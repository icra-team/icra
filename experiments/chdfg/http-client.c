/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is true */

#line 213 "/usr/lib/gcc/x86_64-linux-gnu/4.7/include/stddef.h"
typedef unsigned long size_t;
#line 148 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 181 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __ssize_t;
#line 198 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __socklen_t;
#line 102 "/usr/include/stdio.h"
typedef __ssize_t ssize_t;
#line 75 "/usr/include/time.h"
typedef __time_t time_t;
#line 60 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef unsigned long pthread_t;
#line 63 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
union pthread_attr_t {
   char __size[56] ;
   long __align ;
};
#line 69 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef union pthread_attr_t pthread_attr_t;
#line 75 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
struct __pthread_internal_list {
   struct __pthread_internal_list *__prev ;
   struct __pthread_internal_list *__next ;
};
#line 75 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef struct __pthread_internal_list __pthread_list_t;
#line 90 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
struct __pthread_mutex_s {
   int __lock ;
   unsigned int __count ;
   int __owner ;
   unsigned int __nusers ;
   int __kind ;
   int __spins ;
   __pthread_list_t __list ;
};
#line 90 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
union __anonunion_pthread_mutex_t_14 {
   struct __pthread_mutex_s __data ;
   char __size[40] ;
   long __align ;
};
#line 90 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef union __anonunion_pthread_mutex_t_14 pthread_mutex_t;
#line 120 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
union __anonunion_pthread_mutexattr_t_15 {
   char __size[4] ;
   int __align ;
};
#line 120 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef union __anonunion_pthread_mutexattr_t_15 pthread_mutexattr_t;
#line 33 "/usr/include/x86_64-linux-gnu/bits/socket.h"
typedef __socklen_t socklen_t;
#line 28 "/usr/include/x86_64-linux-gnu/bits/sockaddr.h"
typedef unsigned short sa_family_t;
#line 147 "/usr/include/x86_64-linux-gnu/bits/socket.h"
struct sockaddr {
   sa_family_t sa_family ;
   char sa_data[14] ;
};
#line 49 "/usr/include/stdint.h"
typedef unsigned short uint16_t;
#line 51 "/usr/include/stdint.h"
typedef unsigned int uint32_t;
#line 96 "/usr/include/netinet/in.h"
typedef uint16_t in_port_t;
#line 140 "/usr/include/netinet/in.h"
typedef uint32_t in_addr_t;
#line 141 "/usr/include/netinet/in.h"
struct in_addr {
   in_addr_t s_addr ;
};
#line 224 "/usr/include/netinet/in.h"
struct sockaddr_in {
   sa_family_t sin_family ;
   in_port_t sin_port ;
   struct in_addr sin_addr ;
   unsigned char sin_zero[((sizeof(struct sockaddr ) - sizeof(unsigned short )) - sizeof(in_port_t )) - sizeof(struct in_addr )] ;
};
#line 140 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 141 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 155 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 161 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 246 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 1 "client.o"
#pragma merger("0","/tmp/cil-j6JqYm33.i","")
#line 362 "/usr/include/stdio.h"
extern int printf(char const   * __restrict  __format  , ...) ;
#line 364
extern  __attribute__((__nothrow__)) int sprintf(char * __restrict  __s , char const   * __restrict  __format 
                                                 , ...) ;
#line 147 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) atoi)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 321
extern  __attribute__((__nothrow__)) long ( __attribute__((__leaf__)) random)(void) ;
#line 376
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) srand)(unsigned int __seed ) ;
#line 482
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 114 "/usr/include/x86_64-linux-gnu/sys/socket.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) socket)(int __domain ,
                                                                             int __type ,
                                                                             int __protocol ) ;
#line 138
extern int connect(int __fd , struct sockaddr  const  *__addr , socklen_t __len ) ;
#line 150
extern ssize_t send(int __fd , void const   *__buf , size_t __n , int __flags ) ;
#line 157
extern ssize_t recv(int __fd , void *__buf , size_t __n , int __flags ) ;
#line 262
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) shutdown)(int __fd ,
                                                                               int __how ) ;
#line 62 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1), __leaf__)) memset)(void *__s ,
                                                                                               int __c ,
                                                                                               size_t __n ) ;
#line 395
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 369 "/usr/include/netinet/in.h"
extern  __attribute__((__nothrow__)) uint16_t ( __attribute__((__leaf__)) htons)(uint16_t __hostshort )  __attribute__((__const__)) ;
#line 58 "/usr/include/arpa/inet.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) inet_pton)(int __af ,
                                                                                char const   * __restrict  __cp ,
                                                                                void * __restrict  __buf ) ;
#line 192 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) time_t ( __attribute__((__leaf__)) time)(time_t *__timer ) ;
#line 232 "/usr/include/pthread.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,3))) pthread_create)(pthread_t * __restrict  __newthread ,
                                                                                             pthread_attr_t const   * __restrict  __attr ,
                                                                                             void *(*__start_routine)(void * ) ,
                                                                                             void * __restrict  __arg ) ;
#line 241
extern  __attribute__((__noreturn__)) void pthread_exit(void *__retval ) ;
#line 249
extern int pthread_join(pthread_t __th , void **__thread_return ) ;
#line 740
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) pthread_mutex_init)(pthread_mutex_t *__mutex ,
                                                                                                         pthread_mutexattr_t const   *__mutexattr ) ;
#line 745
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) pthread_mutex_destroy)(pthread_mutex_t *__mutex ) ;
#line 753
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) pthread_mutex_lock)(pthread_mutex_t *__mutex ) ;
#line 764
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) pthread_mutex_unlock)(pthread_mutex_t *__mutex ) ;
#line 7 "helperlib.h"
void print_user_error(char *message , char *detail ) ;
#line 8
void print_system_error(char *message ) ;
#line 23
char *copy_str_dynamic(char *originalStr ) ;
#line 18 "client.c"
struct sockaddr_in serverAddr  ;
#line 19 "client.c"
pthread_mutex_t mutex_print  ;
#line 20 "client.c"
int numFailRecv  =    0;
#line 21 "client.c"
int numFailConn  =    0;
#line 23 "client.c"
char *file_name[7]  = {      (char *)"dummy/complete_hello_fake.html",      (char *)"console.html",      (char *)"debugger.html",      (char *)"fadeIn.html", 
        (char *)"hello.html",      (char *)"complete_hello.html",      (char *)"complete_hello_fake.html"};
#line 24 "client.c"
char DEFAULT_PATH[100]  = 
#line 24
  {      (char )'/',      (char )'R',      (char )'e',      (char )'p', 
        (char )'o',      (char )'s',      (char )'i',      (char )'t', 
        (char )'o',      (char )'r',      (char )'y',      (char )'/', 
        (char )'\000'};
#line 26
void *send_request(void *threadId ) ;
#line 27
char *generate_request(void) ;
#line 29 "client.c"
int main(int argc , char **argv ) 
{ 
  int numThread ;
  int index___0 ;
  int rtnValue ;
  char message[100] ;
  char *serverIP ;
  pthread_t threadArr[10000] ;
  in_port_t serverPort ;
  void *status ;
  int pthread_id[10000] ;
  unsigned int rand_seed ;
  int tmp ;
  time_t tmp___0 ;

  {
#line 39
  if (argc < 3) {
#line 40
    print_user_error((char *)"In-line argument", (char *)"You must specify the server IP address, and the port number");
  }
#line 41
  serverIP = *(argv + 1);
#line 42
  tmp = atoi((char const   *)*(argv + 2));
#line 42
  serverPort = (in_port_t )tmp;
#line 45
  memset((void *)(& serverAddr), 0, sizeof(struct sockaddr_in ));
#line 46
  serverAddr.sin_family = (sa_family_t )2;
#line 47
  rtnValue = inet_pton(2, (char const   * __restrict  )serverIP, (void * __restrict  )(& serverAddr.sin_addr.s_addr));
#line 48
  if (rtnValue == 0) {
#line 49
    print_user_error((char *)"inet_pton() fails", (char *)"Invalid address string");
  } else
#line 51
  if (rtnValue < 0) {
#line 52
    print_system_error((char *)"inet_pton() fails");
  }
#line 53
  serverAddr.sin_port = htons(serverPort);
#line 56
  tmp___0 = time((time_t *)((void *)0));
#line 56
  rand_seed = (unsigned int )tmp___0;
#line 57
  srand(rand_seed);
#line 60
  pthread_mutex_init(& mutex_print, (pthread_mutexattr_t const   *)((void *)0));
#line 62
  if (argc >= 4) {
#line 64
    numThread = atoi((char const   *)*(argv + 3));
#line 65
    if (numThread > 10000) {
#line 66
      numThread = 10000;
    }
  } else {
#line 69
    numThread = 10;
  }
#line 70
  index___0 = 0;
#line 70
  while (index___0 < numThread) {
#line 72
    pthread_id[index___0] = index___0;
#line 73
    rtnValue = pthread_create((pthread_t * __restrict  )(& threadArr[index___0]),
                              (pthread_attr_t const   * __restrict  )((void *)0),
                              & send_request, (void * __restrict  )(& pthread_id[index___0]));
#line 75
    if (rtnValue) {
#line 77
      sprintf((char * __restrict  )(message), (char const   * __restrict  )"pthread_create() fails with error code %d",
              rtnValue);
#line 78
      print_system_error(message);
    }
#line 70
    index___0 ++;
  }
#line 83
  index___0 = 0;
#line 83
  while (index___0 < numThread) {
#line 85
    rtnValue = pthread_join(threadArr[index___0], & status);
#line 83
    index___0 ++;
  }
#line 90
  pthread_mutex_destroy(& mutex_print);
#line 91
  printf((char const   * __restrict  )"Total failed request by recv() = %d\n", numFailRecv);
#line 92
  printf((char const   * __restrict  )"Total failed request by connect() = %d\n",
         numFailConn);
#line 93
  pthread_exit((void *)0);
}
}
#line 163
extern int ( /* missing proto */  close)() ;
#line 96 "client.c"
void *send_request(void *threadId ) 
{ 
  int id ;
  int clientSocket ;
  int lenBuffer ;
  char *request ;
  int curNumRequest ;
  int lenRequest ;
  ssize_t numByte ;
  ssize_t numByteRecv ;
  char buffer[10000] ;
  char *relative_buffer ;
  char end[100] ;
  unsigned int tmp ;
  int flagFailRecv ;
  int tmp___0 ;
  size_t tmp___1 ;

  {
#line 98
  id = *((int *)threadId);
#line 104
  end[0] = (char )'E';
#line 104
  end[1] = (char )'N';
#line 104
  end[2] = (char )'D';
#line 104
  end[3] = (char )'\000';
#line 104
  tmp = 4U;
#line 104
  while (! (tmp >= 100U)) {
#line 104
    end[tmp] = (char)0;
#line 104
    tmp ++;
  }
#line 108
  curNumRequest = 0;
#line 108
  while (curNumRequest < 30) {
#line 110
    clientSocket = socket(2, 1, 6);
#line 111
    if (clientSocket < 0) {
#line 112
      print_system_error((char *)"socket() fails");
    }
#line 115
    tmp___0 = connect(clientSocket, (struct sockaddr  const  *)((struct sockaddr *)(& serverAddr)),
                      (socklen_t )sizeof(serverAddr));
#line 115
    if (tmp___0 < 0) {
#line 120
      pthread_mutex_lock(& mutex_print);
#line 121
      numFailConn ++;
#line 122
      pthread_mutex_unlock(& mutex_print);
#line 123
      goto __Cont;
    }
#line 127
    request = generate_request();
#line 128
    tmp___1 = strlen((char const   *)request);
#line 128
    lenRequest = (int )tmp___1;
#line 130
    numByte = send(clientSocket, (void const   *)request, (size_t )lenRequest, 0);
#line 131
    if (numByte < 0L) {
#line 132
      print_system_error((char *)"send() fails");
    } else
#line 134
    if (numByte != (ssize_t )lenRequest) {
#line 135
      print_user_error((char *)"send()", (char *)"sent unexpected number of bytes");
    }
#line 136
    shutdown(clientSocket, 1);
#line 139
    relative_buffer = buffer;
#line 140
    lenBuffer = 10000;
#line 141
    flagFailRecv = 0;
#line 142
    while (1) {
#line 144
      numByteRecv = recv(clientSocket, (void *)relative_buffer, (size_t )(lenBuffer - 1),
                         0);
#line 145
      if (numByteRecv < 0L) {
#line 147
        flagFailRecv = 1;
#line 148
        break;
      } else
#line 152
      if (numByteRecv > 0L) {
#line 154
        relative_buffer += numByteRecv;
#line 155
        lenBuffer = (int )((ssize_t )lenBuffer - numByteRecv);
      } else {
#line 158
        *(relative_buffer + 0) = (char )'\000';
      }
#line 142
      if (! (numByteRecv > 0L)) {
#line 142
        break;
      }
    }
#line 163
    close(clientSocket);
#line 166
    pthread_mutex_lock(& mutex_print);
#line 168
    if (flagFailRecv) {
#line 169
      numFailRecv ++;
    } else {
#line 172
      printf((char const   * __restrict  )"Client thread with id = %d sends request %d\n",
             id, curNumRequest + 1);
#line 173
      printf((char const   * __restrict  )"Response from the server:\n");
#line 173
      printf((char const   * __restrict  )"%s", buffer);
    }
#line 176
    pthread_mutex_unlock(& mutex_print);
#line 177
    free((void *)request);
    __Cont: /* CIL Label */ 
#line 108
    curNumRequest ++;
  }
#line 180
  pthread_exit((void *)0);
}
}
#line 183 "client.c"
char *generate_request(void) 
{ 
  char buffer[1000] ;
  int rand_index ;
  long tmp ;
  char *tmp___0 ;

  {
#line 186
  tmp = random();
#line 186
  rand_index = (int )(tmp % 7L);
#line 188
  sprintf((char * __restrict  )(buffer), (char const   * __restrict  )"GET %s%s HTTP/1.1",
          DEFAULT_PATH, file_name[rand_index]);
#line 190
  tmp___0 = copy_str_dynamic(buffer);
#line 190
  return (tmp___0);
}
}
#line 1 "helperlib.o"
#pragma merger("0","/tmp/cil-aohltGiy.i","")
#line 170 "/usr/include/stdio.h"
extern struct _IO_FILE *stderr ;
#line 237
extern int fclose(FILE *__stream ) ;
#line 272
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
#line 356
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 695
extern int puts(char const   *__s ) ;
#line 709
extern size_t fread(void * __restrict  __ptr , size_t __size , size_t __n , FILE * __restrict  __stream ) ;
#line 749
extern int fseek(FILE *__stream , long __off , int __whence ) ;
#line 754
extern long ftell(FILE *__stream ) ;
#line 759
extern void rewind(FILE *__stream ) ;
#line 846
extern void perror(char const   *__s ) ;
#line 465 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 542
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 125 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcpy)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 532
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcasecmp)(char const   *__s1 ,
                                                                                                   char const   *__s2 )  __attribute__((__pure__)) ;
#line 11 "helperlib.h"
int find_str_index(char **strArr , int numStr , char *str ) ;
#line 17
int count_occurence(char *str , char character ) ;
#line 26
char *read_whole_file(char *relative_path , int *error_code ) ;
#line 29
char *generate_html_error_page(char *header , char *error_message ) ;
#line 4 "helperlib.c"
void print_system_error(char *message ) 
{ 


  {
#line 6
  perror((char const   *)message);
#line 7
  exit(1);
}
}
#line 10 "helperlib.c"
void print_user_error(char *message , char *detail ) 
{ 


  {
#line 12
  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s: %s\n", message,
          detail);
#line 13
  exit(1);
}
}
#line 17 "helperlib.c"
int find_str_index(char **strArr , int numStr , char *str ) 
{ 
  int index___0 ;
  int tmp ;

  {
#line 21
  index___0 = 0;
#line 21
  while (index___0 < numStr) {
#line 23
    tmp = strcasecmp((char const   *)*(strArr + index___0), (char const   *)str);
#line 23
    if (tmp == 0) {
#line 24
      return (index___0);
    }
#line 21
    index___0 ++;
  }
#line 27
  return (-1);
}
}
#line 31 "helperlib.c"
int find_occurrence_index(char *str , char character , int occurence ) 
{ 
  int index___0 ;
  int curr_occur ;

  {
#line 35
  index___0 = 0;
#line 35
  curr_occur = 0;
#line 35
  while ((int )*(str + index___0) != 0) {
#line 36
    if ((int )*(str + index___0) == (int )character) {
#line 38
      curr_occur ++;
#line 39
      if (curr_occur == occurence) {
#line 40
        return (index___0);
      }
    }
#line 35
    index___0 ++;
  }
#line 43
  return (-1);
}
}
#line 53 "helperlib.c"
char *copy_str_dynamic(char *originalStr ) 
{ 
  char *newStrPointer ;
  size_t tmp ;
  void *tmp___0 ;

  {
#line 55
  if ((unsigned long )originalStr == (unsigned long )((void *)0)) {
#line 56
    return ((char *)((void *)0));
  }
#line 59
  tmp = strlen((char const   *)originalStr);
#line 59
  tmp___0 = malloc((tmp + 1UL) * sizeof(char ));
#line 59
  newStrPointer = (char *)tmp___0;
#line 61
  if ((unsigned long )newStrPointer == (unsigned long )((void *)0)) {
#line 63
    printf((char const   * __restrict  )"error with malloc\n");
#line 64
    return ((char *)((void *)0));
  }
#line 67
  strcpy((char * __restrict  )newStrPointer, (char const   * __restrict  )originalStr);
#line 69
  return (newStrPointer);
}
}
#line 78 "helperlib.c"
int count_occurence(char *str , char character ) 
{ 
  int num ;
  int index___0 ;

  {
#line 80
  num = 0;
#line 82
  if ((unsigned long )str != (unsigned long )((void *)0)) {
#line 84
    index___0 = 0;
#line 84
    while ((int )*(str + index___0) != 0) {
#line 85
      if ((int )*(str + index___0) == (int )character) {
#line 86
        num ++;
      }
#line 84
      index___0 ++;
    }
  }
#line 89
  return (num);
}
}
#line 102 "helperlib.c"
char *read_whole_file(char *relative_path , int *error_code ) 
{ 
  char *buffer ;
  int numByte ;
  FILE *fin ;
  FILE *tmp ;
  long tmp___0 ;
  void *tmp___1 ;
  size_t tmp___2 ;

  {
#line 107
  printf((char const   * __restrict  )"Go to function read_whole_file\n");
#line 109
  tmp = fopen((char const   * __restrict  )relative_path, (char const   * __restrict  )"rb");
#line 109
  fin = tmp;
#line 110
  if ((unsigned long )fin == (unsigned long )((void *)0)) {
#line 112
    *error_code = 1;
#line 113
    return ((char *)((void *)0));
  }
#line 115
  printf((char const   * __restrict  )"Valid path OK\n");
#line 117
  fseek(fin, 0L, 2);
#line 119
  tmp___0 = ftell(fin);
#line 119
  numByte = (int )tmp___0;
#line 121
  rewind(fin);
#line 122
  printf((char const   * __restrict  )"Determine size = %d: OK\n", numByte);
#line 124
  tmp___1 = malloc((unsigned long )(numByte + 1) * sizeof(char ));
#line 124
  buffer = (char *)tmp___1;
#line 125
  if ((unsigned long )buffer == (unsigned long )((void *)0)) {
#line 127
    *error_code = 2;
#line 128
    return ((char *)((void *)0));
  }
#line 131
  fread((void * __restrict  )buffer, (size_t )numByte, (size_t )1, (FILE * __restrict  )fin);
#line 132
  *(buffer + numByte) = (char )'\000';
#line 133
  tmp___2 = strlen((char const   *)buffer);
#line 133
  printf((char const   * __restrict  )"Length buffer = %d vs Byte = %d\n", tmp___2,
         numByte);
#line 134
  printf((char const   * __restrict  )"Read OK\n");
#line 135
  fclose(fin);
#line 136
  printf((char const   * __restrict  )"Close file OK\n");
#line 138
  *error_code = 0;
#line 139
  printf((char const   * __restrict  )"Totally OK?\n");
#line 140
  puts((char const   *)buffer);
#line 141
  return (buffer);
}
}
#line 144 "helperlib.c"
char *generate_html_error_page(char *header , char *error_message ) 
{ 
  char buffer[2001] ;
  char *tmp ;

  {
#line 148
  sprintf((char * __restrict  )(buffer), (char const   * __restrict  )"<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Transitional//EN\" \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\">\n<html xmlns=\"http://www.w3.org/1999/xhtml\">\n<head>\n<meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\" />\n<title>%s</title>\n</head>\n<body><h1>%s</h1><p>%s</p></body></html>",
          header, header, error_message);
#line 150
  tmp = copy_str_dynamic(buffer);
#line 150
  return (tmp);
}
}
