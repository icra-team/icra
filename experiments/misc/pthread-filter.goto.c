// c::tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]
// 
struct anon$3;

// c::tag-#anon#UN[SYM#c::tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR0000000000000000000000000000000000000000000000000000000000110000{S8}'__size'||S64'__align'|]
// 
union anon$4;

// c::tag-#anon#UN[SYM#c::tag-__pthread_mutex_s#'__data'||ARR0000000000000000000000000000000000000000000000000000000000101000{S8}'__size'||S64'__align'|]
// 
union anon$2;

// c::tag-#anon#UN[SYM#c::tag-__pthread_mutex_s#'__data'||ARR0000000000000000000000000000000000000000000000000000000000101000{S8}'__size'||S64'__align'|]$link3
// 
union anon$0$link3;

// c::tag-#anon#UN[SYM#c::tag-__pthread_mutex_s#'__data'||ARR0000000000000000000000000000000000000000000000000000000000101000{S8}'__size'||S64'__align'|]$link4
// 
union anon$1$link4;

// c::tag-_IO_FILE
// file /usr/include/libio.h line 246
struct _IO_FILE;

// c::tag-_IO_FILE$link1
// file /usr/include/libio.h line 246
struct _IO_FILE$link1;

// c::tag-_IO_FILE$link2
// file /usr/include/libio.h line 246
struct _IO_FILE$link2;

// c::tag-_IO_FILE$link3
// file /usr/include/libio.h line 246
struct _IO_FILE$link3;

// c::tag-_IO_FILE$link4
// file /usr/include/libio.h line 246
struct _IO_FILE$link4;

// c::tag-_IO_FILE$link5
// file /usr/include/libio.h line 246
struct _IO_FILE$link5;

// c::tag-_IO_FILE$link6
// file /usr/include/libio.h line 246
struct _IO_FILE$link6;

// c::tag-_IO_FILE$link7
// file /usr/include/libio.h line 246
struct _IO_FILE$link7;

// c::tag-_IO_FILE$link8
// file /usr/include/libio.h line 246
struct _IO_FILE$link8;

// c::tag-_IO_marker
// file /usr/include/libio.h line 161
struct _IO_marker;

// c::tag-_IO_marker$link0
// file /usr/include/libio.h line 161
struct _IO_marker$link0;

// c::tag-_IO_marker$link1
// file /usr/include/libio.h line 161
struct _IO_marker$link1;

// c::tag-_IO_marker$link2
// file /usr/include/libio.h line 161
struct _IO_marker$link2;

// c::tag-_IO_marker$link3
// file /usr/include/libio.h line 161
struct _IO_marker$link3;

// c::tag-_IO_marker$link4
// file /usr/include/libio.h line 161
struct _IO_marker$link4;

// c::tag-_IO_marker$link5
// file /usr/include/libio.h line 161
struct _IO_marker$link5;

// c::tag-_IO_marker$link6
// file /usr/include/libio.h line 161
struct _IO_marker$link6;

// c::tag-_IO_marker$link7
// file /usr/include/libio.h line 161
struct _IO_marker$link7;

// c::tag-__anonstruct___data_13
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 129
struct __anonstruct___data_13;

// c::tag-__anonunion_pthread_cond_t_12
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 129
union __anonunion_pthread_cond_t_12;

// c::tag-__anonunion_pthread_mutex_t_10
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 90
union __anonunion_pthread_mutex_t_10;

// c::tag-__pthread_internal_list
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 75
struct __pthread_internal_list;

// c::tag-__pthread_internal_list$link0
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 75
struct __pthread_internal_list$link0;

// c::tag-__pthread_internal_list$link1
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 75
struct __pthread_internal_list$link1;

// c::tag-__pthread_internal_list$link2
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 75
struct __pthread_internal_list$link2;

// c::tag-__pthread_mutex_s
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 90
struct __pthread_mutex_s;

// c::tag-__pthread_mutex_s$link1
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 92
struct __pthread_mutex_s$link1;

// c::tag-__pthread_mutex_s$link2
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 92
struct __pthread_mutex_s$link2;

// c::tag-__pthread_mutex_s$link3
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 92
struct __pthread_mutex_s$link3;

// c::tag-_blurfilterdata
// file blurfilter.h line 16
struct _blurfilterdata;

// c::tag-_imagepart
// file imagepart.h line 11
struct _imagepart;

// c::tag-_imagethread
// file imagethread.h line 7
struct _imagethread;

// c::tag-_pixel
// file pixel.h line 5
struct _pixel;

// c::tag-_thresfilterdata
// file thresfilter.h line 12
struct _thresfilterdata;

// c::tag-_thresfilterdata$link10
// file thresfilter.h line 12
struct _thresfilterdata$link10;

// c::tag-_thresfilterdata$link9
// file thresfilter.h line 12
struct _thresfilterdata$link9;

// c::tag-pthread_attr_t
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 63
union pthread_attr_t;

// c::tag-timespec
// file /usr/include/time.h line 120
struct timespec;


#ifndef TRUE
#define TRUE (_Bool)1
#endif
#ifndef FALSE
#define FALSE (_Bool)0
#endif
#ifndef NULL
#define NULL ((void*)0)
#endif
#ifndef FENCE
#define FENCE(x) ((void)0)
#endif
#ifndef IEEE_FLOAT_EQUAL
#define IEEE_FLOAT_EQUAL(x,y) (x==y)
#endif
#ifndef IEEE_FLOAT_NOTEQUAL
#define IEEE_FLOAT_NOTEQUAL(x,y) (x!=y)
#endif

// c::SynchronizationPoint
// file imagethread.c line 35
void SynchronizationPoint(void);
// c::_IO_getc
// file /usr/include/libio.h line 435
signed int _IO_getc(struct _IO_FILE *);
// c::allocate_image
// file pixel.c line 26
struct _pixel * allocate_image(signed int size);
// c::atoi
// file /usr/include/stdlib.h line 147
signed int atoi(const char *);
// c::blurfilter
// file blurfilter.c line 22
void blurfilter(const signed int xsize, const signed int ysize, struct _pixel *src, struct _pixel *dst, const signed int radius, const double *w, struct _imagethread *imageThreads, signed int rank);
// c::blurfilterwrapper
// file blurfilter.c line 16
void * blurfilterwrapper(void *arg);
// c::blurmain
// file blurmain.c line 12
signed int blurmain(signed int argc, char **argv);
// c::clock_gettime
// file /usr/include/time.h line 342
signed int clock_gettime(signed int, struct timespec *);
// c::createThread
// file imagethread.c line 11
unsigned long int * createThread(void *function, void *argument);
// c::createThreadData
// file imagethread.c line 18
struct _imagethread * createThreadData(signed int count);
// c::divide
// file imagepart.c line 8
void divide(struct _imagethread *threadData, signed int count, struct _pixel *sourceImage, struct _pixel *destinationImage, const signed int xsize, const signed int ysize);
// c::exit
// file /usr/include/stdlib.h line 542
void exit(signed int);
// c::exp
// file /usr/include/x86_64-linux-gnu/bits/mathcalls.h line 100
double exp(double);
// c::fclose
// file /usr/include/stdio.h line 237
signed int fclose(struct _IO_FILE *);
// c::fgets
// file /usr/include/stdio.h line 622
char * fgets(char *, signed int, struct _IO_FILE *);
// c::fopen
// file /usr/include/stdio.h line 272
struct _IO_FILE * fopen(const char *, const char *);
// c::fprintf
// file /usr/include/stdio.h line 356
signed int fprintf(struct _IO_FILE *, const char *, ...);
// c::fread
// file /usr/include/stdio.h line 709
unsigned long int fread(void *, unsigned long int, unsigned long int, struct _IO_FILE *);
// c::fscanf
// file /usr/include/stdio.h line 425
signed int fscanf(struct _IO_FILE *, const char *, ...);
// c::fwrite
// file /usr/include/stdio.h line 715
unsigned long int fwrite(const void *, unsigned long int, unsigned long int, struct _IO_FILE *);
// c::get_gauss_weights
// file gaussw.c line 18
void get_gauss_weights(signed int n, double *weights_out);
// c::getchar
// file /usr/include/stdio.h line 538
signed int getchar(void);
// c::malloc
// file /usr/include/stdlib.h line 465
void * malloc(unsigned long int);
// c::perror
// file /usr/include/stdio.h line 846
void perror(const char *);
// c::pix
// file pixel.c line 6
struct _pixel * pix(struct _pixel *image, const signed int xx, const signed int yy, const signed int xsize);
// c::pix_trans
// file pixel.c line 16
struct _pixel * pix_trans(struct _pixel *image, const signed int xx, const signed int yy, const signed int ysize);
// c::ppm_error
// file ppm.c line 4
void ppm_error(char *str);
// c::ppm_readchar
// file ppm.c line 12
char ppm_readchar(struct _IO_FILE *file);
// c::ppm_readint
// file ppm.c line 42
signed int ppm_readint(struct _IO_FILE *file);
// c::ppm_readmagicnumber
// file ppm.c line 28
signed int ppm_readmagicnumber(struct _IO_FILE *file);
// c::printf
// file /usr/include/stdio.h line 362
signed int printf(const char *, ...);
// c::pthread_cond_broadcast
// file /usr/include/pthread.h line 972
signed int pthread_cond_broadcast(union __anonunion_pthread_cond_t_12 *);
// c::pthread_cond_wait
// file /usr/include/pthread.h line 980
signed int pthread_cond_wait(union __anonunion_pthread_cond_t_12 *, union __anonunion_pthread_mutex_t_10 *);
// c::pthread_create
// file /usr/include/pthread.h line 232
signed int pthread_create(unsigned long int *, const union pthread_attr_t *, void * (*)(void *), void *);
// c::pthread_mutex_lock
// file /usr/include/pthread.h line 753
signed int pthread_mutex_lock(union __anonunion_pthread_mutex_t_10 *);
// c::pthread_mutex_unlock
// file /usr/include/pthread.h line 764
signed int pthread_mutex_unlock(union __anonunion_pthread_mutex_t_10 *);
// c::read_ppm
// file ppmio.c line 12
signed int read_ppm(const char *fname, signed int *xpix, signed int *ypix, signed int *max, char *data);
// c::setThreadSyncCount
// file imagethread.c line 31
void setThreadSyncCount(signed int count);
// c::sscanf
// file /usr/include/stdio.h line 433
signed int sscanf(const char *, const char *, ...);
// c::strdup
// file /usr/include/string.h line 172
char * strdup(const char *);
// c::strerror
// file /usr/include/string.h line 409
char * strerror(signed int);
// c::strncmp
// file /usr/include/string.h line 143
signed int strncmp(const char *, const char *, unsigned long int);
// c::thresfilter
// file thresfilter.c line 11
void thresfilter(const signed int xsize, const signed int ysize, struct _pixel *src, unsigned int *thresholdsum, union __anonunion_pthread_mutex_t_10 *thresholdsum_mutex, struct _imagethread *imageThreads, signed int rank);
// c::thresfilterwrapper
// file thresfilter.c line 5
void * thresfilterwrapper(void *arg);
// c::thresmain
// file thresmain.c line 11
signed int thresmain(signed int argc, char **argv);
// c::write_ppm
// file ppmio.c line 71
signed int write_ppm(const char *fname, signed int xpix, signed int ypix, char *data);

struct anon$3
{
  // __lock
  signed int __lock;
  // __futex
  unsigned int __futex;
  // __total_seq
  unsigned long long int __total_seq;
  // __wakeup_seq
  unsigned long long int __wakeup_seq;
  // __woken_seq
  unsigned long long int __woken_seq;
  // __mutex
  void *__mutex;
  // __nwaiters
  unsigned int __nwaiters;
  // __broadcast_seq
  unsigned int __broadcast_seq;
};

union anon$4
{
  // __data
  struct anon$3 __data;
  // __size
  char __size[48l];
  // __align
  signed long long int __align;
};

struct __pthread_internal_list$link0
{
  // __prev
  struct __pthread_internal_list$link0 *__prev;
  // __next
  struct __pthread_internal_list$link0 *__next;
};

struct __pthread_mutex_s$link1
{
  // __lock
  signed int __lock;
  // __count
  unsigned int __count;
  // __owner
  signed int __owner;
  // __nusers
  unsigned int __nusers;
  // __kind
  signed int __kind;
  // __spins
  signed int __spins;
  // __list
  struct __pthread_internal_list$link0 __list;
};

union anon$2
{
  // __data
  struct __pthread_mutex_s$link1 __data;
  // __size
  char __size[40l];
  // __align
  signed long int __align;
};

struct __pthread_internal_list$link1
{
  // __prev
  struct __pthread_internal_list$link1 *__prev;
  // __next
  struct __pthread_internal_list$link1 *__next;
};

struct __pthread_mutex_s$link2
{
  // __lock
  signed int __lock;
  // __count
  unsigned int __count;
  // __owner
  signed int __owner;
  // __nusers
  unsigned int __nusers;
  // __kind
  signed int __kind;
  // __spins
  signed int __spins;
  // __list
  struct __pthread_internal_list$link1 __list;
};

union anon$0$link3
{
  // __data
  struct __pthread_mutex_s$link2 __data;
  // __size
  char __size[40l];
  // __align
  signed long int __align;
};

struct __pthread_internal_list$link2
{
  // __prev
  struct __pthread_internal_list$link2 *__prev;
  // __next
  struct __pthread_internal_list$link2 *__next;
};

struct __pthread_mutex_s$link3
{
  // __lock
  signed int __lock;
  // __count
  unsigned int __count;
  // __owner
  signed int __owner;
  // __nusers
  unsigned int __nusers;
  // __kind
  signed int __kind;
  // __spins
  signed int __spins;
  // __list
  struct __pthread_internal_list$link2 __list;
};

union anon$1$link4
{
  // __data
  struct __pthread_mutex_s$link3 __data;
  // __size
  char __size[40l];
  // __align
  signed long int __align;
};

struct _IO_FILE
{
  // _flags
  signed int _flags;
  // _IO_read_ptr
  char *_IO_read_ptr;
  // _IO_read_end
  char *_IO_read_end;
  // _IO_read_base
  char *_IO_read_base;
  // _IO_write_base
  char *_IO_write_base;
  // _IO_write_ptr
  char *_IO_write_ptr;
  // _IO_write_end
  char *_IO_write_end;
  // _IO_buf_base
  char *_IO_buf_base;
  // _IO_buf_end
  char *_IO_buf_end;
  // _IO_save_base
  char *_IO_save_base;
  // _IO_backup_base
  char *_IO_backup_base;
  // _IO_save_end
  char *_IO_save_end;
  // _markers
  struct _IO_marker *_markers;
  // _chain
  struct _IO_FILE *_chain;
  // _fileno
  signed int _fileno;
  // _flags2
  signed int _flags2;
  // _old_offset
  signed long int _old_offset;
  // _cur_column
  unsigned short int _cur_column;
  // _vtable_offset
  signed char _vtable_offset;
  // _shortbuf
  char _shortbuf[1l];
  // _lock
  void *_lock;
  // _offset
  signed long int _offset;
  // __pad1
  void *__pad1;
  // __pad2
  void *__pad2;
  // __pad3
  void *__pad3;
  // __pad4
  void *__pad4;
  // __pad5
  unsigned long int __pad5;
  // _mode
  signed int _mode;
  // _unused2
  char _unused2[20l /*[[signed int]]*/];
};

struct _IO_FILE$link1
{
  // _flags
  signed int _flags;
  // _IO_read_ptr
  char *_IO_read_ptr;
  // _IO_read_end
  char *_IO_read_end;
  // _IO_read_base
  char *_IO_read_base;
  // _IO_write_base
  char *_IO_write_base;
  // _IO_write_ptr
  char *_IO_write_ptr;
  // _IO_write_end
  char *_IO_write_end;
  // _IO_buf_base
  char *_IO_buf_base;
  // _IO_buf_end
  char *_IO_buf_end;
  // _IO_save_base
  char *_IO_save_base;
  // _IO_backup_base
  char *_IO_backup_base;
  // _IO_save_end
  char *_IO_save_end;
  // _markers
  struct _IO_marker$link0 *_markers;
  // _chain
  struct _IO_FILE$link1 *_chain;
  // _fileno
  signed int _fileno;
  // _flags2
  signed int _flags2;
  // _old_offset
  signed long int _old_offset;
  // _cur_column
  unsigned short int _cur_column;
  // _vtable_offset
  signed char _vtable_offset;
  // _shortbuf
  char _shortbuf[1l];
  // _lock
  void *_lock;
  // _offset
  signed long int _offset;
  // __pad1
  void *__pad1;
  // __pad2
  void *__pad2;
  // __pad3
  void *__pad3;
  // __pad4
  void *__pad4;
  // __pad5
  unsigned long int __pad5;
  // _mode
  signed int _mode;
  // _unused2
  char _unused2[20l /*[[signed int]]*/];
};

struct _IO_FILE$link2
{
  // _flags
  signed int _flags;
  // _IO_read_ptr
  char *_IO_read_ptr;
  // _IO_read_end
  char *_IO_read_end;
  // _IO_read_base
  char *_IO_read_base;
  // _IO_write_base
  char *_IO_write_base;
  // _IO_write_ptr
  char *_IO_write_ptr;
  // _IO_write_end
  char *_IO_write_end;
  // _IO_buf_base
  char *_IO_buf_base;
  // _IO_buf_end
  char *_IO_buf_end;
  // _IO_save_base
  char *_IO_save_base;
  // _IO_backup_base
  char *_IO_backup_base;
  // _IO_save_end
  char *_IO_save_end;
  // _markers
  struct _IO_marker$link1 *_markers;
  // _chain
  struct _IO_FILE$link2 *_chain;
  // _fileno
  signed int _fileno;
  // _flags2
  signed int _flags2;
  // _old_offset
  signed long int _old_offset;
  // _cur_column
  unsigned short int _cur_column;
  // _vtable_offset
  signed char _vtable_offset;
  // _shortbuf
  char _shortbuf[1l];
  // _lock
  void *_lock;
  // _offset
  signed long int _offset;
  // __pad1
  void *__pad1;
  // __pad2
  void *__pad2;
  // __pad3
  void *__pad3;
  // __pad4
  void *__pad4;
  // __pad5
  unsigned long int __pad5;
  // _mode
  signed int _mode;
  // _unused2
  char _unused2[20l /*[[signed int]]*/];
};

struct _IO_FILE$link3
{
  // _flags
  signed int _flags;
  // _IO_read_ptr
  char *_IO_read_ptr;
  // _IO_read_end
  char *_IO_read_end;
  // _IO_read_base
  char *_IO_read_base;
  // _IO_write_base
  char *_IO_write_base;
  // _IO_write_ptr
  char *_IO_write_ptr;
  // _IO_write_end
  char *_IO_write_end;
  // _IO_buf_base
  char *_IO_buf_base;
  // _IO_buf_end
  char *_IO_buf_end;
  // _IO_save_base
  char *_IO_save_base;
  // _IO_backup_base
  char *_IO_backup_base;
  // _IO_save_end
  char *_IO_save_end;
  // _markers
  struct _IO_marker$link2 *_markers;
  // _chain
  struct _IO_FILE$link3 *_chain;
  // _fileno
  signed int _fileno;
  // _flags2
  signed int _flags2;
  // _old_offset
  signed long int _old_offset;
  // _cur_column
  unsigned short int _cur_column;
  // _vtable_offset
  signed char _vtable_offset;
  // _shortbuf
  char _shortbuf[1l];
  // _lock
  void *_lock;
  // _offset
  signed long int _offset;
  // __pad1
  void *__pad1;
  // __pad2
  void *__pad2;
  // __pad3
  void *__pad3;
  // __pad4
  void *__pad4;
  // __pad5
  unsigned long int __pad5;
  // _mode
  signed int _mode;
  // _unused2
  char _unused2[20l /*[[signed int]]*/];
};

struct _IO_FILE$link4
{
  // _flags
  signed int _flags;
  // _IO_read_ptr
  char *_IO_read_ptr;
  // _IO_read_end
  char *_IO_read_end;
  // _IO_read_base
  char *_IO_read_base;
  // _IO_write_base
  char *_IO_write_base;
  // _IO_write_ptr
  char *_IO_write_ptr;
  // _IO_write_end
  char *_IO_write_end;
  // _IO_buf_base
  char *_IO_buf_base;
  // _IO_buf_end
  char *_IO_buf_end;
  // _IO_save_base
  char *_IO_save_base;
  // _IO_backup_base
  char *_IO_backup_base;
  // _IO_save_end
  char *_IO_save_end;
  // _markers
  struct _IO_marker$link3 *_markers;
  // _chain
  struct _IO_FILE$link4 *_chain;
  // _fileno
  signed int _fileno;
  // _flags2
  signed int _flags2;
  // _old_offset
  signed long int _old_offset;
  // _cur_column
  unsigned short int _cur_column;
  // _vtable_offset
  signed char _vtable_offset;
  // _shortbuf
  char _shortbuf[1l];
  // _lock
  void *_lock;
  // _offset
  signed long int _offset;
  // __pad1
  void *__pad1;
  // __pad2
  void *__pad2;
  // __pad3
  void *__pad3;
  // __pad4
  void *__pad4;
  // __pad5
  unsigned long int __pad5;
  // _mode
  signed int _mode;
  // _unused2
  char _unused2[20l /*[[signed int]]*/];
};

struct _IO_FILE$link5
{
  // _flags
  signed int _flags;
  // _IO_read_ptr
  char *_IO_read_ptr;
  // _IO_read_end
  char *_IO_read_end;
  // _IO_read_base
  char *_IO_read_base;
  // _IO_write_base
  char *_IO_write_base;
  // _IO_write_ptr
  char *_IO_write_ptr;
  // _IO_write_end
  char *_IO_write_end;
  // _IO_buf_base
  char *_IO_buf_base;
  // _IO_buf_end
  char *_IO_buf_end;
  // _IO_save_base
  char *_IO_save_base;
  // _IO_backup_base
  char *_IO_backup_base;
  // _IO_save_end
  char *_IO_save_end;
  // _markers
  struct _IO_marker$link4 *_markers;
  // _chain
  struct _IO_FILE$link5 *_chain;
  // _fileno
  signed int _fileno;
  // _flags2
  signed int _flags2;
  // _old_offset
  signed long int _old_offset;
  // _cur_column
  unsigned short int _cur_column;
  // _vtable_offset
  signed char _vtable_offset;
  // _shortbuf
  char _shortbuf[1l];
  // _lock
  void *_lock;
  // _offset
  signed long int _offset;
  // __pad1
  void *__pad1;
  // __pad2
  void *__pad2;
  // __pad3
  void *__pad3;
  // __pad4
  void *__pad4;
  // __pad5
  unsigned long int __pad5;
  // _mode
  signed int _mode;
  // _unused2
  char _unused2[20l /*[[signed int]]*/];
};

struct _IO_FILE$link6
{
  // _flags
  signed int _flags;
  // _IO_read_ptr
  char *_IO_read_ptr;
  // _IO_read_end
  char *_IO_read_end;
  // _IO_read_base
  char *_IO_read_base;
  // _IO_write_base
  char *_IO_write_base;
  // _IO_write_ptr
  char *_IO_write_ptr;
  // _IO_write_end
  char *_IO_write_end;
  // _IO_buf_base
  char *_IO_buf_base;
  // _IO_buf_end
  char *_IO_buf_end;
  // _IO_save_base
  char *_IO_save_base;
  // _IO_backup_base
  char *_IO_backup_base;
  // _IO_save_end
  char *_IO_save_end;
  // _markers
  struct _IO_marker$link5 *_markers;
  // _chain
  struct _IO_FILE$link6 *_chain;
  // _fileno
  signed int _fileno;
  // _flags2
  signed int _flags2;
  // _old_offset
  signed long int _old_offset;
  // _cur_column
  unsigned short int _cur_column;
  // _vtable_offset
  signed char _vtable_offset;
  // _shortbuf
  char _shortbuf[1l];
  // _lock
  void *_lock;
  // _offset
  signed long int _offset;
  // __pad1
  void *__pad1;
  // __pad2
  void *__pad2;
  // __pad3
  void *__pad3;
  // __pad4
  void *__pad4;
  // __pad5
  unsigned long int __pad5;
  // _mode
  signed int _mode;
  // _unused2
  char _unused2[20l /*[[signed int]]*/];
};

struct _IO_FILE$link7
{
  // _flags
  signed int _flags;
  // _IO_read_ptr
  char *_IO_read_ptr;
  // _IO_read_end
  char *_IO_read_end;
  // _IO_read_base
  char *_IO_read_base;
  // _IO_write_base
  char *_IO_write_base;
  // _IO_write_ptr
  char *_IO_write_ptr;
  // _IO_write_end
  char *_IO_write_end;
  // _IO_buf_base
  char *_IO_buf_base;
  // _IO_buf_end
  char *_IO_buf_end;
  // _IO_save_base
  char *_IO_save_base;
  // _IO_backup_base
  char *_IO_backup_base;
  // _IO_save_end
  char *_IO_save_end;
  // _markers
  struct _IO_marker$link6 *_markers;
  // _chain
  struct _IO_FILE$link7 *_chain;
  // _fileno
  signed int _fileno;
  // _flags2
  signed int _flags2;
  // _old_offset
  signed long int _old_offset;
  // _cur_column
  unsigned short int _cur_column;
  // _vtable_offset
  signed char _vtable_offset;
  // _shortbuf
  char _shortbuf[1l];
  // _lock
  void *_lock;
  // _offset
  signed long int _offset;
  // __pad1
  void *__pad1;
  // __pad2
  void *__pad2;
  // __pad3
  void *__pad3;
  // __pad4
  void *__pad4;
  // __pad5
  unsigned long int __pad5;
  // _mode
  signed int _mode;
  // _unused2
  char _unused2[20l /*[[signed int]]*/];
};

struct _IO_FILE$link8
{
  // _flags
  signed int _flags;
  // _IO_read_ptr
  char *_IO_read_ptr;
  // _IO_read_end
  char *_IO_read_end;
  // _IO_read_base
  char *_IO_read_base;
  // _IO_write_base
  char *_IO_write_base;
  // _IO_write_ptr
  char *_IO_write_ptr;
  // _IO_write_end
  char *_IO_write_end;
  // _IO_buf_base
  char *_IO_buf_base;
  // _IO_buf_end
  char *_IO_buf_end;
  // _IO_save_base
  char *_IO_save_base;
  // _IO_backup_base
  char *_IO_backup_base;
  // _IO_save_end
  char *_IO_save_end;
  // _markers
  struct _IO_marker$link7 *_markers;
  // _chain
  struct _IO_FILE$link8 *_chain;
  // _fileno
  signed int _fileno;
  // _flags2
  signed int _flags2;
  // _old_offset
  signed long int _old_offset;
  // _cur_column
  unsigned short int _cur_column;
  // _vtable_offset
  signed char _vtable_offset;
  // _shortbuf
  char _shortbuf[1l];
  // _lock
  void *_lock;
  // _offset
  signed long int _offset;
  // __pad1
  void *__pad1;
  // __pad2
  void *__pad2;
  // __pad3
  void *__pad3;
  // __pad4
  void *__pad4;
  // __pad5
  unsigned long int __pad5;
  // _mode
  signed int _mode;
  // _unused2
  char _unused2[20l /*[[signed int]]*/];
};

struct _IO_marker
{
  // _next
  struct _IO_marker *_next;
  // _sbuf
  struct _IO_FILE *_sbuf;
  // _pos
  signed int _pos;
};

struct _IO_marker$link0
{
  // _next
  struct _IO_marker$link0 *_next;
  // _sbuf
  struct _IO_FILE$link1 *_sbuf;
  // _pos
  signed int _pos;
};

struct _IO_marker$link1
{
  // _next
  struct _IO_marker$link1 *_next;
  // _sbuf
  struct _IO_FILE$link2 *_sbuf;
  // _pos
  signed int _pos;
};

struct _IO_marker$link2
{
  // _next
  struct _IO_marker$link2 *_next;
  // _sbuf
  struct _IO_FILE$link3 *_sbuf;
  // _pos
  signed int _pos;
};

struct _IO_marker$link3
{
  // _next
  struct _IO_marker$link3 *_next;
  // _sbuf
  struct _IO_FILE$link4 *_sbuf;
  // _pos
  signed int _pos;
};

struct _IO_marker$link4
{
  // _next
  struct _IO_marker$link4 *_next;
  // _sbuf
  struct _IO_FILE$link5 *_sbuf;
  // _pos
  signed int _pos;
};

struct _IO_marker$link5
{
  // _next
  struct _IO_marker$link5 *_next;
  // _sbuf
  struct _IO_FILE$link6 *_sbuf;
  // _pos
  signed int _pos;
};

struct _IO_marker$link6
{
  // _next
  struct _IO_marker$link6 *_next;
  // _sbuf
  struct _IO_FILE$link7 *_sbuf;
  // _pos
  signed int _pos;
};

struct _IO_marker$link7
{
  // _next
  struct _IO_marker$link7 *_next;
  // _sbuf
  struct _IO_FILE$link8 *_sbuf;
  // _pos
  signed int _pos;
};

struct __anonstruct___data_13
{
  // __lock
  signed int __lock;
  // __futex
  unsigned int __futex;
  // __total_seq
  unsigned long long int __total_seq;
  // __wakeup_seq
  unsigned long long int __wakeup_seq;
  // __woken_seq
  unsigned long long int __woken_seq;
  // __mutex
  void *__mutex;
  // __nwaiters
  unsigned int __nwaiters;
  // __broadcast_seq
  unsigned int __broadcast_seq;
};

union __anonunion_pthread_cond_t_12
{
  // __data
  struct __anonstruct___data_13 __data;
  // __size
  char __size[48l];
  // __align
  signed long long int __align;
};

struct __pthread_internal_list
{
  // __prev
  struct __pthread_internal_list *__prev;
  // __next
  struct __pthread_internal_list *__next;
};

struct __pthread_mutex_s
{
  // __lock
  signed int __lock;
  // __count
  unsigned int __count;
  // __owner
  signed int __owner;
  // __nusers
  unsigned int __nusers;
  // __kind
  signed int __kind;
  // __spins
  signed int __spins;
  // __list
  struct __pthread_internal_list __list;
};

union __anonunion_pthread_mutex_t_10
{
  // __data
  struct __pthread_mutex_s __data;
  // __size
  char __size[40l];
  // __align
  signed long int __align;
};

struct _blurfilterdata
{
  // xsize
  signed int xsize;
  // ysize
  signed int ysize;
  // src
  struct _pixel *src;
  // dst
  struct _pixel *dst;
  // radius
  signed int radius;
  // w
  double *w;
  // imageThreads
  struct _imagethread *imageThreads;
  // rank
  signed int rank;
};

struct _imagepart
{
  // sourcePixels
  struct _pixel *sourcePixels;
  // destinationPixels
  struct _pixel *destinationPixels;
  // height
  signed int height;
  // width
  signed int width;
  // ystart
  signed int ystart;
  // ystop
  signed int ystop;
  // pixelCount
  signed int pixelCount;
  // bytes
  signed int bytes;
};

struct _imagethread
{
  // rank
  signed int rank;
  // thread_count
  signed int thread_count;
  // thread
  unsigned long int *thread;
  // partition
  struct _imagepart *partition;
  // argument
  void *argument;
};

struct _pixel
{
  // r
  unsigned char r;
  // g
  unsigned char g;
  // b
  unsigned char b;
};

struct _thresfilterdata
{
  // xsize
  signed int xsize;
  // ysize
  signed int ysize;
  // src
  struct _pixel *src;
  // dst
  struct _pixel *dst;
  // thresholdsum
  unsigned int *thresholdsum;
  // imageThreads
  struct _imagethread *imageThreads;
  // rank
  signed int rank;
  // thresholdsum_mutex
  union __anonunion_pthread_mutex_t_10 *thresholdsum_mutex;
};

struct _thresfilterdata$link10
{
  // xsize
  signed int xsize;
  // ysize
  signed int ysize;
  // src
  struct _pixel *src;
  // dst
  struct _pixel *dst;
  // thresholdsum
  unsigned int *thresholdsum;
  // imageThreads
  struct _imagethread *imageThreads;
  // rank
  signed int rank;
  // thresholdsum_mutex
  union anon$1$link4 *thresholdsum_mutex;
};

struct _thresfilterdata$link9
{
  // xsize
  signed int xsize;
  // ysize
  signed int ysize;
  // src
  struct _pixel *src;
  // dst
  struct _pixel *dst;
  // thresholdsum
  unsigned int *thresholdsum;
  // imageThreads
  struct _imagethread *imageThreads;
  // rank
  signed int rank;
  // thresholdsum_mutex
  union anon$0$link3 *thresholdsum_mutex;
};

union pthread_attr_t
{
  // __size
  char __size[56l];
  // __align
  signed long int __align;
};

struct timespec
{
  // tv_sec
  signed long int tv_sec;
  // tv_nsec
  signed long int tv_nsec;
};


// c::stderr
// file /usr/include/stdio.h line 170
struct _IO_FILE *stderr;
// c::sync_cond
// file imagethread.c line 7
union __anonunion_pthread_cond_t_12 sync_cond;
// c::sync_cond
// file imagethread.c line 7
union __anonunion_pthread_cond_t_12 sync_cond = { .__data={ .__lock=0, .__futex=0u, .__total_seq=0ull, .__wakeup_seq=0ull,
    .__woken_seq=0ull, .__mutex=NULL,
    .__nwaiters=0u, .__broadcast_seq=0u } };
// c::sync_count
// file imagethread.c line 9
signed int sync_count;
// c::sync_count
// file imagethread.c line 9
signed int sync_count = 0;
// c::sync_lock
// file imagethread.c line 6
union __anonunion_pthread_mutex_t_10 sync_lock;
// c::sync_lock
// file imagethread.c line 6
union __anonunion_pthread_mutex_t_10 sync_lock = { .__data={ .__lock=0, .__count=0u, .__owner=0, .__nusers=0u, .__kind=0,
    .__spins=0, .__list={ .__prev=((struct __pthread_internal_list *)NULL), .__next=((struct __pthread_internal_list *)NULL) } } };
// c::sync_max_count
// file imagethread.c line 8
signed int sync_max_count;
// c::sync_max_count
// file imagethread.c line 8
signed int sync_max_count = 0;

// c::SynchronizationPoint
// file imagethread.c line 35
void SynchronizationPoint(void)
{
  pthread_mutex_lock(&sync_lock);
  sync_count = sync_count + 1;
  if(!(sync_count >= sync_max_count))
    pthread_cond_wait((union __anonunion_pthread_cond_t_12 *)&sync_cond, (union __anonunion_pthread_mutex_t_10 *)&sync_lock);

  else
  {
    sync_count = 0;
    pthread_cond_broadcast(&sync_cond);
  }
  pthread_mutex_unlock(&sync_lock);
  return;
}

// c::allocate_image
// file pixel.c line 26
struct _pixel * allocate_image(signed int size)
{
  struct _pixel *image;
  void *tmp;
  tmp=malloc(3ul /*[[struct _pixel]]*/ * (unsigned long int)size);
  image = (struct _pixel *)tmp;
  if(image == ((struct _pixel *)NULL))
  {
    fprintf((struct _IO_FILE *)stderr, (const char *)"malloc failed");
    getchar();
    exit(1);
  }

  return image;
}

// c::blurfilter
// file blurfilter.c line 22
void blurfilter(const signed int xsize, const signed int ysize, struct _pixel *src, struct _pixel *dst, const signed int radius, const double *w, struct _imagethread *imageThreads, signed int rank)
{
  signed int x;
  signed int y;
  signed int x2;
  signed int wi;
  double r;
  double g;
  double b;
  double n;
  double wc;
  struct timespec stime___0;
  struct timespec etime;
  struct _imagethread *thread;
  struct _imagepart *part;
  signed int ystart;
  signed int ystop;
  struct _pixel *tmp;
  struct _pixel *tmp___0;
  struct _pixel *tmp___1;
  struct _pixel *tmp___2;
  struct _pixel *tmp___3;
  struct _pixel *tmp___4;
  struct _pixel *tmp___5;
  struct _pixel *tmp___6;
  struct _pixel *tmp___7;
  struct _pixel *tmp___8;
  struct _pixel *tmp___9;
  struct _pixel *tmp___10;
  struct _pixel *tmp___11;
  struct _pixel *tmp___12;
  struct _pixel *tmp___13;
  struct _pixel *tmp___14;
  struct _pixel *tmp___15;
  struct _pixel *tmp___16;
  struct _pixel *tmp___17;
  struct _pixel *tmp___18;
  struct _pixel *tmp___19;
  struct _pixel *tmp___20;
  struct _pixel *tmp___21;
  struct _pixel *tmp___22;
  thread = imageThreads + (signed long int)rank;
  part = thread->partition;
  ystart = part->ystart;
  ystop = part->ystop;
  clock_gettime(0, &stime___0);
  y = ystart;
  while(!(y >= ystop))
  {
    x = 0;
    while(!(x >= xsize))
    {
      tmp=pix(src, (const signed int)x, (const signed int)y, xsize);
      r = (double)(w[(signed long int)0] * (const double)tmp->r);
      tmp___0=pix(src, (const signed int)x, (const signed int)y, xsize);
      g = (double)(w[(signed long int)0] * (const double)tmp___0->g);
      tmp___1=pix(src, (const signed int)x, (const signed int)y, xsize);
      b = (double)(w[(signed long int)0] * (const double)tmp___1->b);
      n = (double)w[(signed long int)0];
      wi = 1;
      while(radius >= wi)
      {
        wc = (double)w[(signed long int)wi];
        x2 = x - wi;
        if(x2 >= 0)
        {
          tmp___2=pix(src, (const signed int)x2, (const signed int)y, xsize);
          r = r + wc * (double)tmp___2->r;
          tmp___3=pix(src, (const signed int)x2, (const signed int)y, xsize);
          g = g + wc * (double)tmp___3->g;
          tmp___4=pix(src, (const signed int)x2, (const signed int)y, xsize);
          b = b + wc * (double)tmp___4->b;
          n = n + wc;
        }

        x2 = x + wi;
        if(!(x2 >= xsize))
        {
          tmp___5=pix(src, (const signed int)x2, (const signed int)y, xsize);
          r = r + wc * (double)tmp___5->r;
          tmp___6=pix(src, (const signed int)x2, (const signed int)y, xsize);
          g = g + wc * (double)tmp___6->g;
          tmp___7=pix(src, (const signed int)x2, (const signed int)y, xsize);
          b = b + wc * (double)tmp___7->b;
          n = n + wc;
        }

        wi = wi + 1;
      }
      tmp___8=pix_trans(dst, (const signed int)x, (const signed int)y, ysize);
      tmp___8->r = (unsigned char)(r / n);
      tmp___9=pix_trans(dst, (const signed int)x, (const signed int)y, ysize);
      tmp___9->g = (unsigned char)(g / n);
      tmp___10=pix_trans(dst, (const signed int)x, (const signed int)y, ysize);
      tmp___10->b = (unsigned char)(b / n);
      x = x + 1;
    }
    y = y + 1;
  }
  SynchronizationPoint();
  y = 0;
  while(!(y >= xsize))
  {
    x = ystart;
    while(!(x >= ystop))
    {
      tmp___11=pix(dst, (const signed int)x, (const signed int)y, ysize);
      r = (double)(w[(signed long int)0] * (const double)tmp___11->r);
      tmp___12=pix(dst, (const signed int)x, (const signed int)y, ysize);
      g = (double)(w[(signed long int)0] * (const double)tmp___12->g);
      tmp___13=pix(dst, (const signed int)x, (const signed int)y, ysize);
      b = (double)(w[(signed long int)0] * (const double)tmp___13->b);
      n = (double)w[(signed long int)0];
      wi = 1;
      while(radius >= wi)
      {
        wc = (double)w[(signed long int)wi];
        x2 = x - wi;
        if(x2 >= 0)
        {
          tmp___14=pix(dst, (const signed int)x2, (const signed int)y, ysize);
          r = r + wc * (double)tmp___14->r;
          tmp___15=pix(dst, (const signed int)x2, (const signed int)y, ysize);
          g = g + wc * (double)tmp___15->g;
          tmp___16=pix(dst, (const signed int)x2, (const signed int)y, ysize);
          b = b + wc * (double)tmp___16->b;
          n = n + wc;
        }

        x2 = x + wi;
        if(!(x2 >= ysize))
        {
          tmp___17=pix(dst, (const signed int)x2, (const signed int)y, ysize);
          r = r + wc * (double)tmp___17->r;
          tmp___18=pix(dst, (const signed int)x2, (const signed int)y, ysize);
          g = g + wc * (double)tmp___18->g;
          tmp___19=pix(dst, (const signed int)x2, (const signed int)y, ysize);
          b = b + wc * (double)tmp___19->b;
          n = n + wc;
        }

        wi = wi + 1;
      }
      tmp___20=pix_trans(src, (const signed int)x, (const signed int)y, xsize);
      tmp___20->r = (unsigned char)(r / n);
      tmp___21=pix_trans(src, (const signed int)x, (const signed int)y, xsize);
      tmp___21->g = (unsigned char)(g / n);
      tmp___22=pix_trans(src, (const signed int)x, (const signed int)y, xsize);
      tmp___22->b = (unsigned char)(b / n);
      x = x + 1;
    }
    y = y + 1;
  }
  clock_gettime(0, &etime);
  printf((const char *)"Filtering %d took %g secs\n", rank, (double)(etime.tv_sec - stime___0.tv_sec) + 1.000000e-9 * (double)(etime.tv_nsec - stime___0.tv_nsec));
  SynchronizationPoint();
  return;
}

// c::blurfilterwrapper
// file blurfilter.c line 16
void * blurfilterwrapper(void *arg)
{
  struct _blurfilterdata *data = (struct _blurfilterdata *)arg;
  blurfilter((const signed int)data->xsize, (const signed int)data->ysize, data->src, data->dst, (const signed int)data->radius, (const double *)data->w, data->imageThreads, data->rank);
  return NULL;
}

// c::blurmain
// file blurmain.c line 12
signed int blurmain(signed int argc, char **argv)
{
  signed int thread_count;
  signed int radius;
  signed int xsize;
  signed int ysize;
  signed int colmax;
  struct _pixel *src;
  struct _pixel *dst;
  struct _imagethread *imageThreads;
  struct _blurfilterdata *blurdata;
  signed int i;
  char *inputFilepath;
  char *outputFilepath;
  struct timespec stime___0;
  struct timespec etime;
  double *w;
  void *tmp;
  signed int tmp___0;
  void *tmp___1;
  signed int tmp___2;
  src=allocate_image(1000000);
  dst=allocate_image(1000000);
  tmp=malloc(8ul /*[[double]]*/ * 1000ul);
  w = (double *)tmp;
  if(!(argc == 5))
  {
    fprintf((struct _IO_FILE *)stderr, (const char *)"Usage: %s thread_count radius infile outfile\n", argv[(signed long int)0]);
    return 1;
  }

  thread_count=atoi((const char *)argv[(signed long int)1]);
  if(thread_count < 1)
  {
    fprintf((struct _IO_FILE *)stderr, (const char *)"Too few threads\n");
    return 1;
  }

  thread_count=atoi((const char *)argv[(signed long int)1]);
  radius=atoi((const char *)argv[(signed long int)2]);
  if(radius > 1000)
  {
    fprintf((struct _IO_FILE *)stderr, (const char *)"Radius (%d) must be greater than zero and less then %d\n", radius, 1000);
    return 1;
  }

  else
    if(radius < 1)
    {
      fprintf((struct _IO_FILE *)stderr, (const char *)"Radius (%d) must be greater than zero and less then %d\n", radius, 1000);
      return 1;
    }

  inputFilepath=strdup((const char *)argv[(signed long int)3]);
  outputFilepath=strdup((const char *)argv[(signed long int)4]);
  tmp___0=read_ppm((const char *)inputFilepath, &xsize, &ysize, &colmax, (char *)src);
  if(!(tmp___0 == 0))
    return 1;

  if(colmax > 255)
  {
    fprintf((struct _IO_FILE *)stderr, (const char *)"Too large maximum color-component value\n");
    return 1;
  }

  printf((const char *)"Has read the image, generating coefficients\n");
  get_gauss_weights(radius, w);
  printf((const char *)"Calling filter\n");
  clock_gettime(0, &stime___0);
  printf((const char *)"Creating threads\n");
  imageThreads=createThreadData(thread_count);
  printf((const char *)"Dividing image\n");
  divide(imageThreads, thread_count, src, dst, (const signed int)xsize, (const signed int)ysize);
  printf((const char *)"\n");
  printf((const char *)"Setting arguments\n");
  tmp___1=malloc(56ul /*[[struct _blurfilterdata]]*/ * (unsigned long int)thread_count);
  blurdata = (struct _blurfilterdata *)tmp___1;
  i = 0;
  while(!(i >= thread_count))
  {
    (blurdata + (signed long int)i)->xsize = xsize;
    (blurdata + (signed long int)i)->ysize = ysize;
    (blurdata + (signed long int)i)->src = src;
    (blurdata + (signed long int)i)->dst = dst;
    (blurdata + (signed long int)i)->radius = radius;
    (blurdata + (signed long int)i)->w = w;
    (blurdata + (signed long int)i)->imageThreads = imageThreads;
    (blurdata + (signed long int)i)->rank = i;
    i = i + 1;
  }
  printf((const char *)"Starting threads\n");
  setThreadSyncCount(thread_count);
  i = 0;
  while(!(i >= thread_count))
  {
    (imageThreads + (signed long int)i)->argument = (void *)(blurdata + (signed long int)i);
    (imageThreads + (signed long int)i)->thread=createThread((void *)blurfilterwrapper, (imageThreads + (signed long int)i)->argument);
    i = i + 1;
  }
  printf((const char *)"Threads working on x-axis\n");
  SynchronizationPoint();
  printf((const char *)"Threads working on y-axis\n");
  SynchronizationPoint();
  printf((const char *)"Threads done\n");
  clock_gettime(0, &etime);
  printf((const char *)"Filtering took: %g secs\n", (double)(etime.tv_sec - stime___0.tv_sec) + 1.000000e-9 * (double)(etime.tv_nsec - stime___0.tv_nsec));
  printf((const char *)"Writing output file \"%s\"\n", outputFilepath);
  tmp___2=write_ppm((const char *)outputFilepath, xsize, ysize, (char *)src);
  if(!(tmp___2 == 0))
    return 1;

  return 0;
}

// c::createThread
// file imagethread.c line 11
unsigned long int * createThread(void *function, void *argument)
{
  unsigned long int *thread;
  void *tmp;
  tmp=malloc(8ul /*[[unsigned long int]]*/);
  thread = (unsigned long int *)tmp;
  pthread_create((unsigned long int *)thread, ((const union pthread_attr_t *)NULL), (void * (*)(void *))function, (void *)argument);
  return thread;
}

// c::createThreadData
// file imagethread.c line 18
struct _imagethread * createThreadData(signed int count)
{
  signed int i;
  struct _imagethread *threads;
  void *tmp;
  tmp=malloc(32ul /*[[struct _imagethread]]*/ * (unsigned long int)count);
  threads = (struct _imagethread *)tmp;
  i = 0;
  while(!(i >= count))
  {
    (threads + (signed long int)i)->rank = i;
    (threads + (signed long int)i)->thread_count = count;
    i = i + 1;
  }
  return threads;
}

// c::divide
// file imagepart.c line 8
void divide(struct _imagethread *threadData, signed int count, struct _pixel *sourceImage, struct _pixel *destinationImage, const signed int xsize, const signed int ysize)
{
  signed int i;
  signed int partHeight;
  signed int partHeightLeft;
  void *tmp;
  partHeight = (signed int)(ysize / (const signed int)count);
  partHeightLeft = (signed int)(ysize % (const signed int)count);
  fprintf((struct _IO_FILE *)stderr, (const char *)"Setting structs\n");
  i = 0;
  while(!(i >= count))
  {
    tmp=malloc(40ul /*[[struct _imagepart]]*/);
    (threadData + (signed long int)i)->partition = (struct _imagepart *)tmp;
    i = i + 1;
  }
  fprintf((struct _IO_FILE *)stderr, (const char *)"Setting initial height\n");
  i = 0;
  while(!(i >= count))
  {
    (threadData + (signed long int)i)->partition->width = (signed int)xsize;
    (threadData + (signed long int)i)->partition->height = partHeight;
    i = i + 1;
  }
  fprintf((struct _IO_FILE *)stderr, (const char *)"Setting corrected height\n");
  i = 0;
  while(!(i >= partHeightLeft))
  {
    (threadData + (signed long int)i)->partition->height = (threadData + (signed long int)i)->partition->height + 1;
    i = i + 1;
  }
  fprintf((struct _IO_FILE *)stderr, (const char *)"Setting pixel count & bytes\n");
  i = 0;
  while(!(i >= count))
  {
    (threadData + (signed long int)i)->partition->pixelCount = (threadData + (signed long int)i)->partition->width * (threadData + (signed long int)i)->partition->height;
    (threadData + (signed long int)i)->partition->bytes = (signed int)((unsigned long int)(threadData + (signed long int)i)->partition->pixelCount * 3ul /*[[struct _pixel]]*/);
    i = i + 1;
  }
  fprintf((struct _IO_FILE *)stderr, (const char *)"Setting ystart, sourcePixels and destinationPixels\n");
  (threadData + (signed long int)0)->partition->ystart = 0;
  (threadData + (signed long int)0)->partition->ystop = (threadData + (signed long int)0)->partition->height;
  (threadData + (signed long int)0)->partition->sourcePixels = sourceImage;
  (threadData + (signed long int)0)->partition->destinationPixels = destinationImage;
  i = 1;
  while(!(i >= count))
  {
    (threadData + (signed long int)i)->partition->ystart = (threadData + (signed long int)(i - 1))->partition->ystop;
    (threadData + (signed long int)i)->partition->ystop = (threadData + (signed long int)i)->partition->ystart + (threadData + (signed long int)i)->partition->height;
    (threadData + (signed long int)i)->partition->sourcePixels = (threadData + (signed long int)(i - 1))->partition->sourcePixels + (signed long int)(threadData + (signed long int)(i - 1))->partition->bytes;
    (threadData + (signed long int)i)->partition->destinationPixels = (threadData + (signed long int)(i - 1))->partition->destinationPixels + (signed long int)(threadData + (signed long int)(i - 1))->partition->bytes;
    i = i + 1;
  }
  return;
}

// c::get_gauss_weights
// file gaussw.c line 18
void get_gauss_weights(signed int n, double *weights_out)
{
  double x;
  signed int i = 0;
  while(!(i >= 1 + n))
  {
    x = ((double)i * 1.330000e+0) / (double)n;
    weights_out[(signed long int)i]=exp(-x * x * 3.141590e+0);
    i = i + 1;
  }
  return;
}

// c::main
// file main.c line 6
signed int main(signed int argc, char **argv)
{
  signed int result = 0;
  if(argc == 4)
  {
    printf((const char *)"Threshold!\n");
    result=thresmain(argc, argv);
  }

  else
    if(argc == 5)
    {
      printf((const char *)"Blur!\n");
      result=blurmain(argc, argv);
    }

    else
    {
      fprintf((struct _IO_FILE *)stderr, (const char *)"Threshold usage: %s thread_count infile outfile\n", argv[(signed long int)0]);
      fprintf((struct _IO_FILE *)stderr, (const char *)"Blur usage: %s thread_count radius infile outfile\n", argv[(signed long int)0]);
      result = 1;
    }
  exit(result);
  return nondet_signed_int();
}

// c::pix
// file pixel.c line 6
struct _pixel * pix(struct _pixel *image, const signed int xx, const signed int yy, const signed int xsize)
{
  signed int off = (signed int)(xsize * yy + xx);
  if(off >= 1000000)
    fprintf((struct _IO_FILE *)stderr, (const char *)"\n Terribly wrong: %d %d %d\n", xx, yy, xsize);

  return image + (signed long int)off;
}

// c::pix_trans
// file pixel.c line 16
struct _pixel * pix_trans(struct _pixel *image, const signed int xx, const signed int yy, const signed int ysize)
{
  signed int off = (signed int)(ysize * xx + yy);
  if(off >= 1000000)
    fprintf((struct _IO_FILE *)stderr, (const char *)"\n Terribly wrong: %d %d %d\n", xx, yy, ysize);

  return image + (signed long int)off;
}

// c::ppm_error
// file ppm.c line 4
void ppm_error(char *str)
{
  fprintf((struct _IO_FILE *)stderr, (const char *)"%s\n", str);
  getchar();
  exit(1);
}

// c::ppm_readchar
// file ppm.c line 12
char ppm_readchar(struct _IO_FILE *file)
{
  char ch;
  signed int tmp;
  signed int tmp___0;
  tmp=_IO_getc(file);
  ch = (char)tmp;
  if((signed int)ch == -1)
    ppm_error((char *)"read error");

  if((signed int)ch == 35)
    while(TRUE)
    {
      tmp___0=_IO_getc(file);
      ch = (char)tmp___0;
      if((signed int)ch == -1)
        ppm_error((char *)"read error");

      if((signed int)ch == 10)
        goto __CPROVER_DUMP_L4;

    }


__CPROVER_DUMP_L4:
  ;
  return ch;
}

// c::ppm_readint
// file ppm.c line 42
signed int ppm_readint(struct _IO_FILE *file)
{
  char ch;
  signed int i;
  while(TRUE)
  {
    ch=ppm_readchar(file);
    if(!((signed int)ch == 32))
    {
      if(!((signed int)ch == 9))
      {
        if(!((signed int)ch == 10))
          goto __CPROVER_DUMP_L3;

      }

    }

  }

__CPROVER_DUMP_L3:
  ;
  if((signed int)ch < 48)
    ppm_error((char *)"error in readint");

  else
    if((signed int)ch > 57)
      ppm_error((char *)"error in readint");

  i = 0;
  while(TRUE)
  {
    i = i * 10 + ((signed int)ch - 48);
    ch=ppm_readchar(file);
    if((signed int)ch >= 48)
    {
      if(!((signed int)ch <= 57))
        goto __CPROVER_DUMP_L9;

    }

    else
      goto __CPROVER_DUMP_L9;
  }

__CPROVER_DUMP_L9:
  ;
  return i;
}

// c::ppm_readmagicnumber
// file ppm.c line 28
signed int ppm_readmagicnumber(struct _IO_FILE *file)
{
  signed int ch1;
  signed int ch2;
  ch1=_IO_getc(file);
  if(ch1 == -1)
    ppm_error((char *)"read error");

  ch2=_IO_getc(file);
  if(ch2 == -1)
    ppm_error((char *)"read error");

  return ch1 * 256 + ch2;
}

// c::read_ppm
// file ppmio.c line 12
signed int read_ppm(const char *fname, signed int *xpix, signed int *ypix, signed int *max, char *data)
{
  char ftype[40l];
  char ctype[40l];
  unsigned int tmp;
  char line[80l];
  signed int errno;
  struct _IO_FILE *fp;
  char *filename;
  signed int bytesToRead;
  signed int bytesRead;
  char *tmp___0;
  char *tmp___1;
  unsigned long int tmp___2;
  signed int tmp___3;
  signed int tmp___4;
  ctype[(signed long int)0] = (char)80;
  ctype[(signed long int)1] = (char)54;
  ctype[(signed long int)2] = (char)0;
  tmp = 3u;
  while(!(tmp >= 40u))
  {
    ctype[(signed long int)tmp] = (char)0;
    tmp = tmp + 1u;
  }
  errno = 0;
  filename=strdup(fname);
  if((unsigned long int)filename == 0ul)
    filename = (char *)"";

  fp=fopen((const char *)filename, (const char *)"r");
  if((unsigned long int)fp == 0ul)
  {
    tmp___0=strerror(errno);
    fprintf((struct _IO_FILE *)stderr, (const char *)"read_ppm failed to open %s: %s\n", filename, tmp___0);
    getchar();
    exit(1);
  }

  fgets((char *)line, 80, (struct _IO_FILE *)fp);
  sscanf((const char *)line, (const char *)"%s", (const void *)ftype);
  while(TRUE)
  {
    tmp___1=fgets((char *)line, 80, (struct _IO_FILE *)fp);
    if(!(tmp___1 == ((char *)NULL)))
    {
      if(!((signed int)line[0l] == 35))
        goto __CPROVER_DUMP_L8;

    }

    else
      goto __CPROVER_DUMP_L8;
  }

__CPROVER_DUMP_L8:
  ;
  sscanf((const char *)line, (const char *)"%d%d", xpix, ypix);
  fscanf((struct _IO_FILE *)fp, (const char *)"%d\n", max);
  if(*xpix * *ypix > 1000000)
  {
    fprintf((struct _IO_FILE *)stderr, (const char *)"Image size is too big\n");
    return 4;
  }

  tmp___3=strncmp((const char *)ftype, (const char *)ctype, (unsigned long int)2);
  if(tmp___3 == 0)
  {
    bytesToRead = *xpix * *ypix * 3;
    tmp___2=fread((void *)data, 1ul /*[[char]]*/, (unsigned long int)bytesToRead, (struct _IO_FILE *)fp);
    bytesRead = (signed int)tmp___2;
    if(!(bytesRead == bytesToRead))
    {
      perror("Read failed");
      return 2;
    }

  }

  else
    fprintf((struct _IO_FILE *)stderr, (const char *)"Wrong file format: %s\n", (const void *)ftype);
  tmp___4=fclose(fp);
  if(tmp___4 == -1)
  {
    perror("Close failed");
    return 3;
  }

  return 0;
}

// c::setThreadSyncCount
// file imagethread.c line 31
void setThreadSyncCount(signed int count)
{
  sync_max_count = count + 1;
  return;
}

// c::thresfilter
// file thresfilter.c line 11
void thresfilter(const signed int xsize, const signed int ysize, struct _pixel *src, unsigned int *thresholdsum, union __anonunion_pthread_mutex_t_10 *thresholdsum_mutex, struct _imagethread *imageThreads, signed int rank)
{
  unsigned int sum;
  unsigned int i;
  unsigned int psum;
  unsigned int nump;
  unsigned int numptot;
  unsigned int start;
  unsigned int stop;
  struct timespec stime___0;
  struct timespec etime;
  struct _imagethread *thread;
  struct _imagepart *part;
  signed int ystart;
  signed int ystop;
  unsigned char tmp;
  unsigned char tmp___0;
  unsigned char tmp___1;
  unsigned char tmp___2;
  fprintf((struct _IO_FILE *)stderr, (const char *)"Hello from thread %d\n", rank);
  thread = imageThreads + (signed long int)rank;
  part = thread->partition;
  ystart = part->ystart;
  ystop = part->ystop;
  clock_gettime(0, &stime___0);
  numptot = (unsigned int)(xsize * ysize);
  nump = (unsigned int)part->pixelCount;
  start = (unsigned int)(part->width * part->ystart);
  stop = (unsigned int)(part->width * part->ystart) + nump;
  i = start;
  sum = 0u;
  while(!(i >= stop))
  {
    sum = sum + (unsigned int)(src + (signed long int)i)->r + (unsigned int)(src + (signed long int)i)->g + (unsigned int)(src + (signed long int)i)->b;
    i = i + 1u;
  }
  pthread_mutex_lock(thresholdsum_mutex);
  *thresholdsum = *thresholdsum + sum;
  pthread_mutex_unlock(thresholdsum_mutex);
  SynchronizationPoint();
  sum = *thresholdsum / numptot;
  i = start;
  while(!(i >= stop))
  {
    psum = (unsigned int)(src + (signed long int)i)->r + (unsigned int)(src + (signed long int)i)->g + (unsigned int)(src + (signed long int)i)->b;
    if(!(psum >= sum))
    {
      tmp___0 = (unsigned char)0;
      (src + (signed long int)i)->b = tmp___0;
      tmp = tmp___0;
      (src + (signed long int)i)->g = tmp;
      (src + (signed long int)i)->r = tmp;
    }

    else
    {
      tmp___2 = (unsigned char)255;
      (src + (signed long int)i)->b = tmp___2;
      tmp___1 = tmp___2;
      (src + (signed long int)i)->g = tmp___1;
      (src + (signed long int)i)->r = tmp___1;
    }
    i = i + 1u;
  }
  clock_gettime(0, &etime);
  printf((const char *)"Filtering %d took %g secs\n", rank, (double)(etime.tv_sec - stime___0.tv_sec) + 1.000000e-9 * (double)(etime.tv_nsec - stime___0.tv_nsec));
  SynchronizationPoint();
  return;
}

// c::thresfilterwrapper
// file thresfilter.c line 5
void * thresfilterwrapper(void *arg)
{
  struct _thresfilterdata *data = (struct _thresfilterdata *)arg;
  thresfilter((const signed int)data->xsize, (const signed int)data->ysize, data->src, data->thresholdsum, data->thresholdsum_mutex, data->imageThreads, data->rank);
  return NULL;
}

// c::thresmain
// file thresmain.c line 11
signed int thresmain(signed int argc, char **argv)
{
  signed int thread_count;
  signed int xsize;
  signed int ysize;
  signed int colmax;
  struct _pixel *src;
  struct _pixel *dst;
  struct _imagethread *imageThreads;
  struct _thresfilterdata *thresdata;
  union __anonunion_pthread_mutex_t_10 thresholdsum_mutex;
  unsigned int thresholdsum;
  signed int i;
  char *inputFilepath;
  char *outputFilepath;
  struct timespec stime___0;
  struct timespec etime;
  signed int tmp;
  void *tmp___0;
  signed int tmp___1;
  thresholdsum_mutex.__data.__lock = 0;
  thresholdsum_mutex.__data.__count = 0u;
  thresholdsum_mutex.__data.__owner = 0;
  thresholdsum_mutex.__data.__nusers = 0u;
  thresholdsum_mutex.__data.__kind = 0;
  thresholdsum_mutex.__data.__spins = 0;
  thresholdsum_mutex.__data.__list.__prev = ((struct __pthread_internal_list *)NULL);
  thresholdsum_mutex.__data.__list.__next = ((struct __pthread_internal_list *)NULL);
  thresholdsum = 0u;
  src=allocate_image(1000000);
  dst=allocate_image(1000000);
  if(!(argc == 4))
  {
    fprintf((struct _IO_FILE *)stderr, (const char *)"Usage: %s thread_count infile outfile\n", argv[(signed long int)0]);
    return 1;
  }

  thread_count=atoi((const char *)argv[(signed long int)1]);
  if(thread_count < 1)
  {
    fprintf((struct _IO_FILE *)stderr, (const char *)"Too few threads\n");
    return 1;
  }

  inputFilepath=strdup((const char *)argv[(signed long int)2]);
  outputFilepath=strdup((const char *)argv[(signed long int)3]);
  tmp=read_ppm((const char *)inputFilepath, &xsize, &ysize, &colmax, (char *)src);
  if(!(tmp == 0))
    return 1;

  if(colmax > 255)
  {
    fprintf((struct _IO_FILE *)stderr, (const char *)"Too large maximum color-component value\n");
    return 1;
  }

  printf((const char *)"Creating threads\n");
  imageThreads=createThreadData(thread_count);
  printf((const char *)"Dividing image\n");
  divide(imageThreads, thread_count, src, dst, (const signed int)xsize, (const signed int)ysize);
  printf((const char *)"\n");
  printf((const char *)"Setting arguments\n");
  tmp___0=malloc(56ul /*[[struct _thresfilterdata]]*/ * (unsigned long int)thread_count);
  thresdata = (struct _thresfilterdata *)tmp___0;
  i = 0;
  while(!(i >= thread_count))
  {
    (thresdata + (signed long int)i)->xsize = xsize;
    (thresdata + (signed long int)i)->ysize = ysize;
    (thresdata + (signed long int)i)->src = src;
    (thresdata + (signed long int)i)->dst = dst;
    (thresdata + (signed long int)i)->thresholdsum = &thresholdsum;
    (thresdata + (signed long int)i)->imageThreads = imageThreads;
    (thresdata + (signed long int)i)->rank = i;
    (thresdata + (signed long int)i)->thresholdsum_mutex = &thresholdsum_mutex;
    i = i + 1;
  }
  clock_gettime(0, &stime___0);
  printf((const char *)"Starting threads\n");
  setThreadSyncCount(thread_count);
  i = 0;
  while(!(i >= thread_count))
  {
    (imageThreads + (signed long int)i)->argument = (void *)(thresdata + (signed long int)i);
    (imageThreads + (signed long int)i)->thread=createThread((void *)thresfilterwrapper, (imageThreads + (signed long int)i)->argument);
    i = i + 1;
  }
  printf((const char *)"Threads working on average value\n");
  SynchronizationPoint();
  printf((const char *)"Average value is %d\n", thresholdsum / (unsigned int)(xsize * ysize));
  printf((const char *)"Threads working on threshold\n");
  SynchronizationPoint();
  printf((const char *)"Threads done\n");
  clock_gettime(0, &etime);
  printf((const char *)"Filtering took: %g secs\n", (double)(etime.tv_sec - stime___0.tv_sec) + 1.000000e-9 * (double)(etime.tv_nsec - stime___0.tv_nsec));
  printf((const char *)"Writing output file\n");
  tmp___1=write_ppm((const char *)outputFilepath, xsize, ysize, (char *)src);
  if(!(tmp___1 == 0))
    return 1;

  return 0;
}

// c::write_ppm
// file ppmio.c line 71
signed int write_ppm(const char *fname, signed int xpix, signed int ypix, char *data)
{
  struct _IO_FILE *fp;
  char *filename;
  signed int errnoOut;
  signed int bytesToWrite;
  signed int bytesWritten;
  char *tmp;
  unsigned long int tmp___0;
  signed int tmp___1;
  errnoOut = 0;
  filename=strdup(fname);
  if((unsigned long int)filename == 0ul)
  {
    fprintf((struct _IO_FILE *)stderr, (const char *)"write_ppm filename is null.\n");
    exit(1);
  }

  fp=fopen((const char *)filename, (const char *)"w");
  if((unsigned long int)fp == 0ul)
  {
    tmp=strerror(errnoOut);
    fprintf((struct _IO_FILE *)stderr, (const char *)"write_ppm failed to open %s: %s\n", filename, tmp);
    getchar();
    exit(1);
  }

  fprintf((struct _IO_FILE *)fp, (const char *)"P6\n");
  fprintf((struct _IO_FILE *)fp, (const char *)"%d %d 255\n", xpix, ypix);
  bytesToWrite = xpix * ypix * 3;
  tmp___0=fwrite((const void *)data, 1ul /*[[char]]*/, (unsigned long int)bytesToWrite, (struct _IO_FILE *)fp);
  bytesWritten = (signed int)tmp___0;
  if(!(bytesWritten == bytesToWrite))
  {
    perror("Write failed");
    return 2;
  }

  tmp___1=fclose(fp);
  if(tmp___1 == -1)
  {
    perror("Close failed");
    return 3;
  }

  return 0;
}

