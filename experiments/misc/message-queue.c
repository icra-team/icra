/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is true */

#line 213 "/usr/lib/gcc/x86_64-linux-gnu/4.7/include/stddef.h"
typedef unsigned long size_t;
#line 140 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 141 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 148 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 75 "/usr/include/time.h"
typedef __time_t time_t;
#line 60 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef unsigned long pthread_t;
#line 63 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
union pthread_attr_t {
   char __size[56] ;
   long __align ;
};
#line 69 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef union pthread_attr_t pthread_attr_t;
#line 75 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
struct __pthread_internal_list {
   struct __pthread_internal_list *__prev ;
   struct __pthread_internal_list *__next ;
};
#line 75 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef struct __pthread_internal_list __pthread_list_t;
#line 90 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
struct __pthread_mutex_s {
   int __lock ;
   unsigned int __count ;
   int __owner ;
   unsigned int __nusers ;
   int __kind ;
   int __spins ;
   __pthread_list_t __list ;
};
#line 90 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
union __anonunion_pthread_mutex_t_10 {
   struct __pthread_mutex_s __data ;
   char __size[40] ;
   long __align ;
};
#line 90 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef union __anonunion_pthread_mutex_t_10 pthread_mutex_t;
#line 14 "queue.h"
struct node {
   int priority ;
   void *buf ;
   size_t buflen ;
   struct node *next ;
   int read ;
};
#line 22 "queue.h"
typedef struct node node_t;
#line 25 "queue.h"
struct msg_queue {
   int length ;
   int readers ;
   int disabled ;
   node_t *_queue ;
   pthread_mutex_t mutex ;
};
#line 33 "queue.h"
typedef struct msg_queue msg_queue_t;
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 155 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 161 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 246 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 144 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __clock_t;
#line 59 "/usr/include/time.h"
typedef __clock_t clock_t;
#line 120 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
union __anonunion_pthread_mutexattr_t_11 {
   char __size[4] ;
   int __align ;
};
#line 120 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef union __anonunion_pthread_mutexattr_t_11 pthread_mutexattr_t;
#line 1 "cil-TWVJsl2h.o"
#pragma merger("0","/tmp/cil-CbqTdd5a.i","-pthread")
#line 125 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcpy)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 128
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strncpy)(char * __restrict  __dest ,
                                                                                                  char const   * __restrict  __src ,
                                                                                                  size_t __n ) ;
#line 395
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 192 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) time_t ( __attribute__((__leaf__)) time)(time_t *__timer ) ;
#line 232 "/usr/include/pthread.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,3))) pthread_create)(pthread_t * __restrict  __newthread ,
                                                                                             pthread_attr_t const   * __restrict  __attr ,
                                                                                             void *(*__start_routine)(void * ) ,
                                                                                             void * __restrict  __arg ) ;
#line 249
extern int pthread_join(pthread_t __th , void **__thread_return ) ;
#line 36 "queue.h"
int queue_create(msg_queue_t *new_queue ) ;
#line 42
int queue_send(msg_queue_t *msg_queue , void *buf , size_t buflen , int priority ,
               int timeout , int *stop_signal ) ;
#line 49
int queue_recv(msg_queue_t *msg_queue , void *buf , size_t *buflen , int *priority ,
               int timeout , int *stop_signal ) ;
#line 53
int queue_destroy(msg_queue_t *msg_queue ) ;
#line 169 "/usr/include/stdio.h"
extern struct _IO_FILE *stdout ;
#line 242
extern int fflush(FILE *__stream ) ;
#line 362
extern int printf(char const   * __restrict  __format  , ...) ;
#line 386
extern  __attribute__((__nothrow__)) int ( /* format attribute */  snprintf)(char * __restrict  __s ,
                                                                             size_t __maxlen ,
                                                                             char const   * __restrict  __format 
                                                                             , ...) ;
#line 4 "program.c"
void launch_test(pthread_t *threads , int threads_number , void *(*start_routine)(void * ) ) ;
#line 5
void *test1(void *vptr_args ) ;
#line 6
void *test2a(void *vptr_args ) ;
#line 7
void *test2b(void *vptr_args ) ;
#line 8
void *test3(void *vptr_args ) ;
#line 9
void *test4(void *vptr_args ) ;
#line 11 "program.c"
msg_queue_t queue  ;
#line 12 "program.c"
int stop  ;
#line 14 "program.c"
int main(int argc , char **argv ) 
{ 
  pthread_t threads[4] ;

  {
#line 17
  queue_create(& queue);
#line 19
  printf((char const   * __restrict  )"--- Test 1 ---\n");
#line 20
  launch_test(threads, 2, & test1);
#line 22
  printf((char const   * __restrict  )"\n--- Test 2a ---\n");
#line 23
  launch_test(threads, 4, & test2a);
#line 25
  printf((char const   * __restrict  )"\n--- Test 2b ---\n");
#line 26
  launch_test(threads, 4, & test2b);
#line 28
  printf((char const   * __restrict  )"\n--- Test 3 ---\n");
#line 29
  launch_test(threads, 1, & test3);
#line 31
  printf((char const   * __restrict  )"\n--- Test 4 ---\n");
#line 32
  launch_test(threads, 2, & test4);
#line 34
  queue_destroy(& queue);
#line 35
  return (0);
}
}
#line 38 "program.c"
void launch_test(pthread_t *threads , int threads_number , void *(*start_routine)(void * ) ) 
{ 
  int i ;

  {
#line 41
  i = 0;
#line 41
  while (i < threads_number) {
#line 42
    pthread_create((pthread_t * __restrict  )(threads + i), (pthread_attr_t const   * __restrict  )((void *)0),
                   start_routine, (void * __restrict  )((void *)i));
#line 41
    i ++;
  }
#line 43
  i = 0;
#line 43
  while (i < threads_number) {
#line 44
    pthread_join(*(threads + i), (void **)((void *)0));
#line 43
    i ++;
  }
#line 45
  return;
}
}
#line 48 "program.c"
void *test1(void *vptr_args ) 
{ 
  int thread_no ;
  char message[128] ;
  int buflen ;
  int prio ;
  size_t tmp ;

  {
#line 50
  thread_no = (int )vptr_args;
#line 52
  buflen = 128;
#line 53
  switch (thread_no) {
  case 0: 
#line 56
  strncpy((char * __restrict  )(message), (char const   * __restrict  )"To jest wiadomosc!",
          (size_t )128);
#line 57
  tmp = strlen((char const   *)(message));
#line 57
  queue_send(& queue, (void *)(message), tmp + 1UL, 1, 0, (int *)((void *)0));
#line 58
  printf((char const   * __restrict  )"Wyslano wiadomosc: %s\n", message);
#line 59
  break;
  case 1: 
#line 62
  queue_recv(& queue, (void *)(message), (size_t *)(& buflen), & prio, 0, (int *)((void *)0));
#line 63
  printf((char const   * __restrict  )"Odebrano wiadomosc o dlugosci %d i priorytecie %d: %s\n",
         buflen, prio, message);
#line 64
  break;
  }
#line 66
  return ((void *)0);
}
}
#line 69 "program.c"
void *test2a(void *vptr_args ) 
{ 
  int thread_no ;
  char message[128] ;
  int buflen ;
  int prio ;
  int i ;
  time_t now ;
  size_t tmp ;
  time_t tmp___0 ;

  {
#line 71
  thread_no = (int )vptr_args;
#line 73
  buflen = 128;
#line 75
  switch (thread_no) {
  case 2: 
  case 1: 
  case 0: 
#line 80
  prio = 2 - thread_no;
#line 81
  snprintf((char * __restrict  )(message), (size_t )128, (char const   * __restrict  )"Wiadomosc od watku %d",
           thread_no, prio);
#line 82
  tmp = strlen((char const   *)(message));
#line 82
  queue_send(& queue, (void *)(message), tmp + 1UL, prio, 0, (int *)((void *)0));
#line 83
  break;
  case 3: 
#line 87
  now = time((time_t *)((void *)0));
#line 88
  while (1) {
#line 88
    tmp___0 = time((time_t *)((void *)0));
#line 88
    if (! (tmp___0 == now)) {
#line 88
      break;
    }
  }
#line 89
  i = 0;
#line 89
  while (i < 3) {
#line 91
    queue_recv(& queue, (void *)(message), (size_t *)(& buflen), & prio, 0, (int *)((void *)0));
#line 92
    printf((char const   * __restrict  )"Odebrano wiadomosc o dlugosci %d i priorytecie %d: \"%s\"\n",
           buflen, prio, message);
#line 89
    i ++;
  }
#line 94
  break;
  }
#line 96
  return ((void *)0);
}
}
#line 99 "program.c"
void *test2b(void *vptr_args ) 
{ 
  int thread_no ;
  char message[128] ;
  int buflen ;
  int prio ;
  int i ;
  time_t now ;
  size_t tmp ;
  time_t tmp___0 ;

  {
#line 101
  thread_no = (int )vptr_args;
#line 103
  buflen = 128;
#line 105
  switch (thread_no) {
  case 2: 
  case 1: 
  case 0: 
#line 110
  queue_recv(& queue, (void *)(message), (size_t *)(& buflen), & prio, 0, (int *)((void *)0));
#line 111
  printf((char const   * __restrict  )"Watek %d otrzymal wiadomosc o priorytecie %d: \"%s\"\n",
         thread_no, prio, message);
#line 112
  break;
  case 3: 
#line 116
  strcpy((char * __restrict  )(message), (char const   * __restrict  )"Opozniona wiadomosc");
#line 117
  tmp = strlen((char const   *)(message));
#line 117
  buflen = (int )(tmp + 1UL);
#line 118
  i = 0;
#line 118
  while (i < 3) {
#line 120
    now = time((time_t *)((void *)0));
#line 121
    while (1) {
#line 121
      tmp___0 = time((time_t *)((void *)0));
#line 121
      if (! (tmp___0 == now)) {
#line 121
        break;
      }
    }
#line 122
    queue_send(& queue, (void *)(message), (size_t )buflen, i, 0, (int *)((void *)0));
#line 118
    i ++;
  }
#line 124
  break;
  }
#line 126
  return ((void *)0);
}
}
#line 129 "program.c"
void *test3(void *vptr_args ) 
{ 
  int thread_no ;
  char message[128] ;
  int buflen ;
  size_t tmp ;
  int tmp___0 ;

  {
#line 131
  thread_no = (int )vptr_args;
#line 133
  buflen = 128;
#line 134
  switch (thread_no) {
  case 0: 
#line 137
  printf((char const   * __restrict  )"Proba wyslania wiadomosci...\n");
#line 138
  fflush(stdout);
#line 139
  strncpy((char * __restrict  )(message), (char const   * __restrict  )"To jest wiadomosc!",
          (size_t )128);
#line 140
  tmp = strlen((char const   *)(message));
#line 140
  tmp___0 = queue_send(& queue, (void *)(message), tmp + 1UL, 1, 3, (int *)((void *)0));
#line 140
  if (tmp___0 == 1) {
#line 141
    printf((char const   * __restrict  )"Nastapil timeout.\n");
  }
#line 142
  break;
  }
#line 144
  return ((void *)0);
}
}
#line 147 "program.c"
void *test4(void *vptr_args ) 
{ 
  int thread_no ;
  char message[128] ;
  int buflen ;
  time_t now ;
  size_t tmp ;
  int tmp___0 ;
  time_t tmp___1 ;

  {
#line 149
  thread_no = (int )vptr_args;
#line 151
  buflen = 128;
#line 153
  switch (thread_no) {
  case 0: 
#line 156
  stop = 0;
#line 157
  printf((char const   * __restrict  )"Proba wyslania wiadomosci...\n");
#line 158
  fflush(stdout);
#line 159
  strncpy((char * __restrict  )(message), (char const   * __restrict  )"To jest wiadomosc!",
          (size_t )128);
#line 160
  tmp = strlen((char const   *)(message));
#line 160
  tmp___0 = queue_send(& queue, (void *)(message), tmp + 1UL, 1, 0, & stop);
#line 160
  if (tmp___0 == 2) {
#line 161
    printf((char const   * __restrict  )"Nastapilo zatrzymanie przez zmienna stop.\n");
  }
#line 162
  break;
  case 1: 
#line 165
  now = time((time_t *)((void *)0));
#line 166
  while (1) {
#line 166
    tmp___1 = time((time_t *)((void *)0));
#line 166
    if (! (tmp___1 == now)) {
#line 166
      break;
    }
  }
#line 167
  stop = 1;
  }
#line 169
  return ((void *)0);
}
}
#line 1 "queue.o"
#pragma merger("0","/tmp/cil-vwnLUjVR.i","")
#line 465 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 482
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 42 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memcpy)(void * __restrict  __dest ,
                                                                                                 void const   * __restrict  __src ,
                                                                                                 size_t __n ) ;
#line 189 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) clock_t ( __attribute__((__leaf__)) clock)(void) ;
#line 740 "/usr/include/pthread.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) pthread_mutex_init)(pthread_mutex_t *__mutex ,
                                                                                                         pthread_mutexattr_t const   *__mutexattr ) ;
#line 745
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) pthread_mutex_destroy)(pthread_mutex_t *__mutex ) ;
#line 753
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) pthread_mutex_lock)(pthread_mutex_t *__mutex ) ;
#line 764
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) pthread_mutex_unlock)(pthread_mutex_t *__mutex ) ;
#line 7 "queue.c"
node_t *_add(node_t *_queue , void *buf , int buflen , int priority , node_t **new_node ) 
{ 
  node_t *node ;
  node_t *cur_node ;
  node_t *prev_node ;
  void *tmp ;

  {
#line 9
  prev_node = (node_t *)((void *)0);
#line 10
  tmp = malloc(sizeof(node_t ));
#line 10
  node = (node_t *)tmp;
#line 10
  if (! node) {
#line 11
    return ((node_t *)((void *)0));
  }
#line 12
  if ((unsigned long )new_node != (unsigned long )((void *)0)) {
#line 13
    *new_node = node;
  }
#line 14
  node->buf = malloc((size_t )buflen);
#line 15
  memcpy((void * __restrict  )node->buf, (void const   * __restrict  )buf, (size_t )buflen);
#line 16
  node->buflen = (size_t )buflen;
#line 17
  node->priority = priority;
#line 18
  node->next = (struct node *)((void *)0);
#line 19
  node->read = 0;
#line 20
  cur_node = _queue;
#line 20
  while ((unsigned long )cur_node != (unsigned long )((void *)0)) {
#line 22
    if (cur_node->priority > priority) {
#line 24
      node->next = cur_node;
#line 25
      if (prev_node) {
#line 26
        prev_node->next = node;
      } else {
#line 28
        _queue = node;
      }
#line 29
      return (_queue);
    }
#line 31
    prev_node = cur_node;
#line 20
    cur_node = cur_node->next;
  }
#line 33
  if (prev_node) {
#line 34
    prev_node->next = node;
  } else {
#line 36
    _queue = node;
  }
#line 37
  return (_queue);
}
}
#line 43 "queue.c"
int _copy_to_buf(node_t *node , void *buf , size_t *buflen ) 
{ 


  {
#line 45
  if (node->buflen > *buflen) {
#line 46
    return (4);
  }
#line 47
  memcpy((void * __restrict  )buf, (void const   * __restrict  )node->buf, node->buflen);
#line 48
  *buflen = node->buflen;
#line 49
  return (0);
}
}
#line 53 "queue.c"
node_t *_get_first(node_t *_queue ) 
{ 
  node_t *cur_node ;

  {
#line 56
  cur_node = _queue;
#line 56
  while ((unsigned long )cur_node != (unsigned long )((void *)0)) {
#line 57
    if (! cur_node->read) {
#line 58
      return (cur_node);
    }
#line 56
    cur_node = cur_node->next;
  }
#line 59
  return ((node_t *)((void *)0));
}
}
#line 64 "queue.c"
node_t *_delete(node_t *_queue , node_t *target_node ) 
{ 
  node_t *cur_node ;
  node_t *prev_node ;

  {
#line 66
  prev_node = (node_t *)((void *)0);
#line 67
  cur_node = _queue;
#line 67
  while ((unsigned long )cur_node != (unsigned long )((void *)0)) {
#line 68
    if ((unsigned long )cur_node == (unsigned long )target_node) {
#line 70
      if (prev_node) {
#line 71
        prev_node->next = cur_node->next;
      } else {
#line 73
        _queue = cur_node->next;
      }
#line 74
      free(cur_node->buf);
#line 75
      free((void *)cur_node);
#line 76
      return (_queue);
    }
#line 67
    cur_node = cur_node->next;
  }
#line 78
  return (_queue);
}
}
#line 81 "queue.c"
int queue_create(msg_queue_t *new_queue ) 
{ 


  {
#line 83
  new_queue->length = 0;
#line 84
  new_queue->readers = 0;
#line 85
  new_queue->disabled = 0;
#line 86
  new_queue->_queue = (node_t *)((void *)0);
#line 87
  pthread_mutex_init(& new_queue->mutex, (pthread_mutexattr_t const   *)((void *)0));
#line 88
  return (0);
}
}
#line 91 "queue.c"
int queue_send(msg_queue_t *msg_queue , void *buf , size_t buflen , int priority ,
               int timeout , int *stop_signal ) 
{ 
  int result ;
  int disabled ;
  node_t *new_node ;
  clock_t stop___0 ;
  clock_t tmp ;
  clock_t tmp___0 ;

  {
#line 93
  result = -1;
#line 93
  disabled = 0;
#line 96
  tmp = clock();
#line 96
  stop___0 = tmp + (long )timeout * 1000000L;
#line 99
  if (msg_queue->disabled) {
#line 100
    return (5);
  }
#line 102
  pthread_mutex_lock(& msg_queue->mutex);
#line 106
  if (msg_queue->disabled) {
#line 108
    pthread_mutex_unlock(& msg_queue->mutex);
#line 109
    return (5);
  }
#line 111
  (msg_queue->length) ++;
#line 112
  msg_queue->_queue = _add(msg_queue->_queue, buf, (int )buflen, priority, & new_node);
#line 113
  pthread_mutex_unlock(& msg_queue->mutex);
#line 115
  while (1) {
#line 117
    pthread_mutex_lock(& msg_queue->mutex);
#line 118
    if (new_node->read) {
#line 119
      result = 0;
    } else
#line 120
    if (timeout != 0) {
#line 120
      tmp___0 = clock();
#line 120
      if (tmp___0 >= stop___0) {
#line 121
        result = 1;
      } else {
#line 120
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 122
    if ((unsigned long )stop_signal != (unsigned long )((void *)0)) {
#line 122
      if (*stop_signal) {
#line 123
        result = 2;
      }
    }
#line 124
    pthread_mutex_unlock(& msg_queue->mutex);
#line 115
    if (! (result == -1)) {
#line 115
      break;
    }
  }
#line 127
  pthread_mutex_lock(& msg_queue->mutex);
#line 128
  if (result != 0) {
#line 129
    (msg_queue->length) --;
  }
#line 130
  msg_queue->_queue = _delete(msg_queue->_queue, new_node);
#line 131
  pthread_mutex_unlock(& msg_queue->mutex);
#line 132
  return (result);
}
}
#line 135 "queue.c"
int queue_recv(msg_queue_t *msg_queue , void *buf , size_t *buflen , int *priority ,
               int timeout , int *stop_signal ) 
{ 
  int result ;
  node_t *node ;
  clock_t stop___0 ;
  clock_t tmp ;
  clock_t tmp___0 ;

  {
#line 137
  result = -1;
#line 140
  tmp = clock();
#line 140
  stop___0 = tmp + (long )timeout * 1000000L;
#line 143
  if (msg_queue->disabled) {
#line 144
    return (5);
  }
#line 145
  pthread_mutex_lock(& msg_queue->mutex);
#line 146
  if (msg_queue->disabled) {
#line 148
    pthread_mutex_unlock(& msg_queue->mutex);
#line 149
    return (5);
  }
#line 151
  (msg_queue->readers) ++;
#line 152
  pthread_mutex_unlock(& msg_queue->mutex);
#line 153
  while (1) {
#line 155
    pthread_mutex_lock(& msg_queue->mutex);
#line 156
    if (msg_queue->length > 0) {
#line 158
      node = _get_first(msg_queue->_queue);
#line 159
      node->read = 1;
#line 160
      (msg_queue->length) --;
#line 161
      result = _copy_to_buf(node, buf, buflen);
#line 162
      *priority = node->priority;
    } else
#line 164
    if (timeout != 0) {
#line 164
      tmp___0 = clock();
#line 164
      if (tmp___0 >= stop___0) {
#line 165
        result = 1;
      } else {
#line 164
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 166
    if ((unsigned long )stop_signal != (unsigned long )((void *)0)) {
#line 166
      if (*stop_signal) {
#line 167
        result = 2;
      }
    }
#line 168
    pthread_mutex_unlock(& msg_queue->mutex);
#line 153
    if (! (result == -1)) {
#line 153
      break;
    }
  }
#line 170
  pthread_mutex_lock(& msg_queue->mutex);
#line 171
  (msg_queue->readers) --;
#line 172
  pthread_mutex_unlock(& msg_queue->mutex);
#line 173
  return (result);
}
}
#line 176 "queue.c"
int queue_destroy(msg_queue_t *msg_queue ) 
{ 
  node_t *cur_node ;
  node_t *next_node ;
  int busy ;
  int tmp ;

  {
#line 178
  cur_node = msg_queue->_queue;
#line 179
  busy = 0;
#line 180
  pthread_mutex_lock(& msg_queue->mutex);
#line 181
  if (msg_queue->readers) {
#line 181
    tmp = 1;
  } else
#line 181
  if (msg_queue->length) {
#line 181
    tmp = 1;
  } else {
#line 181
    tmp = 0;
  }
#line 181
  busy = tmp;
#line 182
  if (! busy) {
#line 183
    msg_queue->disabled = 1;
  }
#line 184
  pthread_mutex_unlock(& msg_queue->mutex);
#line 186
  if (busy) {
#line 187
    return (3);
  }
#line 188
  pthread_mutex_destroy(& msg_queue->mutex);
#line 190
  while (cur_node) {
#line 192
    next_node = cur_node->next;
#line 193
    free(cur_node->buf);
#line 194
    free((void *)cur_node);
#line 195
    cur_node = next_node;
  }
#line 197
  return (0);
}
}
