// c::__signbitl::1::tag-#anon0
// 
union anon$9;

// c::__signbitl::1::tag-#anon0$link224
// 
union anon$9$link224;

// c::__signbitl::1::tag-#anon0$link229
// 
union anon$9$link229;

// c::__signbitl::1::tag-#anon0$link233
// 
union anon$9$link233;

// c::__signbitl::1::tag-#anon0$link237
// 
union anon$9$link237;

// c::__signbitl::1::tag-#anon0$link243
// 
union anon$9$link243;

// c::__signbitl::1::tag-#anon0$link252
// 
union anon$9$link252;

// c::__signbitl::1::tag-#anon0$link253
// 
union anon$9$link253;

// c::__signbitl::1::tag-#anon0$link254
// 
union anon$9$link254;

// c::__signbitl::1::tag-#anon0$link255
// 
union anon$9$link255;

// c::__signbitl::1::tag-#anon0$link256
// 
union anon$9$link256;

// c::__signbitl::1::tag-#anon0$link260
// 
union anon$9$link260;

// c::__signbitl::1::tag-#anon0$link261
// 
union anon$9$link261;

// c::__signbitl::1::tag-#anon0$link262
// 
union anon$9$link262;

// c::__signbitl::1::tag-#anon0$link263
// 
union anon$9$link263;

// c::__signbitl::1::tag-#anon0$link266
// 
union anon$9$link266;

// c::__signbitl::1::tag-#anon0$link268
// 
union anon$9$link268;

// c::__signbitl::1::tag-#anon0$link273
// 
union anon$9$link273;

// c::__signbitl::1::tag-#anon0$link276
// 
union anon$9$link276;

// c::__signbitl::1::tag-#anon0$link279
// 
union anon$9$link279;

// c::__signbitl::1::tag-#anon0$link280
// 
union anon$9$link280;

// c::__signbitl::1::tag-#anon0$link282
// 
union anon$9$link282;

// c::__signbitl::1::tag-#anon0$link286
// 
union anon$9$link286;

// c::__signbitl::1::tag-#anon0$link287
// 
union anon$9$link287;

// c::__signbitl::1::tag-#anon0$link290
// 
union anon$9$link290;

// c::__signbitl::1::tag-#anon0$link291
// 
union anon$9$link291;

// c::__signbitl::1::tag-#anon0$link292
// 
union anon$9$link292;

// c::__signbitl::1::tag-#anon0$link294
// 
union anon$9$link294;

// c::__signbitl::1::tag-#anon0$link296
// 
union anon$9$link296;

// c::__signbitl::1::tag-#anon0$link298
// 
union anon$9$link298;

// c::__signbitl::1::tag-#anon0$link299
// 
union anon$9$link299;

// c::__signbitl::1::tag-#anon0$link301
// 
union anon$9$link301;

// c::__signbitl::1::tag-#anon0$link302
// 
union anon$9$link302;

// c::__signbitl::1::tag-#anon0$link303
// 
union anon$9$link303;

// c::__signbitl::1::tag-#anon0$link304
// 
union anon$9$link304;

// c::__signbitl::1::tag-#anon0$link305
// 
union anon$9$link305;

// c::__signbitl::1::tag-#anon0$link306
// 
union anon$9$link306;

// c::__signbitl::1::tag-#anon0$link5
// 
union anon$9$link5;

// c::tag-#anon#ST[*{*{S8}}'filenames'||S32'numfiles'||S32'useoutfilename'||ARR0000000000000000000000000000000000000000000000000001000000000000{S8}'outfilename'||S32'outimageformat'||S32'verbosemode'||S32'aa_maxsamples'||S32'boundmode'||S32'boundthresh'||S32'usecamfile'||ARR0000000000000000000000000000000000000000000000000001000000000000{S8}'camfilename'||S32'shadermode'||S32'phongfunc'||S32'transmode'||S32'fogmode'||S32'numthreads'||S32'nosave'||S32'xsize'||S32'ysize'||S32'normalfixupmode'||S32'imgprocess'||F32'imggamma'||F32'rescale_lights'||F32'auto_skylight'||F32'add_skylight'||S32'skylight_samples'||ARR0000000000000000000000000000000000000000000000000001000000000000{S8}'spaceball'||S32'cropmode'||S32'cropxres'||S32'cropyres'||S32'cropxstart'||S32'cropystart'|]
// 
struct anon$1;

// c::tag-#anon#ST[*{P(*{V})->V}'freetex'|]
// 
struct anon$24;

// c::tag-#anon#ST[*{P(*{cV}|*{V})->V}'intersect'||*{P(*{cV}|*{cV}|*{cV}|*{V})->V}'normal'||*{P(*{V}|*{SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#}|*{SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#})->S32}'bbox'||*{P(*{V})->V}'freeobj'|]
// 
struct anon$23;

// c::tag-#anon#ST[*{P(*{cV}|*{cV}|*{V})->SYM#c::tag-#anon#ST[F32'r'||F32'g'||F32'b'|]#}'texfunc'||*{SYM#c::tag-#anon#ST[*{P(*{V})->V}'freetex'|]#}'methods'||U32'flags'||F32'ambient'||F32'diffuse'||F32'phong'||F32'phongexp'||S32'phongtype'||F32'specular'||F32'opacity'||F32'outline'||F32'outlinewidth'|]
// 
struct anon$25;

// c::tag-#anon#ST[*{P(*{cV}|*{cV}|*{V})->SYM#c::tag-#anon#ST[F32'r'||F32'g'||F32'b'|]#}'texfunc'||*{SYM#c::tag-#anon#ST[*{P(*{V})->V}'freetex'|]#}'methods'||U32'flags'||F32'ambient'||F32'diffuse'||F32'phong'||F32'phongexp'||S32'phongtype'||F32'specular'||F32'opacity'||F32'outline'||F32'outlinewidth'||*{V}'obj'||SYM#c::tag-#anon#ST[F32'r'||F32'g'||F32'b'|]#'c0'||SYM#c::tag-#anon#ST[F32'r'||F32'g'||F32'b'|]#'c1'||SYM#c::tag-#anon#ST[F32'r'||F32'g'||F32'b'|]#'c2'||U32'$pad0'|]
// 
struct anon$36;

// c::tag-#anon#ST[*{P(*{cV}|*{cV}|*{V})->SYM#c::tag-#anon#ST[F32'r'||F32'g'||F32'b'|]#}'texfunc'||*{SYM#c::tag-#anon#ST[*{P(*{V})->V}'freetex'|]#}'methods'||U32'flags'||F32'ambient'||F32'diffuse'||F32'phong'||F32'phongexp'||S32'phongtype'||F32'specular'||F32'opacity'||F32'outline'||F32'outlinewidth'||SYM#c::tag-#anon#ST[F32'r'||F32'g'||F32'b'|]#'col'||U32'$pad0'||SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#'ctr'||SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#'rot'||SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#'scale'||SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#'uaxs'||SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#'vaxs'||SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#'waxs'||*{V}'img'||*{V}'obj'|]
// 
struct anon$35;

// c::tag-#anon#ST[*{S8}'name'||*{V}'tex'|]
// 
struct anon$5;

// c::tag-#anon#ST[*{SYM#c::tag-#anon#ST[U32'id'||U32'$pad0'||*{V}'nextobj'||*{SYM#c::tag-#anon#ST[*{P(*{cV}|*{V})->V}'intersect'||*{P(*{cV}|*{cV}|*{cV}|*{V})->V}'normal'||*{P(*{V}|*{SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#}|*{SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#})->S32}'bbox'||*{P(*{V})->V}'freeobj'|]#}'methods'||*{SYM#c::tag-#anon#ST[S32'numplanes'||U32'$pad0'||*{F64}'planes'|]#}'clip'||*{SYM#c::tag-#anon#ST[*{P(*{cV}|*{cV}|*{V})->SYM#c::tag-#anon#ST[F32'r'||F32'g'||F32'b'|]#}'texfunc'||*{SYM#c::tag-#anon#ST[*{P(*{V})->V}'freetex'|]#}'methods'||U32'flags'||F32'ambient'||F32'diffuse'||F32'phong'||F32'phongexp'||S32'phongtype'||F32'specular'||F32'opacity'||F32'outline'||F32'outlinewidth'|]#}'tex'|]#}'boundedobj'||*{SYM#c::tag-#anon#ST[U32'id'||U32'$pad0'||*{V}'nextobj'||*{SYM#c::tag-#anon#ST[*{P(*{cV}|*{V})->V}'intersect'||*{P(*{cV}|*{cV}|*{cV}|*{V})->V}'normal'||*{P(*{V}|*{SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#}|*{SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#})->S32}'bbox'||*{P(*{V})->V}'freeobj'|]#}'methods'||*{SYM#c::tag-#anon#ST[S32'numplanes'||U32'$pad0'||*{F64}'planes'|]#}'clip'||*{SYM#c::tag-#anon#ST[*{P(*{cV}|*{cV}|*{V})->SYM#c::tag-#anon#ST[F32'r'||F32'g'||F32'b'|]#}'texfunc'||*{SYM#c::tag-#anon#ST[*{P(*{V})->V}'freetex'|]#}'methods'||U32'flags'||F32'ambient'||F32'diffuse'||F32'phong'||F32'phongexp'||S32'phongtype'||F32'specular'||F32'opacity'||F32'outline'||F32'outlinewidth'|]#}'tex'|]#}'unboundedobj'||S32'numobjects'||U32'$pad0'|]
// 
struct anon$21;

// c::tag-#anon#ST[*{SYM#c::tag-_IO_FILE#}'ifp'||*{cS8}'filename'||*{SYM#c::tag-#anon#ST[*{S8}'name'||*{V}'tex'|]#}'textable'||SYM#c::tag-#anon#ST[*{S8}'name'||*{V}'tex'|]#'defaulttex'||S32'numtextures'||S32'maxtextures'||S32'numobjectsparsed'||U32'$pad0'||SYM#c::tag-rt_hash_t#'texhash'|]
// 
struct anon$6;

// c::tag-#anon#ST[*{cSYM#c::tag-#anon#ST[U32'id'||U32'$pad0'||*{V}'nextobj'||*{SYM#c::tag-#anon#ST[*{P(*{cV}|*{V})->V}'intersect'||*{P(*{cV}|*{cV}|*{cV}|*{V})->V}'normal'||*{P(*{V}|*{SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#}|*{SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#})->S32}'bbox'||*{P(*{V})->V}'freeobj'|]#}'methods'||*{SYM#c::tag-#anon#ST[S32'numplanes'||U32'$pad0'||*{F64}'planes'|]#}'clip'||*{SYM#c::tag-#anon#ST[*{P(*{cV}|*{cV}|*{V})->SYM#c::tag-#anon#ST[F32'r'||F32'g'||F32'b'|]#}'texfunc'||*{SYM#c::tag-#anon#ST[*{P(*{V})->V}'freetex'|]#}'methods'||U32'flags'||F32'ambient'||F32'diffuse'||F32'phong'||F32'phongexp'||S32'phongtype'||F32'specular'||F32'opacity'||F32'outline'||F32'outlinewidth'|]#}'tex'|]#}'obj'||F64't'|]
// 
struct anon$37;

// c::tag-#anon#ST[ARR0000000000000000000000000000000000000000000000000000000000011000{S8}'name'||*{V}'tex'|]
// 
struct anon$11;

// c::tag-#anon#ST[ARR0000000000000000000000000000000000000000000000000000000100000000{S8}'outfilename'||S32'writeimagefile'||U32'$pad0'||*{V}'img'||S32'imginternal'||S32'imgprocess'||F32'imggamma'||S32'imgbufformat'||S32'imgfileformat'||SYM#c::tag-#anon#ST[S32'cropmode'||S32'xres'||S32'yres'||S32'xstart'||S32'ystart'|]#'imgcrop'||S32'numthreads'||S32'nodes'||S32'mynode'||U32'$pad1'||*{SYM#c::tag-#anon#ST[S32'numcpus'||U32'$pad0'||F64'cpuspeed'||F64'nodespeed'||ARR0000000000000000000000000000000000000000000000000000001000000000{S8}'machname'|]#}'cpuinfo'||S32'hres'||S32'vres'||F64'aspectratio'||S32'raydepth'||S32'antialiasing'||S32'verbosemode'||S32'boundmode'||S32'boundthresh'||U32'$pad2'||*{SYM#c::tag-list#}'texlist'||*{SYM#c::tag-list#}'cliplist'||U32'flags'||U32'$pad3'||SYM#c::tag-#anon#ST[S32'projection'||U32'$pad0'||SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#'center'||SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#'viewvec'||SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#'rightvec'||SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#'upvec'||F64'camzoom'||F64'px'||F64'py'||F64'psx'||F64'psy'||F64'focallength'||F64'left'||F64'right'||F64'top'||F64'bottom'||F64'aperture'||SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#'projcent'||*{P(*{V}|F64|F64)->SYM#c::tag-#anon#ST[F32'r'||F32'g'||F32'b'|]#}'cam_ray'||SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#'lowleft'||SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#'iplaneright'||SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#'iplaneup'|]#'camera'||*{P(*{V})->SYM#c::tag-#anon#ST[F32'r'||F32'g'||F32'b'|]#}'shader'||*{P(*{cSYM#c::tag-ray_t#}|*{cSYM#c::tag-#anon#ST[SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#'hit'||SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#'N'||SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#'L'||F64'Llen'|]#}|F64)->F64}'phongfunc'||S32'transmode'||U32'$pad4'||SYM#c::tag-#anon#ST[SYM#c::tag-#anon#ST[F32'r'||F32'g'||F32'b'|]#'background'||U32'$pad0'||SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#'gradient'||F64'gradtopval'||F64'gradbotval'||SYM#c::tag-#anon#ST[F32'r'||F32'g'||F32'b'|]#'backgroundtop'||SYM#c::tag-#anon#ST[F32'r'||F32'g'||F32'b'|]#'backgroundbot'|]#'bgtex'||*{P(*{cSYM#c::tag-ray_t#})->SYM#c::tag-#anon#ST[F32'r'||F32'g'||F32'b'|]#}'bgtexfunc'||SYM#c::tag-fogdata_t#'fog'||SYM#c::tag-#anon#ST[*{SYM#c::tag-#anon#ST[U32'id'||U32'$pad0'||*{V}'nextobj'||*{SYM#c::tag-#anon#ST[*{P(*{cV}|*{V})->V}'intersect'||*{P(*{cV}|*{cV}|*{cV}|*{V})->V}'normal'||*{P(*{V}|*{SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#}|*{SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#})->S32}'bbox'||*{P(*{V})->V}'freeobj'|]#}'methods'||*{SYM#c::tag-#anon#ST[S32'numplanes'||U32'$pad0'||*{F64}'planes'|]#}'clip'||*{SYM#c::tag-#anon#ST[*{P(*{cV}|*{cV}|*{V})->SYM#c::tag-#anon#ST[F32'r'||F32'g'||F32'b'|]#}'texfunc'||*{SYM#c::tag-#anon#ST[*{P(*{V})->V}'freetex'|]#}'methods'||U32'flags'||F32'ambient'||F32'diffuse'||F32'phong'||F32'phongexp'||S32'phongtype'||F32'specular'||F32'opacity'||F32'outline'||F32'outlinewidth'|]#}'tex'|]#}'boundedobj'||*{SYM#c::tag-#anon#ST[U32'id'||U32'$pad0'||*{V}'nextobj'||*{SYM#c::tag-#anon#ST[*{P(*{cV}|*{V})->V}'intersect'||*{P(*{cV}|*{cV}|*{cV}|*{V})->V}'normal'||*{P(*{V}|*{SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#}|*{SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#})->S32}'bbox'||*{P(*{V})->V}'freeobj'|]#}'methods'||*{SYM#c::tag-#anon#ST[S32'numplanes'||U32'$pad0'||*{F64}'planes'|]#}'clip'||*{SYM#c::tag-#anon#ST[*{P(*{cV}|*{cV}|*{V})->SYM#c::tag-#anon#ST[F32'r'||F32'g'||F32'b'|]#}'texfunc'||*{SYM#c::tag-#anon#ST[*{P(*{V})->V}'freetex'|]#}'methods'||U32'flags'||F32'ambient'||F32'diffuse'||F32'phong'||F32'phongexp'||S32'phongtype'||F32'specular'||F32'opacity'||F32'outline'||F32'outlinewidth'|]#}'tex'|]#}'unboundedobj'||S32'numobjects'||U32'$pad0'|]#'objgroup'||*{SYM#c::tag-list#}'lightlist'||F64'light_scale'||S32'numlights'||SYM#c::tag-amboccdata_t#'ambocc'||S32'scenecheck'||*{V}'parbuf'||*{V}'threads'||*{V}'threadparms'||*{SYM#c::tag-#anon#ST[S32'numplanes'||U32'$pad0'||*{F64}'planes'|]#}'curclipgroup'||S32'normalfixupmode'||U32'$pad5'|]
// 
struct anon$17;

// c::tag-#anon#ST[ARR0000000000000000000000000000000000000000000000000000000100000000{S8}'outfilename'||S32'writeimagefile'||U32'$pad0'||*{V}'img'||S32'imginternal'||S32'imgprocess'||F32'imggamma'||S32'imgbufformat'||S32'imgfileformat'||SYM#c::tag-#anon#ST[S32'cropmode'||S32'xres'||S32'yres'||S32'xstart'||S32'ystart'|]#'imgcrop'||S32'numthreads'||S32'nodes'||S32'mynode'||U32'$pad1'||*{SYM#c::tag-#anon#ST[S32'numcpus'||U32'$pad0'||F64'cpuspeed'||F64'nodespeed'||ARR0000000000000000000000000000000000000000000000000000001000000000{S8}'machname'|]#}'cpuinfo'||S32'hres'||S32'vres'||F64'aspectratio'||S32'raydepth'||S32'antialiasing'||S32'verbosemode'||S32'boundmode'||S32'boundthresh'||U32'$pad2'||*{SYM#c::tag-list#}'texlist'||*{SYM#c::tag-list#}'cliplist'||U32'flags'||U32'$pad3'||SYM#c::tag-#anon#ST[S32'projection'||U32'$pad0'||SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#'center'||SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#'viewvec'||SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#'rightvec'||SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#'upvec'||F64'camzoom'||F64'px'||F64'py'||F64'psx'||F64'psy'||F64'focallength'||F64'left'||F64'right'||F64'top'||F64'bottom'||F64'aperture'||SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#'projcent'||*{P(*{V}|F64|F64)->SYM#c::tag-#anon#ST[F32'r'||F32'g'||F32'b'|]#}'cam_ray'||SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#'lowleft'||SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#'iplaneright'||SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#'iplaneup'|]#'camera'||*{P(*{V})->SYM#c::tag-#anon#ST[F32'r'||F32'g'||F32'b'|]#}'shader'||*{P(*{cSYM#c::tag-ray_t#}|*{cSYM#c::tag-#anon#ST[SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#'hit'||SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#'N'||SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#'L'||F64'Llen'|]#}|F64)->F64}'phongfunc'||S32'transmode'||U32'$pad4'||SYM#c::tag-#anon#ST[SYM#c::tag-#anon#ST[F32'r'||F32'g'||F32'b'|]#'background'||U32'$pad0'||SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#'gradient'||F64'gradtopval'||F64'gradbotval'||SYM#c::tag-#anon#ST[F32'r'||F32'g'||F32'b'|]#'backgroundtop'||SYM#c::tag-#anon#ST[F32'r'||F32'g'||F32'b'|]#'backgroundbot'|]#'bgtex'||*{P(*{cSYM#c::tag-ray_t#})->SYM#c::tag-#anon#ST[F32'r'||F32'g'||F32'b'|]#}'bgtexfunc'||SYM#c::tag-fogdata_t#'fog'||SYM#c::tag-#anon#ST[*{SYM#c::tag-#anon#ST[U32'id'||U32'$pad0'||*{V}'nextobj'||*{SYM#c::tag-#anon#ST[*{P(*{cV}|*{V})->V}'intersect'||*{P(*{cV}|*{cV}|*{cV}|*{V})->V}'normal'||*{P(*{V}|*{SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#}|*{SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#})->S32}'bbox'||*{P(*{V})->V}'freeobj'|]#}'methods'||*{SYM#c::tag-#anon#ST[S32'numplanes'||U32'$pad0'||*{F64}'planes'|]#}'clip'||*{SYM#c::tag-#anon#ST[*{P(*{cV}|*{cV}|*{V})->SYM#c::tag-#anon#ST[F32'r'||F32'g'||F32'b'|]#}'texfunc'||*{SYM#c::tag-#anon#ST[*{P(*{V})->V}'freetex'|]#}'methods'||U32'flags'||F32'ambient'||F32'diffuse'||F32'phong'||F32'phongexp'||S32'phongtype'||F32'specular'||F32'opacity'||F32'outline'||F32'outlinewidth'|]#}'tex'|]#}'boundedobj'||*{SYM#c::tag-#anon#ST[U32'id'||U32'$pad0'||*{V}'nextobj'||*{SYM#c::tag-#anon#ST[*{P(*{cV}|*{V})->V}'intersect'||*{P(*{cV}|*{cV}|*{cV}|*{V})->V}'normal'||*{P(*{V}|*{SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#}|*{SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#})->S32}'bbox'||*{P(*{V})->V}'freeobj'|]#}'methods'||*{SYM#c::tag-#anon#ST[S32'numplanes'||U32'$pad0'||*{F64}'planes'|]#}'clip'||*{SYM#c::tag-#anon#ST[*{P(*{cV}|*{cV}|*{V})->SYM#c::tag-#anon#ST[F32'r'||F32'g'||F32'b'|]#}'texfunc'||*{SYM#c::tag-#anon#ST[*{P(*{V})->V}'freetex'|]#}'methods'||U32'flags'||F32'ambient'||F32'diffuse'||F32'phong'||F32'phongexp'||S32'phongtype'||F32'specular'||F32'opacity'||F32'outline'||F32'outlinewidth'|]#}'tex'|]#}'unboundedobj'||S32'numobjects'||U32'$pad0'|]#'objgroup'||*{SYM#c::tag-list#}'lightlist'||F64'light_scale'||S32'numlights'||SYM#c::tag-amboccdata_t#'ambocc'||S32'scenecheck'||*{V}'parbuf'||*{V}'threads'||*{V}'threadparms'||*{SYM#c::tag-#anon#ST[S32'numplanes'||U32'$pad0'||*{F64}'planes'|]#}'curclipgroup'||S32'normalfixupmode'||U32'$pad5'|]$link108
// 
struct anon$30$link108;

// c::tag-#anon#ST[ARR0000000000000000000000000000000000000000000000000000000100000000{S8}'outfilename'||S32'writeimagefile'||U32'$pad0'||*{V}'img'||S32'imginternal'||S32'imgprocess'||F32'imggamma'||S32'imgbufformat'||S32'imgfileformat'||SYM#c::tag-#anon#ST[S32'cropmode'||S32'xres'||S32'yres'||S32'xstart'||S32'ystart'|]#'imgcrop'||S32'numthreads'||S32'nodes'||S32'mynode'||U32'$pad1'||*{SYM#c::tag-#anon#ST[S32'numcpus'||U32'$pad0'||F64'cpuspeed'||F64'nodespeed'||ARR0000000000000000000000000000000000000000000000000000001000000000{S8}'machname'|]#}'cpuinfo'||S32'hres'||S32'vres'||F64'aspectratio'||S32'raydepth'||S32'antialiasing'||S32'verbosemode'||S32'boundmode'||S32'boundthresh'||U32'$pad2'||*{SYM#c::tag-list#}'texlist'||*{SYM#c::tag-list#}'cliplist'||U32'flags'||U32'$pad3'||SYM#c::tag-#anon#ST[S32'projection'||U32'$pad0'||SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#'center'||SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#'viewvec'||SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#'rightvec'||SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#'upvec'||F64'camzoom'||F64'px'||F64'py'||F64'psx'||F64'psy'||F64'focallength'||F64'left'||F64'right'||F64'top'||F64'bottom'||F64'aperture'||SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#'projcent'||*{P(*{V}|F64|F64)->SYM#c::tag-#anon#ST[F32'r'||F32'g'||F32'b'|]#}'cam_ray'||SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#'lowleft'||SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#'iplaneright'||SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#'iplaneup'|]#'camera'||*{P(*{V})->SYM#c::tag-#anon#ST[F32'r'||F32'g'||F32'b'|]#}'shader'||*{P(*{cSYM#c::tag-ray_t#}|*{cSYM#c::tag-#anon#ST[SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#'hit'||SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#'N'||SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#'L'||F64'Llen'|]#}|F64)->F64}'phongfunc'||S32'transmode'||U32'$pad4'||SYM#c::tag-#anon#ST[SYM#c::tag-#anon#ST[F32'r'||F32'g'||F32'b'|]#'background'||U32'$pad0'||SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#'gradient'||F64'gradtopval'||F64'gradbotval'||SYM#c::tag-#anon#ST[F32'r'||F32'g'||F32'b'|]#'backgroundtop'||SYM#c::tag-#anon#ST[F32'r'||F32'g'||F32'b'|]#'backgroundbot'|]#'bgtex'||*{P(*{cSYM#c::tag-ray_t#})->SYM#c::tag-#anon#ST[F32'r'||F32'g'||F32'b'|]#}'bgtexfunc'||SYM#c::tag-fogdata_t#'fog'||SYM#c::tag-#anon#ST[*{SYM#c::tag-#anon#ST[U32'id'||U32'$pad0'||*{V}'nextobj'||*{SYM#c::tag-#anon#ST[*{P(*{cV}|*{V})->V}'intersect'||*{P(*{cV}|*{cV}|*{cV}|*{V})->V}'normal'||*{P(*{V}|*{SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#}|*{SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#})->S32}'bbox'||*{P(*{V})->V}'freeobj'|]#}'methods'||*{SYM#c::tag-#anon#ST[S32'numplanes'||U32'$pad0'||*{F64}'planes'|]#}'clip'||*{SYM#c::tag-#anon#ST[*{P(*{cV}|*{cV}|*{V})->SYM#c::tag-#anon#ST[F32'r'||F32'g'||F32'b'|]#}'texfunc'||*{SYM#c::tag-#anon#ST[*{P(*{V})->V}'freetex'|]#}'methods'||U32'flags'||F32'ambient'||F32'diffuse'||F32'phong'||F32'phongexp'||S32'phongtype'||F32'specular'||F32'opacity'||F32'outline'||F32'outlinewidth'|]#}'tex'|]#}'boundedobj'||*{SYM#c::tag-#anon#ST[U32'id'||U32'$pad0'||*{V}'nextobj'||*{SYM#c::tag-#anon#ST[*{P(*{cV}|*{V})->V}'intersect'||*{P(*{cV}|*{cV}|*{cV}|*{V})->V}'normal'||*{P(*{V}|*{SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#}|*{SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#})->S32}'bbox'||*{P(*{V})->V}'freeobj'|]#}'methods'||*{SYM#c::tag-#anon#ST[S32'numplanes'||U32'$pad0'||*{F64}'planes'|]#}'clip'||*{SYM#c::tag-#anon#ST[*{P(*{cV}|*{cV}|*{V})->SYM#c::tag-#anon#ST[F32'r'||F32'g'||F32'b'|]#}'texfunc'||*{SYM#c::tag-#anon#ST[*{P(*{V})->V}'freetex'|]#}'methods'||U32'flags'||F32'ambient'||F32'diffuse'||F32'phong'||F32'phongexp'||S32'phongtype'||F32'specular'||F32'opacity'||F32'outline'||F32'outlinewidth'|]#}'tex'|]#}'unboundedobj'||S32'numobjects'||U32'$pad0'|]#'objgroup'||*{SYM#c::tag-list#}'lightlist'||F64'light_scale'||S32'numlights'||SYM#c::tag-amboccdata_t#'ambocc'||S32'scenecheck'||*{V}'parbuf'||*{V}'threads'||*{V}'threadparms'||*{SYM#c::tag-#anon#ST[S32'numplanes'||U32'$pad0'||*{F64}'planes'|]#}'curclipgroup'||S32'normalfixupmode'||U32'$pad5'|]$link111
// 
struct anon$39$link111;

// c::tag-#anon#ST[ARR0000000000000000000000000000000000000000000000000000000100000000{S8}'outfilename'||S32'writeimagefile'||U32'$pad0'||*{V}'img'||S32'imginternal'||S32'imgprocess'||F32'imggamma'||S32'imgbufformat'||S32'imgfileformat'||SYM#c::tag-#anon#ST[S32'cropmode'||S32'xres'||S32'yres'||S32'xstart'||S32'ystart'|]#'imgcrop'||S32'numthreads'||S32'nodes'||S32'mynode'||U32'$pad1'||*{SYM#c::tag-#anon#ST[S32'numcpus'||U32'$pad0'||F64'cpuspeed'||F64'nodespeed'||ARR0000000000000000000000000000000000000000000000000000001000000000{S8}'machname'|]#}'cpuinfo'||S32'hres'||S32'vres'||F64'aspectratio'||S32'raydepth'||S32'antialiasing'||S32'verbosemode'||S32'boundmode'||S32'boundthresh'||U32'$pad2'||*{SYM#c::tag-list#}'texlist'||*{SYM#c::tag-list#}'cliplist'||U32'flags'||U32'$pad3'||SYM#c::tag-#anon#ST[S32'projection'||U32'$pad0'||SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#'center'||SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#'viewvec'||SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#'rightvec'||SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#'upvec'||F64'camzoom'||F64'px'||F64'py'||F64'psx'||F64'psy'||F64'focallength'||F64'left'||F64'right'||F64'top'||F64'bottom'||F64'aperture'||SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#'projcent'||*{P(*{V}|F64|F64)->SYM#c::tag-#anon#ST[F32'r'||F32'g'||F32'b'|]#}'cam_ray'||SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#'lowleft'||SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#'iplaneright'||SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#'iplaneup'|]#'camera'||*{P(*{V})->SYM#c::tag-#anon#ST[F32'r'||F32'g'||F32'b'|]#}'shader'||*{P(*{cSYM#c::tag-ray_t#}|*{cSYM#c::tag-#anon#ST[SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#'hit'||SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#'N'||SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#'L'||F64'Llen'|]#}|F64)->F64}'phongfunc'||S32'transmode'||U32'$pad4'||SYM#c::tag-#anon#ST[SYM#c::tag-#anon#ST[F32'r'||F32'g'||F32'b'|]#'background'||U32'$pad0'||SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#'gradient'||F64'gradtopval'||F64'gradbotval'||SYM#c::tag-#anon#ST[F32'r'||F32'g'||F32'b'|]#'backgroundtop'||SYM#c::tag-#anon#ST[F32'r'||F32'g'||F32'b'|]#'backgroundbot'|]#'bgtex'||*{P(*{cSYM#c::tag-ray_t#})->SYM#c::tag-#anon#ST[F32'r'||F32'g'||F32'b'|]#}'bgtexfunc'||SYM#c::tag-fogdata_t#'fog'||SYM#c::tag-#anon#ST[*{SYM#c::tag-#anon#ST[U32'id'||U32'$pad0'||*{V}'nextobj'||*{SYM#c::tag-#anon#ST[*{P(*{cV}|*{V})->V}'intersect'||*{P(*{cV}|*{cV}|*{cV}|*{V})->V}'normal'||*{P(*{V}|*{SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#}|*{SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#})->S32}'bbox'||*{P(*{V})->V}'freeobj'|]#}'methods'||*{SYM#c::tag-#anon#ST[S32'numplanes'||U32'$pad0'||*{F64}'planes'|]#}'clip'||*{SYM#c::tag-#anon#ST[*{P(*{cV}|*{cV}|*{V})->SYM#c::tag-#anon#ST[F32'r'||F32'g'||F32'b'|]#}'texfunc'||*{SYM#c::tag-#anon#ST[*{P(*{V})->V}'freetex'|]#}'methods'||U32'flags'||F32'ambient'||F32'diffuse'||F32'phong'||F32'phongexp'||S32'phongtype'||F32'specular'||F32'opacity'||F32'outline'||F32'outlinewidth'|]#}'tex'|]#}'boundedobj'||*{SYM#c::tag-#anon#ST[U32'id'||U32'$pad0'||*{V}'nextobj'||*{SYM#c::tag-#anon#ST[*{P(*{cV}|*{V})->V}'intersect'||*{P(*{cV}|*{cV}|*{cV}|*{V})->V}'normal'||*{P(*{V}|*{SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#}|*{SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#})->S32}'bbox'||*{P(*{V})->V}'freeobj'|]#}'methods'||*{SYM#c::tag-#anon#ST[S32'numplanes'||U32'$pad0'||*{F64}'planes'|]#}'clip'||*{SYM#c::tag-#anon#ST[*{P(*{cV}|*{cV}|*{V})->SYM#c::tag-#anon#ST[F32'r'||F32'g'||F32'b'|]#}'texfunc'||*{SYM#c::tag-#anon#ST[*{P(*{V})->V}'freetex'|]#}'methods'||U32'flags'||F32'ambient'||F32'diffuse'||F32'phong'||F32'phongexp'||S32'phongtype'||F32'specular'||F32'opacity'||F32'outline'||F32'outlinewidth'|]#}'tex'|]#}'unboundedobj'||S32'numobjects'||U32'$pad0'|]#'objgroup'||*{SYM#c::tag-list#}'lightlist'||F64'light_scale'||S32'numlights'||SYM#c::tag-amboccdata_t#'ambocc'||S32'scenecheck'||*{V}'parbuf'||*{V}'threads'||*{V}'threadparms'||*{SYM#c::tag-#anon#ST[S32'numplanes'||U32'$pad0'||*{F64}'planes'|]#}'curclipgroup'||S32'normalfixupmode'||U32'$pad5'|]$link112
// 
struct anon$59$link112;

// c::tag-#anon#ST[ARR0000000000000000000000000000000000000000000000000000000100000000{S8}'outfilename'||S32'writeimagefile'||U32'$pad0'||*{V}'img'||S32'imginternal'||S32'imgprocess'||F32'imggamma'||S32'imgbufformat'||S32'imgfileformat'||SYM#c::tag-#anon#ST[S32'cropmode'||S32'xres'||S32'yres'||S32'xstart'||S32'ystart'|]#'imgcrop'||S32'numthreads'||S32'nodes'||S32'mynode'||U32'$pad1'||*{SYM#c::tag-#anon#ST[S32'numcpus'||U32'$pad0'||F64'cpuspeed'||F64'nodespeed'||ARR0000000000000000000000000000000000000000000000000000001000000000{S8}'machname'|]#}'cpuinfo'||S32'hres'||S32'vres'||F64'aspectratio'||S32'raydepth'||S32'antialiasing'||S32'verbosemode'||S32'boundmode'||S32'boundthresh'||U32'$pad2'||*{SYM#c::tag-list#}'texlist'||*{SYM#c::tag-list#}'cliplist'||U32'flags'||U32'$pad3'||SYM#c::tag-#anon#ST[S32'projection'||U32'$pad0'||SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#'center'||SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#'viewvec'||SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#'rightvec'||SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#'upvec'||F64'camzoom'||F64'px'||F64'py'||F64'psx'||F64'psy'||F64'focallength'||F64'left'||F64'right'||F64'top'||F64'bottom'||F64'aperture'||SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#'projcent'||*{P(*{V}|F64|F64)->SYM#c::tag-#anon#ST[F32'r'||F32'g'||F32'b'|]#}'cam_ray'||SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#'lowleft'||SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#'iplaneright'||SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#'iplaneup'|]#'camera'||*{P(*{V})->SYM#c::tag-#anon#ST[F32'r'||F32'g'||F32'b'|]#}'shader'||*{P(*{cSYM#c::tag-ray_t#}|*{cSYM#c::tag-#anon#ST[SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#'hit'||SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#'N'||SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#'L'||F64'Llen'|]#}|F64)->F64}'phongfunc'||S32'transmode'||U32'$pad4'||SYM#c::tag-#anon#ST[SYM#c::tag-#anon#ST[F32'r'||F32'g'||F32'b'|]#'background'||U32'$pad0'||SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#'gradient'||F64'gradtopval'||F64'gradbotval'||SYM#c::tag-#anon#ST[F32'r'||F32'g'||F32'b'|]#'backgroundtop'||SYM#c::tag-#anon#ST[F32'r'||F32'g'||F32'b'|]#'backgroundbot'|]#'bgtex'||*{P(*{cSYM#c::tag-ray_t#})->SYM#c::tag-#anon#ST[F32'r'||F32'g'||F32'b'|]#}'bgtexfunc'||SYM#c::tag-fogdata_t#'fog'||SYM#c::tag-#anon#ST[*{SYM#c::tag-#anon#ST[U32'id'||U32'$pad0'||*{V}'nextobj'||*{SYM#c::tag-#anon#ST[*{P(*{cV}|*{V})->V}'intersect'||*{P(*{cV}|*{cV}|*{cV}|*{V})->V}'normal'||*{P(*{V}|*{SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#}|*{SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#})->S32}'bbox'||*{P(*{V})->V}'freeobj'|]#}'methods'||*{SYM#c::tag-#anon#ST[S32'numplanes'||U32'$pad0'||*{F64}'planes'|]#}'clip'||*{SYM#c::tag-#anon#ST[*{P(*{cV}|*{cV}|*{V})->SYM#c::tag-#anon#ST[F32'r'||F32'g'||F32'b'|]#}'texfunc'||*{SYM#c::tag-#anon#ST[*{P(*{V})->V}'freetex'|]#}'methods'||U32'flags'||F32'ambient'||F32'diffuse'||F32'phong'||F32'phongexp'||S32'phongtype'||F32'specular'||F32'opacity'||F32'outline'||F32'outlinewidth'|]#}'tex'|]#}'boundedobj'||*{SYM#c::tag-#anon#ST[U32'id'||U32'$pad0'||*{V}'nextobj'||*{SYM#c::tag-#anon#ST[*{P(*{cV}|*{V})->V}'intersect'||*{P(*{cV}|*{cV}|*{cV}|*{V})->V}'normal'||*{P(*{V}|*{SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#}|*{SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#})->S32}'bbox'||*{P(*{V})->V}'freeobj'|]#}'methods'||*{SYM#c::tag-#anon#ST[S32'numplanes'||U32'$pad0'||*{F64}'planes'|]#}'clip'||*{SYM#c::tag-#anon#ST[*{P(*{cV}|*{cV}|*{V})->SYM#c::tag-#anon#ST[F32'r'||F32'g'||F32'b'|]#}'texfunc'||*{SYM#c::tag-#anon#ST[*{P(*{V})->V}'freetex'|]#}'methods'||U32'flags'||F32'ambient'||F32'diffuse'||F32'phong'||F32'phongexp'||S32'phongtype'||F32'specular'||F32'opacity'||F32'outline'||F32'outlinewidth'|]#}'tex'|]#}'unboundedobj'||S32'numobjects'||U32'$pad0'|]#'objgroup'||*{SYM#c::tag-list#}'lightlist'||F64'light_scale'||S32'numlights'||SYM#c::tag-amboccdata_t#'ambocc'||S32'scenecheck'||*{V}'parbuf'||*{V}'threads'||*{V}'threadparms'||*{SYM#c::tag-#anon#ST[S32'numplanes'||U32'$pad0'||*{F64}'planes'|]#}'curclipgroup'||S32'normalfixupmode'||U32'$pad5'|]$link120
// 
struct anon$48$link120;

// c::tag-#anon#ST[ARR0000000000000000000000000000000000000000000000000000000100000000{S8}'outfilename'||S32'writeimagefile'||U32'$pad0'||*{V}'img'||S32'imginternal'||S32'imgprocess'||F32'imggamma'||S32'imgbufformat'||S32'imgfileformat'||SYM#c::tag-#anon#ST[S32'cropmode'||S32'xres'||S32'yres'||S32'xstart'||S32'ystart'|]#'imgcrop'||S32'numthreads'||S32'nodes'||S32'mynode'||U32'$pad1'||*{SYM#c::tag-#anon#ST[S32'numcpus'||U32'$pad0'||F64'cpuspeed'||F64'nodespeed'||ARR0000000000000000000000000000000000000000000000000000001000000000{S8}'machname'|]#}'cpuinfo'||S32'hres'||S32'vres'||F64'aspectratio'||S32'raydepth'||S32'antialiasing'||S32'verbosemode'||S32'boundmode'||S32'boundthresh'||U32'$pad2'||*{SYM#c::tag-list#}'texlist'||*{SYM#c::tag-list#}'cliplist'||U32'flags'||U32'$pad3'||SYM#c::tag-#anon#ST[S32'projection'||U32'$pad0'||SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#'center'||SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#'viewvec'||SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#'rightvec'||SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#'upvec'||F64'camzoom'||F64'px'||F64'py'||F64'psx'||F64'psy'||F64'focallength'||F64'left'||F64'right'||F64'top'||F64'bottom'||F64'aperture'||SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#'projcent'||*{P(*{V}|F64|F64)->SYM#c::tag-#anon#ST[F32'r'||F32'g'||F32'b'|]#}'cam_ray'||SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#'lowleft'||SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#'iplaneright'||SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#'iplaneup'|]#'camera'||*{P(*{V})->SYM#c::tag-#anon#ST[F32'r'||F32'g'||F32'b'|]#}'shader'||*{P(*{cSYM#c::tag-ray_t#}|*{cSYM#c::tag-#anon#ST[SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#'hit'||SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#'N'||SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#'L'||F64'Llen'|]#}|F64)->F64}'phongfunc'||S32'transmode'||U32'$pad4'||SYM#c::tag-#anon#ST[SYM#c::tag-#anon#ST[F32'r'||F32'g'||F32'b'|]#'background'||U32'$pad0'||SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#'gradient'||F64'gradtopval'||F64'gradbotval'||SYM#c::tag-#anon#ST[F32'r'||F32'g'||F32'b'|]#'backgroundtop'||SYM#c::tag-#anon#ST[F32'r'||F32'g'||F32'b'|]#'backgroundbot'|]#'bgtex'||*{P(*{cSYM#c::tag-ray_t#})->SYM#c::tag-#anon#ST[F32'r'||F32'g'||F32'b'|]#}'bgtexfunc'||SYM#c::tag-fogdata_t#'fog'||SYM#c::tag-#anon#ST[*{SYM#c::tag-#anon#ST[U32'id'||U32'$pad0'||*{V}'nextobj'||*{SYM#c::tag-#anon#ST[*{P(*{cV}|*{V})->V}'intersect'||*{P(*{cV}|*{cV}|*{cV}|*{V})->V}'normal'||*{P(*{V}|*{SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#}|*{SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#})->S32}'bbox'||*{P(*{V})->V}'freeobj'|]#}'methods'||*{SYM#c::tag-#anon#ST[S32'numplanes'||U32'$pad0'||*{F64}'planes'|]#}'clip'||*{SYM#c::tag-#anon#ST[*{P(*{cV}|*{cV}|*{V})->SYM#c::tag-#anon#ST[F32'r'||F32'g'||F32'b'|]#}'texfunc'||*{SYM#c::tag-#anon#ST[*{P(*{V})->V}'freetex'|]#}'methods'||U32'flags'||F32'ambient'||F32'diffuse'||F32'phong'||F32'phongexp'||S32'phongtype'||F32'specular'||F32'opacity'||F32'outline'||F32'outlinewidth'|]#}'tex'|]#}'boundedobj'||*{SYM#c::tag-#anon#ST[U32'id'||U32'$pad0'||*{V}'nextobj'||*{SYM#c::tag-#anon#ST[*{P(*{cV}|*{V})->V}'intersect'||*{P(*{cV}|*{cV}|*{cV}|*{V})->V}'normal'||*{P(*{V}|*{SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#}|*{SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#})->S32}'bbox'||*{P(*{V})->V}'freeobj'|]#}'methods'||*{SYM#c::tag-#anon#ST[S32'numplanes'||U32'$pad0'||*{F64}'planes'|]#}'clip'||*{SYM#c::tag-#anon#ST[*{P(*{cV}|*{cV}|*{V})->SYM#c::tag-#anon#ST[F32'r'||F32'g'||F32'b'|]#}'texfunc'||*{SYM#c::tag-#anon#ST[*{P(*{V})->V}'freetex'|]#}'methods'||U32'flags'||F32'ambient'||F32'diffuse'||F32'phong'||F32'phongexp'||S32'phongtype'||F32'specular'||F32'opacity'||F32'outline'||F32'outlinewidth'|]#}'tex'|]#}'unboundedobj'||S32'numobjects'||U32'$pad0'|]#'objgroup'||*{SYM#c::tag-list#}'lightlist'||F64'light_scale'||S32'numlights'||SYM#c::tag-amboccdata_t#'ambocc'||S32'scenecheck'||*{V}'parbuf'||*{V}'threads'||*{V}'threadparms'||*{SYM#c::tag-#anon#ST[S32'numplanes'||U32'$pad0'||*{F64}'planes'|]#}'curclipgroup'||S32'normalfixupmode'||U32'$pad5'|]$link134
// 
struct anon$70$link134;

// c::tag-#anon#ST[ARR0000000000000000000000000000000000000000000000000000000100000000{S8}'outfilename'||S32'writeimagefile'||U32'$pad0'||*{V}'img'||S32'imginternal'||S32'imgprocess'||F32'imggamma'||S32'imgbufformat'||S32'imgfileformat'||SYM#c::tag-#anon#ST[S32'cropmode'||S32'xres'||S32'yres'||S32'xstart'||S32'ystart'|]#'imgcrop'||S32'numthreads'||S32'nodes'||S32'mynode'||U32'$pad1'||*{SYM#c::tag-#anon#ST[S32'numcpus'||U32'$pad0'||F64'cpuspeed'||F64'nodespeed'||ARR0000000000000000000000000000000000000000000000000000001000000000{S8}'machname'|]#}'cpuinfo'||S32'hres'||S32'vres'||F64'aspectratio'||S32'raydepth'||S32'antialiasing'||S32'verbosemode'||S32'boundmode'||S32'boundthresh'||U32'$pad2'||*{SYM#c::tag-list#}'texlist'||*{SYM#c::tag-list#}'cliplist'||U32'flags'||U32'$pad3'||SYM#c::tag-#anon#ST[S32'projection'||U32'$pad0'||SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#'center'||SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#'viewvec'||SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#'rightvec'||SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#'upvec'||F64'camzoom'||F64'px'||F64'py'||F64'psx'||F64'psy'||F64'focallength'||F64'left'||F64'right'||F64'top'||F64'bottom'||F64'aperture'||SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#'projcent'||*{P(*{V}|F64|F64)->SYM#c::tag-#anon#ST[F32'r'||F32'g'||F32'b'|]#}'cam_ray'||SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#'lowleft'||SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#'iplaneright'||SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#'iplaneup'|]#'camera'||*{P(*{V})->SYM#c::tag-#anon#ST[F32'r'||F32'g'||F32'b'|]#}'shader'||*{P(*{cSYM#c::tag-ray_t#}|*{cSYM#c::tag-#anon#ST[SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#'hit'||SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#'N'||SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#'L'||F64'Llen'|]#}|F64)->F64}'phongfunc'||S32'transmode'||U32'$pad4'||SYM#c::tag-#anon#ST[SYM#c::tag-#anon#ST[F32'r'||F32'g'||F32'b'|]#'background'||U32'$pad0'||SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#'gradient'||F64'gradtopval'||F64'gradbotval'||SYM#c::tag-#anon#ST[F32'r'||F32'g'||F32'b'|]#'backgroundtop'||SYM#c::tag-#anon#ST[F32'r'||F32'g'||F32'b'|]#'backgroundbot'|]#'bgtex'||*{P(*{cSYM#c::tag-ray_t#})->SYM#c::tag-#anon#ST[F32'r'||F32'g'||F32'b'|]#}'bgtexfunc'||SYM#c::tag-fogdata_t#'fog'||SYM#c::tag-#anon#ST[*{SYM#c::tag-#anon#ST[U32'id'||U32'$pad0'||*{V}'nextobj'||*{SYM#c::tag-#anon#ST[*{P(*{cV}|*{V})->V}'intersect'||*{P(*{cV}|*{cV}|*{cV}|*{V})->V}'normal'||*{P(*{V}|*{SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#}|*{SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#})->S32}'bbox'||*{P(*{V})->V}'freeobj'|]#}'methods'||*{SYM#c::tag-#anon#ST[S32'numplanes'||U32'$pad0'||*{F64}'planes'|]#}'clip'||*{SYM#c::tag-#anon#ST[*{P(*{cV}|*{cV}|*{V})->SYM#c::tag-#anon#ST[F32'r'||F32'g'||F32'b'|]#}'texfunc'||*{SYM#c::tag-#anon#ST[*{P(*{V})->V}'freetex'|]#}'methods'||U32'flags'||F32'ambient'||F32'diffuse'||F32'phong'||F32'phongexp'||S32'phongtype'||F32'specular'||F32'opacity'||F32'outline'||F32'outlinewidth'|]#}'tex'|]#}'boundedobj'||*{SYM#c::tag-#anon#ST[U32'id'||U32'$pad0'||*{V}'nextobj'||*{SYM#c::tag-#anon#ST[*{P(*{cV}|*{V})->V}'intersect'||*{P(*{cV}|*{cV}|*{cV}|*{V})->V}'normal'||*{P(*{V}|*{SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#}|*{SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#})->S32}'bbox'||*{P(*{V})->V}'freeobj'|]#}'methods'||*{SYM#c::tag-#anon#ST[S32'numplanes'||U32'$pad0'||*{F64}'planes'|]#}'clip'||*{SYM#c::tag-#anon#ST[*{P(*{cV}|*{cV}|*{V})->SYM#c::tag-#anon#ST[F32'r'||F32'g'||F32'b'|]#}'texfunc'||*{SYM#c::tag-#anon#ST[*{P(*{V})->V}'freetex'|]#}'methods'||U32'flags'||F32'ambient'||F32'diffuse'||F32'phong'||F32'phongexp'||S32'phongtype'||F32'specular'||F32'opacity'||F32'outline'||F32'outlinewidth'|]#}'tex'|]#}'unboundedobj'||S32'numobjects'||U32'$pad0'|]#'objgroup'||*{SYM#c::tag-list#}'lightlist'||F64'light_scale'||S32'numlights'||SYM#c::tag-amboccdata_t#'ambocc'||S32'scenecheck'||*{V}'parbuf'||*{V}'threads'||*{V}'threadparms'||*{SYM#c::tag-#anon#ST[S32'numplanes'||U32'$pad0'||*{F64}'planes'|]#}'curclipgroup'||S32'normalfixupmode'||U32'$pad5'|]$link166
// 
struct anon$65$link166;

// c::tag-#anon#ST[ARR0000000000000000000000000000000000000000000000000000000100000000{S8}'outfilename'||S32'writeimagefile'||U32'$pad0'||*{V}'img'||S32'imginternal'||S32'imgprocess'||F32'imggamma'||S32'imgbufformat'||S32'imgfileformat'||SYM#c::tag-#anon#ST[S32'cropmode'||S32'xres'||S32'yres'||S32'xstart'||S32'ystart'|]#'imgcrop'||S32'numthreads'||S32'nodes'||S32'mynode'||U32'$pad1'||*{SYM#c::tag-#anon#ST[S32'numcpus'||U32'$pad0'||F64'cpuspeed'||F64'nodespeed'||ARR0000000000000000000000000000000000000000000000000000001000000000{S8}'machname'|]#}'cpuinfo'||S32'hres'||S32'vres'||F64'aspectratio'||S32'raydepth'||S32'antialiasing'||S32'verbosemode'||S32'boundmode'||S32'boundthresh'||U32'$pad2'||*{SYM#c::tag-list#}'texlist'||*{SYM#c::tag-list#}'cliplist'||U32'flags'||U32'$pad3'||SYM#c::tag-#anon#ST[S32'projection'||U32'$pad0'||SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#'center'||SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#'viewvec'||SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#'rightvec'||SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#'upvec'||F64'camzoom'||F64'px'||F64'py'||F64'psx'||F64'psy'||F64'focallength'||F64'left'||F64'right'||F64'top'||F64'bottom'||F64'aperture'||SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#'projcent'||*{P(*{V}|F64|F64)->SYM#c::tag-#anon#ST[F32'r'||F32'g'||F32'b'|]#}'cam_ray'||SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#'lowleft'||SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#'iplaneright'||SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#'iplaneup'|]#'camera'||*{P(*{V})->SYM#c::tag-#anon#ST[F32'r'||F32'g'||F32'b'|]#}'shader'||*{P(*{cSYM#c::tag-ray_t#}|*{cSYM#c::tag-#anon#ST[SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#'hit'||SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#'N'||SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#'L'||F64'Llen'|]#}|F64)->F64}'phongfunc'||S32'transmode'||U32'$pad4'||SYM#c::tag-#anon#ST[SYM#c::tag-#anon#ST[F32'r'||F32'g'||F32'b'|]#'background'||U32'$pad0'||SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#'gradient'||F64'gradtopval'||F64'gradbotval'||SYM#c::tag-#anon#ST[F32'r'||F32'g'||F32'b'|]#'backgroundtop'||SYM#c::tag-#anon#ST[F32'r'||F32'g'||F32'b'|]#'backgroundbot'|]#'bgtex'||*{P(*{cSYM#c::tag-ray_t#})->SYM#c::tag-#anon#ST[F32'r'||F32'g'||F32'b'|]#}'bgtexfunc'||SYM#c::tag-fogdata_t#'fog'||SYM#c::tag-#anon#ST[*{SYM#c::tag-#anon#ST[U32'id'||U32'$pad0'||*{V}'nextobj'||*{SYM#c::tag-#anon#ST[*{P(*{cV}|*{V})->V}'intersect'||*{P(*{cV}|*{cV}|*{cV}|*{V})->V}'normal'||*{P(*{V}|*{SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#}|*{SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#})->S32}'bbox'||*{P(*{V})->V}'freeobj'|]#}'methods'||*{SYM#c::tag-#anon#ST[S32'numplanes'||U32'$pad0'||*{F64}'planes'|]#}'clip'||*{SYM#c::tag-#anon#ST[*{P(*{cV}|*{cV}|*{V})->SYM#c::tag-#anon#ST[F32'r'||F32'g'||F32'b'|]#}'texfunc'||*{SYM#c::tag-#anon#ST[*{P(*{V})->V}'freetex'|]#}'methods'||U32'flags'||F32'ambient'||F32'diffuse'||F32'phong'||F32'phongexp'||S32'phongtype'||F32'specular'||F32'opacity'||F32'outline'||F32'outlinewidth'|]#}'tex'|]#}'boundedobj'||*{SYM#c::tag-#anon#ST[U32'id'||U32'$pad0'||*{V}'nextobj'||*{SYM#c::tag-#anon#ST[*{P(*{cV}|*{V})->V}'intersect'||*{P(*{cV}|*{cV}|*{cV}|*{V})->V}'normal'||*{P(*{V}|*{SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#}|*{SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#})->S32}'bbox'||*{P(*{V})->V}'freeobj'|]#}'methods'||*{SYM#c::tag-#anon#ST[S32'numplanes'||U32'$pad0'||*{F64}'planes'|]#}'clip'||*{SYM#c::tag-#anon#ST[*{P(*{cV}|*{cV}|*{V})->SYM#c::tag-#anon#ST[F32'r'||F32'g'||F32'b'|]#}'texfunc'||*{SYM#c::tag-#anon#ST[*{P(*{V})->V}'freetex'|]#}'methods'||U32'flags'||F32'ambient'||F32'diffuse'||F32'phong'||F32'phongexp'||S32'phongtype'||F32'specular'||F32'opacity'||F32'outline'||F32'outlinewidth'|]#}'tex'|]#}'unboundedobj'||S32'numobjects'||U32'$pad0'|]#'objgroup'||*{SYM#c::tag-list#}'lightlist'||F64'light_scale'||S32'numlights'||SYM#c::tag-amboccdata_t#'ambocc'||S32'scenecheck'||*{V}'parbuf'||*{V}'threads'||*{V}'threadparms'||*{SYM#c::tag-#anon#ST[S32'numplanes'||U32'$pad0'||*{F64}'planes'|]#}'curclipgroup'||S32'normalfixupmode'||U32'$pad5'|]$link203
// 
struct anon$54$link203;

// c::tag-#anon#ST[ARR0000000000000000000000000000000000000000000000000000000100000000{S8}'outfilename'||S32'writeimagefile'||U32'$pad0'||*{V}'img'||S32'imginternal'||S32'imgprocess'||F32'imggamma'||S32'imgbufformat'||S32'imgfileformat'||SYM#c::tag-#anon#ST[S32'cropmode'||S32'xres'||S32'yres'||S32'xstart'||S32'ystart'|]#'imgcrop'||S32'numthreads'||S32'nodes'||S32'mynode'||U32'$pad1'||*{SYM#c::tag-#anon#ST[S32'numcpus'||U32'$pad0'||F64'cpuspeed'||F64'nodespeed'||ARR0000000000000000000000000000000000000000000000000000001000000000{S8}'machname'|]#}'cpuinfo'||S32'hres'||S32'vres'||F64'aspectratio'||S32'raydepth'||S32'antialiasing'||S32'verbosemode'||S32'boundmode'||S32'boundthresh'||U32'$pad2'||*{SYM#c::tag-list#}'texlist'||*{SYM#c::tag-list#}'cliplist'||U32'flags'||U32'$pad3'||SYM#c::tag-#anon#ST[S32'projection'||U32'$pad0'||SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#'center'||SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#'viewvec'||SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#'rightvec'||SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#'upvec'||F64'camzoom'||F64'px'||F64'py'||F64'psx'||F64'psy'||F64'focallength'||F64'left'||F64'right'||F64'top'||F64'bottom'||F64'aperture'||SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#'projcent'||*{P(*{V}|F64|F64)->SYM#c::tag-#anon#ST[F32'r'||F32'g'||F32'b'|]#}'cam_ray'||SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#'lowleft'||SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#'iplaneright'||SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#'iplaneup'|]#'camera'||*{P(*{V})->SYM#c::tag-#anon#ST[F32'r'||F32'g'||F32'b'|]#}'shader'||*{P(*{cSYM#c::tag-ray_t#}|*{cSYM#c::tag-#anon#ST[SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#'hit'||SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#'N'||SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#'L'||F64'Llen'|]#}|F64)->F64}'phongfunc'||S32'transmode'||U32'$pad4'||SYM#c::tag-#anon#ST[SYM#c::tag-#anon#ST[F32'r'||F32'g'||F32'b'|]#'background'||U32'$pad0'||SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#'gradient'||F64'gradtopval'||F64'gradbotval'||SYM#c::tag-#anon#ST[F32'r'||F32'g'||F32'b'|]#'backgroundtop'||SYM#c::tag-#anon#ST[F32'r'||F32'g'||F32'b'|]#'backgroundbot'|]#'bgtex'||*{P(*{cSYM#c::tag-ray_t#})->SYM#c::tag-#anon#ST[F32'r'||F32'g'||F32'b'|]#}'bgtexfunc'||SYM#c::tag-fogdata_t#'fog'||SYM#c::tag-#anon#ST[*{SYM#c::tag-#anon#ST[U32'id'||U32'$pad0'||*{V}'nextobj'||*{SYM#c::tag-#anon#ST[*{P(*{cV}|*{V})->V}'intersect'||*{P(*{cV}|*{cV}|*{cV}|*{V})->V}'normal'||*{P(*{V}|*{SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#}|*{SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#})->S32}'bbox'||*{P(*{V})->V}'freeobj'|]#}'methods'||*{SYM#c::tag-#anon#ST[S32'numplanes'||U32'$pad0'||*{F64}'planes'|]#}'clip'||*{SYM#c::tag-#anon#ST[*{P(*{cV}|*{cV}|*{V})->SYM#c::tag-#anon#ST[F32'r'||F32'g'||F32'b'|]#}'texfunc'||*{SYM#c::tag-#anon#ST[*{P(*{V})->V}'freetex'|]#}'methods'||U32'flags'||F32'ambient'||F32'diffuse'||F32'phong'||F32'phongexp'||S32'phongtype'||F32'specular'||F32'opacity'||F32'outline'||F32'outlinewidth'|]#}'tex'|]#}'boundedobj'||*{SYM#c::tag-#anon#ST[U32'id'||U32'$pad0'||*{V}'nextobj'||*{SYM#c::tag-#anon#ST[*{P(*{cV}|*{V})->V}'intersect'||*{P(*{cV}|*{cV}|*{cV}|*{V})->V}'normal'||*{P(*{V}|*{SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#}|*{SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#})->S32}'bbox'||*{P(*{V})->V}'freeobj'|]#}'methods'||*{SYM#c::tag-#anon#ST[S32'numplanes'||U32'$pad0'||*{F64}'planes'|]#}'clip'||*{SYM#c::tag-#anon#ST[*{P(*{cV}|*{cV}|*{V})->SYM#c::tag-#anon#ST[F32'r'||F32'g'||F32'b'|]#}'texfunc'||*{SYM#c::tag-#anon#ST[*{P(*{V})->V}'freetex'|]#}'methods'||U32'flags'||F32'ambient'||F32'diffuse'||F32'phong'||F32'phongexp'||S32'phongtype'||F32'specular'||F32'opacity'||F32'outline'||F32'outlinewidth'|]#}'tex'|]#}'unboundedobj'||S32'numobjects'||U32'$pad0'|]#'objgroup'||*{SYM#c::tag-list#}'lightlist'||F64'light_scale'||S32'numlights'||SYM#c::tag-amboccdata_t#'ambocc'||S32'scenecheck'||*{V}'parbuf'||*{V}'threads'||*{V}'threadparms'||*{SYM#c::tag-#anon#ST[S32'numplanes'||U32'$pad0'||*{F64}'planes'|]#}'curclipgroup'||S32'normalfixupmode'||U32'$pad5'|]$link211
// 
struct anon$31$link211;

// c::tag-#anon#ST[ARR0000000000000000000000000000000000000000000000000000000100000000{S8}'outfilename'||S32'writeimagefile'||U32'$pad0'||*{V}'img'||S32'imginternal'||S32'imgprocess'||F32'imggamma'||S32'imgbufformat'||S32'imgfileformat'||SYM#c::tag-#anon#ST[S32'cropmode'||S32'xres'||S32'yres'||S32'xstart'||S32'ystart'|]#'imgcrop'||S32'numthreads'||S32'nodes'||S32'mynode'||U32'$pad1'||*{SYM#c::tag-#anon#ST[S32'numcpus'||U32'$pad0'||F64'cpuspeed'||F64'nodespeed'||ARR0000000000000000000000000000000000000000000000000000001000000000{S8}'machname'|]#}'cpuinfo'||S32'hres'||S32'vres'||F64'aspectratio'||S32'raydepth'||S32'antialiasing'||S32'verbosemode'||S32'boundmode'||S32'boundthresh'||U32'$pad2'||*{SYM#c::tag-list#}'texlist'||*{SYM#c::tag-list#}'cliplist'||U32'flags'||U32'$pad3'||SYM#c::tag-#anon#ST[S32'projection'||U32'$pad0'||SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#'center'||SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#'viewvec'||SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#'rightvec'||SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#'upvec'||F64'camzoom'||F64'px'||F64'py'||F64'psx'||F64'psy'||F64'focallength'||F64'left'||F64'right'||F64'top'||F64'bottom'||F64'aperture'||SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#'projcent'||*{P(*{V}|F64|F64)->SYM#c::tag-#anon#ST[F32'r'||F32'g'||F32'b'|]#}'cam_ray'||SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#'lowleft'||SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#'iplaneright'||SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#'iplaneup'|]#'camera'||*{P(*{V})->SYM#c::tag-#anon#ST[F32'r'||F32'g'||F32'b'|]#}'shader'||*{P(*{cSYM#c::tag-ray_t#}|*{cSYM#c::tag-#anon#ST[SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#'hit'||SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#'N'||SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#'L'||F64'Llen'|]#}|F64)->F64}'phongfunc'||S32'transmode'||U32'$pad4'||SYM#c::tag-#anon#ST[SYM#c::tag-#anon#ST[F32'r'||F32'g'||F32'b'|]#'background'||U32'$pad0'||SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#'gradient'||F64'gradtopval'||F64'gradbotval'||SYM#c::tag-#anon#ST[F32'r'||F32'g'||F32'b'|]#'backgroundtop'||SYM#c::tag-#anon#ST[F32'r'||F32'g'||F32'b'|]#'backgroundbot'|]#'bgtex'||*{P(*{cSYM#c::tag-ray_t#})->SYM#c::tag-#anon#ST[F32'r'||F32'g'||F32'b'|]#}'bgtexfunc'||SYM#c::tag-fogdata_t#'fog'||SYM#c::tag-#anon#ST[*{SYM#c::tag-#anon#ST[U32'id'||U32'$pad0'||*{V}'nextobj'||*{SYM#c::tag-#anon#ST[*{P(*{cV}|*{V})->V}'intersect'||*{P(*{cV}|*{cV}|*{cV}|*{V})->V}'normal'||*{P(*{V}|*{SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#}|*{SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#})->S32}'bbox'||*{P(*{V})->V}'freeobj'|]#}'methods'||*{SYM#c::tag-#anon#ST[S32'numplanes'||U32'$pad0'||*{F64}'planes'|]#}'clip'||*{SYM#c::tag-#anon#ST[*{P(*{cV}|*{cV}|*{V})->SYM#c::tag-#anon#ST[F32'r'||F32'g'||F32'b'|]#}'texfunc'||*{SYM#c::tag-#anon#ST[*{P(*{V})->V}'freetex'|]#}'methods'||U32'flags'||F32'ambient'||F32'diffuse'||F32'phong'||F32'phongexp'||S32'phongtype'||F32'specular'||F32'opacity'||F32'outline'||F32'outlinewidth'|]#}'tex'|]#}'boundedobj'||*{SYM#c::tag-#anon#ST[U32'id'||U32'$pad0'||*{V}'nextobj'||*{SYM#c::tag-#anon#ST[*{P(*{cV}|*{V})->V}'intersect'||*{P(*{cV}|*{cV}|*{cV}|*{V})->V}'normal'||*{P(*{V}|*{SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#}|*{SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#})->S32}'bbox'||*{P(*{V})->V}'freeobj'|]#}'methods'||*{SYM#c::tag-#anon#ST[S32'numplanes'||U32'$pad0'||*{F64}'planes'|]#}'clip'||*{SYM#c::tag-#anon#ST[*{P(*{cV}|*{cV}|*{V})->SYM#c::tag-#anon#ST[F32'r'||F32'g'||F32'b'|]#}'texfunc'||*{SYM#c::tag-#anon#ST[*{P(*{V})->V}'freetex'|]#}'methods'||U32'flags'||F32'ambient'||F32'diffuse'||F32'phong'||F32'phongexp'||S32'phongtype'||F32'specular'||F32'opacity'||F32'outline'||F32'outlinewidth'|]#}'tex'|]#}'unboundedobj'||S32'numobjects'||U32'$pad0'|]#'objgroup'||*{SYM#c::tag-list#}'lightlist'||F64'light_scale'||S32'numlights'||SYM#c::tag-amboccdata_t#'ambocc'||S32'scenecheck'||*{V}'parbuf'||*{V}'threads'||*{V}'threadparms'||*{SYM#c::tag-#anon#ST[S32'numplanes'||U32'$pad0'||*{F64}'planes'|]#}'curclipgroup'||S32'normalfixupmode'||U32'$pad5'|]$link217
// 
struct anon$68$link217;

// c::tag-#anon#ST[ARR0000000000000000000000000000000000000000000000000000000100000000{S8}'outfilename'||S32'writeimagefile'||U32'$pad0'||*{V}'img'||S32'imginternal'||S32'imgprocess'||F32'imggamma'||S32'imgbufformat'||S32'imgfileformat'||SYM#c::tag-#anon#ST[S32'cropmode'||S32'xres'||S32'yres'||S32'xstart'||S32'ystart'|]#'imgcrop'||S32'numthreads'||S32'nodes'||S32'mynode'||U32'$pad1'||*{SYM#c::tag-#anon#ST[S32'numcpus'||U32'$pad0'||F64'cpuspeed'||F64'nodespeed'||ARR0000000000000000000000000000000000000000000000000000001000000000{S8}'machname'|]#}'cpuinfo'||S32'hres'||S32'vres'||F64'aspectratio'||S32'raydepth'||S32'antialiasing'||S32'verbosemode'||S32'boundmode'||S32'boundthresh'||U32'$pad2'||*{SYM#c::tag-list#}'texlist'||*{SYM#c::tag-list#}'cliplist'||U32'flags'||U32'$pad3'||SYM#c::tag-#anon#ST[S32'projection'||U32'$pad0'||SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#'center'||SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#'viewvec'||SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#'rightvec'||SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#'upvec'||F64'camzoom'||F64'px'||F64'py'||F64'psx'||F64'psy'||F64'focallength'||F64'left'||F64'right'||F64'top'||F64'bottom'||F64'aperture'||SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#'projcent'||*{P(*{V}|F64|F64)->SYM#c::tag-#anon#ST[F32'r'||F32'g'||F32'b'|]#}'cam_ray'||SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#'lowleft'||SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#'iplaneright'||SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#'iplaneup'|]#'camera'||*{P(*{V})->SYM#c::tag-#anon#ST[F32'r'||F32'g'||F32'b'|]#}'shader'||*{P(*{cSYM#c::tag-ray_t#}|*{cSYM#c::tag-#anon#ST[SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#'hit'||SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#'N'||SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#'L'||F64'Llen'|]#}|F64)->F64}'phongfunc'||S32'transmode'||U32'$pad4'||SYM#c::tag-#anon#ST[SYM#c::tag-#anon#ST[F32'r'||F32'g'||F32'b'|]#'background'||U32'$pad0'||SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#'gradient'||F64'gradtopval'||F64'gradbotval'||SYM#c::tag-#anon#ST[F32'r'||F32'g'||F32'b'|]#'backgroundtop'||SYM#c::tag-#anon#ST[F32'r'||F32'g'||F32'b'|]#'backgroundbot'|]#'bgtex'||*{P(*{cSYM#c::tag-ray_t#})->SYM#c::tag-#anon#ST[F32'r'||F32'g'||F32'b'|]#}'bgtexfunc'||SYM#c::tag-fogdata_t#'fog'||SYM#c::tag-#anon#ST[*{SYM#c::tag-#anon#ST[U32'id'||U32'$pad0'||*{V}'nextobj'||*{SYM#c::tag-#anon#ST[*{P(*{cV}|*{V})->V}'intersect'||*{P(*{cV}|*{cV}|*{cV}|*{V})->V}'normal'||*{P(*{V}|*{SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#}|*{SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#})->S32}'bbox'||*{P(*{V})->V}'freeobj'|]#}'methods'||*{SYM#c::tag-#anon#ST[S32'numplanes'||U32'$pad0'||*{F64}'planes'|]#}'clip'||*{SYM#c::tag-#anon#ST[*{P(*{cV}|*{cV}|*{V})->SYM#c::tag-#anon#ST[F32'r'||F32'g'||F32'b'|]#}'texfunc'||*{SYM#c::tag-#anon#ST[*{P(*{V})->V}'freetex'|]#}'methods'||U32'flags'||F32'ambient'||F32'diffuse'||F32'phong'||F32'phongexp'||S32'phongtype'||F32'specular'||F32'opacity'||F32'outline'||F32'outlinewidth'|]#}'tex'|]#}'boundedobj'||*{SYM#c::tag-#anon#ST[U32'id'||U32'$pad0'||*{V}'nextobj'||*{SYM#c::tag-#anon#ST[*{P(*{cV}|*{V})->V}'intersect'||*{P(*{cV}|*{cV}|*{cV}|*{V})->V}'normal'||*{P(*{V}|*{SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#}|*{SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#})->S32}'bbox'||*{P(*{V})->V}'freeobj'|]#}'methods'||*{SYM#c::tag-#anon#ST[S32'numplanes'||U32'$pad0'||*{F64}'planes'|]#}'clip'||*{SYM#c::tag-#anon#ST[*{P(*{cV}|*{cV}|*{V})->SYM#c::tag-#anon#ST[F32'r'||F32'g'||F32'b'|]#}'texfunc'||*{SYM#c::tag-#anon#ST[*{P(*{V})->V}'freetex'|]#}'methods'||U32'flags'||F32'ambient'||F32'diffuse'||F32'phong'||F32'phongexp'||S32'phongtype'||F32'specular'||F32'opacity'||F32'outline'||F32'outlinewidth'|]#}'tex'|]#}'unboundedobj'||S32'numobjects'||U32'$pad0'|]#'objgroup'||*{SYM#c::tag-list#}'lightlist'||F64'light_scale'||S32'numlights'||SYM#c::tag-amboccdata_t#'ambocc'||S32'scenecheck'||*{V}'parbuf'||*{V}'threads'||*{V}'threadparms'||*{SYM#c::tag-#anon#ST[S32'numplanes'||U32'$pad0'||*{F64}'planes'|]#}'curclipgroup'||S32'normalfixupmode'||U32'$pad5'|]$link236
// 
struct anon$56$link236;

// c::tag-#anon#ST[ARR0000000000000000000000000000000000000000000000000000000100000000{S8}'outfilename'||S32'writeimagefile'||U32'$pad0'||*{V}'img'||S32'imginternal'||S32'imgprocess'||F32'imggamma'||S32'imgbufformat'||S32'imgfileformat'||SYM#c::tag-#anon#ST[S32'cropmode'||S32'xres'||S32'yres'||S32'xstart'||S32'ystart'|]#'imgcrop'||S32'numthreads'||S32'nodes'||S32'mynode'||U32'$pad1'||*{SYM#c::tag-#anon#ST[S32'numcpus'||U32'$pad0'||F64'cpuspeed'||F64'nodespeed'||ARR0000000000000000000000000000000000000000000000000000001000000000{S8}'machname'|]#}'cpuinfo'||S32'hres'||S32'vres'||F64'aspectratio'||S32'raydepth'||S32'antialiasing'||S32'verbosemode'||S32'boundmode'||S32'boundthresh'||U32'$pad2'||*{SYM#c::tag-list#}'texlist'||*{SYM#c::tag-list#}'cliplist'||U32'flags'||U32'$pad3'||SYM#c::tag-#anon#ST[S32'projection'||U32'$pad0'||SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#'center'||SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#'viewvec'||SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#'rightvec'||SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#'upvec'||F64'camzoom'||F64'px'||F64'py'||F64'psx'||F64'psy'||F64'focallength'||F64'left'||F64'right'||F64'top'||F64'bottom'||F64'aperture'||SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#'projcent'||*{P(*{V}|F64|F64)->SYM#c::tag-#anon#ST[F32'r'||F32'g'||F32'b'|]#}'cam_ray'||SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#'lowleft'||SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#'iplaneright'||SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#'iplaneup'|]#'camera'||*{P(*{V})->SYM#c::tag-#anon#ST[F32'r'||F32'g'||F32'b'|]#}'shader'||*{P(*{cSYM#c::tag-ray_t#}|*{cSYM#c::tag-#anon#ST[SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#'hit'||SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#'N'||SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#'L'||F64'Llen'|]#}|F64)->F64}'phongfunc'||S32'transmode'||U32'$pad4'||SYM#c::tag-#anon#ST[SYM#c::tag-#anon#ST[F32'r'||F32'g'||F32'b'|]#'background'||U32'$pad0'||SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#'gradient'||F64'gradtopval'||F64'gradbotval'||SYM#c::tag-#anon#ST[F32'r'||F32'g'||F32'b'|]#'backgroundtop'||SYM#c::tag-#anon#ST[F32'r'||F32'g'||F32'b'|]#'backgroundbot'|]#'bgtex'||*{P(*{cSYM#c::tag-ray_t#})->SYM#c::tag-#anon#ST[F32'r'||F32'g'||F32'b'|]#}'bgtexfunc'||SYM#c::tag-fogdata_t#'fog'||SYM#c::tag-#anon#ST[*{SYM#c::tag-#anon#ST[U32'id'||U32'$pad0'||*{V}'nextobj'||*{SYM#c::tag-#anon#ST[*{P(*{cV}|*{V})->V}'intersect'||*{P(*{cV}|*{cV}|*{cV}|*{V})->V}'normal'||*{P(*{V}|*{SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#}|*{SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#})->S32}'bbox'||*{P(*{V})->V}'freeobj'|]#}'methods'||*{SYM#c::tag-#anon#ST[S32'numplanes'||U32'$pad0'||*{F64}'planes'|]#}'clip'||*{SYM#c::tag-#anon#ST[*{P(*{cV}|*{cV}|*{V})->SYM#c::tag-#anon#ST[F32'r'||F32'g'||F32'b'|]#}'texfunc'||*{SYM#c::tag-#anon#ST[*{P(*{V})->V}'freetex'|]#}'methods'||U32'flags'||F32'ambient'||F32'diffuse'||F32'phong'||F32'phongexp'||S32'phongtype'||F32'specular'||F32'opacity'||F32'outline'||F32'outlinewidth'|]#}'tex'|]#}'boundedobj'||*{SYM#c::tag-#anon#ST[U32'id'||U32'$pad0'||*{V}'nextobj'||*{SYM#c::tag-#anon#ST[*{P(*{cV}|*{V})->V}'intersect'||*{P(*{cV}|*{cV}|*{cV}|*{V})->V}'normal'||*{P(*{V}|*{SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#}|*{SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#})->S32}'bbox'||*{P(*{V})->V}'freeobj'|]#}'methods'||*{SYM#c::tag-#anon#ST[S32'numplanes'||U32'$pad0'||*{F64}'planes'|]#}'clip'||*{SYM#c::tag-#anon#ST[*{P(*{cV}|*{cV}|*{V})->SYM#c::tag-#anon#ST[F32'r'||F32'g'||F32'b'|]#}'texfunc'||*{SYM#c::tag-#anon#ST[*{P(*{V})->V}'freetex'|]#}'methods'||U32'flags'||F32'ambient'||F32'diffuse'||F32'phong'||F32'phongexp'||S32'phongtype'||F32'specular'||F32'opacity'||F32'outline'||F32'outlinewidth'|]#}'tex'|]#}'unboundedobj'||S32'numobjects'||U32'$pad0'|]#'objgroup'||*{SYM#c::tag-list#}'lightlist'||F64'light_scale'||S32'numlights'||SYM#c::tag-amboccdata_t#'ambocc'||S32'scenecheck'||*{V}'parbuf'||*{V}'threads'||*{V}'threadparms'||*{SYM#c::tag-#anon#ST[S32'numplanes'||U32'$pad0'||*{F64}'planes'|]#}'curclipgroup'||S32'normalfixupmode'||U32'$pad5'|]$link238
// 
struct anon$57$link238;

// c::tag-#anon#ST[ARR0000000000000000000000000000000000000000000000000000000100000000{S8}'outfilename'||S32'writeimagefile'||U32'$pad0'||*{V}'img'||S32'imginternal'||S32'imgprocess'||F32'imggamma'||S32'imgbufformat'||S32'imgfileformat'||SYM#c::tag-#anon#ST[S32'cropmode'||S32'xres'||S32'yres'||S32'xstart'||S32'ystart'|]#'imgcrop'||S32'numthreads'||S32'nodes'||S32'mynode'||U32'$pad1'||*{SYM#c::tag-#anon#ST[S32'numcpus'||U32'$pad0'||F64'cpuspeed'||F64'nodespeed'||ARR0000000000000000000000000000000000000000000000000000001000000000{S8}'machname'|]#}'cpuinfo'||S32'hres'||S32'vres'||F64'aspectratio'||S32'raydepth'||S32'antialiasing'||S32'verbosemode'||S32'boundmode'||S32'boundthresh'||U32'$pad2'||*{SYM#c::tag-list#}'texlist'||*{SYM#c::tag-list#}'cliplist'||U32'flags'||U32'$pad3'||SYM#c::tag-#anon#ST[S32'projection'||U32'$pad0'||SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#'center'||SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#'viewvec'||SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#'rightvec'||SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#'upvec'||F64'camzoom'||F64'px'||F64'py'||F64'psx'||F64'psy'||F64'focallength'||F64'left'||F64'right'||F64'top'||F64'bottom'||F64'aperture'||SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#'projcent'||*{P(*{V}|F64|F64)->SYM#c::tag-#anon#ST[F32'r'||F32'g'||F32'b'|]#}'cam_ray'||SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#'lowleft'||SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#'iplaneright'||SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#'iplaneup'|]#'camera'||*{P(*{V})->SYM#c::tag-#anon#ST[F32'r'||F32'g'||F32'b'|]#}'shader'||*{P(*{cSYM#c::tag-ray_t#}|*{cSYM#c::tag-#anon#ST[SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#'hit'||SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#'N'||SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#'L'||F64'Llen'|]#}|F64)->F64}'phongfunc'||S32'transmode'||U32'$pad4'||SYM#c::tag-#anon#ST[SYM#c::tag-#anon#ST[F32'r'||F32'g'||F32'b'|]#'background'||U32'$pad0'||SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#'gradient'||F64'gradtopval'||F64'gradbotval'||SYM#c::tag-#anon#ST[F32'r'||F32'g'||F32'b'|]#'backgroundtop'||SYM#c::tag-#anon#ST[F32'r'||F32'g'||F32'b'|]#'backgroundbot'|]#'bgtex'||*{P(*{cSYM#c::tag-ray_t#})->SYM#c::tag-#anon#ST[F32'r'||F32'g'||F32'b'|]#}'bgtexfunc'||SYM#c::tag-fogdata_t#'fog'||SYM#c::tag-#anon#ST[*{SYM#c::tag-#anon#ST[U32'id'||U32'$pad0'||*{V}'nextobj'||*{SYM#c::tag-#anon#ST[*{P(*{cV}|*{V})->V}'intersect'||*{P(*{cV}|*{cV}|*{cV}|*{V})->V}'normal'||*{P(*{V}|*{SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#}|*{SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#})->S32}'bbox'||*{P(*{V})->V}'freeobj'|]#}'methods'||*{SYM#c::tag-#anon#ST[S32'numplanes'||U32'$pad0'||*{F64}'planes'|]#}'clip'||*{SYM#c::tag-#anon#ST[*{P(*{cV}|*{cV}|*{V})->SYM#c::tag-#anon#ST[F32'r'||F32'g'||F32'b'|]#}'texfunc'||*{SYM#c::tag-#anon#ST[*{P(*{V})->V}'freetex'|]#}'methods'||U32'flags'||F32'ambient'||F32'diffuse'||F32'phong'||F32'phongexp'||S32'phongtype'||F32'specular'||F32'opacity'||F32'outline'||F32'outlinewidth'|]#}'tex'|]#}'boundedobj'||*{SYM#c::tag-#anon#ST[U32'id'||U32'$pad0'||*{V}'nextobj'||*{SYM#c::tag-#anon#ST[*{P(*{cV}|*{V})->V}'intersect'||*{P(*{cV}|*{cV}|*{cV}|*{V})->V}'normal'||*{P(*{V}|*{SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#}|*{SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#})->S32}'bbox'||*{P(*{V})->V}'freeobj'|]#}'methods'||*{SYM#c::tag-#anon#ST[S32'numplanes'||U32'$pad0'||*{F64}'planes'|]#}'clip'||*{SYM#c::tag-#anon#ST[*{P(*{cV}|*{cV}|*{V})->SYM#c::tag-#anon#ST[F32'r'||F32'g'||F32'b'|]#}'texfunc'||*{SYM#c::tag-#anon#ST[*{P(*{V})->V}'freetex'|]#}'methods'||U32'flags'||F32'ambient'||F32'diffuse'||F32'phong'||F32'phongexp'||S32'phongtype'||F32'specular'||F32'opacity'||F32'outline'||F32'outlinewidth'|]#}'tex'|]#}'unboundedobj'||S32'numobjects'||U32'$pad0'|]#'objgroup'||*{SYM#c::tag-list#}'lightlist'||F64'light_scale'||S32'numlights'||SYM#c::tag-amboccdata_t#'ambocc'||S32'scenecheck'||*{V}'parbuf'||*{V}'threads'||*{V}'threadparms'||*{SYM#c::tag-#anon#ST[S32'numplanes'||U32'$pad0'||*{F64}'planes'|]#}'curclipgroup'||S32'normalfixupmode'||U32'$pad5'|]$link244
// 
struct anon$63$link244;

// c::tag-#anon#ST[ARR0000000000000000000000000000000000000000000000000000000100000000{S8}'outfilename'||S32'writeimagefile'||U32'$pad0'||*{V}'img'||S32'imginternal'||S32'imgprocess'||F32'imggamma'||S32'imgbufformat'||S32'imgfileformat'||SYM#c::tag-#anon#ST[S32'cropmode'||S32'xres'||S32'yres'||S32'xstart'||S32'ystart'|]#'imgcrop'||S32'numthreads'||S32'nodes'||S32'mynode'||U32'$pad1'||*{SYM#c::tag-#anon#ST[S32'numcpus'||U32'$pad0'||F64'cpuspeed'||F64'nodespeed'||ARR0000000000000000000000000000000000000000000000000000001000000000{S8}'machname'|]#}'cpuinfo'||S32'hres'||S32'vres'||F64'aspectratio'||S32'raydepth'||S32'antialiasing'||S32'verbosemode'||S32'boundmode'||S32'boundthresh'||U32'$pad2'||*{SYM#c::tag-list#}'texlist'||*{SYM#c::tag-list#}'cliplist'||U32'flags'||U32'$pad3'||SYM#c::tag-#anon#ST[S32'projection'||U32'$pad0'||SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#'center'||SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#'viewvec'||SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#'rightvec'||SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#'upvec'||F64'camzoom'||F64'px'||F64'py'||F64'psx'||F64'psy'||F64'focallength'||F64'left'||F64'right'||F64'top'||F64'bottom'||F64'aperture'||SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#'projcent'||*{P(*{V}|F64|F64)->SYM#c::tag-#anon#ST[F32'r'||F32'g'||F32'b'|]#}'cam_ray'||SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#'lowleft'||SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#'iplaneright'||SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#'iplaneup'|]#'camera'||*{P(*{V})->SYM#c::tag-#anon#ST[F32'r'||F32'g'||F32'b'|]#}'shader'||*{P(*{cSYM#c::tag-ray_t#}|*{cSYM#c::tag-#anon#ST[SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#'hit'||SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#'N'||SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#'L'||F64'Llen'|]#}|F64)->F64}'phongfunc'||S32'transmode'||U32'$pad4'||SYM#c::tag-#anon#ST[SYM#c::tag-#anon#ST[F32'r'||F32'g'||F32'b'|]#'background'||U32'$pad0'||SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#'gradient'||F64'gradtopval'||F64'gradbotval'||SYM#c::tag-#anon#ST[F32'r'||F32'g'||F32'b'|]#'backgroundtop'||SYM#c::tag-#anon#ST[F32'r'||F32'g'||F32'b'|]#'backgroundbot'|]#'bgtex'||*{P(*{cSYM#c::tag-ray_t#})->SYM#c::tag-#anon#ST[F32'r'||F32'g'||F32'b'|]#}'bgtexfunc'||SYM#c::tag-fogdata_t#'fog'||SYM#c::tag-#anon#ST[*{SYM#c::tag-#anon#ST[U32'id'||U32'$pad0'||*{V}'nextobj'||*{SYM#c::tag-#anon#ST[*{P(*{cV}|*{V})->V}'intersect'||*{P(*{cV}|*{cV}|*{cV}|*{V})->V}'normal'||*{P(*{V}|*{SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#}|*{SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#})->S32}'bbox'||*{P(*{V})->V}'freeobj'|]#}'methods'||*{SYM#c::tag-#anon#ST[S32'numplanes'||U32'$pad0'||*{F64}'planes'|]#}'clip'||*{SYM#c::tag-#anon#ST[*{P(*{cV}|*{cV}|*{V})->SYM#c::tag-#anon#ST[F32'r'||F32'g'||F32'b'|]#}'texfunc'||*{SYM#c::tag-#anon#ST[*{P(*{V})->V}'freetex'|]#}'methods'||U32'flags'||F32'ambient'||F32'diffuse'||F32'phong'||F32'phongexp'||S32'phongtype'||F32'specular'||F32'opacity'||F32'outline'||F32'outlinewidth'|]#}'tex'|]#}'boundedobj'||*{SYM#c::tag-#anon#ST[U32'id'||U32'$pad0'||*{V}'nextobj'||*{SYM#c::tag-#anon#ST[*{P(*{cV}|*{V})->V}'intersect'||*{P(*{cV}|*{cV}|*{cV}|*{V})->V}'normal'||*{P(*{V}|*{SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#}|*{SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#})->S32}'bbox'||*{P(*{V})->V}'freeobj'|]#}'methods'||*{SYM#c::tag-#anon#ST[S32'numplanes'||U32'$pad0'||*{F64}'planes'|]#}'clip'||*{SYM#c::tag-#anon#ST[*{P(*{cV}|*{cV}|*{V})->SYM#c::tag-#anon#ST[F32'r'||F32'g'||F32'b'|]#}'texfunc'||*{SYM#c::tag-#anon#ST[*{P(*{V})->V}'freetex'|]#}'methods'||U32'flags'||F32'ambient'||F32'diffuse'||F32'phong'||F32'phongexp'||S32'phongtype'||F32'specular'||F32'opacity'||F32'outline'||F32'outlinewidth'|]#}'tex'|]#}'unboundedobj'||S32'numobjects'||U32'$pad0'|]#'objgroup'||*{SYM#c::tag-list#}'lightlist'||F64'light_scale'||S32'numlights'||SYM#c::tag-amboccdata_t#'ambocc'||S32'scenecheck'||*{V}'parbuf'||*{V}'threads'||*{V}'threadparms'||*{SYM#c::tag-#anon#ST[S32'numplanes'||U32'$pad0'||*{F64}'planes'|]#}'curclipgroup'||S32'normalfixupmode'||U32'$pad5'|]$link250
// 
struct anon$66$link250;

// c::tag-#anon#ST[ARR0000000000000000000000000000000000000000000000000000000100000000{S8}'outfilename'||S32'writeimagefile'||U32'$pad0'||*{V}'img'||S32'imginternal'||S32'imgprocess'||F32'imggamma'||S32'imgbufformat'||S32'imgfileformat'||SYM#c::tag-#anon#ST[S32'cropmode'||S32'xres'||S32'yres'||S32'xstart'||S32'ystart'|]#'imgcrop'||S32'numthreads'||S32'nodes'||S32'mynode'||U32'$pad1'||*{SYM#c::tag-#anon#ST[S32'numcpus'||U32'$pad0'||F64'cpuspeed'||F64'nodespeed'||ARR0000000000000000000000000000000000000000000000000000001000000000{S8}'machname'|]#}'cpuinfo'||S32'hres'||S32'vres'||F64'aspectratio'||S32'raydepth'||S32'antialiasing'||S32'verbosemode'||S32'boundmode'||S32'boundthresh'||U32'$pad2'||*{SYM#c::tag-list#}'texlist'||*{SYM#c::tag-list#}'cliplist'||U32'flags'||U32'$pad3'||SYM#c::tag-#anon#ST[S32'projection'||U32'$pad0'||SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#'center'||SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#'viewvec'||SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#'rightvec'||SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#'upvec'||F64'camzoom'||F64'px'||F64'py'||F64'psx'||F64'psy'||F64'focallength'||F64'left'||F64'right'||F64'top'||F64'bottom'||F64'aperture'||SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#'projcent'||*{P(*{V}|F64|F64)->SYM#c::tag-#anon#ST[F32'r'||F32'g'||F32'b'|]#}'cam_ray'||SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#'lowleft'||SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#'iplaneright'||SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#'iplaneup'|]#'camera'||*{P(*{V})->SYM#c::tag-#anon#ST[F32'r'||F32'g'||F32'b'|]#}'shader'||*{P(*{cSYM#c::tag-ray_t#}|*{cSYM#c::tag-#anon#ST[SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#'hit'||SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#'N'||SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#'L'||F64'Llen'|]#}|F64)->F64}'phongfunc'||S32'transmode'||U32'$pad4'||SYM#c::tag-#anon#ST[SYM#c::tag-#anon#ST[F32'r'||F32'g'||F32'b'|]#'background'||U32'$pad0'||SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#'gradient'||F64'gradtopval'||F64'gradbotval'||SYM#c::tag-#anon#ST[F32'r'||F32'g'||F32'b'|]#'backgroundtop'||SYM#c::tag-#anon#ST[F32'r'||F32'g'||F32'b'|]#'backgroundbot'|]#'bgtex'||*{P(*{cSYM#c::tag-ray_t#})->SYM#c::tag-#anon#ST[F32'r'||F32'g'||F32'b'|]#}'bgtexfunc'||SYM#c::tag-fogdata_t#'fog'||SYM#c::tag-#anon#ST[*{SYM#c::tag-#anon#ST[U32'id'||U32'$pad0'||*{V}'nextobj'||*{SYM#c::tag-#anon#ST[*{P(*{cV}|*{V})->V}'intersect'||*{P(*{cV}|*{cV}|*{cV}|*{V})->V}'normal'||*{P(*{V}|*{SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#}|*{SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#})->S32}'bbox'||*{P(*{V})->V}'freeobj'|]#}'methods'||*{SYM#c::tag-#anon#ST[S32'numplanes'||U32'$pad0'||*{F64}'planes'|]#}'clip'||*{SYM#c::tag-#anon#ST[*{P(*{cV}|*{cV}|*{V})->SYM#c::tag-#anon#ST[F32'r'||F32'g'||F32'b'|]#}'texfunc'||*{SYM#c::tag-#anon#ST[*{P(*{V})->V}'freetex'|]#}'methods'||U32'flags'||F32'ambient'||F32'diffuse'||F32'phong'||F32'phongexp'||S32'phongtype'||F32'specular'||F32'opacity'||F32'outline'||F32'outlinewidth'|]#}'tex'|]#}'boundedobj'||*{SYM#c::tag-#anon#ST[U32'id'||U32'$pad0'||*{V}'nextobj'||*{SYM#c::tag-#anon#ST[*{P(*{cV}|*{V})->V}'intersect'||*{P(*{cV}|*{cV}|*{cV}|*{V})->V}'normal'||*{P(*{V}|*{SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#}|*{SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#})->S32}'bbox'||*{P(*{V})->V}'freeobj'|]#}'methods'||*{SYM#c::tag-#anon#ST[S32'numplanes'||U32'$pad0'||*{F64}'planes'|]#}'clip'||*{SYM#c::tag-#anon#ST[*{P(*{cV}|*{cV}|*{V})->SYM#c::tag-#anon#ST[F32'r'||F32'g'||F32'b'|]#}'texfunc'||*{SYM#c::tag-#anon#ST[*{P(*{V})->V}'freetex'|]#}'methods'||U32'flags'||F32'ambient'||F32'diffuse'||F32'phong'||F32'phongexp'||S32'phongtype'||F32'specular'||F32'opacity'||F32'outline'||F32'outlinewidth'|]#}'tex'|]#}'unboundedobj'||S32'numobjects'||U32'$pad0'|]#'objgroup'||*{SYM#c::tag-list#}'lightlist'||F64'light_scale'||S32'numlights'||SYM#c::tag-amboccdata_t#'ambocc'||S32'scenecheck'||*{V}'parbuf'||*{V}'threads'||*{V}'threadparms'||*{SYM#c::tag-#anon#ST[S32'numplanes'||U32'$pad0'||*{F64}'planes'|]#}'curclipgroup'||S32'normalfixupmode'||U32'$pad5'|]$link259
// 
struct anon$71$link259;

// c::tag-#anon#ST[ARR0000000000000000000000000000000000000000000000000000000100000000{S8}'outfilename'||S32'writeimagefile'||U32'$pad0'||*{V}'img'||S32'imginternal'||S32'imgprocess'||F32'imggamma'||S32'imgbufformat'||S32'imgfileformat'||SYM#c::tag-#anon#ST[S32'cropmode'||S32'xres'||S32'yres'||S32'xstart'||S32'ystart'|]#'imgcrop'||S32'numthreads'||S32'nodes'||S32'mynode'||U32'$pad1'||*{SYM#c::tag-#anon#ST[S32'numcpus'||U32'$pad0'||F64'cpuspeed'||F64'nodespeed'||ARR0000000000000000000000000000000000000000000000000000001000000000{S8}'machname'|]#}'cpuinfo'||S32'hres'||S32'vres'||F64'aspectratio'||S32'raydepth'||S32'antialiasing'||S32'verbosemode'||S32'boundmode'||S32'boundthresh'||U32'$pad2'||*{SYM#c::tag-list#}'texlist'||*{SYM#c::tag-list#}'cliplist'||U32'flags'||U32'$pad3'||SYM#c::tag-#anon#ST[S32'projection'||U32'$pad0'||SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#'center'||SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#'viewvec'||SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#'rightvec'||SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#'upvec'||F64'camzoom'||F64'px'||F64'py'||F64'psx'||F64'psy'||F64'focallength'||F64'left'||F64'right'||F64'top'||F64'bottom'||F64'aperture'||SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#'projcent'||*{P(*{V}|F64|F64)->SYM#c::tag-#anon#ST[F32'r'||F32'g'||F32'b'|]#}'cam_ray'||SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#'lowleft'||SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#'iplaneright'||SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#'iplaneup'|]#'camera'||*{P(*{V})->SYM#c::tag-#anon#ST[F32'r'||F32'g'||F32'b'|]#}'shader'||*{P(*{cSYM#c::tag-ray_t#}|*{cSYM#c::tag-#anon#ST[SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#'hit'||SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#'N'||SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#'L'||F64'Llen'|]#}|F64)->F64}'phongfunc'||S32'transmode'||U32'$pad4'||SYM#c::tag-#anon#ST[SYM#c::tag-#anon#ST[F32'r'||F32'g'||F32'b'|]#'background'||U32'$pad0'||SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#'gradient'||F64'gradtopval'||F64'gradbotval'||SYM#c::tag-#anon#ST[F32'r'||F32'g'||F32'b'|]#'backgroundtop'||SYM#c::tag-#anon#ST[F32'r'||F32'g'||F32'b'|]#'backgroundbot'|]#'bgtex'||*{P(*{cSYM#c::tag-ray_t#})->SYM#c::tag-#anon#ST[F32'r'||F32'g'||F32'b'|]#}'bgtexfunc'||SYM#c::tag-fogdata_t#'fog'||SYM#c::tag-#anon#ST[*{SYM#c::tag-#anon#ST[U32'id'||U32'$pad0'||*{V}'nextobj'||*{SYM#c::tag-#anon#ST[*{P(*{cV}|*{V})->V}'intersect'||*{P(*{cV}|*{cV}|*{cV}|*{V})->V}'normal'||*{P(*{V}|*{SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#}|*{SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#})->S32}'bbox'||*{P(*{V})->V}'freeobj'|]#}'methods'||*{SYM#c::tag-#anon#ST[S32'numplanes'||U32'$pad0'||*{F64}'planes'|]#}'clip'||*{SYM#c::tag-#anon#ST[*{P(*{cV}|*{cV}|*{V})->SYM#c::tag-#anon#ST[F32'r'||F32'g'||F32'b'|]#}'texfunc'||*{SYM#c::tag-#anon#ST[*{P(*{V})->V}'freetex'|]#}'methods'||U32'flags'||F32'ambient'||F32'diffuse'||F32'phong'||F32'phongexp'||S32'phongtype'||F32'specular'||F32'opacity'||F32'outline'||F32'outlinewidth'|]#}'tex'|]#}'boundedobj'||*{SYM#c::tag-#anon#ST[U32'id'||U32'$pad0'||*{V}'nextobj'||*{SYM#c::tag-#anon#ST[*{P(*{cV}|*{V})->V}'intersect'||*{P(*{cV}|*{cV}|*{cV}|*{V})->V}'normal'||*{P(*{V}|*{SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#}|*{SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#})->S32}'bbox'||*{P(*{V})->V}'freeobj'|]#}'methods'||*{SYM#c::tag-#anon#ST[S32'numplanes'||U32'$pad0'||*{F64}'planes'|]#}'clip'||*{SYM#c::tag-#anon#ST[*{P(*{cV}|*{cV}|*{V})->SYM#c::tag-#anon#ST[F32'r'||F32'g'||F32'b'|]#}'texfunc'||*{SYM#c::tag-#anon#ST[*{P(*{V})->V}'freetex'|]#}'methods'||U32'flags'||F32'ambient'||F32'diffuse'||F32'phong'||F32'phongexp'||S32'phongtype'||F32'specular'||F32'opacity'||F32'outline'||F32'outlinewidth'|]#}'tex'|]#}'unboundedobj'||S32'numobjects'||U32'$pad0'|]#'objgroup'||*{SYM#c::tag-list#}'lightlist'||F64'light_scale'||S32'numlights'||SYM#c::tag-amboccdata_t#'ambocc'||S32'scenecheck'||*{V}'parbuf'||*{V}'threads'||*{V}'threadparms'||*{SYM#c::tag-#anon#ST[S32'numplanes'||U32'$pad0'||*{F64}'planes'|]#}'curclipgroup'||S32'normalfixupmode'||U32'$pad5'|]$link4
// 
struct anon$32$link4;

// c::tag-#anon#ST[ARR0000000000000000000000000000000000000000000000000000000100000000{S8}'outfilename'||S32'writeimagefile'||U32'$pad0'||*{V}'img'||S32'imginternal'||S32'imgprocess'||F32'imggamma'||S32'imgbufformat'||S32'imgfileformat'||SYM#c::tag-#anon#ST[S32'cropmode'||S32'xres'||S32'yres'||S32'xstart'||S32'ystart'|]#'imgcrop'||S32'numthreads'||S32'nodes'||S32'mynode'||U32'$pad1'||*{SYM#c::tag-#anon#ST[S32'numcpus'||U32'$pad0'||F64'cpuspeed'||F64'nodespeed'||ARR0000000000000000000000000000000000000000000000000000001000000000{S8}'machname'|]#}'cpuinfo'||S32'hres'||S32'vres'||F64'aspectratio'||S32'raydepth'||S32'antialiasing'||S32'verbosemode'||S32'boundmode'||S32'boundthresh'||U32'$pad2'||*{SYM#c::tag-list#}'texlist'||*{SYM#c::tag-list#}'cliplist'||U32'flags'||U32'$pad3'||SYM#c::tag-#anon#ST[S32'projection'||U32'$pad0'||SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#'center'||SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#'viewvec'||SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#'rightvec'||SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#'upvec'||F64'camzoom'||F64'px'||F64'py'||F64'psx'||F64'psy'||F64'focallength'||F64'left'||F64'right'||F64'top'||F64'bottom'||F64'aperture'||SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#'projcent'||*{P(*{V}|F64|F64)->SYM#c::tag-#anon#ST[F32'r'||F32'g'||F32'b'|]#}'cam_ray'||SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#'lowleft'||SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#'iplaneright'||SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#'iplaneup'|]#'camera'||*{P(*{V})->SYM#c::tag-#anon#ST[F32'r'||F32'g'||F32'b'|]#}'shader'||*{P(*{cSYM#c::tag-ray_t#}|*{cSYM#c::tag-#anon#ST[SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#'hit'||SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#'N'||SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#'L'||F64'Llen'|]#}|F64)->F64}'phongfunc'||S32'transmode'||U32'$pad4'||SYM#c::tag-#anon#ST[SYM#c::tag-#anon#ST[F32'r'||F32'g'||F32'b'|]#'background'||U32'$pad0'||SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#'gradient'||F64'gradtopval'||F64'gradbotval'||SYM#c::tag-#anon#ST[F32'r'||F32'g'||F32'b'|]#'backgroundtop'||SYM#c::tag-#anon#ST[F32'r'||F32'g'||F32'b'|]#'backgroundbot'|]#'bgtex'||*{P(*{cSYM#c::tag-ray_t#})->SYM#c::tag-#anon#ST[F32'r'||F32'g'||F32'b'|]#}'bgtexfunc'||SYM#c::tag-fogdata_t#'fog'||SYM#c::tag-#anon#ST[*{SYM#c::tag-#anon#ST[U32'id'||U32'$pad0'||*{V}'nextobj'||*{SYM#c::tag-#anon#ST[*{P(*{cV}|*{V})->V}'intersect'||*{P(*{cV}|*{cV}|*{cV}|*{V})->V}'normal'||*{P(*{V}|*{SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#}|*{SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#})->S32}'bbox'||*{P(*{V})->V}'freeobj'|]#}'methods'||*{SYM#c::tag-#anon#ST[S32'numplanes'||U32'$pad0'||*{F64}'planes'|]#}'clip'||*{SYM#c::tag-#anon#ST[*{P(*{cV}|*{cV}|*{V})->SYM#c::tag-#anon#ST[F32'r'||F32'g'||F32'b'|]#}'texfunc'||*{SYM#c::tag-#anon#ST[*{P(*{V})->V}'freetex'|]#}'methods'||U32'flags'||F32'ambient'||F32'diffuse'||F32'phong'||F32'phongexp'||S32'phongtype'||F32'specular'||F32'opacity'||F32'outline'||F32'outlinewidth'|]#}'tex'|]#}'boundedobj'||*{SYM#c::tag-#anon#ST[U32'id'||U32'$pad0'||*{V}'nextobj'||*{SYM#c::tag-#anon#ST[*{P(*{cV}|*{V})->V}'intersect'||*{P(*{cV}|*{cV}|*{cV}|*{V})->V}'normal'||*{P(*{V}|*{SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#}|*{SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#})->S32}'bbox'||*{P(*{V})->V}'freeobj'|]#}'methods'||*{SYM#c::tag-#anon#ST[S32'numplanes'||U32'$pad0'||*{F64}'planes'|]#}'clip'||*{SYM#c::tag-#anon#ST[*{P(*{cV}|*{cV}|*{V})->SYM#c::tag-#anon#ST[F32'r'||F32'g'||F32'b'|]#}'texfunc'||*{SYM#c::tag-#anon#ST[*{P(*{V})->V}'freetex'|]#}'methods'||U32'flags'||F32'ambient'||F32'diffuse'||F32'phong'||F32'phongexp'||S32'phongtype'||F32'specular'||F32'opacity'||F32'outline'||F32'outlinewidth'|]#}'tex'|]#}'unboundedobj'||S32'numobjects'||U32'$pad0'|]#'objgroup'||*{SYM#c::tag-list#}'lightlist'||F64'light_scale'||S32'numlights'||SYM#c::tag-amboccdata_t#'ambocc'||S32'scenecheck'||*{V}'parbuf'||*{V}'threads'||*{V}'threadparms'||*{SYM#c::tag-#anon#ST[S32'numplanes'||U32'$pad0'||*{F64}'planes'|]#}'curclipgroup'||S32'normalfixupmode'||U32'$pad5'|]$link40
// 
struct anon$38$link40;

// c::tag-#anon#ST[ARR0000000000000000000000000000000000000000000000000000000100000000{S8}'outfilename'||S32'writeimagefile'||U32'$pad0'||*{V}'img'||S32'imginternal'||S32'imgprocess'||F32'imggamma'||S32'imgbufformat'||S32'imgfileformat'||SYM#c::tag-#anon#ST[S32'cropmode'||S32'xres'||S32'yres'||S32'xstart'||S32'ystart'|]#'imgcrop'||S32'numthreads'||S32'nodes'||S32'mynode'||U32'$pad1'||*{SYM#c::tag-#anon#ST[S32'numcpus'||U32'$pad0'||F64'cpuspeed'||F64'nodespeed'||ARR0000000000000000000000000000000000000000000000000000001000000000{S8}'machname'|]#}'cpuinfo'||S32'hres'||S32'vres'||F64'aspectratio'||S32'raydepth'||S32'antialiasing'||S32'verbosemode'||S32'boundmode'||S32'boundthresh'||U32'$pad2'||*{SYM#c::tag-list#}'texlist'||*{SYM#c::tag-list#}'cliplist'||U32'flags'||U32'$pad3'||SYM#c::tag-#anon#ST[S32'projection'||U32'$pad0'||SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#'center'||SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#'viewvec'||SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#'rightvec'||SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#'upvec'||F64'camzoom'||F64'px'||F64'py'||F64'psx'||F64'psy'||F64'focallength'||F64'left'||F64'right'||F64'top'||F64'bottom'||F64'aperture'||SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#'projcent'||*{P(*{V}|F64|F64)->SYM#c::tag-#anon#ST[F32'r'||F32'g'||F32'b'|]#}'cam_ray'||SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#'lowleft'||SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#'iplaneright'||SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#'iplaneup'|]#'camera'||*{P(*{V})->SYM#c::tag-#anon#ST[F32'r'||F32'g'||F32'b'|]#}'shader'||*{P(*{cSYM#c::tag-ray_t#}|*{cSYM#c::tag-#anon#ST[SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#'hit'||SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#'N'||SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#'L'||F64'Llen'|]#}|F64)->F64}'phongfunc'||S32'transmode'||U32'$pad4'||SYM#c::tag-#anon#ST[SYM#c::tag-#anon#ST[F32'r'||F32'g'||F32'b'|]#'background'||U32'$pad0'||SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#'gradient'||F64'gradtopval'||F64'gradbotval'||SYM#c::tag-#anon#ST[F32'r'||F32'g'||F32'b'|]#'backgroundtop'||SYM#c::tag-#anon#ST[F32'r'||F32'g'||F32'b'|]#'backgroundbot'|]#'bgtex'||*{P(*{cSYM#c::tag-ray_t#})->SYM#c::tag-#anon#ST[F32'r'||F32'g'||F32'b'|]#}'bgtexfunc'||SYM#c::tag-fogdata_t#'fog'||SYM#c::tag-#anon#ST[*{SYM#c::tag-#anon#ST[U32'id'||U32'$pad0'||*{V}'nextobj'||*{SYM#c::tag-#anon#ST[*{P(*{cV}|*{V})->V}'intersect'||*{P(*{cV}|*{cV}|*{cV}|*{V})->V}'normal'||*{P(*{V}|*{SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#}|*{SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#})->S32}'bbox'||*{P(*{V})->V}'freeobj'|]#}'methods'||*{SYM#c::tag-#anon#ST[S32'numplanes'||U32'$pad0'||*{F64}'planes'|]#}'clip'||*{SYM#c::tag-#anon#ST[*{P(*{cV}|*{cV}|*{V})->SYM#c::tag-#anon#ST[F32'r'||F32'g'||F32'b'|]#}'texfunc'||*{SYM#c::tag-#anon#ST[*{P(*{V})->V}'freetex'|]#}'methods'||U32'flags'||F32'ambient'||F32'diffuse'||F32'phong'||F32'phongexp'||S32'phongtype'||F32'specular'||F32'opacity'||F32'outline'||F32'outlinewidth'|]#}'tex'|]#}'boundedobj'||*{SYM#c::tag-#anon#ST[U32'id'||U32'$pad0'||*{V}'nextobj'||*{SYM#c::tag-#anon#ST[*{P(*{cV}|*{V})->V}'intersect'||*{P(*{cV}|*{cV}|*{cV}|*{V})->V}'normal'||*{P(*{V}|*{SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#}|*{SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#})->S32}'bbox'||*{P(*{V})->V}'freeobj'|]#}'methods'||*{SYM#c::tag-#anon#ST[S32'numplanes'||U32'$pad0'||*{F64}'planes'|]#}'clip'||*{SYM#c::tag-#anon#ST[*{P(*{cV}|*{cV}|*{V})->SYM#c::tag-#anon#ST[F32'r'||F32'g'||F32'b'|]#}'texfunc'||*{SYM#c::tag-#anon#ST[*{P(*{V})->V}'freetex'|]#}'methods'||U32'flags'||F32'ambient'||F32'diffuse'||F32'phong'||F32'phongexp'||S32'phongtype'||F32'specular'||F32'opacity'||F32'outline'||F32'outlinewidth'|]#}'tex'|]#}'unboundedobj'||S32'numobjects'||U32'$pad0'|]#'objgroup'||*{SYM#c::tag-list#}'lightlist'||F64'light_scale'||S32'numlights'||SYM#c::tag-amboccdata_t#'ambocc'||S32'scenecheck'||*{V}'parbuf'||*{V}'threads'||*{V}'threadparms'||*{SYM#c::tag-#anon#ST[S32'numplanes'||U32'$pad0'||*{F64}'planes'|]#}'curclipgroup'||S32'normalfixupmode'||U32'$pad5'|]$link5
// 
struct anon$52$link5;

// c::tag-#anon#ST[ARR0000000000000000000000000000000000000000000000000000000100000000{S8}'outfilename'||S32'writeimagefile'||U32'$pad0'||*{V}'img'||S32'imginternal'||S32'imgprocess'||F32'imggamma'||S32'imgbufformat'||S32'imgfileformat'||SYM#c::tag-#anon#ST[S32'cropmode'||S32'xres'||S32'yres'||S32'xstart'||S32'ystart'|]#'imgcrop'||S32'numthreads'||S32'nodes'||S32'mynode'||U32'$pad1'||*{SYM#c::tag-#anon#ST[S32'numcpus'||U32'$pad0'||F64'cpuspeed'||F64'nodespeed'||ARR0000000000000000000000000000000000000000000000000000001000000000{S8}'machname'|]#}'cpuinfo'||S32'hres'||S32'vres'||F64'aspectratio'||S32'raydepth'||S32'antialiasing'||S32'verbosemode'||S32'boundmode'||S32'boundthresh'||U32'$pad2'||*{SYM#c::tag-list#}'texlist'||*{SYM#c::tag-list#}'cliplist'||U32'flags'||U32'$pad3'||SYM#c::tag-#anon#ST[S32'projection'||U32'$pad0'||SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#'center'||SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#'viewvec'||SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#'rightvec'||SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#'upvec'||F64'camzoom'||F64'px'||F64'py'||F64'psx'||F64'psy'||F64'focallength'||F64'left'||F64'right'||F64'top'||F64'bottom'||F64'aperture'||SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#'projcent'||*{P(*{V}|F64|F64)->SYM#c::tag-#anon#ST[F32'r'||F32'g'||F32'b'|]#}'cam_ray'||SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#'lowleft'||SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#'iplaneright'||SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#'iplaneup'|]#'camera'||*{P(*{V})->SYM#c::tag-#anon#ST[F32'r'||F32'g'||F32'b'|]#}'shader'||*{P(*{cSYM#c::tag-ray_t#}|*{cSYM#c::tag-#anon#ST[SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#'hit'||SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#'N'||SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#'L'||F64'Llen'|]#}|F64)->F64}'phongfunc'||S32'transmode'||U32'$pad4'||SYM#c::tag-#anon#ST[SYM#c::tag-#anon#ST[F32'r'||F32'g'||F32'b'|]#'background'||U32'$pad0'||SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#'gradient'||F64'gradtopval'||F64'gradbotval'||SYM#c::tag-#anon#ST[F32'r'||F32'g'||F32'b'|]#'backgroundtop'||SYM#c::tag-#anon#ST[F32'r'||F32'g'||F32'b'|]#'backgroundbot'|]#'bgtex'||*{P(*{cSYM#c::tag-ray_t#})->SYM#c::tag-#anon#ST[F32'r'||F32'g'||F32'b'|]#}'bgtexfunc'||SYM#c::tag-fogdata_t#'fog'||SYM#c::tag-#anon#ST[*{SYM#c::tag-#anon#ST[U32'id'||U32'$pad0'||*{V}'nextobj'||*{SYM#c::tag-#anon#ST[*{P(*{cV}|*{V})->V}'intersect'||*{P(*{cV}|*{cV}|*{cV}|*{V})->V}'normal'||*{P(*{V}|*{SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#}|*{SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#})->S32}'bbox'||*{P(*{V})->V}'freeobj'|]#}'methods'||*{SYM#c::tag-#anon#ST[S32'numplanes'||U32'$pad0'||*{F64}'planes'|]#}'clip'||*{SYM#c::tag-#anon#ST[*{P(*{cV}|*{cV}|*{V})->SYM#c::tag-#anon#ST[F32'r'||F32'g'||F32'b'|]#}'texfunc'||*{SYM#c::tag-#anon#ST[*{P(*{V})->V}'freetex'|]#}'methods'||U32'flags'||F32'ambient'||F32'diffuse'||F32'phong'||F32'phongexp'||S32'phongtype'||F32'specular'||F32'opacity'||F32'outline'||F32'outlinewidth'|]#}'tex'|]#}'boundedobj'||*{SYM#c::tag-#anon#ST[U32'id'||U32'$pad0'||*{V}'nextobj'||*{SYM#c::tag-#anon#ST[*{P(*{cV}|*{V})->V}'intersect'||*{P(*{cV}|*{cV}|*{cV}|*{V})->V}'normal'||*{P(*{V}|*{SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#}|*{SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#})->S32}'bbox'||*{P(*{V})->V}'freeobj'|]#}'methods'||*{SYM#c::tag-#anon#ST[S32'numplanes'||U32'$pad0'||*{F64}'planes'|]#}'clip'||*{SYM#c::tag-#anon#ST[*{P(*{cV}|*{cV}|*{V})->SYM#c::tag-#anon#ST[F32'r'||F32'g'||F32'b'|]#}'texfunc'||*{SYM#c::tag-#anon#ST[*{P(*{V})->V}'freetex'|]#}'methods'||U32'flags'||F32'ambient'||F32'diffuse'||F32'phong'||F32'phongexp'||S32'phongtype'||F32'specular'||F32'opacity'||F32'outline'||F32'outlinewidth'|]#}'tex'|]#}'unboundedobj'||S32'numobjects'||U32'$pad0'|]#'objgroup'||*{SYM#c::tag-list#}'lightlist'||F64'light_scale'||S32'numlights'||SYM#c::tag-amboccdata_t#'ambocc'||S32'scenecheck'||*{V}'parbuf'||*{V}'threads'||*{V}'threadparms'||*{SYM#c::tag-#anon#ST[S32'numplanes'||U32'$pad0'||*{F64}'planes'|]#}'curclipgroup'||S32'normalfixupmode'||U32'$pad5'|]$link71
// 
struct anon$67$link71;

// c::tag-#anon#ST[ARR0000000000000000000000000000000000000000000000000000000100000000{S8}'outfilename'||S32'writeimagefile'||U32'$pad0'||*{V}'img'||S32'imginternal'||S32'imgprocess'||F32'imggamma'||S32'imgbufformat'||S32'imgfileformat'||SYM#c::tag-#anon#ST[S32'cropmode'||S32'xres'||S32'yres'||S32'xstart'||S32'ystart'|]#'imgcrop'||S32'numthreads'||S32'nodes'||S32'mynode'||U32'$pad1'||*{SYM#c::tag-#anon#ST[S32'numcpus'||U32'$pad0'||F64'cpuspeed'||F64'nodespeed'||ARR0000000000000000000000000000000000000000000000000000001000000000{S8}'machname'|]#}'cpuinfo'||S32'hres'||S32'vres'||F64'aspectratio'||S32'raydepth'||S32'antialiasing'||S32'verbosemode'||S32'boundmode'||S32'boundthresh'||U32'$pad2'||*{SYM#c::tag-list#}'texlist'||*{SYM#c::tag-list#}'cliplist'||U32'flags'||U32'$pad3'||SYM#c::tag-#anon#ST[S32'projection'||U32'$pad0'||SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#'center'||SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#'viewvec'||SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#'rightvec'||SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#'upvec'||F64'camzoom'||F64'px'||F64'py'||F64'psx'||F64'psy'||F64'focallength'||F64'left'||F64'right'||F64'top'||F64'bottom'||F64'aperture'||SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#'projcent'||*{P(*{V}|F64|F64)->SYM#c::tag-#anon#ST[F32'r'||F32'g'||F32'b'|]#}'cam_ray'||SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#'lowleft'||SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#'iplaneright'||SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#'iplaneup'|]#'camera'||*{P(*{V})->SYM#c::tag-#anon#ST[F32'r'||F32'g'||F32'b'|]#}'shader'||*{P(*{cSYM#c::tag-ray_t#}|*{cSYM#c::tag-#anon#ST[SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#'hit'||SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#'N'||SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#'L'||F64'Llen'|]#}|F64)->F64}'phongfunc'||S32'transmode'||U32'$pad4'||SYM#c::tag-#anon#ST[SYM#c::tag-#anon#ST[F32'r'||F32'g'||F32'b'|]#'background'||U32'$pad0'||SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#'gradient'||F64'gradtopval'||F64'gradbotval'||SYM#c::tag-#anon#ST[F32'r'||F32'g'||F32'b'|]#'backgroundtop'||SYM#c::tag-#anon#ST[F32'r'||F32'g'||F32'b'|]#'backgroundbot'|]#'bgtex'||*{P(*{cSYM#c::tag-ray_t#})->SYM#c::tag-#anon#ST[F32'r'||F32'g'||F32'b'|]#}'bgtexfunc'||SYM#c::tag-fogdata_t#'fog'||SYM#c::tag-#anon#ST[*{SYM#c::tag-#anon#ST[U32'id'||U32'$pad0'||*{V}'nextobj'||*{SYM#c::tag-#anon#ST[*{P(*{cV}|*{V})->V}'intersect'||*{P(*{cV}|*{cV}|*{cV}|*{V})->V}'normal'||*{P(*{V}|*{SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#}|*{SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#})->S32}'bbox'||*{P(*{V})->V}'freeobj'|]#}'methods'||*{SYM#c::tag-#anon#ST[S32'numplanes'||U32'$pad0'||*{F64}'planes'|]#}'clip'||*{SYM#c::tag-#anon#ST[*{P(*{cV}|*{cV}|*{V})->SYM#c::tag-#anon#ST[F32'r'||F32'g'||F32'b'|]#}'texfunc'||*{SYM#c::tag-#anon#ST[*{P(*{V})->V}'freetex'|]#}'methods'||U32'flags'||F32'ambient'||F32'diffuse'||F32'phong'||F32'phongexp'||S32'phongtype'||F32'specular'||F32'opacity'||F32'outline'||F32'outlinewidth'|]#}'tex'|]#}'boundedobj'||*{SYM#c::tag-#anon#ST[U32'id'||U32'$pad0'||*{V}'nextobj'||*{SYM#c::tag-#anon#ST[*{P(*{cV}|*{V})->V}'intersect'||*{P(*{cV}|*{cV}|*{cV}|*{V})->V}'normal'||*{P(*{V}|*{SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#}|*{SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#})->S32}'bbox'||*{P(*{V})->V}'freeobj'|]#}'methods'||*{SYM#c::tag-#anon#ST[S32'numplanes'||U32'$pad0'||*{F64}'planes'|]#}'clip'||*{SYM#c::tag-#anon#ST[*{P(*{cV}|*{cV}|*{V})->SYM#c::tag-#anon#ST[F32'r'||F32'g'||F32'b'|]#}'texfunc'||*{SYM#c::tag-#anon#ST[*{P(*{V})->V}'freetex'|]#}'methods'||U32'flags'||F32'ambient'||F32'diffuse'||F32'phong'||F32'phongexp'||S32'phongtype'||F32'specular'||F32'opacity'||F32'outline'||F32'outlinewidth'|]#}'tex'|]#}'unboundedobj'||S32'numobjects'||U32'$pad0'|]#'objgroup'||*{SYM#c::tag-list#}'lightlist'||F64'light_scale'||S32'numlights'||SYM#c::tag-amboccdata_t#'ambocc'||S32'scenecheck'||*{V}'parbuf'||*{V}'threads'||*{V}'threadparms'||*{SYM#c::tag-#anon#ST[S32'numplanes'||U32'$pad0'||*{F64}'planes'|]#}'curclipgroup'||S32'normalfixupmode'||U32'$pad5'|]$link94
// 
struct anon$44$link94;

// c::tag-#anon#ST[F32'r'||F32'g'||F32'b'|]
// 
struct anon$4;

// c::tag-#anon#ST[F32'x'||F32'y'||F32'z'|]
// 
struct anon$2;

// c::tag-#anon#ST[F64'a'||F64'b'||F64'c'||F64'd'||F64'e'||F64'f'||F64'g'||F64'h'||F64'i'||F64'j'|]
// 
struct anon$27;

// c::tag-#anon#ST[F64'rx1'||F64'rx2'||F64'rx3'||F64'ry1'||F64'ry2'||F64'ry3'||F64'rz1'||F64'rz2'||F64'rz3'|]
// 
struct anon$8;

// c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]
// 
struct anon$0;

// c::tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]
// 
struct anon$41;

// c::tag-#anon#ST[S32'cropmode'||S32'xres'||S32'yres'||S32'xstart'||S32'ystart'|]
// 
struct anon$12;

// c::tag-#anon#ST[S32'levels'||U32'$pad0'||*{*{SYM#c::tag-#anon#ST[S32'loaded'||S32'xres'||S32'yres'||S32'zres'||S32'bpp'||ARR0000000000000000000000000000000000000000000000000000000001100000{S8}'name'||U32'$pad0'||*{U8}'data'|]#}}'images'|]
// 
struct anon$34;

// c::tag-#anon#ST[S32'loaded'||S32'xres'||S32'yres'||S32'zres'||F64'opacity'||ARR0000000000000000000000000000000000000000000000000000000001100000{S8}'name'||*{U8}'data'|]
// 
struct anon$10;

// c::tag-#anon#ST[S32'loaded'||S32'xres'||S32'yres'||S32'zres'||S32'bpp'||ARR0000000000000000000000000000000000000000000000000000000001100000{S8}'name'||U32'$pad0'||*{U8}'data'|]
// 
struct anon$33;

// c::tag-#anon#ST[S32'num'||U32'$pad0'||SYM#c::tag-#anon#ST[*{cSYM#c::tag-#anon#ST[U32'id'||U32'$pad0'||*{V}'nextobj'||*{SYM#c::tag-#anon#ST[*{P(*{cV}|*{V})->V}'intersect'||*{P(*{cV}|*{cV}|*{cV}|*{V})->V}'normal'||*{P(*{V}|*{SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#}|*{SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#})->S32}'bbox'||*{P(*{V})->V}'freeobj'|]#}'methods'||*{SYM#c::tag-#anon#ST[S32'numplanes'||U32'$pad0'||*{F64}'planes'|]#}'clip'||*{SYM#c::tag-#anon#ST[*{P(*{cV}|*{cV}|*{V})->SYM#c::tag-#anon#ST[F32'r'||F32'g'||F32'b'|]#}'texfunc'||*{SYM#c::tag-#anon#ST[*{P(*{V})->V}'freetex'|]#}'methods'||U32'flags'||F32'ambient'||F32'diffuse'||F32'phong'||F32'phongexp'||S32'phongtype'||F32'specular'||F32'opacity'||F32'outline'||F32'outlinewidth'|]#}'tex'|]#}'obj'||F64't'|]#'closest'||F64'shadowfilter'|]
// 
struct anon$16;

// c::tag-#anon#ST[S32'numcpus'||U32'$pad0'||F64'cpuspeed'||F64'nodespeed'||ARR0000000000000000000000000000000000000000000000000000001000000000{S8}'machname'|]
// 
struct anon$13;

// c::tag-#anon#ST[S32'numplanes'||U32'$pad0'||*{F64}'planes'|]
// 
struct anon$22;

// c::tag-#anon#ST[S32'projection'||U32'$pad0'||SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#'center'||SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#'viewvec'||SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#'rightvec'||SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#'upvec'||F64'camzoom'||F64'px'||F64'py'||F64'psx'||F64'psy'||F64'focallength'||F64'left'||F64'right'||F64'top'||F64'bottom'||F64'aperture'||SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#'projcent'||*{P(*{V}|F64|F64)->SYM#c::tag-#anon#ST[F32'r'||F32'g'||F32'b'|]#}'cam_ray'||SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#'lowleft'||SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#'iplaneright'||SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#'iplaneup'|]
// 
struct anon$14;

// c::tag-#anon#ST[S32'texturefunc'||SYM#c::tag-#anon#ST[F32'r'||F32'g'||F32'b'|]#'col'||S32'shadowcast'||U32'$pad0'||F64'ambient'||F64'diffuse'||F64'specular'||F64'opacity'||SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#'ctr'||SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#'rot'||SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#'scale'||SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#'uaxs'||SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#'vaxs'||SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#'waxs'||ARR0000000000000000000000000000000000000000000000000000000001100000{S8}'imap'|]
// 
struct anon$7;

// c::tag-#anon#ST[S32'tid'||S32'nthr'||*{SYM#c::tag-#anon#ST[ARR0000000000000000000000000000000000000000000000000000000100000000{S8}'outfilename'||S32'writeimagefile'||U32'$pad0'||*{V}'img'||S32'imginternal'||S32'imgprocess'||F32'imggamma'||S32'imgbufformat'||S32'imgfileformat'||SYM#c::tag-#anon#ST[S32'cropmode'||S32'xres'||S32'yres'||S32'xstart'||S32'ystart'|]#'imgcrop'||S32'numthreads'||S32'nodes'||S32'mynode'||U32'$pad1'||*{SYM#c::tag-#anon#ST[S32'numcpus'||U32'$pad0'||F64'cpuspeed'||F64'nodespeed'||ARR0000000000000000000000000000000000000000000000000000001000000000{S8}'machname'|]#}'cpuinfo'||S32'hres'||S32'vres'||F64'aspectratio'||S32'raydepth'||S32'antialiasing'||S32'verbosemode'||S32'boundmode'||S32'boundthresh'||U32'$pad2'||*{SYM#c::tag-list#}'texlist'||*{SYM#c::tag-list#}'cliplist'||U32'flags'||U32'$pad3'||SYM#c::tag-#anon#ST[S32'projection'||U32'$pad0'||SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#'center'||SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#'viewvec'||SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#'rightvec'||SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#'upvec'||F64'camzoom'||F64'px'||F64'py'||F64'psx'||F64'psy'||F64'focallength'||F64'left'||F64'right'||F64'top'||F64'bottom'||F64'aperture'||SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#'projcent'||*{P(*{V}|F64|F64)->SYM#c::tag-#anon#ST[F32'r'||F32'g'||F32'b'|]#}'cam_ray'||SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#'lowleft'||SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#'iplaneright'||SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#'iplaneup'|]#'camera'||*{P(*{V})->SYM#c::tag-#anon#ST[F32'r'||F32'g'||F32'b'|]#}'shader'||*{P(*{cSYM#c::tag-ray_t#}|*{cSYM#c::tag-#anon#ST[SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#'hit'||SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#'N'||SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#'L'||F64'Llen'|]#}|F64)->F64}'phongfunc'||S32'transmode'||U32'$pad4'||SYM#c::tag-#anon#ST[SYM#c::tag-#anon#ST[F32'r'||F32'g'||F32'b'|]#'background'||U32'$pad0'||SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#'gradient'||F64'gradtopval'||F64'gradbotval'||SYM#c::tag-#anon#ST[F32'r'||F32'g'||F32'b'|]#'backgroundtop'||SYM#c::tag-#anon#ST[F32'r'||F32'g'||F32'b'|]#'backgroundbot'|]#'bgtex'||*{P(*{cSYM#c::tag-ray_t#})->SYM#c::tag-#anon#ST[F32'r'||F32'g'||F32'b'|]#}'bgtexfunc'||SYM#c::tag-fogdata_t#'fog'||SYM#c::tag-#anon#ST[*{SYM#c::tag-#anon#ST[U32'id'||U32'$pad0'||*{V}'nextobj'||*{SYM#c::tag-#anon#ST[*{P(*{cV}|*{V})->V}'intersect'||*{P(*{cV}|*{cV}|*{cV}|*{V})->V}'normal'||*{P(*{V}|*{SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#}|*{SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#})->S32}'bbox'||*{P(*{V})->V}'freeobj'|]#}'methods'||*{SYM#c::tag-#anon#ST[S32'numplanes'||U32'$pad0'||*{F64}'planes'|]#}'clip'||*{SYM#c::tag-#anon#ST[*{P(*{cV}|*{cV}|*{V})->SYM#c::tag-#anon#ST[F32'r'||F32'g'||F32'b'|]#}'texfunc'||*{SYM#c::tag-#anon#ST[*{P(*{V})->V}'freetex'|]#}'methods'||U32'flags'||F32'ambient'||F32'diffuse'||F32'phong'||F32'phongexp'||S32'phongtype'||F32'specular'||F32'opacity'||F32'outline'||F32'outlinewidth'|]#}'tex'|]#}'boundedobj'||*{SYM#c::tag-#anon#ST[U32'id'||U32'$pad0'||*{V}'nextobj'||*{SYM#c::tag-#anon#ST[*{P(*{cV}|*{V})->V}'intersect'||*{P(*{cV}|*{cV}|*{cV}|*{V})->V}'normal'||*{P(*{V}|*{SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#}|*{SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#})->S32}'bbox'||*{P(*{V})->V}'freeobj'|]#}'methods'||*{SYM#c::tag-#anon#ST[S32'numplanes'||U32'$pad0'||*{F64}'planes'|]#}'clip'||*{SYM#c::tag-#anon#ST[*{P(*{cV}|*{cV}|*{V})->SYM#c::tag-#anon#ST[F32'r'||F32'g'||F32'b'|]#}'texfunc'||*{SYM#c::tag-#anon#ST[*{P(*{V})->V}'freetex'|]#}'methods'||U32'flags'||F32'ambient'||F32'diffuse'||F32'phong'||F32'phongexp'||S32'phongtype'||F32'specular'||F32'opacity'||F32'outline'||F32'outlinewidth'|]#}'tex'|]#}'unboundedobj'||S32'numobjects'||U32'$pad0'|]#'objgroup'||*{SYM#c::tag-list#}'lightlist'||F64'light_scale'||S32'numlights'||SYM#c::tag-amboccdata_t#'ambocc'||S32'scenecheck'||*{V}'parbuf'||*{V}'threads'||*{V}'threadparms'||*{SYM#c::tag-#anon#ST[S32'numplanes'||U32'$pad0'||*{F64}'planes'|]#}'curclipgroup'||S32'normalfixupmode'||U32'$pad5'|]#}'scene'||*{U64}'local_mbox'||U64'serialno'||S32'startx'||S32'stopx'||S32'xinc'||S32'starty'||S32'stopy'||S32'yinc'||*{SYM#c::tag-barrier_struct#}'runbar'|]
// 
struct anon$45;

// c::tag-#anon#ST[S32'tid'||S32'nthr'||*{SYM#c::tag-#anon#ST[ARR0000000000000000000000000000000000000000000000000000000100000000{S8}'outfilename'||S32'writeimagefile'||U32'$pad0'||*{V}'img'||S32'imginternal'||S32'imgprocess'||F32'imggamma'||S32'imgbufformat'||S32'imgfileformat'||SYM#c::tag-#anon#ST[S32'cropmode'||S32'xres'||S32'yres'||S32'xstart'||S32'ystart'|]#'imgcrop'||S32'numthreads'||S32'nodes'||S32'mynode'||U32'$pad1'||*{SYM#c::tag-#anon#ST[S32'numcpus'||U32'$pad0'||F64'cpuspeed'||F64'nodespeed'||ARR0000000000000000000000000000000000000000000000000000001000000000{S8}'machname'|]#}'cpuinfo'||S32'hres'||S32'vres'||F64'aspectratio'||S32'raydepth'||S32'antialiasing'||S32'verbosemode'||S32'boundmode'||S32'boundthresh'||U32'$pad2'||*{SYM#c::tag-list#}'texlist'||*{SYM#c::tag-list#}'cliplist'||U32'flags'||U32'$pad3'||SYM#c::tag-#anon#ST[S32'projection'||U32'$pad0'||SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#'center'||SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#'viewvec'||SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#'rightvec'||SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#'upvec'||F64'camzoom'||F64'px'||F64'py'||F64'psx'||F64'psy'||F64'focallength'||F64'left'||F64'right'||F64'top'||F64'bottom'||F64'aperture'||SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#'projcent'||*{P(*{V}|F64|F64)->SYM#c::tag-#anon#ST[F32'r'||F32'g'||F32'b'|]#}'cam_ray'||SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#'lowleft'||SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#'iplaneright'||SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#'iplaneup'|]#'camera'||*{P(*{V})->SYM#c::tag-#anon#ST[F32'r'||F32'g'||F32'b'|]#}'shader'||*{P(*{cSYM#c::tag-ray_t#}|*{cSYM#c::tag-#anon#ST[SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#'hit'||SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#'N'||SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#'L'||F64'Llen'|]#}|F64)->F64}'phongfunc'||S32'transmode'||U32'$pad4'||SYM#c::tag-#anon#ST[SYM#c::tag-#anon#ST[F32'r'||F32'g'||F32'b'|]#'background'||U32'$pad0'||SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#'gradient'||F64'gradtopval'||F64'gradbotval'||SYM#c::tag-#anon#ST[F32'r'||F32'g'||F32'b'|]#'backgroundtop'||SYM#c::tag-#anon#ST[F32'r'||F32'g'||F32'b'|]#'backgroundbot'|]#'bgtex'||*{P(*{cSYM#c::tag-ray_t#})->SYM#c::tag-#anon#ST[F32'r'||F32'g'||F32'b'|]#}'bgtexfunc'||SYM#c::tag-fogdata_t#'fog'||SYM#c::tag-#anon#ST[*{SYM#c::tag-#anon#ST[U32'id'||U32'$pad0'||*{V}'nextobj'||*{SYM#c::tag-#anon#ST[*{P(*{cV}|*{V})->V}'intersect'||*{P(*{cV}|*{cV}|*{cV}|*{V})->V}'normal'||*{P(*{V}|*{SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#}|*{SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#})->S32}'bbox'||*{P(*{V})->V}'freeobj'|]#}'methods'||*{SYM#c::tag-#anon#ST[S32'numplanes'||U32'$pad0'||*{F64}'planes'|]#}'clip'||*{SYM#c::tag-#anon#ST[*{P(*{cV}|*{cV}|*{V})->SYM#c::tag-#anon#ST[F32'r'||F32'g'||F32'b'|]#}'texfunc'||*{SYM#c::tag-#anon#ST[*{P(*{V})->V}'freetex'|]#}'methods'||U32'flags'||F32'ambient'||F32'diffuse'||F32'phong'||F32'phongexp'||S32'phongtype'||F32'specular'||F32'opacity'||F32'outline'||F32'outlinewidth'|]#}'tex'|]#}'boundedobj'||*{SYM#c::tag-#anon#ST[U32'id'||U32'$pad0'||*{V}'nextobj'||*{SYM#c::tag-#anon#ST[*{P(*{cV}|*{V})->V}'intersect'||*{P(*{cV}|*{cV}|*{cV}|*{V})->V}'normal'||*{P(*{V}|*{SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#}|*{SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#})->S32}'bbox'||*{P(*{V})->V}'freeobj'|]#}'methods'||*{SYM#c::tag-#anon#ST[S32'numplanes'||U32'$pad0'||*{F64}'planes'|]#}'clip'||*{SYM#c::tag-#anon#ST[*{P(*{cV}|*{cV}|*{V})->SYM#c::tag-#anon#ST[F32'r'||F32'g'||F32'b'|]#}'texfunc'||*{SYM#c::tag-#anon#ST[*{P(*{V})->V}'freetex'|]#}'methods'||U32'flags'||F32'ambient'||F32'diffuse'||F32'phong'||F32'phongexp'||S32'phongtype'||F32'specular'||F32'opacity'||F32'outline'||F32'outlinewidth'|]#}'tex'|]#}'unboundedobj'||S32'numobjects'||U32'$pad0'|]#'objgroup'||*{SYM#c::tag-list#}'lightlist'||F64'light_scale'||S32'numlights'||SYM#c::tag-amboccdata_t#'ambocc'||S32'scenecheck'||*{V}'parbuf'||*{V}'threads'||*{V}'threadparms'||*{SYM#c::tag-#anon#ST[S32'numplanes'||U32'$pad0'||*{F64}'planes'|]#}'curclipgroup'||S32'normalfixupmode'||U32'$pad5'|]#}'scene'||*{U64}'local_mbox'||U64'serialno'||S32'startx'||S32'stopx'||S32'xinc'||S32'starty'||S32'stopy'||S32'yinc'||*{SYM#c::tag-barrier_struct#}'runbar'|]$link123
// 
struct anon$46$link123;

// c::tag-#anon#ST[S32'x'||S32'y'||S32'z'|]
// 
struct anon$51;

// c::tag-#anon#ST[S32'xsize'||S32'ysize'|]
// 
struct anon$3;

// c::tag-#anon#ST[SYM#c::tag-#anon#ST[F32'r'||F32'g'||F32'b'|]#'background'||U32'$pad0'||SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#'gradient'||F64'gradtopval'||F64'gradbotval'||SYM#c::tag-#anon#ST[F32'r'||F32'g'||F32'b'|]#'backgroundtop'||SYM#c::tag-#anon#ST[F32'r'||F32'g'||F32'b'|]#'backgroundbot'|]
// 
struct anon$20;

// c::tag-#anon#ST[SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#'hit'||SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#'N'||SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#'L'||F64'Llen'|]
// 
struct anon$19;

// c::tag-#anon#ST[SYM#c::tag-timeval#'starttime'||SYM#c::tag-timeval#'endtime'||SYM#c::tag-timezone#'tz'|]
// 
struct anon$69;

// c::tag-#anon#ST[U16'width'||U16'height'||U32'$pad0'||*{SYM#c::tag-_IO_FILE#}'ofp'|]
// 
struct anon$72;

// c::tag-#anon#ST[U32'id'||U32'$pad0'||*{V}'nextobj'||*{SYM#c::tag-#anon#ST[*{P(*{cV}|*{V})->V}'intersect'||*{P(*{cV}|*{cV}|*{cV}|*{V})->V}'normal'||*{P(*{V}|*{SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#}|*{SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#})->S32}'bbox'||*{P(*{V})->V}'freeobj'|]#}'methods'||*{SYM#c::tag-#anon#ST[S32'numplanes'||U32'$pad0'||*{F64}'planes'|]#}'clip'||*{SYM#c::tag-#anon#ST[*{P(*{cV}|*{cV}|*{V})->SYM#c::tag-#anon#ST[F32'r'||F32'g'||F32'b'|]#}'texfunc'||*{SYM#c::tag-#anon#ST[*{P(*{V})->V}'freetex'|]#}'methods'||U32'flags'||F32'ambient'||F32'diffuse'||F32'phong'||F32'phongexp'||S32'phongtype'||F32'specular'||F32'opacity'||F32'outline'||F32'outlinewidth'|]#}'tex'|]
// 
struct anon$15;

// c::tag-#anon#ST[U32'id'||U32'$pad0'||*{V}'nextobj'||*{SYM#c::tag-#anon#ST[*{P(*{cV}|*{V})->V}'intersect'||*{P(*{cV}|*{cV}|*{cV}|*{V})->V}'normal'||*{P(*{V}|*{SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#}|*{SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#})->S32}'bbox'||*{P(*{V})->V}'freeobj'|]#}'methods'||*{SYM#c::tag-#anon#ST[S32'numplanes'||U32'$pad0'||*{F64}'planes'|]#}'clip'||*{SYM#c::tag-#anon#ST[*{P(*{cV}|*{cV}|*{V})->SYM#c::tag-#anon#ST[F32'r'||F32'g'||F32'b'|]#}'texfunc'||*{SYM#c::tag-#anon#ST[*{P(*{V})->V}'freetex'|]#}'methods'||U32'flags'||F32'ambient'||F32'diffuse'||F32'phong'||F32'phongexp'||S32'phongtype'||F32'specular'||F32'opacity'||F32'outline'||F32'outlinewidth'|]#}'tex'||F64'd'||SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#'norm'|]
// 
struct anon$55;

// c::tag-#anon#ST[U32'id'||U32'$pad0'||*{V}'nextobj'||*{SYM#c::tag-#anon#ST[*{P(*{cV}|*{V})->V}'intersect'||*{P(*{cV}|*{cV}|*{cV}|*{V})->V}'normal'||*{P(*{V}|*{SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#}|*{SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#})->S32}'bbox'||*{P(*{V})->V}'freeobj'|]#}'methods'||*{SYM#c::tag-#anon#ST[S32'numplanes'||U32'$pad0'||*{F64}'planes'|]#}'clip'||*{SYM#c::tag-#anon#ST[*{P(*{cV}|*{cV}|*{V})->SYM#c::tag-#anon#ST[F32'r'||F32'g'||F32'b'|]#}'texfunc'||*{SYM#c::tag-#anon#ST[*{P(*{V})->V}'freetex'|]#}'methods'||U32'flags'||F32'ambient'||F32'diffuse'||F32'phong'||F32'phongexp'||S32'phongtype'||F32'specular'||F32'opacity'||F32'outline'||F32'outlinewidth'|]#}'tex'||S32'xsize'||S32'ysize'||S32'zsize'||U32'$pad1'||SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#'min'||SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#'max'||SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#'voxsize'||*{SYM#c::tag-#anon#ST[U32'id'||U32'$pad0'||*{V}'nextobj'||*{SYM#c::tag-#anon#ST[*{P(*{cV}|*{V})->V}'intersect'||*{P(*{cV}|*{cV}|*{cV}|*{V})->V}'normal'||*{P(*{V}|*{SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#}|*{SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#})->S32}'bbox'||*{P(*{V})->V}'freeobj'|]#}'methods'||*{SYM#c::tag-#anon#ST[S32'numplanes'||U32'$pad0'||*{F64}'planes'|]#}'clip'||*{SYM#c::tag-#anon#ST[*{P(*{cV}|*{cV}|*{V})->SYM#c::tag-#anon#ST[F32'r'||F32'g'||F32'b'|]#}'texfunc'||*{SYM#c::tag-#anon#ST[*{P(*{V})->V}'freetex'|]#}'methods'||U32'flags'||F32'ambient'||F32'diffuse'||F32'phong'||F32'phongexp'||S32'phongtype'||F32'specular'||F32'opacity'||F32'outline'||F32'outlinewidth'|]#}'tex'|]#}'objects'||*{*{SYM#c::tag-objectlist#}}'cells'|]
// 
struct anon$50;

// c::tag-#anon#ST[U32'id'||U32'$pad0'||*{V}'nextobj'||*{SYM#c::tag-#anon#ST[*{P(*{cV}|*{V})->V}'intersect'||*{P(*{cV}|*{cV}|*{cV}|*{V})->V}'normal'||*{P(*{V}|*{SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#}|*{SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#})->S32}'bbox'||*{P(*{V})->V}'freeobj'|]#}'methods'||*{SYM#c::tag-#anon#ST[S32'numplanes'||U32'$pad0'||*{F64}'planes'|]#}'clip'||*{SYM#c::tag-#anon#ST[*{P(*{cV}|*{cV}|*{V})->SYM#c::tag-#anon#ST[F32'r'||F32'g'||F32'b'|]#}'texfunc'||*{SYM#c::tag-#anon#ST[*{P(*{V})->V}'freetex'|]#}'methods'||U32'flags'||F32'ambient'||F32'diffuse'||F32'phong'||F32'phongexp'||S32'phongtype'||F32'specular'||F32'opacity'||F32'outline'||F32'outlinewidth'|]#}'tex'||SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#'ctr'||F64'rad'|]
// 
struct anon$53;

// c::tag-#anon#ST[U32'id'||U32'$pad0'||*{V}'nextobj'||*{SYM#c::tag-#anon#ST[*{P(*{cV}|*{V})->V}'intersect'||*{P(*{cV}|*{cV}|*{cV}|*{V})->V}'normal'||*{P(*{V}|*{SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#}|*{SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#})->S32}'bbox'||*{P(*{V})->V}'freeobj'|]#}'methods'||*{SYM#c::tag-#anon#ST[S32'numplanes'||U32'$pad0'||*{F64}'planes'|]#}'clip'||*{SYM#c::tag-#anon#ST[*{P(*{cV}|*{cV}|*{V})->SYM#c::tag-#anon#ST[F32'r'||F32'g'||F32'b'|]#}'texfunc'||*{SYM#c::tag-#anon#ST[*{P(*{V})->V}'freetex'|]#}'methods'||U32'flags'||F32'ambient'||F32'diffuse'||F32'phong'||F32'phongexp'||S32'phongtype'||F32'specular'||F32'opacity'||F32'outline'||F32'outlinewidth'|]#}'tex'||SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#'ctr'||SYM#c::tag-#anon#ST[F64'a'||F64'b'||F64'c'||F64'd'||F64'e'||F64'f'||F64'g'||F64'h'||F64'i'||F64'j'|]#'mat'|]
// 
struct anon$28;

// c::tag-#anon#ST[U32'id'||U32'$pad0'||*{V}'nextobj'||*{SYM#c::tag-#anon#ST[*{P(*{cV}|*{V})->V}'intersect'||*{P(*{cV}|*{cV}|*{cV}|*{V})->V}'normal'||*{P(*{V}|*{SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#}|*{SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#})->S32}'bbox'||*{P(*{V})->V}'freeobj'|]#}'methods'||*{SYM#c::tag-#anon#ST[S32'numplanes'||U32'$pad0'||*{F64}'planes'|]#}'clip'||*{SYM#c::tag-#anon#ST[*{P(*{cV}|*{cV}|*{V})->SYM#c::tag-#anon#ST[F32'r'||F32'g'||F32'b'|]#}'texfunc'||*{SYM#c::tag-#anon#ST[*{P(*{V})->V}'freetex'|]#}'methods'||U32'flags'||F32'ambient'||F32'diffuse'||F32'phong'||F32'phongexp'||S32'phongtype'||F32'specular'||F32'opacity'||F32'outline'||F32'outlinewidth'|]#}'tex'||SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#'ctr'||SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#'axis'||F64'rad'|]
// 
struct anon$64;

// c::tag-#anon#ST[U32'id'||U32'$pad0'||*{V}'nextobj'||*{SYM#c::tag-#anon#ST[*{P(*{cV}|*{V})->V}'intersect'||*{P(*{cV}|*{cV}|*{cV}|*{V})->V}'normal'||*{P(*{V}|*{SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#}|*{SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#})->S32}'bbox'||*{P(*{V})->V}'freeobj'|]#}'methods'||*{SYM#c::tag-#anon#ST[S32'numplanes'||U32'$pad0'||*{F64}'planes'|]#}'clip'||*{SYM#c::tag-#anon#ST[*{P(*{cV}|*{cV}|*{V})->SYM#c::tag-#anon#ST[F32'r'||F32'g'||F32'b'|]#}'texfunc'||*{SYM#c::tag-#anon#ST[*{P(*{V})->V}'freetex'|]#}'methods'||U32'flags'||F32'ambient'||F32'diffuse'||F32'phong'||F32'phongexp'||S32'phongtype'||F32'specular'||F32'opacity'||F32'outline'||F32'outlinewidth'|]#}'tex'||SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#'ctr'||SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#'norm'||F64'inrad'||F64'outrad'|]
// 
struct anon$58;

// c::tag-#anon#ST[U32'id'||U32'$pad0'||*{V}'nextobj'||*{SYM#c::tag-#anon#ST[*{P(*{cV}|*{V})->V}'intersect'||*{P(*{cV}|*{cV}|*{cV}|*{V})->V}'normal'||*{P(*{V}|*{SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#}|*{SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#})->S32}'bbox'||*{P(*{V})->V}'freeobj'|]#}'methods'||*{SYM#c::tag-#anon#ST[S32'numplanes'||U32'$pad0'||*{F64}'planes'|]#}'clip'||*{SYM#c::tag-#anon#ST[*{P(*{cV}|*{cV}|*{V})->SYM#c::tag-#anon#ST[F32'r'||F32'g'||F32'b'|]#}'texfunc'||*{SYM#c::tag-#anon#ST[*{P(*{V})->V}'freetex'|]#}'methods'||U32'flags'||F32'ambient'||F32'diffuse'||F32'phong'||F32'phongexp'||S32'phongtype'||F32'specular'||F32'opacity'||F32'outline'||F32'outlinewidth'|]#}'tex'||SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#'edge2'||SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#'edge1'||SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#'v0'|]
// 
struct anon$60;

// c::tag-#anon#ST[U32'id'||U32'$pad0'||*{V}'nextobj'||*{SYM#c::tag-#anon#ST[*{P(*{cV}|*{V})->V}'intersect'||*{P(*{cV}|*{cV}|*{cV}|*{V})->V}'normal'||*{P(*{V}|*{SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#}|*{SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#})->S32}'bbox'||*{P(*{V})->V}'freeobj'|]#}'methods'||*{SYM#c::tag-#anon#ST[S32'numplanes'||U32'$pad0'||*{F64}'planes'|]#}'clip'||*{SYM#c::tag-#anon#ST[*{P(*{cV}|*{cV}|*{V})->SYM#c::tag-#anon#ST[F32'r'||F32'g'||F32'b'|]#}'texfunc'||*{SYM#c::tag-#anon#ST[*{P(*{V})->V}'freetex'|]#}'methods'||U32'flags'||F32'ambient'||F32'diffuse'||F32'phong'||F32'phongexp'||S32'phongtype'||F32'specular'||F32'opacity'||F32'outline'||F32'outlinewidth'|]#}'tex'||SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#'edge2'||SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#'edge1'||SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#'v0'||SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#'n0'||SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#'n1'||SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#'n2'|]
// 
struct anon$61;

// c::tag-#anon#ST[U32'id'||U32'$pad0'||*{V}'nextobj'||*{SYM#c::tag-#anon#ST[*{P(*{cV}|*{V})->V}'intersect'||*{P(*{cV}|*{cV}|*{cV}|*{V})->V}'normal'||*{P(*{V}|*{SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#}|*{SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#})->S32}'bbox'||*{P(*{V})->V}'freeobj'|]#}'methods'||*{SYM#c::tag-#anon#ST[S32'numplanes'||U32'$pad0'||*{F64}'planes'|]#}'clip'||*{SYM#c::tag-#anon#ST[*{P(*{cV}|*{cV}|*{V})->SYM#c::tag-#anon#ST[F32'r'||F32'g'||F32'b'|]#}'texfunc'||*{SYM#c::tag-#anon#ST[*{P(*{V})->V}'freetex'|]#}'methods'||U32'flags'||F32'ambient'||F32'diffuse'||F32'phong'||F32'phongexp'||S32'phongtype'||F32'specular'||F32'opacity'||F32'outline'||F32'outlinewidth'|]#}'tex'||SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#'edge2'||SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#'edge1'||SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#'v0'||SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#'n0'||SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#'n1'||SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#'n2'||SYM#c::tag-#anon#ST[F32'r'||F32'g'||F32'b'|]#'c0'||SYM#c::tag-#anon#ST[F32'r'||F32'g'||F32'b'|]#'c1'||SYM#c::tag-#anon#ST[F32'r'||F32'g'||F32'b'|]#'c2'||U32'$pad1'|]
// 
struct anon$62;

// c::tag-#anon#ST[U32'id'||U32'$pad0'||*{V}'nextobj'||*{SYM#c::tag-#anon#ST[*{P(*{cV}|*{V})->V}'intersect'||*{P(*{cV}|*{cV}|*{cV}|*{V})->V}'normal'||*{P(*{V}|*{SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#}|*{SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#})->S32}'bbox'||*{P(*{V})->V}'freeobj'|]#}'methods'||*{SYM#c::tag-#anon#ST[S32'numplanes'||U32'$pad0'||*{F64}'planes'|]#}'clip'||*{SYM#c::tag-#anon#ST[*{P(*{cV}|*{cV}|*{V})->SYM#c::tag-#anon#ST[F32'r'||F32'g'||F32'b'|]#}'texfunc'||*{SYM#c::tag-#anon#ST[*{P(*{V})->V}'freetex'|]#}'methods'||U32'flags'||F32'ambient'||F32'diffuse'||F32'phong'||F32'phongexp'||S32'phongtype'||F32'specular'||F32'opacity'||F32'outline'||F32'outlinewidth'|]#}'tex'||SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#'min'||SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#'max'|]
// 
struct anon$26;

// c::tag-#anon#ST[U32'id'||U32'$pad0'||*{V}'nextobj'||*{SYM#c::tag-#anon#ST[*{P(*{cV}|*{V})->V}'intersect'||*{P(*{cV}|*{cV}|*{cV}|*{V})->V}'normal'||*{P(*{V}|*{SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#}|*{SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#})->S32}'bbox'||*{P(*{V})->V}'freeobj'|]#}'methods'||*{SYM#c::tag-#anon#ST[S32'numplanes'||U32'$pad0'||*{F64}'planes'|]#}'clip'||*{SYM#c::tag-#anon#ST[*{P(*{cV}|*{cV}|*{V})->SYM#c::tag-#anon#ST[F32'r'||F32'g'||F32'b'|]#}'texfunc'||*{SYM#c::tag-#anon#ST[*{P(*{V})->V}'freetex'|]#}'methods'||U32'flags'||F32'ambient'||F32'diffuse'||F32'phong'||F32'phongexp'||S32'phongtype'||F32'specular'||F32'opacity'||F32'outline'||F32'outlinewidth'|]#}'tex'||SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#'min'||SYM#c::tag-#anon#ST[F64'x'||F64'y'||F64'z'|]#'max'||F64'ambient'||F64'diffuse'||F64'opacity'||S32'samples'||U32'$pad1'||*{P(F64|F64|F64)->F64}'evaluator'|]
// 
struct anon$29;

// c::tag-#anon#ST[U32'x'||U32'y'||U32'z'||U32'w'||U32'c'||U32'k'||U32'm'|]
// 
struct anon$18;

// c::tag-#anon#UN[ARR0000000000000000000000000000000000000000000000000000000000000100{S8}'__size'||S32'__align'|]
// 
union anon$43;

// c::tag-#anon#UN[SYM#c::tag-#anon#ST[S32'__lock'||U32'__futex'||U64'__total_seq'||U64'__wakeup_seq'||U64'__woken_seq'||*{V}'__mutex'||U32'__nwaiters'||U32'__broadcast_seq'|]#'__data'||ARR0000000000000000000000000000000000000000000000000000000000110000{S8}'__size'||S64'__align'|]
// 
union anon$42;

// c::tag-#anon#UN[SYM#c::tag-__pthread_mutex_s#'__data'||ARR0000000000000000000000000000000000000000000000000000000000101000{S8}'__size'||S64'__align'|]
// 
union anon$40;

// c::tag-#anon#UN[SYM#c::tag-__pthread_mutex_s#'__data'||ARR0000000000000000000000000000000000000000000000000000000000101000{S8}'__size'||S64'__align'|]$link116
// 
union anon$47$link116;

// c::tag-#anon#UN[SYM#c::tag-__pthread_mutex_s#'__data'||ARR0000000000000000000000000000000000000000000000000000000000101000{S8}'__size'||S64'__align'|]$link117
// 
union anon$49$link117;

// c::tag-_IO_FILE
// file /usr/include/libio.h line 246
struct _IO_FILE;

// c::tag-_IO_FILE$link0
// file /usr/include/libio.h line 246
struct _IO_FILE$link0;

// c::tag-_IO_FILE$link11
// file /usr/include/libio.h line 246
struct _IO_FILE$link11;

// c::tag-_IO_FILE$link12
// file /usr/include/libio.h line 246
struct _IO_FILE$link12;

// c::tag-_IO_FILE$link13
// file /usr/include/libio.h line 246
struct _IO_FILE$link13;

// c::tag-_IO_FILE$link14
// file /usr/include/libio.h line 246
struct _IO_FILE$link14;

// c::tag-_IO_FILE$link15
// file /usr/include/libio.h line 246
struct _IO_FILE$link15;

// c::tag-_IO_FILE$link16
// file /usr/include/libio.h line 246
struct _IO_FILE$link16;

// c::tag-_IO_FILE$link17
// file /usr/include/libio.h line 246
struct _IO_FILE$link17;

// c::tag-_IO_FILE$link18
// file /usr/include/libio.h line 246
struct _IO_FILE$link18;

// c::tag-_IO_FILE$link19
// file /usr/include/libio.h line 246
struct _IO_FILE$link19;

// c::tag-_IO_FILE$link20
// file /usr/include/libio.h line 246
struct _IO_FILE$link20;

// c::tag-_IO_FILE$link21
// file /usr/include/libio.h line 246
struct _IO_FILE$link21;

// c::tag-_IO_FILE$link22
// file /usr/include/libio.h line 246
struct _IO_FILE$link22;

// c::tag-_IO_FILE$link23
// file /usr/include/libio.h line 246
struct _IO_FILE$link23;

// c::tag-_IO_FILE$link24
// file /usr/include/libio.h line 246
struct _IO_FILE$link24;

// c::tag-_IO_FILE$link25
// file /usr/include/libio.h line 246
struct _IO_FILE$link25;

// c::tag-_IO_FILE$link26
// file /usr/include/libio.h line 246
struct _IO_FILE$link26;

// c::tag-_IO_FILE$link27
// file /usr/include/libio.h line 246
struct _IO_FILE$link27;

// c::tag-_IO_FILE$link28
// file /usr/include/libio.h line 246
struct _IO_FILE$link28;

// c::tag-_IO_FILE$link29
// file /usr/include/libio.h line 246
struct _IO_FILE$link29;

// c::tag-_IO_FILE$link30
// file /usr/include/libio.h line 246
struct _IO_FILE$link30;

// c::tag-_IO_FILE$link31
// file /usr/include/libio.h line 246
struct _IO_FILE$link31;

// c::tag-_IO_FILE$link32
// file /usr/include/libio.h line 246
struct _IO_FILE$link32;

// c::tag-_IO_FILE$link33
// file /usr/include/libio.h line 246
struct _IO_FILE$link33;

// c::tag-_IO_FILE$link34
// file /usr/include/libio.h line 246
struct _IO_FILE$link34;

// c::tag-_IO_FILE$link35
// file /usr/include/libio.h line 246
struct _IO_FILE$link35;

// c::tag-_IO_FILE$link36
// file /usr/include/libio.h line 246
struct _IO_FILE$link36;

// c::tag-_IO_FILE$link37
// file /usr/include/libio.h line 246
struct _IO_FILE$link37;

// c::tag-_IO_FILE$link38
// file /usr/include/libio.h line 246
struct _IO_FILE$link38;

// c::tag-_IO_FILE$link39
// file /usr/include/libio.h line 246
struct _IO_FILE$link39;

// c::tag-_IO_FILE$link40
// file /usr/include/libio.h line 246
struct _IO_FILE$link40;

// c::tag-_IO_FILE$link41
// file /usr/include/libio.h line 246
struct _IO_FILE$link41;

// c::tag-_IO_FILE$link42
// file /usr/include/libio.h line 246
struct _IO_FILE$link42;

// c::tag-_IO_FILE$link43
// file /usr/include/libio.h line 246
struct _IO_FILE$link43;

// c::tag-_IO_FILE$link44
// file /usr/include/libio.h line 246
struct _IO_FILE$link44;

// c::tag-_IO_FILE$link5
// file /usr/include/libio.h line 246
struct _IO_FILE$link5;

// c::tag-_IO_FILE$link6
// file /usr/include/libio.h line 246
struct _IO_FILE$link6;

// c::tag-_IO_FILE$link7
// file /usr/include/libio.h line 246
struct _IO_FILE$link7;

// c::tag-_IO_FILE$link8
// file /usr/include/libio.h line 246
struct _IO_FILE$link8;

// c::tag-_IO_FILE$link9
// file /usr/include/libio.h line 246
struct _IO_FILE$link9;

// c::tag-_IO_marker
// file /usr/include/libio.h line 161
struct _IO_marker;

// c::tag-_IO_marker$link10
// file /usr/include/libio.h line 161
struct _IO_marker$link10;

// c::tag-_IO_marker$link11
// file /usr/include/libio.h line 161
struct _IO_marker$link11;

// c::tag-_IO_marker$link13
// file /usr/include/libio.h line 161
struct _IO_marker$link13;

// c::tag-_IO_marker$link14
// file /usr/include/libio.h line 161
struct _IO_marker$link14;

// c::tag-_IO_marker$link15
// file /usr/include/libio.h line 161
struct _IO_marker$link15;

// c::tag-_IO_marker$link16
// file /usr/include/libio.h line 161
struct _IO_marker$link16;

// c::tag-_IO_marker$link17
// file /usr/include/libio.h line 161
struct _IO_marker$link17;

// c::tag-_IO_marker$link18
// file /usr/include/libio.h line 161
struct _IO_marker$link18;

// c::tag-_IO_marker$link2
// file /usr/include/libio.h line 161
struct _IO_marker$link2;

// c::tag-_IO_marker$link20
// file /usr/include/libio.h line 161
struct _IO_marker$link20;

// c::tag-_IO_marker$link21
// file /usr/include/libio.h line 161
struct _IO_marker$link21;

// c::tag-_IO_marker$link22
// file /usr/include/libio.h line 161
struct _IO_marker$link22;

// c::tag-_IO_marker$link23
// file /usr/include/libio.h line 161
struct _IO_marker$link23;

// c::tag-_IO_marker$link24
// file /usr/include/libio.h line 161
struct _IO_marker$link24;

// c::tag-_IO_marker$link25
// file /usr/include/libio.h line 161
struct _IO_marker$link25;

// c::tag-_IO_marker$link26
// file /usr/include/libio.h line 161
struct _IO_marker$link26;

// c::tag-_IO_marker$link27
// file /usr/include/libio.h line 161
struct _IO_marker$link27;

// c::tag-_IO_marker$link28
// file /usr/include/libio.h line 161
struct _IO_marker$link28;

// c::tag-_IO_marker$link29
// file /usr/include/libio.h line 161
struct _IO_marker$link29;

// c::tag-_IO_marker$link30
// file /usr/include/libio.h line 161
struct _IO_marker$link30;

// c::tag-_IO_marker$link31
// file /usr/include/libio.h line 161
struct _IO_marker$link31;

// c::tag-_IO_marker$link32
// file /usr/include/libio.h line 161
struct _IO_marker$link32;

// c::tag-_IO_marker$link33
// file /usr/include/libio.h line 161
struct _IO_marker$link33;

// c::tag-_IO_marker$link34
// file /usr/include/libio.h line 161
struct _IO_marker$link34;

// c::tag-_IO_marker$link35
// file /usr/include/libio.h line 161
struct _IO_marker$link35;

// c::tag-_IO_marker$link36
// file /usr/include/libio.h line 161
struct _IO_marker$link36;

// c::tag-_IO_marker$link37
// file /usr/include/libio.h line 161
struct _IO_marker$link37;

// c::tag-_IO_marker$link38
// file /usr/include/libio.h line 161
struct _IO_marker$link38;

// c::tag-_IO_marker$link39
// file /usr/include/libio.h line 161
struct _IO_marker$link39;

// c::tag-_IO_marker$link40
// file /usr/include/libio.h line 161
struct _IO_marker$link40;

// c::tag-_IO_marker$link41
// file /usr/include/libio.h line 161
struct _IO_marker$link41;

// c::tag-_IO_marker$link42
// file /usr/include/libio.h line 161
struct _IO_marker$link42;

// c::tag-_IO_marker$link43
// file /usr/include/libio.h line 161
struct _IO_marker$link43;

// c::tag-_IO_marker$link44
// file /usr/include/libio.h line 161
struct _IO_marker$link44;

// c::tag-_IO_marker$link45
// file /usr/include/libio.h line 161
struct _IO_marker$link45;

// c::tag-_IO_marker$link46
// file /usr/include/libio.h line 161
struct _IO_marker$link46;

// c::tag-_IO_marker$link47
// file /usr/include/libio.h line 161
struct _IO_marker$link47;

// c::tag-_IO_marker$link7
// file /usr/include/libio.h line 161
struct _IO_marker$link7;

// c::tag-_IO_marker$link8
// file /usr/include/libio.h line 161
struct _IO_marker$link8;

// c::tag-_IO_marker$link9
// file /usr/include/libio.h line 161
struct _IO_marker$link9;

// c::tag-__pthread_internal_list
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 75
struct __pthread_internal_list;

// c::tag-__pthread_internal_list$link114
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 75
struct __pthread_internal_list$link114;

// c::tag-__pthread_internal_list$link115
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 75
struct __pthread_internal_list$link115;

// c::tag-__pthread_mutex_s
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 92
struct __pthread_mutex_s;

// c::tag-__pthread_mutex_s$link115
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 92
struct __pthread_mutex_s$link115;

// c::tag-__pthread_mutex_s$link116
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 92
struct __pthread_mutex_s$link116;

// c::tag-amboccdata_t
// file ../src/types.h line 262
struct amboccdata_t;

// c::tag-barrier_struct
// file ../src/threads.h line 100
struct barrier_struct;

// c::tag-barrier_struct$link117
// file ../src/threads.h line 100
struct barrier_struct$link117;

// c::tag-barrier_struct$link118
// file ../src/threads.h line 100
struct barrier_struct$link118;

// c::tag-directional_light_t
// file ../src/light.h line 29
struct directional_light_t;

// c::tag-directional_light_t$link271
// file ../src/light.h line 29
struct directional_light_t$link271;

// c::tag-fogdata_t
// file ../src/types.h line 253
struct fogdata_t;

// c::tag-fogdata_t$link109
// file ../src/types.h line 253
struct fogdata_t$link109;

// c::tag-fogdata_t$link110
// file ../src/types.h line 253
struct fogdata_t$link110;

// c::tag-fogdata_t$link112
// file ../src/types.h line 253
struct fogdata_t$link112;

// c::tag-fogdata_t$link121
// file ../src/types.h line 253
struct fogdata_t$link121;

// c::tag-fogdata_t$link132
// file ../src/types.h line 253
struct fogdata_t$link132;

// c::tag-fogdata_t$link164
// file ../src/types.h line 253
struct fogdata_t$link164;

// c::tag-fogdata_t$link2
// file ../src/types.h line 253
struct fogdata_t$link2;

// c::tag-fogdata_t$link201
// file ../src/types.h line 253
struct fogdata_t$link201;

// c::tag-fogdata_t$link212
// file ../src/types.h line 253
struct fogdata_t$link212;

// c::tag-fogdata_t$link215
// file ../src/types.h line 253
struct fogdata_t$link215;

// c::tag-fogdata_t$link235
// file ../src/types.h line 253
struct fogdata_t$link235;

// c::tag-fogdata_t$link236
// file ../src/types.h line 253
struct fogdata_t$link236;

// c::tag-fogdata_t$link243
// file ../src/types.h line 253
struct fogdata_t$link243;

// c::tag-fogdata_t$link249
// file ../src/types.h line 253
struct fogdata_t$link249;

// c::tag-fogdata_t$link257
// file ../src/types.h line 253
struct fogdata_t$link257;

// c::tag-fogdata_t$link3
// file ../src/types.h line 253
struct fogdata_t$link3;

// c::tag-fogdata_t$link38
// file ../src/types.h line 253
struct fogdata_t$link38;

// c::tag-fogdata_t$link69
// file ../src/types.h line 253
struct fogdata_t$link69;

// c::tag-fogdata_t$link95
// file ../src/types.h line 253
struct fogdata_t$link95;

// c::tag-hash_node_t
// file ../src/hash.h line 16
struct hash_node_t;

// c::tag-light_t
// file ../src/light.h line 9
struct light_t;

// c::tag-light_t$link272
// file ../src/light.h line 9
struct light_t$link272;

// c::tag-list
// file ../src/types.h line 274
struct list;

// c::tag-list$link110
// file ../src/types.h line 274
struct list$link110;

// c::tag-list$link111
// file ../src/types.h line 274
struct list$link111;

// c::tag-list$link113
// file ../src/types.h line 274
struct list$link113;

// c::tag-list$link122
// file ../src/types.h line 274
struct list$link122;

// c::tag-list$link133
// file ../src/types.h line 274
struct list$link133;

// c::tag-list$link165
// file ../src/types.h line 274
struct list$link165;

// c::tag-list$link202
// file ../src/types.h line 274
struct list$link202;

// c::tag-list$link213
// file ../src/types.h line 274
struct list$link213;

// c::tag-list$link216
// file ../src/types.h line 274
struct list$link216;

// c::tag-list$link232
// file ../src/types.h line 274
struct list$link232;

// c::tag-list$link237
// file ../src/types.h line 274
struct list$link237;

// c::tag-list$link240
// file ../src/types.h line 274
struct list$link240;

// c::tag-list$link246
// file ../src/types.h line 274
struct list$link246;

// c::tag-list$link258
// file ../src/types.h line 274
struct list$link258;

// c::tag-list$link3
// file ../src/types.h line 274
struct list$link3;

// c::tag-list$link39
// file ../src/types.h line 274
struct list$link39;

// c::tag-list$link4
// file ../src/types.h line 274
struct list$link4;

// c::tag-list$link70
// file ../src/types.h line 274
struct list$link70;

// c::tag-list$link96
// file ../src/types.h line 274
struct list$link96;

// c::tag-objectlist
// file ../src/grid.h line 14
struct objectlist;

// c::tag-point_light_t
// file ../src/light.h line 14
struct point_light_t;

// c::tag-point_light_t$link179
// file ../src/light.h line 14
struct point_light_t$link179;

// c::tag-point_light_t$link242
// file ../src/light.h line 14
struct point_light_t$link242;

// c::tag-pthread_attr_t
// file /usr/include/x86_64-linux-gnu/bits/pthreadtypes.h line 63
union pthread_attr_t;

// c::tag-ray_t
// file ../src/types.h line 346
struct ray_t;

// c::tag-ray_t$link0
// file ../src/types.h line 346
struct ray_t$link0;

// c::tag-ray_t$link1
// file ../src/types.h line 346
struct ray_t$link1;

// c::tag-ray_t$link107
// file ../src/types.h line 346
struct ray_t$link107;

// c::tag-ray_t$link108
// file ../src/types.h line 346
struct ray_t$link108;

// c::tag-ray_t$link110
// file ../src/types.h line 346
struct ray_t$link110;

// c::tag-ray_t$link119
// file ../src/types.h line 346
struct ray_t$link119;

// c::tag-ray_t$link130
// file ../src/types.h line 346
struct ray_t$link130;

// c::tag-ray_t$link162
// file ../src/types.h line 346
struct ray_t$link162;

// c::tag-ray_t$link199
// file ../src/types.h line 346
struct ray_t$link199;

// c::tag-ray_t$link210
// file ../src/types.h line 346
struct ray_t$link210;

// c::tag-ray_t$link213
// file ../src/types.h line 346
struct ray_t$link213;

// c::tag-ray_t$link233
// file ../src/types.h line 346
struct ray_t$link233;

// c::tag-ray_t$link234
// file ../src/types.h line 346
struct ray_t$link234;

// c::tag-ray_t$link241
// file ../src/types.h line 346
struct ray_t$link241;

// c::tag-ray_t$link247
// file ../src/types.h line 346
struct ray_t$link247;

// c::tag-ray_t$link255
// file ../src/types.h line 346
struct ray_t$link255;

// c::tag-ray_t$link36
// file ../src/types.h line 346
struct ray_t$link36;

// c::tag-ray_t$link67
// file ../src/types.h line 346
struct ray_t$link67;

// c::tag-ray_t$link93
// file ../src/types.h line 346
struct ray_t$link93;

// c::tag-rt_hash_t
// file ../src/hash.h line 15
struct rt_hash_t;

// c::tag-rt_run_barrier_struct
// file ../src/threads.h line 112
struct rt_run_barrier_struct;

// c::tag-rt_shared_iterator_struct
// file ../src/threads.h line 213
struct rt_shared_iterator_struct;

// c::tag-rt_threadpool_struct
// file ../src/threads.h line 177
struct rt_threadpool_struct;

// c::tag-rt_threadpool_workerdata_struct
// file ../src/threads.h line 168
struct rt_threadpool_workerdata_struct;

// c::tag-rwlock_struct
// file ../src/threads.h line 38
struct rwlock_struct;

// c::tag-stat
// file /usr/include/x86_64-linux-gnu/bits/stat.h line 46
struct stat;

// c::tag-timespec
// file /usr/include/time.h line 120
struct timespec;

// c::tag-timeval
// file /usr/include/x86_64-linux-gnu/bits/time.h line 30
struct timeval;

// c::tag-timezone
// file /usr/include/x86_64-linux-gnu/sys/time.h line 56
struct timezone;

// c::tag-tri_list_t
// file ../demosrc/ac3dparse.h line 27
struct tri_list_t;


#ifndef TRUE
#define TRUE (_Bool)1
#endif
#ifndef FALSE
#define FALSE (_Bool)0
#endif
#ifndef NULL
#define NULL ((void*)0)
#endif
#ifndef FENCE
#define FENCE(x) ((void)0)
#endif
#ifndef IEEE_FLOAT_EQUAL
#define IEEE_FLOAT_EQUAL(x,y) (x==y)
#endif
#ifndef IEEE_FLOAT_NOTEQUAL
#define IEEE_FLOAT_NOTEQUAL(x,y) (x!=y)
#endif

// c::AllocateImageFile
// file ../src/imap.c line 76
struct anon$33 * AllocateImageFile(const char *filename);
// c::AllocateImageRGB24
// file ../src/imap.h line 9
struct anon$33 * AllocateImageRGB24(const char *filename, signed int xs, signed int ys, signed int zs, unsigned char *rgb);
// c::ColorAccum
// file ../src/vector.c line 76
void ColorAccum(struct anon$4 *a, const struct anon$4 *b);
// c::ColorAddS
// file ../src/vector.c line 70
void ColorAddS(struct anon$4 *a, const struct anon$4 *b, double s);
// c::ColorScale
// file ../src/vector.c line 82
void ColorScale(struct anon$4 *a, double s);
// c::CreateMIPMap
// file ../src/imap.c line 252
struct anon$34 * CreateMIPMap(struct anon$33 *image, signed int maxlevels);
// c::DeallocateImage
// file ../src/imap.c line 130
void DeallocateImage(struct anon$33 *image);
// c::DecimateImage
// file ../src/imap.c line 169
struct anon$33 * DecimateImage(const struct anon$33 *image);
// c::ExtVoxelColor
// file ../src/extvol.c line 85
struct anon$4 ExtVoxelColor(double scalar);
// c::FreeImages
// file ../src/imap.h line 13
void FreeImages(void);
// c::FreeMIPMap
// file ../src/imap.h line 17
void FreeMIPMap(struct anon$34 *mip);
// c::FreeTextures
// file ../src/texture.h line 28
void FreeTextures(void);
// c::GetAC3DString
// file ../demosrc/ac3dparse.c line 43
static void GetAC3DString(struct _IO_FILE$link6 *dfile, char *str);
// c::GetBackGnd
// file ../demosrc/parse.c line 1096
static unsigned int GetBackGnd(struct anon$6 *ph, void *scene);
// c::GetBox
// file ../demosrc/parse.c line 1250
static unsigned int GetBox(struct anon$6 *ph, void *scene);
// c::GetCamera
// file ../demosrc/parse.c line 380
static unsigned int GetCamera(struct anon$6 *ph, void *scene);
// c::GetClipGroup
// file ../demosrc/parse.c line 1722
static unsigned int GetClipGroup(struct anon$6 *ph, void *scene);
// c::GetClipGroupEnd
// file ../demosrc/parse.c line 1753
static unsigned int GetClipGroupEnd(struct anon$6 *ph, void *scene);
// c::GetColor
// file ../demosrc/parse.c line 621
static unsigned int GetColor(struct anon$6 *ph, struct anon$4 *c1);
// c::GetCylinder
// file ../demosrc/parse.c line 1111
static unsigned int GetCylinder(struct anon$6 *ph, void *scene);
// c::GetDirLight
// file ../demosrc/parse.c line 909
static unsigned int GetDirLight(struct anon$6 *ph, void *scene);
// c::GetFCylinder
// file ../demosrc/parse.c line 1132
static unsigned int GetFCylinder(struct anon$6 *ph, void *scene);
// c::GetFog
// file ../demosrc/parse.c line 1062
static unsigned int GetFog(struct anon$6 *ph, void *scene);
// c::GetImageDef
// file ../demosrc/parse.c line 634
static unsigned int GetImageDef(struct anon$6 *ph, void *scene);
// c::GetInt
// file ../demosrc/parse.c line 586
static unsigned int GetInt(struct anon$6 *ph, signed int *i);
// c::GetLandScape
// file ../demosrc/parse.c line 1627
static unsigned int GetLandScape(struct anon$6 *ph, void *scene);
// c::GetLight
// file ../demosrc/parse.c line 934
static unsigned int GetLight(struct anon$6 *ph, void *scene);
// c::GetMaterial
// file ../demosrc/ac3dparse.c line 198
static unsigned int GetMaterial(struct _IO_FILE$link6 *dfile, void *scene);
// c::GetObject
// file ../demosrc/parse.c line 469
static unsigned int GetObject(struct anon$6 *ph, void *scene);
// c::GetObject$link86
// file ../demosrc/ac3dparse.c line 578
static unsigned int GetObject$link86(struct _IO_FILE$link6 *dfile, void *scene$link85);
// c::GetPlane
// file ../demosrc/parse.c line 1211
static unsigned int GetPlane(struct anon$6 *ph, void *scene);
// c::GetPolyCylinder
// file ../demosrc/parse.c line 1161
static unsigned int GetPolyCylinder(struct anon$6 *ph, void *scene);
// c::GetRecurseObject
// file ../demosrc/ac3dparse.c line 375
static unsigned int GetRecurseObject(void *scene, struct _IO_FILE$link6 *dfile, float (*rmat)[3l], float *tmat);
// c::GetRing
// file ../demosrc/parse.c line 1266
static unsigned int GetRing(struct anon$6 *ph, void *scene);
// c::GetSTri
// file ../demosrc/parse.c line 1309
static unsigned int GetSTri(struct anon$6 *ph, void *scene);
// c::GetScene
// file ../demosrc/ac3dparse.c line 181
static unsigned int GetScene(struct _IO_FILE$link6 *dfile, void *scene);
// c::GetScenedefs
// file ../demosrc/parse.c line 315
static unsigned int GetScenedefs(struct anon$6 *ph, void *scene);
// c::GetScenedefs$link61
// file ../demosrc/ac3dparse.c line 133
static unsigned int GetScenedefs$link61(struct _IO_FILE$link6 *dfile, void *scene$link58);
// c::GetShaderMode
// file ../demosrc/parse.c line 329
static unsigned int GetShaderMode(struct anon$6 *ph, void *scene);
// c::GetSkyLight
// file ../demosrc/parse.c line 983
static unsigned int GetSkyLight(struct anon$6 *ph, void *scene);
// c::GetSphere
// file ../demosrc/parse.c line 1191
static unsigned int GetSphere(struct anon$6 *ph, void *scene);
// c::GetSpotLight
// file ../demosrc/parse.c line 1003
static unsigned int GetSpotLight(struct anon$6 *ph, void *scene);
// c::GetString
// file ../demosrc/parse.c line 209
static unsigned int GetString(struct anon$6 *ph, const char *string);
// c::GetString$link57
// file ../demosrc/ac3dparse.c line 77
static unsigned int GetString$link57(struct _IO_FILE$link6 *dfile, char *string$link56);
// c::GetTPolyFile
// file ../demosrc/parse.c line 1653
static unsigned int GetTPolyFile(struct anon$6 *ph, void *scene);
// c::GetTexAlias
// file ../demosrc/parse.c line 725
static unsigned int GetTexAlias(struct anon$6 *ph);
// c::GetTexBody
// file ../demosrc/parse.c line 751
void * GetTexBody(struct anon$6 *ph, void *scene, signed int modeflag);
// c::GetTexDef
// file ../demosrc/parse.c line 716
static unsigned int GetTexDef(struct anon$6 *ph, void *scene);
// c::GetTexture
// file ../demosrc/parse.c line 737
static unsigned int GetTexture(struct anon$6 *ph, void *scene, void **tex);
// c::GetTri
// file ../demosrc/parse.c line 1288
static unsigned int GetTri(struct anon$6 *ph, void *scene);
// c::GetVCSTri
// file ../demosrc/parse.c line 1339
static unsigned int GetVCSTri(struct anon$6 *ph, void *scene);
// c::GetVector
// file ../demosrc/parse.c line 596
static unsigned int GetVector(struct anon$6 *ph, struct anon$0 *v1);
// c::GetVertexArray
// file ../demosrc/parse.c line 1391
static unsigned int GetVertexArray(struct anon$6 *ph, void *scene);
// c::GetVol
// file ../demosrc/parse.c line 1228
static unsigned int GetVol(struct anon$6 *ph, void *scene);
// c::ImageMap
// file ../src/imap.c line 361
struct anon$4 ImageMap(const struct anon$33 *image, double u, double v);
// c::InitNoise
// file ../src/texture.c line 357
void InitNoise(void);
// c::InitRot3d
// file ../demosrc/parse.c line 135
static void InitRot3d(struct anon$8 *rot, double x, double y, double z);
// c::InitTextures
// file ../src/texture.h line 8
void InitTextures(void);
// c::LoadMIPMap
// file ../src/imap.h line 15
struct anon$34 * LoadMIPMap(const char *filename, signed int maxlevels);
// c::LoadRawImage
// file ../src/imap.c line 35
void LoadRawImage(struct anon$33 *image);
// c::LoadVol
// file ../src/vol.c line 271
void LoadVol(struct anon$10 *vol);
// c::MIPMap
// file ../src/imap.h line 18
struct anon$4 MIPMap(const struct anon$34 *mip, double u, double v, double d);
// c::NFFGetBackground
// file ../demosrc/nffparse.c line 134
signed int NFFGetBackground(struct _IO_FILE$link5 *dfile, void *scene);
// c::NFFGetCylCone
// file ../demosrc/nffparse.c line 185
signed int NFFGetCylCone(struct _IO_FILE$link5 *dfile, void *scene);
// c::NFFGetLight
// file ../demosrc/nffparse.c line 144
signed int NFFGetLight(struct _IO_FILE$link5 *dfile, void *scene);
// c::NFFGetObject
// file ../demosrc/nffparse.c line 261
signed int NFFGetObject(struct _IO_FILE$link5 *dfile, void *scene);
// c::NFFGetPatch
// file ../demosrc/nffparse.c line 238
signed int NFFGetPatch(struct _IO_FILE$link5 *dfile, void *scene);
// c::NFFGetPolygon
// file ../demosrc/nffparse.c line 221
signed int NFFGetPolygon(struct _IO_FILE$link5 *dfile, void *scene);
// c::NFFGetScenedefs
// file ../demosrc/nffparse.c line 86
signed int NFFGetScenedefs(struct _IO_FILE$link5 *dfile, void *scene);
// c::NFFGetSphere
// file ../demosrc/nffparse.c line 207
signed int NFFGetSphere(struct _IO_FILE$link5 *dfile, void *scene);
// c::NFFGetString
// file ../demosrc/nffparse.c line 42
void NFFGetString(struct _IO_FILE$link5 *dfile, char *string);
// c::NFFGetTexture
// file ../demosrc/nffparse.c line 165
signed int NFFGetTexture(struct _IO_FILE$link5 *dfile, void *scene);
// c::NFFGetVector
// file ../demosrc/nffparse.c line 54
void NFFGetVector(struct _IO_FILE$link5 *dfile, struct anon$0 *v1);
// c::NFFstringcmp
// file ../demosrc/nffparse.c line 24
signed int NFFstringcmp(char *a, char *b);
// c::NewImage
// file ../src/imap.c line 110
struct anon$33 * NewImage(signed int x, signed int y, signed int z);
// c::Noise
// file ../src/texture.c line 381
signed int Noise(double x, double y, double z);
// c::ParseAC3D
// file ../demosrc/ac3dparse.h line 13
unsigned int ParseAC3D(char *modelfile, void *scene);
// c::ParseNFF
// file ../demosrc/nffparse.h line 12
unsigned int ParseNFF(char *nffname, void *scene);
// c::PrintSyntaxError
// file ../demosrc/parse.c line 169
static void PrintSyntaxError(struct anon$6 *ph, const char *string, const char *found);
// c::Raypnt
// file ../src/vector.h line 14
struct anon$0 Raypnt(struct ray_t$link130 *a, double t);
// c::ReadIncludeFile
// file ../demosrc/parse.c line 277
static unsigned int ReadIncludeFile(struct anon$6 *ph, const char *includefile, void *scene);
// c::ResetImages
// file ../src/imap.h line 12
void ResetImages(void);
// c::RmatIdentity
// file ../demosrc/ac3dparse.c line 238
static void RmatIdentity(float (*rmat)[3l]);
// c::RmatMult
// file ../demosrc/ac3dparse.c line 250
static void RmatMult(float (*A)[3l], float (*B)[3l], float (*C)[3l]);
// c::RmatTmatMult
// file ../demosrc/ac3dparse.c line 263
static void RmatTmatMult(float *NT, float (*R)[3l], float *T);
// c::Rotate3d
// file ../demosrc/parse.c line 149
static void Rotate3d(struct anon$8 *rot, struct anon$0 *vec);
// c::Scale3d
// file ../demosrc/parse.c line 157
static void Scale3d(struct anon$0 *scale, struct anon$0 *vec);
// c::Trans3d
// file ../demosrc/parse.c line 163
static void Trans3d(struct anon$0 *trans, struct anon$0 *vec);
// c::VAdd
// file ../src/vector.h line 11
void VAdd(const struct anon$0 *a, const struct anon$0 *b, struct anon$0 *c);
// c::VAddS
// file ../src/vector.c line 48
void VAddS(double a, const struct anon$0 *A, const struct anon$0 *B, struct anon$0 *C);
// c::VCross
// file ../src/vector.h line 8
void VCross(const struct anon$0 *a, const struct anon$0 *b, struct anon$0 *c);
// c::VDot
// file ../src/vector.h line 7
double VDot(const struct anon$0 *a, const struct anon$0 *b);
// c::VLength
// file ../src/vector.h line 9
double VLength(const struct anon$0 *a);
// c::VNorm
// file ../src/vector.h line 10
void VNorm(struct anon$0 *a);
// c::VScale
// file ../src/vector.c line 64
void VScale(struct anon$0 *a, double s);
// c::VSub
// file ../src/vector.h line 12
void VSub(const struct anon$0 *a, const struct anon$0 *b, struct anon$0 *c);
// c::VolImageMapNearest
// file ../src/imap.c line 405
struct anon$4 VolImageMapNearest(const struct anon$33 *img, double u, double v, double w);
// c::VolImageMapTrilinear
// file ../src/imap.c line 427
struct anon$4 VolImageMapTrilinear(const struct anon$33 *img, double u, double v, double w);
// c::VolMIPMap
// file ../src/imap.h line 22
struct anon$4 VolMIPMap(const struct anon$34 *mip, double u, double v, double w, double d);
// c::VoxelColor
// file ../src/vol.c line 109
struct anon$4 VoxelColor(double scalar);
// c::_IO_getc
// file /usr/include/libio.h line 435
signed int _IO_getc(struct _IO_FILE *);
// c::_IO_putc
// file /usr/include/libio.h line 436
signed int _IO_putc(signed int, struct _IO_FILE *);
// c::__builtin___memcpy_chk
// file gcc_builtin_headers_generic.h line 16
void * __builtin___memcpy_chk(void *, const void *, unsigned int, unsigned long int);
// c::__builtin___memmove_chk
// file gcc_builtin_headers_generic.h line 17
char * __builtin___memmove_chk(void *, const void *, unsigned int, unsigned long int);
// c::__builtin___memset_chk
// file gcc_builtin_headers_generic.h line 35
void * __builtin___memset_chk(void *, signed int, unsigned int, unsigned long int);
// c::__builtin___snprintf_chk
// file gcc_builtin_headers_generic.h line 50
signed int __builtin___snprintf_chk(char *, unsigned long int, signed int, unsigned long int, const char *, ...);
// c::__builtin___sprintf_chk
// file gcc_builtin_headers_generic.h line 49
signed int __builtin___sprintf_chk(char *, signed int, unsigned long int, const char *, ...);
// c::__builtin___strcat_chk
// file gcc_builtin_headers_generic.h line 41
char * __builtin___strcat_chk(char *, const char *, unsigned long int);
// c::__builtin___strcpy_chk
// file gcc_builtin_headers_generic.h line 43
char * __builtin___strcpy_chk(char *, const char *, unsigned long int);
// c::__builtin___strncat_chk
// file gcc_builtin_headers_generic.h line 61
char * __builtin___strncat_chk(char *, const char *, unsigned int, unsigned long int);
// c::__builtin___strncpy_chk
// file gcc_builtin_headers_generic.h line 45
char * __builtin___strncpy_chk(char *, const char *, unsigned int, unsigned long int);
// c::__builtin___vsnprintf_chk
// file gcc_builtin_headers_generic.h line 52
signed int __builtin___vsnprintf_chk(char *, unsigned long int, signed int, unsigned long int, const char *, void **);
// c::__builtin___vsprintf_chk
// file gcc_builtin_headers_generic.h line 51
signed int __builtin___vsprintf_chk(char *, signed int, unsigned long int, const char *, void **);
// c::__builtin_strchr
// file gcc_builtin_headers_generic.h line 54
char * __builtin_strchr(const char *, signed int);
// c::__builtin_strcmp
// file gcc_builtin_headers_generic.h line 22
signed int __builtin_strcmp(const char *, const char *);
// c::__builtin_strlen
// file gcc_builtin_headers_generic.h line 23
unsigned int __builtin_strlen(const char *);
// c::__builtin_va_arg_pack
// file gcc_builtin_headers_generic.h line 5
void * __builtin_va_arg_pack();
// c::__builtin_va_arg_pack_len
// file gcc_builtin_headers_generic.h line 6
signed int __builtin_va_arg_pack_len();
// c::__confstr_alias
// file /usr/include/x86_64-linux-gnu/bits/unistd.h line 231
unsigned long int __confstr_alias(signed int, char *, unsigned long int);
// c::__confstr_chk
// file /usr/include/x86_64-linux-gnu/bits/unistd.h line 229
unsigned long int __confstr_chk(signed int, char *, unsigned long int, unsigned long int);
// c::__confstr_chk_warn
// file /usr/include/x86_64-linux-gnu/bits/unistd.h line 233
unsigned long int __confstr_chk_warn(signed int, char *, unsigned long int, unsigned long int);
// c::__ctype_tolower_loc
// file /usr/include/ctype.h line 82
const signed int ** __ctype_tolower_loc(void);
// c::__ctype_toupper_loc
// file /usr/include/ctype.h line 84
const signed int ** __ctype_toupper_loc(void);
// c::__dprintf_chk
// file /usr/include/x86_64-linux-gnu/bits/stdio2.h line 131
signed int __dprintf_chk(signed int, signed int, const char *, ...);
// c::__fgets_alias
// file /usr/include/x86_64-linux-gnu/bits/stdio2.h line 243
char * __fgets_alias(char *, signed int, struct _IO_FILE *);
// c::__fgets_chk
// file /usr/include/x86_64-linux-gnu/bits/stdio2.h line 241
char * __fgets_chk(char *, unsigned long int, signed int, struct _IO_FILE *);
// c::__fgets_chk_warn
// file /usr/include/x86_64-linux-gnu/bits/stdio2.h line 246
char * __fgets_chk_warn(char *, unsigned long int, signed int, struct _IO_FILE *);
// c::__fprintf_chk
// file /usr/include/x86_64-linux-gnu/bits/stdio2.h line 85
signed int __fprintf_chk(struct _IO_FILE *, signed int, const char *, ...);
// c::__fread_alias
// file /usr/include/x86_64-linux-gnu/bits/stdio2.h line 269
unsigned long int __fread_alias(void *, unsigned long int, unsigned long int, struct _IO_FILE *);
// c::__fread_chk
// file /usr/include/x86_64-linux-gnu/bits/stdio2.h line 266
unsigned long int __fread_chk(void *, unsigned long int, unsigned long int, unsigned long int, struct _IO_FILE *);
// c::__fread_chk_warn
// file /usr/include/x86_64-linux-gnu/bits/stdio2.h line 273
unsigned long int __fread_chk_warn(void *, unsigned long int, unsigned long int, unsigned long int, struct _IO_FILE *);
// c::__fread_unlocked_alias
// file /usr/include/x86_64-linux-gnu/bits/stdio2.h line 330
unsigned long int __fread_unlocked_alias(void *, unsigned long int, unsigned long int, struct _IO_FILE *);
// c::__fread_unlocked_chk
// file /usr/include/x86_64-linux-gnu/bits/stdio2.h line 327
unsigned long int __fread_unlocked_chk(void *, unsigned long int, unsigned long int, unsigned long int, struct _IO_FILE *);
// c::__fread_unlocked_chk_warn
// file /usr/include/x86_64-linux-gnu/bits/stdio2.h line 334
unsigned long int __fread_unlocked_chk_warn(void *, unsigned long int, unsigned long int, unsigned long int, struct _IO_FILE *);
// c::__fxstat
// file /usr/include/x86_64-linux-gnu/sys/stat.h line 400
signed int __fxstat(signed int, signed int, struct stat *);
// c::__fxstatat
// file /usr/include/x86_64-linux-gnu/sys/stat.h line 406
signed int __fxstatat(signed int, signed int, const char *, struct stat *, signed int);
// c::__gamma_r_finite
// file /usr/include/x86_64-linux-gnu/bits/math-finite.h line 427
double __gamma_r_finite(double, signed int *);
// c::__gammaf_r_finite
// file /usr/include/x86_64-linux-gnu/bits/math-finite.h line 434
float __gammaf_r_finite(float, signed int *);
// c::__gammal_r_finite
// file /usr/include/x86_64-linux-gnu/bits/math-finite.h line 442
long double __gammal_r_finite(long double, signed int *);
// c::__getcwd_alias
// file /usr/include/x86_64-linux-gnu/bits/unistd.h line 191
char * __getcwd_alias(char *, unsigned long int);
// c::__getcwd_chk
// file /usr/include/x86_64-linux-gnu/bits/unistd.h line 189
char * __getcwd_chk(char *, unsigned long int, unsigned long int);
// c::__getcwd_chk_warn
// file /usr/include/x86_64-linux-gnu/bits/unistd.h line 193
char * __getcwd_chk_warn(char *, unsigned long int, unsigned long int);
// c::__getdomainname_alias
// file /usr/include/x86_64-linux-gnu/bits/unistd.h line 362
signed int __getdomainname_alias(char *, unsigned long int);
// c::__getdomainname_chk
// file /usr/include/x86_64-linux-gnu/bits/unistd.h line 360
signed int __getdomainname_chk(char *, unsigned long int, unsigned long int);
// c::__getdomainname_chk_warn
// file /usr/include/x86_64-linux-gnu/bits/unistd.h line 365
signed int __getdomainname_chk_warn(char *, unsigned long int, unsigned long int);
// c::__getgroups_alias
// file /usr/include/x86_64-linux-gnu/bits/unistd.h line 256
signed int __getgroups_alias(signed int, unsigned int *);
// c::__getgroups_chk
// file /usr/include/x86_64-linux-gnu/bits/unistd.h line 254
signed int __getgroups_chk(signed int, unsigned int *, unsigned long int);
// c::__getgroups_chk_warn
// file /usr/include/x86_64-linux-gnu/bits/unistd.h line 258
signed int __getgroups_chk_warn(signed int, unsigned int *, unsigned long int);
// c::__gethostname_alias
// file /usr/include/x86_64-linux-gnu/bits/unistd.h line 335
signed int __gethostname_alias(char *, unsigned long int);
// c::__gethostname_chk
// file /usr/include/x86_64-linux-gnu/bits/unistd.h line 333
signed int __gethostname_chk(char *, unsigned long int, unsigned long int);
// c::__gethostname_chk_warn
// file /usr/include/x86_64-linux-gnu/bits/unistd.h line 337
signed int __gethostname_chk_warn(char *, unsigned long int, unsigned long int);
// c::__getlogin_r_alias
// file /usr/include/x86_64-linux-gnu/bits/unistd.h line 308
signed int __getlogin_r_alias(char *, unsigned long int);
// c::__getlogin_r_chk
// file /usr/include/x86_64-linux-gnu/bits/unistd.h line 306
signed int __getlogin_r_chk(char *, unsigned long int, unsigned long int);
// c::__getlogin_r_chk_warn
// file /usr/include/x86_64-linux-gnu/bits/unistd.h line 310
signed int __getlogin_r_chk_warn(char *, unsigned long int, unsigned long int);
// c::__gets_chk
// file /usr/include/x86_64-linux-gnu/bits/stdio2.h line 227
char * __gets_chk(char *, unsigned long int);
// c::__gets_warn
// file /usr/include/x86_64-linux-gnu/bits/stdio2.h line 228
char * __gets_warn(char *);
// c::__getwd_chk
// file /usr/include/x86_64-linux-gnu/bits/unistd.h line 214
char * __getwd_chk(char *, unsigned long int);
// c::__getwd_warn
// file /usr/include/x86_64-linux-gnu/bits/unistd.h line 216
char * __getwd_warn(char *);
// c::__lxstat
// file /usr/include/x86_64-linux-gnu/sys/stat.h line 404
signed int __lxstat(signed int, const char *, struct stat *);
// c::__mbstowcs_alias
// file /usr/include/x86_64-linux-gnu/bits/stdlib.h line 101
unsigned long int __mbstowcs_alias(signed int *, const char *, unsigned long int);
// c::__mbstowcs_chk
// file /usr/include/x86_64-linux-gnu/bits/stdlib.h line 98
unsigned long int __mbstowcs_chk(signed int *, const char *, unsigned long int, unsigned long int);
// c::__mbstowcs_chk_warn
// file /usr/include/x86_64-linux-gnu/bits/stdlib.h line 105
unsigned long int __mbstowcs_chk_warn(signed int *, const char *, unsigned long int, unsigned long int);
// c::__open_2
// file /usr/include/x86_64-linux-gnu/bits/fcntl2.h line 26
signed int __open_2(const char *, signed int);
// c::__open_alias
// file /usr/include/x86_64-linux-gnu/bits/fcntl2.h line 27
signed int __open_alias(const char *, signed int, ...);
// c::__open_missing_mode
// file /usr/include/x86_64-linux-gnu/bits/fcntl2.h line 37
void __open_missing_mode(void);
// c::__open_too_many_args
// file /usr/include/x86_64-linux-gnu/bits/fcntl2.h line 35
void __open_too_many_args(void);
// c::__openat_2
// file /usr/include/x86_64-linux-gnu/bits/fcntl2.h line 98
signed int __openat_2(signed int, const char *, signed int);
// c::__openat_alias
// file /usr/include/x86_64-linux-gnu/bits/fcntl2.h line 100
signed int __openat_alias(signed int, const char *, signed int, ...);
// c::__openat_missing_mode
// file /usr/include/x86_64-linux-gnu/bits/fcntl2.h line 113
void __openat_missing_mode(void);
// c::__openat_too_many_args
// file /usr/include/x86_64-linux-gnu/bits/fcntl2.h line 111
void __openat_too_many_args(void);
// c::__overflow
// file /usr/include/libio.h line 393
signed int __overflow(struct _IO_FILE *, signed int);
// c::__printf_chk
// file /usr/include/x86_64-linux-gnu/bits/stdio2.h line 87
signed int __printf_chk(signed int, const char *, ...);
// c::__ptsname_r_alias
// file /usr/include/x86_64-linux-gnu/bits/stdlib.h line 54
signed int __ptsname_r_alias(signed int, char *, unsigned long int);
// c::__ptsname_r_chk
// file /usr/include/x86_64-linux-gnu/bits/stdlib.h line 52
signed int __ptsname_r_chk(signed int, char *, unsigned long int, unsigned long int);
// c::__ptsname_r_chk_warn
// file /usr/include/x86_64-linux-gnu/bits/stdlib.h line 57
signed int __ptsname_r_chk_warn(signed int, char *, unsigned long int, unsigned long int);
// c::__rawmemchr
// file /usr/include/x86_64-linux-gnu/bits/string2.h line 393
void * __rawmemchr(const void *, signed int);
// c::__read_alias
// file /usr/include/x86_64-linux-gnu/bits/unistd.h line 25
signed long int __read_alias(signed int, void *, unsigned long int);
// c::__read_chk
// file /usr/include/x86_64-linux-gnu/bits/unistd.h line 23
signed long int __read_chk(signed int, void *, unsigned long int, unsigned long int);
// c::__read_chk_warn
// file /usr/include/x86_64-linux-gnu/bits/unistd.h line 27
signed long int __read_chk_warn(signed int, void *, unsigned long int, unsigned long int);
// c::__readlink_alias
// file /usr/include/x86_64-linux-gnu/bits/unistd.h line 127
signed long int __readlink_alias(const char *, char *, unsigned long int);
// c::__readlink_chk
// file /usr/include/x86_64-linux-gnu/bits/unistd.h line 123
signed long int __readlink_chk(const char *, char *, unsigned long int, unsigned long int);
// c::__readlink_chk_warn
// file /usr/include/x86_64-linux-gnu/bits/unistd.h line 131
signed long int __readlink_chk_warn(const char *, char *, unsigned long int, unsigned long int);
// c::__readlinkat_alias
// file /usr/include/x86_64-linux-gnu/bits/unistd.h line 159
signed long int __readlinkat_alias(signed int, const char *, char *, unsigned long int);
// c::__readlinkat_chk
// file /usr/include/x86_64-linux-gnu/bits/unistd.h line 155
signed long int __readlinkat_chk(signed int, const char *, char *, unsigned long int, unsigned long int);
// c::__readlinkat_chk_warn
// file /usr/include/x86_64-linux-gnu/bits/unistd.h line 164
signed long int __readlinkat_chk_warn(signed int, const char *, char *, unsigned long int, unsigned long int);
// c::__realpath_alias
// file /usr/include/x86_64-linux-gnu/bits/stdlib.h line 26
char * __realpath_alias(const char *, char *);
// c::__realpath_chk
// file /usr/include/x86_64-linux-gnu/bits/stdlib.h line 23
char * __realpath_chk(const char *, char *, unsigned long int);
// c::__signbit
// file /usr/include/x86_64-linux-gnu/bits/mathinline.h line 139
signed int __signbit(double __x);
// c::__signbitf
// file /usr/include/x86_64-linux-gnu/bits/mathinline.h line 127
signed int __signbitf(float __x);
// c::__signbitl
// file /usr/include/x86_64-linux-gnu/bits/mathinline.h line 151
signed int __signbitl(long double __x);
// c::__stpncpy_alias
// file /usr/include/x86_64-linux-gnu/bits/string3.h line 126
char * __stpncpy_alias(char *, const char *, unsigned long int);
// c::__stpncpy_chk
// file /usr/include/x86_64-linux-gnu/bits/string3.h line 124
char * __stpncpy_chk(char *, const char *, unsigned long int, unsigned long int);
// c::__strcspn_c1
// file /usr/include/x86_64-linux-gnu/bits/string2.h line 970
unsigned long int __strcspn_c1(const char *__s, signed int __reject);
// c::__strcspn_c2
// file /usr/include/x86_64-linux-gnu/bits/string2.h line 981
unsigned long int __strcspn_c2(const char *__s, signed int __reject1, signed int __reject2);
// c::__strcspn_c3
// file /usr/include/x86_64-linux-gnu/bits/string2.h line 993
unsigned long int __strcspn_c3(const char *__s, signed int __reject1, signed int __reject2, signed int __reject3);
// c::__strpbrk_c2
// file /usr/include/x86_64-linux-gnu/bits/string2.h line 1123
char * __strpbrk_c2(const char *__s, signed int __accept1, signed int __accept2);
// c::__strpbrk_c3
// file /usr/include/x86_64-linux-gnu/bits/string2.h line 1134
char * __strpbrk_c3(const char *__s, signed int __accept1, signed int __accept2, signed int __accept3);
// c::__strsep_1c
// file /usr/include/x86_64-linux-gnu/bits/string2.h line 1222
char * __strsep_1c(char **__s, char __reject);
// c::__strsep_2c
// file /usr/include/x86_64-linux-gnu/bits/string2.h line 1232
char * __strsep_2c(char **__s, char __reject1, char __reject2);
// c::__strsep_3c
// file /usr/include/x86_64-linux-gnu/bits/string2.h line 1260
char * __strsep_3c(char **__s, char __reject1, char __reject2, char __reject3);
// c::__strspn_c1
// file /usr/include/x86_64-linux-gnu/bits/string2.h line 1046
unsigned long int __strspn_c1(const char *__s, signed int __accept);
// c::__strspn_c2
// file /usr/include/x86_64-linux-gnu/bits/string2.h line 1058
unsigned long int __strspn_c2(const char *__s, signed int __accept1, signed int __accept2);
// c::__strspn_c3
// file /usr/include/x86_64-linux-gnu/bits/string2.h line 1070
unsigned long int __strspn_c3(const char *__s, signed int __accept1, signed int __accept2, signed int __accept3);
// c::__strtok_r_1c
// file /usr/include/x86_64-linux-gnu/bits/string2.h line 1172
char * __strtok_r_1c(char *__s, char __sep, char **__nextp);
// c::__ttyname_r_alias
// file /usr/include/x86_64-linux-gnu/bits/unistd.h line 281
signed int __ttyname_r_alias(signed int, char *, unsigned long int);
// c::__ttyname_r_chk
// file /usr/include/x86_64-linux-gnu/bits/unistd.h line 279
signed int __ttyname_r_chk(signed int, char *, unsigned long int, unsigned long int);
// c::__ttyname_r_chk_warn
// file /usr/include/x86_64-linux-gnu/bits/unistd.h line 284
signed int __ttyname_r_chk_warn(signed int, char *, unsigned long int, unsigned long int);
// c::__uflow
// file /usr/include/libio.h line 392
signed int __uflow(struct _IO_FILE *);
// c::__vdprintf_chk
// file /usr/include/x86_64-linux-gnu/bits/stdio2.h line 133
signed int __vdprintf_chk(signed int, signed int, const char *, void **);
// c::__vfprintf_chk
// file /usr/include/x86_64-linux-gnu/bits/stdio2.h line 88
signed int __vfprintf_chk(struct _IO_FILE *, signed int, const char *, void **);
// c::__warn_memset_zero_len
// file /usr/include/x86_64-linux-gnu/bits/string3.h line 22
void __warn_memset_zero_len(void);
// c::__wcstombs_alias
// file /usr/include/x86_64-linux-gnu/bits/stdlib.h line 133
unsigned long int __wcstombs_alias(char *, const signed int *, unsigned long int);
// c::__wcstombs_chk
// file /usr/include/x86_64-linux-gnu/bits/stdlib.h line 130
unsigned long int __wcstombs_chk(char *, const signed int *, unsigned long int, unsigned long int);
// c::__wcstombs_chk_warn
// file /usr/include/x86_64-linux-gnu/bits/stdlib.h line 137
unsigned long int __wcstombs_chk_warn(char *, const signed int *, unsigned long int, unsigned long int);
// c::__wctomb_alias
// file /usr/include/x86_64-linux-gnu/bits/stdlib.h line 79
signed int __wctomb_alias(char *, signed int);
// c::__wctomb_chk
// file /usr/include/x86_64-linux-gnu/bits/stdlib.h line 77
signed int __wctomb_chk(char *, signed int, unsigned long int);
// c::__xmknod
// file /usr/include/x86_64-linux-gnu/sys/stat.h line 443
signed int __xmknod(signed int, const char *, unsigned int, unsigned long int *);
// c::__xmknodat
// file /usr/include/x86_64-linux-gnu/sys/stat.h line 446
signed int __xmknodat(signed int, signed int, const char *, unsigned int, unsigned long int *);
// c::__xstat
// file /usr/include/x86_64-linux-gnu/sys/stat.h line 402
signed int __xstat(signed int, const char *, struct stat *);
// c::abs
// file /usr/include/stdlib.h line 770
signed int abs(signed int);
// c::acos
// file /usr/include/x86_64-linux-gnu/bits/mathcalls.h line 54
double acos(double);
// c::add_bounded_object
// file ../src/api.c line 731
static void add_bounded_object(struct anon$17 *scene, struct anon$15 *obj);
// c::add_clipped_intersection
// file ../src/intersect.h line 12
void add_clipped_intersection(double t, const struct anon$15 *obj, struct ray_t$link0 *ry);
// c::add_clipped_shadow_intersection
// file ../src/intersect.c line 130
void add_clipped_shadow_intersection(double t, const struct anon$15 *obj, struct ray_t$link0 *ry);
// c::add_quats
// file ../demosrc/trackball.c line 247
void add_quats(float *q1, float *q2, float *dest);
// c::add_regular_intersection
// file ../src/intersect.h line 13
void add_regular_intersection(double t, const struct anon$15 *obj, struct ray_t$link0 *ry);
// c::add_shadow_intersection
// file ../src/intersect.c line 108
void add_shadow_intersection(double t, const struct anon$15 *obj, struct ray_t$link0 *ry);
// c::add_texture
// file ../demosrc/parse.c line 81
static unsigned int add_texture(struct anon$6 *ph, void *tex, const char *name);
// c::add_texture$link50
// file ../demosrc/ac3dparse.c line 63
static unsigned int add_texture$link50(void *tex$link46, char *name$link48);
// c::add_unbounded_object
// file ../src/api.c line 750
static void add_unbounded_object(struct anon$17 *scene, struct anon$15 *obj);
// c::adjust
// file ../src/apigeom.c line 147
static void adjust(double *base, signed int xres, signed int yres, double wx, double wy, signed int xa, signed int ya, signed int x, signed int y, signed int xb, signed int yb, unsigned int *rndval);
// c::alos
// file ../src/hash.c line 239
static float alos(struct rt_hash_t *tptr);
// c::animate_scene
// file ../demosrc/main.c line 224
static signed int animate_scene(struct anon$1 opt, void *scene, signed int node);
// c::apitextotex
// file ../src/api.c line 590
void apitextotex(struct anon$7 *apitex, struct anon$25 *tx);
// c::asin
// file /usr/include/x86_64-linux-gnu/bits/mathcalls.h line 56
double asin(double);
// c::atan
// file /usr/include/x86_64-linux-gnu/bits/mathcalls.h line 58
double atan(double);
// c::atof
// file /usr/include/x86_64-linux-gnu/bits/stdlib-float.h line 26
double atof(const char *__nptr);
// c::atoi
// file /usr/include/stdlib.h line 278
signed int atoi(const char *__nptr);
// c::atol
// file /usr/include/stdlib.h line 283
signed long int atol(const char *__nptr);
// c::atoll
// file /usr/include/stdlib.h line 292
signed long long int atoll(const char *__nptr);
// c::axis_to_quat
// file ../demosrc/trackball.c line 206
void axis_to_quat(float *a, float phi, float *q);
// c::bcopy
// file /usr/include/x86_64-linux-gnu/bits/string3.h line 89
void bcopy(const void *__src, void *__dest, unsigned long int __len);
// c::box_bbox
// file ../src/box.c line 15
signed int box_bbox(void *obj, struct anon$0 *min, struct anon$0 *max);
// c::box_intersect
// file ../src/box.c line 44
void box_intersect(const struct anon$26 *bx, struct ray_t$link36 *ry);
// c::box_normal
// file ../src/box.c line 94
void box_normal(const struct anon$26 *bx, const struct anon$0 *pnt, struct ray_t$link36 *incident, struct anon$0 *N);
// c::build_rotmatrix
// file ../demosrc/trackball.c line 302
void build_rotmatrix(float (*m)[4l], float *q);
// c::bzero
// file /usr/include/x86_64-linux-gnu/bits/string3.h line 95
void bzero(void *__dest, unsigned long int __len);
// c::calloc
// file /usr/include/stdlib.h line 467
void * calloc(unsigned long int, unsigned long int);
// c::cam_aa_dof_ray
// file ../src/camera.c line 285
struct anon$4 cam_aa_dof_ray(struct ray_t$link210 *ry, double x, double y);
// c::cam_aa_fisheye_ray
// file ../src/camera.c line 565
struct anon$4 cam_aa_fisheye_ray(struct ray_t$link210 *ry, double x, double y);
// c::cam_aa_orthographic_ray
// file ../src/camera.c line 461
struct anon$4 cam_aa_orthographic_ray(struct ray_t$link210 *ry, double x, double y);
// c::cam_aa_perspective_ray
// file ../src/camera.c line 383
struct anon$4 cam_aa_perspective_ray(struct ray_t$link210 *ry, double x, double y);
// c::cam_dof_ray
// file ../src/camera.c line 340
struct anon$4 cam_dof_ray(struct ray_t$link210 *ry, double x, double y);
// c::cam_fisheye_ray
// file ../src/camera.c line 529
struct anon$4 cam_fisheye_ray(struct ray_t$link210 *ry, double x, double y);
// c::cam_orthographic_ray
// file ../src/camera.c line 495
struct anon$4 cam_orthographic_ray(struct ray_t$link210 *ry, double x, double y);
// c::cam_perspective_ray
// file ../src/camera.c line 417
struct anon$4 cam_perspective_ray(struct ray_t$link210 *ry, double x, double y);
// c::camera_init
// file ../src/camera.c line 20
void camera_init(struct anon$31$link211 *scene);
// c::cameradof
// file ../src/camera.h line 12
void cameradof(struct anon$14 *camera, double focallength, double aperture);
// c::camerafrustum
// file ../src/camera.h line 13
void camerafrustum(struct anon$14 *camera, double left, double right, double bottom, double top);
// c::cameraposition
// file ../src/camera.h line 15
void cameraposition(struct anon$14 *camera, struct anon$0 center, struct anon$0 viewvec, struct anon$0 upvec);
// c::cameraprojection
// file ../src/camera.h line 11
void cameraprojection(struct anon$14 *camera, signed int mode);
// c::camerasetup
// file ../src/camera.h line 10
void camerasetup(struct anon$31$link211 *scene, double zoom, struct anon$0 center, struct anon$0 viewvec, struct anon$0 upvec);
// c::camray_init
// file ../src/camera.c line 158
void camray_init(struct anon$31$link211 *scene, struct ray_t$link210 *primary, unsigned long int serial, unsigned long int *mbox, unsigned int randval);
// c::cellbound
// file ../src/grid.c line 128
static signed int cellbound(const struct anon$50 *g, const struct anon$51 *index, struct anon$0 *cmin, struct anon$0 *cmax);
// c::checker_texture
// file ../src/texture.h line 20
struct anon$4 checker_texture(const struct anon$0 *hit, const struct anon$25 *tx, struct ray_t$link234 *ry);
// c::clear_normals
// file ../demosrc/ac3dparse.c line 304
static void clear_normals(struct anon$0 *normals, signed int numverts);
// c::closest_intersection
// file ../src/intersect.c line 96
signed int closest_intersection(double *t, const struct anon$15 **obj, struct ray_t$link0 *ry);
// c::closetgafile
// file ../src/tgafile.c line 166
void closetgafile(void *voidhandle);
// c::compare
// file ../demosrc/getargs.c line 20
static signed int compare(const char *a, const char *b);
// c::confstr
// file /usr/include/x86_64-linux-gnu/bits/unistd.h line 240
unsigned long int confstr(signed int __name, char *__buf, unsigned long int __len);
// c::constant_texture
// file ../src/texture.h line 15
struct anon$4 constant_texture(const struct anon$0 *hit, const struct anon$25 *tx, struct ray_t$link234 *ry);
// c::cos
// file /usr/include/x86_64-linux-gnu/bits/mathcalls.h line 63
double cos(double);
// c::countobj
// file ../src/grid.c line 191
static signed int countobj(struct anon$15 *root);
// c::create_render_threads
// file ../src/render.c line 61
void create_render_threads(struct anon$30$link108 *scene);
// c::createtgafile
// file ../src/tgafile.c line 20
signed int createtgafile(char *name, unsigned short int width, unsigned short int height);
// c::cyl_checker_texture
// file ../src/texture.h line 21
struct anon$4 cyl_checker_texture(const struct anon$0 *hit, const struct anon$25 *tx, struct ray_t$link234 *ry);
// c::cylinder_bbox
// file ../src/cylinder.c line 46
static signed int cylinder_bbox(void *obj, struct anon$0 *min, struct anon$0 *max);
// c::cylinder_intersect
// file ../src/cylinder.c line 50
static void cylinder_intersect(const struct anon$64 *cyl, struct ray_t$link162 *ry);
// c::cylinder_normal
// file ../src/cylinder.c line 101
static void cylinder_normal(const struct anon$64 *cyl, const struct anon$0 *pnt, struct ray_t$link162 *incident, struct anon$0 *N);
// c::degtorad
// file ../demosrc/parse.c line 120
double degtorad(double deg);
// c::degvectoradvec
// file ../demosrc/parse.c line 126
static void degvectoradvec(struct anon$0 *degvec);
// c::destroy_render_threads
// file ../src/render.h line 8
void destroy_render_threads(struct anon$30$link108 *scene);
// c::directional_light_shade_diffuse
// file ../src/light.c line 139
static double directional_light_shade_diffuse(struct directional_light_t$link271 *li, struct anon$19 *shadevars);
// c::dprintf
// file /usr/include/x86_64-linux-gnu/bits/stdio2.h line 139
signed int dprintf(signed int __fd, const char * restrict __fmt, ...);
// c::engrid_cell
// file ../src/grid.c line 304
static signed int engrid_cell(struct anon$44$link94 *scene, signed int boundthresh, struct anon$50 *gold, struct anon$51 *index);
// c::engrid_object
// file ../src/grid.c line 383
static signed int engrid_object(struct anon$50 *g, struct anon$15 *obj, signed int addtolist);
// c::engrid_objectlist
// file ../src/grid.c line 355
static signed int engrid_objectlist(struct anon$50 *g, struct objectlist **list);
// c::engrid_objlist
// file ../src/grid.c line 277
static signed int engrid_objlist(struct anon$50 *g, struct anon$15 **list);
// c::engrid_scene
// file ../src/grid.h line 8
signed int engrid_scene(struct anon$44$link94 *scene, signed int boundthresh);
// c::exit
// file /usr/include/stdlib.h line 542
void exit(signed int);
// c::exp
// file /usr/include/x86_64-linux-gnu/bits/mathcalls.h line 100
double exp(double);
// c::ext_volume_texture
// file ../src/extvol.c line 107
struct anon$4 ext_volume_texture(const struct anon$0 *hit, const struct anon$25 *tx, struct ray_t$link67 *ry);
// c::extvol_bbox
// file ../src/extvol.c line 23
signed int extvol_bbox(void *obj, struct anon$0 *min, struct anon$0 *max);
// c::fabs
// file /usr/include/x86_64-linux-gnu/bits/mathcalls.h line 182
double fabs(double);
// c::fakeimage
// file ../src/imageio.c line 26
static signed int fakeimage(char *name, signed int *xres, signed int *yres, unsigned char **imgdata);
// c::fclose
// file /usr/include/stdio.h line 237
signed int fclose(struct _IO_FILE *);
// c::fcylinder_bbox
// file ../src/cylinder.c line 150
static signed int fcylinder_bbox(void *obj, struct anon$0 *min, struct anon$0 *max);
// c::fcylinder_intersect
// file ../src/cylinder.c line 179
static void fcylinder_intersect(const struct anon$64 *cyl, struct ray_t$link162 *ry);
// c::feof
// file /usr/include/stdio.h line 828
signed int feof(struct _IO_FILE *);
// c::feof_unlocked
// file /usr/include/x86_64-linux-gnu/bits/stdio.h line 125
signed int feof_unlocked(struct _IO_FILE *__stream);
// c::ferror_unlocked
// file /usr/include/x86_64-linux-gnu/bits/stdio.h line 132
signed int ferror_unlocked(struct _IO_FILE *__stream);
// c::fflush
// file /usr/include/stdio.h line 242
signed int fflush(struct _IO_FILE *);
// c::fgetc
// file /usr/include/stdio.h line 531
signed int fgetc(struct _IO_FILE$link13 *);
// c::fgetc_unlocked
// file /usr/include/x86_64-linux-gnu/bits/stdio.h line 53
signed int fgetc_unlocked(struct _IO_FILE *__fp);
// c::fgets
// file /usr/include/x86_64-linux-gnu/bits/stdio2.h line 253
char * fgets(char * restrict __s, signed int __n, struct _IO_FILE * restrict __stream);
// c::find_texture
// file ../demosrc/parse.c line 108
static void * find_texture(struct anon$6 *ph, const char *name);
// c::fly_scene
// file ../demosrc/main.c line 126
static signed int fly_scene(struct anon$1 opt, void *scene, signed int node);
// c::fog_color
// file ../src/shade.c line 628
struct anon$4 fog_color(struct ray_t$link1 *incident, struct anon$4 col, double t);
// c::fog_color_exp
// file ../src/shade.h line 27
struct anon$4 fog_color_exp(struct fogdata_t$link3 *fog, struct anon$4 col, double r);
// c::fog_color_exp2
// file ../src/shade.h line 28
struct anon$4 fog_color_exp2(struct fogdata_t$link3 *fog, struct anon$4 col, double r);
// c::fog_color_linear
// file ../src/shade.h line 26
struct anon$4 fog_color_linear(struct fogdata_t$link3 *fog, struct anon$4 col, double r);
// c::fopen
// file /usr/include/stdio.h line 272
struct _IO_FILE * fopen(const char *, const char *);
// c::fprintf
// file /usr/include/x86_64-linux-gnu/bits/stdio2.h line 95
signed int fprintf(struct _IO_FILE * restrict __stream, const char * restrict __fmt, ...);
// c::fputc
// file /usr/include/stdio.h line 573
signed int fputc(signed int, struct _IO_FILE$link43 *);
// c::fputc_unlocked
// file /usr/include/x86_64-linux-gnu/bits/stdio.h line 88
signed int fputc_unlocked(signed int __c, struct _IO_FILE *__stream);
// c::fread
// file /usr/include/x86_64-linux-gnu/bits/stdio2.h line 282
unsigned long int fread(void * restrict __ptr, unsigned long int __size, unsigned long int __n, struct _IO_FILE * restrict __stream);
// c::fread_unlocked
// file /usr/include/x86_64-linux-gnu/bits/stdio2.h line 343
unsigned long int fread_unlocked(void * restrict __ptr, unsigned long int __size, unsigned long int __n, struct _IO_FILE * restrict __stream);
// c::free
// file /usr/include/stdlib.h line 482
void free(void *);
// c::free_light_special
// file ../src/light.h line 36
void free_light_special(void *voidlight);
// c::free_objects
// file ../src/intersect.h line 9
void free_objects(struct anon$15 *start);
// c::free_standard_texture
// file ../src/texture.c line 50
void free_standard_texture(void *voidtex);
// c::free_tex_table
// file ../demosrc/parse.c line 66
static void free_tex_table(struct anon$6 *ph, void *scene);
// c::freeoptions
// file ../demosrc/getargs.h line 41
void freeoptions(struct anon$1 *opt);
// c::fscanf
// file /usr/include/stdio.h line 425
signed int fscanf(struct _IO_FILE *, const char *, ...);
// c::fseek
// file /usr/include/stdio.h line 749
signed int fseek(struct _IO_FILE$link13 *, signed long int, signed int);
// c::fstat
// file /usr/include/x86_64-linux-gnu/sys/stat.h line 468
signed int fstat(signed int __fd, struct stat *__statbuf);
// c::fstatat
// file /usr/include/x86_64-linux-gnu/sys/stat.h line 475
signed int fstatat(signed int __fd, const char *__filename, struct stat *__statbuf, signed int __flag);
// c::ftell
// file /usr/include/stdio.h line 754
signed long int ftell(struct _IO_FILE$link13 *);
// c::full_shader
// file ../src/shade.h line 13
struct anon$4 full_shader(struct ray_t$link1 *incident);
// c::fwrite
// file /usr/include/stdio.h line 715
unsigned long int fwrite(const void *, unsigned long int, unsigned long int, struct _IO_FILE$link40 *);
// c::gamma
// file /usr/include/x86_64-linux-gnu/bits/math-finite.h line 289
double gamma(double __d);
// c::gamma_rgb96f
// file ../src/imageio.h line 24
void gamma_rgb96f(signed int xres, signed int yres, float *fimg, float gamma);
// c::gammaf
// file /usr/include/x86_64-linux-gnu/bits/math-finite.h line 298
float gammaf(float __d);
// c::gammal
// file /usr/include/x86_64-linux-gnu/bits/math-finite.h line 308
long double gammal(long double __d);
// c::gen_triangles
// file ../demosrc/ac3dparse.c line 353
static void gen_triangles(void *scene, struct tri_list_t *tlist, struct anon$0 *vertex, struct anon$0 *normal);
// c::getargs
// file ../demosrc/getargs.h line 38
signed int getargs(signed int argc, char **argv, struct anon$1 *opt, signed int node);
// c::getc_unlocked
// file /usr/include/x86_64-linux-gnu/bits/stdio.h line 63
signed int getc_unlocked(struct _IO_FILE *__fp);
// c::getcameraposition
// file ../src/camera.h line 17
void getcameraposition(struct anon$14 *camera, struct anon$0 *center, struct anon$0 *viewvec, struct anon$0 *upvec, struct anon$0 *rightvec);
// c::getchar
// file /usr/include/x86_64-linux-gnu/bits/stdio.h line 44
signed int getchar(void);
// c::getchar_unlocked
// file /usr/include/x86_64-linux-gnu/bits/stdio.h line 70
signed int getchar_unlocked(void);
// c::getcwd
// file /usr/include/x86_64-linux-gnu/bits/unistd.h line 200
char * getcwd(char *__buf, unsigned long int __size);
// c::getdomainname
// file /usr/include/x86_64-linux-gnu/bits/unistd.h line 373
signed int getdomainname(char *__buf, unsigned long int __buflen);
// c::getgroups
// file /usr/include/x86_64-linux-gnu/bits/unistd.h line 265
signed int getgroups(signed int __size, unsigned int *__list);
// c::gethostname
// file /usr/include/x86_64-linux-gnu/bits/unistd.h line 344
signed int gethostname(char *__buf, unsigned long int __buflen);
// c::getint
// file ../src/ppm.c line 18
static signed int getint(struct _IO_FILE$link40 *dfile);
// c::getlogin_r
// file /usr/include/x86_64-linux-gnu/bits/unistd.h line 317
signed int getlogin_r(char *__buf, unsigned long int __buflen);
// c::getparm
// file ../demosrc/getargs.c line 327
static signed int getparm(signed int argc, char **argv, signed int num, struct anon$1 *opt, signed int node);
// c::gets
// file /usr/include/x86_64-linux-gnu/bits/stdio2.h line 233
char * gets(char *__str);
// c::gettimeofday
// file /usr/include/x86_64-linux-gnu/sys/time.h line 72
signed int gettimeofday(struct timeval *, struct timezone *);
// c::getwd
// file /usr/include/x86_64-linux-gnu/bits/unistd.h line 221
char * getwd(char *__buf);
// c::globalbound
// file ../src/grid.c line 98
static void globalbound(struct anon$15 **rootlist, struct anon$0 *gmin, struct anon$0 *gmax);
// c::glwin_create
// file ../demosrc/glwin.c line 427
void * glwin_create(const char *wintitle, signed int width, signed int height);
// c::glwin_destroy
// file ../demosrc/glwin.c line 431
void glwin_destroy(void *voidhandle);
// c::glwin_draw_image
// file ../demosrc/glwin.c line 443
void glwin_draw_image(void *voidhandle, signed int xsize, signed int ysize, unsigned char *img);
// c::glwin_handle_events
// file ../demosrc/glwin.c line 439
signed int glwin_handle_events(void *voidhandle);
// c::glwin_swap_buffers
// file ../demosrc/glwin.c line 435
void glwin_swap_buffers(void *voidhandle);
// c::gnoise_texture
// file ../src/texture.h line 25
struct anon$4 gnoise_texture(const struct anon$0 *hit, const struct anon$25 *tx, struct ray_t$link234 *ry);
// c::gnu_dev_major
// file /usr/include/x86_64-linux-gnu/sys/sysmacros.h line 44
unsigned int gnu_dev_major(unsigned long long int __dev);
// c::gnu_dev_makedev
// file /usr/include/x86_64-linux-gnu/sys/sysmacros.h line 56
unsigned long long int gnu_dev_makedev(unsigned int __major, unsigned int __minor);
// c::gnu_dev_minor
// file /usr/include/x86_64-linux-gnu/sys/sysmacros.h line 50
unsigned int gnu_dev_minor(unsigned long long int __dev);
// c::grid_bbox
// file ../src/grid.c line 62
static signed int grid_bbox(void *obj, struct anon$0 *min, struct anon$0 *max);
// c::grid_bounds_intersect
// file ../src/grid.c line 622
static signed int grid_bounds_intersect(const struct anon$50 *g, struct ray_t$link93 *ry, double *hitnear, double *hitfar);
// c::grid_free
// file ../src/grid.c line 71
static void grid_free(void *v);
// c::grid_intersect
// file ../src/grid.c line 465
static void grid_intersect(const struct anon$50 *g, struct ray_t$link93 *ry);
// c::gridstats
// file ../src/grid.c line 205
static void gridstats(signed int xs, signed int ys, signed int zs, signed int numobj);
// c::grit_texture
// file ../src/texture.h line 22
struct anon$4 grit_texture(const struct anon$0 *hit, const struct anon$25 *tx, struct ray_t$link234 *ry);
// c::hash
// file ../src/hash.c line 30
static signed int hash(struct rt_hash_t *tptr, const char *key);
// c::image_crop_rgb24
// file ../src/imageio.h line 29
unsigned char * image_crop_rgb24(signed int xres, signed int yres, unsigned char *img, signed int szx, signed int szy, signed int sx, signed int sy);
// c::image_crop_rgb96f
// file ../src/imageio.h line 27
float * image_crop_rgb96f(signed int xres, signed int yres, float *fimg, signed int szx, signed int szy, signed int sx, signed int sy);
// c::image_cyl_texture
// file ../src/texture.h line 16
struct anon$4 image_cyl_texture(const struct anon$0 *hit, const struct anon$25 *tx, struct ray_t$link234 *ry);
// c::image_plane_texture
// file ../src/texture.h line 18
struct anon$4 image_plane_texture(const struct anon$0 *hit, const struct anon$25 *tx, struct ray_t$link234 *ry);
// c::image_rgb24_from_rgb96f
// file ../src/imageio.c line 150
unsigned char * image_rgb24_from_rgb96f(signed int xres, signed int yres, float *fimg);
// c::image_rgb48be_from_rgb96f
// file ../src/imageio.c line 232
unsigned char * image_rgb48be_from_rgb96f(signed int xres, signed int yres, float *fimg);
// c::image_rgb48bepl_from_rgb96f
// file ../src/imageio.c line 266
unsigned char * image_rgb48bepl_from_rgb96f(signed int xres, signed int yres, float *fimg);
// c::image_sphere_texture
// file ../src/texture.h line 17
struct anon$4 image_sphere_texture(const struct anon$0 *hit, const struct anon$25 *tx, struct ray_t$link234 *ry);
// c::image_volume_texture
// file ../src/texture.h line 19
struct anon$4 image_volume_texture(const struct anon$0 *hit, const struct anon$25 *tx, struct ray_t$link234 *ry);
// c::initoptions
// file ../demosrc/getargs.c line 127
static void initoptions(struct anon$1 *opt);
// c::intersect_objects
// file ../src/intersect.h line 10
void intersect_objects(struct ray_t$link0 *ry);
// c::jitter_disc2f
// file ../src/util.c line 596
void jitter_disc2f(unsigned int *pval, float *dir);
// c::jitter_offset2f
// file ../src/util.h line 89
void jitter_offset2f(unsigned int *pval, float *xy);
// c::jitter_sphere3f
// file ../src/util.c line 608
void jitter_sphere3f(struct anon$18 *rngh, float *dir);
// c::lgamma
// file /usr/include/x86_64-linux-gnu/bits/math-finite.h line 256
double lgamma(double __d);
// c::lgamma_r
// file /usr/include/x86_64-linux-gnu/bits/mathcalls.h line 272
double lgamma_r(double, signed int *);
// c::lgammaf
// file /usr/include/x86_64-linux-gnu/bits/math-finite.h line 265
float lgammaf(float __d);
// c::lgammaf_r
// file /usr/include/x86_64-linux-gnu/bits/mathcalls.h line 272
float lgammaf_r(float, signed int *);
// c::lgammal
// file /usr/include/x86_64-linux-gnu/bits/math-finite.h line 275
long double lgammal(long double __d);
// c::lgammal_r
// file /usr/include/x86_64-linux-gnu/bits/mathcalls.h line 272
long double lgammal_r(long double, signed int *);
// c::light_bbox
// file ../src/light.c line 234
static signed int light_bbox(void *obj, struct anon$0 *min, struct anon$0 *max);
// c::light_complex_attenuation
// file ../src/light.c line 201
static double light_complex_attenuation(void *vli, double Llen);
// c::light_intersect
// file ../src/light.c line 239
static void light_intersect(struct point_light_t$link242 *l, struct ray_t$link255 *ry);
// c::light_no_attenuation
// file ../src/light.c line 197
static double light_no_attenuation(void *vli, double Llen);
// c::light_no_falloff
// file ../src/light.c line 210
static double light_no_falloff(void *vli, struct anon$0 *L);
// c::light_normal
// file ../src/light.c line 266
static void light_normal(struct point_light_t$link242 *l, const struct anon$0 *pnt, struct ray_t$link255 *incident, struct anon$0 *N);
// c::light_set_attenuation
// file ../src/light.h line 48
void light_set_attenuation(struct point_light_t$link242 *li, double Kc, double Kl, double Kq);
// c::light_spotlight_falloff
// file ../src/light.c line 215
static double light_spotlight_falloff(void *vli, struct anon$0 *L);
// c::low_shader
// file ../src/shade.h line 11
struct anon$4 low_shader(struct ray_t$link1 *incident);
// c::lowest_shader
// file ../src/shade.h line 10
struct anon$4 lowest_shader(struct ray_t$link1 *incident);
// c::lstat
// file /usr/include/x86_64-linux-gnu/sys/stat.h line 461
signed int lstat(const char *__path, struct stat *__statbuf);
// c::malloc
// file /usr/include/stdlib.h line 465
void * malloc(unsigned long int);
// c::marble_texture
// file ../src/texture.h line 24
struct anon$4 marble_texture(const struct anon$0 *hit, const struct anon$25 *tx, struct ray_t$link234 *ry);
// c::max_objectid
// file ../src/intersect.c line 16
unsigned int max_objectid(struct anon$32$link4 *scene);
// c::mbstowcs
// file /usr/include/x86_64-linux-gnu/bits/stdlib.h line 113
unsigned long int mbstowcs(signed int * restrict __dst, const char * restrict __src, unsigned long int __len);
// c::medium_shader
// file ../src/shade.h line 12
struct anon$4 medium_shader(struct ray_t$link1 *incident);
// c::memcpy
// file /usr/include/x86_64-linux-gnu/bits/string3.h line 48
void * memcpy(void * restrict __dest, const void * restrict __src, unsigned long int __len);
// c::memmove
// file /usr/include/x86_64-linux-gnu/bits/string3.h line 55
void * memmove(void *__dest, const void *__src, unsigned long int __len);
// c::memset
// file /usr/include/x86_64-linux-gnu/bits/string3.h line 76
void * memset(void *__dest, signed int __ch, unsigned long int __len);
// c::minmax_rgb96f
// file ../src/imageio.c line 107
void minmax_rgb96f(signed int xres, signed int yres, const float *fimg, float *min, float *max);
// c::mknod
// file /usr/include/x86_64-linux-gnu/sys/stat.h line 484
signed int mknod(const char *__path, unsigned int __mode, unsigned long int __dev);
// c::mknodat
// file /usr/include/x86_64-linux-gnu/sys/stat.h line 492
signed int mknodat(signed int __fd, const char *__path, unsigned int __mode, unsigned long int __dev);
// c::my_ui_message
// file ../demosrc/main.c line 52
static void my_ui_message(signed int a, char *msg);
// c::my_ui_progress
// file ../demosrc/main.c line 56
static void my_ui_progress(signed int percent);
// c::new_objectid
// file ../src/intersect.h line 8
unsigned int new_objectid(struct anon$32$link4 *scene);
// c::new_standard_texture
// file ../src/texture.h line 31
struct anon$25 * new_standard_texture(void);
// c::new_texture
// file ../src/texture.c line 29
struct anon$25 * new_texture(void);
// c::new_vcstri_texture
// file ../src/texture.h line 32
struct anon$25 * new_vcstri_texture(void);
// c::newbox
// file ../src/box.h line 15
struct anon$26 * newbox(void *tex, struct anon$0 min, struct anon$0 max);
// c::newcylinder
// file ../src/cylinder.h line 7
struct anon$15 * newcylinder(void *tex, struct anon$0 ctr, struct anon$0 axis, double rad);
// c::newdirectionallight
// file ../src/light.h line 38
struct directional_light_t$link271 * newdirectionallight(void *tex, struct anon$0 dir);
// c::newextvol
// file ../src/extvol.h line 19
struct anon$29 * newextvol(void *voidtex, struct anon$0 min, struct anon$0 max, signed int samples, double (*evaluator)(double, double, double));
// c::newextvol::evaluator$object
// 
double evaluator$object(double, double, double);
// c::newfcylinder
// file ../src/cylinder.h line 8
struct anon$15 * newfcylinder(void *tex, struct anon$0 ctr, struct anon$0 axis, double rad);
// c::newgrid
// file ../src/grid.c line 32
struct anon$15 * newgrid(struct anon$44$link94 *scene, signed int xsize, signed int ysize, signed int zsize, struct anon$0 min, struct anon$0 max);
// c::newplane
// file ../src/plane.h line 8
struct anon$15 * newplane(void *tex, struct anon$0 ctr, struct anon$0 norm);
// c::newpointlight
// file ../src/light.h line 40
struct point_light_t$link242 * newpointlight(void *tex, struct anon$0 ctr, double rad);
// c::newquadric
// file ../src/quadric.h line 21
struct anon$28 * newquadric(void);
// c::newring
// file ../src/ring.h line 7
struct anon$15 * newring(void *tex, struct anon$0 ctr, struct anon$0 norm, double inrad, double outrad);
// c::newscalarvol
// file ../src/vol.h line 9
void * newscalarvol(void *voidtex, struct anon$0 min, struct anon$0 max, signed int xs, signed int ys, signed int zs, const char *fname, struct anon$10 *invol);
// c::newsphere
// file ../src/sphere.h line 7
struct anon$15 * newsphere(void *tex, struct anon$0 ctr, double rad);
// c::newspotlight
// file ../src/light.h line 41
struct point_light_t$link242 * newspotlight(void *tex, struct anon$0 ctr, double rad, struct anon$0 dir, double fallstart, double fallend);
// c::newstri
// file ../src/triangle.h line 8
struct anon$15 * newstri(void *tex, struct anon$0 v0, struct anon$0 v1, struct anon$0 v2, struct anon$0 n0, struct anon$0 n1, struct anon$0 n2);
// c::newtri
// file ../src/triangle.h line 7
struct anon$15 * newtri(void *tex, struct anon$0 v0, struct anon$0 v1, struct anon$0 v2);
// c::newvcstri
// file ../src/triangle.h line 10
struct anon$15 * newvcstri(void *voidtex, struct anon$0 v0, struct anon$0 v1, struct anon$0 v2, struct anon$0 n0, struct anon$0 n1, struct anon$0 n2, struct anon$4 c0, struct anon$4 c1, struct anon$4 c2);
// c::normalize
// file ../demosrc/ac3dparse.c line 316
static void normalize(struct anon$0 *vec);
// c::normalize_quat
// file ../demosrc/trackball.c line 288
static void normalize_quat(float *q);
// c::normalize_rgb96f
// file ../src/imageio.h line 23
void normalize_rgb96f(signed int xres, signed int yres, float *fimg);
// c::open
// file /usr/include/x86_64-linux-gnu/bits/fcntl2.h line 41
signed int open(const char *__path, signed int __oflag, ...);
// c::openat
// file /usr/include/x86_64-linux-gnu/bits/fcntl2.h line 117
signed int openat(signed int __fd, const char *__path, signed int __oflag, ...);
// c::opentgafile
// file ../src/tgafile.c line 66
void * opentgafile(char *filename);
// c::plane_bbox
// file ../src/plane.c line 39
static signed int plane_bbox(void *obj, struct anon$0 *min, struct anon$0 *max);
// c::plane_intersect
// file ../src/plane.c line 43
static void plane_intersect(const struct anon$55 *pln, struct ray_t$link233 *ry);
// c::plane_normal
// file ../src/plane.c line 61
static void plane_normal(const struct anon$55 *pln, const struct anon$0 *pnt, struct ray_t$link233 *incident, struct anon$0 *N);
// c::point_light_shade_diffuse
// file ../src/light.c line 174
static double point_light_shade_diffuse(struct point_light_t$link242 *li, struct anon$19 *shadevars);
// c::pos2grid
// file ../src/grid.c line 438
static signed int pos2grid(struct anon$50 *g, struct anon$0 *pos, struct anon$51 *index);
// c::postsceneoptions
// file ../demosrc/getargs.h line 40
signed int postsceneoptions(struct anon$1 *opt, void *scene);
// c::pow
// file /usr/include/x86_64-linux-gnu/bits/mathcalls.h line 154
double pow(double, double);
// c::presceneoptions
// file ../demosrc/getargs.h line 39
signed int presceneoptions(struct anon$1 *opt, void *scene);
// c::printf
// file /usr/include/x86_64-linux-gnu/bits/stdio2.h line 102
signed int printf(const char * restrict __fmt, ...);
// c::printusage
// file ../demosrc/getargs.c line 27
static void printusage(char **argv);
// c::pthread_cond_broadcast
// file /usr/include/pthread.h line 972
signed int pthread_cond_broadcast(union anon$42 *);
// c::pthread_cond_destroy
// file /usr/include/pthread.h line 964
signed int pthread_cond_destroy(union anon$42 *);
// c::pthread_cond_init
// file /usr/include/pthread.h line 959
signed int pthread_cond_init(union anon$42 *, const union anon$43 *);
// c::pthread_cond_signal
// file /usr/include/pthread.h line 968
signed int pthread_cond_signal(union anon$42 *);
// c::pthread_cond_wait
// file /usr/include/pthread.h line 980
signed int pthread_cond_wait(union anon$42 *, union anon$40 *);
// c::pthread_create
// file /usr/include/pthread.h line 232
signed int pthread_create(unsigned long int *, const union pthread_attr_t *, void * (*)(void *), void *);
// c::pthread_equal
// file /usr/include/pthread.h line 1144
signed int pthread_equal(unsigned long int __thread1, unsigned long int __thread2);
// c::pthread_join
// file /usr/include/pthread.h line 249
signed int pthread_join(unsigned long int, void **);
// c::pthread_mutex_destroy
// file /usr/include/pthread.h line 745
signed int pthread_mutex_destroy(union anon$40 *);
// c::pthread_mutex_init
// file /usr/include/pthread.h line 740
signed int pthread_mutex_init(union anon$40 *, const union anon$43 *);
// c::pthread_mutex_lock
// file /usr/include/pthread.h line 753
signed int pthread_mutex_lock(union anon$40 *);
// c::pthread_mutex_unlock
// file /usr/include/pthread.h line 764
signed int pthread_mutex_unlock(union anon$40 *);
// c::ptsname_r
// file /usr/include/x86_64-linux-gnu/bits/stdlib.h line 64
signed int ptsname_r(signed int __fd, char *__buf, unsigned long int __buflen);
// c::putbyte
// file ../src/sgirgb.c line 14
static void putbyte(struct _IO_FILE$link42 *outf, unsigned char val);
// c::putc_unlocked
// file /usr/include/x86_64-linux-gnu/bits/stdio.h line 98
signed int putc_unlocked(signed int __c, struct _IO_FILE *__stream);
// c::putchar
// file /usr/include/x86_64-linux-gnu/bits/stdio.h line 79
signed int putchar(signed int __c);
// c::putchar_unlocked
// file /usr/include/x86_64-linux-gnu/bits/stdio.h line 105
signed int putchar_unlocked(signed int __c);
// c::putint
// file ../src/sgirgb.c line 27
static void putint(struct _IO_FILE$link42 *outf, unsigned int val);
// c::putshort
// file ../src/sgirgb.c line 20
static void putshort(struct _IO_FILE$link42 *outf, unsigned short int val);
// c::quadric_bbox
// file ../src/quadric.c line 15
signed int quadric_bbox(void *obj, struct anon$0 *min, struct anon$0 *max);
// c::quadric_intersect
// file ../src/quadric.c line 39
void quadric_intersect(const struct anon$28 *q, struct ray_t$link247 *ry);
// c::quadric_normal
// file ../src/quadric.c line 100
void quadric_normal(const struct anon$28 *q, const struct anon$0 *pnt, struct ray_t$link247 *incident, struct anon$0 *N);
// c::rand
// file /usr/include/stdlib.h line 374
signed int rand(void);
// c::read
// file /usr/include/x86_64-linux-gnu/bits/unistd.h line 34
signed long int read(signed int __fd, void *__buf, unsigned long int __nbytes);
// c::readimage
// file ../src/imageio.h line 18
signed int readimage(struct anon$33 *img);
// c::readjpeg
// file ../src/jpeg.h line 7
signed int readjpeg(char *name, signed int *xres, signed int *yres, unsigned char **imgdata);
// c::readlink
// file /usr/include/x86_64-linux-gnu/bits/unistd.h line 139
signed long int readlink(const char * restrict __path, char * restrict __buf, unsigned long int __len);
// c::readlinkat
// file /usr/include/x86_64-linux-gnu/bits/unistd.h line 173
signed long int readlinkat(signed int __fd, const char * restrict __path, char * restrict __buf, unsigned long int __len);
// c::readmodel
// file ../demosrc/parse.h line 14
unsigned int readmodel(const char *modelfile, void *scene);
// c::readpng
// file ../src/pngfile.h line 7
signed int readpng(char *name, signed int *xres, signed int *yres, unsigned char **imgdata);
// c::readppm
// file ../src/ppm.h line 11
signed int readppm(char *name, signed int *xres, signed int *yres, unsigned char **imgdata);
// c::readtga
// file ../src/tgafile.h line 12
signed int readtga(char *name, signed int *xres, signed int *yres, unsigned char **imgdata);
// c::realloc
// file /usr/include/stdlib.h line 479
void * realloc(void *, unsigned long int);
// c::realpath
// file /usr/include/x86_64-linux-gnu/bits/stdlib.h line 37
char * realpath(const char * restrict __name, char * restrict __resolved);
// c::rebuild_table
// file ../src/hash.c line 50
static void rebuild_table(struct rt_hash_t *tptr);
// c::rendercheck
// file ../src/render.c line 168
static void rendercheck(struct anon$30$link108 *scene);
// c::renderio
// file ../src/render.c line 273
static void renderio(struct anon$30$link108 *scene);
// c::renderscene
// file ../src/render.h line 9
void renderscene(struct anon$30$link108 *scene);
// c::renormalize_normals
// file ../demosrc/ac3dparse.c line 324
static void renormalize_normals(struct anon$0 *normals, signed int numverts);
// c::reset_tex_table
// file ../demosrc/parse.c line 45
static void reset_tex_table(struct anon$6 *ph, void *scene);
// c::reset_tex_table$link39
// file ../demosrc/ac3dparse.c line 58
static void reset_tex_table$link39(void);
// c::ring_bbox
// file ../src/ring.c line 41
static signed int ring_bbox(void *obj, struct anon$0 *min, struct anon$0 *max);
// c::ring_intersect
// file ../src/ring.c line 54
static void ring_intersect(const struct anon$58 *rng, struct ray_t$link108 *ry);
// c::ring_normal
// file ../src/ring.c line 76
static void ring_normal(const struct anon$58 *rng, const struct anon$0 *pnt, struct ray_t$link108 *incident, struct anon$0 *N);
// c::rng_drand
// file ../src/util.c line 558
double rng_drand(struct anon$18 *rngh);
// c::rng_drand_init
// file ../src/util.c line 554
void rng_drand_init(struct anon$18 *rngh);
// c::rng_drand_seed
// file ../src/util.c line 562
void rng_drand_seed(struct anon$18 *rngh, unsigned int seed);
// c::rng_frand
// file ../src/util.c line 546
float rng_frand(struct anon$18 *rngh);
// c::rng_frand_init
// file ../src/util.h line 76
void rng_frand_init(struct anon$18 *rngh);
// c::rng_frand_seed
// file ../src/util.c line 550
void rng_frand_seed(struct anon$18 *rngh, unsigned int seed);
// c::rng_seed_from_tid_nodeid
// file ../src/util.h line 87
unsigned int rng_seed_from_tid_nodeid(signed int tid, signed int node);
// c::rng_urand
// file ../src/util.c line 487
unsigned int rng_urand(struct anon$18 *rngh);
// c::rng_urand_init
// file ../src/util.c line 469
void rng_urand_init(struct anon$18 *rngh);
// c::rng_urand_seed
// file ../src/util.c line 479
void rng_urand_seed(struct anon$18 *rngh, unsigned int seed);
// c::rt_aa_maxsamples
// file ../src/tachyon.h line 146
void rt_aa_maxsamples(void *voidscene, signed int maxsamples);
// c::rt_allocate_reqbuf
// file ../src/parallel.c line 141
void * rt_allocate_reqbuf(signed int count);
// c::rt_ambient_occlusion
// file ../src/tachyon.h line 377
void rt_ambient_occlusion(void *voidscene, signed int numsamples, struct anon$4 col);
// c::rt_autoshader
// file ../src/render.c line 28
static void rt_autoshader(struct anon$30$link108 *scene);
// c::rt_background
// file ../src/tachyon.h line 214
void rt_background(void *voidscene, struct anon$4 col);
// c::rt_background_mode
// file ../src/api.c line 311
void rt_background_mode(void *voidscene, signed int mode);
// c::rt_background_sky_sphere
// file ../src/api.c line 292
void rt_background_sky_sphere(void *voidscene, struct anon$0 up, double topval, double botval, struct anon$4 topcol, struct anon$4 botcol);
// c::rt_barrier_sync
// file ../src/parallel.c line 67
void rt_barrier_sync(void);
// c::rt_boundmode
// file ../src/tachyon.h line 262
void rt_boundmode(void *voidscene, signed int mode);
// c::rt_boundthresh
// file ../src/tachyon.h line 274
void rt_boundthresh(void *voidscene, signed int threshold);
// c::rt_box
// file ../src/tachyon.h line 387
void rt_box(void *scene, void *tex, struct anon$0 min, struct anon$0 max);
// c::rt_camera_dof
// file ../src/tachyon.h line 312
void rt_camera_dof(void *voidscene, double focallength, double aperture);
// c::rt_camera_frustum
// file ../src/tachyon.h line 327
void rt_camera_frustum(void *voidscene, double left, double right, double bottom, double top);
// c::rt_camera_position
// file ../src/tachyon.h line 317
void rt_camera_position(void *voidscene, struct anon$0 camcent, struct anon$0 viewvec, struct anon$0 upvec);
// c::rt_camera_projection
// file ../src/tachyon.h line 307
void rt_camera_projection(void *voidscene, signed int mode);
// c::rt_camera_setup
// file ../src/tachyon.h line 301
void rt_camera_setup(void *voidscene, double zoom, double aspectratio, signed int antialiasing, signed int raydepth, struct anon$0 camcent, struct anon$0 viewvec, struct anon$0 upvec);
// c::rt_clip_dv
// file ../src/api.c line 1029
void rt_clip_dv(void *voidscene, signed int numplanes, double *planes);
// c::rt_clip_fv
// file ../src/tachyon.h line 433
void rt_clip_fv(void *voidscene, signed int numplanes, float *planes);
// c::rt_clip_off
// file ../src/tachyon.h line 435
void rt_clip_off(void *voidscene);
// c::rt_color
// file ../src/tachyon.h line 60
struct anon$4 rt_color(double r, double g, double b);
// c::rt_cond_broadcast
// file ../src/threads.c line 386
signed int rt_cond_broadcast(union anon$42 *cvp);
// c::rt_cond_destroy
// file ../src/threads.c line 271
signed int rt_cond_destroy(union anon$42 *cvp);
// c::rt_cond_init
// file ../src/threads.c line 235
signed int rt_cond_init(union anon$42 *cvp);
// c::rt_cond_signal
// file ../src/threads.c line 354
signed int rt_cond_signal(union anon$42 *cvp);
// c::rt_cond_wait
// file ../src/threads.c line 295
signed int rt_cond_wait(union anon$42 *cvp, union anon$40 *mp);
// c::rt_crop_disable
// file ../src/api.c line 206
void rt_crop_disable(void *voidscene);
// c::rt_crop_output
// file ../src/tachyon.h line 138
void rt_crop_output(void *voidscene, signed int hres, signed int vres, signed int sx, signed int sy);
// c::rt_cylinder
// file ../src/tachyon.h line 421
void rt_cylinder(void *scene, void *tex, struct anon$0 ctr, struct anon$0 axis, double rad);
// c::rt_define_image
// file ../src/tachyon.h line 347
void rt_define_image(const char *name, signed int xs, signed int ys, signed int zs, unsigned char *rgb);
// c::rt_delete_scanlinereceives
// file ../src/parallel.h line 22
void rt_delete_scanlinereceives(void *voidhandle);
// c::rt_deletescene
// file ../src/tachyon.h line 100
void rt_deletescene(void *voidscene);
// c::rt_directional_light
// file ../src/tachyon.h line 363
void * rt_directional_light(void *voidscene, void *tex, struct anon$0 dir);
// c::rt_extvol
// file ../src/api.c line 843
void rt_extvol(void *scene, void *tex, struct anon$0 min, struct anon$0 max, signed int samples, double (*evaluator)(double, double, double));
// c::rt_extvol::evaluator$object
// 
double evaluator$object(double, double, double);
// c::rt_fcylinder
// file ../src/tachyon.h line 423
void rt_fcylinder(void *scene, void *tex, struct anon$0 ctr, struct anon$0 axis, double rad);
// c::rt_finalize
// file ../src/tachyon.h line 85
void rt_finalize(void);
// c::rt_fog_mode
// file ../src/tachyon.h line 241
void rt_fog_mode(void *voidscene, signed int mode);
// c::rt_fog_parms
// file ../src/tachyon.h line 246
void rt_fog_parms(void *voidscene, struct anon$4 col, double start, double end, double density);
// c::rt_fog_rendering_mode
// file ../src/tachyon.h line 236
void rt_fog_rendering_mode(void *voidscene, signed int mode);
// c::rt_free_reqbuf
// file ../src/parallel.c line 160
void rt_free_reqbuf(void *voidhandle);
// c::rt_get_camera_position
// file ../src/api.c line 165
void rt_get_camera_position(void *voidscene, struct anon$0 *camcent, struct anon$0 *viewvec, struct anon$0 *upvec, struct anon$0 *rightvec);
// c::rt_get_resolution
// file ../src/tachyon.h line 131
void rt_get_resolution(void *voidscene, signed int *hres, signed int *vres);
// c::rt_getcpuinfo
// file ../src/parallel.h line 13
signed int rt_getcpuinfo(struct anon$13 **nodes);
// c::rt_hash_delete
// file ../src/hash.c line 173
signed int rt_hash_delete(struct rt_hash_t *tptr, const char *key);
// c::rt_hash_destroy
// file ../src/hash.h line 29
void rt_hash_destroy(struct rt_hash_t *tptr);
// c::rt_hash_init
// file ../src/hash.h line 25
void rt_hash_init(struct rt_hash_t *tptr, signed int buckets);
// c::rt_hash_insert
// file ../src/hash.h line 27
signed int rt_hash_insert(struct rt_hash_t *tptr, const char *key, signed int data);
// c::rt_hash_lookup
// file ../src/hash.h line 26
signed int rt_hash_lookup(struct rt_hash_t *tptr, const char *key);
// c::rt_hash_stats
// file ../src/hash.c line 260
char * rt_hash_stats(struct rt_hash_t *tptr);
// c::rt_heightfield
// file ../src/apigeom.c line 37
void rt_heightfield(void *scene, void *tex, struct anon$0 ctr, signed int m, signed int n, double *field, double wx, double wy);
// c::rt_image_clamp
// file ../src/tachyon.h line 168
void rt_image_clamp(void *voidscene);
// c::rt_image_gamma
// file ../src/tachyon.h line 180
void rt_image_gamma(void *voidscene, float gamma);
// c::rt_image_normalize
// file ../src/tachyon.h line 174
void rt_image_normalize(void *voidscene);
// c::rt_init_scanlinereceives
// file ../src/parallel.c line 179
void * rt_init_scanlinereceives(struct anon$39$link111 *scene);
// c::rt_initialize
// file ../src/tachyon.h line 75
signed int rt_initialize(signed int *argc, char ***argv);
// c::rt_landscape
// file ../src/tachyon.h line 416
void rt_landscape(void *scene, void *tex, signed int m, signed int n, struct anon$0 ctr, double wx, double wy);
// c::rt_light
// file ../src/tachyon.h line 359
void * rt_light(void *voidscene, void *tex, struct anon$0 ctr, double rad);
// c::rt_light_attenuation
// file ../src/tachyon.h line 371
void rt_light_attenuation(void *vli, double Kc, double Kl, double Kq);
// c::rt_mutex_destroy
// file ../src/threads.c line 212
signed int rt_mutex_destroy(union anon$40 *mp);
// c::rt_mutex_init
// file ../src/threads.c line 149
signed int rt_mutex_init(union anon$40 *mp);
// c::rt_mutex_lock
// file ../src/threads.c line 170
signed int rt_mutex_lock(union anon$40 *mp);
// c::rt_mutex_unlock
// file ../src/threads.c line 191
signed int rt_mutex_unlock(union anon$40 *mp);
// c::rt_mynode
// file ../src/parallel.h line 11
signed int rt_mynode(void);
// c::rt_newscene
// file ../src/tachyon.h line 92
void * rt_newscene(void);
// c::rt_normal_fixup_mode
// file ../src/tachyon.h line 162
void rt_normal_fixup_mode(void *voidscene, signed int mode);
// c::rt_numnodes
// file ../src/parallel.c line 57
signed int rt_numnodes(void);
// c::rt_outputfile
// file ../src/tachyon.h line 114
void rt_outputfile(void *voidscene, const char *outname);
// c::rt_outputformat
// file ../src/tachyon.h line 121
void rt_outputformat(void *voidscene, signed int format);
// c::rt_par_finish
// file ../src/parallel.h line 10
signed int rt_par_finish(void);
// c::rt_par_init
// file ../src/parallel.h line 9
signed int rt_par_init(signed int *argc, char ***argv);
// c::rt_phong_shader
// file ../src/tachyon.h line 292
void rt_phong_shader(void *voidscene, signed int mode);
// c::rt_plane
// file ../src/tachyon.h line 390
void rt_plane(void *scene, void *tex, struct anon$0 ctr, struct anon$0 norm);
// c::rt_polycylinder
// file ../src/tachyon.h line 425
void rt_polycylinder(void *scene, void *tex, struct anon$0 *points, signed int numpts, double rad);
// c::rt_quadsphere
// file ../src/api.c line 981
void rt_quadsphere(void *scene, void *tex, struct anon$0 ctr, double rad);
// c::rt_rand
// file ../src/util.h line 19
unsigned int rt_rand(unsigned int *idum);
// c::rt_rawimage_rgb24
// file ../src/api.c line 229
void rt_rawimage_rgb24(void *voidscene, unsigned char *img);
// c::rt_rawimage_rgb96f
// file ../src/api.c line 238
void rt_rawimage_rgb96f(void *voidscene, float *img);
// c::rt_renderscene
// file ../src/tachyon.h line 107
void rt_renderscene(void *voidscene);
// c::rt_rescale_lights
// file ../src/tachyon.h line 357
void rt_rescale_lights(void *voidscene, double lightscale);
// c::rt_resolution
// file ../src/tachyon.h line 130
void rt_resolution(void *voidscene, signed int hres, signed int vres);
// c::rt_ring
// file ../src/tachyon.h line 393
void rt_ring(void *scene, void *tex, struct anon$0 ctr, struct anon$0 norm, double a, double b);
// c::rt_rwlock_init
// file ../src/threads.c line 423
signed int rt_rwlock_init(struct rwlock_struct *rwp);
// c::rt_rwlock_readlock
// file ../src/threads.c line 443
signed int rt_rwlock_readlock(struct rwlock_struct *rwp);
// c::rt_rwlock_unlock
// file ../src/threads.c line 486
signed int rt_rwlock_unlock(struct rwlock_struct *rwp);
// c::rt_rwlock_writelock
// file ../src/threads.c line 463
signed int rt_rwlock_writelock(struct rwlock_struct *rwp);
// c::rt_scalarvol
// file ../src/tachyon.h line 382
void rt_scalarvol(void *scene, void *tex, struct anon$0 min, struct anon$0 max, signed int xs, signed int ys, signed int zs, const char *fname, struct anon$10 *invol);
// c::rt_sendrecvscanline
// file ../src/parallel.c line 285
void rt_sendrecvscanline(void *voidhandle);
// c::rt_set_numthreads
// file ../src/tachyon.h line 207
void rt_set_numthreads(void *voidscene, signed int numthreads);
// c::rt_set_ui_message
// file ../src/tachyon.h line 62
void rt_set_ui_message(void (*func)(signed int, char *));
// c::rt_set_ui_message::func$object
// 
void func$object(signed int, char *);
// c::rt_set_ui_progress
// file ../src/tachyon.h line 63
void rt_set_ui_progress(void (*func)(signed int));
// c::rt_set_ui_progress::func$object
// 
void func$object(signed int);
// c::rt_shadermode
// file ../src/tachyon.h line 284
void rt_shadermode(void *voidscene, signed int mode);
// c::rt_shared_iterator_destroy
// file ../src/threads.c line 790
signed int rt_shared_iterator_destroy(struct rt_shared_iterator_struct *it);
// c::rt_shared_iterator_getfatalerror
// file ../src/threads.c line 890
signed int rt_shared_iterator_getfatalerror(struct rt_shared_iterator_struct *it);
// c::rt_shared_iterator_init
// file ../src/threads.c line 780
signed int rt_shared_iterator_init(struct rt_shared_iterator_struct *it);
// c::rt_shared_iterator_next
// file ../src/threads.c line 815
signed int rt_shared_iterator_next(struct rt_shared_iterator_struct *it, signed int *current);
// c::rt_shared_iterator_next_block
// file ../src/threads.c line 841
signed int rt_shared_iterator_next_block(struct rt_shared_iterator_struct *it, signed int reqsize, signed int *start, signed int *end);
// c::rt_shared_iterator_set
// file ../src/threads.c line 799
signed int rt_shared_iterator_set(struct rt_shared_iterator_struct *it, signed int start, signed int end);
// c::rt_shared_iterator_setfatalerror
// file ../src/threads.c line 877
signed int rt_shared_iterator_setfatalerror(struct rt_shared_iterator_struct *it);
// c::rt_sheightfield
// file ../src/apigeom.c line 81
static void rt_sheightfield(void *scene, void *tex, struct anon$0 ctr, signed int m, signed int n, double *field, double wx, double wy);
// c::rt_sphere
// file ../src/tachyon.h line 379
void rt_sphere(void *scene, void *tex, struct anon$0 ctr, double rad);
// c::rt_spotlight
// file ../src/tachyon.h line 367
void * rt_spotlight(void *voidscene, void *tex, struct anon$0 ctr, double rad, struct anon$0 dir, double start, double end);
// c::rt_start_scanlinereceives
// file ../src/parallel.c line 245
void rt_start_scanlinereceives(void *voidhandle);
// c::rt_static_ui_checkaction$object
// 
signed int rt_static_ui_checkaction$object(void);
// c::rt_static_ui_message$object
// 
void rt_static_ui_message$object(signed int, char *);
// c::rt_static_ui_progress$object
// 
void rt_static_ui_progress$object(signed int);
// c::rt_stri
// file ../src/tachyon.h line 399
void rt_stri(void *voidscene, void *tex, struct anon$0 v0, struct anon$0 v1, struct anon$0 v2, struct anon$0 n0, struct anon$0 n1, struct anon$0 n2);
// c::rt_tex_outline
// file ../src/tachyon.h line 430
void rt_tex_outline(void *voidtex, double outline, double outlinewidth);
// c::rt_tex_phong
// file ../src/tachyon.h line 428
void rt_tex_phong(void *voidtex, double phong, double phongexp, signed int type);
// c::rt_texture
// file ../src/tachyon.h line 340
void * rt_texture(void *sc, struct anon$7 *apitex);
// c::rt_texture_copy_standard
// file ../src/api.c line 702
void * rt_texture_copy_standard(void *sc, void *oldtex);
// c::rt_texture_copy_vcstri
// file ../src/tachyon.h line 354
void * rt_texture_copy_vcstri(void *sc, void *oldtex);
// c::rt_thread_barrier
// file ../src/threads.c line 541
signed int rt_thread_barrier(struct barrier_struct *barrier, signed int increment);
// c::rt_thread_barrier_destroy
// file ../src/threads.c line 533
void rt_thread_barrier_destroy(struct barrier_struct *barrier);
// c::rt_thread_barrier_init
// file ../src/threads.c line 516
struct barrier_struct * rt_thread_barrier_init(signed int n_clients);
// c::rt_thread_create
// file ../src/threads.c line 84
signed int rt_thread_create(unsigned long int *thr, void * (*fctn)(void *), void *arg);
// c::rt_thread_create::fctn$object
// 
void * fctn$object(void *);
// c::rt_thread_join
// file ../src/threads.c line 122
signed int rt_thread_join(unsigned long int thr, void **stat);
// c::rt_thread_numprocessors
// file ../src/threads.h line 126
signed int rt_thread_numprocessors(void);
// c::rt_thread_run_barrier
// file ../src/threads.c line 603
void * (*rt_thread_run_barrier(struct rt_run_barrier_struct *barrier, void * (*fctn)(void *), void *parms, void **rsltparms))(void *);
// c::rt_thread_run_barrier::1::my_result$object
// 
void * my_result$object(void *);
// c::rt_thread_run_barrier::fctn$object
// 
void * fctn$object(void *);
// c::rt_thread_run_barrier_destroy
// file ../src/threads.c line 592
void rt_thread_run_barrier_destroy(struct rt_run_barrier_struct *barrier);
// c::rt_thread_run_barrier_init
// file ../src/threads.c line 576
signed int rt_thread_run_barrier_init(struct rt_run_barrier_struct *barrier, signed int n_clients);
// c::rt_thread_setconcurrency
// file ../src/threads.h line 127
signed int rt_thread_setconcurrency(signed int nthr);
// c::rt_threadpool_create
// file ../src/threads.c line 672
struct rt_threadpool_struct * rt_threadpool_create(signed int workercount);
// c::rt_threadpool_destroy
// file ../src/threads.c line 731
signed int rt_threadpool_destroy(struct rt_threadpool_struct *thrpool);
// c::rt_threadpool_launch
// file ../src/threads.c line 710
signed int rt_threadpool_launch(struct rt_threadpool_struct *thrpool, void * (*fctn)(void *), void *parms, signed int blocking);
// c::rt_threadpool_launch::fctn$object
// 
void * fctn$object(void *);
// c::rt_threadpool_wait
// file ../src/threads.c line 724
signed int rt_threadpool_wait(struct rt_threadpool_struct *thrpool);
// c::rt_threadpool_worker_getdata
// file ../src/threads.c line 770
signed int rt_threadpool_worker_getdata(void *voiddata, void **clientdata);
// c::rt_threadpool_worker_getid
// file ../src/threads.c line 757
signed int rt_threadpool_worker_getid(void *voiddata, signed int *threadid, signed int *threadcount);
// c::rt_threadpool_workerproc
// file ../src/threads.c line 654
static void * rt_threadpool_workerproc(void *voidparms);
// c::rt_threadpool_workerproc::1::fctn$object
// 
void * fctn$object(void *);
// c::rt_threadpool_workersync
// file ../src/threads.c line 667
static void * rt_threadpool_workersync(void *voidparms);
// c::rt_timer_create
// file ../src/util.h line 11
void * rt_timer_create(void);
// c::rt_timer_destroy
// file ../src/util.h line 12
void rt_timer_destroy(void *v);
// c::rt_timer_start
// file ../src/util.h line 13
void rt_timer_start(void *v);
// c::rt_timer_stop
// file ../src/util.h line 14
void rt_timer_stop(void *v);
// c::rt_timer_time
// file ../src/util.h line 15
double rt_timer_time(void *v);
// c::rt_timer_timenow
// file ../src/util.c line 223
double rt_timer_timenow(void *v);
// c::rt_trans_mode
// file ../src/tachyon.h line 252
void rt_trans_mode(void *voidscene, signed int mode);
// c::rt_tri
// file ../src/tachyon.h line 396
void rt_tri(void *voidscene, void *tex, struct anon$0 v0, struct anon$0 v1, struct anon$0 v2);
// c::rt_tristripscnv3fv
// file ../src/api.c line 903
void rt_tristripscnv3fv(void *voidscene, void *tex, signed int numverts, const float *cnv, signed int numstrips, signed int *vertsperstrip, signed int *facets);
// c::rt_ui_checkaction
// file ../src/ui.c line 35
signed int rt_ui_checkaction(void);
// c::rt_ui_message
// file ../src/ui.h line 17
void rt_ui_message(signed int level, char *msg);
// c::rt_ui_progress
// file ../src/ui.h line 18
void rt_ui_progress(signed int percent);
// c::rt_vcstri
// file ../src/tachyon.h line 403
void rt_vcstri(void *voidscene, void *tex, struct anon$0 v0, struct anon$0 v1, struct anon$0 v2, struct anon$0 n0, struct anon$0 n1, struct anon$0 n2, struct anon$4 c0, struct anon$4 c1, struct anon$4 c2);
// c::rt_vector
// file ../src/tachyon.h line 59
struct anon$0 rt_vector(double x, double y, double z);
// c::rt_verbose
// file ../src/tachyon.h line 154
void rt_verbose(void *voidscene, signed int v);
// c::rt_waitscanlines
// file ../src/parallel.c line 257
void rt_waitscanlines(void *voidhandle);
// c::scalar_volume_texture
// file ../src/vol.c line 139
struct anon$4 scalar_volume_texture(const struct anon$0 *hit, const struct anon$25 *tx, struct ray_t$link213 *ry);
// c::scalarvol_bbox
// file ../src/vol.c line 23
signed int scalarvol_bbox(void *obj, struct anon$0 *min, struct anon$0 *max);
// c::shade_ambient_occlusion
// file ../src/shade.c line 367
struct anon$4 shade_ambient_occlusion(struct ray_t$link1 *incident, const struct anon$19 *shadevars);
// c::shade_blinn
// file ../src/shade.h line 21
double shade_blinn(struct ray_t$link1 *incident, const struct anon$19 *shadevars, double specpower);
// c::shade_blinn_fast
// file ../src/shade.h line 22
double shade_blinn_fast(struct ray_t$link1 *incident, const struct anon$19 *shadevars, double specpower);
// c::shade_nullphong
// file ../src/shade.h line 20
double shade_nullphong(struct ray_t$link1 *incident, const struct anon$19 *shadevars, double specpower);
// c::shade_phong
// file ../src/shade.h line 19
double shade_phong(struct ray_t$link1 *incident, const struct anon$19 *shadevars, double specpower);
// c::shade_reflection
// file ../src/shade.c line 444
struct anon$4 shade_reflection(struct ray_t$link1 *incident, const struct anon$19 *shadevars, double specular);
// c::shade_transmission
// file ../src/shade.h line 15
struct anon$4 shade_transmission(struct ray_t$link1 *incident, const struct anon$19 *shadevars, double trans);
// c::shadow_intersection
// file ../src/intersect.c line 168
signed int shadow_intersection(struct ray_t$link0 *ry);
// c::simple_point_light_shade_diffuse
// file ../src/light.c line 152
static double simple_point_light_shade_diffuse(struct point_light_t$link242 *li, struct anon$19 *shadevars);
// c::sin
// file /usr/include/x86_64-linux-gnu/bits/mathcalls.h line 65
double sin(double);
// c::sky_sphere_background_texture
// file ../src/texture.h line 12
struct anon$4 sky_sphere_background_texture(struct ray_t$link234 *ry);
// c::snprintf
// file /usr/include/x86_64-linux-gnu/bits/stdio2.h line 61
signed int snprintf(char * restrict __s, unsigned long int __n, const char * restrict __fmt, ...);
// c::solid_background_texture
// file ../src/texture.h line 11
struct anon$4 solid_background_texture(struct ray_t$link234 *ry);
// c::sphere_bbox
// file ../src/sphere.c line 38
static signed int sphere_bbox(void *obj, struct anon$0 *min, struct anon$0 *max);
// c::sphere_intersect
// file ../src/sphere.c line 51
static void sphere_intersect(const struct anon$53 *spr, struct ray_t$link199 *ry);
// c::sphere_normal
// file ../src/sphere.c line 74
static void sphere_normal(const struct anon$53 *spr, const struct anon$0 *pnt, struct ray_t$link199 *incident, struct anon$0 *N);
// c::sprintf
// file /usr/include/x86_64-linux-gnu/bits/stdio2.h line 31
signed int sprintf(char * restrict __s, const char * restrict __fmt, ...);
// c::sqrt
// file /usr/include/x86_64-linux-gnu/bits/mathcalls.h line 157
double sqrt(double);
// c::sscanf
// file /usr/include/stdio.h line 433
signed int sscanf(const char *, const char *, ...);
// c::stat
// file /usr/include/x86_64-linux-gnu/sys/stat.h line 454
signed int stat(const char *__path, struct stat *__statbuf);
// c::stpncpy
// file /usr/include/x86_64-linux-gnu/bits/string3.h line 130
char * stpncpy(char *__dest, const char *__src, unsigned long int __n);
// c::strcat
// file /usr/include/x86_64-linux-gnu/bits/string3.h line 140
char * strcat(char * restrict __dest, const char * restrict __src);
// c::strcpy
// file /usr/include/x86_64-linux-gnu/bits/string3.h line 102
char * strcpy(char * restrict __dest, const char * restrict __src);
// c::stri_normal
// file ../src/triangle.c line 312
static void stri_normal(const struct anon$61 *trn, const struct anon$0 *hit, struct ray_t$link241 *incident, struct anon$0 *N);
// c::stri_normal_fixup
// file ../src/triangle.h line 9
void stri_normal_fixup(struct anon$15 *otri, signed int mode);
// c::stri_normal_guess
// file ../src/triangle.c line 419
static void stri_normal_guess(const struct anon$61 *trn, const struct anon$0 *hit, struct ray_t$link241 *incident, struct anon$0 *N);
// c::stri_normal_reverse
// file ../src/triangle.c line 379
static void stri_normal_reverse(const struct anon$61 *trn, const struct anon$0 *hit, struct ray_t$link241 *incident, struct anon$0 *N);
// c::stringcmp
// file ../demosrc/parse.c line 28
static signed int stringcmp(const char *a, const char *b);
// c::stringcmp$link93
// file ../demosrc/ac3dparse.c line 25
static signed int stringcmp$link93(char *a$link91, char *b$link92);
// c::strlen
// file /usr/include/string.h line 395
unsigned long int strlen(const char *);
// c::strncat
// file /usr/include/x86_64-linux-gnu/bits/string3.h line 147
char * strncat(char * restrict __dest, const char * restrict __src, unsigned long int __len);
// c::strncpy
// file /usr/include/x86_64-linux-gnu/bits/string3.h line 117
char * strncpy(char * restrict __dest, const char * restrict __src, unsigned long int __len);
// c::strstr
// file /usr/include/string.h line 338
char * strstr(const char *, const char *);
// c::strtod
// file /usr/include/stdlib.h line 164
double strtod(const char *, char **);
// c::strtol
// file /usr/include/stdlib.h line 183
signed long int strtol(const char *, char **, signed int);
// c::strtoll
// file /usr/include/stdlib.h line 209
signed long long int strtoll(const char *, char **, signed int);
// c::strupncmp
// file ../demosrc/getargs.c line 9
static signed int strupncmp(const char *a, const char *b, signed int n);
// c::subdivide
// file ../src/apigeom.c line 166
static void subdivide(double *base, signed int xres, signed int yres, double wx, double wy, signed int x1, signed int y1, signed int x2, signed int y2, unsigned int *rndval);
// c::sysconf
// file /usr/include/unistd.h line 619
signed long int sysconf(signed int);
// c::tachyon_display_create
// file ../demosrc/main.c line 65
static struct anon$3 * tachyon_display_create(void *scene);
// c::tachyon_display_delete
// file ../demosrc/main.c line 110
static void tachyon_display_delete(struct anon$3 *dh);
// c::tachyon_display_draw
// file ../demosrc/main.c line 98
static void tachyon_display_draw(struct anon$3 *dh);
// c::tb_project_to_sphere
// file ../demosrc/trackball.c line 219
static float tb_project_to_sphere(float r, float x, float y);
// c::tgamma
// file /usr/include/x86_64-linux-gnu/bits/math-finite.h line 428
double tgamma(double __d);
// c::tgammaf
// file /usr/include/x86_64-linux-gnu/bits/math-finite.h line 435
float tgammaf(float __d);
// c::tgammal
// file /usr/include/x86_64-linux-gnu/bits/math-finite.h line 443
long double tgammal(long double __d);
// c::thread_slave
// file ../src/render.c line 47
void * thread_slave(void *voidparms);
// c::thread_trace
// file ../src/trace.h line 23
void * thread_trace(struct anon$46$link123 *t);
// c::tlist_add_tri
// file ../demosrc/ac3dparse.c line 273
static void tlist_add_tri(struct tri_list_t **tlist, signed int v0, signed int v1, signed int v2, signed int smooth, signed int texnum);
// c::tlist_delete
// file ../demosrc/ac3dparse.c line 288
static void tlist_delete(struct tri_list_t **tlist);
// c::tolower
// file /usr/include/ctype.h line 216
signed int tolower(signed int __c);
// c::toupper
// file /usr/include/ctype.h line 222
signed int toupper(signed int __c);
// c::trace
// file ../src/trace.c line 21
struct anon$4 trace(struct ray_t$link119 *primary);
// c::trackball
// file ../demosrc/trackball.c line 160
void trackball(float *q, float p1x, float p1y, float p2x, float p2y);
// c::tri_bbox
// file ../src/triangle.c line 209
static signed int tri_bbox(void *obj, struct anon$0 *min, struct anon$0 *max);
// c::tri_intersect
// file ../src/triangle.c line 227
static void tri_intersect(const struct anon$60 *trn, struct ray_t$link241 *ry);
// c::tri_normal
// file ../demosrc/ac3dparse.c line 332
static struct anon$0 tri_normal(struct anon$0 *v0, struct anon$0 *v1, struct anon$0 *v2);
// c::tri_normal$link249
// file ../src/triangle.c line 293
static void tri_normal$link249(const struct anon$60 *trn, const struct anon$0 *hit, struct ray_t$link241 *incident, struct anon$0 *N);
// c::ttyname_r
// file /usr/include/x86_64-linux-gnu/bits/unistd.h line 291
signed int ttyname_r(signed int __fd, char *__buf, unsigned long int __buflen);
// c::vadd
// file ../demosrc/trackball.c line 140
void vadd(const float *src1, const float *src2, float *dst);
// c::vcopy
// file ../demosrc/trackball.c line 95
void vcopy(const float *v1, float *v2);
// c::vcross
// file ../demosrc/trackball.c line 103
void vcross(const float *v1, const float *v2, float *cross);
// c::vcstri_color
// file ../src/triangle.c line 351
struct anon$4 vcstri_color(const struct anon$0 *hit, const struct anon$25 *tx, struct ray_t$link241 *incident);
// c::vcstri_normal_fixup
// file ../src/triangle.h line 12
void vcstri_normal_fixup(struct anon$15 *otri, signed int mode);
// c::vdot
// file ../demosrc/trackball.c line 134
float vdot(const float *v1, const float *v2);
// c::vdprintf
// file /usr/include/x86_64-linux-gnu/bits/stdio2.h line 150
signed int vdprintf(signed int __fd, const char * restrict __fmt, void **__ap);
// c::vfprintf
// file /usr/include/x86_64-linux-gnu/bits/stdio2.h line 124
signed int vfprintf(struct _IO_FILE * restrict __stream, const char * restrict __fmt, void **__ap);
// c::vlength
// file ../demosrc/trackball.c line 114
float vlength(const float *v);
// c::vnormal
// file ../demosrc/trackball.c line 128
void vnormal(float *v);
// c::vprintf
// file /usr/include/x86_64-linux-gnu/bits/stdio2.h line 114
signed int vprintf(const char * restrict __fmt, void **__ap);
// c::vscale
// file ../demosrc/trackball.c line 120
void vscale(float *v, float div);
// c::vset
// file ../demosrc/trackball.c line 79
void vset(float *v, float x, float y, float z);
// c::vsnprintf
// file /usr/include/x86_64-linux-gnu/bits/stdio2.h line 74
signed int vsnprintf(char * restrict __s, unsigned long int __n, const char * restrict __fmt, void **__ap);
// c::vsprintf
// file /usr/include/x86_64-linux-gnu/bits/stdio2.h line 43
signed int vsprintf(char * restrict __s, const char * restrict __fmt, void **__ap);
// c::vsub
// file ../demosrc/trackball.c line 87
void vsub(const float *src1, const float *src2, float *dst);
// c::vzero
// file ../demosrc/trackball.c line 71
void vzero(float *v);
// c::wcstombs
// file /usr/include/x86_64-linux-gnu/bits/stdlib.h line 144
unsigned long int wcstombs(char * restrict __dst, const signed int * restrict __src, unsigned long int __len);
// c::wctomb
// file /usr/include/x86_64-linux-gnu/bits/stdlib.h line 83
signed int wctomb(char *__s, signed int __wchar);
// c::wood_texture
// file ../src/texture.h line 23
struct anon$4 wood_texture(const struct anon$0 *hit, const struct anon$25 *tx, struct ray_t$link234 *ry);
// c::write_le_int16
// file ../src/winbmp.c line 22
static void write_le_int16(struct _IO_FILE$link44 *dfile, signed int num);
// c::write_le_int32
// file ../src/winbmp.c line 15
static void write_le_int32(struct _IO_FILE$link44 *dfile, signed int num);
// c::writebmp
// file ../src/winbmp.h line 8
signed int writebmp(char *filename, signed int xs, signed int ys, unsigned char *img);
// c::writeimage
// file ../src/imageio.h line 19
signed int writeimage(char *name, signed int xres, signed int yres, void *img, signed int imgbufferformat, signed int fileformat);
// c::writejpeg
// file ../src/jpeg.h line 8
signed int writejpeg(char *name, signed int xres, signed int yres, unsigned char *imgdata);
// c::writepng
// file ../src/pngfile.h line 8
signed int writepng(char *name, signed int xres, signed int yres, unsigned char *imgdata);
// c::writeppm
// file ../src/ppm.h line 12
signed int writeppm(char *name, signed int xres, signed int yres, unsigned char *imgdata);
// c::writeppm48
// file ../src/ppm.h line 13
signed int writeppm48(char *name, signed int xres, signed int yres, unsigned char *imgdata);
// c::writepsd48
// file ../src/psd.h line 7
signed int writepsd48(char *name, signed int xres, signed int yres, unsigned char *imgdata);
// c::writergb
// file ../src/sgirgb.h line 7
signed int writergb(char *name, signed int xres, signed int yres, unsigned char *imgdata);
// c::writetga
// file ../src/tgafile.h line 13
signed int writetga(char *name, signed int xres, signed int yres, unsigned char *imgdata);
// c::writetgaregion
// file ../src/tgafile.c line 88
void writetgaregion(void *voidhandle, signed int startx, signed int starty, signed int stopx, signed int stopy, unsigned char *buffer);
// c::xytopolar
// file ../src/coordsys.c line 11
void xytopolar(double x, double y, double rad, double *u, double *v);
// c::xyztocyl
// file ../src/coordsys.h line 8
void xyztocyl(struct anon$0 pnt, double height, double *u, double *v);
// c::xyztospr
// file ../src/coordsys.h line 9
void xyztospr(struct anon$0 pnt, double *u, double *v);

union anon$9
{
  // __l
  long double __l;
  // __i
  signed int __i[3l];
};

union anon$9$link224
{
  // __l
  long double __l;
  // __i
  signed int __i[3l];
};

union anon$9$link229
{
  // __l
  long double __l;
  // __i
  signed int __i[3l];
};

union anon$9$link233
{
  // __l
  long double __l;
  // __i
  signed int __i[3l];
};

union anon$9$link237
{
  // __l
  long double __l;
  // __i
  signed int __i[3l];
};

union anon$9$link243
{
  // __l
  long double __l;
  // __i
  signed int __i[3l];
};

union anon$9$link252
{
  // __l
  long double __l;
  // __i
  signed int __i[3l];
};

union anon$9$link253
{
  // __l
  long double __l;
  // __i
  signed int __i[3l];
};

union anon$9$link254
{
  // __l
  long double __l;
  // __i
  signed int __i[3l];
};

union anon$9$link255
{
  // __l
  long double __l;
  // __i
  signed int __i[3l];
};

union anon$9$link256
{
  // __l
  long double __l;
  // __i
  signed int __i[3l];
};

union anon$9$link260
{
  // __l
  long double __l;
  // __i
  signed int __i[3l];
};

union anon$9$link261
{
  // __l
  long double __l;
  // __i
  signed int __i[3l];
};

union anon$9$link262
{
  // __l
  long double __l;
  // __i
  signed int __i[3l];
};

union anon$9$link263
{
  // __l
  long double __l;
  // __i
  signed int __i[3l];
};

union anon$9$link266
{
  // __l
  long double __l;
  // __i
  signed int __i[3l];
};

union anon$9$link268
{
  // __l
  long double __l;
  // __i
  signed int __i[3l];
};

union anon$9$link273
{
  // __l
  long double __l;
  // __i
  signed int __i[3l];
};

union anon$9$link276
{
  // __l
  long double __l;
  // __i
  signed int __i[3l];
};

union anon$9$link279
{
  // __l
  long double __l;
  // __i
  signed int __i[3l];
};

union anon$9$link280
{
  // __l
  long double __l;
  // __i
  signed int __i[3l];
};

union anon$9$link282
{
  // __l
  long double __l;
  // __i
  signed int __i[3l];
};

union anon$9$link286
{
  // __l
  long double __l;
  // __i
  signed int __i[3l];
};

union anon$9$link287
{
  // __l
  long double __l;
  // __i
  signed int __i[3l];
};

union anon$9$link290
{
  // __l
  long double __l;
  // __i
  signed int __i[3l];
};

union anon$9$link291
{
  // __l
  long double __l;
  // __i
  signed int __i[3l];
};

union anon$9$link292
{
  // __l
  long double __l;
  // __i
  signed int __i[3l];
};

union anon$9$link294
{
  // __l
  long double __l;
  // __i
  signed int __i[3l];
};

union anon$9$link296
{
  // __l
  long double __l;
  // __i
  signed int __i[3l];
};

union anon$9$link298
{
  // __l
  long double __l;
  // __i
  signed int __i[3l];
};

union anon$9$link299
{
  // __l
  long double __l;
  // __i
  signed int __i[3l];
};

union anon$9$link301
{
  // __l
  long double __l;
  // __i
  signed int __i[3l];
};

union anon$9$link302
{
  // __l
  long double __l;
  // __i
  signed int __i[3l];
};

union anon$9$link303
{
  // __l
  long double __l;
  // __i
  signed int __i[3l];
};

union anon$9$link304
{
  // __l
  long double __l;
  // __i
  signed int __i[3l];
};

union anon$9$link305
{
  // __l
  long double __l;
  // __i
  signed int __i[3l];
};

union anon$9$link306
{
  // __l
  long double __l;
  // __i
  signed int __i[3l];
};

union anon$9$link5
{
  // __l
  long double __l;
  // __i
  signed int __i[3l];
};

struct anon$1
{
  // filenames
  char **filenames;
  // numfiles
  signed int numfiles;
  // useoutfilename
  signed int useoutfilename;
  // outfilename
  char outfilename[4096l];
  // outimageformat
  signed int outimageformat;
  // verbosemode
  signed int verbosemode;
  // aa_maxsamples
  signed int aa_maxsamples;
  // boundmode
  signed int boundmode;
  // boundthresh
  signed int boundthresh;
  // usecamfile
  signed int usecamfile;
  // camfilename
  char camfilename[4096l];
  // shadermode
  signed int shadermode;
  // phongfunc
  signed int phongfunc;
  // transmode
  signed int transmode;
  // fogmode
  signed int fogmode;
  // numthreads
  signed int numthreads;
  // nosave
  signed int nosave;
  // xsize
  signed int xsize;
  // ysize
  signed int ysize;
  // normalfixupmode
  signed int normalfixupmode;
  // imgprocess
  signed int imgprocess;
  // imggamma
  float imggamma;
  // rescale_lights
  float rescale_lights;
  // auto_skylight
  float auto_skylight;
  // add_skylight
  float add_skylight;
  // skylight_samples
  signed int skylight_samples;
  // spaceball
  char spaceball[4096l];
  // cropmode
  signed int cropmode;
  // cropxres
  signed int cropxres;
  // cropyres
  signed int cropyres;
  // cropxstart
  signed int cropxstart;
  // cropystart
  signed int cropystart;
};

struct anon$24
{
  // freetex
  void (*freetex)(void *);
};

struct anon$23
{
  // intersect
  void (*intersect)(const void *, void *);
  // normal
  void (*normal)(const void *, const void *, const void *, void *);
  // bbox
  signed int (*bbox)(void *, struct anon$0 *, struct anon$0 *);
  // freeobj
  void (*freeobj)(void *);
};

struct anon$25
{
  // texfunc
  struct anon$4 (*texfunc)(const void *, const void *, void *);
  // methods
  struct anon$24 *methods;
  // flags
  unsigned int flags;
  // ambient
  float ambient;
  // diffuse
  float diffuse;
  // phong
  float phong;
  // phongexp
  float phongexp;
  // phongtype
  signed int phongtype;
  // specular
  float specular;
  // opacity
  float opacity;
  // outline
  float outline;
  // outlinewidth
  float outlinewidth;
};

struct anon$4
{
  // r
  float r;
  // g
  float g;
  // b
  float b;
};

struct anon$36
{
  // texfunc
  struct anon$4 (*texfunc)(const void *, const void *, void *);
  // methods
  struct anon$24 *methods;
  // flags
  unsigned int flags;
  // ambient
  float ambient;
  // diffuse
  float diffuse;
  // phong
  float phong;
  // phongexp
  float phongexp;
  // phongtype
  signed int phongtype;
  // specular
  float specular;
  // opacity
  float opacity;
  // outline
  float outline;
  // outlinewidth
  float outlinewidth;
  // obj
  void *obj;
  // c0
  struct anon$4 c0;
  // c1
  struct anon$4 c1;
  // c2
  struct anon$4 c2;
};

struct anon$0
{
  // x
  double x;
  // y
  double y;
  // z
  double z;
};

struct anon$35
{
  // texfunc
  struct anon$4 (*texfunc)(const void *, const void *, void *);
  // methods
  struct anon$24 *methods;
  // flags
  unsigned int flags;
  // ambient
  float ambient;
  // diffuse
  float diffuse;
  // phong
  float phong;
  // phongexp
  float phongexp;
  // phongtype
  signed int phongtype;
  // specular
  float specular;
  // opacity
  float opacity;
  // outline
  float outline;
  // outlinewidth
  float outlinewidth;
  // col
  struct anon$4 col;
  // ctr
  struct anon$0 ctr;
  // rot
  struct anon$0 rot;
  // scale
  struct anon$0 scale;
  // uaxs
  struct anon$0 uaxs;
  // vaxs
  struct anon$0 vaxs;
  // waxs
  struct anon$0 waxs;
  // img
  void *img;
  // obj
  void *obj;
};

struct anon$5
{
  // name
  char *name;
  // tex
  void *tex;
};

struct anon$21
{
  // boundedobj
  struct anon$15 *boundedobj;
  // unboundedobj
  struct anon$15 *unboundedobj;
  // numobjects
  signed int numobjects;
};

struct rt_hash_t
{
  // bucket
  struct hash_node_t **bucket;
  // size
  signed int size;
  // entries
  signed int entries;
  // downshift
  signed int downshift;
  // mask
  signed int mask;
};

struct anon$6
{
  // ifp
  struct _IO_FILE$link13 *ifp;
  // filename
  const char *filename;
  // textable
  struct anon$5 *textable;
  // defaulttex
  struct anon$5 defaulttex;
  // numtextures
  signed int numtextures;
  // maxtextures
  signed int maxtextures;
  // numobjectsparsed
  signed int numobjectsparsed;
  // texhash
  struct rt_hash_t texhash;
};

struct anon$37
{
  // obj
  const struct anon$15 *obj;
  // t
  double t;
};

struct anon$11
{
  // name
  char name[24l];
  // tex
  void *tex;
};

struct anon$12
{
  // cropmode
  signed int cropmode;
  // xres
  signed int xres;
  // yres
  signed int yres;
  // xstart
  signed int xstart;
  // ystart
  signed int ystart;
};

struct anon$14
{
  // projection
  signed int projection;
  // center
  struct anon$0 center;
  // viewvec
  struct anon$0 viewvec;
  // rightvec
  struct anon$0 rightvec;
  // upvec
  struct anon$0 upvec;
  // camzoom
  double camzoom;
  // px
  double px;
  // py
  double py;
  // psx
  double psx;
  // psy
  double psy;
  // focallength
  double focallength;
  // left
  double left;
  // right
  double right;
  // top
  double top;
  // bottom
  double bottom;
  // aperture
  double aperture;
  // projcent
  struct anon$0 projcent;
  // cam_ray
  struct anon$4 (*cam_ray)(void *, double, double);
  // lowleft
  struct anon$0 lowleft;
  // iplaneright
  struct anon$0 iplaneright;
  // iplaneup
  struct anon$0 iplaneup;
};

struct anon$20
{
  // background
  struct anon$4 background;
  // gradient
  struct anon$0 gradient;
  // gradtopval
  double gradtopval;
  // gradbotval
  double gradbotval;
  // backgroundtop
  struct anon$4 backgroundtop;
  // backgroundbot
  struct anon$4 backgroundbot;
};

struct fogdata_t
{
  // fog_fctn
  struct anon$4 (*fog_fctn)(struct fogdata_t *, struct anon$4, double);
  // type
  signed int type;
  // col
  struct anon$4 col;
  // start
  double start;
  // end
  double end;
  // density
  double density;
};

struct amboccdata_t
{
  // numsamples
  signed int numsamples;
  // col
  struct anon$4 col;
};

struct anon$17
{
  // outfilename
  char outfilename[256l];
  // writeimagefile
  signed int writeimagefile;
  // img
  void *img;
  // imginternal
  signed int imginternal;
  // imgprocess
  signed int imgprocess;
  // imggamma
  float imggamma;
  // imgbufformat
  signed int imgbufformat;
  // imgfileformat
  signed int imgfileformat;
  // imgcrop
  struct anon$12 imgcrop;
  // numthreads
  signed int numthreads;
  // nodes
  signed int nodes;
  // mynode
  signed int mynode;
  // cpuinfo
  struct anon$13 *cpuinfo;
  // hres
  signed int hres;
  // vres
  signed int vres;
  // aspectratio
  double aspectratio;
  // raydepth
  signed int raydepth;
  // antialiasing
  signed int antialiasing;
  // verbosemode
  signed int verbosemode;
  // boundmode
  signed int boundmode;
  // boundthresh
  signed int boundthresh;
  // texlist
  struct list *texlist;
  // cliplist
  struct list *cliplist;
  // flags
  unsigned int flags;
  // camera
  struct anon$14 camera;
  // shader
  struct anon$4 (*shader)(void *);
  // phongfunc
  double (*phongfunc)(const struct ray_t *incident, const struct anon$19 *shadevars, double specpower);
  // transmode
  signed int transmode;
  // bgtex
  struct anon$20 bgtex;
  // bgtexfunc
  struct anon$4 (*bgtexfunc)(const struct ray_t *incident);
  // fog
  struct fogdata_t fog;
  // objgroup
  struct anon$21 objgroup;
  // lightlist
  struct list *lightlist;
  // light_scale
  double light_scale;
  // numlights
  signed int numlights;
  // ambocc
  struct amboccdata_t ambocc;
  // scenecheck
  signed int scenecheck;
  // parbuf
  void *parbuf;
  // threads
  void *threads;
  // threadparms
  void *threadparms;
  // curclipgroup
  struct anon$22 *curclipgroup;
  // normalfixupmode
  signed int normalfixupmode;
};

struct fogdata_t$link109
{
  // fog_fctn
  struct anon$4 (*fog_fctn)(struct fogdata_t$link109 *, struct anon$4, double);
  // type
  signed int type;
  // col
  struct anon$4 col;
  // start
  double start;
  // end
  double end;
  // density
  double density;
};

struct anon$30$link108
{
  // outfilename
  char outfilename[256l];
  // writeimagefile
  signed int writeimagefile;
  // img
  void *img;
  // imginternal
  signed int imginternal;
  // imgprocess
  signed int imgprocess;
  // imggamma
  float imggamma;
  // imgbufformat
  signed int imgbufformat;
  // imgfileformat
  signed int imgfileformat;
  // imgcrop
  struct anon$12 imgcrop;
  // numthreads
  signed int numthreads;
  // nodes
  signed int nodes;
  // mynode
  signed int mynode;
  // cpuinfo
  struct anon$13 *cpuinfo;
  // hres
  signed int hres;
  // vres
  signed int vres;
  // aspectratio
  double aspectratio;
  // raydepth
  signed int raydepth;
  // antialiasing
  signed int antialiasing;
  // verbosemode
  signed int verbosemode;
  // boundmode
  signed int boundmode;
  // boundthresh
  signed int boundthresh;
  // texlist
  struct list$link110 *texlist;
  // cliplist
  struct list$link110 *cliplist;
  // flags
  unsigned int flags;
  // camera
  struct anon$14 camera;
  // shader
  struct anon$4 (*shader)(void *);
  // phongfunc
  double (*phongfunc)(struct ray_t$link107 *incident, const struct anon$19 *shadevars, double specpower);
  // transmode
  signed int transmode;
  // bgtex
  struct anon$20 bgtex;
  // bgtexfunc
  struct anon$4 (*bgtexfunc)(struct ray_t$link107 *incident);
  // fog
  struct fogdata_t$link109 fog;
  // objgroup
  struct anon$21 objgroup;
  // lightlist
  struct list$link110 *lightlist;
  // light_scale
  double light_scale;
  // numlights
  signed int numlights;
  // ambocc
  struct amboccdata_t ambocc;
  // scenecheck
  signed int scenecheck;
  // parbuf
  void *parbuf;
  // threads
  void *threads;
  // threadparms
  void *threadparms;
  // curclipgroup
  struct anon$22 *curclipgroup;
  // normalfixupmode
  signed int normalfixupmode;
};

struct fogdata_t$link112
{
  // fog_fctn
  struct anon$4 (*fog_fctn)(struct fogdata_t$link112 *, struct anon$4, double);
  // type
  signed int type;
  // col
  struct anon$4 col;
  // start
  double start;
  // end
  double end;
  // density
  double density;
};

struct anon$39$link111
{
  // outfilename
  char outfilename[256l];
  // writeimagefile
  signed int writeimagefile;
  // img
  void *img;
  // imginternal
  signed int imginternal;
  // imgprocess
  signed int imgprocess;
  // imggamma
  float imggamma;
  // imgbufformat
  signed int imgbufformat;
  // imgfileformat
  signed int imgfileformat;
  // imgcrop
  struct anon$12 imgcrop;
  // numthreads
  signed int numthreads;
  // nodes
  signed int nodes;
  // mynode
  signed int mynode;
  // cpuinfo
  struct anon$13 *cpuinfo;
  // hres
  signed int hres;
  // vres
  signed int vres;
  // aspectratio
  double aspectratio;
  // raydepth
  signed int raydepth;
  // antialiasing
  signed int antialiasing;
  // verbosemode
  signed int verbosemode;
  // boundmode
  signed int boundmode;
  // boundthresh
  signed int boundthresh;
  // texlist
  struct list$link113 *texlist;
  // cliplist
  struct list$link113 *cliplist;
  // flags
  unsigned int flags;
  // camera
  struct anon$14 camera;
  // shader
  struct anon$4 (*shader)(void *);
  // phongfunc
  double (*phongfunc)(struct ray_t$link110 *incident, const struct anon$19 *shadevars, double specpower);
  // transmode
  signed int transmode;
  // bgtex
  struct anon$20 bgtex;
  // bgtexfunc
  struct anon$4 (*bgtexfunc)(struct ray_t$link110 *incident);
  // fog
  struct fogdata_t$link112 fog;
  // objgroup
  struct anon$21 objgroup;
  // lightlist
  struct list$link113 *lightlist;
  // light_scale
  double light_scale;
  // numlights
  signed int numlights;
  // ambocc
  struct amboccdata_t ambocc;
  // scenecheck
  signed int scenecheck;
  // parbuf
  void *parbuf;
  // threads
  void *threads;
  // threadparms
  void *threadparms;
  // curclipgroup
  struct anon$22 *curclipgroup;
  // normalfixupmode
  signed int normalfixupmode;
};

struct fogdata_t$link110
{
  // fog_fctn
  struct anon$4 (*fog_fctn)(struct fogdata_t$link110 *, struct anon$4, double);
  // type
  signed int type;
  // col
  struct anon$4 col;
  // start
  double start;
  // end
  double end;
  // density
  double density;
};

struct anon$59$link112
{
  // outfilename
  char outfilename[256l];
  // writeimagefile
  signed int writeimagefile;
  // img
  void *img;
  // imginternal
  signed int imginternal;
  // imgprocess
  signed int imgprocess;
  // imggamma
  float imggamma;
  // imgbufformat
  signed int imgbufformat;
  // imgfileformat
  signed int imgfileformat;
  // imgcrop
  struct anon$12 imgcrop;
  // numthreads
  signed int numthreads;
  // nodes
  signed int nodes;
  // mynode
  signed int mynode;
  // cpuinfo
  struct anon$13 *cpuinfo;
  // hres
  signed int hres;
  // vres
  signed int vres;
  // aspectratio
  double aspectratio;
  // raydepth
  signed int raydepth;
  // antialiasing
  signed int antialiasing;
  // verbosemode
  signed int verbosemode;
  // boundmode
  signed int boundmode;
  // boundthresh
  signed int boundthresh;
  // texlist
  struct list$link111 *texlist;
  // cliplist
  struct list$link111 *cliplist;
  // flags
  unsigned int flags;
  // camera
  struct anon$14 camera;
  // shader
  struct anon$4 (*shader)(void *);
  // phongfunc
  double (*phongfunc)(struct ray_t$link108 *incident, const struct anon$19 *shadevars, double specpower);
  // transmode
  signed int transmode;
  // bgtex
  struct anon$20 bgtex;
  // bgtexfunc
  struct anon$4 (*bgtexfunc)(struct ray_t$link108 *incident);
  // fog
  struct fogdata_t$link110 fog;
  // objgroup
  struct anon$21 objgroup;
  // lightlist
  struct list$link111 *lightlist;
  // light_scale
  double light_scale;
  // numlights
  signed int numlights;
  // ambocc
  struct amboccdata_t ambocc;
  // scenecheck
  signed int scenecheck;
  // parbuf
  void *parbuf;
  // threads
  void *threads;
  // threadparms
  void *threadparms;
  // curclipgroup
  struct anon$22 *curclipgroup;
  // normalfixupmode
  signed int normalfixupmode;
};

struct fogdata_t$link121
{
  // fog_fctn
  struct anon$4 (*fog_fctn)(struct fogdata_t$link121 *, struct anon$4, double);
  // type
  signed int type;
  // col
  struct anon$4 col;
  // start
  double start;
  // end
  double end;
  // density
  double density;
};

struct anon$48$link120
{
  // outfilename
  char outfilename[256l];
  // writeimagefile
  signed int writeimagefile;
  // img
  void *img;
  // imginternal
  signed int imginternal;
  // imgprocess
  signed int imgprocess;
  // imggamma
  float imggamma;
  // imgbufformat
  signed int imgbufformat;
  // imgfileformat
  signed int imgfileformat;
  // imgcrop
  struct anon$12 imgcrop;
  // numthreads
  signed int numthreads;
  // nodes
  signed int nodes;
  // mynode
  signed int mynode;
  // cpuinfo
  struct anon$13 *cpuinfo;
  // hres
  signed int hres;
  // vres
  signed int vres;
  // aspectratio
  double aspectratio;
  // raydepth
  signed int raydepth;
  // antialiasing
  signed int antialiasing;
  // verbosemode
  signed int verbosemode;
  // boundmode
  signed int boundmode;
  // boundthresh
  signed int boundthresh;
  // texlist
  struct list$link122 *texlist;
  // cliplist
  struct list$link122 *cliplist;
  // flags
  unsigned int flags;
  // camera
  struct anon$14 camera;
  // shader
  struct anon$4 (*shader)(void *);
  // phongfunc
  double (*phongfunc)(struct ray_t$link119 *incident, const struct anon$19 *shadevars, double specpower);
  // transmode
  signed int transmode;
  // bgtex
  struct anon$20 bgtex;
  // bgtexfunc
  struct anon$4 (*bgtexfunc)(struct ray_t$link119 *incident);
  // fog
  struct fogdata_t$link121 fog;
  // objgroup
  struct anon$21 objgroup;
  // lightlist
  struct list$link122 *lightlist;
  // light_scale
  double light_scale;
  // numlights
  signed int numlights;
  // ambocc
  struct amboccdata_t ambocc;
  // scenecheck
  signed int scenecheck;
  // parbuf
  void *parbuf;
  // threads
  void *threads;
  // threadparms
  void *threadparms;
  // curclipgroup
  struct anon$22 *curclipgroup;
  // normalfixupmode
  signed int normalfixupmode;
};

struct fogdata_t$link132
{
  // fog_fctn
  struct anon$4 (*fog_fctn)(struct fogdata_t$link132 *, struct anon$4, double);
  // type
  signed int type;
  // col
  struct anon$4 col;
  // start
  double start;
  // end
  double end;
  // density
  double density;
};

struct anon$70$link134
{
  // outfilename
  char outfilename[256l];
  // writeimagefile
  signed int writeimagefile;
  // img
  void *img;
  // imginternal
  signed int imginternal;
  // imgprocess
  signed int imgprocess;
  // imggamma
  float imggamma;
  // imgbufformat
  signed int imgbufformat;
  // imgfileformat
  signed int imgfileformat;
  // imgcrop
  struct anon$12 imgcrop;
  // numthreads
  signed int numthreads;
  // nodes
  signed int nodes;
  // mynode
  signed int mynode;
  // cpuinfo
  struct anon$13 *cpuinfo;
  // hres
  signed int hres;
  // vres
  signed int vres;
  // aspectratio
  double aspectratio;
  // raydepth
  signed int raydepth;
  // antialiasing
  signed int antialiasing;
  // verbosemode
  signed int verbosemode;
  // boundmode
  signed int boundmode;
  // boundthresh
  signed int boundthresh;
  // texlist
  struct list$link133 *texlist;
  // cliplist
  struct list$link133 *cliplist;
  // flags
  unsigned int flags;
  // camera
  struct anon$14 camera;
  // shader
  struct anon$4 (*shader)(void *);
  // phongfunc
  double (*phongfunc)(struct ray_t$link130 *incident, const struct anon$19 *shadevars, double specpower);
  // transmode
  signed int transmode;
  // bgtex
  struct anon$20 bgtex;
  // bgtexfunc
  struct anon$4 (*bgtexfunc)(struct ray_t$link130 *incident);
  // fog
  struct fogdata_t$link132 fog;
  // objgroup
  struct anon$21 objgroup;
  // lightlist
  struct list$link133 *lightlist;
  // light_scale
  double light_scale;
  // numlights
  signed int numlights;
  // ambocc
  struct amboccdata_t ambocc;
  // scenecheck
  signed int scenecheck;
  // parbuf
  void *parbuf;
  // threads
  void *threads;
  // threadparms
  void *threadparms;
  // curclipgroup
  struct anon$22 *curclipgroup;
  // normalfixupmode
  signed int normalfixupmode;
};

struct fogdata_t$link164
{
  // fog_fctn
  struct anon$4 (*fog_fctn)(struct fogdata_t$link164 *, struct anon$4, double);
  // type
  signed int type;
  // col
  struct anon$4 col;
  // start
  double start;
  // end
  double end;
  // density
  double density;
};

struct anon$65$link166
{
  // outfilename
  char outfilename[256l];
  // writeimagefile
  signed int writeimagefile;
  // img
  void *img;
  // imginternal
  signed int imginternal;
  // imgprocess
  signed int imgprocess;
  // imggamma
  float imggamma;
  // imgbufformat
  signed int imgbufformat;
  // imgfileformat
  signed int imgfileformat;
  // imgcrop
  struct anon$12 imgcrop;
  // numthreads
  signed int numthreads;
  // nodes
  signed int nodes;
  // mynode
  signed int mynode;
  // cpuinfo
  struct anon$13 *cpuinfo;
  // hres
  signed int hres;
  // vres
  signed int vres;
  // aspectratio
  double aspectratio;
  // raydepth
  signed int raydepth;
  // antialiasing
  signed int antialiasing;
  // verbosemode
  signed int verbosemode;
  // boundmode
  signed int boundmode;
  // boundthresh
  signed int boundthresh;
  // texlist
  struct list$link165 *texlist;
  // cliplist
  struct list$link165 *cliplist;
  // flags
  unsigned int flags;
  // camera
  struct anon$14 camera;
  // shader
  struct anon$4 (*shader)(void *);
  // phongfunc
  double (*phongfunc)(struct ray_t$link162 *incident, const struct anon$19 *shadevars, double specpower);
  // transmode
  signed int transmode;
  // bgtex
  struct anon$20 bgtex;
  // bgtexfunc
  struct anon$4 (*bgtexfunc)(struct ray_t$link162 *incident);
  // fog
  struct fogdata_t$link164 fog;
  // objgroup
  struct anon$21 objgroup;
  // lightlist
  struct list$link165 *lightlist;
  // light_scale
  double light_scale;
  // numlights
  signed int numlights;
  // ambocc
  struct amboccdata_t ambocc;
  // scenecheck
  signed int scenecheck;
  // parbuf
  void *parbuf;
  // threads
  void *threads;
  // threadparms
  void *threadparms;
  // curclipgroup
  struct anon$22 *curclipgroup;
  // normalfixupmode
  signed int normalfixupmode;
};

struct fogdata_t$link201
{
  // fog_fctn
  struct anon$4 (*fog_fctn)(struct fogdata_t$link201 *, struct anon$4, double);
  // type
  signed int type;
  // col
  struct anon$4 col;
  // start
  double start;
  // end
  double end;
  // density
  double density;
};

struct anon$54$link203
{
  // outfilename
  char outfilename[256l];
  // writeimagefile
  signed int writeimagefile;
  // img
  void *img;
  // imginternal
  signed int imginternal;
  // imgprocess
  signed int imgprocess;
  // imggamma
  float imggamma;
  // imgbufformat
  signed int imgbufformat;
  // imgfileformat
  signed int imgfileformat;
  // imgcrop
  struct anon$12 imgcrop;
  // numthreads
  signed int numthreads;
  // nodes
  signed int nodes;
  // mynode
  signed int mynode;
  // cpuinfo
  struct anon$13 *cpuinfo;
  // hres
  signed int hres;
  // vres
  signed int vres;
  // aspectratio
  double aspectratio;
  // raydepth
  signed int raydepth;
  // antialiasing
  signed int antialiasing;
  // verbosemode
  signed int verbosemode;
  // boundmode
  signed int boundmode;
  // boundthresh
  signed int boundthresh;
  // texlist
  struct list$link202 *texlist;
  // cliplist
  struct list$link202 *cliplist;
  // flags
  unsigned int flags;
  // camera
  struct anon$14 camera;
  // shader
  struct anon$4 (*shader)(void *);
  // phongfunc
  double (*phongfunc)(struct ray_t$link199 *incident, const struct anon$19 *shadevars, double specpower);
  // transmode
  signed int transmode;
  // bgtex
  struct anon$20 bgtex;
  // bgtexfunc
  struct anon$4 (*bgtexfunc)(struct ray_t$link199 *incident);
  // fog
  struct fogdata_t$link201 fog;
  // objgroup
  struct anon$21 objgroup;
  // lightlist
  struct list$link202 *lightlist;
  // light_scale
  double light_scale;
  // numlights
  signed int numlights;
  // ambocc
  struct amboccdata_t ambocc;
  // scenecheck
  signed int scenecheck;
  // parbuf
  void *parbuf;
  // threads
  void *threads;
  // threadparms
  void *threadparms;
  // curclipgroup
  struct anon$22 *curclipgroup;
  // normalfixupmode
  signed int normalfixupmode;
};

struct fogdata_t$link212
{
  // fog_fctn
  struct anon$4 (*fog_fctn)(struct fogdata_t$link212 *, struct anon$4, double);
  // type
  signed int type;
  // col
  struct anon$4 col;
  // start
  double start;
  // end
  double end;
  // density
  double density;
};

struct anon$31$link211
{
  // outfilename
  char outfilename[256l];
  // writeimagefile
  signed int writeimagefile;
  // img
  void *img;
  // imginternal
  signed int imginternal;
  // imgprocess
  signed int imgprocess;
  // imggamma
  float imggamma;
  // imgbufformat
  signed int imgbufformat;
  // imgfileformat
  signed int imgfileformat;
  // imgcrop
  struct anon$12 imgcrop;
  // numthreads
  signed int numthreads;
  // nodes
  signed int nodes;
  // mynode
  signed int mynode;
  // cpuinfo
  struct anon$13 *cpuinfo;
  // hres
  signed int hres;
  // vres
  signed int vres;
  // aspectratio
  double aspectratio;
  // raydepth
  signed int raydepth;
  // antialiasing
  signed int antialiasing;
  // verbosemode
  signed int verbosemode;
  // boundmode
  signed int boundmode;
  // boundthresh
  signed int boundthresh;
  // texlist
  struct list$link213 *texlist;
  // cliplist
  struct list$link213 *cliplist;
  // flags
  unsigned int flags;
  // camera
  struct anon$14 camera;
  // shader
  struct anon$4 (*shader)(void *);
  // phongfunc
  double (*phongfunc)(struct ray_t$link210 *incident, const struct anon$19 *shadevars, double specpower);
  // transmode
  signed int transmode;
  // bgtex
  struct anon$20 bgtex;
  // bgtexfunc
  struct anon$4 (*bgtexfunc)(struct ray_t$link210 *incident);
  // fog
  struct fogdata_t$link212 fog;
  // objgroup
  struct anon$21 objgroup;
  // lightlist
  struct list$link213 *lightlist;
  // light_scale
  double light_scale;
  // numlights
  signed int numlights;
  // ambocc
  struct amboccdata_t ambocc;
  // scenecheck
  signed int scenecheck;
  // parbuf
  void *parbuf;
  // threads
  void *threads;
  // threadparms
  void *threadparms;
  // curclipgroup
  struct anon$22 *curclipgroup;
  // normalfixupmode
  signed int normalfixupmode;
};

struct fogdata_t$link215
{
  // fog_fctn
  struct anon$4 (*fog_fctn)(struct fogdata_t$link215 *, struct anon$4, double);
  // type
  signed int type;
  // col
  struct anon$4 col;
  // start
  double start;
  // end
  double end;
  // density
  double density;
};

struct anon$68$link217
{
  // outfilename
  char outfilename[256l];
  // writeimagefile
  signed int writeimagefile;
  // img
  void *img;
  // imginternal
  signed int imginternal;
  // imgprocess
  signed int imgprocess;
  // imggamma
  float imggamma;
  // imgbufformat
  signed int imgbufformat;
  // imgfileformat
  signed int imgfileformat;
  // imgcrop
  struct anon$12 imgcrop;
  // numthreads
  signed int numthreads;
  // nodes
  signed int nodes;
  // mynode
  signed int mynode;
  // cpuinfo
  struct anon$13 *cpuinfo;
  // hres
  signed int hres;
  // vres
  signed int vres;
  // aspectratio
  double aspectratio;
  // raydepth
  signed int raydepth;
  // antialiasing
  signed int antialiasing;
  // verbosemode
  signed int verbosemode;
  // boundmode
  signed int boundmode;
  // boundthresh
  signed int boundthresh;
  // texlist
  struct list$link216 *texlist;
  // cliplist
  struct list$link216 *cliplist;
  // flags
  unsigned int flags;
  // camera
  struct anon$14 camera;
  // shader
  struct anon$4 (*shader)(void *);
  // phongfunc
  double (*phongfunc)(struct ray_t$link213 *incident, const struct anon$19 *shadevars, double specpower);
  // transmode
  signed int transmode;
  // bgtex
  struct anon$20 bgtex;
  // bgtexfunc
  struct anon$4 (*bgtexfunc)(struct ray_t$link213 *incident);
  // fog
  struct fogdata_t$link215 fog;
  // objgroup
  struct anon$21 objgroup;
  // lightlist
  struct list$link216 *lightlist;
  // light_scale
  double light_scale;
  // numlights
  signed int numlights;
  // ambocc
  struct amboccdata_t ambocc;
  // scenecheck
  signed int scenecheck;
  // parbuf
  void *parbuf;
  // threads
  void *threads;
  // threadparms
  void *threadparms;
  // curclipgroup
  struct anon$22 *curclipgroup;
  // normalfixupmode
  signed int normalfixupmode;
};

struct fogdata_t$link235
{
  // fog_fctn
  struct anon$4 (*fog_fctn)(struct fogdata_t$link235 *, struct anon$4, double);
  // type
  signed int type;
  // col
  struct anon$4 col;
  // start
  double start;
  // end
  double end;
  // density
  double density;
};

struct anon$56$link236
{
  // outfilename
  char outfilename[256l];
  // writeimagefile
  signed int writeimagefile;
  // img
  void *img;
  // imginternal
  signed int imginternal;
  // imgprocess
  signed int imgprocess;
  // imggamma
  float imggamma;
  // imgbufformat
  signed int imgbufformat;
  // imgfileformat
  signed int imgfileformat;
  // imgcrop
  struct anon$12 imgcrop;
  // numthreads
  signed int numthreads;
  // nodes
  signed int nodes;
  // mynode
  signed int mynode;
  // cpuinfo
  struct anon$13 *cpuinfo;
  // hres
  signed int hres;
  // vres
  signed int vres;
  // aspectratio
  double aspectratio;
  // raydepth
  signed int raydepth;
  // antialiasing
  signed int antialiasing;
  // verbosemode
  signed int verbosemode;
  // boundmode
  signed int boundmode;
  // boundthresh
  signed int boundthresh;
  // texlist
  struct list$link232 *texlist;
  // cliplist
  struct list$link232 *cliplist;
  // flags
  unsigned int flags;
  // camera
  struct anon$14 camera;
  // shader
  struct anon$4 (*shader)(void *);
  // phongfunc
  double (*phongfunc)(struct ray_t$link233 *incident, const struct anon$19 *shadevars, double specpower);
  // transmode
  signed int transmode;
  // bgtex
  struct anon$20 bgtex;
  // bgtexfunc
  struct anon$4 (*bgtexfunc)(struct ray_t$link233 *incident);
  // fog
  struct fogdata_t$link235 fog;
  // objgroup
  struct anon$21 objgroup;
  // lightlist
  struct list$link232 *lightlist;
  // light_scale
  double light_scale;
  // numlights
  signed int numlights;
  // ambocc
  struct amboccdata_t ambocc;
  // scenecheck
  signed int scenecheck;
  // parbuf
  void *parbuf;
  // threads
  void *threads;
  // threadparms
  void *threadparms;
  // curclipgroup
  struct anon$22 *curclipgroup;
  // normalfixupmode
  signed int normalfixupmode;
};

struct fogdata_t$link236
{
  // fog_fctn
  struct anon$4 (*fog_fctn)(struct fogdata_t$link236 *, struct anon$4, double);
  // type
  signed int type;
  // col
  struct anon$4 col;
  // start
  double start;
  // end
  double end;
  // density
  double density;
};

struct anon$57$link238
{
  // outfilename
  char outfilename[256l];
  // writeimagefile
  signed int writeimagefile;
  // img
  void *img;
  // imginternal
  signed int imginternal;
  // imgprocess
  signed int imgprocess;
  // imggamma
  float imggamma;
  // imgbufformat
  signed int imgbufformat;
  // imgfileformat
  signed int imgfileformat;
  // imgcrop
  struct anon$12 imgcrop;
  // numthreads
  signed int numthreads;
  // nodes
  signed int nodes;
  // mynode
  signed int mynode;
  // cpuinfo
  struct anon$13 *cpuinfo;
  // hres
  signed int hres;
  // vres
  signed int vres;
  // aspectratio
  double aspectratio;
  // raydepth
  signed int raydepth;
  // antialiasing
  signed int antialiasing;
  // verbosemode
  signed int verbosemode;
  // boundmode
  signed int boundmode;
  // boundthresh
  signed int boundthresh;
  // texlist
  struct list$link237 *texlist;
  // cliplist
  struct list$link237 *cliplist;
  // flags
  unsigned int flags;
  // camera
  struct anon$14 camera;
  // shader
  struct anon$4 (*shader)(void *);
  // phongfunc
  double (*phongfunc)(struct ray_t$link234 *incident, const struct anon$19 *shadevars, double specpower);
  // transmode
  signed int transmode;
  // bgtex
  struct anon$20 bgtex;
  // bgtexfunc
  struct anon$4 (*bgtexfunc)(struct ray_t$link234 *incident);
  // fog
  struct fogdata_t$link236 fog;
  // objgroup
  struct anon$21 objgroup;
  // lightlist
  struct list$link237 *lightlist;
  // light_scale
  double light_scale;
  // numlights
  signed int numlights;
  // ambocc
  struct amboccdata_t ambocc;
  // scenecheck
  signed int scenecheck;
  // parbuf
  void *parbuf;
  // threads
  void *threads;
  // threadparms
  void *threadparms;
  // curclipgroup
  struct anon$22 *curclipgroup;
  // normalfixupmode
  signed int normalfixupmode;
};

struct fogdata_t$link243
{
  // fog_fctn
  struct anon$4 (*fog_fctn)(struct fogdata_t$link243 *, struct anon$4, double);
  // type
  signed int type;
  // col
  struct anon$4 col;
  // start
  double start;
  // end
  double end;
  // density
  double density;
};

struct anon$63$link244
{
  // outfilename
  char outfilename[256l];
  // writeimagefile
  signed int writeimagefile;
  // img
  void *img;
  // imginternal
  signed int imginternal;
  // imgprocess
  signed int imgprocess;
  // imggamma
  float imggamma;
  // imgbufformat
  signed int imgbufformat;
  // imgfileformat
  signed int imgfileformat;
  // imgcrop
  struct anon$12 imgcrop;
  // numthreads
  signed int numthreads;
  // nodes
  signed int nodes;
  // mynode
  signed int mynode;
  // cpuinfo
  struct anon$13 *cpuinfo;
  // hres
  signed int hres;
  // vres
  signed int vres;
  // aspectratio
  double aspectratio;
  // raydepth
  signed int raydepth;
  // antialiasing
  signed int antialiasing;
  // verbosemode
  signed int verbosemode;
  // boundmode
  signed int boundmode;
  // boundthresh
  signed int boundthresh;
  // texlist
  struct list$link240 *texlist;
  // cliplist
  struct list$link240 *cliplist;
  // flags
  unsigned int flags;
  // camera
  struct anon$14 camera;
  // shader
  struct anon$4 (*shader)(void *);
  // phongfunc
  double (*phongfunc)(struct ray_t$link241 *incident, const struct anon$19 *shadevars, double specpower);
  // transmode
  signed int transmode;
  // bgtex
  struct anon$20 bgtex;
  // bgtexfunc
  struct anon$4 (*bgtexfunc)(struct ray_t$link241 *incident);
  // fog
  struct fogdata_t$link243 fog;
  // objgroup
  struct anon$21 objgroup;
  // lightlist
  struct list$link240 *lightlist;
  // light_scale
  double light_scale;
  // numlights
  signed int numlights;
  // ambocc
  struct amboccdata_t ambocc;
  // scenecheck
  signed int scenecheck;
  // parbuf
  void *parbuf;
  // threads
  void *threads;
  // threadparms
  void *threadparms;
  // curclipgroup
  struct anon$22 *curclipgroup;
  // normalfixupmode
  signed int normalfixupmode;
};

struct fogdata_t$link249
{
  // fog_fctn
  struct anon$4 (*fog_fctn)(struct fogdata_t$link249 *, struct anon$4, double);
  // type
  signed int type;
  // col
  struct anon$4 col;
  // start
  double start;
  // end
  double end;
  // density
  double density;
};

struct anon$66$link250
{
  // outfilename
  char outfilename[256l];
  // writeimagefile
  signed int writeimagefile;
  // img
  void *img;
  // imginternal
  signed int imginternal;
  // imgprocess
  signed int imgprocess;
  // imggamma
  float imggamma;
  // imgbufformat
  signed int imgbufformat;
  // imgfileformat
  signed int imgfileformat;
  // imgcrop
  struct anon$12 imgcrop;
  // numthreads
  signed int numthreads;
  // nodes
  signed int nodes;
  // mynode
  signed int mynode;
  // cpuinfo
  struct anon$13 *cpuinfo;
  // hres
  signed int hres;
  // vres
  signed int vres;
  // aspectratio
  double aspectratio;
  // raydepth
  signed int raydepth;
  // antialiasing
  signed int antialiasing;
  // verbosemode
  signed int verbosemode;
  // boundmode
  signed int boundmode;
  // boundthresh
  signed int boundthresh;
  // texlist
  struct list$link246 *texlist;
  // cliplist
  struct list$link246 *cliplist;
  // flags
  unsigned int flags;
  // camera
  struct anon$14 camera;
  // shader
  struct anon$4 (*shader)(void *);
  // phongfunc
  double (*phongfunc)(struct ray_t$link247 *incident, const struct anon$19 *shadevars, double specpower);
  // transmode
  signed int transmode;
  // bgtex
  struct anon$20 bgtex;
  // bgtexfunc
  struct anon$4 (*bgtexfunc)(struct ray_t$link247 *incident);
  // fog
  struct fogdata_t$link249 fog;
  // objgroup
  struct anon$21 objgroup;
  // lightlist
  struct list$link246 *lightlist;
  // light_scale
  double light_scale;
  // numlights
  signed int numlights;
  // ambocc
  struct amboccdata_t ambocc;
  // scenecheck
  signed int scenecheck;
  // parbuf
  void *parbuf;
  // threads
  void *threads;
  // threadparms
  void *threadparms;
  // curclipgroup
  struct anon$22 *curclipgroup;
  // normalfixupmode
  signed int normalfixupmode;
};

struct fogdata_t$link257
{
  // fog_fctn
  struct anon$4 (*fog_fctn)(struct fogdata_t$link257 *, struct anon$4, double);
  // type
  signed int type;
  // col
  struct anon$4 col;
  // start
  double start;
  // end
  double end;
  // density
  double density;
};

struct anon$71$link259
{
  // outfilename
  char outfilename[256l];
  // writeimagefile
  signed int writeimagefile;
  // img
  void *img;
  // imginternal
  signed int imginternal;
  // imgprocess
  signed int imgprocess;
  // imggamma
  float imggamma;
  // imgbufformat
  signed int imgbufformat;
  // imgfileformat
  signed int imgfileformat;
  // imgcrop
  struct anon$12 imgcrop;
  // numthreads
  signed int numthreads;
  // nodes
  signed int nodes;
  // mynode
  signed int mynode;
  // cpuinfo
  struct anon$13 *cpuinfo;
  // hres
  signed int hres;
  // vres
  signed int vres;
  // aspectratio
  double aspectratio;
  // raydepth
  signed int raydepth;
  // antialiasing
  signed int antialiasing;
  // verbosemode
  signed int verbosemode;
  // boundmode
  signed int boundmode;
  // boundthresh
  signed int boundthresh;
  // texlist
  struct list$link258 *texlist;
  // cliplist
  struct list$link258 *cliplist;
  // flags
  unsigned int flags;
  // camera
  struct anon$14 camera;
  // shader
  struct anon$4 (*shader)(void *);
  // phongfunc
  double (*phongfunc)(struct ray_t$link255 *incident, const struct anon$19 *shadevars, double specpower);
  // transmode
  signed int transmode;
  // bgtex
  struct anon$20 bgtex;
  // bgtexfunc
  struct anon$4 (*bgtexfunc)(struct ray_t$link255 *incident);
  // fog
  struct fogdata_t$link257 fog;
  // objgroup
  struct anon$21 objgroup;
  // lightlist
  struct list$link258 *lightlist;
  // light_scale
  double light_scale;
  // numlights
  signed int numlights;
  // ambocc
  struct amboccdata_t ambocc;
  // scenecheck
  signed int scenecheck;
  // parbuf
  void *parbuf;
  // threads
  void *threads;
  // threadparms
  void *threadparms;
  // curclipgroup
  struct anon$22 *curclipgroup;
  // normalfixupmode
  signed int normalfixupmode;
};

struct fogdata_t$link2
{
  // fog_fctn
  struct anon$4 (*fog_fctn)(struct fogdata_t$link2 *, struct anon$4, double);
  // type
  signed int type;
  // col
  struct anon$4 col;
  // start
  double start;
  // end
  double end;
  // density
  double density;
};

struct anon$32$link4
{
  // outfilename
  char outfilename[256l];
  // writeimagefile
  signed int writeimagefile;
  // img
  void *img;
  // imginternal
  signed int imginternal;
  // imgprocess
  signed int imgprocess;
  // imggamma
  float imggamma;
  // imgbufformat
  signed int imgbufformat;
  // imgfileformat
  signed int imgfileformat;
  // imgcrop
  struct anon$12 imgcrop;
  // numthreads
  signed int numthreads;
  // nodes
  signed int nodes;
  // mynode
  signed int mynode;
  // cpuinfo
  struct anon$13 *cpuinfo;
  // hres
  signed int hres;
  // vres
  signed int vres;
  // aspectratio
  double aspectratio;
  // raydepth
  signed int raydepth;
  // antialiasing
  signed int antialiasing;
  // verbosemode
  signed int verbosemode;
  // boundmode
  signed int boundmode;
  // boundthresh
  signed int boundthresh;
  // texlist
  struct list$link3 *texlist;
  // cliplist
  struct list$link3 *cliplist;
  // flags
  unsigned int flags;
  // camera
  struct anon$14 camera;
  // shader
  struct anon$4 (*shader)(void *);
  // phongfunc
  double (*phongfunc)(struct ray_t$link0 *incident, const struct anon$19 *shadevars, double specpower);
  // transmode
  signed int transmode;
  // bgtex
  struct anon$20 bgtex;
  // bgtexfunc
  struct anon$4 (*bgtexfunc)(struct ray_t$link0 *incident);
  // fog
  struct fogdata_t$link2 fog;
  // objgroup
  struct anon$21 objgroup;
  // lightlist
  struct list$link3 *lightlist;
  // light_scale
  double light_scale;
  // numlights
  signed int numlights;
  // ambocc
  struct amboccdata_t ambocc;
  // scenecheck
  signed int scenecheck;
  // parbuf
  void *parbuf;
  // threads
  void *threads;
  // threadparms
  void *threadparms;
  // curclipgroup
  struct anon$22 *curclipgroup;
  // normalfixupmode
  signed int normalfixupmode;
};

struct fogdata_t$link38
{
  // fog_fctn
  struct anon$4 (*fog_fctn)(struct fogdata_t$link38 *, struct anon$4, double);
  // type
  signed int type;
  // col
  struct anon$4 col;
  // start
  double start;
  // end
  double end;
  // density
  double density;
};

struct anon$38$link40
{
  // outfilename
  char outfilename[256l];
  // writeimagefile
  signed int writeimagefile;
  // img
  void *img;
  // imginternal
  signed int imginternal;
  // imgprocess
  signed int imgprocess;
  // imggamma
  float imggamma;
  // imgbufformat
  signed int imgbufformat;
  // imgfileformat
  signed int imgfileformat;
  // imgcrop
  struct anon$12 imgcrop;
  // numthreads
  signed int numthreads;
  // nodes
  signed int nodes;
  // mynode
  signed int mynode;
  // cpuinfo
  struct anon$13 *cpuinfo;
  // hres
  signed int hres;
  // vres
  signed int vres;
  // aspectratio
  double aspectratio;
  // raydepth
  signed int raydepth;
  // antialiasing
  signed int antialiasing;
  // verbosemode
  signed int verbosemode;
  // boundmode
  signed int boundmode;
  // boundthresh
  signed int boundthresh;
  // texlist
  struct list$link39 *texlist;
  // cliplist
  struct list$link39 *cliplist;
  // flags
  unsigned int flags;
  // camera
  struct anon$14 camera;
  // shader
  struct anon$4 (*shader)(void *);
  // phongfunc
  double (*phongfunc)(struct ray_t$link36 *incident, const struct anon$19 *shadevars, double specpower);
  // transmode
  signed int transmode;
  // bgtex
  struct anon$20 bgtex;
  // bgtexfunc
  struct anon$4 (*bgtexfunc)(struct ray_t$link36 *incident);
  // fog
  struct fogdata_t$link38 fog;
  // objgroup
  struct anon$21 objgroup;
  // lightlist
  struct list$link39 *lightlist;
  // light_scale
  double light_scale;
  // numlights
  signed int numlights;
  // ambocc
  struct amboccdata_t ambocc;
  // scenecheck
  signed int scenecheck;
  // parbuf
  void *parbuf;
  // threads
  void *threads;
  // threadparms
  void *threadparms;
  // curclipgroup
  struct anon$22 *curclipgroup;
  // normalfixupmode
  signed int normalfixupmode;
};

struct fogdata_t$link3
{
  // fog_fctn
  struct anon$4 (*fog_fctn)(struct fogdata_t$link3 *, struct anon$4, double);
  // type
  signed int type;
  // col
  struct anon$4 col;
  // start
  double start;
  // end
  double end;
  // density
  double density;
};

struct anon$52$link5
{
  // outfilename
  char outfilename[256l];
  // writeimagefile
  signed int writeimagefile;
  // img
  void *img;
  // imginternal
  signed int imginternal;
  // imgprocess
  signed int imgprocess;
  // imggamma
  float imggamma;
  // imgbufformat
  signed int imgbufformat;
  // imgfileformat
  signed int imgfileformat;
  // imgcrop
  struct anon$12 imgcrop;
  // numthreads
  signed int numthreads;
  // nodes
  signed int nodes;
  // mynode
  signed int mynode;
  // cpuinfo
  struct anon$13 *cpuinfo;
  // hres
  signed int hres;
  // vres
  signed int vres;
  // aspectratio
  double aspectratio;
  // raydepth
  signed int raydepth;
  // antialiasing
  signed int antialiasing;
  // verbosemode
  signed int verbosemode;
  // boundmode
  signed int boundmode;
  // boundthresh
  signed int boundthresh;
  // texlist
  struct list$link4 *texlist;
  // cliplist
  struct list$link4 *cliplist;
  // flags
  unsigned int flags;
  // camera
  struct anon$14 camera;
  // shader
  struct anon$4 (*shader)(void *);
  // phongfunc
  double (*phongfunc)(struct ray_t$link1 *incident, const struct anon$19 *shadevars, double specpower);
  // transmode
  signed int transmode;
  // bgtex
  struct anon$20 bgtex;
  // bgtexfunc
  struct anon$4 (*bgtexfunc)(struct ray_t$link1 *incident);
  // fog
  struct fogdata_t$link3 fog;
  // objgroup
  struct anon$21 objgroup;
  // lightlist
  struct list$link4 *lightlist;
  // light_scale
  double light_scale;
  // numlights
  signed int numlights;
  // ambocc
  struct amboccdata_t ambocc;
  // scenecheck
  signed int scenecheck;
  // parbuf
  void *parbuf;
  // threads
  void *threads;
  // threadparms
  void *threadparms;
  // curclipgroup
  struct anon$22 *curclipgroup;
  // normalfixupmode
  signed int normalfixupmode;
};

struct fogdata_t$link69
{
  // fog_fctn
  struct anon$4 (*fog_fctn)(struct fogdata_t$link69 *, struct anon$4, double);
  // type
  signed int type;
  // col
  struct anon$4 col;
  // start
  double start;
  // end
  double end;
  // density
  double density;
};

struct anon$67$link71
{
  // outfilename
  char outfilename[256l];
  // writeimagefile
  signed int writeimagefile;
  // img
  void *img;
  // imginternal
  signed int imginternal;
  // imgprocess
  signed int imgprocess;
  // imggamma
  float imggamma;
  // imgbufformat
  signed int imgbufformat;
  // imgfileformat
  signed int imgfileformat;
  // imgcrop
  struct anon$12 imgcrop;
  // numthreads
  signed int numthreads;
  // nodes
  signed int nodes;
  // mynode
  signed int mynode;
  // cpuinfo
  struct anon$13 *cpuinfo;
  // hres
  signed int hres;
  // vres
  signed int vres;
  // aspectratio
  double aspectratio;
  // raydepth
  signed int raydepth;
  // antialiasing
  signed int antialiasing;
  // verbosemode
  signed int verbosemode;
  // boundmode
  signed int boundmode;
  // boundthresh
  signed int boundthresh;
  // texlist
  struct list$link70 *texlist;
  // cliplist
  struct list$link70 *cliplist;
  // flags
  unsigned int flags;
  // camera
  struct anon$14 camera;
  // shader
  struct anon$4 (*shader)(void *);
  // phongfunc
  double (*phongfunc)(struct ray_t$link67 *incident, const struct anon$19 *shadevars, double specpower);
  // transmode
  signed int transmode;
  // bgtex
  struct anon$20 bgtex;
  // bgtexfunc
  struct anon$4 (*bgtexfunc)(struct ray_t$link67 *incident);
  // fog
  struct fogdata_t$link69 fog;
  // objgroup
  struct anon$21 objgroup;
  // lightlist
  struct list$link70 *lightlist;
  // light_scale
  double light_scale;
  // numlights
  signed int numlights;
  // ambocc
  struct amboccdata_t ambocc;
  // scenecheck
  signed int scenecheck;
  // parbuf
  void *parbuf;
  // threads
  void *threads;
  // threadparms
  void *threadparms;
  // curclipgroup
  struct anon$22 *curclipgroup;
  // normalfixupmode
  signed int normalfixupmode;
};

struct fogdata_t$link95
{
  // fog_fctn
  struct anon$4 (*fog_fctn)(struct fogdata_t$link95 *, struct anon$4, double);
  // type
  signed int type;
  // col
  struct anon$4 col;
  // start
  double start;
  // end
  double end;
  // density
  double density;
};

struct anon$44$link94
{
  // outfilename
  char outfilename[256l];
  // writeimagefile
  signed int writeimagefile;
  // img
  void *img;
  // imginternal
  signed int imginternal;
  // imgprocess
  signed int imgprocess;
  // imggamma
  float imggamma;
  // imgbufformat
  signed int imgbufformat;
  // imgfileformat
  signed int imgfileformat;
  // imgcrop
  struct anon$12 imgcrop;
  // numthreads
  signed int numthreads;
  // nodes
  signed int nodes;
  // mynode
  signed int mynode;
  // cpuinfo
  struct anon$13 *cpuinfo;
  // hres
  signed int hres;
  // vres
  signed int vres;
  // aspectratio
  double aspectratio;
  // raydepth
  signed int raydepth;
  // antialiasing
  signed int antialiasing;
  // verbosemode
  signed int verbosemode;
  // boundmode
  signed int boundmode;
  // boundthresh
  signed int boundthresh;
  // texlist
  struct list$link96 *texlist;
  // cliplist
  struct list$link96 *cliplist;
  // flags
  unsigned int flags;
  // camera
  struct anon$14 camera;
  // shader
  struct anon$4 (*shader)(void *);
  // phongfunc
  double (*phongfunc)(struct ray_t$link93 *incident, const struct anon$19 *shadevars, double specpower);
  // transmode
  signed int transmode;
  // bgtex
  struct anon$20 bgtex;
  // bgtexfunc
  struct anon$4 (*bgtexfunc)(struct ray_t$link93 *incident);
  // fog
  struct fogdata_t$link95 fog;
  // objgroup
  struct anon$21 objgroup;
  // lightlist
  struct list$link96 *lightlist;
  // light_scale
  double light_scale;
  // numlights
  signed int numlights;
  // ambocc
  struct amboccdata_t ambocc;
  // scenecheck
  signed int scenecheck;
  // parbuf
  void *parbuf;
  // threads
  void *threads;
  // threadparms
  void *threadparms;
  // curclipgroup
  struct anon$22 *curclipgroup;
  // normalfixupmode
  signed int normalfixupmode;
};

struct anon$2
{
  // x
  float x;
  // y
  float y;
  // z
  float z;
};

struct anon$27
{
  // a
  double a;
  // b
  double b;
  // c
  double c;
  // d
  double d;
  // e
  double e;
  // f
  double f;
  // g
  double g;
  // h
  double h;
  // i
  double i;
  // j
  double j;
};

struct anon$8
{
  // rx1
  double rx1;
  // rx2
  double rx2;
  // rx3
  double rx3;
  // ry1
  double ry1;
  // ry2
  double ry2;
  // ry3
  double ry3;
  // rz1
  double rz1;
  // rz2
  double rz2;
  // rz3
  double rz3;
};

struct anon$41
{
  // __lock
  signed int __lock;
  // __futex
  unsigned int __futex;
  // __total_seq
  unsigned long long int __total_seq;
  // __wakeup_seq
  unsigned long long int __wakeup_seq;
  // __woken_seq
  unsigned long long int __woken_seq;
  // __mutex
  void *__mutex;
  // __nwaiters
  unsigned int __nwaiters;
  // __broadcast_seq
  unsigned int __broadcast_seq;
};

struct anon$34
{
  // levels
  signed int levels;
  // images
  struct anon$33 **images;
};

struct anon$10
{
  // loaded
  signed int loaded;
  // xres
  signed int xres;
  // yres
  signed int yres;
  // zres
  signed int zres;
  // opacity
  double opacity;
  // name
  char name[96l];
  // data
  unsigned char *data;
};

struct anon$33
{
  // loaded
  signed int loaded;
  // xres
  signed int xres;
  // yres
  signed int yres;
  // zres
  signed int zres;
  // bpp
  signed int bpp;
  // name
  char name[96l];
  // data
  unsigned char *data;
};

struct anon$16
{
  // num
  signed int num;
  // closest
  struct anon$37 closest;
  // shadowfilter
  double shadowfilter;
};

struct anon$13
{
  // numcpus
  signed int numcpus;
  // cpuspeed
  double cpuspeed;
  // nodespeed
  double nodespeed;
  // machname
  char machname[512l];
};

struct anon$22
{
  // numplanes
  signed int numplanes;
  // planes
  double *planes;
};

struct anon$7
{
  // texturefunc
  signed int texturefunc;
  // col
  struct anon$4 col;
  // shadowcast
  signed int shadowcast;
  // ambient
  double ambient;
  // diffuse
  double diffuse;
  // specular
  double specular;
  // opacity
  double opacity;
  // ctr
  struct anon$0 ctr;
  // rot
  struct anon$0 rot;
  // scale
  struct anon$0 scale;
  // uaxs
  struct anon$0 uaxs;
  // vaxs
  struct anon$0 vaxs;
  // waxs
  struct anon$0 waxs;
  // imap
  char imap[96l];
};

struct anon$45
{
  // tid
  signed int tid;
  // nthr
  signed int nthr;
  // scene
  struct anon$30$link108 *scene;
  // local_mbox
  unsigned long int *local_mbox;
  // serialno
  unsigned long int serialno;
  // startx
  signed int startx;
  // stopx
  signed int stopx;
  // xinc
  signed int xinc;
  // starty
  signed int starty;
  // stopy
  signed int stopy;
  // yinc
  signed int yinc;
  // runbar
  struct barrier_struct$link117 *runbar;
};

struct anon$46$link123
{
  // tid
  signed int tid;
  // nthr
  signed int nthr;
  // scene
  struct anon$48$link120 *scene;
  // local_mbox
  unsigned long int *local_mbox;
  // serialno
  unsigned long int serialno;
  // startx
  signed int startx;
  // stopx
  signed int stopx;
  // xinc
  signed int xinc;
  // starty
  signed int starty;
  // stopy
  signed int stopy;
  // yinc
  signed int yinc;
  // runbar
  struct barrier_struct$link118 *runbar;
};

struct anon$51
{
  // x
  signed int x;
  // y
  signed int y;
  // z
  signed int z;
};

struct anon$3
{
  // xsize
  signed int xsize;
  // ysize
  signed int ysize;
};

struct anon$19
{
  // hit
  struct anon$0 hit;
  // N
  struct anon$0 N;
  // L
  struct anon$0 L;
  // Llen
  double Llen;
};

struct timeval
{
  // tv_sec
  signed long int tv_sec;
  // tv_usec
  signed long int tv_usec;
};

struct timezone
{
  // tz_minuteswest
  signed int tz_minuteswest;
  // tz_dsttime
  signed int tz_dsttime;
};

struct anon$69
{
  // starttime
  struct timeval starttime;
  // endtime
  struct timeval endtime;
  // tz
  struct timezone tz;
};

struct anon$72
{
  // width
  unsigned short int width;
  // height
  unsigned short int height;
  // ofp
  struct _IO_FILE$link43 *ofp;
};

struct anon$15
{
  // id
  unsigned int id;
  // nextobj
  void *nextobj;
  // methods
  struct anon$23 *methods;
  // clip
  struct anon$22 *clip;
  // tex
  struct anon$25 *tex;
};

struct anon$55
{
  // id
  unsigned int id;
  // nextobj
  void *nextobj;
  // methods
  struct anon$23 *methods;
  // clip
  struct anon$22 *clip;
  // tex
  struct anon$25 *tex;
  // d
  double d;
  // norm
  struct anon$0 norm;
};

struct anon$50
{
  // id
  unsigned int id;
  // nextobj
  void *nextobj;
  // methods
  struct anon$23 *methods;
  // clip
  struct anon$22 *clip;
  // tex
  struct anon$25 *tex;
  // xsize
  signed int xsize;
  // ysize
  signed int ysize;
  // zsize
  signed int zsize;
  // min
  struct anon$0 min;
  // max
  struct anon$0 max;
  // voxsize
  struct anon$0 voxsize;
  // objects
  struct anon$15 *objects;
  // cells
  struct objectlist **cells;
};

struct anon$53
{
  // id
  unsigned int id;
  // nextobj
  void *nextobj;
  // methods
  struct anon$23 *methods;
  // clip
  struct anon$22 *clip;
  // tex
  struct anon$25 *tex;
  // ctr
  struct anon$0 ctr;
  // rad
  double rad;
};

struct anon$28
{
  // id
  unsigned int id;
  // nextobj
  void *nextobj;
  // methods
  struct anon$23 *methods;
  // clip
  struct anon$22 *clip;
  // tex
  struct anon$25 *tex;
  // ctr
  struct anon$0 ctr;
  // mat
  struct anon$27 mat;
};

struct anon$64
{
  // id
  unsigned int id;
  // nextobj
  void *nextobj;
  // methods
  struct anon$23 *methods;
  // clip
  struct anon$22 *clip;
  // tex
  struct anon$25 *tex;
  // ctr
  struct anon$0 ctr;
  // axis
  struct anon$0 axis;
  // rad
  double rad;
};

struct anon$58
{
  // id
  unsigned int id;
  // nextobj
  void *nextobj;
  // methods
  struct anon$23 *methods;
  // clip
  struct anon$22 *clip;
  // tex
  struct anon$25 *tex;
  // ctr
  struct anon$0 ctr;
  // norm
  struct anon$0 norm;
  // inrad
  double inrad;
  // outrad
  double outrad;
};

struct anon$60
{
  // id
  unsigned int id;
  // nextobj
  void *nextobj;
  // methods
  struct anon$23 *methods;
  // clip
  struct anon$22 *clip;
  // tex
  struct anon$25 *tex;
  // edge2
  struct anon$0 edge2;
  // edge1
  struct anon$0 edge1;
  // v0
  struct anon$0 v0;
};

struct anon$61
{
  // id
  unsigned int id;
  // nextobj
  void *nextobj;
  // methods
  struct anon$23 *methods;
  // clip
  struct anon$22 *clip;
  // tex
  struct anon$25 *tex;
  // edge2
  struct anon$0 edge2;
  // edge1
  struct anon$0 edge1;
  // v0
  struct anon$0 v0;
  // n0
  struct anon$0 n0;
  // n1
  struct anon$0 n1;
  // n2
  struct anon$0 n2;
};

struct anon$62
{
  // id
  unsigned int id;
  // nextobj
  void *nextobj;
  // methods
  struct anon$23 *methods;
  // clip
  struct anon$22 *clip;
  // tex
  struct anon$25 *tex;
  // edge2
  struct anon$0 edge2;
  // edge1
  struct anon$0 edge1;
  // v0
  struct anon$0 v0;
  // n0
  struct anon$0 n0;
  // n1
  struct anon$0 n1;
  // n2
  struct anon$0 n2;
  // c0
  struct anon$4 c0;
  // c1
  struct anon$4 c1;
  // c2
  struct anon$4 c2;
};

struct anon$26
{
  // id
  unsigned int id;
  // nextobj
  void *nextobj;
  // methods
  struct anon$23 *methods;
  // clip
  struct anon$22 *clip;
  // tex
  struct anon$25 *tex;
  // min
  struct anon$0 min;
  // max
  struct anon$0 max;
};

struct anon$29
{
  // id
  unsigned int id;
  // nextobj
  void *nextobj;
  // methods
  struct anon$23 *methods;
  // clip
  struct anon$22 *clip;
  // tex
  struct anon$25 *tex;
  // min
  struct anon$0 min;
  // max
  struct anon$0 max;
  // ambient
  double ambient;
  // diffuse
  double diffuse;
  // opacity
  double opacity;
  // samples
  signed int samples;
  // evaluator
  double (*evaluator)(double, double, double);
};

struct anon$18
{
  // x
  unsigned int x;
  // y
  unsigned int y;
  // z
  unsigned int z;
  // w
  unsigned int w;
  // c
  unsigned int c;
  // k
  unsigned int k;
  // m
  unsigned int m;
};

union anon$43
{
  // __size
  char __size[4l];
  // __align
  signed int __align;
};

union anon$42
{
  // __data
  struct anon$41 __data;
  // __size
  char __size[48l];
  // __align
  signed long long int __align;
};

struct __pthread_internal_list
{
  // __prev
  struct __pthread_internal_list *__prev;
  // __next
  struct __pthread_internal_list *__next;
};

struct __pthread_mutex_s
{
  // __lock
  signed int __lock;
  // __count
  unsigned int __count;
  // __owner
  signed int __owner;
  // __nusers
  unsigned int __nusers;
  // __kind
  signed int __kind;
  // __spins
  signed int __spins;
  // __list
  struct __pthread_internal_list __list;
};

union anon$40
{
  // __data
  struct __pthread_mutex_s __data;
  // __size
  char __size[40l];
  // __align
  signed long int __align;
};

struct __pthread_internal_list$link114
{
  // __prev
  struct __pthread_internal_list$link114 *__prev;
  // __next
  struct __pthread_internal_list$link114 *__next;
};

struct __pthread_mutex_s$link115
{
  // __lock
  signed int __lock;
  // __count
  unsigned int __count;
  // __owner
  signed int __owner;
  // __nusers
  unsigned int __nusers;
  // __kind
  signed int __kind;
  // __spins
  signed int __spins;
  // __list
  struct __pthread_internal_list$link114 __list;
};

union anon$47$link116
{
  // __data
  struct __pthread_mutex_s$link115 __data;
  // __size
  char __size[40l];
  // __align
  signed long int __align;
};

struct __pthread_internal_list$link115
{
  // __prev
  struct __pthread_internal_list$link115 *__prev;
  // __next
  struct __pthread_internal_list$link115 *__next;
};

struct __pthread_mutex_s$link116
{
  // __lock
  signed int __lock;
  // __count
  unsigned int __count;
  // __owner
  signed int __owner;
  // __nusers
  unsigned int __nusers;
  // __kind
  signed int __kind;
  // __spins
  signed int __spins;
  // __list
  struct __pthread_internal_list$link115 __list;
};

union anon$49$link117
{
  // __data
  struct __pthread_mutex_s$link116 __data;
  // __size
  char __size[40l];
  // __align
  signed long int __align;
};

struct _IO_FILE
{
  // _flags
  signed int _flags;
  // _IO_read_ptr
  char *_IO_read_ptr;
  // _IO_read_end
  char *_IO_read_end;
  // _IO_read_base
  char *_IO_read_base;
  // _IO_write_base
  char *_IO_write_base;
  // _IO_write_ptr
  char *_IO_write_ptr;
  // _IO_write_end
  char *_IO_write_end;
  // _IO_buf_base
  char *_IO_buf_base;
  // _IO_buf_end
  char *_IO_buf_end;
  // _IO_save_base
  char *_IO_save_base;
  // _IO_backup_base
  char *_IO_backup_base;
  // _IO_save_end
  char *_IO_save_end;
  // _markers
  struct _IO_marker *_markers;
  // _chain
  struct _IO_FILE *_chain;
  // _fileno
  signed int _fileno;
  // _flags2
  signed int _flags2;
  // _old_offset
  signed long int _old_offset;
  // _cur_column
  unsigned short int _cur_column;
  // _vtable_offset
  signed char _vtable_offset;
  // _shortbuf
  char _shortbuf[1l];
  // _lock
  void *_lock;
  // _offset
  signed long int _offset;
  // __pad1
  void *__pad1;
  // __pad2
  void *__pad2;
  // __pad3
  void *__pad3;
  // __pad4
  void *__pad4;
  // __pad5
  unsigned long int __pad5;
  // _mode
  signed int _mode;
  // _unused2
  char _unused2[20l /*[[signed int]]*/];
};

struct _IO_FILE$link0
{
  // _flags
  signed int _flags;
  // _IO_read_ptr
  char *_IO_read_ptr;
  // _IO_read_end
  char *_IO_read_end;
  // _IO_read_base
  char *_IO_read_base;
  // _IO_write_base
  char *_IO_write_base;
  // _IO_write_ptr
  char *_IO_write_ptr;
  // _IO_write_end
  char *_IO_write_end;
  // _IO_buf_base
  char *_IO_buf_base;
  // _IO_buf_end
  char *_IO_buf_end;
  // _IO_save_base
  char *_IO_save_base;
  // _IO_backup_base
  char *_IO_backup_base;
  // _IO_save_end
  char *_IO_save_end;
  // _markers
  struct _IO_marker$link2 *_markers;
  // _chain
  struct _IO_FILE$link0 *_chain;
  // _fileno
  signed int _fileno;
  // _flags2
  signed int _flags2;
  // _old_offset
  signed long int _old_offset;
  // _cur_column
  unsigned short int _cur_column;
  // _vtable_offset
  signed char _vtable_offset;
  // _shortbuf
  char _shortbuf[1l];
  // _lock
  void *_lock;
  // _offset
  signed long int _offset;
  // __pad1
  void *__pad1;
  // __pad2
  void *__pad2;
  // __pad3
  void *__pad3;
  // __pad4
  void *__pad4;
  // __pad5
  unsigned long int __pad5;
  // _mode
  signed int _mode;
  // _unused2
  char _unused2[20l /*[[signed int]]*/];
};

struct _IO_FILE$link11
{
  // _flags
  signed int _flags;
  // _IO_read_ptr
  char *_IO_read_ptr;
  // _IO_read_end
  char *_IO_read_end;
  // _IO_read_base
  char *_IO_read_base;
  // _IO_write_base
  char *_IO_write_base;
  // _IO_write_ptr
  char *_IO_write_ptr;
  // _IO_write_end
  char *_IO_write_end;
  // _IO_buf_base
  char *_IO_buf_base;
  // _IO_buf_end
  char *_IO_buf_end;
  // _IO_save_base
  char *_IO_save_base;
  // _IO_backup_base
  char *_IO_backup_base;
  // _IO_save_end
  char *_IO_save_end;
  // _markers
  struct _IO_marker$link16 *_markers;
  // _chain
  struct _IO_FILE$link11 *_chain;
  // _fileno
  signed int _fileno;
  // _flags2
  signed int _flags2;
  // _old_offset
  signed long int _old_offset;
  // _cur_column
  unsigned short int _cur_column;
  // _vtable_offset
  signed char _vtable_offset;
  // _shortbuf
  char _shortbuf[1l];
  // _lock
  void *_lock;
  // _offset
  signed long int _offset;
  // __pad1
  void *__pad1;
  // __pad2
  void *__pad2;
  // __pad3
  void *__pad3;
  // __pad4
  void *__pad4;
  // __pad5
  unsigned long int __pad5;
  // _mode
  signed int _mode;
  // _unused2
  char _unused2[20l /*[[signed int]]*/];
};

struct _IO_FILE$link12
{
  // _flags
  signed int _flags;
  // _IO_read_ptr
  char *_IO_read_ptr;
  // _IO_read_end
  char *_IO_read_end;
  // _IO_read_base
  char *_IO_read_base;
  // _IO_write_base
  char *_IO_write_base;
  // _IO_write_ptr
  char *_IO_write_ptr;
  // _IO_write_end
  char *_IO_write_end;
  // _IO_buf_base
  char *_IO_buf_base;
  // _IO_buf_end
  char *_IO_buf_end;
  // _IO_save_base
  char *_IO_save_base;
  // _IO_backup_base
  char *_IO_backup_base;
  // _IO_save_end
  char *_IO_save_end;
  // _markers
  struct _IO_marker$link13 *_markers;
  // _chain
  struct _IO_FILE$link12 *_chain;
  // _fileno
  signed int _fileno;
  // _flags2
  signed int _flags2;
  // _old_offset
  signed long int _old_offset;
  // _cur_column
  unsigned short int _cur_column;
  // _vtable_offset
  signed char _vtable_offset;
  // _shortbuf
  char _shortbuf[1l];
  // _lock
  void *_lock;
  // _offset
  signed long int _offset;
  // __pad1
  void *__pad1;
  // __pad2
  void *__pad2;
  // __pad3
  void *__pad3;
  // __pad4
  void *__pad4;
  // __pad5
  unsigned long int __pad5;
  // _mode
  signed int _mode;
  // _unused2
  char _unused2[20l /*[[signed int]]*/];
};

struct _IO_FILE$link13
{
  // _flags
  signed int _flags;
  // _IO_read_ptr
  char *_IO_read_ptr;
  // _IO_read_end
  char *_IO_read_end;
  // _IO_read_base
  char *_IO_read_base;
  // _IO_write_base
  char *_IO_write_base;
  // _IO_write_ptr
  char *_IO_write_ptr;
  // _IO_write_end
  char *_IO_write_end;
  // _IO_buf_base
  char *_IO_buf_base;
  // _IO_buf_end
  char *_IO_buf_end;
  // _IO_save_base
  char *_IO_save_base;
  // _IO_backup_base
  char *_IO_backup_base;
  // _IO_save_end
  char *_IO_save_end;
  // _markers
  struct _IO_marker$link14 *_markers;
  // _chain
  struct _IO_FILE$link13 *_chain;
  // _fileno
  signed int _fileno;
  // _flags2
  signed int _flags2;
  // _old_offset
  signed long int _old_offset;
  // _cur_column
  unsigned short int _cur_column;
  // _vtable_offset
  signed char _vtable_offset;
  // _shortbuf
  char _shortbuf[1l];
  // _lock
  void *_lock;
  // _offset
  signed long int _offset;
  // __pad1
  void *__pad1;
  // __pad2
  void *__pad2;
  // __pad3
  void *__pad3;
  // __pad4
  void *__pad4;
  // __pad5
  unsigned long int __pad5;
  // _mode
  signed int _mode;
  // _unused2
  char _unused2[20l /*[[signed int]]*/];
};

struct _IO_FILE$link14
{
  // _flags
  signed int _flags;
  // _IO_read_ptr
  char *_IO_read_ptr;
  // _IO_read_end
  char *_IO_read_end;
  // _IO_read_base
  char *_IO_read_base;
  // _IO_write_base
  char *_IO_write_base;
  // _IO_write_ptr
  char *_IO_write_ptr;
  // _IO_write_end
  char *_IO_write_end;
  // _IO_buf_base
  char *_IO_buf_base;
  // _IO_buf_end
  char *_IO_buf_end;
  // _IO_save_base
  char *_IO_save_base;
  // _IO_backup_base
  char *_IO_backup_base;
  // _IO_save_end
  char *_IO_save_end;
  // _markers
  struct _IO_marker$link15 *_markers;
  // _chain
  struct _IO_FILE$link14 *_chain;
  // _fileno
  signed int _fileno;
  // _flags2
  signed int _flags2;
  // _old_offset
  signed long int _old_offset;
  // _cur_column
  unsigned short int _cur_column;
  // _vtable_offset
  signed char _vtable_offset;
  // _shortbuf
  char _shortbuf[1l];
  // _lock
  void *_lock;
  // _offset
  signed long int _offset;
  // __pad1
  void *__pad1;
  // __pad2
  void *__pad2;
  // __pad3
  void *__pad3;
  // __pad4
  void *__pad4;
  // __pad5
  unsigned long int __pad5;
  // _mode
  signed int _mode;
  // _unused2
  char _unused2[20l /*[[signed int]]*/];
};

struct _IO_FILE$link15
{
  // _flags
  signed int _flags;
  // _IO_read_ptr
  char *_IO_read_ptr;
  // _IO_read_end
  char *_IO_read_end;
  // _IO_read_base
  char *_IO_read_base;
  // _IO_write_base
  char *_IO_write_base;
  // _IO_write_ptr
  char *_IO_write_ptr;
  // _IO_write_end
  char *_IO_write_end;
  // _IO_buf_base
  char *_IO_buf_base;
  // _IO_buf_end
  char *_IO_buf_end;
  // _IO_save_base
  char *_IO_save_base;
  // _IO_backup_base
  char *_IO_backup_base;
  // _IO_save_end
  char *_IO_save_end;
  // _markers
  struct _IO_marker$link17 *_markers;
  // _chain
  struct _IO_FILE$link15 *_chain;
  // _fileno
  signed int _fileno;
  // _flags2
  signed int _flags2;
  // _old_offset
  signed long int _old_offset;
  // _cur_column
  unsigned short int _cur_column;
  // _vtable_offset
  signed char _vtable_offset;
  // _shortbuf
  char _shortbuf[1l];
  // _lock
  void *_lock;
  // _offset
  signed long int _offset;
  // __pad1
  void *__pad1;
  // __pad2
  void *__pad2;
  // __pad3
  void *__pad3;
  // __pad4
  void *__pad4;
  // __pad5
  unsigned long int __pad5;
  // _mode
  signed int _mode;
  // _unused2
  char _unused2[20l /*[[signed int]]*/];
};

struct _IO_FILE$link16
{
  // _flags
  signed int _flags;
  // _IO_read_ptr
  char *_IO_read_ptr;
  // _IO_read_end
  char *_IO_read_end;
  // _IO_read_base
  char *_IO_read_base;
  // _IO_write_base
  char *_IO_write_base;
  // _IO_write_ptr
  char *_IO_write_ptr;
  // _IO_write_end
  char *_IO_write_end;
  // _IO_buf_base
  char *_IO_buf_base;
  // _IO_buf_end
  char *_IO_buf_end;
  // _IO_save_base
  char *_IO_save_base;
  // _IO_backup_base
  char *_IO_backup_base;
  // _IO_save_end
  char *_IO_save_end;
  // _markers
  struct _IO_marker$link18 *_markers;
  // _chain
  struct _IO_FILE$link16 *_chain;
  // _fileno
  signed int _fileno;
  // _flags2
  signed int _flags2;
  // _old_offset
  signed long int _old_offset;
  // _cur_column
  unsigned short int _cur_column;
  // _vtable_offset
  signed char _vtable_offset;
  // _shortbuf
  char _shortbuf[1l];
  // _lock
  void *_lock;
  // _offset
  signed long int _offset;
  // __pad1
  void *__pad1;
  // __pad2
  void *__pad2;
  // __pad3
  void *__pad3;
  // __pad4
  void *__pad4;
  // __pad5
  unsigned long int __pad5;
  // _mode
  signed int _mode;
  // _unused2
  char _unused2[20l /*[[signed int]]*/];
};

struct _IO_FILE$link17
{
  // _flags
  signed int _flags;
  // _IO_read_ptr
  char *_IO_read_ptr;
  // _IO_read_end
  char *_IO_read_end;
  // _IO_read_base
  char *_IO_read_base;
  // _IO_write_base
  char *_IO_write_base;
  // _IO_write_ptr
  char *_IO_write_ptr;
  // _IO_write_end
  char *_IO_write_end;
  // _IO_buf_base
  char *_IO_buf_base;
  // _IO_buf_end
  char *_IO_buf_end;
  // _IO_save_base
  char *_IO_save_base;
  // _IO_backup_base
  char *_IO_backup_base;
  // _IO_save_end
  char *_IO_save_end;
  // _markers
  struct _IO_marker$link21 *_markers;
  // _chain
  struct _IO_FILE$link17 *_chain;
  // _fileno
  signed int _fileno;
  // _flags2
  signed int _flags2;
  // _old_offset
  signed long int _old_offset;
  // _cur_column
  unsigned short int _cur_column;
  // _vtable_offset
  signed char _vtable_offset;
  // _shortbuf
  char _shortbuf[1l];
  // _lock
  void *_lock;
  // _offset
  signed long int _offset;
  // __pad1
  void *__pad1;
  // __pad2
  void *__pad2;
  // __pad3
  void *__pad3;
  // __pad4
  void *__pad4;
  // __pad5
  unsigned long int __pad5;
  // _mode
  signed int _mode;
  // _unused2
  char _unused2[20l /*[[signed int]]*/];
};

struct _IO_FILE$link18
{
  // _flags
  signed int _flags;
  // _IO_read_ptr
  char *_IO_read_ptr;
  // _IO_read_end
  char *_IO_read_end;
  // _IO_read_base
  char *_IO_read_base;
  // _IO_write_base
  char *_IO_write_base;
  // _IO_write_ptr
  char *_IO_write_ptr;
  // _IO_write_end
  char *_IO_write_end;
  // _IO_buf_base
  char *_IO_buf_base;
  // _IO_buf_end
  char *_IO_buf_end;
  // _IO_save_base
  char *_IO_save_base;
  // _IO_backup_base
  char *_IO_backup_base;
  // _IO_save_end
  char *_IO_save_end;
  // _markers
  struct _IO_marker$link20 *_markers;
  // _chain
  struct _IO_FILE$link18 *_chain;
  // _fileno
  signed int _fileno;
  // _flags2
  signed int _flags2;
  // _old_offset
  signed long int _old_offset;
  // _cur_column
  unsigned short int _cur_column;
  // _vtable_offset
  signed char _vtable_offset;
  // _shortbuf
  char _shortbuf[1l];
  // _lock
  void *_lock;
  // _offset
  signed long int _offset;
  // __pad1
  void *__pad1;
  // __pad2
  void *__pad2;
  // __pad3
  void *__pad3;
  // __pad4
  void *__pad4;
  // __pad5
  unsigned long int __pad5;
  // _mode
  signed int _mode;
  // _unused2
  char _unused2[20l /*[[signed int]]*/];
};

struct _IO_FILE$link19
{
  // _flags
  signed int _flags;
  // _IO_read_ptr
  char *_IO_read_ptr;
  // _IO_read_end
  char *_IO_read_end;
  // _IO_read_base
  char *_IO_read_base;
  // _IO_write_base
  char *_IO_write_base;
  // _IO_write_ptr
  char *_IO_write_ptr;
  // _IO_write_end
  char *_IO_write_end;
  // _IO_buf_base
  char *_IO_buf_base;
  // _IO_buf_end
  char *_IO_buf_end;
  // _IO_save_base
  char *_IO_save_base;
  // _IO_backup_base
  char *_IO_backup_base;
  // _IO_save_end
  char *_IO_save_end;
  // _markers
  struct _IO_marker$link22 *_markers;
  // _chain
  struct _IO_FILE$link19 *_chain;
  // _fileno
  signed int _fileno;
  // _flags2
  signed int _flags2;
  // _old_offset
  signed long int _old_offset;
  // _cur_column
  unsigned short int _cur_column;
  // _vtable_offset
  signed char _vtable_offset;
  // _shortbuf
  char _shortbuf[1l];
  // _lock
  void *_lock;
  // _offset
  signed long int _offset;
  // __pad1
  void *__pad1;
  // __pad2
  void *__pad2;
  // __pad3
  void *__pad3;
  // __pad4
  void *__pad4;
  // __pad5
  unsigned long int __pad5;
  // _mode
  signed int _mode;
  // _unused2
  char _unused2[20l /*[[signed int]]*/];
};

struct _IO_FILE$link20
{
  // _flags
  signed int _flags;
  // _IO_read_ptr
  char *_IO_read_ptr;
  // _IO_read_end
  char *_IO_read_end;
  // _IO_read_base
  char *_IO_read_base;
  // _IO_write_base
  char *_IO_write_base;
  // _IO_write_ptr
  char *_IO_write_ptr;
  // _IO_write_end
  char *_IO_write_end;
  // _IO_buf_base
  char *_IO_buf_base;
  // _IO_buf_end
  char *_IO_buf_end;
  // _IO_save_base
  char *_IO_save_base;
  // _IO_backup_base
  char *_IO_backup_base;
  // _IO_save_end
  char *_IO_save_end;
  // _markers
  struct _IO_marker$link23 *_markers;
  // _chain
  struct _IO_FILE$link20 *_chain;
  // _fileno
  signed int _fileno;
  // _flags2
  signed int _flags2;
  // _old_offset
  signed long int _old_offset;
  // _cur_column
  unsigned short int _cur_column;
  // _vtable_offset
  signed char _vtable_offset;
  // _shortbuf
  char _shortbuf[1l];
  // _lock
  void *_lock;
  // _offset
  signed long int _offset;
  // __pad1
  void *__pad1;
  // __pad2
  void *__pad2;
  // __pad3
  void *__pad3;
  // __pad4
  void *__pad4;
  // __pad5
  unsigned long int __pad5;
  // _mode
  signed int _mode;
  // _unused2
  char _unused2[20l /*[[signed int]]*/];
};

struct _IO_FILE$link21
{
  // _flags
  signed int _flags;
  // _IO_read_ptr
  char *_IO_read_ptr;
  // _IO_read_end
  char *_IO_read_end;
  // _IO_read_base
  char *_IO_read_base;
  // _IO_write_base
  char *_IO_write_base;
  // _IO_write_ptr
  char *_IO_write_ptr;
  // _IO_write_end
  char *_IO_write_end;
  // _IO_buf_base
  char *_IO_buf_base;
  // _IO_buf_end
  char *_IO_buf_end;
  // _IO_save_base
  char *_IO_save_base;
  // _IO_backup_base
  char *_IO_backup_base;
  // _IO_save_end
  char *_IO_save_end;
  // _markers
  struct _IO_marker$link24 *_markers;
  // _chain
  struct _IO_FILE$link21 *_chain;
  // _fileno
  signed int _fileno;
  // _flags2
  signed int _flags2;
  // _old_offset
  signed long int _old_offset;
  // _cur_column
  unsigned short int _cur_column;
  // _vtable_offset
  signed char _vtable_offset;
  // _shortbuf
  char _shortbuf[1l];
  // _lock
  void *_lock;
  // _offset
  signed long int _offset;
  // __pad1
  void *__pad1;
  // __pad2
  void *__pad2;
  // __pad3
  void *__pad3;
  // __pad4
  void *__pad4;
  // __pad5
  unsigned long int __pad5;
  // _mode
  signed int _mode;
  // _unused2
  char _unused2[20l /*[[signed int]]*/];
};

struct _IO_FILE$link22
{
  // _flags
  signed int _flags;
  // _IO_read_ptr
  char *_IO_read_ptr;
  // _IO_read_end
  char *_IO_read_end;
  // _IO_read_base
  char *_IO_read_base;
  // _IO_write_base
  char *_IO_write_base;
  // _IO_write_ptr
  char *_IO_write_ptr;
  // _IO_write_end
  char *_IO_write_end;
  // _IO_buf_base
  char *_IO_buf_base;
  // _IO_buf_end
  char *_IO_buf_end;
  // _IO_save_base
  char *_IO_save_base;
  // _IO_backup_base
  char *_IO_backup_base;
  // _IO_save_end
  char *_IO_save_end;
  // _markers
  struct _IO_marker$link25 *_markers;
  // _chain
  struct _IO_FILE$link22 *_chain;
  // _fileno
  signed int _fileno;
  // _flags2
  signed int _flags2;
  // _old_offset
  signed long int _old_offset;
  // _cur_column
  unsigned short int _cur_column;
  // _vtable_offset
  signed char _vtable_offset;
  // _shortbuf
  char _shortbuf[1l];
  // _lock
  void *_lock;
  // _offset
  signed long int _offset;
  // __pad1
  void *__pad1;
  // __pad2
  void *__pad2;
  // __pad3
  void *__pad3;
  // __pad4
  void *__pad4;
  // __pad5
  unsigned long int __pad5;
  // _mode
  signed int _mode;
  // _unused2
  char _unused2[20l /*[[signed int]]*/];
};

struct _IO_FILE$link23
{
  // _flags
  signed int _flags;
  // _IO_read_ptr
  char *_IO_read_ptr;
  // _IO_read_end
  char *_IO_read_end;
  // _IO_read_base
  char *_IO_read_base;
  // _IO_write_base
  char *_IO_write_base;
  // _IO_write_ptr
  char *_IO_write_ptr;
  // _IO_write_end
  char *_IO_write_end;
  // _IO_buf_base
  char *_IO_buf_base;
  // _IO_buf_end
  char *_IO_buf_end;
  // _IO_save_base
  char *_IO_save_base;
  // _IO_backup_base
  char *_IO_backup_base;
  // _IO_save_end
  char *_IO_save_end;
  // _markers
  struct _IO_marker$link26 *_markers;
  // _chain
  struct _IO_FILE$link23 *_chain;
  // _fileno
  signed int _fileno;
  // _flags2
  signed int _flags2;
  // _old_offset
  signed long int _old_offset;
  // _cur_column
  unsigned short int _cur_column;
  // _vtable_offset
  signed char _vtable_offset;
  // _shortbuf
  char _shortbuf[1l];
  // _lock
  void *_lock;
  // _offset
  signed long int _offset;
  // __pad1
  void *__pad1;
  // __pad2
  void *__pad2;
  // __pad3
  void *__pad3;
  // __pad4
  void *__pad4;
  // __pad5
  unsigned long int __pad5;
  // _mode
  signed int _mode;
  // _unused2
  char _unused2[20l /*[[signed int]]*/];
};

struct _IO_FILE$link24
{
  // _flags
  signed int _flags;
  // _IO_read_ptr
  char *_IO_read_ptr;
  // _IO_read_end
  char *_IO_read_end;
  // _IO_read_base
  char *_IO_read_base;
  // _IO_write_base
  char *_IO_write_base;
  // _IO_write_ptr
  char *_IO_write_ptr;
  // _IO_write_end
  char *_IO_write_end;
  // _IO_buf_base
  char *_IO_buf_base;
  // _IO_buf_end
  char *_IO_buf_end;
  // _IO_save_base
  char *_IO_save_base;
  // _IO_backup_base
  char *_IO_backup_base;
  // _IO_save_end
  char *_IO_save_end;
  // _markers
  struct _IO_marker$link27 *_markers;
  // _chain
  struct _IO_FILE$link24 *_chain;
  // _fileno
  signed int _fileno;
  // _flags2
  signed int _flags2;
  // _old_offset
  signed long int _old_offset;
  // _cur_column
  unsigned short int _cur_column;
  // _vtable_offset
  signed char _vtable_offset;
  // _shortbuf
  char _shortbuf[1l];
  // _lock
  void *_lock;
  // _offset
  signed long int _offset;
  // __pad1
  void *__pad1;
  // __pad2
  void *__pad2;
  // __pad3
  void *__pad3;
  // __pad4
  void *__pad4;
  // __pad5
  unsigned long int __pad5;
  // _mode
  signed int _mode;
  // _unused2
  char _unused2[20l /*[[signed int]]*/];
};

struct _IO_FILE$link25
{
  // _flags
  signed int _flags;
  // _IO_read_ptr
  char *_IO_read_ptr;
  // _IO_read_end
  char *_IO_read_end;
  // _IO_read_base
  char *_IO_read_base;
  // _IO_write_base
  char *_IO_write_base;
  // _IO_write_ptr
  char *_IO_write_ptr;
  // _IO_write_end
  char *_IO_write_end;
  // _IO_buf_base
  char *_IO_buf_base;
  // _IO_buf_end
  char *_IO_buf_end;
  // _IO_save_base
  char *_IO_save_base;
  // _IO_backup_base
  char *_IO_backup_base;
  // _IO_save_end
  char *_IO_save_end;
  // _markers
  struct _IO_marker$link28 *_markers;
  // _chain
  struct _IO_FILE$link25 *_chain;
  // _fileno
  signed int _fileno;
  // _flags2
  signed int _flags2;
  // _old_offset
  signed long int _old_offset;
  // _cur_column
  unsigned short int _cur_column;
  // _vtable_offset
  signed char _vtable_offset;
  // _shortbuf
  char _shortbuf[1l];
  // _lock
  void *_lock;
  // _offset
  signed long int _offset;
  // __pad1
  void *__pad1;
  // __pad2
  void *__pad2;
  // __pad3
  void *__pad3;
  // __pad4
  void *__pad4;
  // __pad5
  unsigned long int __pad5;
  // _mode
  signed int _mode;
  // _unused2
  char _unused2[20l /*[[signed int]]*/];
};

struct _IO_FILE$link26
{
  // _flags
  signed int _flags;
  // _IO_read_ptr
  char *_IO_read_ptr;
  // _IO_read_end
  char *_IO_read_end;
  // _IO_read_base
  char *_IO_read_base;
  // _IO_write_base
  char *_IO_write_base;
  // _IO_write_ptr
  char *_IO_write_ptr;
  // _IO_write_end
  char *_IO_write_end;
  // _IO_buf_base
  char *_IO_buf_base;
  // _IO_buf_end
  char *_IO_buf_end;
  // _IO_save_base
  char *_IO_save_base;
  // _IO_backup_base
  char *_IO_backup_base;
  // _IO_save_end
  char *_IO_save_end;
  // _markers
  struct _IO_marker$link29 *_markers;
  // _chain
  struct _IO_FILE$link26 *_chain;
  // _fileno
  signed int _fileno;
  // _flags2
  signed int _flags2;
  // _old_offset
  signed long int _old_offset;
  // _cur_column
  unsigned short int _cur_column;
  // _vtable_offset
  signed char _vtable_offset;
  // _shortbuf
  char _shortbuf[1l];
  // _lock
  void *_lock;
  // _offset
  signed long int _offset;
  // __pad1
  void *__pad1;
  // __pad2
  void *__pad2;
  // __pad3
  void *__pad3;
  // __pad4
  void *__pad4;
  // __pad5
  unsigned long int __pad5;
  // _mode
  signed int _mode;
  // _unused2
  char _unused2[20l /*[[signed int]]*/];
};

struct _IO_FILE$link27
{
  // _flags
  signed int _flags;
  // _IO_read_ptr
  char *_IO_read_ptr;
  // _IO_read_end
  char *_IO_read_end;
  // _IO_read_base
  char *_IO_read_base;
  // _IO_write_base
  char *_IO_write_base;
  // _IO_write_ptr
  char *_IO_write_ptr;
  // _IO_write_end
  char *_IO_write_end;
  // _IO_buf_base
  char *_IO_buf_base;
  // _IO_buf_end
  char *_IO_buf_end;
  // _IO_save_base
  char *_IO_save_base;
  // _IO_backup_base
  char *_IO_backup_base;
  // _IO_save_end
  char *_IO_save_end;
  // _markers
  struct _IO_marker$link30 *_markers;
  // _chain
  struct _IO_FILE$link27 *_chain;
  // _fileno
  signed int _fileno;
  // _flags2
  signed int _flags2;
  // _old_offset
  signed long int _old_offset;
  // _cur_column
  unsigned short int _cur_column;
  // _vtable_offset
  signed char _vtable_offset;
  // _shortbuf
  char _shortbuf[1l];
  // _lock
  void *_lock;
  // _offset
  signed long int _offset;
  // __pad1
  void *__pad1;
  // __pad2
  void *__pad2;
  // __pad3
  void *__pad3;
  // __pad4
  void *__pad4;
  // __pad5
  unsigned long int __pad5;
  // _mode
  signed int _mode;
  // _unused2
  char _unused2[20l /*[[signed int]]*/];
};

struct _IO_FILE$link28
{
  // _flags
  signed int _flags;
  // _IO_read_ptr
  char *_IO_read_ptr;
  // _IO_read_end
  char *_IO_read_end;
  // _IO_read_base
  char *_IO_read_base;
  // _IO_write_base
  char *_IO_write_base;
  // _IO_write_ptr
  char *_IO_write_ptr;
  // _IO_write_end
  char *_IO_write_end;
  // _IO_buf_base
  char *_IO_buf_base;
  // _IO_buf_end
  char *_IO_buf_end;
  // _IO_save_base
  char *_IO_save_base;
  // _IO_backup_base
  char *_IO_backup_base;
  // _IO_save_end
  char *_IO_save_end;
  // _markers
  struct _IO_marker$link31 *_markers;
  // _chain
  struct _IO_FILE$link28 *_chain;
  // _fileno
  signed int _fileno;
  // _flags2
  signed int _flags2;
  // _old_offset
  signed long int _old_offset;
  // _cur_column
  unsigned short int _cur_column;
  // _vtable_offset
  signed char _vtable_offset;
  // _shortbuf
  char _shortbuf[1l];
  // _lock
  void *_lock;
  // _offset
  signed long int _offset;
  // __pad1
  void *__pad1;
  // __pad2
  void *__pad2;
  // __pad3
  void *__pad3;
  // __pad4
  void *__pad4;
  // __pad5
  unsigned long int __pad5;
  // _mode
  signed int _mode;
  // _unused2
  char _unused2[20l /*[[signed int]]*/];
};

struct _IO_FILE$link29
{
  // _flags
  signed int _flags;
  // _IO_read_ptr
  char *_IO_read_ptr;
  // _IO_read_end
  char *_IO_read_end;
  // _IO_read_base
  char *_IO_read_base;
  // _IO_write_base
  char *_IO_write_base;
  // _IO_write_ptr
  char *_IO_write_ptr;
  // _IO_write_end
  char *_IO_write_end;
  // _IO_buf_base
  char *_IO_buf_base;
  // _IO_buf_end
  char *_IO_buf_end;
  // _IO_save_base
  char *_IO_save_base;
  // _IO_backup_base
  char *_IO_backup_base;
  // _IO_save_end
  char *_IO_save_end;
  // _markers
  struct _IO_marker$link32 *_markers;
  // _chain
  struct _IO_FILE$link29 *_chain;
  // _fileno
  signed int _fileno;
  // _flags2
  signed int _flags2;
  // _old_offset
  signed long int _old_offset;
  // _cur_column
  unsigned short int _cur_column;
  // _vtable_offset
  signed char _vtable_offset;
  // _shortbuf
  char _shortbuf[1l];
  // _lock
  void *_lock;
  // _offset
  signed long int _offset;
  // __pad1
  void *__pad1;
  // __pad2
  void *__pad2;
  // __pad3
  void *__pad3;
  // __pad4
  void *__pad4;
  // __pad5
  unsigned long int __pad5;
  // _mode
  signed int _mode;
  // _unused2
  char _unused2[20l /*[[signed int]]*/];
};

struct _IO_FILE$link30
{
  // _flags
  signed int _flags;
  // _IO_read_ptr
  char *_IO_read_ptr;
  // _IO_read_end
  char *_IO_read_end;
  // _IO_read_base
  char *_IO_read_base;
  // _IO_write_base
  char *_IO_write_base;
  // _IO_write_ptr
  char *_IO_write_ptr;
  // _IO_write_end
  char *_IO_write_end;
  // _IO_buf_base
  char *_IO_buf_base;
  // _IO_buf_end
  char *_IO_buf_end;
  // _IO_save_base
  char *_IO_save_base;
  // _IO_backup_base
  char *_IO_backup_base;
  // _IO_save_end
  char *_IO_save_end;
  // _markers
  struct _IO_marker$link33 *_markers;
  // _chain
  struct _IO_FILE$link30 *_chain;
  // _fileno
  signed int _fileno;
  // _flags2
  signed int _flags2;
  // _old_offset
  signed long int _old_offset;
  // _cur_column
  unsigned short int _cur_column;
  // _vtable_offset
  signed char _vtable_offset;
  // _shortbuf
  char _shortbuf[1l];
  // _lock
  void *_lock;
  // _offset
  signed long int _offset;
  // __pad1
  void *__pad1;
  // __pad2
  void *__pad2;
  // __pad3
  void *__pad3;
  // __pad4
  void *__pad4;
  // __pad5
  unsigned long int __pad5;
  // _mode
  signed int _mode;
  // _unused2
  char _unused2[20l /*[[signed int]]*/];
};

struct _IO_FILE$link31
{
  // _flags
  signed int _flags;
  // _IO_read_ptr
  char *_IO_read_ptr;
  // _IO_read_end
  char *_IO_read_end;
  // _IO_read_base
  char *_IO_read_base;
  // _IO_write_base
  char *_IO_write_base;
  // _IO_write_ptr
  char *_IO_write_ptr;
  // _IO_write_end
  char *_IO_write_end;
  // _IO_buf_base
  char *_IO_buf_base;
  // _IO_buf_end
  char *_IO_buf_end;
  // _IO_save_base
  char *_IO_save_base;
  // _IO_backup_base
  char *_IO_backup_base;
  // _IO_save_end
  char *_IO_save_end;
  // _markers
  struct _IO_marker$link34 *_markers;
  // _chain
  struct _IO_FILE$link31 *_chain;
  // _fileno
  signed int _fileno;
  // _flags2
  signed int _flags2;
  // _old_offset
  signed long int _old_offset;
  // _cur_column
  unsigned short int _cur_column;
  // _vtable_offset
  signed char _vtable_offset;
  // _shortbuf
  char _shortbuf[1l];
  // _lock
  void *_lock;
  // _offset
  signed long int _offset;
  // __pad1
  void *__pad1;
  // __pad2
  void *__pad2;
  // __pad3
  void *__pad3;
  // __pad4
  void *__pad4;
  // __pad5
  unsigned long int __pad5;
  // _mode
  signed int _mode;
  // _unused2
  char _unused2[20l /*[[signed int]]*/];
};

struct _IO_FILE$link32
{
  // _flags
  signed int _flags;
  // _IO_read_ptr
  char *_IO_read_ptr;
  // _IO_read_end
  char *_IO_read_end;
  // _IO_read_base
  char *_IO_read_base;
  // _IO_write_base
  char *_IO_write_base;
  // _IO_write_ptr
  char *_IO_write_ptr;
  // _IO_write_end
  char *_IO_write_end;
  // _IO_buf_base
  char *_IO_buf_base;
  // _IO_buf_end
  char *_IO_buf_end;
  // _IO_save_base
  char *_IO_save_base;
  // _IO_backup_base
  char *_IO_backup_base;
  // _IO_save_end
  char *_IO_save_end;
  // _markers
  struct _IO_marker$link35 *_markers;
  // _chain
  struct _IO_FILE$link32 *_chain;
  // _fileno
  signed int _fileno;
  // _flags2
  signed int _flags2;
  // _old_offset
  signed long int _old_offset;
  // _cur_column
  unsigned short int _cur_column;
  // _vtable_offset
  signed char _vtable_offset;
  // _shortbuf
  char _shortbuf[1l];
  // _lock
  void *_lock;
  // _offset
  signed long int _offset;
  // __pad1
  void *__pad1;
  // __pad2
  void *__pad2;
  // __pad3
  void *__pad3;
  // __pad4
  void *__pad4;
  // __pad5
  unsigned long int __pad5;
  // _mode
  signed int _mode;
  // _unused2
  char _unused2[20l /*[[signed int]]*/];
};

struct _IO_FILE$link33
{
  // _flags
  signed int _flags;
  // _IO_read_ptr
  char *_IO_read_ptr;
  // _IO_read_end
  char *_IO_read_end;
  // _IO_read_base
  char *_IO_read_base;
  // _IO_write_base
  char *_IO_write_base;
  // _IO_write_ptr
  char *_IO_write_ptr;
  // _IO_write_end
  char *_IO_write_end;
  // _IO_buf_base
  char *_IO_buf_base;
  // _IO_buf_end
  char *_IO_buf_end;
  // _IO_save_base
  char *_IO_save_base;
  // _IO_backup_base
  char *_IO_backup_base;
  // _IO_save_end
  char *_IO_save_end;
  // _markers
  struct _IO_marker$link36 *_markers;
  // _chain
  struct _IO_FILE$link33 *_chain;
  // _fileno
  signed int _fileno;
  // _flags2
  signed int _flags2;
  // _old_offset
  signed long int _old_offset;
  // _cur_column
  unsigned short int _cur_column;
  // _vtable_offset
  signed char _vtable_offset;
  // _shortbuf
  char _shortbuf[1l];
  // _lock
  void *_lock;
  // _offset
  signed long int _offset;
  // __pad1
  void *__pad1;
  // __pad2
  void *__pad2;
  // __pad3
  void *__pad3;
  // __pad4
  void *__pad4;
  // __pad5
  unsigned long int __pad5;
  // _mode
  signed int _mode;
  // _unused2
  char _unused2[20l /*[[signed int]]*/];
};

struct _IO_FILE$link34
{
  // _flags
  signed int _flags;
  // _IO_read_ptr
  char *_IO_read_ptr;
  // _IO_read_end
  char *_IO_read_end;
  // _IO_read_base
  char *_IO_read_base;
  // _IO_write_base
  char *_IO_write_base;
  // _IO_write_ptr
  char *_IO_write_ptr;
  // _IO_write_end
  char *_IO_write_end;
  // _IO_buf_base
  char *_IO_buf_base;
  // _IO_buf_end
  char *_IO_buf_end;
  // _IO_save_base
  char *_IO_save_base;
  // _IO_backup_base
  char *_IO_backup_base;
  // _IO_save_end
  char *_IO_save_end;
  // _markers
  struct _IO_marker$link37 *_markers;
  // _chain
  struct _IO_FILE$link34 *_chain;
  // _fileno
  signed int _fileno;
  // _flags2
  signed int _flags2;
  // _old_offset
  signed long int _old_offset;
  // _cur_column
  unsigned short int _cur_column;
  // _vtable_offset
  signed char _vtable_offset;
  // _shortbuf
  char _shortbuf[1l];
  // _lock
  void *_lock;
  // _offset
  signed long int _offset;
  // __pad1
  void *__pad1;
  // __pad2
  void *__pad2;
  // __pad3
  void *__pad3;
  // __pad4
  void *__pad4;
  // __pad5
  unsigned long int __pad5;
  // _mode
  signed int _mode;
  // _unused2
  char _unused2[20l /*[[signed int]]*/];
};

struct _IO_FILE$link35
{
  // _flags
  signed int _flags;
  // _IO_read_ptr
  char *_IO_read_ptr;
  // _IO_read_end
  char *_IO_read_end;
  // _IO_read_base
  char *_IO_read_base;
  // _IO_write_base
  char *_IO_write_base;
  // _IO_write_ptr
  char *_IO_write_ptr;
  // _IO_write_end
  char *_IO_write_end;
  // _IO_buf_base
  char *_IO_buf_base;
  // _IO_buf_end
  char *_IO_buf_end;
  // _IO_save_base
  char *_IO_save_base;
  // _IO_backup_base
  char *_IO_backup_base;
  // _IO_save_end
  char *_IO_save_end;
  // _markers
  struct _IO_marker$link38 *_markers;
  // _chain
  struct _IO_FILE$link35 *_chain;
  // _fileno
  signed int _fileno;
  // _flags2
  signed int _flags2;
  // _old_offset
  signed long int _old_offset;
  // _cur_column
  unsigned short int _cur_column;
  // _vtable_offset
  signed char _vtable_offset;
  // _shortbuf
  char _shortbuf[1l];
  // _lock
  void *_lock;
  // _offset
  signed long int _offset;
  // __pad1
  void *__pad1;
  // __pad2
  void *__pad2;
  // __pad3
  void *__pad3;
  // __pad4
  void *__pad4;
  // __pad5
  unsigned long int __pad5;
  // _mode
  signed int _mode;
  // _unused2
  char _unused2[20l /*[[signed int]]*/];
};

struct _IO_FILE$link36
{
  // _flags
  signed int _flags;
  // _IO_read_ptr
  char *_IO_read_ptr;
  // _IO_read_end
  char *_IO_read_end;
  // _IO_read_base
  char *_IO_read_base;
  // _IO_write_base
  char *_IO_write_base;
  // _IO_write_ptr
  char *_IO_write_ptr;
  // _IO_write_end
  char *_IO_write_end;
  // _IO_buf_base
  char *_IO_buf_base;
  // _IO_buf_end
  char *_IO_buf_end;
  // _IO_save_base
  char *_IO_save_base;
  // _IO_backup_base
  char *_IO_backup_base;
  // _IO_save_end
  char *_IO_save_end;
  // _markers
  struct _IO_marker$link39 *_markers;
  // _chain
  struct _IO_FILE$link36 *_chain;
  // _fileno
  signed int _fileno;
  // _flags2
  signed int _flags2;
  // _old_offset
  signed long int _old_offset;
  // _cur_column
  unsigned short int _cur_column;
  // _vtable_offset
  signed char _vtable_offset;
  // _shortbuf
  char _shortbuf[1l];
  // _lock
  void *_lock;
  // _offset
  signed long int _offset;
  // __pad1
  void *__pad1;
  // __pad2
  void *__pad2;
  // __pad3
  void *__pad3;
  // __pad4
  void *__pad4;
  // __pad5
  unsigned long int __pad5;
  // _mode
  signed int _mode;
  // _unused2
  char _unused2[20l /*[[signed int]]*/];
};

struct _IO_FILE$link37
{
  // _flags
  signed int _flags;
  // _IO_read_ptr
  char *_IO_read_ptr;
  // _IO_read_end
  char *_IO_read_end;
  // _IO_read_base
  char *_IO_read_base;
  // _IO_write_base
  char *_IO_write_base;
  // _IO_write_ptr
  char *_IO_write_ptr;
  // _IO_write_end
  char *_IO_write_end;
  // _IO_buf_base
  char *_IO_buf_base;
  // _IO_buf_end
  char *_IO_buf_end;
  // _IO_save_base
  char *_IO_save_base;
  // _IO_backup_base
  char *_IO_backup_base;
  // _IO_save_end
  char *_IO_save_end;
  // _markers
  struct _IO_marker$link40 *_markers;
  // _chain
  struct _IO_FILE$link37 *_chain;
  // _fileno
  signed int _fileno;
  // _flags2
  signed int _flags2;
  // _old_offset
  signed long int _old_offset;
  // _cur_column
  unsigned short int _cur_column;
  // _vtable_offset
  signed char _vtable_offset;
  // _shortbuf
  char _shortbuf[1l];
  // _lock
  void *_lock;
  // _offset
  signed long int _offset;
  // __pad1
  void *__pad1;
  // __pad2
  void *__pad2;
  // __pad3
  void *__pad3;
  // __pad4
  void *__pad4;
  // __pad5
  unsigned long int __pad5;
  // _mode
  signed int _mode;
  // _unused2
  char _unused2[20l /*[[signed int]]*/];
};

struct _IO_FILE$link38
{
  // _flags
  signed int _flags;
  // _IO_read_ptr
  char *_IO_read_ptr;
  // _IO_read_end
  char *_IO_read_end;
  // _IO_read_base
  char *_IO_read_base;
  // _IO_write_base
  char *_IO_write_base;
  // _IO_write_ptr
  char *_IO_write_ptr;
  // _IO_write_end
  char *_IO_write_end;
  // _IO_buf_base
  char *_IO_buf_base;
  // _IO_buf_end
  char *_IO_buf_end;
  // _IO_save_base
  char *_IO_save_base;
  // _IO_backup_base
  char *_IO_backup_base;
  // _IO_save_end
  char *_IO_save_end;
  // _markers
  struct _IO_marker$link41 *_markers;
  // _chain
  struct _IO_FILE$link38 *_chain;
  // _fileno
  signed int _fileno;
  // _flags2
  signed int _flags2;
  // _old_offset
  signed long int _old_offset;
  // _cur_column
  unsigned short int _cur_column;
  // _vtable_offset
  signed char _vtable_offset;
  // _shortbuf
  char _shortbuf[1l];
  // _lock
  void *_lock;
  // _offset
  signed long int _offset;
  // __pad1
  void *__pad1;
  // __pad2
  void *__pad2;
  // __pad3
  void *__pad3;
  // __pad4
  void *__pad4;
  // __pad5
  unsigned long int __pad5;
  // _mode
  signed int _mode;
  // _unused2
  char _unused2[20l /*[[signed int]]*/];
};

struct _IO_FILE$link39
{
  // _flags
  signed int _flags;
  // _IO_read_ptr
  char *_IO_read_ptr;
  // _IO_read_end
  char *_IO_read_end;
  // _IO_read_base
  char *_IO_read_base;
  // _IO_write_base
  char *_IO_write_base;
  // _IO_write_ptr
  char *_IO_write_ptr;
  // _IO_write_end
  char *_IO_write_end;
  // _IO_buf_base
  char *_IO_buf_base;
  // _IO_buf_end
  char *_IO_buf_end;
  // _IO_save_base
  char *_IO_save_base;
  // _IO_backup_base
  char *_IO_backup_base;
  // _IO_save_end
  char *_IO_save_end;
  // _markers
  struct _IO_marker$link42 *_markers;
  // _chain
  struct _IO_FILE$link39 *_chain;
  // _fileno
  signed int _fileno;
  // _flags2
  signed int _flags2;
  // _old_offset
  signed long int _old_offset;
  // _cur_column
  unsigned short int _cur_column;
  // _vtable_offset
  signed char _vtable_offset;
  // _shortbuf
  char _shortbuf[1l];
  // _lock
  void *_lock;
  // _offset
  signed long int _offset;
  // __pad1
  void *__pad1;
  // __pad2
  void *__pad2;
  // __pad3
  void *__pad3;
  // __pad4
  void *__pad4;
  // __pad5
  unsigned long int __pad5;
  // _mode
  signed int _mode;
  // _unused2
  char _unused2[20l /*[[signed int]]*/];
};

struct _IO_FILE$link40
{
  // _flags
  signed int _flags;
  // _IO_read_ptr
  char *_IO_read_ptr;
  // _IO_read_end
  char *_IO_read_end;
  // _IO_read_base
  char *_IO_read_base;
  // _IO_write_base
  char *_IO_write_base;
  // _IO_write_ptr
  char *_IO_write_ptr;
  // _IO_write_end
  char *_IO_write_end;
  // _IO_buf_base
  char *_IO_buf_base;
  // _IO_buf_end
  char *_IO_buf_end;
  // _IO_save_base
  char *_IO_save_base;
  // _IO_backup_base
  char *_IO_backup_base;
  // _IO_save_end
  char *_IO_save_end;
  // _markers
  struct _IO_marker$link43 *_markers;
  // _chain
  struct _IO_FILE$link40 *_chain;
  // _fileno
  signed int _fileno;
  // _flags2
  signed int _flags2;
  // _old_offset
  signed long int _old_offset;
  // _cur_column
  unsigned short int _cur_column;
  // _vtable_offset
  signed char _vtable_offset;
  // _shortbuf
  char _shortbuf[1l];
  // _lock
  void *_lock;
  // _offset
  signed long int _offset;
  // __pad1
  void *__pad1;
  // __pad2
  void *__pad2;
  // __pad3
  void *__pad3;
  // __pad4
  void *__pad4;
  // __pad5
  unsigned long int __pad5;
  // _mode
  signed int _mode;
  // _unused2
  char _unused2[20l /*[[signed int]]*/];
};

struct _IO_FILE$link41
{
  // _flags
  signed int _flags;
  // _IO_read_ptr
  char *_IO_read_ptr;
  // _IO_read_end
  char *_IO_read_end;
  // _IO_read_base
  char *_IO_read_base;
  // _IO_write_base
  char *_IO_write_base;
  // _IO_write_ptr
  char *_IO_write_ptr;
  // _IO_write_end
  char *_IO_write_end;
  // _IO_buf_base
  char *_IO_buf_base;
  // _IO_buf_end
  char *_IO_buf_end;
  // _IO_save_base
  char *_IO_save_base;
  // _IO_backup_base
  char *_IO_backup_base;
  // _IO_save_end
  char *_IO_save_end;
  // _markers
  struct _IO_marker$link44 *_markers;
  // _chain
  struct _IO_FILE$link41 *_chain;
  // _fileno
  signed int _fileno;
  // _flags2
  signed int _flags2;
  // _old_offset
  signed long int _old_offset;
  // _cur_column
  unsigned short int _cur_column;
  // _vtable_offset
  signed char _vtable_offset;
  // _shortbuf
  char _shortbuf[1l];
  // _lock
  void *_lock;
  // _offset
  signed long int _offset;
  // __pad1
  void *__pad1;
  // __pad2
  void *__pad2;
  // __pad3
  void *__pad3;
  // __pad4
  void *__pad4;
  // __pad5
  unsigned long int __pad5;
  // _mode
  signed int _mode;
  // _unused2
  char _unused2[20l /*[[signed int]]*/];
};

struct _IO_FILE$link42
{
  // _flags
  signed int _flags;
  // _IO_read_ptr
  char *_IO_read_ptr;
  // _IO_read_end
  char *_IO_read_end;
  // _IO_read_base
  char *_IO_read_base;
  // _IO_write_base
  char *_IO_write_base;
  // _IO_write_ptr
  char *_IO_write_ptr;
  // _IO_write_end
  char *_IO_write_end;
  // _IO_buf_base
  char *_IO_buf_base;
  // _IO_buf_end
  char *_IO_buf_end;
  // _IO_save_base
  char *_IO_save_base;
  // _IO_backup_base
  char *_IO_backup_base;
  // _IO_save_end
  char *_IO_save_end;
  // _markers
  struct _IO_marker$link45 *_markers;
  // _chain
  struct _IO_FILE$link42 *_chain;
  // _fileno
  signed int _fileno;
  // _flags2
  signed int _flags2;
  // _old_offset
  signed long int _old_offset;
  // _cur_column
  unsigned short int _cur_column;
  // _vtable_offset
  signed char _vtable_offset;
  // _shortbuf
  char _shortbuf[1l];
  // _lock
  void *_lock;
  // _offset
  signed long int _offset;
  // __pad1
  void *__pad1;
  // __pad2
  void *__pad2;
  // __pad3
  void *__pad3;
  // __pad4
  void *__pad4;
  // __pad5
  unsigned long int __pad5;
  // _mode
  signed int _mode;
  // _unused2
  char _unused2[20l /*[[signed int]]*/];
};

struct _IO_FILE$link43
{
  // _flags
  signed int _flags;
  // _IO_read_ptr
  char *_IO_read_ptr;
  // _IO_read_end
  char *_IO_read_end;
  // _IO_read_base
  char *_IO_read_base;
  // _IO_write_base
  char *_IO_write_base;
  // _IO_write_ptr
  char *_IO_write_ptr;
  // _IO_write_end
  char *_IO_write_end;
  // _IO_buf_base
  char *_IO_buf_base;
  // _IO_buf_end
  char *_IO_buf_end;
  // _IO_save_base
  char *_IO_save_base;
  // _IO_backup_base
  char *_IO_backup_base;
  // _IO_save_end
  char *_IO_save_end;
  // _markers
  struct _IO_marker$link46 *_markers;
  // _chain
  struct _IO_FILE$link43 *_chain;
  // _fileno
  signed int _fileno;
  // _flags2
  signed int _flags2;
  // _old_offset
  signed long int _old_offset;
  // _cur_column
  unsigned short int _cur_column;
  // _vtable_offset
  signed char _vtable_offset;
  // _shortbuf
  char _shortbuf[1l];
  // _lock
  void *_lock;
  // _offset
  signed long int _offset;
  // __pad1
  void *__pad1;
  // __pad2
  void *__pad2;
  // __pad3
  void *__pad3;
  // __pad4
  void *__pad4;
  // __pad5
  unsigned long int __pad5;
  // _mode
  signed int _mode;
  // _unused2
  char _unused2[20l /*[[signed int]]*/];
};

struct _IO_FILE$link44
{
  // _flags
  signed int _flags;
  // _IO_read_ptr
  char *_IO_read_ptr;
  // _IO_read_end
  char *_IO_read_end;
  // _IO_read_base
  char *_IO_read_base;
  // _IO_write_base
  char *_IO_write_base;
  // _IO_write_ptr
  char *_IO_write_ptr;
  // _IO_write_end
  char *_IO_write_end;
  // _IO_buf_base
  char *_IO_buf_base;
  // _IO_buf_end
  char *_IO_buf_end;
  // _IO_save_base
  char *_IO_save_base;
  // _IO_backup_base
  char *_IO_backup_base;
  // _IO_save_end
  char *_IO_save_end;
  // _markers
  struct _IO_marker$link47 *_markers;
  // _chain
  struct _IO_FILE$link44 *_chain;
  // _fileno
  signed int _fileno;
  // _flags2
  signed int _flags2;
  // _old_offset
  signed long int _old_offset;
  // _cur_column
  unsigned short int _cur_column;
  // _vtable_offset
  signed char _vtable_offset;
  // _shortbuf
  char _shortbuf[1l];
  // _lock
  void *_lock;
  // _offset
  signed long int _offset;
  // __pad1
  void *__pad1;
  // __pad2
  void *__pad2;
  // __pad3
  void *__pad3;
  // __pad4
  void *__pad4;
  // __pad5
  unsigned long int __pad5;
  // _mode
  signed int _mode;
  // _unused2
  char _unused2[20l /*[[signed int]]*/];
};

struct _IO_FILE$link5
{
  // _flags
  signed int _flags;
  // _IO_read_ptr
  char *_IO_read_ptr;
  // _IO_read_end
  char *_IO_read_end;
  // _IO_read_base
  char *_IO_read_base;
  // _IO_write_base
  char *_IO_write_base;
  // _IO_write_ptr
  char *_IO_write_ptr;
  // _IO_write_end
  char *_IO_write_end;
  // _IO_buf_base
  char *_IO_buf_base;
  // _IO_buf_end
  char *_IO_buf_end;
  // _IO_save_base
  char *_IO_save_base;
  // _IO_backup_base
  char *_IO_backup_base;
  // _IO_save_end
  char *_IO_save_end;
  // _markers
  struct _IO_marker$link7 *_markers;
  // _chain
  struct _IO_FILE$link5 *_chain;
  // _fileno
  signed int _fileno;
  // _flags2
  signed int _flags2;
  // _old_offset
  signed long int _old_offset;
  // _cur_column
  unsigned short int _cur_column;
  // _vtable_offset
  signed char _vtable_offset;
  // _shortbuf
  char _shortbuf[1l];
  // _lock
  void *_lock;
  // _offset
  signed long int _offset;
  // __pad1
  void *__pad1;
  // __pad2
  void *__pad2;
  // __pad3
  void *__pad3;
  // __pad4
  void *__pad4;
  // __pad5
  unsigned long int __pad5;
  // _mode
  signed int _mode;
  // _unused2
  char _unused2[20l /*[[signed int]]*/];
};

struct _IO_FILE$link6
{
  // _flags
  signed int _flags;
  // _IO_read_ptr
  char *_IO_read_ptr;
  // _IO_read_end
  char *_IO_read_end;
  // _IO_read_base
  char *_IO_read_base;
  // _IO_write_base
  char *_IO_write_base;
  // _IO_write_ptr
  char *_IO_write_ptr;
  // _IO_write_end
  char *_IO_write_end;
  // _IO_buf_base
  char *_IO_buf_base;
  // _IO_buf_end
  char *_IO_buf_end;
  // _IO_save_base
  char *_IO_save_base;
  // _IO_backup_base
  char *_IO_backup_base;
  // _IO_save_end
  char *_IO_save_end;
  // _markers
  struct _IO_marker$link8 *_markers;
  // _chain
  struct _IO_FILE$link6 *_chain;
  // _fileno
  signed int _fileno;
  // _flags2
  signed int _flags2;
  // _old_offset
  signed long int _old_offset;
  // _cur_column
  unsigned short int _cur_column;
  // _vtable_offset
  signed char _vtable_offset;
  // _shortbuf
  char _shortbuf[1l];
  // _lock
  void *_lock;
  // _offset
  signed long int _offset;
  // __pad1
  void *__pad1;
  // __pad2
  void *__pad2;
  // __pad3
  void *__pad3;
  // __pad4
  void *__pad4;
  // __pad5
  unsigned long int __pad5;
  // _mode
  signed int _mode;
  // _unused2
  char _unused2[20l /*[[signed int]]*/];
};

struct _IO_FILE$link7
{
  // _flags
  signed int _flags;
  // _IO_read_ptr
  char *_IO_read_ptr;
  // _IO_read_end
  char *_IO_read_end;
  // _IO_read_base
  char *_IO_read_base;
  // _IO_write_base
  char *_IO_write_base;
  // _IO_write_ptr
  char *_IO_write_ptr;
  // _IO_write_end
  char *_IO_write_end;
  // _IO_buf_base
  char *_IO_buf_base;
  // _IO_buf_end
  char *_IO_buf_end;
  // _IO_save_base
  char *_IO_save_base;
  // _IO_backup_base
  char *_IO_backup_base;
  // _IO_save_end
  char *_IO_save_end;
  // _markers
  struct _IO_marker$link9 *_markers;
  // _chain
  struct _IO_FILE$link7 *_chain;
  // _fileno
  signed int _fileno;
  // _flags2
  signed int _flags2;
  // _old_offset
  signed long int _old_offset;
  // _cur_column
  unsigned short int _cur_column;
  // _vtable_offset
  signed char _vtable_offset;
  // _shortbuf
  char _shortbuf[1l];
  // _lock
  void *_lock;
  // _offset
  signed long int _offset;
  // __pad1
  void *__pad1;
  // __pad2
  void *__pad2;
  // __pad3
  void *__pad3;
  // __pad4
  void *__pad4;
  // __pad5
  unsigned long int __pad5;
  // _mode
  signed int _mode;
  // _unused2
  char _unused2[20l /*[[signed int]]*/];
};

struct _IO_FILE$link8
{
  // _flags
  signed int _flags;
  // _IO_read_ptr
  char *_IO_read_ptr;
  // _IO_read_end
  char *_IO_read_end;
  // _IO_read_base
  char *_IO_read_base;
  // _IO_write_base
  char *_IO_write_base;
  // _IO_write_ptr
  char *_IO_write_ptr;
  // _IO_write_end
  char *_IO_write_end;
  // _IO_buf_base
  char *_IO_buf_base;
  // _IO_buf_end
  char *_IO_buf_end;
  // _IO_save_base
  char *_IO_save_base;
  // _IO_backup_base
  char *_IO_backup_base;
  // _IO_save_end
  char *_IO_save_end;
  // _markers
  struct _IO_marker$link10 *_markers;
  // _chain
  struct _IO_FILE$link8 *_chain;
  // _fileno
  signed int _fileno;
  // _flags2
  signed int _flags2;
  // _old_offset
  signed long int _old_offset;
  // _cur_column
  unsigned short int _cur_column;
  // _vtable_offset
  signed char _vtable_offset;
  // _shortbuf
  char _shortbuf[1l];
  // _lock
  void *_lock;
  // _offset
  signed long int _offset;
  // __pad1
  void *__pad1;
  // __pad2
  void *__pad2;
  // __pad3
  void *__pad3;
  // __pad4
  void *__pad4;
  // __pad5
  unsigned long int __pad5;
  // _mode
  signed int _mode;
  // _unused2
  char _unused2[20l /*[[signed int]]*/];
};

struct _IO_FILE$link9
{
  // _flags
  signed int _flags;
  // _IO_read_ptr
  char *_IO_read_ptr;
  // _IO_read_end
  char *_IO_read_end;
  // _IO_read_base
  char *_IO_read_base;
  // _IO_write_base
  char *_IO_write_base;
  // _IO_write_ptr
  char *_IO_write_ptr;
  // _IO_write_end
  char *_IO_write_end;
  // _IO_buf_base
  char *_IO_buf_base;
  // _IO_buf_end
  char *_IO_buf_end;
  // _IO_save_base
  char *_IO_save_base;
  // _IO_backup_base
  char *_IO_backup_base;
  // _IO_save_end
  char *_IO_save_end;
  // _markers
  struct _IO_marker$link11 *_markers;
  // _chain
  struct _IO_FILE$link9 *_chain;
  // _fileno
  signed int _fileno;
  // _flags2
  signed int _flags2;
  // _old_offset
  signed long int _old_offset;
  // _cur_column
  unsigned short int _cur_column;
  // _vtable_offset
  signed char _vtable_offset;
  // _shortbuf
  char _shortbuf[1l];
  // _lock
  void *_lock;
  // _offset
  signed long int _offset;
  // __pad1
  void *__pad1;
  // __pad2
  void *__pad2;
  // __pad3
  void *__pad3;
  // __pad4
  void *__pad4;
  // __pad5
  unsigned long int __pad5;
  // _mode
  signed int _mode;
  // _unused2
  char _unused2[20l /*[[signed int]]*/];
};

struct _IO_marker
{
  // _next
  struct _IO_marker *_next;
  // _sbuf
  struct _IO_FILE *_sbuf;
  // _pos
  signed int _pos;
};

struct _IO_marker$link10
{
  // _next
  struct _IO_marker$link10 *_next;
  // _sbuf
  struct _IO_FILE$link8 *_sbuf;
  // _pos
  signed int _pos;
};

struct _IO_marker$link11
{
  // _next
  struct _IO_marker$link11 *_next;
  // _sbuf
  struct _IO_FILE$link9 *_sbuf;
  // _pos
  signed int _pos;
};

struct _IO_marker$link13
{
  // _next
  struct _IO_marker$link13 *_next;
  // _sbuf
  struct _IO_FILE$link12 *_sbuf;
  // _pos
  signed int _pos;
};

struct _IO_marker$link14
{
  // _next
  struct _IO_marker$link14 *_next;
  // _sbuf
  struct _IO_FILE$link13 *_sbuf;
  // _pos
  signed int _pos;
};

struct _IO_marker$link15
{
  // _next
  struct _IO_marker$link15 *_next;
  // _sbuf
  struct _IO_FILE$link14 *_sbuf;
  // _pos
  signed int _pos;
};

struct _IO_marker$link16
{
  // _next
  struct _IO_marker$link16 *_next;
  // _sbuf
  struct _IO_FILE$link11 *_sbuf;
  // _pos
  signed int _pos;
};

struct _IO_marker$link17
{
  // _next
  struct _IO_marker$link17 *_next;
  // _sbuf
  struct _IO_FILE$link15 *_sbuf;
  // _pos
  signed int _pos;
};

struct _IO_marker$link18
{
  // _next
  struct _IO_marker$link18 *_next;
  // _sbuf
  struct _IO_FILE$link16 *_sbuf;
  // _pos
  signed int _pos;
};

struct _IO_marker$link2
{
  // _next
  struct _IO_marker$link2 *_next;
  // _sbuf
  struct _IO_FILE$link0 *_sbuf;
  // _pos
  signed int _pos;
};

struct _IO_marker$link20
{
  // _next
  struct _IO_marker$link20 *_next;
  // _sbuf
  struct _IO_FILE$link18 *_sbuf;
  // _pos
  signed int _pos;
};

struct _IO_marker$link21
{
  // _next
  struct _IO_marker$link21 *_next;
  // _sbuf
  struct _IO_FILE$link17 *_sbuf;
  // _pos
  signed int _pos;
};

struct _IO_marker$link22
{
  // _next
  struct _IO_marker$link22 *_next;
  // _sbuf
  struct _IO_FILE$link19 *_sbuf;
  // _pos
  signed int _pos;
};

struct _IO_marker$link23
{
  // _next
  struct _IO_marker$link23 *_next;
  // _sbuf
  struct _IO_FILE$link20 *_sbuf;
  // _pos
  signed int _pos;
};

struct _IO_marker$link24
{
  // _next
  struct _IO_marker$link24 *_next;
  // _sbuf
  struct _IO_FILE$link21 *_sbuf;
  // _pos
  signed int _pos;
};

struct _IO_marker$link25
{
  // _next
  struct _IO_marker$link25 *_next;
  // _sbuf
  struct _IO_FILE$link22 *_sbuf;
  // _pos
  signed int _pos;
};

struct _IO_marker$link26
{
  // _next
  struct _IO_marker$link26 *_next;
  // _sbuf
  struct _IO_FILE$link23 *_sbuf;
  // _pos
  signed int _pos;
};

struct _IO_marker$link27
{
  // _next
  struct _IO_marker$link27 *_next;
  // _sbuf
  struct _IO_FILE$link24 *_sbuf;
  // _pos
  signed int _pos;
};

struct _IO_marker$link28
{
  // _next
  struct _IO_marker$link28 *_next;
  // _sbuf
  struct _IO_FILE$link25 *_sbuf;
  // _pos
  signed int _pos;
};

struct _IO_marker$link29
{
  // _next
  struct _IO_marker$link29 *_next;
  // _sbuf
  struct _IO_FILE$link26 *_sbuf;
  // _pos
  signed int _pos;
};

struct _IO_marker$link30
{
  // _next
  struct _IO_marker$link30 *_next;
  // _sbuf
  struct _IO_FILE$link27 *_sbuf;
  // _pos
  signed int _pos;
};

struct _IO_marker$link31
{
  // _next
  struct _IO_marker$link31 *_next;
  // _sbuf
  struct _IO_FILE$link28 *_sbuf;
  // _pos
  signed int _pos;
};

struct _IO_marker$link32
{
  // _next
  struct _IO_marker$link32 *_next;
  // _sbuf
  struct _IO_FILE$link29 *_sbuf;
  // _pos
  signed int _pos;
};

struct _IO_marker$link33
{
  // _next
  struct _IO_marker$link33 *_next;
  // _sbuf
  struct _IO_FILE$link30 *_sbuf;
  // _pos
  signed int _pos;
};

struct _IO_marker$link34
{
  // _next
  struct _IO_marker$link34 *_next;
  // _sbuf
  struct _IO_FILE$link31 *_sbuf;
  // _pos
  signed int _pos;
};

struct _IO_marker$link35
{
  // _next
  struct _IO_marker$link35 *_next;
  // _sbuf
  struct _IO_FILE$link32 *_sbuf;
  // _pos
  signed int _pos;
};

struct _IO_marker$link36
{
  // _next
  struct _IO_marker$link36 *_next;
  // _sbuf
  struct _IO_FILE$link33 *_sbuf;
  // _pos
  signed int _pos;
};

struct _IO_marker$link37
{
  // _next
  struct _IO_marker$link37 *_next;
  // _sbuf
  struct _IO_FILE$link34 *_sbuf;
  // _pos
  signed int _pos;
};

struct _IO_marker$link38
{
  // _next
  struct _IO_marker$link38 *_next;
  // _sbuf
  struct _IO_FILE$link35 *_sbuf;
  // _pos
  signed int _pos;
};

struct _IO_marker$link39
{
  // _next
  struct _IO_marker$link39 *_next;
  // _sbuf
  struct _IO_FILE$link36 *_sbuf;
  // _pos
  signed int _pos;
};

struct _IO_marker$link40
{
  // _next
  struct _IO_marker$link40 *_next;
  // _sbuf
  struct _IO_FILE$link37 *_sbuf;
  // _pos
  signed int _pos;
};

struct _IO_marker$link41
{
  // _next
  struct _IO_marker$link41 *_next;
  // _sbuf
  struct _IO_FILE$link38 *_sbuf;
  // _pos
  signed int _pos;
};

struct _IO_marker$link42
{
  // _next
  struct _IO_marker$link42 *_next;
  // _sbuf
  struct _IO_FILE$link39 *_sbuf;
  // _pos
  signed int _pos;
};

struct _IO_marker$link43
{
  // _next
  struct _IO_marker$link43 *_next;
  // _sbuf
  struct _IO_FILE$link40 *_sbuf;
  // _pos
  signed int _pos;
};

struct _IO_marker$link44
{
  // _next
  struct _IO_marker$link44 *_next;
  // _sbuf
  struct _IO_FILE$link41 *_sbuf;
  // _pos
  signed int _pos;
};

struct _IO_marker$link45
{
  // _next
  struct _IO_marker$link45 *_next;
  // _sbuf
  struct _IO_FILE$link42 *_sbuf;
  // _pos
  signed int _pos;
};

struct _IO_marker$link46
{
  // _next
  struct _IO_marker$link46 *_next;
  // _sbuf
  struct _IO_FILE$link43 *_sbuf;
  // _pos
  signed int _pos;
};

struct _IO_marker$link47
{
  // _next
  struct _IO_marker$link47 *_next;
  // _sbuf
  struct _IO_FILE$link44 *_sbuf;
  // _pos
  signed int _pos;
};

struct _IO_marker$link7
{
  // _next
  struct _IO_marker$link7 *_next;
  // _sbuf
  struct _IO_FILE$link5 *_sbuf;
  // _pos
  signed int _pos;
};

struct _IO_marker$link8
{
  // _next
  struct _IO_marker$link8 *_next;
  // _sbuf
  struct _IO_FILE$link6 *_sbuf;
  // _pos
  signed int _pos;
};

struct _IO_marker$link9
{
  // _next
  struct _IO_marker$link9 *_next;
  // _sbuf
  struct _IO_FILE$link7 *_sbuf;
  // _pos
  signed int _pos;
};

struct barrier_struct
{
  // padding1
  signed int padding1[8l];
  // lock
  union anon$40 lock;
  // n_clients
  signed int n_clients;
  // n_waiting
  signed int n_waiting;
  // phase
  signed int phase;
  // sum
  signed int sum;
  // result
  signed int result;
  // wait_cv
  union anon$42 wait_cv;
  // padding2
  signed int padding2[8l];
};

struct barrier_struct$link117
{
  // padding1
  signed int padding1[8l];
  // lock
  union anon$47$link116 lock;
  // n_clients
  signed int n_clients;
  // n_waiting
  signed int n_waiting;
  // phase
  signed int phase;
  // sum
  signed int sum;
  // result
  signed int result;
  // wait_cv
  union anon$42 wait_cv;
  // padding2
  signed int padding2[8l];
};

struct barrier_struct$link118
{
  // padding1
  signed int padding1[8l];
  // lock
  union anon$49$link117 lock;
  // n_clients
  signed int n_clients;
  // n_waiting
  signed int n_waiting;
  // phase
  signed int phase;
  // sum
  signed int sum;
  // result
  signed int result;
  // wait_cv
  union anon$42 wait_cv;
  // padding2
  signed int padding2[8l];
};

struct directional_light_t
{
  // id
  unsigned int id;
  // nextobj
  void *nextobj;
  // methods
  struct anon$23 *methods;
  // clip
  struct anon$22 *clip;
  // tex
  struct anon$25 *tex;
  // shade_diffuse
  double (*shade_diffuse)(struct directional_light_t *, struct anon$19 *);
  // dir
  struct anon$0 dir;
};

struct directional_light_t$link271
{
  // id
  unsigned int id;
  // nextobj
  void *nextobj;
  // methods
  struct anon$23 *methods;
  // clip
  struct anon$22 *clip;
  // tex
  struct anon$25 *tex;
  // shade_diffuse
  double (*shade_diffuse)(struct directional_light_t$link271 *, struct anon$19 *);
  // dir
  struct anon$0 dir;
};

struct hash_node_t
{
  // data
  signed int data;
  // key
  const char *key;
  // next
  struct hash_node_t *next;
};

struct light_t
{
  // id
  unsigned int id;
  // nextobj
  void *nextobj;
  // methods
  struct anon$23 *methods;
  // clip
  struct anon$22 *clip;
  // tex
  struct anon$25 *tex;
  // shade_diffuse
  double (*shade_diffuse)(struct light_t *, struct anon$19 *);
};

struct light_t$link272
{
  // id
  unsigned int id;
  // nextobj
  void *nextobj;
  // methods
  struct anon$23 *methods;
  // clip
  struct anon$22 *clip;
  // tex
  struct anon$25 *tex;
  // shade_diffuse
  double (*shade_diffuse)(struct light_t$link272 *, struct anon$19 *);
};

struct list
{
  // item
  void *item;
  // next
  struct list *next;
};

struct list$link110
{
  // item
  void *item;
  // next
  struct list$link110 *next;
};

struct list$link111
{
  // item
  void *item;
  // next
  struct list$link111 *next;
};

struct list$link113
{
  // item
  void *item;
  // next
  struct list$link113 *next;
};

struct list$link122
{
  // item
  void *item;
  // next
  struct list$link122 *next;
};

struct list$link133
{
  // item
  void *item;
  // next
  struct list$link133 *next;
};

struct list$link165
{
  // item
  void *item;
  // next
  struct list$link165 *next;
};

struct list$link202
{
  // item
  void *item;
  // next
  struct list$link202 *next;
};

struct list$link213
{
  // item
  void *item;
  // next
  struct list$link213 *next;
};

struct list$link216
{
  // item
  void *item;
  // next
  struct list$link216 *next;
};

struct list$link232
{
  // item
  void *item;
  // next
  struct list$link232 *next;
};

struct list$link237
{
  // item
  void *item;
  // next
  struct list$link237 *next;
};

struct list$link240
{
  // item
  void *item;
  // next
  struct list$link240 *next;
};

struct list$link246
{
  // item
  void *item;
  // next
  struct list$link246 *next;
};

struct list$link258
{
  // item
  void *item;
  // next
  struct list$link258 *next;
};

struct list$link3
{
  // item
  void *item;
  // next
  struct list$link3 *next;
};

struct list$link39
{
  // item
  void *item;
  // next
  struct list$link39 *next;
};

struct list$link4
{
  // item
  void *item;
  // next
  struct list$link4 *next;
};

struct list$link70
{
  // item
  void *item;
  // next
  struct list$link70 *next;
};

struct list$link96
{
  // item
  void *item;
  // next
  struct list$link96 *next;
};

struct objectlist
{
  // next
  struct objectlist *next;
  // obj
  struct anon$15 *obj;
};

struct point_light_t
{
  // id
  unsigned int id;
  // nextobj
  void *nextobj;
  // methods
  struct anon$23 *methods;
  // clip
  struct anon$22 *clip;
  // tex
  struct anon$25 *tex;
  // shade_diffuse
  double (*shade_diffuse)(struct point_light_t *, struct anon$19 *);
  // ctr
  struct anon$0 ctr;
  // rad
  double rad;
  // attenuationfunc
  double (*attenuationfunc)(void *, double);
  // Kc
  double Kc;
  // Kl
  double Kl;
  // Kq
  double Kq;
  // spotfunc
  double (*spotfunc)(void *, struct anon$0 *);
  // spotdir
  struct anon$0 spotdir;
  // fallstart
  double fallstart;
  // fallend
  double fallend;
};

struct point_light_t$link179
{
  // id
  unsigned int id;
  // nextobj
  void *nextobj;
  // methods
  struct anon$23 *methods;
  // clip
  struct anon$22 *clip;
  // tex
  struct anon$25 *tex;
  // shade_diffuse
  double (*shade_diffuse)(struct point_light_t$link179 *, struct anon$19 *);
  // ctr
  struct anon$0 ctr;
  // rad
  double rad;
  // attenuationfunc
  double (*attenuationfunc)(void *, double);
  // Kc
  double Kc;
  // Kl
  double Kl;
  // Kq
  double Kq;
  // spotfunc
  double (*spotfunc)(void *, struct anon$0 *);
  // spotdir
  struct anon$0 spotdir;
  // fallstart
  double fallstart;
  // fallend
  double fallend;
};

struct point_light_t$link242
{
  // id
  unsigned int id;
  // nextobj
  void *nextobj;
  // methods
  struct anon$23 *methods;
  // clip
  struct anon$22 *clip;
  // tex
  struct anon$25 *tex;
  // shade_diffuse
  double (*shade_diffuse)(struct point_light_t$link242 *, struct anon$19 *);
  // ctr
  struct anon$0 ctr;
  // rad
  double rad;
  // attenuationfunc
  double (*attenuationfunc)(void *, double);
  // Kc
  double Kc;
  // Kl
  double Kl;
  // Kq
  double Kq;
  // spotfunc
  double (*spotfunc)(void *, struct anon$0 *);
  // spotdir
  struct anon$0 spotdir;
  // fallstart
  double fallstart;
  // fallend
  double fallend;
};

union pthread_attr_t
{
  // __size
  char __size[56l];
  // __align
  signed long int __align;
};

struct ray_t
{
  // o
  struct anon$0 o;
  // d
  struct anon$0 d;
  // maxdist
  double maxdist;
  // opticdist
  double opticdist;
  // add_intersection
  void (*add_intersection)(double, const struct anon$15 *, struct ray_t *);
  // intstruct
  struct anon$16 intstruct;
  // depth
  unsigned int depth;
  // flags
  unsigned int flags;
  // serial
  unsigned long int serial;
  // mbox
  unsigned long int *mbox;
  // scene
  struct anon$17 *scene;
  // randval
  unsigned int randval;
  // frng
  struct anon$18 frng;
};

struct ray_t$link0
{
  // o
  struct anon$0 o;
  // d
  struct anon$0 d;
  // maxdist
  double maxdist;
  // opticdist
  double opticdist;
  // add_intersection
  void (*add_intersection)(double, const struct anon$15 *, struct ray_t$link0 *);
  // intstruct
  struct anon$16 intstruct;
  // depth
  unsigned int depth;
  // flags
  unsigned int flags;
  // serial
  unsigned long int serial;
  // mbox
  unsigned long int *mbox;
  // scene
  struct anon$32$link4 *scene;
  // randval
  unsigned int randval;
  // frng
  struct anon$18 frng;
};

struct ray_t$link1
{
  // o
  struct anon$0 o;
  // d
  struct anon$0 d;
  // maxdist
  double maxdist;
  // opticdist
  double opticdist;
  // add_intersection
  void (*add_intersection)(double, const struct anon$15 *, struct ray_t$link1 *);
  // intstruct
  struct anon$16 intstruct;
  // depth
  unsigned int depth;
  // flags
  unsigned int flags;
  // serial
  unsigned long int serial;
  // mbox
  unsigned long int *mbox;
  // scene
  struct anon$52$link5 *scene;
  // randval
  unsigned int randval;
  // frng
  struct anon$18 frng;
};

struct ray_t$link107
{
  // o
  struct anon$0 o;
  // d
  struct anon$0 d;
  // maxdist
  double maxdist;
  // opticdist
  double opticdist;
  // add_intersection
  void (*add_intersection)(double, const struct anon$15 *, struct ray_t$link107 *);
  // intstruct
  struct anon$16 intstruct;
  // depth
  unsigned int depth;
  // flags
  unsigned int flags;
  // serial
  unsigned long int serial;
  // mbox
  unsigned long int *mbox;
  // scene
  struct anon$30$link108 *scene;
  // randval
  unsigned int randval;
  // frng
  struct anon$18 frng;
};

struct ray_t$link108
{
  // o
  struct anon$0 o;
  // d
  struct anon$0 d;
  // maxdist
  double maxdist;
  // opticdist
  double opticdist;
  // add_intersection
  void (*add_intersection)(double, const struct anon$15 *, struct ray_t$link108 *);
  // intstruct
  struct anon$16 intstruct;
  // depth
  unsigned int depth;
  // flags
  unsigned int flags;
  // serial
  unsigned long int serial;
  // mbox
  unsigned long int *mbox;
  // scene
  struct anon$59$link112 *scene;
  // randval
  unsigned int randval;
  // frng
  struct anon$18 frng;
};

struct ray_t$link110
{
  // o
  struct anon$0 o;
  // d
  struct anon$0 d;
  // maxdist
  double maxdist;
  // opticdist
  double opticdist;
  // add_intersection
  void (*add_intersection)(double, const struct anon$15 *, struct ray_t$link110 *);
  // intstruct
  struct anon$16 intstruct;
  // depth
  unsigned int depth;
  // flags
  unsigned int flags;
  // serial
  unsigned long int serial;
  // mbox
  unsigned long int *mbox;
  // scene
  struct anon$39$link111 *scene;
  // randval
  unsigned int randval;
  // frng
  struct anon$18 frng;
};

struct ray_t$link119
{
  // o
  struct anon$0 o;
  // d
  struct anon$0 d;
  // maxdist
  double maxdist;
  // opticdist
  double opticdist;
  // add_intersection
  void (*add_intersection)(double, const struct anon$15 *, struct ray_t$link119 *);
  // intstruct
  struct anon$16 intstruct;
  // depth
  unsigned int depth;
  // flags
  unsigned int flags;
  // serial
  unsigned long int serial;
  // mbox
  unsigned long int *mbox;
  // scene
  struct anon$48$link120 *scene;
  // randval
  unsigned int randval;
  // frng
  struct anon$18 frng;
};

struct ray_t$link130
{
  // o
  struct anon$0 o;
  // d
  struct anon$0 d;
  // maxdist
  double maxdist;
  // opticdist
  double opticdist;
  // add_intersection
  void (*add_intersection)(double, const struct anon$15 *, struct ray_t$link130 *);
  // intstruct
  struct anon$16 intstruct;
  // depth
  unsigned int depth;
  // flags
  unsigned int flags;
  // serial
  unsigned long int serial;
  // mbox
  unsigned long int *mbox;
  // scene
  struct anon$70$link134 *scene;
  // randval
  unsigned int randval;
  // frng
  struct anon$18 frng;
};

struct ray_t$link162
{
  // o
  struct anon$0 o;
  // d
  struct anon$0 d;
  // maxdist
  double maxdist;
  // opticdist
  double opticdist;
  // add_intersection
  void (*add_intersection)(double, const struct anon$15 *, struct ray_t$link162 *);
  // intstruct
  struct anon$16 intstruct;
  // depth
  unsigned int depth;
  // flags
  unsigned int flags;
  // serial
  unsigned long int serial;
  // mbox
  unsigned long int *mbox;
  // scene
  struct anon$65$link166 *scene;
  // randval
  unsigned int randval;
  // frng
  struct anon$18 frng;
};

struct ray_t$link199
{
  // o
  struct anon$0 o;
  // d
  struct anon$0 d;
  // maxdist
  double maxdist;
  // opticdist
  double opticdist;
  // add_intersection
  void (*add_intersection)(double, const struct anon$15 *, struct ray_t$link199 *);
  // intstruct
  struct anon$16 intstruct;
  // depth
  unsigned int depth;
  // flags
  unsigned int flags;
  // serial
  unsigned long int serial;
  // mbox
  unsigned long int *mbox;
  // scene
  struct anon$54$link203 *scene;
  // randval
  unsigned int randval;
  // frng
  struct anon$18 frng;
};

struct ray_t$link210
{
  // o
  struct anon$0 o;
  // d
  struct anon$0 d;
  // maxdist
  double maxdist;
  // opticdist
  double opticdist;
  // add_intersection
  void (*add_intersection)(double, const struct anon$15 *, struct ray_t$link210 *);
  // intstruct
  struct anon$16 intstruct;
  // depth
  unsigned int depth;
  // flags
  unsigned int flags;
  // serial
  unsigned long int serial;
  // mbox
  unsigned long int *mbox;
  // scene
  struct anon$31$link211 *scene;
  // randval
  unsigned int randval;
  // frng
  struct anon$18 frng;
};

struct ray_t$link213
{
  // o
  struct anon$0 o;
  // d
  struct anon$0 d;
  // maxdist
  double maxdist;
  // opticdist
  double opticdist;
  // add_intersection
  void (*add_intersection)(double, const struct anon$15 *, struct ray_t$link213 *);
  // intstruct
  struct anon$16 intstruct;
  // depth
  unsigned int depth;
  // flags
  unsigned int flags;
  // serial
  unsigned long int serial;
  // mbox
  unsigned long int *mbox;
  // scene
  struct anon$68$link217 *scene;
  // randval
  unsigned int randval;
  // frng
  struct anon$18 frng;
};

struct ray_t$link233
{
  // o
  struct anon$0 o;
  // d
  struct anon$0 d;
  // maxdist
  double maxdist;
  // opticdist
  double opticdist;
  // add_intersection
  void (*add_intersection)(double, const struct anon$15 *, struct ray_t$link233 *);
  // intstruct
  struct anon$16 intstruct;
  // depth
  unsigned int depth;
  // flags
  unsigned int flags;
  // serial
  unsigned long int serial;
  // mbox
  unsigned long int *mbox;
  // scene
  struct anon$56$link236 *scene;
  // randval
  unsigned int randval;
  // frng
  struct anon$18 frng;
};

struct ray_t$link234
{
  // o
  struct anon$0 o;
  // d
  struct anon$0 d;
  // maxdist
  double maxdist;
  // opticdist
  double opticdist;
  // add_intersection
  void (*add_intersection)(double, const struct anon$15 *, struct ray_t$link234 *);
  // intstruct
  struct anon$16 intstruct;
  // depth
  unsigned int depth;
  // flags
  unsigned int flags;
  // serial
  unsigned long int serial;
  // mbox
  unsigned long int *mbox;
  // scene
  struct anon$57$link238 *scene;
  // randval
  unsigned int randval;
  // frng
  struct anon$18 frng;
};

struct ray_t$link241
{
  // o
  struct anon$0 o;
  // d
  struct anon$0 d;
  // maxdist
  double maxdist;
  // opticdist
  double opticdist;
  // add_intersection
  void (*add_intersection)(double, const struct anon$15 *, struct ray_t$link241 *);
  // intstruct
  struct anon$16 intstruct;
  // depth
  unsigned int depth;
  // flags
  unsigned int flags;
  // serial
  unsigned long int serial;
  // mbox
  unsigned long int *mbox;
  // scene
  struct anon$63$link244 *scene;
  // randval
  unsigned int randval;
  // frng
  struct anon$18 frng;
};

struct ray_t$link247
{
  // o
  struct anon$0 o;
  // d
  struct anon$0 d;
  // maxdist
  double maxdist;
  // opticdist
  double opticdist;
  // add_intersection
  void (*add_intersection)(double, const struct anon$15 *, struct ray_t$link247 *);
  // intstruct
  struct anon$16 intstruct;
  // depth
  unsigned int depth;
  // flags
  unsigned int flags;
  // serial
  unsigned long int serial;
  // mbox
  unsigned long int *mbox;
  // scene
  struct anon$66$link250 *scene;
  // randval
  unsigned int randval;
  // frng
  struct anon$18 frng;
};

struct ray_t$link255
{
  // o
  struct anon$0 o;
  // d
  struct anon$0 d;
  // maxdist
  double maxdist;
  // opticdist
  double opticdist;
  // add_intersection
  void (*add_intersection)(double, const struct anon$15 *, struct ray_t$link255 *);
  // intstruct
  struct anon$16 intstruct;
  // depth
  unsigned int depth;
  // flags
  unsigned int flags;
  // serial
  unsigned long int serial;
  // mbox
  unsigned long int *mbox;
  // scene
  struct anon$71$link259 *scene;
  // randval
  unsigned int randval;
  // frng
  struct anon$18 frng;
};

struct ray_t$link36
{
  // o
  struct anon$0 o;
  // d
  struct anon$0 d;
  // maxdist
  double maxdist;
  // opticdist
  double opticdist;
  // add_intersection
  void (*add_intersection)(double, const struct anon$15 *, struct ray_t$link36 *);
  // intstruct
  struct anon$16 intstruct;
  // depth
  unsigned int depth;
  // flags
  unsigned int flags;
  // serial
  unsigned long int serial;
  // mbox
  unsigned long int *mbox;
  // scene
  struct anon$38$link40 *scene;
  // randval
  unsigned int randval;
  // frng
  struct anon$18 frng;
};

struct ray_t$link67
{
  // o
  struct anon$0 o;
  // d
  struct anon$0 d;
  // maxdist
  double maxdist;
  // opticdist
  double opticdist;
  // add_intersection
  void (*add_intersection)(double, const struct anon$15 *, struct ray_t$link67 *);
  // intstruct
  struct anon$16 intstruct;
  // depth
  unsigned int depth;
  // flags
  unsigned int flags;
  // serial
  unsigned long int serial;
  // mbox
  unsigned long int *mbox;
  // scene
  struct anon$67$link71 *scene;
  // randval
  unsigned int randval;
  // frng
  struct anon$18 frng;
};

struct ray_t$link93
{
  // o
  struct anon$0 o;
  // d
  struct anon$0 d;
  // maxdist
  double maxdist;
  // opticdist
  double opticdist;
  // add_intersection
  void (*add_intersection)(double, const struct anon$15 *, struct ray_t$link93 *);
  // intstruct
  struct anon$16 intstruct;
  // depth
  unsigned int depth;
  // flags
  unsigned int flags;
  // serial
  unsigned long int serial;
  // mbox
  unsigned long int *mbox;
  // scene
  struct anon$44$link94 *scene;
  // randval
  unsigned int randval;
  // frng
  struct anon$18 frng;
};

struct rt_run_barrier_struct
{
  // padding1
  signed int padding1[8l];
  // lock
  union anon$40 lock;
  // n_clients
  signed int n_clients;
  // n_waiting
  signed int n_waiting;
  // phase
  signed int phase;
  // fctn
  void * (*fctn)(void *);
  // parms
  void *parms;
  // rslt
  void * (*rslt)(void *);
  // rsltparms
  void *rsltparms;
  // wait_cv
  union anon$42 wait_cv;
  // padding2
  signed int padding2[8l];
};

struct rt_shared_iterator_struct
{
  // mtx
  union anon$40 mtx;
  // start
  signed int start;
  // end
  signed int end;
  // current
  signed int current;
  // fatalerror
  signed int fatalerror;
};

struct rt_threadpool_struct
{
  // workercount
  signed int workercount;
  // threads
  unsigned long int *threads;
  // workerdata
  struct rt_threadpool_workerdata_struct *workerdata;
  // runbar
  struct rt_run_barrier_struct runbar;
};

struct rt_threadpool_workerdata_struct
{
  // padding1
  signed int padding1[8l];
  // threadid
  signed int threadid;
  // threadcount
  signed int threadcount;
  // parms
  void *parms;
  // thrpool
  void *thrpool;
  // padding2
  signed int padding2[8l];
};

struct rwlock_struct
{
  // lock
  union anon$40 lock;
  // rwlock
  signed int rwlock;
  // rdrs_ok
  union anon$42 rdrs_ok;
  // waiting_writers
  unsigned int waiting_writers;
  // wrtr_ok
  union anon$42 wrtr_ok;
};

struct timespec
{
  // tv_sec
  signed long int tv_sec;
  // tv_nsec
  signed long int tv_nsec;
};

struct stat
{
  // st_dev
  unsigned long int st_dev;
  // st_ino
  unsigned long int st_ino;
  // st_nlink
  unsigned long int st_nlink;
  // st_mode
  unsigned int st_mode;
  // st_uid
  unsigned int st_uid;
  // st_gid
  unsigned int st_gid;
  // __pad0
  signed int __pad0;
  // st_rdev
  unsigned long int st_rdev;
  // st_size
  signed long int st_size;
  // st_blksize
  signed long int st_blksize;
  // st_blocks
  signed long int st_blocks;
  // st_atim
  struct timespec st_atim;
  // st_mtim
  struct timespec st_mtim;
  // st_ctim
  struct timespec st_ctim;
  // __unused
  signed long int __unused[3l];
};

struct tri_list_t
{
  // v0
  signed int v0;
  // v1
  signed int v1;
  // v2
  signed int v2;
  // smooth
  signed int smooth;
  // texnum
  signed int texnum;
  // next
  struct tri_list_t *next;
};


// c::NoiseMatrix
// file ../src/texture.c line 355
signed short int NoiseMatrix[28l][28l][28l];
// c::backgr
// file ../demosrc/nffparse.c line 18
static struct anon$4 backgr;
// c::box_methods
// file ../src/box.c line 24
static struct anon$23 box_methods;
// c::box_methods
// file ../src/box.c line 24
static struct anon$23 box_methods = { .intersect=(void (*)(const void *, void *))box_intersect, .normal=(void (*)(const void *, const void *, const void *, void *))box_normal,
    .bbox=box_bbox,
    .freeobj=free };
// c::curtexture
// file ../demosrc/nffparse.c line 17
static void *curtexture;
// c::cylinder_methods
// file ../src/cylinder.c line 17
static struct anon$23 cylinder_methods;
// c::cylinder_methods
// file ../src/cylinder.c line 17
static struct anon$23 cylinder_methods = { .intersect=(void (*)(const void *, void *))cylinder_intersect, .normal=(void (*)(const void *, const void *, const void *, void *))cylinder_normal,
    .bbox=cylinder_bbox,
    .freeobj=free };
// c::extvol_methods
// file ../src/extvol.c line 32
static struct anon$23 extvol_methods;
// c::extvol_methods
// file ../src/extvol.c line 32
static struct anon$23 extvol_methods = { .intersect=(void (*)(const void *, void *))box_intersect, .normal=(void (*)(const void *, const void *, const void *, void *))box_normal,
    .bbox=extvol_bbox,
    .freeobj=free };
// c::fcylinder_methods
// file ../src/cylinder.c line 24
static struct anon$23 fcylinder_methods;
// c::fcylinder_methods
// file ../src/cylinder.c line 24
static struct anon$23 fcylinder_methods = { .intersect=(void (*)(const void *, void *))fcylinder_intersect, .normal=(void (*)(const void *, const void *, const void *, void *))cylinder_normal,
    .bbox=fcylinder_bbox,
    .freeobj=free };
// c::grid_methods
// file ../src/grid.c line 25
static struct anon$23 grid_methods;
// c::grid_methods
// file ../src/grid.c line 25
static struct anon$23 grid_methods = { .intersect=(void (*)(const void *, void *))grid_intersect, .normal=((void (*)(const void *, const void *, const void *, void *))NULL),
    .bbox=grid_bbox,
    .freeobj=grid_free };
// c::imagelist
// file ../src/imap.c line 16
struct anon$33 *imagelist[39l];
// c::light_methods
// file ../src/light.c line 17
static struct anon$23 light_methods;
// c::light_methods
// file ../src/light.c line 17
static struct anon$23 light_methods = { .intersect=(void (*)(const void *, void *))light_intersect, .normal=(void (*)(const void *, const void *, const void *, void *))light_normal,
    .bbox=light_bbox,
    .freeobj=free };
// c::normal_methods
// file ../src/texture.c line 17
static struct anon$24 normal_methods;
// c::normal_methods
// file ../src/texture.c line 17
static struct anon$24 normal_methods = { .freetex=free };
// c::numimages
// file ../src/imap.c line 17
signed int numimages;
// c::numobjectsparsed
// file ../demosrc/ac3dparse.c line 22
static signed int numobjectsparsed;
// c::numtextures
// file ../demosrc/ac3dparse.c line 21
static signed int numtextures;
// c::parinitted
// file ../src/global.h line 8
signed int parinitted;
// c::parinitted
// file ../src/global.h line 8
signed int parinitted = 0;
// c::plane_methods
// file ../src/plane.c line 17
static struct anon$23 plane_methods;
// c::plane_methods
// file ../src/plane.c line 17
static struct anon$23 plane_methods = { .intersect=(void (*)(const void *, void *))plane_intersect, .normal=(void (*)(const void *, const void *, const void *, void *))plane_normal,
    .bbox=plane_bbox,
    .freeobj=free };
// c::quadric_methods
// file ../src/quadric.c line 19
static struct anon$23 quadric_methods;
// c::quadric_methods
// file ../src/quadric.c line 19
static struct anon$23 quadric_methods = { .intersect=(void (*)(const void *, void *))quadric_intersect, .normal=(void (*)(const void *, const void *, const void *, void *))quadric_normal,
    .bbox=quadric_bbox,
    .freeobj=free };
// c::ring_methods
// file ../src/ring.c line 17
static struct anon$23 ring_methods;
// c::ring_methods
// file ../src/ring.c line 17
static struct anon$23 ring_methods = { .intersect=(void (*)(const void *, void *))ring_intersect, .normal=(void (*)(const void *, const void *, const void *, void *))ring_normal,
    .bbox=ring_bbox,
    .freeobj=free };
// c::rt_static_ui_checkaction
// file ../src/ui.c line 15
static signed int (*rt_static_ui_checkaction)(void);
// c::rt_static_ui_checkaction
// file ../src/ui.c line 15
static signed int (*rt_static_ui_checkaction)(void) = (signed int (*)(void))NULL;
// c::rt_static_ui_message
// file ../src/ui.c line 13
static void (*rt_static_ui_message)(signed int, char *);
// c::rt_static_ui_message
// file ../src/ui.c line 13
static void (*rt_static_ui_message)(signed int, char *) = (void (*)(signed int, char *))NULL;
// c::rt_static_ui_progress
// file ../src/ui.c line 14
static void (*rt_static_ui_progress)(signed int);
// c::rt_static_ui_progress
// file ../src/ui.c line 14
static void (*rt_static_ui_progress)(signed int) = (void (*)(signed int))NULL;
// c::scenebackcol
// file ../demosrc/ac3dparse.c line 23
static struct anon$4 scenebackcol;
// c::sphere_methods
// file ../src/sphere.c line 17
static struct anon$23 sphere_methods;
// c::sphere_methods
// file ../src/sphere.c line 17
static struct anon$23 sphere_methods = { .intersect=(void (*)(const void *, void *))sphere_intersect, .normal=(void (*)(const void *, const void *, const void *, void *))sphere_normal,
    .bbox=sphere_bbox,
    .freeobj=free };
// c::standard_methods
// file ../src/texture.c line 21
static struct anon$24 standard_methods;
// c::standard_methods
// file ../src/texture.c line 21
static struct anon$24 standard_methods = { .freetex=free_standard_texture };
// c::stdin
// file /usr/include/stdio.h line 168
struct _IO_FILE *stdin;
// c::stdout
// file /usr/include/stdio.h line 169
struct _IO_FILE *stdout;
// c::stri_methods
// file ../src/triangle.c line 24
static struct anon$23 stri_methods;
// c::stri_methods
// file ../src/triangle.c line 24
static struct anon$23 stri_methods = { .intersect=(void (*)(const void *, void *))tri_intersect, .normal=(void (*)(const void *, const void *, const void *, void *))stri_normal,
    .bbox=tri_bbox,
    .freeobj=free };
// c::stri_methods_guess
// file ../src/triangle.c line 38
static struct anon$23 stri_methods_guess;
// c::stri_methods_guess
// file ../src/triangle.c line 38
static struct anon$23 stri_methods_guess = { .intersect=(void (*)(const void *, void *))tri_intersect, .normal=(void (*)(const void *, const void *, const void *, void *))stri_normal_guess,
    .bbox=tri_bbox,
    .freeobj=free };
// c::stri_methods_reverse
// file ../src/triangle.c line 31
static struct anon$23 stri_methods_reverse;
// c::stri_methods_reverse
// file ../src/triangle.c line 31
static struct anon$23 stri_methods_reverse = { .intersect=(void (*)(const void *, void *))tri_intersect, .normal=(void (*)(const void *, const void *, const void *, void *))stri_normal_reverse,
    .bbox=tri_bbox,
    .freeobj=free };
// c::textable
// file ../demosrc/ac3dparse.c line 20
static struct anon$11 textable[8192l];
// c::tri_methods
// file ../src/triangle.c line 17
static struct anon$23 tri_methods;
// c::tri_methods
// file ../src/triangle.c line 17
static struct anon$23 tri_methods = { .intersect=(void (*)(const void *, void *))tri_intersect, .normal=(void (*)(const void *, const void *, const void *, void *))tri_normal$link249,
    .bbox=tri_bbox,
    .freeobj=free };
// c::vcstri_methods
// file ../src/texture.c line 25
static struct anon$24 vcstri_methods;
// c::vcstri_methods
// file ../src/texture.c line 25
static struct anon$24 vcstri_methods = { .freetex=free };

// c::AllocateImageFile
// file ../src/imap.c line 76
struct anon$33 * AllocateImageFile(const char *filename)
{
  struct anon$33 *newimage = (struct anon$33 *)NULL;
  signed int i;
  signed int len;
  signed int intable = 0;
  signed int tmp_statement_expression$1;
  if(!(numimages == 0))
  {
    i = 0;
    while(!(i >= numimages))
    {
      unsigned long int __s1_len;
      unsigned long int __s2_len;
      signed int return_value___builtin_strcmp$2;
      return_value___builtin_strcmp$2=__builtin_strcmp(filename, imagelist[(signed long int)i]->name);
      tmp_statement_expression$1 = return_value___builtin_strcmp$2;
      if(tmp_statement_expression$1 == 0)
      {
        newimage = imagelist[(signed long int)i];
        intable = 1;
      }

      i = i + 1;
    }
  }

  if(intable == 0)
  {
    void *return_value_malloc$3;
    return_value_malloc$3=malloc(128ul /*[[struct anon$33]]*/);
    newimage = (struct anon$33 *)return_value_malloc$3;
    newimage->loaded = 0;
    newimage->xres = 0;
    newimage->yres = 0;
    newimage->zres = 0;
    newimage->bpp = 0;
    newimage->data = (unsigned char *)NULL;
    unsigned long int return_value_strlen$4;
    return_value_strlen$4=strlen(filename);
    len = (signed int)return_value_strlen$4;
    if(len > 80)
      return (struct anon$33 *)NULL;

    strcpy(newimage->name, filename);
    imagelist[(signed long int)numimages] = newimage;
    numimages = numimages + 1;
  }

  return newimage;
}

// c::AllocateImageRGB24
// file ../src/imap.h line 9
struct anon$33 * AllocateImageRGB24(const char *filename, signed int xs, signed int ys, signed int zs, unsigned char *rgb)
{
  struct anon$33 *newimage = (struct anon$33 *)NULL;
  signed int i;
  signed int len;
  signed int intable = 0;
  signed int tmp_statement_expression$1;
  if(!(numimages == 0))
  {
    i = 0;
    while(!(i >= numimages))
    {
      unsigned long int __s1_len;
      unsigned long int __s2_len;
      signed int return_value___builtin_strcmp$2;
      return_value___builtin_strcmp$2=__builtin_strcmp(filename, imagelist[(signed long int)i]->name);
      tmp_statement_expression$1 = return_value___builtin_strcmp$2;
      if(tmp_statement_expression$1 == 0)
      {
        newimage = imagelist[(signed long int)i];
        intable = 1;
      }

      i = i + 1;
    }
  }

  if(intable == 0)
  {
    void *return_value_malloc$3;
    return_value_malloc$3=malloc(128ul /*[[struct anon$33]]*/);
    newimage = (struct anon$33 *)return_value_malloc$3;
    newimage->loaded = 1;
    newimage->xres = xs;
    newimage->yres = ys;
    newimage->zres = zs;
    newimage->bpp = 3;
    newimage->data = rgb;
    unsigned long int return_value_strlen$4;
    return_value_strlen$4=strlen(filename);
    len = (signed int)return_value_strlen$4;
    if(len > 80)
      return (struct anon$33 *)NULL;

    strcpy(newimage->name, filename);
    imagelist[(signed long int)numimages] = newimage;
    numimages = numimages + 1;
  }

  return newimage;
}

// c::ColorAccum
// file ../src/vector.c line 76
void ColorAccum(struct anon$4 *a, const struct anon$4 *b)
{
  a->r = a->r + b->r;
  a->g = a->g + b->g;
  a->b = a->b + b->b;
}

// c::ColorAddS
// file ../src/vector.c line 70
void ColorAddS(struct anon$4 *a, const struct anon$4 *b, double s)
{
  a->r = a->r + (float)((double)b->r * s);
  a->g = a->g + (float)((double)b->g * s);
  a->b = a->b + (float)((double)b->b * s);
}

// c::ColorScale
// file ../src/vector.c line 82
void ColorScale(struct anon$4 *a, double s)
{
  a->r = a->r * (float)s;
  a->g = a->g * (float)s;
  a->b = a->b * (float)s;
}

// c::CreateMIPMap
// file ../src/imap.c line 252
struct anon$34 * CreateMIPMap(struct anon$33 *image, signed int maxlevels)
{
  struct anon$34 *mip;
  signed int xlevels;
  signed int ylevels;
  signed int zlevels;
  signed int i;
  char msgtxt[1024l];
  if(image == ((struct anon$33 *)NULL))
    return (struct anon$34 *)NULL;

  void *return_value_malloc$1;
  return_value_malloc$1=malloc(16ul /*[[struct anon$34]]*/);
  mip = (struct anon$34 *)return_value_malloc$1;
  if(mip == ((struct anon$34 *)NULL))
    return (struct anon$34 *)NULL;

  xlevels = 0;
  i=abs(image->xres);
  while(!(i == 0))
  {
    i = i >> 1;
    xlevels = xlevels + 1;
  }
  ylevels = 0;
  i=abs(image->yres);
  while(!(i == 0))
  {
    i = i >> 1;
    ylevels = ylevels + 1;
  }
  zlevels = 0;
  i=abs(image->zres);
  while(!(i == 0))
  {
    i = i >> 1;
    zlevels = zlevels + 1;
  }
  mip->levels = xlevels > ylevels ? xlevels : ylevels;
  if(!(mip->levels >= zlevels))
    mip->levels = zlevels;

  if(image->zres > 1)
    maxlevels = 1;

  if(maxlevels > 0)
  {
    if(!(maxlevels >= mip->levels))
      mip->levels = maxlevels;

  }

  sprintf(msgtxt, "Creating MIP Map: xlevels: %d  ylevels: %d  zlevels: %d  levels: %d", xlevels, ylevels, zlevels, mip->levels);
  rt_ui_message(100, msgtxt);
  void *return_value_malloc$2;
  return_value_malloc$2=malloc((unsigned long int)mip->levels * 8ul /*[[struct anon$33 *]]*/);
  mip->images = (struct anon$33 **)return_value_malloc$2;
  if(mip->images == ((struct anon$33 **)NULL))
  {
    free((void *)mip);
    return (struct anon$34 *)NULL;
  }

  i = 0;
  while(!(i >= mip->levels))
  {
    mip->images[(signed long int)i] = (struct anon$33 *)NULL;
    i = i + 1;
  }
  mip->images[(signed long int)0] = image;
  i = 1;
  while(!(i >= mip->levels))
  {
    mip->images[(signed long int)i]=DecimateImage(mip->images[(signed long int)(i - 1)]);
    i = i + 1;
  }
  return mip;
}

// c::DeallocateImage
// file ../src/imap.c line 130
void DeallocateImage(struct anon$33 *image)
{
  image->loaded = 0;
  free((void *)image->data);
  image->data = (unsigned char *)NULL;
  free((void *)image);
}

// c::DecimateImage
// file ../src/imap.c line 169
struct anon$33 * DecimateImage(const struct anon$33 *image)
{
  struct anon$33 *newimage;
  signed int x;
  signed int y;
  signed int addr;
  signed int addr2;
  x = (signed int)image->xres >> 1;
  if(x == 0)
    x = 1;

  y = (signed int)image->yres >> 1;
  if(y == 0)
    y = 1;

  newimage=NewImage(x, y, 1);
  _Bool tmp_if_expr$1;
  if(image->xres > 1)
    tmp_if_expr$1 = image->yres > 1 ? TRUE : FALSE;

  else
    tmp_if_expr$1 = FALSE;
  if(tmp_if_expr$1)
  {
    y = 0;
    while(!(y >= newimage->yres))
    {
      x = 0;
      while(!(x >= newimage->xres))
      {
        addr = (newimage->xres * y + x) * 3;
        addr2 = (image->xres * y + x) * 3 * 2;
        newimage->data[(signed long int)addr] = (unsigned char)((signed int)((signed int)image->data[(signed long int)addr2] + (signed int)image->data[(signed long int)(addr2 + 3)] + (signed int)image->data[(signed long int)(addr2 + image->xres * 3)] + (signed int)image->data[(signed long int)(addr2 + (image->xres + 1) * 3)]) >> 2);
        addr = addr + 1;
        addr2 = addr2 + 1;
        newimage->data[(signed long int)addr] = (unsigned char)((signed int)((signed int)image->data[(signed long int)addr2] + (signed int)image->data[(signed long int)(addr2 + 3)] + (signed int)image->data[(signed long int)(addr2 + image->xres * 3)] + (signed int)image->data[(signed long int)(addr2 + (image->xres + 1) * 3)]) >> 2);
        addr = addr + 1;
        addr2 = addr2 + 1;
        newimage->data[(signed long int)addr] = (unsigned char)((signed int)((signed int)image->data[(signed long int)addr2] + (signed int)image->data[(signed long int)(addr2 + 3)] + (signed int)image->data[(signed long int)(addr2 + image->xres * 3)] + (signed int)image->data[(signed long int)(addr2 + (image->xres + 1) * 3)]) >> 2);
        x = x + 1;
      }
      y = y + 1;
    }
  }

  else
    if(image->xres == 1)
    {
      y = 0;
      while(!(y >= newimage->yres))
      {
        addr = y * 3;
        addr2 = y * 3 * 2;
        newimage->data[(signed long int)addr] = (unsigned char)((signed int)((signed int)image->data[(signed long int)addr2] + (signed int)image->data[(signed long int)(addr2 + 3)]) >> 1);
        addr = addr + 1;
        addr2 = addr2 + 1;
        newimage->data[(signed long int)addr] = (unsigned char)((signed int)((signed int)image->data[(signed long int)addr2] + (signed int)image->data[(signed long int)(addr2 + 3)]) >> 1);
        addr = addr + 1;
        addr2 = addr2 + 1;
        newimage->data[(signed long int)addr] = (unsigned char)((signed int)((signed int)image->data[(signed long int)addr2] + (signed int)image->data[(signed long int)(addr2 + 3)]) >> 1);
        y = y + 1;
      }
    }

    else
      if(image->yres == 1)
      {
        x = 0;
        while(!(x >= newimage->xres))
        {
          addr = x * 3;
          addr2 = x * 3 * 2;
          newimage->data[(signed long int)addr] = (unsigned char)((signed int)((signed int)image->data[(signed long int)addr2] + (signed int)image->data[(signed long int)(addr2 + 3)]) >> 1);
          addr = addr + 1;
          addr2 = addr2 + 1;
          newimage->data[(signed long int)addr] = (unsigned char)((signed int)((signed int)image->data[(signed long int)addr2] + (signed int)image->data[(signed long int)(addr2 + 3)]) >> 1);
          addr = addr + 1;
          addr2 = addr2 + 1;
          newimage->data[(signed long int)addr] = (unsigned char)((signed int)((signed int)image->data[(signed long int)addr2] + (signed int)image->data[(signed long int)(addr2 + 3)]) >> 1);
          x = x + 1;
        }
      }

  return newimage;
}

// c::ExtVoxelColor
// file ../src/extvol.c line 85
struct anon$4 ExtVoxelColor(double scalar)
{
  struct anon$4 col;
  if(scalar > 1.000000)
    scalar = 1.000000;

  if(scalar < 0.000000)
    scalar = 0.000000;

  if(scalar < 5.000000e-1)
    col.g = (float)0.000000;

  else
    col.g = (float)((scalar - 5.000000e-1) * 2.000000);
  col.r = (float)scalar;
  col.b = (float)(1.000000 - scalar / 2.000000);
  return col;
}

// c::FreeImages
// file ../src/imap.h line 13
void FreeImages(void)
{
  signed int i = 0;
  while(!(i >= numimages))
  {
    DeallocateImage(imagelist[(signed long int)i]);
    i = i + 1;
  }
  ResetImages();
}

// c::FreeMIPMap
// file ../src/imap.h line 17
void FreeMIPMap(struct anon$34 *mip)
{
  signed int i = 1;
  while(!(i >= mip->levels))
  {
    DeallocateImage(mip->images[(signed long int)i]);
    i = i + 1;
  }
  free((void *)mip->images);
  free((void *)mip);
}

// c::FreeTextures
// file ../src/texture.h line 28
void FreeTextures(void)
{
  FreeImages();
}

// c::GetAC3DString
// file ../demosrc/ac3dparse.c line 43
static void GetAC3DString(struct _IO_FILE$link6 *dfile, char *str)
{
  char c;
  signed int i = 0;
  signed int return_value_feof$1;
  signed int return_value_fgetc$2;
  do
  {
    return_value_feof$1=feof(dfile);
    if(return_value_feof$1 != 0)
      goto __CPROVER_DUMP_L2;

    return_value_fgetc$2=fgetc(dfile);
    c = (char)return_value_fgetc$2;
    if((signed int)c == 34)
      goto __CPROVER_DUMP_L2;

  }
  while(TRUE);
  signed int return_value_feof$3;
  signed int return_value_fgetc$4;
  do
  {

  __CPROVER_DUMP_L2:
    ;
    return_value_feof$3=feof(dfile);
    if(return_value_feof$3 != 0)
      goto __CPROVER_DUMP_L3;

    return_value_fgetc$4=fgetc(dfile);
    c = (char)return_value_fgetc$4;
    if((signed int)c == 34)
      goto __CPROVER_DUMP_L3;

    str[(signed long int)i] = c;
    i = i + 1;
  }
  while(TRUE);

__CPROVER_DUMP_L3:
  ;
  str[(signed long int)i] = (char)0;
}

// c::GetBackGnd
// file ../demosrc/parse.c line 1096
static unsigned int GetBackGnd(struct anon$6 *ph, void *scene)
{
  float r;
  float g;
  float b;
  struct anon$4 scenebackcol;
  fscanf(ph->ifp, "%f %f %f", &r, &g, &b);
  scenebackcol.r = r;
  scenebackcol.g = g;
  scenebackcol.b = b;
  rt_background(scene, scenebackcol);
  return (unsigned int)0;
}

// c::GetBox
// file ../demosrc/parse.c line 1250
static unsigned int GetBox(struct anon$6 *ph, void *scene)
{
  struct anon$0 min;
  struct anon$0 max;
  void *tex;
  unsigned int rc;
  rc=GetString(ph, "MIN");
  unsigned int return_value_GetVector$1;
  return_value_GetVector$1=GetVector(ph, &min);
  rc = rc | return_value_GetVector$1;
  unsigned int return_value_GetString$2;
  return_value_GetString$2=GetString(ph, "MAX");
  rc = rc | return_value_GetString$2;
  unsigned int return_value_GetVector$3;
  return_value_GetVector$3=GetVector(ph, &max);
  rc = rc | return_value_GetVector$3;
  unsigned int return_value_GetTexture$4;
  return_value_GetTexture$4=GetTexture(ph, scene, &tex);
  rc = rc | return_value_GetTexture$4;
  rt_box(scene, tex, min, max);
  return rc;
}

// c::GetCamera
// file ../demosrc/parse.c line 380
static unsigned int GetCamera(struct anon$6 *ph, void *scene)
{
  struct anon$0 Ccenter;
  struct anon$0 Cview;
  struct anon$0 Cup;
  double zoom;
  double aspectratio;
  signed int raydepth;
  signed int antialiasing;
  float a;
  float b;
  float c;
  float d;
  unsigned int rc = (unsigned int)0;
  char data[255l];
  fscanf(ph->ifp, "%s", (const void *)data);
  signed int return_value_stringcmp$9;
  return_value_stringcmp$9=stringcmp(data, "PROJECTION");
  signed int return_value_stringcmp$5;
  signed int return_value_stringcmp$4;
  signed int return_value_stringcmp$3;
  signed int return_value_stringcmp$8;
  if(return_value_stringcmp$9 == 0)
  {
    fscanf(ph->ifp, "%s", (const void *)data);
    signed int return_value_stringcmp$6;
    return_value_stringcmp$6=stringcmp(data, "FISHEYE");
    if(return_value_stringcmp$6 == 0)
      rt_camera_projection(scene, 3);

    else
    {
      return_value_stringcmp$5=stringcmp(data, "PERSPECTIVE");
      if(return_value_stringcmp$5 == 0)
        rt_camera_projection(scene, 0);

      else
      {
        return_value_stringcmp$4=stringcmp(data, "PERSPECTIVE_DOF");
        if(return_value_stringcmp$4 == 0)
        {
          rt_camera_projection(scene, 2);
          unsigned int return_value_GetString$1;
          return_value_GetString$1=GetString(ph, "FOCALLENGTH");
          rc = rc | return_value_GetString$1;
          fscanf(ph->ifp, "%f", &a);
          unsigned int return_value_GetString$2;
          return_value_GetString$2=GetString(ph, "APERTURE");
          rc = rc | return_value_GetString$2;
          fscanf(ph->ifp, "%f", &b);
          rt_camera_dof(scene, (double)a, (double)b);
        }

        else
        {
          return_value_stringcmp$3=stringcmp(data, "ORTHOGRAPHIC");
          if(return_value_stringcmp$3 == 0)
            rt_camera_projection(scene, 1);

        }
      }
    }
    unsigned int return_value_GetString$7;
    return_value_GetString$7=GetString(ph, "ZOOM");
    rc = rc | return_value_GetString$7;
    fscanf(ph->ifp, "%f", &a);
    zoom = (double)a;
  }

  else
  {
    return_value_stringcmp$8=stringcmp(data, "ZOOM");
    if(return_value_stringcmp$8 == 0)
    {
      fscanf(ph->ifp, "%f", &a);
      zoom = (double)a;
    }

    else
    {
      rc = (unsigned int)4;
      return rc;
    }
  }
  unsigned int return_value_GetString$10;
  return_value_GetString$10=GetString(ph, "ASPECTRATIO");
  rc = rc | return_value_GetString$10;
  fscanf(ph->ifp, "%f", &b);
  aspectratio = (double)b;
  unsigned int return_value_GetString$11;
  return_value_GetString$11=GetString(ph, "ANTIALIASING");
  rc = rc | return_value_GetString$11;
  fscanf(ph->ifp, "%d", &antialiasing);
  unsigned int return_value_GetString$12;
  return_value_GetString$12=GetString(ph, "RAYDEPTH");
  rc = rc | return_value_GetString$12;
  fscanf(ph->ifp, "%d", &raydepth);
  unsigned int return_value_GetString$13;
  return_value_GetString$13=GetString(ph, "CENTER");
  rc = rc | return_value_GetString$13;
  fscanf(ph->ifp, "%f %f %f", &a, &b, &c);
  Ccenter.x = (double)a;
  Ccenter.y = (double)b;
  Ccenter.z = (double)c;
  unsigned int return_value_GetString$14;
  return_value_GetString$14=GetString(ph, "VIEWDIR");
  rc = rc | return_value_GetString$14;
  fscanf(ph->ifp, "%f %f %f", &a, &b, &c);
  Cview.x = (double)a;
  Cview.y = (double)b;
  Cview.z = (double)c;
  unsigned int return_value_GetString$15;
  return_value_GetString$15=GetString(ph, "UPDIR");
  rc = rc | return_value_GetString$15;
  fscanf(ph->ifp, "%f %f %f", &a, &b, &c);
  Cup.x = (double)a;
  Cup.y = (double)b;
  Cup.z = (double)c;
  rt_camera_setup(scene, zoom, aspectratio, antialiasing, raydepth, Ccenter, Cview, Cup);
  fscanf(ph->ifp, "%s", (const void *)data);
  signed int return_value_stringcmp$18;
  return_value_stringcmp$18=stringcmp(data, "FRUSTUM");
  signed int return_value_stringcmp$17;
  if(return_value_stringcmp$18 == 0)
  {
    fscanf(ph->ifp, "%f %f %f %f", &a, &b, &c, &d);
    rt_camera_frustum(scene, (double)a, (double)b, (double)c, (double)d);
    fscanf(ph->ifp, "%s", (const void *)data);
    signed int return_value_stringcmp$16;
    return_value_stringcmp$16=stringcmp(data, "END_CAMERA");
    if(!(return_value_stringcmp$16 == 0))
    {
      rc = rc | (unsigned int)4;
      return rc;
    }

  }

  else
  {
    return_value_stringcmp$17=stringcmp(data, "END_CAMERA");
    if(!(return_value_stringcmp$17 == 0))
    {
      rc = rc | (unsigned int)4;
      return rc;
    }

  }
  return rc;
}

// c::GetClipGroup
// file ../demosrc/parse.c line 1722
static unsigned int GetClipGroup(struct anon$6 *ph, void *scene)
{
  char objtype[256l];
  signed int return_value_fscanf$1;
  return_value_fscanf$1=fscanf(ph->ifp, "%s", (const void *)objtype);
  if(return_value_fscanf$1 == -1)
    return (unsigned int)8;

  signed int return_value_stringcmp$5;
  return_value_stringcmp$5=stringcmp(objtype, "NUMPLANES");
  if(return_value_stringcmp$5 == 0)
  {
    signed int numplanes;
    signed int i;
    float *planes;
    signed int return_value_fscanf$2;
    return_value_fscanf$2=fscanf(ph->ifp, "%d", &numplanes);
    if(!(return_value_fscanf$2 == 1))
      return (unsigned int)4;

    void *return_value_malloc$3;
    return_value_malloc$3=malloc((unsigned long int)(numplanes * 4) * 4ul /*[[float]]*/);
    planes = (float *)return_value_malloc$3;
    i = 0;
    while(!(i >= 4 * numplanes))
    {
      signed int return_value_fscanf$4;
      return_value_fscanf$4=fscanf(ph->ifp, "%f", &planes[(signed long int)i]);
      if(!(return_value_fscanf$4 == 1))
        return (unsigned int)4;

      i = i + 1;
    }
    rt_clip_fv(scene, numplanes, planes);
    free((void *)planes);
    return (unsigned int)0;
  }

  return (unsigned int)4;
}

// c::GetClipGroupEnd
// file ../demosrc/parse.c line 1753
static unsigned int GetClipGroupEnd(struct anon$6 *ph, void *scene)
{
  rt_clip_off(scene);
  return (unsigned int)0;
}

// c::GetColor
// file ../demosrc/parse.c line 621
static unsigned int GetColor(struct anon$6 *ph, struct anon$4 *c1)
{
  float r;
  float g;
  float b;
  signed int rc;
  unsigned int return_value_GetString$1;
  return_value_GetString$1=GetString(ph, "COLOR");
  rc = (signed int)return_value_GetString$1;
  fscanf(ph->ifp, "%f %f %f", &r, &g, &b);
  c1->r = r;
  c1->g = g;
  c1->b = b;
  return (unsigned int)rc;
}

// c::GetCylinder
// file ../demosrc/parse.c line 1111
static unsigned int GetCylinder(struct anon$6 *ph, void *scene)
{
  double rad;
  struct anon$0 ctr;
  struct anon$0 axis;
  void *tex;
  float a;
  unsigned int rc;
  rc=GetString(ph, "CENTER");
  unsigned int return_value_GetVector$1;
  return_value_GetVector$1=GetVector(ph, &ctr);
  rc = rc | return_value_GetVector$1;
  unsigned int return_value_GetString$2;
  return_value_GetString$2=GetString(ph, "AXIS");
  rc = rc | return_value_GetString$2;
  unsigned int return_value_GetVector$3;
  return_value_GetVector$3=GetVector(ph, &axis);
  rc = rc | return_value_GetVector$3;
  unsigned int return_value_GetString$4;
  return_value_GetString$4=GetString(ph, "RAD");
  rc = rc | return_value_GetString$4;
  fscanf(ph->ifp, "%f", &a);
  rad = (double)a;
  unsigned int return_value_GetTexture$5;
  return_value_GetTexture$5=GetTexture(ph, scene, &tex);
  rc = rc | return_value_GetTexture$5;
  rt_cylinder(scene, tex, ctr, axis, rad);
  return rc;
}

// c::GetDirLight
// file ../demosrc/parse.c line 909
static unsigned int GetDirLight(struct anon$6 *ph, void *scene)
{
  char tmp[255l];
  struct anon$0 dir;
  struct anon$7 tex;
  float r;
  float g;
  float b;
  unsigned int rc;
  memset((void *)&tex, 0, 296ul /*[[struct anon$7]]*/);
  rc=GetString(ph, "DIRECTION");
  unsigned int return_value_GetVector$1;
  return_value_GetVector$1=GetVector(ph, &dir);
  rc = rc | return_value_GetVector$1;
  fscanf(ph->ifp, "%s", (const void *)tmp);
  signed int return_value_stringcmp$3;
  return_value_stringcmp$3=stringcmp(tmp, "COLOR");
  if(return_value_stringcmp$3 == 0)
  {
    fscanf(ph->ifp, "%f %f %f", &r, &g, &b);
    tex.col.r = r;
    tex.col.g = g;
    tex.col.b = b;
    void *return_value_rt_texture$2;
    return_value_rt_texture$2=rt_texture(scene, &tex);
    rt_directional_light(scene, return_value_rt_texture$2, dir);
  }

  return rc;
}

// c::GetFCylinder
// file ../demosrc/parse.c line 1132
static unsigned int GetFCylinder(struct anon$6 *ph, void *scene)
{
  double rad;
  struct anon$0 ctr;
  struct anon$0 axis;
  struct anon$0 pnt1 = (struct anon$0){ .x=(double)0, .y=(double)0, .z=(double)0 };
  struct anon$0 pnt2 = (struct anon$0){ .x=(double)0, .y=(double)0, .z=(double)0 };
  void *tex;
  float a;
  unsigned int rc;
  rc=GetString(ph, "BASE");
  unsigned int return_value_GetVector$1;
  return_value_GetVector$1=GetVector(ph, &pnt1);
  rc = rc | return_value_GetVector$1;
  unsigned int return_value_GetString$2;
  return_value_GetString$2=GetString(ph, "APEX");
  rc = rc | return_value_GetString$2;
  unsigned int return_value_GetVector$3;
  return_value_GetVector$3=GetVector(ph, &pnt2);
  rc = rc | return_value_GetVector$3;
  ctr = pnt1;
  axis.x = pnt2.x - pnt1.x;
  axis.y = pnt2.y - pnt1.y;
  axis.z = pnt2.z - pnt1.z;
  unsigned int return_value_GetString$4;
  return_value_GetString$4=GetString(ph, "RAD");
  rc = rc | return_value_GetString$4;
  fscanf(ph->ifp, "%f", &a);
  rad = (double)a;
  unsigned int return_value_GetTexture$5;
  return_value_GetTexture$5=GetTexture(ph, scene, &tex);
  rc = rc | return_value_GetTexture$5;
  rt_fcylinder(scene, tex, ctr, axis, rad);
  return rc;
}

// c::GetFog
// file ../demosrc/parse.c line 1062
static unsigned int GetFog(struct anon$6 *ph, void *scene)
{
  char tmp[255l];
  struct anon$4 fogcol;
  float start;
  float end;
  float density;
  unsigned int rc = (unsigned int)0;
  fscanf(ph->ifp, "%s", (const void *)tmp);
  signed int return_value_stringcmp$4;
  return_value_stringcmp$4=stringcmp(tmp, "LINEAR");
  signed int return_value_stringcmp$3;
  signed int return_value_stringcmp$2;
  signed int return_value_stringcmp$1;
  if(return_value_stringcmp$4 == 0)
    rt_fog_mode(scene, 1);

  else
  {
    return_value_stringcmp$3=stringcmp(tmp, "EXP");
    if(return_value_stringcmp$3 == 0)
      rt_fog_mode(scene, 2);

    else
    {
      return_value_stringcmp$2=stringcmp(tmp, "EXP2");
      if(return_value_stringcmp$2 == 0)
        rt_fog_mode(scene, 3);

      else
      {
        return_value_stringcmp$1=stringcmp(tmp, "OFF");
        if(return_value_stringcmp$1 == 0)
          rt_fog_mode(scene, 0);

      }
    }
  }
  unsigned int return_value_GetString$5;
  return_value_GetString$5=GetString(ph, "START");
  rc = rc | return_value_GetString$5;
  fscanf(ph->ifp, "%f", &start);
  unsigned int return_value_GetString$6;
  return_value_GetString$6=GetString(ph, "END");
  rc = rc | return_value_GetString$6;
  fscanf(ph->ifp, "%f", &end);
  unsigned int return_value_GetString$7;
  return_value_GetString$7=GetString(ph, "DENSITY");
  rc = rc | return_value_GetString$7;
  fscanf(ph->ifp, "%f", &density);
  unsigned int return_value_GetColor$8;
  return_value_GetColor$8=GetColor(ph, &fogcol);
  rc = rc | return_value_GetColor$8;
  rt_fog_parms(scene, fogcol, (double)start, (double)end, (double)density);
  return (unsigned int)0;
}

// c::GetImageDef
// file ../demosrc/parse.c line 634
static unsigned int GetImageDef(struct anon$6 *ph, void *scene)
{
  char texname[255l];
  signed int x;
  signed int y;
  signed int z;
  signed int rc;
  unsigned char *rgb = (unsigned char *)NULL;
  signed int xres = 0;
  signed int yres = 0;
  signed int zres = 0;
  fscanf(ph->ifp, "%s", (const void *)texname);
  unsigned int return_value_GetString$1;
  return_value_GetString$1=GetString(ph, "FORMAT");
  rc = (signed int)return_value_GetString$1;
  unsigned int return_value_GetString$2;
  return_value_GetString$2=GetString(ph, "RGB24");
  rc = rc | (signed int)return_value_GetString$2;
  unsigned int return_value_GetString$3;
  return_value_GetString$3=GetString(ph, "RESOLUTION");
  rc = rc | (signed int)return_value_GetString$3;
  unsigned int return_value_GetInt$4;
  return_value_GetInt$4=GetInt(ph, &xres);
  rc = rc | (signed int)return_value_GetInt$4;
  unsigned int return_value_GetInt$5;
  return_value_GetInt$5=GetInt(ph, &yres);
  rc = rc | (signed int)return_value_GetInt$5;
  unsigned int return_value_GetInt$6;
  return_value_GetInt$6=GetInt(ph, &zres);
  rc = rc | (signed int)return_value_GetInt$6;
  void *return_value_malloc$7;
  return_value_malloc$7=malloc((unsigned long int)(xres * yres * zres * 3));
  rgb = (unsigned char *)return_value_malloc$7;
  unsigned int return_value_GetString$8;
  return_value_GetString$8=GetString(ph, "ENCODING");
  rc = rc | (signed int)return_value_GetString$8;
  unsigned int return_value_GetString$9;
  return_value_GetString$9=GetString(ph, "HEX");
  rc = rc | (signed int)return_value_GetString$9;
  z = 0;
  while(!(z >= zres))
  {
    y = 0;
    while(!(y >= yres))
    {
      x = 0;
      while(!(x >= xres))
      {
        char clrstr[1024l];
        signed int red;
        signed int green;
        signed int blue;
        signed int addr = (z * xres * yres + y * xres + x) * 3;
        signed int n = 0;
        fscanf(ph->ifp, "%s", (const void *)clrstr);
        unsigned long int return_value_strlen$10;
        return_value_strlen$10=strlen(clrstr);
        switch(return_value_strlen$10)
        {

          case (unsigned long int)3:
            {
              n=sscanf(clrstr, "%01x%01x%01x", &red, &green, &blue);
              red = red | red << 4;
              green = green | green << 4;
              blue = blue | blue << 4;
              goto __CPROVER_DUMP_L8;
            }
          case (unsigned long int)6:
            {
              n=sscanf(clrstr, "%02x%02x%02x", &red, &green, &blue);
              goto __CPROVER_DUMP_L8;
            }
          case (unsigned long int)9:
            {
              n=sscanf(clrstr, "%03x%03x%03x", &red, &green, &blue);
              red = red >> 4;
              green = green >> 4;
              blue = blue >> 4;
              goto __CPROVER_DUMP_L8;
            }
          case (unsigned long int)12:
            {
              n=sscanf(clrstr, "%04x%04x%04x", &red, &green, &blue);
              red = red >> 8;
              green = green >> 8;
              blue = blue >> 8;
            }
          default:
            {

            __CPROVER_DUMP_L8:
              ;
              if(!(n == 3))
                rc = rc | 4;

              rgb[(signed long int)addr] = (unsigned char)(red & 255);
              rgb[(signed long int)(addr + 1)] = (unsigned char)(green & 255);
              rgb[(signed long int)(addr + 2)] = (unsigned char)(blue & 255);
              x = x + 1;
            }
        }
      }
      y = y + 1;
    }
    z = z + 1;
  }
  if(rc == 0)
    rt_define_image(texname, xres, yres, zres, rgb);

  return (unsigned int)rc;
}

// c::GetInt
// file ../demosrc/parse.c line 586
static unsigned int GetInt(struct anon$6 *ph, signed int *i)
{
  signed int a;
  signed int return_value_fscanf$1;
  return_value_fscanf$1=fscanf(ph->ifp, "%d", &a);
  if(!(return_value_fscanf$1 == 1))
    return (unsigned int)4;

  *i = a;
  return (unsigned int)0;
}

// c::GetLandScape
// file ../demosrc/parse.c line 1627
static unsigned int GetLandScape(struct anon$6 *ph, void *scene)
{
  void *tex;
  struct anon$0 ctr;
  double wx;
  double wy;
  signed int m;
  signed int n;
  float a;
  float b;
  unsigned int rc;
  rc=GetString(ph, "RES");
  fscanf(ph->ifp, "%d %d", &m, &n);
  unsigned int return_value_GetString$1;
  return_value_GetString$1=GetString(ph, "SCALE");
  rc = rc | return_value_GetString$1;
  fscanf(ph->ifp, "%f %f", &a, &b);
  wx = (double)a;
  wy = (double)b;
  unsigned int return_value_GetString$2;
  return_value_GetString$2=GetString(ph, "CENTER");
  rc = rc | return_value_GetString$2;
  unsigned int return_value_GetVector$3;
  return_value_GetVector$3=GetVector(ph, &ctr);
  rc = rc | return_value_GetVector$3;
  unsigned int return_value_GetTexture$4;
  return_value_GetTexture$4=GetTexture(ph, scene, &tex);
  rc = rc | return_value_GetTexture$4;
  rt_landscape(scene, tex, m, n, ctr, wx, wy);
  return rc;
}

// c::GetLight
// file ../demosrc/parse.c line 934
static unsigned int GetLight(struct anon$6 *ph, void *scene)
{
  char tmp[255l];
  double rad;
  double Kc;
  double Kl;
  double Kq;
  struct anon$0 ctr;
  struct anon$7 tex;
  float r;
  float g;
  float b;
  float a;
  unsigned int rc;
  void *li;
  memset((void *)&tex, 0, 296ul /*[[struct anon$7]]*/);
  rc=GetString(ph, "CENTER");
  unsigned int return_value_GetVector$1;
  return_value_GetVector$1=GetVector(ph, &ctr);
  rc = rc | return_value_GetVector$1;
  unsigned int return_value_GetString$2;
  return_value_GetString$2=GetString(ph, "RAD");
  rc = rc | return_value_GetString$2;
  fscanf(ph->ifp, "%f", &a);
  rad = (double)a;
  fscanf(ph->ifp, "%s", (const void *)tmp);
  signed int return_value_stringcmp$10;
  return_value_stringcmp$10=stringcmp(tmp, "COLOR");
  if(return_value_stringcmp$10 == 0)
  {
    fscanf(ph->ifp, "%f %f %f", &r, &g, &b);
    tex.col.r = r;
    tex.col.g = g;
    tex.col.b = b;
    void *return_value_rt_texture$3;
    return_value_rt_texture$3=rt_texture(scene, &tex);
    li=rt_light(scene, return_value_rt_texture$3, ctr, rad);
  }

  else
  {
    signed int return_value_stringcmp$4;
    return_value_stringcmp$4=stringcmp(tmp, "ATTENUATION");
    if(!(return_value_stringcmp$4 == 0))
      return (unsigned int)-1;

    unsigned int return_value_GetString$5;
    return_value_GetString$5=GetString(ph, "CONSTANT");
    rc = rc | return_value_GetString$5;
    fscanf(ph->ifp, "%f", &a);
    Kc = (double)a;
    unsigned int return_value_GetString$6;
    return_value_GetString$6=GetString(ph, "LINEAR");
    rc = rc | return_value_GetString$6;
    fscanf(ph->ifp, "%f", &a);
    Kl = (double)a;
    unsigned int return_value_GetString$7;
    return_value_GetString$7=GetString(ph, "QUADRATIC");
    rc = rc | return_value_GetString$7;
    fscanf(ph->ifp, "%f", &a);
    Kq = (double)a;
    unsigned int return_value_GetColor$8;
    return_value_GetColor$8=GetColor(ph, &tex.col);
    rc = rc | return_value_GetColor$8;
    void *return_value_rt_texture$9;
    return_value_rt_texture$9=rt_texture(scene, &tex);
    li=rt_light(scene, return_value_rt_texture$9, ctr, rad);
    rt_light_attenuation(li, Kc, Kl, Kq);
  }
  return rc;
}

// c::GetMaterial
// file ../demosrc/ac3dparse.c line 198
static unsigned int GetMaterial(struct _IO_FILE$link6 *dfile, void *scene)
{
  struct anon$7 tex;
  float a;
  float b;
  float c;
  float d;
  signed int e;
  unsigned int rc;
  char texname[24l];
  fscanf(dfile, "%s", (const void *)texname);
  rc=GetString$link57(dfile, "RGB");
  fscanf(dfile, "%f %f %f", &a, &b, &c);
  tex.col.r = a;
  tex.col.g = b;
  tex.col.b = c;
  tex.diffuse = (double)(a + b + c) / 3.000000;
  rc=GetString$link57(dfile, "AMB");
  fscanf(dfile, "%f %f %f", &a, &b, &c);
  tex.ambient = (double)(a + b + c) / 3.000000;
  unsigned int return_value_GetString$1;
  return_value_GetString$1=GetString$link57(dfile, "EMIS");
  rc = rc | return_value_GetString$1;
  fscanf(dfile, "%f %f %f", &a, &b, &c);
  unsigned int return_value_GetString$2;
  return_value_GetString$2=GetString$link57(dfile, "SPEC");
  rc = rc | return_value_GetString$2;
  fscanf(dfile, "%f %f %f", &a, &b, &c);
  tex.specular = (double)(a + b + c) / 3.000000;
  unsigned int return_value_GetString$3;
  return_value_GetString$3=GetString$link57(dfile, "SHI");
  rc = rc | return_value_GetString$3;
  fscanf(dfile, "%d", &e);
  unsigned int return_value_GetString$4;
  return_value_GetString$4=GetString$link57(dfile, "TRANS");
  rc = rc | return_value_GetString$4;
  fscanf(dfile, "%f", &d);
  tex.opacity = (double)d > 9.900000e-1 ? 0.000000 : 1.000000 - (double)d;
  tex.texturefunc = 0;
  void *return_value_rt_texture$5;
  return_value_rt_texture$5=rt_texture(scene, &tex);
  add_texture$link50(return_value_rt_texture$5, texname);
  return rc;
}

// c::GetObject
// file ../demosrc/parse.c line 469
static unsigned int GetObject(struct anon$6 *ph, void *scene)
{
  char objtype[256l];
  signed int return_value_fscanf$1;
  return_value_fscanf$1=fscanf(ph->ifp, "%s", (const void *)objtype);
  if(return_value_fscanf$1 == -1)
    return (unsigned int)8;

  signed int return_value_stringcmp$3;
  return_value_stringcmp$3=stringcmp(objtype, "TRI");
  if(return_value_stringcmp$3 == 0)
  {
    unsigned int return_value_GetTri$2;
    return_value_GetTri$2=GetTri(ph, scene);
    return return_value_GetTri$2;
  }

  signed int return_value_stringcmp$5;
  return_value_stringcmp$5=stringcmp(objtype, "STRI");
  if(return_value_stringcmp$5 == 0)
  {
    unsigned int return_value_GetSTri$4;
    return_value_GetSTri$4=GetSTri(ph, scene);
    return return_value_GetSTri$4;
  }

  signed int return_value_stringcmp$7;
  return_value_stringcmp$7=stringcmp(objtype, "VCSTRI");
  if(return_value_stringcmp$7 == 0)
  {
    unsigned int return_value_GetVCSTri$6;
    return_value_GetVCSTri$6=GetVCSTri(ph, scene);
    return return_value_GetVCSTri$6;
  }

  signed int return_value_stringcmp$9;
  return_value_stringcmp$9=stringcmp(objtype, "VERTEXARRAY");
  if(return_value_stringcmp$9 == 0)
  {
    unsigned int return_value_GetVertexArray$8;
    return_value_GetVertexArray$8=GetVertexArray(ph, scene);
    return return_value_GetVertexArray$8;
  }

  signed int return_value_stringcmp$11;
  return_value_stringcmp$11=stringcmp(objtype, "SPHERE");
  if(return_value_stringcmp$11 == 0)
  {
    unsigned int return_value_GetSphere$10;
    return_value_GetSphere$10=GetSphere(ph, scene);
    return return_value_GetSphere$10;
  }

  signed int return_value_stringcmp$13;
  return_value_stringcmp$13=stringcmp(objtype, "FCYLINDER");
  if(return_value_stringcmp$13 == 0)
  {
    unsigned int return_value_GetFCylinder$12;
    return_value_GetFCylinder$12=GetFCylinder(ph, scene);
    return return_value_GetFCylinder$12;
  }

  signed int return_value_stringcmp$15;
  return_value_stringcmp$15=stringcmp(objtype, "RING");
  if(return_value_stringcmp$15 == 0)
  {
    unsigned int return_value_GetRing$14;
    return_value_GetRing$14=GetRing(ph, scene);
    return return_value_GetRing$14;
  }

  signed int return_value_stringcmp$17;
  return_value_stringcmp$17=stringcmp(objtype, "POLYCYLINDER");
  if(return_value_stringcmp$17 == 0)
  {
    unsigned int return_value_GetPolyCylinder$16;
    return_value_GetPolyCylinder$16=GetPolyCylinder(ph, scene);
    return return_value_GetPolyCylinder$16;
  }

  signed int return_value_stringcmp$19;
  return_value_stringcmp$19=stringcmp(objtype, "CYLINDER");
  if(return_value_stringcmp$19 == 0)
  {
    unsigned int return_value_GetCylinder$18;
    return_value_GetCylinder$18=GetCylinder(ph, scene);
    return return_value_GetCylinder$18;
  }

  signed int return_value_stringcmp$21;
  return_value_stringcmp$21=stringcmp(objtype, "PLANE");
  if(return_value_stringcmp$21 == 0)
  {
    unsigned int return_value_GetPlane$20;
    return_value_GetPlane$20=GetPlane(ph, scene);
    return return_value_GetPlane$20;
  }

  signed int return_value_stringcmp$23;
  return_value_stringcmp$23=stringcmp(objtype, "BOX");
  if(return_value_stringcmp$23 == 0)
  {
    unsigned int return_value_GetBox$22;
    return_value_GetBox$22=GetBox(ph, scene);
    return return_value_GetBox$22;
  }

  signed int return_value_stringcmp$25;
  return_value_stringcmp$25=stringcmp(objtype, "SCALARVOL");
  if(return_value_stringcmp$25 == 0)
  {
    unsigned int return_value_GetVol$24;
    return_value_GetVol$24=GetVol(ph, scene);
    return return_value_GetVol$24;
  }

  signed int return_value_stringcmp$27;
  return_value_stringcmp$27=stringcmp(objtype, "IMAGEDEF");
  if(return_value_stringcmp$27 == 0)
  {
    unsigned int return_value_GetImageDef$26;
    return_value_GetImageDef$26=GetImageDef(ph, scene);
    return return_value_GetImageDef$26;
  }

  signed int return_value_stringcmp$29;
  return_value_stringcmp$29=stringcmp(objtype, "TEXDEF");
  if(return_value_stringcmp$29 == 0)
  {
    unsigned int return_value_GetTexDef$28;
    return_value_GetTexDef$28=GetTexDef(ph, scene);
    return return_value_GetTexDef$28;
  }

  signed int return_value_stringcmp$31;
  return_value_stringcmp$31=stringcmp(objtype, "TEXALIAS");
  if(return_value_stringcmp$31 == 0)
  {
    unsigned int return_value_GetTexAlias$30;
    return_value_GetTexAlias$30=GetTexAlias(ph);
    return return_value_GetTexAlias$30;
  }

  signed int return_value_stringcmp$33;
  return_value_stringcmp$33=stringcmp(objtype, "LIGHT");
  if(return_value_stringcmp$33 == 0)
  {
    unsigned int return_value_GetLight$32;
    return_value_GetLight$32=GetLight(ph, scene);
    return return_value_GetLight$32;
  }

  signed int return_value_stringcmp$35;
  return_value_stringcmp$35=stringcmp(objtype, "DIRECTIONAL_LIGHT");
  if(return_value_stringcmp$35 == 0)
  {
    unsigned int return_value_GetDirLight$34;
    return_value_GetDirLight$34=GetDirLight(ph, scene);
    return return_value_GetDirLight$34;
  }

  signed int return_value_stringcmp$37;
  return_value_stringcmp$37=stringcmp(objtype, "SKY_LIGHT");
  if(return_value_stringcmp$37 == 0)
  {
    unsigned int return_value_GetSkyLight$36;
    return_value_GetSkyLight$36=GetSkyLight(ph, scene);
    return return_value_GetSkyLight$36;
  }

  signed int return_value_stringcmp$39;
  return_value_stringcmp$39=stringcmp(objtype, "SPOTLIGHT");
  if(return_value_stringcmp$39 == 0)
  {
    unsigned int return_value_GetSpotLight$38;
    return_value_GetSpotLight$38=GetSpotLight(ph, scene);
    return return_value_GetSpotLight$38;
  }

  signed int return_value_stringcmp$41;
  return_value_stringcmp$41=stringcmp(objtype, "SCAPE");
  if(return_value_stringcmp$41 == 0)
  {
    unsigned int return_value_GetLandScape$40;
    return_value_GetLandScape$40=GetLandScape(ph, scene);
    return return_value_GetLandScape$40;
  }

  signed int return_value_stringcmp$43;
  return_value_stringcmp$43=stringcmp(objtype, "SHADER_MODE");
  if(return_value_stringcmp$43 == 0)
  {
    unsigned int return_value_GetShaderMode$42;
    return_value_GetShaderMode$42=GetShaderMode(ph, scene);
    return return_value_GetShaderMode$42;
  }

  signed int return_value_stringcmp$45;
  return_value_stringcmp$45=stringcmp(objtype, "CAMERA");
  if(return_value_stringcmp$45 == 0)
  {
    unsigned int return_value_GetCamera$44;
    return_value_GetCamera$44=GetCamera(ph, scene);
    return return_value_GetCamera$44;
  }

  signed int return_value_stringcmp$47;
  return_value_stringcmp$47=stringcmp(objtype, "TPOLYFILE");
  if(return_value_stringcmp$47 == 0)
  {
    unsigned int return_value_GetTPolyFile$46;
    return_value_GetTPolyFile$46=GetTPolyFile(ph, scene);
    return return_value_GetTPolyFile$46;
  }

  signed int return_value_stringcmp$48;
  return_value_stringcmp$48=stringcmp(objtype, "MGFFILE");
  if(return_value_stringcmp$48 == 0)
  {
    printf("MGF File Parsing is not available in this build.\n");
    return (unsigned int)4;
  }

  signed int return_value_stringcmp$49;
  return_value_stringcmp$49=stringcmp(objtype, "#");
  if(return_value_stringcmp$49 == 0)
  {
    signed int c;
    while(TRUE)
    {
      c=fgetc(ph->ifp);
      if(!(c == -1))
      {
        if(c == 10)
          goto __CPROVER_DUMP_L27;

      }

      else
      {

      __CPROVER_DUMP_L27:
        ;
        return (unsigned int)0;
      }
    }
  }

  signed int return_value_stringcmp$51;
  return_value_stringcmp$51=stringcmp(objtype, "BACKGROUND");
  if(return_value_stringcmp$51 == 0)
  {
    unsigned int return_value_GetBackGnd$50;
    return_value_GetBackGnd$50=GetBackGnd(ph, scene);
    return return_value_GetBackGnd$50;
  }

  signed int return_value_stringcmp$53;
  return_value_stringcmp$53=stringcmp(objtype, "FOG");
  if(return_value_stringcmp$53 == 0)
  {
    unsigned int return_value_GetFog$52;
    return_value_GetFog$52=GetFog(ph, scene);
    return return_value_GetFog$52;
  }

  signed int return_value_stringcmp$55;
  return_value_stringcmp$55=stringcmp(objtype, "INCLUDE");
  if(return_value_stringcmp$55 == 0)
  {
    char includefile[4096l];
    fscanf(ph->ifp, "%s", (const void *)includefile);
    unsigned int return_value_ReadIncludeFile$54;
    return_value_ReadIncludeFile$54=ReadIncludeFile(ph, includefile, scene);
    return return_value_ReadIncludeFile$54;
  }

  signed int return_value_stringcmp$57;
  return_value_stringcmp$57=stringcmp(objtype, "START_CLIPGROUP");
  if(return_value_stringcmp$57 == 0)
  {
    unsigned int return_value_GetClipGroup$56;
    return_value_GetClipGroup$56=GetClipGroup(ph, scene);
    return return_value_GetClipGroup$56;
  }

  signed int return_value_stringcmp$59;
  return_value_stringcmp$59=stringcmp(objtype, "END_CLIPGROUP");
  if(return_value_stringcmp$59 == 0)
  {
    unsigned int return_value_GetClipGroupEnd$58;
    return_value_GetClipGroupEnd$58=GetClipGroupEnd(ph, scene);
    return return_value_GetClipGroupEnd$58;
  }

  signed int return_value_stringcmp$60;
  return_value_stringcmp$60=stringcmp(objtype, "END_SCENE");
  if(return_value_stringcmp$60 == 0)
    return (unsigned int)8;

  PrintSyntaxError(ph, "an object or other declaration", objtype);
  return (unsigned int)4;
}

// c::GetObject$link86
// file ../demosrc/ac3dparse.c line 578
static unsigned int GetObject$link86(struct _IO_FILE$link6 *dfile, void *scene$link85)
{
  float defaultrmat[3l][3l];
  float defaulttmat[3l];
  unsigned int rc;
  RmatIdentity(defaultrmat);
  defaulttmat[(signed long int)0] = (float)0.000000;
  defaulttmat[(signed long int)1] = (float)0.000000;
  defaulttmat[(signed long int)2] = (float)0.000000;
  rc=GetRecurseObject(scene$link85, dfile, defaultrmat, defaulttmat);
  return rc;
}

// c::GetPlane
// file ../demosrc/parse.c line 1211
static unsigned int GetPlane(struct anon$6 *ph, void *scene)
{
  struct anon$0 normal;
  struct anon$0 ctr;
  void *tex;
  unsigned int rc;
  rc=GetString(ph, "CENTER");
  unsigned int return_value_GetVector$1;
  return_value_GetVector$1=GetVector(ph, &ctr);
  rc = rc | return_value_GetVector$1;
  unsigned int return_value_GetString$2;
  return_value_GetString$2=GetString(ph, "NORMAL");
  rc = rc | return_value_GetString$2;
  unsigned int return_value_GetVector$3;
  return_value_GetVector$3=GetVector(ph, &normal);
  rc = rc | return_value_GetVector$3;
  unsigned int return_value_GetTexture$4;
  return_value_GetTexture$4=GetTexture(ph, scene, &tex);
  rc = rc | return_value_GetTexture$4;
  rt_plane(scene, tex, ctr, normal);
  return rc;
}

// c::GetPolyCylinder
// file ../demosrc/parse.c line 1161
static unsigned int GetPolyCylinder(struct anon$6 *ph, void *scene)
{
  double rad;
  struct anon$0 *temp;
  void *tex;
  float a;
  signed int numpts;
  signed int i;
  unsigned int rc;
  rc=GetString(ph, "POINTS");
  fscanf(ph->ifp, "%d", &numpts);
  void *return_value_malloc$1;
  return_value_malloc$1=malloc((unsigned long int)numpts * 24ul /*[[struct anon$0]]*/);
  temp = (struct anon$0 *)return_value_malloc$1;
  i = 0;
  while(!(i >= numpts))
  {
    unsigned int return_value_GetVector$2;
    return_value_GetVector$2=GetVector(ph, &temp[(signed long int)i]);
    rc = rc | return_value_GetVector$2;
    i = i + 1;
  }
  unsigned int return_value_GetString$3;
  return_value_GetString$3=GetString(ph, "RAD");
  rc = rc | return_value_GetString$3;
  fscanf(ph->ifp, "%f", &a);
  rad = (double)a;
  unsigned int return_value_GetTexture$4;
  return_value_GetTexture$4=GetTexture(ph, scene, &tex);
  rc = rc | return_value_GetTexture$4;
  rt_polycylinder(scene, tex, temp, numpts, rad);
  free((void *)temp);
  return rc;
}

// c::GetRecurseObject
// file ../demosrc/ac3dparse.c line 375
static unsigned int GetRecurseObject(void *scene, struct _IO_FILE$link6 *dfile, float (*rmat)[3l], float *tmat)
{
  char token[256l];
  char objname[128l];
  char name[128l];
  char texname[128l];
  char urlname[100l];
  float localrmat[3l][3l];
  float newrmat[3l][3l];
  float localtmat[3l];
  float newtmat[3l];
  float txrepa;
  float txrepb;
  float a;
  float b;
  signed int numvert;
  signed int numsurf;
  signed int surf;
  signed int materialnum;
  signed int numrefs;
  signed int numkids;
  signed int data;
  signed int i;
  signed int j;
  struct anon$0 *vertexarray = (struct anon$0 *)NULL;
  struct anon$0 *normalarray = (struct anon$0 *)NULL;
  signed int *refarray = (signed int *)NULL;
  struct tri_list_t *tlist = (struct tri_list_t *)NULL;
  unsigned int rc = (unsigned int)0;
  data = 0;
  numkids = data;
  numrefs = numkids;
  materialnum = numrefs;
  surf = materialnum;
  numsurf = surf;
  numvert = numsurf;
  RmatIdentity(localrmat);
  localtmat[(signed long int)0] = (float)0.000000;
  localtmat[(signed long int)1] = (float)0.000000;
  localtmat[(signed long int)2] = (float)0.000000;
  fscanf(dfile, "%s", (const void *)objname);
  fscanf(dfile, "%s", (const void *)token);
  signed int return_value_stringcmp$1;
  return_value_stringcmp$1=stringcmp$link93(token, "NAME");
  if(return_value_stringcmp$1 == 0)
  {
    GetAC3DString(dfile, name);
    fscanf(dfile, "%s", (const void *)token);
  }

  signed int return_value_stringcmp$2;
  return_value_stringcmp$2=stringcmp$link93(token, "DATA");
  if(return_value_stringcmp$2 == 0)
  {
    fscanf(dfile, "%d", &data);
    fscanf(dfile, "%s", (const void *)token);
  }

  signed int return_value_stringcmp$3;
  return_value_stringcmp$3=stringcmp$link93(token, "TEXTURE");
  if(return_value_stringcmp$3 == 0)
  {
    fscanf(dfile, "%s", (const void *)texname);
    fscanf(dfile, "%s", (const void *)token);
  }

  signed int return_value_stringcmp$4;
  return_value_stringcmp$4=stringcmp$link93(token, "TEXREP");
  if(return_value_stringcmp$4 == 0)
  {
    fscanf(dfile, "%f %f", &txrepa, &txrepb);
    fscanf(dfile, "%s", (const void *)token);
  }

  signed int return_value_stringcmp$5;
  return_value_stringcmp$5=stringcmp$link93(token, "ROT");
  if(return_value_stringcmp$5 == 0)
  {
    j = 0;
    while(j < 3)
    {
      i = 0;
      while(i < 3)
      {
        fscanf(dfile, "%f", &localrmat[(signed long int)j][(signed long int)i]);
        i = i + 1;
      }
      j = j + 1;
    }
    fscanf(dfile, "%s", (const void *)token);
  }

  signed int return_value_stringcmp$6;
  return_value_stringcmp$6=stringcmp$link93(token, "LOC");
  if(return_value_stringcmp$6 == 0)
  {
    j = 0;
    while(j < 3)
    {
      fscanf(dfile, "%f", &localtmat[(signed long int)j]);
      j = j + 1;
    }
    fscanf(dfile, "%s", (const void *)token);
  }

  signed int return_value_stringcmp$7;
  return_value_stringcmp$7=stringcmp$link93(token, "ROT");
  if(return_value_stringcmp$7 == 0)
  {
    j = 0;
    while(j < 3)
    {
      i = 0;
      while(i < 3)
      {
        fscanf(dfile, "%f", &localrmat[(signed long int)j][(signed long int)i]);
        i = i + 1;
      }
      j = j + 1;
    }
    fscanf(dfile, "%s", (const void *)token);
  }

  RmatTmatMult(newtmat, rmat, localtmat);
  newtmat[(signed long int)0] = newtmat[(signed long int)0] + tmat[(signed long int)0];
  newtmat[(signed long int)1] = newtmat[(signed long int)1] + tmat[(signed long int)1];
  newtmat[(signed long int)2] = newtmat[(signed long int)2] + tmat[(signed long int)2];
  RmatMult(newrmat, rmat, localrmat);
  signed int return_value_stringcmp$8;
  return_value_stringcmp$8=stringcmp$link93(token, "URL");
  if(return_value_stringcmp$8 == 0)
  {
    fscanf(dfile, "%s", (const void *)urlname);
    fscanf(dfile, "%s", (const void *)token);
  }

  signed int return_value_stringcmp$9;
  return_value_stringcmp$9=stringcmp$link93(token, "TEXTURE");
  if(return_value_stringcmp$9 == 0)
  {
    GetAC3DString(dfile, token);
    fscanf(dfile, "%s", (const void *)token);
  }

  signed int return_value_stringcmp$12;
  return_value_stringcmp$12=stringcmp$link93(token, "NUMVERT");
  if(return_value_stringcmp$12 == 0)
  {
    float vtx[3l];
    float tvtx[3l];
    fscanf(dfile, "%d", &numvert);
    void *return_value_malloc$10;
    return_value_malloc$10=malloc((unsigned long int)numvert * 24ul /*[[struct anon$0]]*/);
    vertexarray = (struct anon$0 *)return_value_malloc$10;
    void *return_value_malloc$11;
    return_value_malloc$11=malloc((unsigned long int)numvert * 24ul /*[[struct anon$0]]*/);
    normalarray = (struct anon$0 *)return_value_malloc$11;
    clear_normals(normalarray, numvert);
    i = 0;
    while(!(i >= numvert))
    {
      fscanf(dfile, "%f %f %f", &vtx[(signed long int)0], &vtx[(signed long int)1], &vtx[(signed long int)2]);
      RmatTmatMult(tvtx, newrmat, vtx);
      (vertexarray + (signed long int)i)->x = (double)(tvtx[(signed long int)0] + newtmat[(signed long int)0]);
      (vertexarray + (signed long int)i)->y = (double)(tvtx[(signed long int)1] + newtmat[(signed long int)1]);
      (vertexarray + (signed long int)i)->z = (double)(tvtx[(signed long int)2] + newtmat[(signed long int)2]);
      i = i + 1;
    }
    fscanf(dfile, "%s", (const void *)token);
  }

  signed int return_value_stringcmp$17;
  return_value_stringcmp$17=stringcmp$link93(token, "NUMSURF");
  if(return_value_stringcmp$17 == 0)
  {
    fscanf(dfile, "%d", &numsurf);
    fscanf(dfile, "%s", (const void *)token);
    j = 0;
    while(!(j >= numsurf))
    {
      materialnum = 0;
      surf = materialnum;
      numrefs = surf;
      signed int return_value_stringcmp$13;
      return_value_stringcmp$13=stringcmp$link93(token, "SURF");
      if(return_value_stringcmp$13 == 0)
      {
        fscanf(dfile, "%s", (const void *)token);
        sscanf(token, "%x", &surf);
        fscanf(dfile, "%s", (const void *)token);
      }

      signed int return_value_stringcmp$14;
      return_value_stringcmp$14=stringcmp$link93(token, "MAT");
      if(return_value_stringcmp$14 == 0)
      {
        fscanf(dfile, "%d", &materialnum);
        fscanf(dfile, "%s", (const void *)token);
      }

      signed int return_value_stringcmp$15;
      return_value_stringcmp$15=stringcmp$link93(token, "REFS");
      if(return_value_stringcmp$15 == 0)
        fscanf(dfile, "%d", &numrefs);

      else
      {
        rc = rc | (unsigned int)4;
        return rc;
      }
      void *return_value_malloc$16;
      return_value_malloc$16=malloc((unsigned long int)numrefs * 4ul /*[[signed int]]*/);
      refarray = (signed int *)return_value_malloc$16;
      i = 0;
      while(!(i >= numrefs))
      {
        fscanf(dfile, "%d %f %f", &refarray[(signed long int)i], &a, &b);
        i = i + 1;
      }
      if((15 & surf) == 0)
      {
        signed int v0;
        signed int vold;
        signed int vnew;
        struct anon$0 trinorm;
        trinorm=tri_normal(&vertexarray[(signed long int)refarray[(signed long int)1]], &vertexarray[(signed long int)refarray[(signed long int)0]], &vertexarray[(signed long int)refarray[(signed long int)2]]);
        i = 0;
        while(!(i >= numrefs))
        {
          (normalarray + (signed long int)refarray[(signed long int)i])->x = (normalarray + (signed long int)refarray[(signed long int)i])->x + trinorm.x;
          (normalarray + (signed long int)refarray[(signed long int)i])->y = (normalarray + (signed long int)refarray[(signed long int)i])->y + trinorm.y;
          (normalarray + (signed long int)refarray[(signed long int)i])->z = (normalarray + (signed long int)refarray[(signed long int)i])->z + trinorm.z;
          i = i + 1;
        }
        v0 = refarray[(signed long int)0];
        vold = refarray[(signed long int)1];
        i = 2;
        while(!(i >= numrefs))
        {
          vnew = refarray[(signed long int)i];
          tlist_add_tri(&tlist, vold, v0, vnew, surf & 16, materialnum);
          vold = vnew;
          i = i + 1;
        }
      }

      free((void *)refarray);
      refarray = (signed int *)NULL;
      fscanf(dfile, "%s", (const void *)token);
      j = j + 1;
    }
  }

  if(!(vertexarray == ((struct anon$0 *)NULL)))
  {
    if(!(normalarray == ((struct anon$0 *)NULL)))
    {
      renormalize_normals(normalarray, numvert);
      gen_triangles(scene, tlist, vertexarray, normalarray);
      tlist_delete(&tlist);
    }

  }

  if(!(vertexarray == ((struct anon$0 *)NULL)))
    free((void *)vertexarray);

  vertexarray = (struct anon$0 *)NULL;
  if(!(normalarray == ((struct anon$0 *)NULL)))
    free((void *)normalarray);

  normalarray = (struct anon$0 *)NULL;
  signed int return_value_stringcmp$18;
  return_value_stringcmp$18=stringcmp$link93(token, "KIDS");
  if(return_value_stringcmp$18 == 0)
    fscanf(dfile, "%d", &numkids);

  else
  {
    rc = rc | (unsigned int)4;
    return rc;
  }
  while(numkids > 0)
  {
    unsigned int return_value_GetString$19;
    return_value_GetString$19=GetString$link57(dfile, "OBJECT");
    rc = rc | return_value_GetString$19;
    unsigned int return_value_GetRecurseObject$20;
    return_value_GetRecurseObject$20=GetRecurseObject(scene, dfile, newrmat, newtmat);
    rc = rc | return_value_GetRecurseObject$20;
    numkids = numkids - 1;
  }
  return rc;
}

// c::GetRing
// file ../demosrc/parse.c line 1266
static unsigned int GetRing(struct anon$6 *ph, void *scene)
{
  struct anon$0 normal;
  struct anon$0 ctr;
  void *tex;
  float a;
  float b;
  unsigned int rc;
  rc=GetString(ph, "CENTER");
  unsigned int return_value_GetVector$1;
  return_value_GetVector$1=GetVector(ph, &ctr);
  rc = rc | return_value_GetVector$1;
  unsigned int return_value_GetString$2;
  return_value_GetString$2=GetString(ph, "NORMAL");
  rc = rc | return_value_GetString$2;
  unsigned int return_value_GetVector$3;
  return_value_GetVector$3=GetVector(ph, &normal);
  rc = rc | return_value_GetVector$3;
  unsigned int return_value_GetString$4;
  return_value_GetString$4=GetString(ph, "INNER");
  rc = rc | return_value_GetString$4;
  fscanf(ph->ifp, " %f ", &a);
  unsigned int return_value_GetString$5;
  return_value_GetString$5=GetString(ph, "OUTER");
  rc = rc | return_value_GetString$5;
  fscanf(ph->ifp, " %f ", &b);
  unsigned int return_value_GetTexture$6;
  return_value_GetTexture$6=GetTexture(ph, scene, &tex);
  rc = rc | return_value_GetTexture$6;
  rt_ring(scene, tex, ctr, normal, (double)a, (double)b);
  return rc;
}

// c::GetSTri
// file ../demosrc/parse.c line 1309
static unsigned int GetSTri(struct anon$6 *ph, void *scene)
{
  struct anon$0 v0;
  struct anon$0 v1;
  struct anon$0 v2;
  struct anon$0 n0;
  struct anon$0 n1;
  struct anon$0 n2;
  void *tex;
  unsigned int rc;
  rc=GetString(ph, "V0");
  unsigned int return_value_GetVector$1;
  return_value_GetVector$1=GetVector(ph, &v0);
  rc = rc | return_value_GetVector$1;
  unsigned int return_value_GetString$2;
  return_value_GetString$2=GetString(ph, "V1");
  rc = rc | return_value_GetString$2;
  unsigned int return_value_GetVector$3;
  return_value_GetVector$3=GetVector(ph, &v1);
  rc = rc | return_value_GetVector$3;
  unsigned int return_value_GetString$4;
  return_value_GetString$4=GetString(ph, "V2");
  rc = rc | return_value_GetString$4;
  unsigned int return_value_GetVector$5;
  return_value_GetVector$5=GetVector(ph, &v2);
  rc = rc | return_value_GetVector$5;
  unsigned int return_value_GetString$6;
  return_value_GetString$6=GetString(ph, "N0");
  rc = rc | return_value_GetString$6;
  unsigned int return_value_GetVector$7;
  return_value_GetVector$7=GetVector(ph, &n0);
  rc = rc | return_value_GetVector$7;
  unsigned int return_value_GetString$8;
  return_value_GetString$8=GetString(ph, "N1");
  rc = rc | return_value_GetString$8;
  unsigned int return_value_GetVector$9;
  return_value_GetVector$9=GetVector(ph, &n1);
  rc = rc | return_value_GetVector$9;
  unsigned int return_value_GetString$10;
  return_value_GetString$10=GetString(ph, "N2");
  rc = rc | return_value_GetString$10;
  unsigned int return_value_GetVector$11;
  return_value_GetVector$11=GetVector(ph, &n2);
  rc = rc | return_value_GetVector$11;
  unsigned int return_value_GetTexture$12;
  return_value_GetTexture$12=GetTexture(ph, scene, &tex);
  rc = rc | return_value_GetTexture$12;
  rt_stri(scene, tex, v0, v1, v2, n0, n1, n2);
  return rc;
}

// c::GetScene
// file ../demosrc/ac3dparse.c line 181
static unsigned int GetScene(struct _IO_FILE$link6 *dfile, void *scene)
{
  char objtype[80l];
  signed int return_value_fscanf$1;
  return_value_fscanf$1=fscanf(dfile, "%s", (const void *)objtype);
  if(!(return_value_fscanf$1 == 1))
    return (unsigned int)8;

  signed int return_value_stringcmp$3;
  return_value_stringcmp$3=stringcmp$link93(objtype, "MATERIAL");
  if(return_value_stringcmp$3 == 0)
  {
    unsigned int return_value_GetMaterial$2;
    return_value_GetMaterial$2=GetMaterial(dfile, scene);
    return return_value_GetMaterial$2;
  }

  signed int return_value_stringcmp$5;
  return_value_stringcmp$5=stringcmp$link93(objtype, "OBJECT");
  if(return_value_stringcmp$5 == 0)
  {
    unsigned int return_value_GetObject$4;
    return_value_GetObject$4=GetObject$link86(dfile, scene);
    return return_value_GetObject$4;
  }

  printf("Found bad token: %s expected an object type\n", (const void *)objtype);
  return (unsigned int)4;
}

// c::GetScenedefs
// file ../demosrc/parse.c line 315
static unsigned int GetScenedefs(struct anon$6 *ph, void *scene)
{
  signed int xres;
  signed int yres;
  unsigned int rc = (unsigned int)0;
  unsigned int return_value_GetString$1;
  return_value_GetString$1=GetString(ph, "RESOLUTION");
  rc = rc | return_value_GetString$1;
  fscanf(ph->ifp, "%d %d", &xres, &yres);
  rt_outputfile(scene, "outfile.tga");
  rt_resolution(scene, xres, yres);
  rt_verbose(scene, 0);
  return rc;
}

// c::GetScenedefs$link61
// file ../demosrc/ac3dparse.c line 133
static unsigned int GetScenedefs$link61(struct _IO_FILE$link6 *dfile, void *scene$link58)
{
  struct anon$0 Ccenter;
  struct anon$0 Cview;
  struct anon$0 Cup;
  double zoom;
  double aspectratio;
  signed int raydepth;
  signed int antialiasing;
  rt_outputfile(scene$link58, "outfile.tga");
  rt_resolution(scene$link58, 512, 512);
  rt_verbose(scene$link58, 0);
  zoom = 1.000000;
  aspectratio = 1.000000;
  antialiasing = 0;
  raydepth = 6;
  Ccenter.x = 0.000000;
  Ccenter.y = 0.000000;
  Ccenter.z = -5.000000;
  Cview.x = 0.000000;
  Cview.y = 0.000000;
  Cview.z = 1.000000;
  Cup.x = 0.000000;
  Cup.y = 1.000000;
  Cup.z = 0.000000;
  rt_camera_setup(scene$link58, zoom, aspectratio, antialiasing, raydepth, Ccenter, Cview, Cup);
  struct anon$0 ctr;
  struct anon$7 tex;
  memset((void *)&tex, 0, 296ul /*[[struct anon$7]]*/);
  tex.col.r = (float)1.000000;
  tex.col.g = (float)1.000000;
  tex.col.b = (float)1.000000;
  ctr.x = 0.000000;
  ctr.y = 0.000000;
  ctr.z = -100.000000;
  void *return_value_rt_texture$1;
  return_value_rt_texture$1=rt_texture(scene$link58, &tex);
  rt_light(scene$link58, return_value_rt_texture$1, ctr, 1.000000);
  return (unsigned int)0;
}

// c::GetShaderMode
// file ../demosrc/parse.c line 329
static unsigned int GetShaderMode(struct anon$6 *ph, void *scene)
{
  unsigned int rc = (unsigned int)0;
  char data[255l];
  fscanf(ph->ifp, "%s", (const void *)data);
  signed int return_value_stringcmp$4;
  return_value_stringcmp$4=stringcmp(data, "FULL");
  signed int return_value_stringcmp$3;
  signed int return_value_stringcmp$2;
  signed int return_value_stringcmp$1;
  if(return_value_stringcmp$4 == 0)
    rt_shadermode(scene, 5);

  else
  {
    return_value_stringcmp$3=stringcmp(data, "MEDIUM");
    if(return_value_stringcmp$3 == 0)
      rt_shadermode(scene, 3);

    else
    {
      return_value_stringcmp$2=stringcmp(data, "LOW");
      if(return_value_stringcmp$2 == 0)
        rt_shadermode(scene, 2);

      else
      {
        return_value_stringcmp$1=stringcmp(data, "LOWEST");
        if(return_value_stringcmp$1 == 0)
          rt_shadermode(scene, 1);

        else
        {
          printf("Bad token '%s' while reading shader mode block\n", (const void *)data);
          return (unsigned int)4;
        }
      }
    }
  }
  signed int return_value_stringcmp$10;
  signed int return_value_stringcmp$9;
  signed int return_value_stringcmp$8;
  while(rc == 0u)
  {
    fscanf(ph->ifp, "%s", (const void *)data);
    signed int return_value_stringcmp$11;
    return_value_stringcmp$11=stringcmp(data, "END_SHADER_MODE");
    if(return_value_stringcmp$11 == 0)
      return rc;

    else
    {
      return_value_stringcmp$10=stringcmp(data, "TRANS_VMD");
      if(return_value_stringcmp$10 == 0)
        rt_trans_mode(scene, 1);

      else
      {
        return_value_stringcmp$9=stringcmp(data, "FOG_VMD");
        if(return_value_stringcmp$9 == 0)
          rt_fog_rendering_mode(scene, 1);

        else
        {
          return_value_stringcmp$8=stringcmp(data, "AMBIENT_OCCLUSION");
          if(return_value_stringcmp$8 == 0)
          {
            signed int aosamples;
            float aodirect;
            struct anon$4 aoambient;
            unsigned int return_value_GetString$5;
            return_value_GetString$5=GetString(ph, "AMBIENT_COLOR");
            rc = rc | return_value_GetString$5;
            fscanf(ph->ifp, "%f %f %f", &aoambient.r, &aoambient.g, &aoambient.b);
            unsigned int return_value_GetString$6;
            return_value_GetString$6=GetString(ph, "RESCALE_DIRECT");
            rc = rc | return_value_GetString$6;
            fscanf(ph->ifp, "%f", &aodirect);
            unsigned int return_value_GetString$7;
            return_value_GetString$7=GetString(ph, "SAMPLES");
            rc = rc | return_value_GetString$7;
            fscanf(ph->ifp, "%d", &aosamples);
            rt_rescale_lights(scene, (double)aodirect);
            rt_ambient_occlusion(scene, aosamples, aoambient);
          }

          else
          {
            printf("Bad token '%s' while reading optional shader modes\n", (const void *)data);
            return (unsigned int)4;
          }
        }
      }
    }
  }
  return rc;
}

// c::GetSkyLight
// file ../demosrc/parse.c line 983
static unsigned int GetSkyLight(struct anon$6 *ph, void *scene)
{
  unsigned int rc;
  struct anon$4 ambcol;
  signed int numsamples = 128;
  ambcol.r = (float)1.000000;
  ambcol.g = (float)1.000000;
  ambcol.b = (float)1.000000;
  rc=GetString(ph, "NUMSAMPLES");
  fscanf(ph->ifp, "%d", &numsamples);
  unsigned int return_value_GetString$1;
  return_value_GetString$1=GetString(ph, "COLOR");
  rc = rc | return_value_GetString$1;
  fscanf(ph->ifp, "%f %f %f", &ambcol.r, &ambcol.g, &ambcol.b);
  rt_ambient_occlusion(scene, numsamples, ambcol);
  return rc;
}

// c::GetSphere
// file ../demosrc/parse.c line 1191
static unsigned int GetSphere(struct anon$6 *ph, void *scene)
{
  double rad;
  struct anon$0 ctr;
  void *tex;
  float a;
  unsigned int rc;
  rc=GetString(ph, "CENTER");
  unsigned int return_value_GetVector$1;
  return_value_GetVector$1=GetVector(ph, &ctr);
  rc = rc | return_value_GetVector$1;
  unsigned int return_value_GetString$2;
  return_value_GetString$2=GetString(ph, "RAD");
  rc = rc | return_value_GetString$2;
  fscanf(ph->ifp, "%f", &a);
  rad = (double)a;
  unsigned int return_value_GetTexture$3;
  return_value_GetTexture$3=GetTexture(ph, scene, &tex);
  rc = rc | return_value_GetTexture$3;
  rt_sphere(scene, tex, ctr, rad);
  return rc;
}

// c::GetSpotLight
// file ../demosrc/parse.c line 1003
static unsigned int GetSpotLight(struct anon$6 *ph, void *scene)
{
  char tmp[255l];
  double rad;
  double Kc;
  double Kl;
  double Kq;
  struct anon$0 ctr;
  struct anon$7 tex;
  struct anon$0 direction;
  double start;
  double end;
  float r;
  float g;
  float b;
  float a;
  unsigned int rc;
  void *li;
  memset((void *)&tex, 0, 296ul /*[[struct anon$7]]*/);
  rc=GetString(ph, "CENTER");
  unsigned int return_value_GetVector$1;
  return_value_GetVector$1=GetVector(ph, &ctr);
  rc = rc | return_value_GetVector$1;
  unsigned int return_value_GetString$2;
  return_value_GetString$2=GetString(ph, "RAD");
  rc = rc | return_value_GetString$2;
  fscanf(ph->ifp, "%f", &a);
  rad = (double)a;
  unsigned int return_value_GetString$3;
  return_value_GetString$3=GetString(ph, "DIRECTION");
  rc = rc | return_value_GetString$3;
  unsigned int return_value_GetVector$4;
  return_value_GetVector$4=GetVector(ph, &direction);
  rc = rc | return_value_GetVector$4;
  unsigned int return_value_GetString$5;
  return_value_GetString$5=GetString(ph, "FALLOFF_START");
  rc = rc | return_value_GetString$5;
  fscanf(ph->ifp, "%f", &a);
  start = (double)a;
  unsigned int return_value_GetString$6;
  return_value_GetString$6=GetString(ph, "FALLOFF_END");
  rc = rc | return_value_GetString$6;
  fscanf(ph->ifp, "%f", &a);
  end = (double)a;
  fscanf(ph->ifp, "%s", (const void *)tmp);
  signed int return_value_stringcmp$14;
  return_value_stringcmp$14=stringcmp(tmp, "COLOR");
  if(return_value_stringcmp$14 == 0)
  {
    fscanf(ph->ifp, "%f %f %f", &r, &g, &b);
    tex.col.r = r;
    tex.col.g = g;
    tex.col.b = b;
    void *return_value_rt_texture$7;
    return_value_rt_texture$7=rt_texture(scene, &tex);
    li=rt_spotlight(scene, return_value_rt_texture$7, ctr, rad, direction, start, end);
  }

  else
  {
    signed int return_value_stringcmp$8;
    return_value_stringcmp$8=stringcmp(tmp, "ATTENUATION");
    if(!(return_value_stringcmp$8 == 0))
      return (unsigned int)-1;

    unsigned int return_value_GetString$9;
    return_value_GetString$9=GetString(ph, "CONSTANT");
    rc = rc | return_value_GetString$9;
    fscanf(ph->ifp, "%f", &a);
    Kc = (double)a;
    unsigned int return_value_GetString$10;
    return_value_GetString$10=GetString(ph, "LINEAR");
    rc = rc | return_value_GetString$10;
    fscanf(ph->ifp, "%f", &a);
    Kl = (double)a;
    unsigned int return_value_GetString$11;
    return_value_GetString$11=GetString(ph, "QUADRATIC");
    rc = rc | return_value_GetString$11;
    fscanf(ph->ifp, "%f", &a);
    Kq = (double)a;
    unsigned int return_value_GetColor$12;
    return_value_GetColor$12=GetColor(ph, &tex.col);
    rc = rc | return_value_GetColor$12;
    void *return_value_rt_texture$13;
    return_value_rt_texture$13=rt_texture(scene, &tex);
    li=rt_spotlight(scene, return_value_rt_texture$13, ctr, rad, direction, start, end);
    rt_light_attenuation(li, Kc, Kl, Kq);
  }
  return rc;
}

// c::GetString
// file ../demosrc/parse.c line 209
static unsigned int GetString(struct anon$6 *ph, const char *string)
{
  char data[255l];
  fscanf(ph->ifp, "%s", (const void *)data);
  signed int return_value_stringcmp$1;
  return_value_stringcmp$1=stringcmp(data, string);
  if(!(return_value_stringcmp$1 == 0))
  {
    PrintSyntaxError(ph, string, data);
    return (unsigned int)4;
  }

  return (unsigned int)0;
}

// c::GetString$link57
// file ../demosrc/ac3dparse.c line 77
static unsigned int GetString$link57(struct _IO_FILE$link6 *dfile, char *string$link56)
{
  char data$link146[100l];
  fscanf(dfile, "%s", (const void *)data$link146);
  signed int return_value_stringcmp$1$link262;
  return_value_stringcmp$1$link262=stringcmp$link93(data$link146, string$link56);
  if(!(return_value_stringcmp$1$link262 == 0))
  {
    printf("parse: Expected %s, got %s \n", string$link56, (const void *)data$link146);
    printf("parse: Error while parsing object: %d \n", numobjectsparsed);
    return (unsigned int)4;
  }

  return (unsigned int)0;
}

// c::GetTPolyFile
// file ../demosrc/parse.c line 1653
static unsigned int GetTPolyFile(struct anon$6 *ph, void *scene)
{
  void *tex;
  char ifname[255l];
  struct _IO_FILE$link13 *ifp;
  signed int v;
  struct anon$8 RotA;
  unsigned int rc = (unsigned int)0;
  signed int totalpolys = 0;
  struct anon$0 ctr = (struct anon$0){ .x=(double)0, .y=(double)0, .z=(double)0 };
  struct anon$0 rot = (struct anon$0){ .x=(double)0, .y=(double)0, .z=(double)0 };
  struct anon$0 scale = (struct anon$0){ .x=(double)0, .y=(double)0, .z=(double)0 };
  struct anon$0 v0 = (struct anon$0){ .x=(double)0, .y=(double)0, .z=(double)0 };
  struct anon$0 v1 = (struct anon$0){ .x=(double)0, .y=(double)0, .z=(double)0 };
  struct anon$0 v2 = (struct anon$0){ .x=(double)0, .y=(double)0, .z=(double)0 };
  rc=GetString(ph, "SCALE");
  unsigned int return_value_GetVector$1;
  return_value_GetVector$1=GetVector(ph, &scale);
  rc = rc | return_value_GetVector$1;
  unsigned int return_value_GetString$2;
  return_value_GetString$2=GetString(ph, "ROT");
  rc = rc | return_value_GetString$2;
  unsigned int return_value_GetVector$3;
  return_value_GetVector$3=GetVector(ph, &rot);
  rc = rc | return_value_GetVector$3;
  degvectoradvec(&rot);
  InitRot3d(&RotA, rot.x, rot.y, rot.z);
  unsigned int return_value_GetString$4;
  return_value_GetString$4=GetString(ph, "CENTER");
  rc = rc | return_value_GetString$4;
  unsigned int return_value_GetVector$5;
  return_value_GetVector$5=GetVector(ph, &ctr);
  rc = rc | return_value_GetVector$5;
  unsigned int return_value_GetString$6;
  return_value_GetString$6=GetString(ph, "FILE");
  rc = rc | return_value_GetString$6;
  fscanf(ph->ifp, "%s", (const void *)ifname);
  unsigned int return_value_GetTexture$7;
  return_value_GetTexture$7=GetTexture(ph, scene, &tex);
  rc = rc | return_value_GetTexture$7;
  ifp=fopen(ifname, "r");
  if(ifp == ((struct _IO_FILE$link13 *)NULL))
  {
    printf("Can't open data file %s for input!! Aborting...\n", (const void *)ifname);
    return (unsigned int)2;
  }

  signed int return_value_feof$8;
  do
  {
    return_value_feof$8=feof(ifp);
    if(return_value_feof$8 != 0)
      goto __CPROVER_DUMP_L2;

    fscanf(ifp, "%d", &v);
    if(v != 3)
      goto __CPROVER_DUMP_L2;

    totalpolys = totalpolys + 1;
    v = 0;
    unsigned int return_value_GetVector$9;
    return_value_GetVector$9=GetVector(ph, &v0);
    rc = rc | return_value_GetVector$9;
    unsigned int return_value_GetVector$10;
    return_value_GetVector$10=GetVector(ph, &v1);
    rc = rc | return_value_GetVector$10;
    unsigned int return_value_GetVector$11;
    return_value_GetVector$11=GetVector(ph, &v2);
    rc = rc | return_value_GetVector$11;
    Scale3d(&scale, &v0);
    Scale3d(&scale, &v1);
    Scale3d(&scale, &v2);
    Rotate3d(&RotA, &v0);
    Rotate3d(&RotA, &v1);
    Rotate3d(&RotA, &v2);
    Trans3d(&ctr, &v0);
    Trans3d(&ctr, &v1);
    Trans3d(&ctr, &v2);
    rt_tri(scene, tex, v1, v0, v2);
  }
  while(TRUE);

__CPROVER_DUMP_L2:
  ;
  fclose(ifp);
  return rc;
}

// c::GetTexAlias
// file ../demosrc/parse.c line 725
static unsigned int GetTexAlias(struct anon$6 *ph)
{
  char texname[255l];
  char aliasname[255l];
  fscanf(ph->ifp, "%s", (const void *)texname);
  fscanf(ph->ifp, "%s", (const void *)aliasname);
  void *return_value_find_texture$1;
  return_value_find_texture$1=find_texture(ph, aliasname);
  add_texture(ph, return_value_find_texture$1, texname);
  return (unsigned int)0;
}

// c::GetTexBody
// file ../demosrc/parse.c line 751
void * GetTexBody(struct anon$6 *ph, void *scene, signed int modeflag)
{
  char tmp[255l];
  float a;
  float b;
  float c;
  float d;
  float outline;
  float outlinewidth;
  float phong;
  float phongexp;
  signed int phongtype;
  struct anon$7 tex;
  void *voidtex;
  unsigned int rc;
  outline = 0.000000f;
  outlinewidth = 0.000000f;
  phong = 0.000000f;
  phongexp = 100.000000f;
  phongtype = 0;
  rc=GetString(ph, "AMBIENT");
  fscanf(ph->ifp, "%f", &a);
  tex.ambient = (double)a;
  unsigned int return_value_GetString$1;
  return_value_GetString$1=GetString(ph, "DIFFUSE");
  rc = rc | return_value_GetString$1;
  fscanf(ph->ifp, "%f", &b);
  tex.diffuse = (double)b;
  unsigned int return_value_GetString$2;
  return_value_GetString$2=GetString(ph, "SPECULAR");
  rc = rc | return_value_GetString$2;
  fscanf(ph->ifp, "%f", &c);
  tex.specular = (double)c;
  unsigned int return_value_GetString$3;
  return_value_GetString$3=GetString(ph, "OPACITY");
  rc = rc | return_value_GetString$3;
  fscanf(ph->ifp, "%f", &d);
  tex.opacity = (double)d;
  fscanf(ph->ifp, "%s", (const void *)tmp);
  signed int return_value_stringcmp$4;
  return_value_stringcmp$4=stringcmp(tmp, "OUTLINE");
  if(return_value_stringcmp$4 == 0)
  {
    fscanf(ph->ifp, "%f", &outline);
    GetString(ph, "OUTLINE_WIDTH");
    fscanf(ph->ifp, "%f", &outlinewidth);
    fscanf(ph->ifp, "%s", (const void *)tmp);
  }

  signed int return_value_stringcmp$7;
  return_value_stringcmp$7=stringcmp(tmp, "PHONG");
  signed int return_value_stringcmp$5;
  if(return_value_stringcmp$7 == 0)
  {
    fscanf(ph->ifp, "%s", (const void *)tmp);
    signed int return_value_stringcmp$6;
    return_value_stringcmp$6=stringcmp(tmp, "METAL");
    if(return_value_stringcmp$6 == 0)
      phongtype = 1;

    else
    {
      return_value_stringcmp$5=stringcmp(tmp, "PLASTIC");
      if(return_value_stringcmp$5 == 0)
        phongtype = 0;

      else
        phongtype = 0;
    }
    fscanf(ph->ifp, "%f", &phong);
    GetString(ph, "PHONG_SIZE");
    fscanf(ph->ifp, "%f", &phongexp);
    fscanf(ph->ifp, "%s", (const void *)tmp);
  }

  if(modeflag == 0)
  {
    signed int return_value_stringcmp$8;
    return_value_stringcmp$8=stringcmp(tmp, "COLOR");
    if(!(return_value_stringcmp$8 == 0))
      rc = rc | (unsigned int)4;

    fscanf(ph->ifp, "%f %f %f", &a, &b, &c);
    tex.col.r = a;
    tex.col.g = b;
    tex.col.b = c;
    unsigned int return_value_GetString$9;
    return_value_GetString$9=GetString(ph, "TEXFUNC");
    rc = rc | return_value_GetString$9;
    fscanf(ph->ifp, "%d", &tex.texturefunc);
    if(!(tex.texturefunc == 0))
    {
      if(tex.texturefunc == 1 || tex.texturefunc == 2 || tex.texturefunc == 3 || tex.texturefunc == 4 || tex.texturefunc == 5 || tex.texturefunc == 6)
        goto __CPROVER_DUMP_L8;

      if(tex.texturefunc == 7 || tex.texturefunc == 8)
        goto __CPROVER_DUMP_L9;

      if(tex.texturefunc == 9)
        goto __CPROVER_DUMP_L10;

      if(tex.texturefunc == 10)
        goto __CPROVER_DUMP_L11;

    }

    goto __CPROVER_DUMP_L12;

  __CPROVER_DUMP_L8:
    ;
    unsigned int return_value_GetString$10;
    return_value_GetString$10=GetString(ph, "CENTER");
    rc = rc | return_value_GetString$10;
    unsigned int return_value_GetVector$11;
    return_value_GetVector$11=GetVector(ph, &tex.ctr);
    rc = rc | return_value_GetVector$11;
    unsigned int return_value_GetString$12;
    return_value_GetString$12=GetString(ph, "ROTATE");
    rc = rc | return_value_GetString$12;
    unsigned int return_value_GetVector$13;
    return_value_GetVector$13=GetVector(ph, &tex.rot);
    rc = rc | return_value_GetVector$13;
    unsigned int return_value_GetString$14;
    return_value_GetString$14=GetString(ph, "SCALE");
    rc = rc | return_value_GetString$14;
    unsigned int return_value_GetVector$15;
    return_value_GetVector$15=GetVector(ph, &tex.scale);
    rc = rc | return_value_GetVector$15;
    goto __CPROVER_DUMP_L12;

  __CPROVER_DUMP_L9:
    ;
    fscanf(ph->ifp, "%s", (const void *)tex.imap);
    unsigned int return_value_GetString$16;
    return_value_GetString$16=GetString(ph, "CENTER");
    rc = rc | return_value_GetString$16;
    unsigned int return_value_GetVector$17;
    return_value_GetVector$17=GetVector(ph, &tex.ctr);
    rc = rc | return_value_GetVector$17;
    unsigned int return_value_GetString$18;
    return_value_GetString$18=GetString(ph, "ROTATE");
    rc = rc | return_value_GetString$18;
    unsigned int return_value_GetVector$19;
    return_value_GetVector$19=GetVector(ph, &tex.rot);
    rc = rc | return_value_GetVector$19;
    unsigned int return_value_GetString$20;
    return_value_GetString$20=GetString(ph, "SCALE");
    rc = rc | return_value_GetString$20;
    unsigned int return_value_GetVector$21;
    return_value_GetVector$21=GetVector(ph, &tex.scale);
    rc = rc | return_value_GetVector$21;
    goto __CPROVER_DUMP_L12;

  __CPROVER_DUMP_L10:
    ;
    fscanf(ph->ifp, "%s", (const void *)tex.imap);
    unsigned int return_value_GetString$22;
    return_value_GetString$22=GetString(ph, "CENTER");
    rc = rc | return_value_GetString$22;
    unsigned int return_value_GetVector$23;
    return_value_GetVector$23=GetVector(ph, &tex.ctr);
    rc = rc | return_value_GetVector$23;
    unsigned int return_value_GetString$24;
    return_value_GetString$24=GetString(ph, "ROTATE");
    rc = rc | return_value_GetString$24;
    unsigned int return_value_GetVector$25;
    return_value_GetVector$25=GetVector(ph, &tex.rot);
    rc = rc | return_value_GetVector$25;
    unsigned int return_value_GetString$26;
    return_value_GetString$26=GetString(ph, "SCALE");
    rc = rc | return_value_GetString$26;
    unsigned int return_value_GetVector$27;
    return_value_GetVector$27=GetVector(ph, &tex.scale);
    rc = rc | return_value_GetVector$27;
    unsigned int return_value_GetString$28;
    return_value_GetString$28=GetString(ph, "UAXIS");
    rc = rc | return_value_GetString$28;
    unsigned int return_value_GetVector$29;
    return_value_GetVector$29=GetVector(ph, &tex.uaxs);
    rc = rc | return_value_GetVector$29;
    unsigned int return_value_GetString$30;
    return_value_GetString$30=GetString(ph, "VAXIS");
    rc = rc | return_value_GetString$30;
    unsigned int return_value_GetVector$31;
    return_value_GetVector$31=GetVector(ph, &tex.vaxs);
    rc = rc | return_value_GetVector$31;
    goto __CPROVER_DUMP_L12;

  __CPROVER_DUMP_L11:
    ;
    fscanf(ph->ifp, "%s", (const void *)tex.imap);
    unsigned int return_value_GetString$32;
    return_value_GetString$32=GetString(ph, "CENTER");
    rc = rc | return_value_GetString$32;
    unsigned int return_value_GetVector$33;
    return_value_GetVector$33=GetVector(ph, &tex.ctr);
    rc = rc | return_value_GetVector$33;
    unsigned int return_value_GetString$34;
    return_value_GetString$34=GetString(ph, "ROTATE");
    rc = rc | return_value_GetString$34;
    unsigned int return_value_GetVector$35;
    return_value_GetVector$35=GetVector(ph, &tex.rot);
    rc = rc | return_value_GetVector$35;
    unsigned int return_value_GetString$36;
    return_value_GetString$36=GetString(ph, "SCALE");
    rc = rc | return_value_GetString$36;
    unsigned int return_value_GetVector$37;
    return_value_GetVector$37=GetVector(ph, &tex.scale);
    rc = rc | return_value_GetVector$37;
    unsigned int return_value_GetString$38;
    return_value_GetString$38=GetString(ph, "UAXIS");
    rc = rc | return_value_GetString$38;
    unsigned int return_value_GetVector$39;
    return_value_GetVector$39=GetVector(ph, &tex.uaxs);
    rc = rc | return_value_GetVector$39;
    unsigned int return_value_GetString$40;
    return_value_GetString$40=GetString(ph, "VAXIS");
    rc = rc | return_value_GetString$40;
    unsigned int return_value_GetVector$41;
    return_value_GetVector$41=GetVector(ph, &tex.vaxs);
    rc = rc | return_value_GetVector$41;
    unsigned int return_value_GetString$42;
    return_value_GetString$42=GetString(ph, "WAXIS");
    rc = rc | return_value_GetString$42;
    unsigned int return_value_GetVector$43;
    return_value_GetVector$43=GetVector(ph, &tex.waxs);
    rc = rc | return_value_GetVector$43;
    goto __CPROVER_DUMP_L12;
  }

  else
  {
    signed int return_value_stringcmp$44;
    return_value_stringcmp$44=stringcmp(tmp, "VCST");
    if(!(return_value_stringcmp$44 == 0))
      rc = rc | (unsigned int)4;

    tex.col.r = (float)1.000000;
    tex.col.g = (float)1.000000;
    tex.col.b = (float)1.000000;
    tex.texturefunc = 0;
  }

__CPROVER_DUMP_L12:
  ;
  voidtex=rt_texture(scene, &tex);
  rt_tex_phong(voidtex, (double)phong, (double)phongexp, phongtype);
  rt_tex_outline(voidtex, (double)outline, (double)outlinewidth);
  return voidtex;
}

// c::GetTexDef
// file ../demosrc/parse.c line 716
static unsigned int GetTexDef(struct anon$6 *ph, void *scene)
{
  char texname[255l];
  fscanf(ph->ifp, "%s", (const void *)texname);
  void *return_value_GetTexBody$1;
  return_value_GetTexBody$1=GetTexBody(ph, scene, 0);
  add_texture(ph, return_value_GetTexBody$1, texname);
  return (unsigned int)0;
}

// c::GetTexture
// file ../demosrc/parse.c line 737
static unsigned int GetTexture(struct anon$6 *ph, void *scene, void **tex)
{
  char tmp[255l];
  unsigned int rc = (unsigned int)0;
  fscanf(ph->ifp, "%s", (const void *)tmp);
  signed int return_value_stringcmp$1;
  return_value_stringcmp$1=stringcmp(tmp, "TEXTURE");
  if(return_value_stringcmp$1 == 0)
    *tex=GetTexBody(ph, scene, 0);

  else
    *tex=find_texture(ph, tmp);
  return rc;
}

// c::GetTri
// file ../demosrc/parse.c line 1288
static unsigned int GetTri(struct anon$6 *ph, void *scene)
{
  struct anon$0 v0;
  struct anon$0 v1;
  struct anon$0 v2;
  void *tex;
  unsigned int rc;
  rc=GetString(ph, "V0");
  unsigned int return_value_GetVector$1;
  return_value_GetVector$1=GetVector(ph, &v0);
  rc = rc | return_value_GetVector$1;
  unsigned int return_value_GetString$2;
  return_value_GetString$2=GetString(ph, "V1");
  rc = rc | return_value_GetString$2;
  unsigned int return_value_GetVector$3;
  return_value_GetVector$3=GetVector(ph, &v1);
  rc = rc | return_value_GetVector$3;
  unsigned int return_value_GetString$4;
  return_value_GetString$4=GetString(ph, "V2");
  rc = rc | return_value_GetString$4;
  unsigned int return_value_GetVector$5;
  return_value_GetVector$5=GetVector(ph, &v2);
  rc = rc | return_value_GetVector$5;
  unsigned int return_value_GetTexture$6;
  return_value_GetTexture$6=GetTexture(ph, scene, &tex);
  rc = rc | return_value_GetTexture$6;
  rt_tri(scene, tex, v0, v1, v2);
  return rc;
}

// c::GetVCSTri
// file ../demosrc/parse.c line 1339
static unsigned int GetVCSTri(struct anon$6 *ph, void *scene)
{
  struct anon$0 v0;
  struct anon$0 v1;
  struct anon$0 v2;
  struct anon$0 n0;
  struct anon$0 n1;
  struct anon$0 n2;
  struct anon$4 c0;
  struct anon$4 c1;
  struct anon$4 c2;
  float a;
  float b;
  float c;
  void *tex;
  unsigned int rc;
  rc=GetString(ph, "V0");
  unsigned int return_value_GetVector$1;
  return_value_GetVector$1=GetVector(ph, &v0);
  rc = rc | return_value_GetVector$1;
  unsigned int return_value_GetString$2;
  return_value_GetString$2=GetString(ph, "V1");
  rc = rc | return_value_GetString$2;
  unsigned int return_value_GetVector$3;
  return_value_GetVector$3=GetVector(ph, &v1);
  rc = rc | return_value_GetVector$3;
  unsigned int return_value_GetString$4;
  return_value_GetString$4=GetString(ph, "V2");
  rc = rc | return_value_GetString$4;
  unsigned int return_value_GetVector$5;
  return_value_GetVector$5=GetVector(ph, &v2);
  rc = rc | return_value_GetVector$5;
  unsigned int return_value_GetString$6;
  return_value_GetString$6=GetString(ph, "N0");
  rc = rc | return_value_GetString$6;
  unsigned int return_value_GetVector$7;
  return_value_GetVector$7=GetVector(ph, &n0);
  rc = rc | return_value_GetVector$7;
  unsigned int return_value_GetString$8;
  return_value_GetString$8=GetString(ph, "N1");
  rc = rc | return_value_GetString$8;
  unsigned int return_value_GetVector$9;
  return_value_GetVector$9=GetVector(ph, &n1);
  rc = rc | return_value_GetVector$9;
  unsigned int return_value_GetString$10;
  return_value_GetString$10=GetString(ph, "N2");
  rc = rc | return_value_GetString$10;
  unsigned int return_value_GetVector$11;
  return_value_GetVector$11=GetVector(ph, &n2);
  rc = rc | return_value_GetVector$11;
  unsigned int return_value_GetString$12;
  return_value_GetString$12=GetString(ph, "C0");
  rc = rc | return_value_GetString$12;
  fscanf(ph->ifp, "%f %f %f", &a, &b, &c);
  c0.r = a;
  c0.g = b;
  c0.b = c;
  unsigned int return_value_GetString$13;
  return_value_GetString$13=GetString(ph, "C1");
  rc = rc | return_value_GetString$13;
  fscanf(ph->ifp, "%f %f %f", &a, &b, &c);
  c1.r = a;
  c1.g = b;
  c1.b = c;
  unsigned int return_value_GetString$14;
  return_value_GetString$14=GetString(ph, "C2");
  rc = rc | return_value_GetString$14;
  fscanf(ph->ifp, "%f %f %f", &a, &b, &c);
  c2.r = a;
  c2.g = b;
  c2.b = c;
  tex=GetTexBody(ph, scene, 1);
  rt_vcstri(scene, tex, v0, v1, v2, n0, n1, n2, c0, c1, c2);
  return rc;
}

// c::GetVector
// file ../demosrc/parse.c line 596
static unsigned int GetVector(struct anon$6 *ph, struct anon$0 *v1)
{
  float a;
  float b;
  float c;
  signed int return_value_fscanf$1;
  return_value_fscanf$1=fscanf(ph->ifp, "%f %f %f", &a, &b, &c);
  if(!(return_value_fscanf$1 == 3))
    return (unsigned int)4;

  v1->x = (double)a;
  v1->y = (double)b;
  v1->z = (double)c;
  return (unsigned int)0;
}

// c::GetVertexArray
// file ../demosrc/parse.c line 1391
static unsigned int GetVertexArray(struct anon$6 *ph, void *scene)
{
  char arraytype[1024l];
  signed int done;
  signed int i;
  signed int texusecount;
  signed int vertexcount = 0;
  unsigned int rc = (unsigned int)0;
  void *tex = NULL;
  float *v = (float *)NULL;
  float *n = (float *)NULL;
  float *c = (float *)NULL;
  unsigned int return_value_GetString$1;
  return_value_GetString$1=GetString(ph, "NUMVERTS");
  rc = rc | return_value_GetString$1;
  unsigned int return_value_GetInt$2;
  return_value_GetInt$2=GetInt(ph, &vertexcount);
  rc = rc | return_value_GetInt$2;
  if(!(rc == 0u))
    return rc;

  fscanf(ph->ifp, "%s", (const void *)arraytype);
  signed int return_value_stringcmp$4;
  return_value_stringcmp$4=stringcmp(arraytype, "COORDS");
  if(return_value_stringcmp$4 == 0)
  {
    void *return_value_malloc$3;
    return_value_malloc$3=malloc((unsigned long int)(vertexcount * 3) * 4ul /*[[float]]*/);
    v = (float *)return_value_malloc$3;
    i = 0;
    while(!(i >= 3 * vertexcount))
    {
      fscanf(ph->ifp, "%f %f %f", &v[(signed long int)i], &v[(signed long int)(i + 1)], &v[(signed long int)(i + 2)]);
      i = i + 3;
    }
    fscanf(ph->ifp, "%s", (const void *)arraytype);
  }

  else
  {
    printf("Expected vertex array coords block\n");
    return (unsigned int)4;
  }
  signed int return_value_stringcmp$6;
  return_value_stringcmp$6=stringcmp(arraytype, "NORMALS");
  if(return_value_stringcmp$6 == 0)
  {
    void *return_value_malloc$5;
    return_value_malloc$5=malloc((unsigned long int)(vertexcount * 3) * 4ul /*[[float]]*/);
    n = (float *)return_value_malloc$5;
    i = 0;
    while(!(i >= 3 * vertexcount))
    {
      fscanf(ph->ifp, "%f %f %f", &n[(signed long int)i], &n[(signed long int)(i + 1)], &n[(signed long int)(i + 2)]);
      i = i + 3;
    }
    fscanf(ph->ifp, "%s", (const void *)arraytype);
  }

  else
  {
    free((void *)v);
    printf("Expected vertex array normals block\n");
    return (unsigned int)4;
  }
  tex = ph->defaulttex.tex;
  texusecount = 1;
  done = 0;
  signed int return_value_stringcmp$45;
  signed int return_value_stringcmp$44;
  signed int return_value_stringcmp$43;
  signed int return_value_stringcmp$42;
  while(done == 0)
  {
    signed int return_value_stringcmp$46;
    return_value_stringcmp$46=stringcmp(arraytype, "COLORS");
    if(return_value_stringcmp$46 == 0)
    {
      void *return_value_malloc$7;
      return_value_malloc$7=malloc((unsigned long int)(vertexcount * 3) * 4ul /*[[float]]*/);
      c = (float *)return_value_malloc$7;
      i = 0;
      while(!(i >= 3 * vertexcount))
      {
        fscanf(ph->ifp, "%f %f %f", &c[(signed long int)i], &c[(signed long int)(i + 1)], &c[(signed long int)(i + 2)]);
        i = i + 3;
      }
    }

    else
    {
      return_value_stringcmp$45=stringcmp(arraytype, "TEXTURE");
      if(return_value_stringcmp$45 == 0)
      {
        tex=GetTexBody(ph, scene, 0);
        if(tex == NULL)
        {
          printf("Failed to parse vertex array texture block\n");
          rc = rc | (unsigned int)4;
          done = 1;
        }

        texusecount = 0;
      }

      else
      {
        return_value_stringcmp$44=stringcmp(arraytype, "TRISTRIP");
        if(return_value_stringcmp$44 == 0)
        {
          signed int t;
          signed int numv = 0;
          signed int stripaddr[2l][3l] = { { 0, 1, 2 }, { 1, 0, 2 } };
          signed int *GetVertexArray$$1$$5$$3$$facets = (signed int *)NULL;
          unsigned int return_value_GetInt$8;
          return_value_GetInt$8=GetInt(ph, &numv);
          rc = rc | return_value_GetInt$8;
          if(!(rc == 0u))
            return (unsigned int)4;

          void *return_value_malloc$9;
          return_value_malloc$9=malloc((unsigned long int)numv * 4ul /*[[signed int]]*/);
          GetVertexArray$$1$$5$$3$$facets = (signed int *)return_value_malloc$9;
          i = 0;
          while(!(i >= numv))
          {
            fscanf(ph->ifp, "%d", &GetVertexArray$$1$$5$$3$$facets[(signed long int)i]);
            i = i + 1;
          }
          t = 0;
          while(!(t >= -2 + numv))
          {
            signed int GetVertexArray$$1$$5$$3$$2$$v0 = GetVertexArray$$1$$5$$3$$facets[(signed long int)(t + stripaddr[(signed long int)(t & 1)][(signed long int)0])];
            signed int GetVertexArray$$1$$5$$3$$2$$v1 = GetVertexArray$$1$$5$$3$$facets[(signed long int)(t + stripaddr[(signed long int)(t & 1)][(signed long int)1])];
            signed int GetVertexArray$$1$$5$$3$$2$$v2 = GetVertexArray$$1$$5$$3$$facets[(signed long int)(t + stripaddr[(signed long int)(t & 1)][(signed long int)2])];
            if(GetVertexArray$$1$$5$$3$$2$$v0 >= 0)
            {
              if(GetVertexArray$$1$$5$$3$$2$$v0 >= vertexcount)
                goto __CPROVER_DUMP_L23;

              if(!(GetVertexArray$$1$$5$$3$$2$$v1 >= 0))
                goto __CPROVER_DUMP_L23;

              if(GetVertexArray$$1$$5$$3$$2$$v1 >= vertexcount)
                goto __CPROVER_DUMP_L23;

              if(!(GetVertexArray$$1$$5$$3$$2$$v2 >= 0))
                goto __CPROVER_DUMP_L23;

              if(GetVertexArray$$1$$5$$3$$2$$v2 >= vertexcount)
                goto __CPROVER_DUMP_L23;

              GetVertexArray$$1$$5$$3$$2$$v0 = GetVertexArray$$1$$5$$3$$2$$v0 * 3;
              GetVertexArray$$1$$5$$3$$2$$v1 = GetVertexArray$$1$$5$$3$$2$$v1 * 3;
              GetVertexArray$$1$$5$$3$$2$$v2 = GetVertexArray$$1$$5$$3$$2$$v2 * 3;
              if(!(c == ((float *)NULL)))
              {
                if(texusecount > 0)
                  tex=rt_texture_copy_vcstri(scene, tex);

                struct anon$0 return_value_rt_vector$10;
                return_value_rt_vector$10=rt_vector((double)v[(signed long int)GetVertexArray$$1$$5$$3$$2$$v0], (double)v[(signed long int)(GetVertexArray$$1$$5$$3$$2$$v0 + 1)], (double)v[(signed long int)(GetVertexArray$$1$$5$$3$$2$$v0 + 2)]);
                struct anon$0 return_value_rt_vector$11;
                return_value_rt_vector$11=rt_vector((double)v[(signed long int)GetVertexArray$$1$$5$$3$$2$$v1], (double)v[(signed long int)(GetVertexArray$$1$$5$$3$$2$$v1 + 1)], (double)v[(signed long int)(GetVertexArray$$1$$5$$3$$2$$v1 + 2)]);
                struct anon$0 return_value_rt_vector$12;
                return_value_rt_vector$12=rt_vector((double)v[(signed long int)GetVertexArray$$1$$5$$3$$2$$v2], (double)v[(signed long int)(GetVertexArray$$1$$5$$3$$2$$v2 + 1)], (double)v[(signed long int)(GetVertexArray$$1$$5$$3$$2$$v2 + 2)]);
                struct anon$0 return_value_rt_vector$13;
                return_value_rt_vector$13=rt_vector((double)n[(signed long int)GetVertexArray$$1$$5$$3$$2$$v0], (double)n[(signed long int)(GetVertexArray$$1$$5$$3$$2$$v0 + 1)], (double)n[(signed long int)(GetVertexArray$$1$$5$$3$$2$$v0 + 2)]);
                struct anon$0 return_value_rt_vector$14;
                return_value_rt_vector$14=rt_vector((double)n[(signed long int)GetVertexArray$$1$$5$$3$$2$$v1], (double)n[(signed long int)(GetVertexArray$$1$$5$$3$$2$$v1 + 1)], (double)n[(signed long int)(GetVertexArray$$1$$5$$3$$2$$v1 + 2)]);
                struct anon$0 return_value_rt_vector$15;
                return_value_rt_vector$15=rt_vector((double)n[(signed long int)GetVertexArray$$1$$5$$3$$2$$v2], (double)n[(signed long int)(GetVertexArray$$1$$5$$3$$2$$v2 + 1)], (double)n[(signed long int)(GetVertexArray$$1$$5$$3$$2$$v2 + 2)]);
                struct anon$4 return_value_rt_color$16;
                return_value_rt_color$16=rt_color((double)c[(signed long int)GetVertexArray$$1$$5$$3$$2$$v0], (double)c[(signed long int)(GetVertexArray$$1$$5$$3$$2$$v0 + 1)], (double)c[(signed long int)(GetVertexArray$$1$$5$$3$$2$$v0 + 2)]);
                struct anon$4 return_value_rt_color$17;
                return_value_rt_color$17=rt_color((double)c[(signed long int)GetVertexArray$$1$$5$$3$$2$$v1], (double)c[(signed long int)(GetVertexArray$$1$$5$$3$$2$$v1 + 1)], (double)c[(signed long int)(GetVertexArray$$1$$5$$3$$2$$v1 + 2)]);
                struct anon$4 return_value_rt_color$18;
                return_value_rt_color$18=rt_color((double)c[(signed long int)GetVertexArray$$1$$5$$3$$2$$v2], (double)c[(signed long int)(GetVertexArray$$1$$5$$3$$2$$v2 + 1)], (double)c[(signed long int)(GetVertexArray$$1$$5$$3$$2$$v2 + 2)]);
                rt_vcstri(scene, tex, return_value_rt_vector$10, return_value_rt_vector$11, return_value_rt_vector$12, return_value_rt_vector$13, return_value_rt_vector$14, return_value_rt_vector$15, return_value_rt_color$16, return_value_rt_color$17, return_value_rt_color$18);
              }

              else
              {
                struct anon$0 return_value_rt_vector$19;
                return_value_rt_vector$19=rt_vector((double)v[(signed long int)GetVertexArray$$1$$5$$3$$2$$v0], (double)v[(signed long int)(GetVertexArray$$1$$5$$3$$2$$v0 + 1)], (double)v[(signed long int)(GetVertexArray$$1$$5$$3$$2$$v0 + 2)]);
                struct anon$0 return_value_rt_vector$20;
                return_value_rt_vector$20=rt_vector((double)v[(signed long int)GetVertexArray$$1$$5$$3$$2$$v1], (double)v[(signed long int)(GetVertexArray$$1$$5$$3$$2$$v1 + 1)], (double)v[(signed long int)(GetVertexArray$$1$$5$$3$$2$$v1 + 2)]);
                struct anon$0 return_value_rt_vector$21;
                return_value_rt_vector$21=rt_vector((double)v[(signed long int)GetVertexArray$$1$$5$$3$$2$$v2], (double)v[(signed long int)(GetVertexArray$$1$$5$$3$$2$$v2 + 1)], (double)v[(signed long int)(GetVertexArray$$1$$5$$3$$2$$v2 + 2)]);
                struct anon$0 return_value_rt_vector$22;
                return_value_rt_vector$22=rt_vector((double)n[(signed long int)GetVertexArray$$1$$5$$3$$2$$v0], (double)n[(signed long int)(GetVertexArray$$1$$5$$3$$2$$v0 + 1)], (double)n[(signed long int)(GetVertexArray$$1$$5$$3$$2$$v0 + 2)]);
                struct anon$0 return_value_rt_vector$23;
                return_value_rt_vector$23=rt_vector((double)n[(signed long int)GetVertexArray$$1$$5$$3$$2$$v1], (double)n[(signed long int)(GetVertexArray$$1$$5$$3$$2$$v1 + 1)], (double)n[(signed long int)(GetVertexArray$$1$$5$$3$$2$$v1 + 2)]);
                struct anon$0 return_value_rt_vector$24;
                return_value_rt_vector$24=rt_vector((double)n[(signed long int)GetVertexArray$$1$$5$$3$$2$$v2], (double)n[(signed long int)(GetVertexArray$$1$$5$$3$$2$$v2 + 1)], (double)n[(signed long int)(GetVertexArray$$1$$5$$3$$2$$v2 + 2)]);
                rt_stri(scene, tex, return_value_rt_vector$19, return_value_rt_vector$20, return_value_rt_vector$21, return_value_rt_vector$22, return_value_rt_vector$23, return_value_rt_vector$24);
              }
            }

            else
            {

            __CPROVER_DUMP_L23:
              ;
              printf("tristrip error: skipping invalid strip vertex %d\n", t);
              printf("  vertexcount: %d\n", vertexcount);
              printf("  verts: %d %d %d\n", GetVertexArray$$1$$5$$3$$2$$v0, GetVertexArray$$1$$5$$3$$2$$v1, GetVertexArray$$1$$5$$3$$2$$v2);
              rc = rc | (unsigned int)4;
              done = 1;
              goto __CPROVER_DUMP_L25;
            }
            texusecount = texusecount + 1;
            t = t + 1;
          }

        __CPROVER_DUMP_L25:
          ;
          free((void *)GetVertexArray$$1$$5$$3$$facets);
        }

        else
        {
          return_value_stringcmp$43=stringcmp(arraytype, "TRIMESH");
          if(return_value_stringcmp$43 == 0)
          {
            signed int numfacets = 0;
            signed int *GetVertexArray$$1$$5$$4$$facets;
            unsigned int return_value_GetInt$25;
            return_value_GetInt$25=GetInt(ph, &numfacets);
            rc = rc | return_value_GetInt$25;
            if(!(rc == 0u))
              return (unsigned int)4;

            void *return_value_malloc$26;
            return_value_malloc$26=malloc((unsigned long int)(numfacets * 3) * 4ul /*[[signed int]]*/);
            GetVertexArray$$1$$5$$4$$facets = (signed int *)return_value_malloc$26;
            i = 0;
            while(!(i >= 3 * numfacets))
            {
              fscanf(ph->ifp, "%d %d %d", &GetVertexArray$$1$$5$$4$$facets[(signed long int)i], &GetVertexArray$$1$$5$$4$$facets[(signed long int)(i + 1)], &GetVertexArray$$1$$5$$4$$facets[(signed long int)(i + 2)]);
              i = i + 3;
            }
            i = 0;
            while(!(i >= 3 * numfacets))
            {
              signed int GetVertexArray$$1$$5$$4$$2$$v0 = GetVertexArray$$1$$5$$4$$facets[(signed long int)i];
              signed int GetVertexArray$$1$$5$$4$$2$$v1 = GetVertexArray$$1$$5$$4$$facets[(signed long int)(i + 1)];
              signed int GetVertexArray$$1$$5$$4$$2$$v2 = GetVertexArray$$1$$5$$4$$facets[(signed long int)(i + 2)];
              if(GetVertexArray$$1$$5$$4$$2$$v0 >= 0)
              {
                if(GetVertexArray$$1$$5$$4$$2$$v0 >= vertexcount)
                  goto __CPROVER_DUMP_L34;

                if(!(GetVertexArray$$1$$5$$4$$2$$v1 >= 0))
                  goto __CPROVER_DUMP_L34;

                if(GetVertexArray$$1$$5$$4$$2$$v1 >= vertexcount)
                  goto __CPROVER_DUMP_L34;

                if(!(GetVertexArray$$1$$5$$4$$2$$v2 >= 0))
                  goto __CPROVER_DUMP_L34;

                if(GetVertexArray$$1$$5$$4$$2$$v2 >= vertexcount)
                  goto __CPROVER_DUMP_L34;

                GetVertexArray$$1$$5$$4$$2$$v0 = GetVertexArray$$1$$5$$4$$2$$v0 * 3;
                GetVertexArray$$1$$5$$4$$2$$v1 = GetVertexArray$$1$$5$$4$$2$$v1 * 3;
                GetVertexArray$$1$$5$$4$$2$$v2 = GetVertexArray$$1$$5$$4$$2$$v2 * 3;
                if(!(c == ((float *)NULL)))
                {
                  if(texusecount > 0)
                    tex=rt_texture_copy_vcstri(scene, tex);

                  struct anon$0 return_value_rt_vector$27;
                  return_value_rt_vector$27=rt_vector((double)v[(signed long int)GetVertexArray$$1$$5$$4$$2$$v0], (double)v[(signed long int)(GetVertexArray$$1$$5$$4$$2$$v0 + 1)], (double)v[(signed long int)(GetVertexArray$$1$$5$$4$$2$$v0 + 2)]);
                  struct anon$0 return_value_rt_vector$28;
                  return_value_rt_vector$28=rt_vector((double)v[(signed long int)GetVertexArray$$1$$5$$4$$2$$v1], (double)v[(signed long int)(GetVertexArray$$1$$5$$4$$2$$v1 + 1)], (double)v[(signed long int)(GetVertexArray$$1$$5$$4$$2$$v1 + 2)]);
                  struct anon$0 return_value_rt_vector$29;
                  return_value_rt_vector$29=rt_vector((double)v[(signed long int)GetVertexArray$$1$$5$$4$$2$$v2], (double)v[(signed long int)(GetVertexArray$$1$$5$$4$$2$$v2 + 1)], (double)v[(signed long int)(GetVertexArray$$1$$5$$4$$2$$v2 + 2)]);
                  struct anon$0 return_value_rt_vector$30;
                  return_value_rt_vector$30=rt_vector((double)n[(signed long int)GetVertexArray$$1$$5$$4$$2$$v0], (double)n[(signed long int)(GetVertexArray$$1$$5$$4$$2$$v0 + 1)], (double)n[(signed long int)(GetVertexArray$$1$$5$$4$$2$$v0 + 2)]);
                  struct anon$0 return_value_rt_vector$31;
                  return_value_rt_vector$31=rt_vector((double)n[(signed long int)GetVertexArray$$1$$5$$4$$2$$v1], (double)n[(signed long int)(GetVertexArray$$1$$5$$4$$2$$v1 + 1)], (double)n[(signed long int)(GetVertexArray$$1$$5$$4$$2$$v1 + 2)]);
                  struct anon$0 return_value_rt_vector$32;
                  return_value_rt_vector$32=rt_vector((double)n[(signed long int)GetVertexArray$$1$$5$$4$$2$$v2], (double)n[(signed long int)(GetVertexArray$$1$$5$$4$$2$$v2 + 1)], (double)n[(signed long int)(GetVertexArray$$1$$5$$4$$2$$v2 + 2)]);
                  struct anon$4 return_value_rt_color$33;
                  return_value_rt_color$33=rt_color((double)c[(signed long int)GetVertexArray$$1$$5$$4$$2$$v0], (double)c[(signed long int)(GetVertexArray$$1$$5$$4$$2$$v0 + 1)], (double)c[(signed long int)(GetVertexArray$$1$$5$$4$$2$$v0 + 2)]);
                  struct anon$4 return_value_rt_color$34;
                  return_value_rt_color$34=rt_color((double)c[(signed long int)GetVertexArray$$1$$5$$4$$2$$v1], (double)c[(signed long int)(GetVertexArray$$1$$5$$4$$2$$v1 + 1)], (double)c[(signed long int)(GetVertexArray$$1$$5$$4$$2$$v1 + 2)]);
                  struct anon$4 return_value_rt_color$35;
                  return_value_rt_color$35=rt_color((double)c[(signed long int)GetVertexArray$$1$$5$$4$$2$$v2], (double)c[(signed long int)(GetVertexArray$$1$$5$$4$$2$$v2 + 1)], (double)c[(signed long int)(GetVertexArray$$1$$5$$4$$2$$v2 + 2)]);
                  rt_vcstri(scene, tex, return_value_rt_vector$27, return_value_rt_vector$28, return_value_rt_vector$29, return_value_rt_vector$30, return_value_rt_vector$31, return_value_rt_vector$32, return_value_rt_color$33, return_value_rt_color$34, return_value_rt_color$35);
                }

                else
                {
                  struct anon$0 return_value_rt_vector$36;
                  return_value_rt_vector$36=rt_vector((double)v[(signed long int)GetVertexArray$$1$$5$$4$$2$$v0], (double)v[(signed long int)(GetVertexArray$$1$$5$$4$$2$$v0 + 1)], (double)v[(signed long int)(GetVertexArray$$1$$5$$4$$2$$v0 + 2)]);
                  struct anon$0 return_value_rt_vector$37;
                  return_value_rt_vector$37=rt_vector((double)v[(signed long int)GetVertexArray$$1$$5$$4$$2$$v1], (double)v[(signed long int)(GetVertexArray$$1$$5$$4$$2$$v1 + 1)], (double)v[(signed long int)(GetVertexArray$$1$$5$$4$$2$$v1 + 2)]);
                  struct anon$0 return_value_rt_vector$38;
                  return_value_rt_vector$38=rt_vector((double)v[(signed long int)GetVertexArray$$1$$5$$4$$2$$v2], (double)v[(signed long int)(GetVertexArray$$1$$5$$4$$2$$v2 + 1)], (double)v[(signed long int)(GetVertexArray$$1$$5$$4$$2$$v2 + 2)]);
                  struct anon$0 return_value_rt_vector$39;
                  return_value_rt_vector$39=rt_vector((double)n[(signed long int)GetVertexArray$$1$$5$$4$$2$$v0], (double)n[(signed long int)(GetVertexArray$$1$$5$$4$$2$$v0 + 1)], (double)n[(signed long int)(GetVertexArray$$1$$5$$4$$2$$v0 + 2)]);
                  struct anon$0 return_value_rt_vector$40;
                  return_value_rt_vector$40=rt_vector((double)n[(signed long int)GetVertexArray$$1$$5$$4$$2$$v1], (double)n[(signed long int)(GetVertexArray$$1$$5$$4$$2$$v1 + 1)], (double)n[(signed long int)(GetVertexArray$$1$$5$$4$$2$$v1 + 2)]);
                  struct anon$0 return_value_rt_vector$41;
                  return_value_rt_vector$41=rt_vector((double)n[(signed long int)GetVertexArray$$1$$5$$4$$2$$v2], (double)n[(signed long int)(GetVertexArray$$1$$5$$4$$2$$v2 + 1)], (double)n[(signed long int)(GetVertexArray$$1$$5$$4$$2$$v2 + 2)]);
                  rt_stri(scene, tex, return_value_rt_vector$36, return_value_rt_vector$37, return_value_rt_vector$38, return_value_rt_vector$39, return_value_rt_vector$40, return_value_rt_vector$41);
                }
              }

              else
              {

              __CPROVER_DUMP_L34:
                ;
                printf("trimesh error: skipping invalid vertex in facet %d\n", i / 3);
                printf("  numfacets: %d  vertexcount: %d\n", numfacets, vertexcount);
                printf("  verts: %d %d %d\n", GetVertexArray$$1$$5$$4$$2$$v0, GetVertexArray$$1$$5$$4$$2$$v1, GetVertexArray$$1$$5$$4$$2$$v2);
                rc = rc | (unsigned int)4;
                done = 1;
                goto __CPROVER_DUMP_L36;
              }
              texusecount = texusecount + 1;
              i = i + 3;
            }

          __CPROVER_DUMP_L36:
            ;
            free((void *)GetVertexArray$$1$$5$$4$$facets);
          }

          else
          {
            return_value_stringcmp$42=stringcmp(arraytype, "END_VERTEXARRAY");
            if(return_value_stringcmp$42 == 0)
              done = 1;

            else
            {
              printf("Unrecognized vertex array block `%s`\n", (const void *)arraytype);
              rc = rc | (unsigned int)4;
              done = 1;
            }
          }
        }
      }
    }
    if(done == 0)
      fscanf(ph->ifp, "%s", (const void *)arraytype);

  }
  if(!(v == ((float *)NULL)))
    free((void *)v);

  if(!(n == ((float *)NULL)))
    free((void *)n);

  if(!(c == ((float *)NULL)))
    free((void *)c);

  return rc;
}

// c::GetVol
// file ../demosrc/parse.c line 1228
static unsigned int GetVol(struct anon$6 *ph, void *scene)
{
  struct anon$0 min;
  struct anon$0 max;
  signed int x;
  signed int y;
  signed int z;
  char fname[255l];
  void *tex;
  unsigned int rc;
  rc=GetString(ph, "MIN");
  unsigned int return_value_GetVector$1;
  return_value_GetVector$1=GetVector(ph, &min);
  rc = rc | return_value_GetVector$1;
  unsigned int return_value_GetString$2;
  return_value_GetString$2=GetString(ph, "MAX");
  rc = rc | return_value_GetString$2;
  unsigned int return_value_GetVector$3;
  return_value_GetVector$3=GetVector(ph, &max);
  rc = rc | return_value_GetVector$3;
  unsigned int return_value_GetString$4;
  return_value_GetString$4=GetString(ph, "DIM");
  rc = rc | return_value_GetString$4;
  fscanf(ph->ifp, "%d %d %d ", &x, &y, &z);
  unsigned int return_value_GetString$5;
  return_value_GetString$5=GetString(ph, "FILE");
  rc = rc | return_value_GetString$5;
  fscanf(ph->ifp, "%s", (const void *)fname);
  unsigned int return_value_GetTexture$6;
  return_value_GetTexture$6=GetTexture(ph, scene, &tex);
  rc = rc | return_value_GetTexture$6;
  rt_scalarvol(scene, tex, min, max, x, y, z, fname, NULL);
  return rc;
}

// c::ImageMap
// file ../src/imap.c line 361
struct anon$4 ImageMap(const struct anon$33 *image, double u, double v)
{
  struct anon$4 col;
  struct anon$4 colx;
  struct anon$4 colx2;
  double x;
  double y;
  double px;
  double py;
  signed int ix;
  signed int iy;
  signed int nx;
  signed int ny;
  unsigned char *ptr;
  nx = image->xres > 1 ? 3 : 0;
  x = ((double)image->xres - 1.000000) * u;
  ix = (signed int)x;
  px = x - (double)ix;
  signed int tmp_if_expr$1;
  if(image->yres > 1)
    tmp_if_expr$1 = image->xres * 3;

  else
    tmp_if_expr$1 = 0;
  ny = tmp_if_expr$1;
  y = ((double)image->yres - 1.000000) * v;
  iy = (signed int)y;
  py = y - (double)iy;
  ptr = image->data + (signed long int)((image->xres * iy + ix) * 3);
  colx.r = (float)(double)((double)ptr[(signed long int)0] + px * ((double)ptr[(signed long int)nx] - (double)ptr[(signed long int)0]));
  colx.g = (float)(double)((double)ptr[(signed long int)1] + px * ((double)ptr[(signed long int)(nx + 1)] - (double)ptr[(signed long int)1]));
  colx.b = (float)(double)((double)ptr[(signed long int)2] + px * ((double)ptr[(signed long int)(nx + 2)] - (double)ptr[(signed long int)2]));
  ptr = ptr + (signed long int)ny;
  colx2.r = (float)((double)ptr[(signed long int)0] + px * ((double)ptr[(signed long int)nx] - (double)ptr[(signed long int)0]));
  colx2.g = (float)((double)ptr[(signed long int)1] + px * ((double)ptr[(signed long int)(nx + 1)] - (double)ptr[(signed long int)1]));
  colx2.b = (float)((double)ptr[(signed long int)2] + px * ((double)ptr[(signed long int)(nx + 2)] - (double)ptr[(signed long int)2]));
  col.r = (float)(((double)colx.r + py * (double)(colx2.r - colx.r)) / 255.000000);
  col.g = (float)(((double)colx.g + py * (double)(colx2.g - colx.g)) / 255.000000);
  col.b = (float)(((double)colx.b + py * (double)(colx2.b - colx.b)) / 255.000000);
  return col;
}

// c::InitNoise
// file ../src/texture.c line 357
void InitNoise(void)
{
  unsigned char x;
  unsigned char y;
  unsigned char z;
  unsigned char i;
  unsigned char j;
  unsigned char k;
  unsigned int rndval = (unsigned int)1234567;
  x = (unsigned char)0;
  while((signed int)x < 28)
  {
    y = (unsigned char)0;
    while((signed int)y < 28)
    {
      z = (unsigned char)0;
      while((signed int)z < 28)
      {
        unsigned int return_value_rt_rand$1;
        return_value_rt_rand$1=rt_rand(&rndval);
        NoiseMatrix[(signed long int)x][(signed long int)y][(signed long int)z] = (signed short int)(((double)return_value_rt_rand$1 / 4.294967e+9) * 12000.000000);
        if((signed int)x == 27)
          i = (unsigned char)0;

        else
          i = x;
        if((signed int)y == 27)
          j = (unsigned char)0;

        else
          j = y;
        if((signed int)z == 27)
          k = (unsigned char)0;

        else
          k = z;
        NoiseMatrix[(signed long int)x][(signed long int)y][(signed long int)z] = NoiseMatrix[(signed long int)i][(signed long int)j][(signed long int)k];
        z = z + 1;
      }
      y = y + 1;
    }
    x = x + 1;
  }
}

// c::InitRot3d
// file ../demosrc/parse.c line 135
static void InitRot3d(struct anon$8 *rot, double x, double y, double z)
{
  double return_value_cos$1;
  return_value_cos$1=cos(y);
  double return_value_cos$2;
  return_value_cos$2=cos(z);
  rot->rx1 = return_value_cos$1 * return_value_cos$2;
  double return_value_sin$3;
  return_value_sin$3=sin(x);
  double return_value_sin$4;
  return_value_sin$4=sin(y);
  double return_value_cos$5;
  return_value_cos$5=cos(z);
  double return_value_cos$6;
  return_value_cos$6=cos(x);
  double return_value_sin$7;
  return_value_sin$7=sin(z);
  rot->rx2 = return_value_sin$3 * return_value_sin$4 * return_value_cos$5 - return_value_cos$6 * return_value_sin$7;
  double return_value_sin$8;
  return_value_sin$8=sin(x);
  double return_value_sin$9;
  return_value_sin$9=sin(z);
  double return_value_cos$10;
  return_value_cos$10=cos(x);
  double return_value_cos$11;
  return_value_cos$11=cos(z);
  double return_value_sin$12;
  return_value_sin$12=sin(y);
  rot->rx3 = return_value_sin$8 * return_value_sin$9 + return_value_cos$10 * return_value_cos$11 * return_value_sin$12;
  double return_value_cos$13;
  return_value_cos$13=cos(y);
  double return_value_sin$14;
  return_value_sin$14=sin(z);
  rot->ry1 = return_value_cos$13 * return_value_sin$14;
  double return_value_cos$15;
  return_value_cos$15=cos(x);
  double return_value_cos$16;
  return_value_cos$16=cos(z);
  double return_value_sin$17;
  return_value_sin$17=sin(x);
  double return_value_sin$18;
  return_value_sin$18=sin(y);
  double return_value_sin$19;
  return_value_sin$19=sin(z);
  rot->ry2 = return_value_cos$15 * return_value_cos$16 + return_value_sin$17 * return_value_sin$18 * return_value_sin$19;
  double return_value_cos$20;
  return_value_cos$20=cos(x);
  double return_value_sin$21;
  return_value_sin$21=sin(y);
  double return_value_sin$22;
  return_value_sin$22=sin(z);
  double return_value_sin$23;
  return_value_sin$23=sin(x);
  double return_value_cos$24;
  return_value_cos$24=cos(z);
  rot->ry3 = return_value_cos$20 * return_value_sin$21 * return_value_sin$22 - return_value_sin$23 * return_value_cos$24;
  rot->rz1=sin(y);
  double return_value_sin$25;
  return_value_sin$25=sin(x);
  double return_value_cos$26;
  return_value_cos$26=cos(y);
  rot->rz2 = return_value_sin$25 * return_value_cos$26;
  double return_value_cos$27;
  return_value_cos$27=cos(x);
  double return_value_cos$28;
  return_value_cos$28=cos(y);
  rot->rz3 = return_value_cos$27 * return_value_cos$28;
}

// c::InitTextures
// file ../src/texture.h line 8
void InitTextures(void)
{
  InitNoise();
  ResetImages();
}

// c::LoadMIPMap
// file ../src/imap.h line 15
struct anon$34 * LoadMIPMap(const char *filename, signed int maxlevels)
{
  struct anon$33 *img;
  struct anon$34 *mip;
  img=AllocateImageFile(filename);
  if(img == ((struct anon$33 *)NULL))
    return (struct anon$34 *)NULL;

  LoadRawImage(img);
  mip=CreateMIPMap(img, maxlevels);
  if(mip == ((struct anon$34 *)NULL))
  {
    DeallocateImage(img);
    free((void *)mip);
    return (struct anon$34 *)NULL;
  }

  return mip;
}

// c::LoadRawImage
// file ../src/imap.c line 35
void LoadRawImage(struct anon$33 *image)
{
  if(image->loaded == 0)
  {
    readimage(image);
    image->loaded = 1;
  }

}

// c::LoadVol
// file ../src/vol.c line 271
void LoadVol(struct anon$10 *vol)
{
  struct _IO_FILE$link28 *dfile;
  dfile=fopen(vol->name, "r");
  if(dfile == ((struct _IO_FILE$link28 *)NULL))
  {
    char LoadVol$$1$$1$$msgtxt[2048l];
    sprintf(LoadVol$$1$$1$$msgtxt, "Can't load volume %s, using object color", (const void *)vol->name);
    rt_ui_message(200, LoadVol$$1$$1$$msgtxt);
    return;
  }

  signed int return_value_rt_mynode$1;
  return_value_rt_mynode$1=rt_mynode();
  if(return_value_rt_mynode$1 == 0)
  {
    char LoadVol$$1$$2$$msgtxt[2048l];
    sprintf(LoadVol$$1$$2$$msgtxt, "Loading %dx%dx%d volume set from %s", vol->xres, vol->yres, vol->zres, (const void *)vol->name);
    rt_ui_message(100, LoadVol$$1$$2$$msgtxt);
  }

  void *return_value_malloc$2;
  return_value_malloc$2=malloc((unsigned long int)(vol->xres * vol->yres * vol->zres));
  vol->data = (unsigned char *)return_value_malloc$2;
  fread((void *)vol->data, (unsigned long int)1, (unsigned long int)(vol->xres * vol->yres * vol->zres), dfile);
  vol->loaded = 1;
}

// c::MIPMap
// file ../src/imap.h line 18
struct anon$4 MIPMap(const struct anon$34 *mip, double u, double v, double d)
{
  signed int mapindex;
  double mapflt;
  struct anon$4 col;
  struct anon$4 col1;
  struct anon$4 col2;
  if(u <= 1.000000)
  {
    if(!(u >= 0.000000))
      goto __CPROVER_DUMP_L5;

    if(!(v <= 1.000000))
      goto __CPROVER_DUMP_L5;

    if(!(v >= 0.000000))
      goto __CPROVER_DUMP_L5;

    if(d > 1.000000)
      d = 1.000000;

    else
      if(d < 0.000000)
        d = 0.000000;

    mapflt = d * ((double)mip->levels - 9.999000e-1);
    mapindex = (signed int)mapflt;
    mapflt = mapflt - (double)mapindex;
    if(!(mapindex >= -2 + mip->levels))
    {
      col1=ImageMap(mip->images[(signed long int)mapindex], u, v);
      col2=ImageMap(mip->images[(signed long int)(mapindex + 1)], u, v);
      col.r = (float)((double)col1.r + mapflt * (double)(col2.r - col1.r));
      col.g = (float)((double)col1.g + mapflt * (double)(col2.g - col1.g));
      col.b = (float)((double)col1.b + mapflt * (double)(col2.b - col1.b));
    }

    else
      col=ImageMap(mip->images[(signed long int)(mip->levels - 1)], u, v);
  }

  else
  {

  __CPROVER_DUMP_L5:
    ;
    col.r = (float)0.000000;
    col.g = (float)0.000000;
    col.b = (float)0.000000;
  }
  return col;
}

// c::NFFGetBackground
// file ../demosrc/nffparse.c line 134
signed int NFFGetBackground(struct _IO_FILE$link5 *dfile, void *scene)
{
  float r;
  float g;
  float b;
  fscanf(dfile, "%f %f %f", &r, &g, &b);
  backgr.r = r;
  backgr.g = g;
  backgr.b = b;
  return 0;
}

// c::NFFGetCylCone
// file ../demosrc/nffparse.c line 185
signed int NFFGetCylCone(struct _IO_FILE$link5 *dfile, void *scene)
{
  struct anon$0 pnt1;
  struct anon$0 pnt2;
  struct anon$0 ctr;
  struct anon$0 axis;
  float baserad;
  float apexrad;
  NFFGetVector(dfile, &pnt1);
  fscanf(dfile, "%f", &baserad);
  NFFGetVector(dfile, &pnt2);
  fscanf(dfile, "%f", &apexrad);
  ctr = pnt1;
  axis.x = pnt2.x - pnt1.x;
  axis.y = pnt2.y - pnt1.y;
  axis.z = pnt2.z - pnt1.z;
  rt_fcylinder(scene, curtexture, ctr, axis, (double)baserad);
  return 0;
}

// c::NFFGetLight
// file ../demosrc/nffparse.c line 144
signed int NFFGetLight(struct _IO_FILE$link5 *dfile, void *scene)
{
  double rad;
  struct anon$0 ctr;
  struct anon$7 tex;
  float r;
  float g;
  float b;
  NFFGetVector(dfile, &ctr);
  rad = 1.000000;
  b = (float)1.000000;
  g = b;
  r = g;
  fscanf(dfile, "%f %f %f", &r, &g, &b);
  tex.col.r = r;
  tex.col.g = g;
  tex.col.b = b;
  void *return_value_rt_texture$1;
  return_value_rt_texture$1=rt_texture(scene, &tex);
  rt_light(scene, return_value_rt_texture$1, ctr, rad);
  return 0;
}

// c::NFFGetObject
// file ../demosrc/nffparse.c line 261
signed int NFFGetObject(struct _IO_FILE$link5 *dfile, void *scene)
{
  char objtype[80l];
  signed int return_value_fscanf$1;
  return_value_fscanf$1=fscanf(dfile, "%s", (const void *)objtype);
  if(!(return_value_fscanf$1 == 1))
    return 3;

  signed int return_value_NFFstringcmp$3;
  return_value_NFFstringcmp$3=NFFstringcmp(objtype, "v");
  if(return_value_NFFstringcmp$3 == 0)
  {
    signed int return_value_NFFGetScenedefs$2;
    return_value_NFFGetScenedefs$2=NFFGetScenedefs(dfile, scene);
    return return_value_NFFGetScenedefs$2;
  }

  signed int return_value_NFFstringcmp$5;
  return_value_NFFstringcmp$5=NFFstringcmp(objtype, "b");
  if(return_value_NFFstringcmp$5 == 0)
  {
    signed int return_value_NFFGetBackground$4;
    return_value_NFFGetBackground$4=NFFGetBackground(dfile, scene);
    return return_value_NFFGetBackground$4;
  }

  signed int return_value_NFFstringcmp$7;
  return_value_NFFstringcmp$7=NFFstringcmp(objtype, "l");
  if(return_value_NFFstringcmp$7 == 0)
  {
    signed int return_value_NFFGetLight$6;
    return_value_NFFGetLight$6=NFFGetLight(dfile, scene);
    return return_value_NFFGetLight$6;
  }

  signed int return_value_NFFstringcmp$9;
  return_value_NFFstringcmp$9=NFFstringcmp(objtype, "f");
  if(return_value_NFFstringcmp$9 == 0)
  {
    signed int return_value_NFFGetTexture$8;
    return_value_NFFGetTexture$8=NFFGetTexture(dfile, scene);
    return return_value_NFFGetTexture$8;
  }

  signed int return_value_NFFstringcmp$11;
  return_value_NFFstringcmp$11=NFFstringcmp(objtype, "s");
  if(return_value_NFFstringcmp$11 == 0)
  {
    signed int return_value_NFFGetSphere$10;
    return_value_NFFGetSphere$10=NFFGetSphere(dfile, scene);
    return return_value_NFFGetSphere$10;
  }

  signed int return_value_NFFstringcmp$13;
  return_value_NFFstringcmp$13=NFFstringcmp(objtype, "c");
  if(return_value_NFFstringcmp$13 == 0)
  {
    signed int return_value_NFFGetCylCone$12;
    return_value_NFFGetCylCone$12=NFFGetCylCone(dfile, scene);
    return return_value_NFFGetCylCone$12;
  }

  signed int return_value_NFFstringcmp$15;
  return_value_NFFstringcmp$15=NFFstringcmp(objtype, "p");
  if(return_value_NFFstringcmp$15 == 0)
  {
    signed int return_value_NFFGetPolygon$14;
    return_value_NFFGetPolygon$14=NFFGetPolygon(dfile, scene);
    return return_value_NFFGetPolygon$14;
  }

  signed int return_value_NFFstringcmp$17;
  return_value_NFFstringcmp$17=NFFstringcmp(objtype, "pp");
  if(return_value_NFFstringcmp$17 == 0)
  {
    signed int return_value_NFFGetPatch$16;
    return_value_NFFGetPatch$16=NFFGetPatch(dfile, scene);
    return return_value_NFFGetPatch$16;
  }

  return 3;
}

// c::NFFGetPatch
// file ../demosrc/nffparse.c line 238
signed int NFFGetPatch(struct _IO_FILE$link5 *dfile, void *scene)
{
  signed int numverts;
  signed int i;
  struct anon$0 v0;
  struct anon$0 n0;
  struct anon$0 vold;
  struct anon$0 nold;
  struct anon$0 vnew;
  struct anon$0 nnew;
  fscanf(dfile, "%d", &numverts);
  NFFGetVector(dfile, &v0);
  NFFGetVector(dfile, &n0);
  NFFGetVector(dfile, &vold);
  NFFGetVector(dfile, &nold);
  i = 2;
  while(!(i >= numverts))
  {
    NFFGetVector(dfile, &vnew);
    NFFGetVector(dfile, &nnew);
    rt_stri(scene, curtexture, v0, vold, vnew, n0, nold, nnew);
    vold = vnew;
    nold = nnew;
    i = i + 1;
  }
  return 0;
}

// c::NFFGetPolygon
// file ../demosrc/nffparse.c line 221
signed int NFFGetPolygon(struct _IO_FILE$link5 *dfile, void *scene)
{
  signed int numverts;
  signed int i;
  struct anon$0 v0;
  struct anon$0 vold;
  struct anon$0 vnew;
  fscanf(dfile, "%d", &numverts);
  NFFGetVector(dfile, &v0);
  NFFGetVector(dfile, &vold);
  i = 2;
  while(!(i >= numverts))
  {
    NFFGetVector(dfile, &vnew);
    rt_tri(scene, curtexture, v0, vold, vnew);
    vold = vnew;
    i = i + 1;
  }
  return 0;
}

// c::NFFGetScenedefs
// file ../demosrc/nffparse.c line 86
signed int NFFGetScenedefs(struct _IO_FILE$link5 *dfile, void *scene)
{
  struct anon$0 Ccenter;
  struct anon$0 Cview;
  struct anon$0 Cup;
  double zoom;
  double aspectratio;
  signed int raydepth;
  signed int antialiasing;
  signed int xres;
  signed int yres;
  signed int verbose;
  struct anon$0 lookat;
  float vangle;
  float hither;
  NFFGetString(dfile, "from");
  NFFGetVector(dfile, &Ccenter);
  NFFGetString(dfile, "at");
  NFFGetVector(dfile, &lookat);
  Cview.x = lookat.x - Ccenter.x;
  Cview.y = lookat.y - Ccenter.y;
  Cview.z = lookat.z - Ccenter.z;
  NFFGetString(dfile, "up");
  NFFGetVector(dfile, &Cup);
  NFFGetString(dfile, "angle");
  fscanf(dfile, "%f", &vangle);
  zoom = 1.000000;
  aspectratio = 1.000000;
  NFFGetString(dfile, "hither");
  fscanf(dfile, "%f", &hither);
  NFFGetString(dfile, "resolution");
  fscanf(dfile, "%d %d", &xres, &yres);
  antialiasing = 0;
  raydepth = 6;
  verbose = 0;
  rt_outputfile(scene, "outfile.tga");
  rt_resolution(scene, xres, yres);
  rt_verbose(scene, verbose);
  rt_camera_setup(scene, zoom, aspectratio, antialiasing, raydepth, Ccenter, Cview, Cup);
  rt_background(scene, backgr);
  return 0;
}

// c::NFFGetSphere
// file ../demosrc/nffparse.c line 207
signed int NFFGetSphere(struct _IO_FILE$link5 *dfile, void *scene)
{
  double rad;
  struct anon$0 ctr;
  float a;
  NFFGetVector(dfile, &ctr);
  fscanf(dfile, "%f", &a);
  rad = (double)a;
  rt_sphere(scene, curtexture, ctr, rad);
  return 0;
}

// c::NFFGetString
// file ../demosrc/nffparse.c line 42
void NFFGetString(struct _IO_FILE$link5 *dfile, char *string)
{
  char data[100l];
  fscanf(dfile, "%s", (const void *)data);
  signed int return_value_NFFstringcmp$1;
  return_value_NFFstringcmp$1=NFFstringcmp(data, string);
  if(!(return_value_NFFstringcmp$1 == 0))
  {
    printf("parse: Expected %s, got %s \n", string, (const void *)data);
    printf("Rendering terminated. \n");
    exit(1);
  }

}

// c::NFFGetTexture
// file ../demosrc/nffparse.c line 165
signed int NFFGetTexture(struct _IO_FILE$link5 *dfile, void *scene)
{
  struct anon$7 tex;
  float r;
  float g;
  float b;
  float Kd;
  float Ks;
  float Shine;
  float T;
  float IOR;
  fscanf(dfile, "%f %f %f %f %f %f %f %f", &r, &g, &b, &Kd, &Ks, &Shine, &T, &IOR);
  tex.col.r = r;
  tex.col.g = g;
  tex.col.b = b;
  tex.ambient = 1.000000e-1;
  tex.diffuse = (double)Kd;
  tex.specular = (double)Ks;
  tex.opacity = (double)T > 9.900000e-1 ? 0.000000 : 1.000000 - (double)T;
  tex.texturefunc = 0;
  curtexture=rt_texture(scene, &tex);
  return 0;
}

// c::NFFGetVector
// file ../demosrc/nffparse.c line 54
void NFFGetVector(struct _IO_FILE$link5 *dfile, struct anon$0 *v1)
{
  float a;
  float b;
  float c;
  fscanf(dfile, "%f %f %f", &a, &b, &c);
  v1->x = (double)a;
  v1->y = (double)b;
  v1->z = (double)c;
}

// c::NFFstringcmp
// file ../demosrc/nffparse.c line 24
signed int NFFstringcmp(char *a, char *b)
{
  signed int i;
  signed int s;
  signed int l;
  unsigned long int return_value_strlen$1;
  return_value_strlen$1=strlen(a);
  s = (signed int)return_value_strlen$1;
  unsigned long int return_value_strlen$2;
  return_value_strlen$2=strlen(b);
  l = (signed int)return_value_strlen$2;
  if(!(s == l))
    return 1;

  i = 0;
  signed int tmp_statement_expression$3;
  signed int tmp_if_expr$5;
  const signed int **return_value___ctype_toupper_loc$6;
  signed int tmp_statement_expression$7;
  signed int tmp_if_expr$9;
  const signed int **return_value___ctype_toupper_loc$10;
  while(!(i >= s))
  {
    signed int NFFstringcmp$$1$$1$$1$$__res;
    if(FALSE)
    {
      if(FALSE)
      {
        signed int NFFstringcmp$$1$$1$$1$$1$$1$$__c = (signed int)a[(signed long int)i];
        if(!(NFFstringcmp$$1$$1$$1$$1$$1$$__c < -128))
        {
          if(NFFstringcmp$$1$$1$$1$$1$$1$$__c > 255)
            goto __CPROVER_DUMP_L3;

        }

        else
        {

        __CPROVER_DUMP_L3:
          ;
          tmp_if_expr$5 = NFFstringcmp$$1$$1$$1$$1$$1$$__c;
          goto __CPROVER_DUMP_L5;
        }
        const signed int **return_value___ctype_toupper_loc$4;
        return_value___ctype_toupper_loc$4=__ctype_toupper_loc();
        tmp_if_expr$5 = (*return_value___ctype_toupper_loc$4)[(signed long int)NFFstringcmp$$1$$1$$1$$1$$1$$__c];

      __CPROVER_DUMP_L5:
        ;
        NFFstringcmp$$1$$1$$1$$__res = tmp_if_expr$5;
      }

      else
        NFFstringcmp$$1$$1$$1$$__res=toupper((signed int)a[(signed long int)i]);
    }

    else
    {
      return_value___ctype_toupper_loc$6=__ctype_toupper_loc();
      NFFstringcmp$$1$$1$$1$$__res = (*return_value___ctype_toupper_loc$6)[(signed long int)(signed int)a[(signed long int)i]];
    }
    tmp_statement_expression$3 = NFFstringcmp$$1$$1$$1$$__res;
    signed int NFFstringcmp$$1$$1$$2$$__res;
    if(FALSE)
    {
      if(FALSE)
      {
        signed int NFFstringcmp$$1$$1$$2$$1$$1$$__c = (signed int)b[(signed long int)i];
        if(!(NFFstringcmp$$1$$1$$2$$1$$1$$__c < -128))
        {
          if(NFFstringcmp$$1$$1$$2$$1$$1$$__c > 255)
            goto __CPROVER_DUMP_L10;

        }

        else
        {

        __CPROVER_DUMP_L10:
          ;
          tmp_if_expr$9 = NFFstringcmp$$1$$1$$2$$1$$1$$__c;
          goto __CPROVER_DUMP_L12;
        }
        const signed int **return_value___ctype_toupper_loc$8;
        return_value___ctype_toupper_loc$8=__ctype_toupper_loc();
        tmp_if_expr$9 = (*return_value___ctype_toupper_loc$8)[(signed long int)NFFstringcmp$$1$$1$$2$$1$$1$$__c];

      __CPROVER_DUMP_L12:
        ;
        NFFstringcmp$$1$$1$$2$$__res = tmp_if_expr$9;
      }

      else
        NFFstringcmp$$1$$1$$2$$__res=toupper((signed int)b[(signed long int)i]);
    }

    else
    {
      return_value___ctype_toupper_loc$10=__ctype_toupper_loc();
      NFFstringcmp$$1$$1$$2$$__res = (*return_value___ctype_toupper_loc$10)[(signed long int)(signed int)b[(signed long int)i]];
    }
    tmp_statement_expression$7 = NFFstringcmp$$1$$1$$2$$__res;
    if(!(tmp_statement_expression$3 == tmp_statement_expression$7))
      return 1;

    i = i + 1;
  }
  return 0;
}

// c::NewImage
// file ../src/imap.c line 110
struct anon$33 * NewImage(signed int x, signed int y, signed int z)
{
  struct anon$33 *newimage = (struct anon$33 *)NULL;
  void *return_value_malloc$1;
  return_value_malloc$1=malloc(128ul /*[[struct anon$33]]*/);
  newimage = (struct anon$33 *)return_value_malloc$1;
  if(newimage == ((struct anon$33 *)NULL))
    return (struct anon$33 *)NULL;

  newimage->loaded = 1;
  newimage->xres = x;
  newimage->yres = y;
  newimage->zres = z;
  newimage->bpp = 0;
  void *return_value_malloc$2;
  return_value_malloc$2=malloc((unsigned long int)(x * y * z * 3));
  newimage->data = (unsigned char *)return_value_malloc$2;
  if(newimage->data == ((unsigned char *)NULL))
  {
    free((void *)newimage);
    return (struct anon$33 *)NULL;
  }

  return newimage;
}

// c::Noise
// file ../src/texture.c line 381
signed int Noise(double x, double y, double z)
{
  unsigned char ix;
  unsigned char iy;
  unsigned char iz;
  double ox;
  double oy;
  double oz;
  signed int p000;
  signed int p001;
  signed int p010;
  signed int p011;
  signed int p100;
  signed int p101;
  signed int p110;
  signed int p111;
  signed int p00;
  signed int p01;
  signed int p10;
  signed int p11;
  signed int p0;
  signed int p1;
  signed int d00;
  signed int d01;
  signed int d10;
  signed int d11;
  signed int d0;
  signed int d1;
  signed int d;
  x=fabs(x);
  y=fabs(y);
  z=fabs(z);
  ix = (unsigned char)((signed int)x % 28);
  iy = (unsigned char)((signed int)y % 28);
  iz = (unsigned char)((signed int)z % 28);
  ox = x - (double)(signed int)x;
  oy = y - (double)(signed int)y;
  oz = z - (double)(signed int)z;
  p000 = (signed int)NoiseMatrix[(signed long int)ix][(signed long int)iy][(signed long int)iz];
  p001 = (signed int)NoiseMatrix[(signed long int)ix][(signed long int)iy][(signed long int)((signed int)iz + 1)];
  p010 = (signed int)NoiseMatrix[(signed long int)ix][(signed long int)((signed int)iy + 1)][(signed long int)iz];
  p011 = (signed int)NoiseMatrix[(signed long int)ix][(signed long int)((signed int)iy + 1)][(signed long int)((signed int)iz + 1)];
  p100 = (signed int)NoiseMatrix[(signed long int)((signed int)ix + 1)][(signed long int)iy][(signed long int)iz];
  p101 = (signed int)NoiseMatrix[(signed long int)((signed int)ix + 1)][(signed long int)iy][(signed long int)((signed int)iz + 1)];
  p110 = (signed int)NoiseMatrix[(signed long int)((signed int)ix + 1)][(signed long int)((signed int)iy + 1)][(signed long int)iz];
  p111 = (signed int)NoiseMatrix[(signed long int)((signed int)ix + 1)][(signed long int)((signed int)iy + 1)][(signed long int)((signed int)iz + 1)];
  d00 = p100 - p000;
  d01 = p101 - p001;
  d10 = p110 - p010;
  d11 = p111 - p011;
  p00 = (signed int)((double)(signed int)d00 * ox) + p000;
  p01 = (signed int)((double)(signed int)d01 * ox) + p001;
  p10 = (signed int)((double)(signed int)d10 * ox) + p010;
  p11 = (signed int)((double)(signed int)d11 * ox) + p011;
  d0 = p10 - p00;
  d1 = p11 - p01;
  p0 = (signed int)((double)(signed int)d0 * oy) + p00;
  p1 = (signed int)((double)(signed int)d1 * oy) + p01;
  d = p1 - p0;
  return (signed int)((double)(signed int)d * oz) + p0;
}

// c::ParseAC3D
// file ../demosrc/ac3dparse.h line 13
unsigned int ParseAC3D(char *modelfile, void *scene)
{
  struct _IO_FILE$link6 *dfile;
  char filehdr[255l];
  unsigned int rc;
  reset_tex_table$link39();
  dfile = (struct _IO_FILE$link6 *)NULL;
  dfile=fopen(modelfile, "r");
  if(dfile == ((struct _IO_FILE$link6 *)NULL))
    return (unsigned int)1;

  fscanf(dfile, "%s", (const void *)filehdr);
  signed int tmp_statement_expression$1;
  unsigned long int __s1_len;
  unsigned long int __s2_len;
  _Bool tmp_if_expr$3;
  unsigned int return_value___builtin_strlen$2;
  if(TRUE)
  {
    if(!((unsigned long int)("AC3Db" + 1l) + -((unsigned long int)"AC3Db") == 1ul))
      goto __CPROVER_DUMP_L2;

    return_value___builtin_strlen$2=__builtin_strlen("AC3Db");
    __s2_len = (unsigned long int)return_value___builtin_strlen$2;
    tmp_if_expr$3 = __s2_len < (unsigned long int)4 ? TRUE : FALSE;
  }

  else
  {

  __CPROVER_DUMP_L2:
    ;
    tmp_if_expr$3 = FALSE;
  }
  signed int tmp_if_expr$6;
  signed int tmp_statement_expression$4;
  signed int return_value___builtin_strcmp$5;
  if(tmp_if_expr$3)
  {
    const unsigned char *__s1 = (const unsigned char *)(const char *)filehdr;
    signed int __result = (signed int)__s1[(signed long int)0] - (signed int)((const unsigned char *)(const char *)"AC3Db")[(signed long int)0];
    if(__s2_len > 0ul)
    {
      if(__result == 0)
      {
        __result = (signed int)__s1[(signed long int)1] - (signed int)((const unsigned char *)(const char *)"AC3Db")[(signed long int)1];
        if(__s2_len > 1ul)
        {
          if(__result == 0)
          {
            __result = (signed int)__s1[(signed long int)2] - (signed int)((const unsigned char *)(const char *)"AC3Db")[(signed long int)2];
            if(__s2_len > 2ul)
            {
              if(__result == 0)
                __result = (signed int)__s1[(signed long int)3] - (signed int)((const unsigned char *)(const char *)"AC3Db")[(signed long int)3];

            }

          }

        }

      }

    }

    tmp_statement_expression$4 = __result;
    tmp_if_expr$6 = tmp_statement_expression$4;
  }

  else
  {
    return_value___builtin_strcmp$5=__builtin_strcmp(filehdr, "AC3Db");
    tmp_if_expr$6 = return_value___builtin_strcmp$5;
  }
  tmp_statement_expression$1 = tmp_if_expr$6;
  if(!(tmp_statement_expression$1 == 0))
  {
    printf("Unknown version of AC3D Model File Format\n");
    fclose(dfile);
    return (unsigned int)1;
  }

  rc=GetScenedefs$link61(dfile, scene);
  if(!(rc == 0u))
    return rc;

  scenebackcol.r = (float)0.000000;
  scenebackcol.g = (float)0.000000;
  scenebackcol.b = (float)0.000000;
  numobjectsparsed = 0;
  do
  {
    rc=GetScene(dfile, scene);
    if(!(rc == 0u))
      goto __CPROVER_DUMP_L10;

    numobjectsparsed = numobjectsparsed + 1;
  }
  while(TRUE);

__CPROVER_DUMP_L10:
  ;
  fclose(dfile);
  if(rc == 8u)
    rc = (unsigned int)0;

  rt_background(scene, scenebackcol);
  return rc;
}

// c::ParseNFF
// file ../demosrc/nffparse.h line 12
unsigned int ParseNFF(char *nffname, void *scene)
{
  struct _IO_FILE$link5 *dfile;
  backgr.r = (float)0.000000;
  backgr.g = (float)0.000000;
  backgr.b = (float)0.000000;
  if(nffname == ((char *)NULL))
    return (unsigned int)1;

  else
  {
    dfile=fopen(nffname, "r");
    if(dfile == ((struct _IO_FILE$link5 *)NULL))
      return (unsigned int)1;

  }
  signed int return_value_NFFGetObject$1;
  do
  {
    return_value_NFFGetObject$1=NFFGetObject(dfile, scene);
    if(!(return_value_NFFGetObject$1 == 0))
      goto __CPROVER_DUMP_L3;

  }
  while(TRUE);

__CPROVER_DUMP_L3:
  ;
  rt_background(scene, backgr);
  return (unsigned int)0;
}

// c::PrintSyntaxError
// file ../demosrc/parse.c line 169
static void PrintSyntaxError(struct anon$6 *ph, const char *string, const char *found)
{
  signed long int streampos;
  signed long int readsize;
  signed long int i;
  signed long int j;
  signed long int linecount;
  char cbuf[65536l];
  streampos=ftell(ph->ifp);
  fseek(ph->ifp, (signed long int)0, 0);
  i = (signed long int)0;
  linecount = (signed long int)0;
  while(!(i >= streampos))
  {
    if(streampos + -i > 65536l)
      readsize = (signed long int)65536;

    else
      readsize = streampos - i;
    fread((void *)cbuf, (unsigned long int)readsize, (unsigned long int)1, ph->ifp);
    i = i + readsize;
    j = (signed long int)0;
    while(!(j >= readsize))
    {
      if((signed int)cbuf[j] == 10)
        linecount = linecount + 1l;

      j = j + 1l;
    }
  }
  printf("Parse Error:\n");
  printf("   Encountered a syntax error in file %s\n", ph->filename);
  printf("   Expected to find %s\n", string);
  printf("   Actually found: %s\n", found);
  printf("   Error occured at or prior to file offset %ld, line %ld\n", streampos, linecount);
  printf("   Error position is only approximate, but should be close\n\n");
  fseek(ph->ifp, streampos, 0);
}

// c::Raypnt
// file ../src/vector.h line 14
struct anon$0 Raypnt(struct ray_t$link130 *a, double t)
{
  struct anon$0 temp;
  temp.x = a->o.x + a->d.x * t;
  temp.y = a->o.y + a->d.y * t;
  temp.z = a->o.z + a->d.z * t;
  return temp;
}

// c::ReadIncludeFile
// file ../demosrc/parse.c line 277
static unsigned int ReadIncludeFile(struct anon$6 *ph, const char *includefile, void *scene)
{
  unsigned int rc;
  const char *oldfilename = ph->filename;
  struct _IO_FILE$link13 *oldfp = ph->ifp;
  signed int tmp_statement_expression$1;
  unsigned long int __s1_len;
  unsigned long int __s2_len;
  signed int return_value___builtin_strcmp$2;
  return_value___builtin_strcmp$2=__builtin_strcmp(includefile, ph->filename);
  tmp_statement_expression$1 = return_value___builtin_strcmp$2;
  if(tmp_statement_expression$1 == 0)
    printf("Warning: possible self-recursive include of file %s\n", includefile);

  ph->filename = includefile;
  ph->ifp=fopen(includefile, "r");
  if(ph->ifp == ((struct _IO_FILE$link13 *)NULL))
  {
    printf("Parser failed trying to open file: %s\n", includefile);
    ph->filename = oldfilename;
    ph->ifp = oldfp;
    return (unsigned int)2;
  }

  do
  {
    rc=GetObject(ph, scene);
    if(!(rc == 0u))
      goto __CPROVER_DUMP_L3;

    ph->numobjectsparsed = ph->numobjectsparsed + 1;
  }
  while(TRUE);

__CPROVER_DUMP_L3:
  ;
  fclose(ph->ifp);
  ph->filename = oldfilename;
  ph->ifp = oldfp;
  if(rc == 8u)
    rc = (unsigned int)0;

  return rc;
}

// c::ResetImages
// file ../src/imap.h line 12
void ResetImages(void)
{
  signed int i;
  numimages = 0;
  i = 0;
  while(i < 39)
  {
    imagelist[(signed long int)i] = (struct anon$33 *)NULL;
    i = i + 1;
  }
}

// c::RmatIdentity
// file ../demosrc/ac3dparse.c line 238
static void RmatIdentity(float (*rmat)[3l])
{
  signed int i;
  signed int j = 0;
  while(j < 3)
  {
    i = 0;
    while(i < 3)
    {
      if(i == j)
        rmat[(signed long int)j][(signed long int)i] = (float)1.000000;

      else
        rmat[(signed long int)j][(signed long int)i] = (float)0.000000;
      i = i + 1;
    }
    j = j + 1;
  }
}

// c::RmatMult
// file ../demosrc/ac3dparse.c line 250
static void RmatMult(float (*A)[3l], float (*B)[3l], float (*C)[3l])
{
  signed int i;
  signed int j;
  signed int k = 0;
  while(k < 3)
  {
    j = 0;
    while(j < 3)
    {
      A[(signed long int)k][(signed long int)j] = (float)0.000000;
      i = 0;
      while(i < 3)
      {
        A[(signed long int)k][(signed long int)j] = A[(signed long int)k][(signed long int)j] + B[(signed long int)k][(signed long int)i] * C[(signed long int)i][(signed long int)j];
        i = i + 1;
      }
      j = j + 1;
    }
    k = k + 1;
  }
}

// c::RmatTmatMult
// file ../demosrc/ac3dparse.c line 263
static void RmatTmatMult(float *NT, float (*R)[3l], float *T)
{
  signed int i;
  signed int j = 0;
  while(j < 3)
  {
    NT[(signed long int)j] = (float)0.000000;
    i = 0;
    while(i < 3)
    {
      NT[(signed long int)j] = NT[(signed long int)j] + R[(signed long int)j][(signed long int)i] * T[(signed long int)i];
      i = i + 1;
    }
    j = j + 1;
  }
}

// c::Rotate3d
// file ../demosrc/parse.c line 149
static void Rotate3d(struct anon$8 *rot, struct anon$0 *vec)
{
  struct anon$0 tmp;
  tmp.x = vec->x * rot->rx1 + vec->y * rot->rx2 + vec->z * rot->rx3;
  tmp.y = vec->x * rot->ry1 + vec->y * rot->ry2 + vec->z * rot->ry3;
  tmp.z = vec->x * rot->rz1 + vec->y * rot->rz2 + vec->z * rot->rz3;
  *vec = tmp;
}

// c::Scale3d
// file ../demosrc/parse.c line 157
static void Scale3d(struct anon$0 *scale, struct anon$0 *vec)
{
  vec->x = vec->x * scale->x;
  vec->y = vec->y * scale->y;
  vec->z = vec->z * scale->z;
}

// c::Trans3d
// file ../demosrc/parse.c line 163
static void Trans3d(struct anon$0 *trans, struct anon$0 *vec)
{
  vec->x = vec->x + trans->x;
  vec->y = vec->y + trans->y;
  vec->z = vec->z + trans->z;
}

// c::VAdd
// file ../src/vector.h line 11
void VAdd(const struct anon$0 *a, const struct anon$0 *b, struct anon$0 *c)
{
  c->x = a->x + b->x;
  c->y = a->y + b->y;
  c->z = a->z + b->z;
}

// c::VAddS
// file ../src/vector.c line 48
void VAddS(double a, const struct anon$0 *A, const struct anon$0 *B, struct anon$0 *C)
{
  C->x = a * A->x + B->x;
  C->y = a * A->y + B->y;
  C->z = a * A->z + B->z;
}

// c::VCross
// file ../src/vector.h line 8
void VCross(const struct anon$0 *a, const struct anon$0 *b, struct anon$0 *c)
{
  c->x = a->y * b->z - a->z * b->y;
  c->y = a->z * b->x - a->x * b->z;
  c->z = a->x * b->y - a->y * b->x;
}

// c::VDot
// file ../src/vector.h line 7
double VDot(const struct anon$0 *a, const struct anon$0 *b)
{
  return a->x * b->x + a->y * b->y + a->z * b->z;
}

// c::VLength
// file ../src/vector.h line 9
double VLength(const struct anon$0 *a)
{
  double return_value_sqrt$1;
  return_value_sqrt$1=sqrt(a->x * a->x + a->y * a->y + a->z * a->z);
  return (double)return_value_sqrt$1;
}

// c::VNorm
// file ../src/vector.h line 10
void VNorm(struct anon$0 *a)
{
  double len;
  len=sqrt(a->x * a->x + a->y * a->y + a->z * a->z);
  if(IEEE_FLOAT_NOTEQUAL(len, 0.000000))
  {
    a->x = a->x / len;
    a->y = a->y / len;
    a->z = a->z / len;
  }

}

// c::VScale
// file ../src/vector.c line 64
void VScale(struct anon$0 *a, double s)
{
  a->x = a->x * s;
  a->y = a->y * s;
  a->z = a->z * s;
}

// c::VSub
// file ../src/vector.h line 12
void VSub(const struct anon$0 *a, const struct anon$0 *b, struct anon$0 *c)
{
  c->x = a->x - b->x;
  c->y = a->y - b->y;
  c->z = a->z - b->z;
}

// c::VolImageMapNearest
// file ../src/imap.c line 405
struct anon$4 VolImageMapNearest(const struct anon$33 *img, double u, double v, double w)
{
  struct anon$4 col;
  double x;
  double y;
  double z;
  signed int ix;
  signed int iy;
  signed int iz;
  signed int addr;
  x = ((double)img->xres - 1.000000) * u;
  ix = (signed int)x;
  y = ((double)img->yres - 1.000000) * v;
  iy = (signed int)y;
  z = ((double)img->zres - 1.000000) * w;
  iz = (signed int)z;
  addr = (iz * img->xres * img->yres + iy * img->xres + ix) * 3;
  col.r = (float)img->data[(signed long int)addr];
  col.g = (float)img->data[(signed long int)(addr + 1)];
  col.b = (float)img->data[(signed long int)(addr + 2)];
  return col;
}

// c::VolImageMapTrilinear
// file ../src/imap.c line 427
struct anon$4 VolImageMapTrilinear(const struct anon$33 *img, double u, double v, double w)
{
  struct anon$4 col;
  struct anon$4 colL;
  struct anon$4 colU;
  struct anon$4 colll;
  struct anon$4 colul;
  struct anon$4 colLL;
  struct anon$4 colUL;
  double x;
  double y;
  double z;
  double px;
  double py;
  double pz;
  signed int ix;
  signed int iy;
  signed int iz;
  signed int nx;
  signed int ny;
  signed int nz;
  unsigned char *llptr;
  unsigned char *ulptr;
  unsigned char *LLptr;
  unsigned char *ULptr;
  signed int addr;
  nx = img->xres > 1 ? 3 : 0;
  x = ((double)img->xres - 1.000000) * u;
  ix = (signed int)x;
  px = x - (double)ix;
  signed int tmp_if_expr$1;
  if(img->yres > 1)
    tmp_if_expr$1 = img->xres * 3;

  else
    tmp_if_expr$1 = 0;
  ny = tmp_if_expr$1;
  y = ((double)img->yres - 1.000000) * v;
  iy = (signed int)y;
  py = y - (double)iy;
  signed int tmp_if_expr$2;
  if(img->zres > 1)
    tmp_if_expr$2 = img->xres * img->yres * 3;

  else
    tmp_if_expr$2 = 0;
  nz = tmp_if_expr$2;
  z = ((double)img->zres - 1.000000) * w;
  iz = (signed int)z;
  pz = z - (double)iz;
  addr = (img->xres * img->yres * iz + img->xres * iy + ix) * 3;
  llptr = img->data + (signed long int)addr;
  ulptr = llptr + (signed long int)ny;
  LLptr = llptr + (signed long int)nz;
  ULptr = LLptr + (signed long int)ny;
  colll.r = (float)(double)((double)llptr[(signed long int)0] + px * ((double)llptr[(signed long int)nx] - (double)llptr[(signed long int)0]));
  colll.g = (float)(double)((double)llptr[(signed long int)1] + px * ((double)llptr[(signed long int)(nx + 1)] - (double)llptr[(signed long int)1]));
  colll.b = (float)(double)((double)llptr[(signed long int)2] + px * ((double)llptr[(signed long int)(nx + 2)] - (double)llptr[(signed long int)2]));
  colul.r = (float)((double)ulptr[(signed long int)0] + px * ((double)ulptr[(signed long int)nx] - (double)ulptr[(signed long int)0]));
  colul.g = (float)((double)ulptr[(signed long int)1] + px * ((double)ulptr[(signed long int)(nx + 1)] - (double)ulptr[(signed long int)1]));
  colul.b = (float)((double)ulptr[(signed long int)2] + px * ((double)ulptr[(signed long int)(nx + 2)] - (double)ulptr[(signed long int)2]));
  colLL.r = (float)(double)((double)LLptr[(signed long int)0] + px * ((double)LLptr[(signed long int)nx] - (double)LLptr[(signed long int)0]));
  colLL.g = (float)(double)((double)LLptr[(signed long int)1] + px * ((double)LLptr[(signed long int)(nx + 1)] - (double)LLptr[(signed long int)1]));
  colLL.b = (float)(double)((double)LLptr[(signed long int)2] + px * ((double)LLptr[(signed long int)(nx + 2)] - (double)LLptr[(signed long int)2]));
  colUL.r = (float)((double)ULptr[(signed long int)0] + px * ((double)ULptr[(signed long int)nx] - (double)ULptr[(signed long int)0]));
  colUL.g = (float)((double)ULptr[(signed long int)1] + px * ((double)ULptr[(signed long int)(nx + 1)] - (double)ULptr[(signed long int)1]));
  colUL.b = (float)((double)ULptr[(signed long int)2] + px * ((double)ULptr[(signed long int)(nx + 2)] - (double)ULptr[(signed long int)2]));
  colL.r = (float)((double)colll.r + py * (double)(colul.r - colll.r));
  colL.g = (float)((double)colll.g + py * (double)(colul.g - colll.g));
  colL.b = (float)((double)colll.b + py * (double)(colul.b - colll.b));
  colU.r = (float)((double)colLL.r + py * (double)(colUL.r - colLL.r));
  colU.g = (float)((double)colLL.g + py * (double)(colUL.g - colLL.g));
  colU.b = (float)((double)colLL.b + py * (double)(colUL.b - colLL.b));
  col.r = (float)(((double)colL.r + pz * (double)(colU.r - colL.r)) / 255.000000);
  col.g = (float)(((double)colL.g + pz * (double)(colU.g - colL.g)) / 255.000000);
  col.b = (float)(((double)colL.b + pz * (double)(colU.b - colL.b)) / 255.000000);
  return col;
}

// c::VolMIPMap
// file ../src/imap.h line 22
struct anon$4 VolMIPMap(const struct anon$34 *mip, double u, double v, double w, double d)
{
  signed int mapindex;
  double mapflt;
  struct anon$4 col;
  struct anon$4 col1;
  struct anon$4 col2;
  if(u <= 1.000000)
  {
    if(!(u >= 0.000000))
      goto __CPROVER_DUMP_L5;

    if(!(v <= 1.000000))
      goto __CPROVER_DUMP_L5;

    if(!(v >= 0.000000))
      goto __CPROVER_DUMP_L5;

    if(!(w <= 1.000000))
      goto __CPROVER_DUMP_L5;

    if(!(w >= 0.000000))
      goto __CPROVER_DUMP_L5;

    if(d > 1.000000)
      d = 1.000000;

    else
      if(d < 0.000000)
        d = 0.000000;

    mapflt = d * ((double)mip->levels - 9.999000e-1);
    mapindex = (signed int)mapflt;
    mapflt = mapflt - (double)mapindex;
    if(!(mapindex >= -2 + mip->levels))
    {
      col1=VolImageMapTrilinear(mip->images[(signed long int)mapindex], u, v, w);
      col2=VolImageMapTrilinear(mip->images[(signed long int)(mapindex + 1)], u, v, w);
      col.r = (float)((double)col1.r + mapflt * (double)(col2.r - col1.r));
      col.g = (float)((double)col1.g + mapflt * (double)(col2.g - col1.g));
      col.b = (float)((double)col1.b + mapflt * (double)(col2.b - col1.b));
    }

    else
      col=VolImageMapTrilinear(mip->images[(signed long int)(mip->levels - 1)], u, v, w);
  }

  else
  {

  __CPROVER_DUMP_L5:
    ;
    col.r = (float)0.000000;
    col.g = (float)0.000000;
    col.b = (float)0.000000;
  }
  return col;
}

// c::VoxelColor
// file ../src/vol.c line 109
struct anon$4 VoxelColor(double scalar)
{
  struct anon$4 col;
  if(scalar > 1.000000)
    scalar = 1.000000;

  if(scalar < 0.000000)
    scalar = 0.000000;

  if(scalar < 2.500000e-1)
  {
    col.r = (float)(scalar * 4.000000);
    col.g = (float)0.000000;
    col.b = (float)0.000000;
  }

  else
    if(scalar < 7.500000e-1)
    {
      col.r = (float)1.000000;
      col.g = (float)((scalar - 2.500000e-1) * 2.000000);
      col.b = (float)0.000000;
    }

    else
    {
      col.r = (float)1.000000;
      col.g = (float)1.000000;
      col.b = (float)((scalar - 7.500000e-1) * 4.000000);
    }
  return col;
}

// c::__signbit
// file /usr/include/x86_64-linux-gnu/bits/mathinline.h line 139
signed int __signbit(double __x)
{
  signed int __m;
  asm("pmovmskb %1, %0");
  return (signed int)((__m & 128) != 0);
}

// c::__signbitf
// file /usr/include/x86_64-linux-gnu/bits/mathinline.h line 127
signed int __signbitf(float __x)
{
  signed int __m;
  asm("pmovmskb %1, %0");
  return (signed int)((__m & 8) != 0);
}

// c::__signbitl
// file /usr/include/x86_64-linux-gnu/bits/mathinline.h line 151
signed int __signbitl(long double __x)
{
  union anon$9 __u = (union anon$9){ .__l=__x };
  return (signed int)((__u.__i[(signed long int)2] & 32768) != 0);
}

// c::__strcspn_c1
// file /usr/include/x86_64-linux-gnu/bits/string2.h line 970
unsigned long int __strcspn_c1(const char *__s, signed int __reject)
{
  unsigned long int __result = (unsigned long int)0;
  while(!((signed int)__s[(signed long int)__result] == 0))
  {
    if((signed int)__s[(signed long int)__result] == __reject)
      goto __CPROVER_DUMP_L2;

    __result = __result + 1ul;
    __result;
  }

__CPROVER_DUMP_L2:
  ;
  return __result;
}

// c::__strcspn_c2
// file /usr/include/x86_64-linux-gnu/bits/string2.h line 981
unsigned long int __strcspn_c2(const char *__s, signed int __reject1, signed int __reject2)
{
  unsigned long int __result = (unsigned long int)0;
  while(!((signed int)__s[(signed long int)__result] == 0))
  {
    if((signed int)__s[(signed long int)__result] == __reject1)
      goto __CPROVER_DUMP_L2;

    if((signed int)__s[(signed long int)__result] == __reject2)
      goto __CPROVER_DUMP_L2;

    __result = __result + 1ul;
    __result;
  }

__CPROVER_DUMP_L2:
  ;
  return __result;
}

// c::__strcspn_c3
// file /usr/include/x86_64-linux-gnu/bits/string2.h line 993
unsigned long int __strcspn_c3(const char *__s, signed int __reject1, signed int __reject2, signed int __reject3)
{
  unsigned long int __result = (unsigned long int)0;
  while(!((signed int)__s[(signed long int)__result] == 0))
  {
    if((signed int)__s[(signed long int)__result] == __reject1)
      goto __CPROVER_DUMP_L2;

    if((signed int)__s[(signed long int)__result] == __reject2)
      goto __CPROVER_DUMP_L2;

    if((signed int)__s[(signed long int)__result] == __reject3)
      goto __CPROVER_DUMP_L2;

    __result = __result + 1ul;
    __result;
  }

__CPROVER_DUMP_L2:
  ;
  return __result;
}

// c::__strpbrk_c2
// file /usr/include/x86_64-linux-gnu/bits/string2.h line 1123
char * __strpbrk_c2(const char *__s, signed int __accept1, signed int __accept2)
{
  while(!((signed int)*__s == 0))
  {
    if((signed int)*__s == __accept1)
      goto __CPROVER_DUMP_L2;

    if((signed int)*__s == __accept2)
      goto __CPROVER_DUMP_L2;

    __s = __s + 1l;
    __s;
  }

__CPROVER_DUMP_L2:
  ;
  return (signed int)*__s == 0 ? (char *)NULL : (char *)(unsigned long int)__s;
}

// c::__strpbrk_c3
// file /usr/include/x86_64-linux-gnu/bits/string2.h line 1134
char * __strpbrk_c3(const char *__s, signed int __accept1, signed int __accept2, signed int __accept3)
{
  while(!((signed int)*__s == 0))
  {
    if((signed int)*__s == __accept1)
      goto __CPROVER_DUMP_L2;

    if((signed int)*__s == __accept2)
      goto __CPROVER_DUMP_L2;

    if((signed int)*__s == __accept3)
      goto __CPROVER_DUMP_L2;

    __s = __s + 1l;
    __s;
  }

__CPROVER_DUMP_L2:
  ;
  return (signed int)*__s == 0 ? (char *)NULL : (char *)(unsigned long int)__s;
}

// c::__strsep_1c
// file /usr/include/x86_64-linux-gnu/bits/string2.h line 1222
char * __strsep_1c(char **__s, char __reject)
{
  char *__retval = *__s;
  char *return_value___builtin_strchr$2;
  char *tmp_post$1;
  if(!(__retval == ((char *)NULL)))
  {
    return_value___builtin_strchr$2=__builtin_strchr(__retval, (signed int)__reject);
    *__s = return_value___builtin_strchr$2;
    if(!(*__s == ((char *)NULL)))
    {
      tmp_post$1 = *__s;
      *__s = *__s + 1l;
      *tmp_post$1 = (char)0;
    }

  }

  return __retval;
}

// c::__strsep_2c
// file /usr/include/x86_64-linux-gnu/bits/string2.h line 1232
char * __strsep_2c(char **__s, char __reject1, char __reject2)
{
  char *__retval = *__s;
  _Bool tmp_if_expr$2;
  char *tmp_post$1;
  if(!(__retval == ((char *)NULL)))
  {
    char *__cp = __retval;
    while(TRUE)
    {
      if(!((signed int)*__cp == 0))
        goto __CPROVER_DUMP_L2;

      __cp = (char *)NULL;
      goto __CPROVER_DUMP_L6;

    __CPROVER_DUMP_L2:
      ;
      if(*__cp == __reject1)
        tmp_if_expr$2 = TRUE;

      else
        tmp_if_expr$2 = *__cp == __reject2 ? TRUE : FALSE;
      if(!tmp_if_expr$2)
        goto __CPROVER_DUMP_L5;

      tmp_post$1 = __cp;
      __cp = __cp + 1l;
      *tmp_post$1 = (char)0;
      goto __CPROVER_DUMP_L6;

    __CPROVER_DUMP_L5:
      ;
      __cp = __cp + 1l;
      __cp;
    }

  __CPROVER_DUMP_L6:
    ;
    *__s = __cp;
  }

  return __retval;
}

// c::__strsep_3c
// file /usr/include/x86_64-linux-gnu/bits/string2.h line 1260
char * __strsep_3c(char **__s, char __reject1, char __reject2, char __reject3)
{
  char *__retval = *__s;
  _Bool tmp_if_expr$2;
  _Bool tmp_if_expr$3;
  char *tmp_post$1;
  if(!(__retval == ((char *)NULL)))
  {
    char *__cp = __retval;
    while(TRUE)
    {
      if(!((signed int)*__cp == 0))
        goto __CPROVER_DUMP_L2;

      __cp = (char *)NULL;
      goto __CPROVER_DUMP_L8;

    __CPROVER_DUMP_L2:
      ;
      if(*__cp == __reject1)
        tmp_if_expr$2 = TRUE;

      else
        tmp_if_expr$2 = *__cp == __reject2 ? TRUE : FALSE;
      if(tmp_if_expr$2)
        tmp_if_expr$3 = TRUE;

      else
        tmp_if_expr$3 = *__cp == __reject3 ? TRUE : FALSE;
      if(!tmp_if_expr$3)
        goto __CPROVER_DUMP_L7;

      tmp_post$1 = __cp;
      __cp = __cp + 1l;
      *tmp_post$1 = (char)0;
      goto __CPROVER_DUMP_L8;

    __CPROVER_DUMP_L7:
      ;
      __cp = __cp + 1l;
      __cp;
    }

  __CPROVER_DUMP_L8:
    ;
    *__s = __cp;
  }

  return __retval;
}

// c::__strspn_c1
// file /usr/include/x86_64-linux-gnu/bits/string2.h line 1046
unsigned long int __strspn_c1(const char *__s, signed int __accept)
{
  unsigned long int __result = (unsigned long int)0;
  while((signed int)__s[(signed long int)__result] == __accept)
  {
    __result = __result + 1ul;
    __result;
  }
  return __result;
}

// c::__strspn_c2
// file /usr/include/x86_64-linux-gnu/bits/string2.h line 1058
unsigned long int __strspn_c2(const char *__s, signed int __accept1, signed int __accept2)
{
  unsigned long int __result = (unsigned long int)0;
  while(TRUE)
  {
    if((signed int)__s[(signed long int)__result] == __accept1)
      goto __CPROVER_DUMP_L2;

    if((signed int)__s[(signed long int)__result] == __accept2)
      goto __CPROVER_DUMP_L2;

    goto __CPROVER_DUMP_L3;

  __CPROVER_DUMP_L2:
    ;
    __result = __result + 1ul;
    __result;
  }

__CPROVER_DUMP_L3:
  ;
  return __result;
}

// c::__strspn_c3
// file /usr/include/x86_64-linux-gnu/bits/string2.h line 1070
unsigned long int __strspn_c3(const char *__s, signed int __accept1, signed int __accept2, signed int __accept3)
{
  unsigned long int __result = (unsigned long int)0;
  while(TRUE)
  {
    if((signed int)__s[(signed long int)__result] == __accept1)
      goto __CPROVER_DUMP_L2;

    if((signed int)__s[(signed long int)__result] == __accept2)
      goto __CPROVER_DUMP_L2;

    if((signed int)__s[(signed long int)__result] == __accept3)
      goto __CPROVER_DUMP_L2;

    goto __CPROVER_DUMP_L3;

  __CPROVER_DUMP_L2:
    ;
    __result = __result + 1ul;
    __result;
  }

__CPROVER_DUMP_L3:
  ;
  return __result;
}

// c::__strtok_r_1c
// file /usr/include/x86_64-linux-gnu/bits/string2.h line 1172
char * __strtok_r_1c(char *__s, char __sep, char **__nextp)
{
  char *__result;
  if(__s == ((char *)NULL))
    __s = *__nextp;

  while(*__s == __sep)
  {
    __s = __s + 1l;
    __s;
  }
  __result = (char *)NULL;
  char *tmp_post$1;
  char *tmp_post$2;
  if(!((signed int)*__s == 0))
  {
    tmp_post$1 = __s;
    __s = __s + 1l;
    __result = tmp_post$1;
    while(!((signed int)*__s == 0))
    {
      tmp_post$2 = __s;
      __s = __s + 1l;
      if(!(*tmp_post$2 == __sep))
        goto __CPROVER_DUMP_L4;

      __s[(signed long int)-1] = (char)0;
      goto __CPROVER_DUMP_L5;

    __CPROVER_DUMP_L4:
      ;
    }
  }


__CPROVER_DUMP_L5:
  ;
  *__nextp = __s;
  return __result;
}

// c::add_bounded_object
// file ../src/api.c line 731
static void add_bounded_object(struct anon$17 *scene, struct anon$15 *obj)
{
  struct anon$15 *objtemp;
  if(obj == ((struct anon$15 *)NULL))
    return;

  obj->id=new_objectid(scene);
  objtemp = scene->objgroup.boundedobj;
  scene->objgroup.boundedobj = obj;
  obj->nextobj = (void *)objtemp;
  obj->clip = scene->curclipgroup;
  scene->scenecheck = 1;
}

// c::add_clipped_intersection
// file ../src/intersect.h line 12
void add_clipped_intersection(double t, const struct anon$15 *obj, struct ray_t$link0 *ry)
{
  if(t > 5.000000e-8)
  {
    if(t < ry->maxdist)
    {
      if(!(obj->clip == ((struct anon$22 *)NULL)))
      {
        struct anon$0 hit;
        signed int i;
        hit.x = ry->o.x + ry->d.x * t;
        hit.y = ry->o.y + ry->d.y * t;
        hit.z = ry->o.z + ry->d.z * t;
        i = 0;
        while(!(i >= obj->clip->numplanes))
        {
          if((4l * (signed long int)i)[obj->clip->planes] * hit.x + *(4l * (signed long int)i + 1l + obj->clip->planes) * hit.y + *(4l * (signed long int)i + 2l + obj->clip->planes) * hit.z > *(4l * (signed long int)i + 3l + obj->clip->planes))
            return;

          i = i + 1;
        }
      }

      ry->maxdist = t;
      ry->intstruct.num = 1;
      ry->intstruct.closest.obj = obj;
      ry->intstruct.closest.t = t;
    }

  }

}

// c::add_clipped_shadow_intersection
// file ../src/intersect.c line 130
void add_clipped_shadow_intersection(double t, const struct anon$15 *obj, struct ray_t$link0 *ry)
{
  if(t > 5.000000e-8)
  {
    if(t < ry->maxdist)
    {
      if((1u & obj->tex->flags) == 0u)
      {
        ry->intstruct.shadowfilter = ry->intstruct.shadowfilter * (1.000000 - (double)obj->tex->opacity);
        return;
      }

      if(!(obj->clip == ((struct anon$22 *)NULL)))
      {
        struct anon$0 hit;
        signed int i;
        hit.x = ry->o.x + ry->d.x * t;
        hit.y = ry->o.y + ry->d.y * t;
        hit.z = ry->o.z + ry->d.z * t;
        i = 0;
        while(!(i >= obj->clip->numplanes))
        {
          if((4l * (signed long int)i)[obj->clip->planes] * hit.x + *(4l * (signed long int)i + 1l + obj->clip->planes) * hit.y + *(4l * (signed long int)i + 2l + obj->clip->planes) * hit.z > *(4l * (signed long int)i + 3l + obj->clip->planes))
            return;

          i = i + 1;
        }
      }

      ry->maxdist = t;
      ry->intstruct.num = 1;
      ry->flags = ry->flags | (unsigned int)8;
    }

  }

}

// c::add_quats
// file ../demosrc/trackball.c line 247
void add_quats(float *q1, float *q2, float *dest)
{
  static signed int count = 0;
  float t1[4l];
  float t2[4l];
  float t3[4l];
  float tf[4l];
  vcopy(q1, t1);
  vscale(t1, q2[(signed long int)3]);
  vcopy(q2, t2);
  vscale(t2, q1[(signed long int)3]);
  vcross(q2, q1, t3);
  vadd(t1, t2, tf);
  vadd(t3, tf, tf);
  float return_value_vdot$1;
  return_value_vdot$1=vdot(q1, q2);
  tf[(signed long int)3] = q1[(signed long int)3] * q2[(signed long int)3] - return_value_vdot$1;
  dest[(signed long int)0] = tf[(signed long int)0];
  dest[(signed long int)1] = tf[(signed long int)1];
  dest[(signed long int)2] = tf[(signed long int)2];
  dest[(signed long int)3] = tf[(signed long int)3];
  count = count + 1;
  if(count > 97)
  {
    count = 0;
    normalize_quat(dest);
  }

}

// c::add_regular_intersection
// file ../src/intersect.h line 13
void add_regular_intersection(double t, const struct anon$15 *obj, struct ray_t$link0 *ry)
{
  if(t > 5.000000e-8)
  {
    if(t < ry->maxdist)
    {
      ry->maxdist = t;
      ry->intstruct.num = 1;
      ry->intstruct.closest.obj = obj;
      ry->intstruct.closest.t = t;
    }

  }

}

// c::add_shadow_intersection
// file ../src/intersect.c line 108
void add_shadow_intersection(double t, const struct anon$15 *obj, struct ray_t$link0 *ry)
{
  if(t > 5.000000e-8)
  {
    if(t < ry->maxdist)
    {
      if((1u & obj->tex->flags) == 0u)
      {
        ry->intstruct.shadowfilter = ry->intstruct.shadowfilter * (1.000000 - (double)obj->tex->opacity);
        return;
      }

      ry->maxdist = t;
      ry->intstruct.num = 1;
      ry->flags = ry->flags | (unsigned int)8;
    }

  }

}

// c::add_texture
// file ../demosrc/parse.c line 81
static unsigned int add_texture(struct anon$6 *ph, void *tex, const char *name)
{
  (ph->textable + (signed long int)ph->numtextures)->tex = tex;
  unsigned long int return_value_strlen$1;
  return_value_strlen$1=strlen(name);
  void *return_value_malloc$2;
  return_value_malloc$2=malloc(return_value_strlen$1 + (unsigned long int)1);
  (ph->textable + (signed long int)ph->numtextures)->name = (char *)return_value_malloc$2;
  strcpy((ph->textable + (signed long int)ph->numtextures)->name, name);
  rt_hash_insert(&ph->texhash, (ph->textable + (signed long int)ph->numtextures)->name, ph->numtextures);
  ph->numtextures = ph->numtextures + 1;
  if(ph->numtextures >= ph->maxtextures)
  {
    struct anon$5 *newblock;
    signed int newsize = 2 * ph->maxtextures;
    void *return_value_realloc$3;
    return_value_realloc$3=realloc((void *)ph->textable, (unsigned long int)newsize * 16ul /*[[struct anon$5]]*/);
    newblock = (struct anon$5 *)return_value_realloc$3;
    if(!(newblock == ((struct anon$5 *)NULL)))
    {
      ph->maxtextures = newsize;
      ph->textable = newblock;
      return (unsigned int)0;
    }

    else
    {
      printf("Parse: %d textures allocated, texture slots full!\n", ph->numtextures);
      ph->numtextures = ph->numtextures - 1;
      return (unsigned int)16;
    }
  }

  return (unsigned int)0;
}

// c::add_texture$link50
// file ../demosrc/ac3dparse.c line 63
static unsigned int add_texture$link50(void *tex$link46, char *name$link48)
{
  textable[(signed long int)numtextures].tex = tex$link46;
  strcpy(textable[(signed long int)numtextures].name, name$link48);
  numtextures = numtextures + 1;
  if(numtextures > 8192)
  {
    printf("Parse: %d textures allocated, texture slots full!\n", numtextures);
    numtextures = numtextures - 1;
    return (unsigned int)16;
  }

  return (unsigned int)0;
}

// c::add_unbounded_object
// file ../src/api.c line 750
static void add_unbounded_object(struct anon$17 *scene, struct anon$15 *obj)
{
  struct anon$15 *objtemp;
  if(obj == ((struct anon$15 *)NULL))
    return;

  obj->id=new_objectid(scene);
  objtemp = scene->objgroup.unboundedobj;
  scene->objgroup.unboundedobj = obj;
  obj->nextobj = (void *)objtemp;
  obj->clip = scene->curclipgroup;
  scene->scenecheck = 1;
}

// c::adjust
// file ../src/apigeom.c line 147
static void adjust(double *base, signed int xres, signed int yres, double wx, double wy, signed int xa, signed int ya, signed int x, signed int y, signed int xb, signed int yb, unsigned int *rndval)
{
  double d;
  double v;
  double len;
  len=sqrt(wx * wx + wy * wy);
  if(IEEE_FLOAT_EQUAL(*((signed long int)xres * (signed long int)y + base + (signed long int)x), 0.000000))
  {
    signed int return_value_abs$1;
    return_value_abs$1=abs(xa - xb);
    signed int return_value_abs$2;
    return_value_abs$2=abs(ya - yb);
    d = ((double)return_value_abs$1 / ((double)xres * 1.000000)) * wx + ((double)return_value_abs$2 / ((double)yres * 1.000000)) * wy;
    unsigned int return_value_rt_rand$3;
    return_value_rt_rand$3=rt_rand(rndval);
    v = (base[(signed long int)(xa + xres * ya)] + base[(signed long int)(xb + xres * yb)]) / 2.000000 + ((((double)return_value_rt_rand$3 / 4.294967e+9 - 5.000000e-1) * d) / 4.000000) * (len / 16.000000);
    if(v < 0.000000)
      v = 0.000000;

    if(v > (double)(xres + yres))
      v = (double)(xres + yres);

    base[(signed long int)(x + xres * y)] = v;
  }

}

// c::alos
// file ../src/hash.c line 239
static float alos(struct rt_hash_t *tptr)
{
  signed int i;
  signed int j;
  float alos = (float)0;
  struct hash_node_t *node;
  i = 0;
  while(!(i >= tptr->size))
  {
    node = tptr->bucket[(signed long int)i];
    j = 0;
    while(!(node == ((struct hash_node_t *)NULL)))
    {
      node = node->next;
      j = j + 1;
    }
    if(!(j == 0))
      alos = alos + (float)(j * (j + 1) >> 1);

    i = i + 1;
  }
  float tmp_if_expr$1;
  if(!(tptr->entries == 0))
    tmp_if_expr$1 = alos / (float)tptr->entries;

  else
    tmp_if_expr$1 = (float)0;
  return tmp_if_expr$1;
}

// c::animate_scene
// file ../demosrc/main.c line 224
static signed int animate_scene(struct anon$1 opt, void *scene, signed int node)
{
  char outfilename[1000l];
  struct _IO_FILE *camfp;
  struct anon$3 *dh = (struct anon$3 *)NULL;
  if(node == 0)
    dh=tachyon_display_create(scene);

  camfp=fopen(opt.camfilename, "r");
  signed int return_value_feof$1;
  if(!(camfp == ((struct _IO_FILE *)NULL)))
  {
    struct anon$2 cv;
    struct anon$2 cu;
    struct anon$2 cc;
    struct anon$0 cmv;
    struct anon$0 cmu;
    struct anon$0 cmc;
    signed int frameno = 0;
    float fps;
    void *fpstimer;
    void *animationtimer;
    rt_set_ui_message((void (*)(signed int, char *))NULL);
    rt_set_ui_progress((void (*)(signed int))NULL);
    if(node == 0)
      printf("Running Camera File: %s\n", (const void *)opt.camfilename);

    fpstimer=rt_timer_create();
    animationtimer=rt_timer_create();
    rt_timer_start(animationtimer);
    do
    {
      return_value_feof$1=feof(camfp);
      if(return_value_feof$1 != 0)
        goto __CPROVER_DUMP_L10;

      fscanf(camfp, "%f %f %f  %f %f %f  %f %f %f", &cv.x, &cv.y, &cv.z, &cu.x, &cu.y, &cu.z, &cc.x, &cc.y, &cc.z);
      cmv.x = (double)cv.x;
      cmv.y = (double)cv.y;
      cmv.z = (double)cv.z;
      cmu.x = (double)cu.x;
      cmu.y = (double)cu.y;
      cmu.z = (double)cu.z;
      cmc.x = (double)cc.x;
      cmc.y = (double)cc.y;
      cmc.z = (double)cc.z;
      if(!(frameno == 0))
      {
        rt_timer_stop(fpstimer);
        double return_value_rt_timer_time$2;
        return_value_rt_timer_time$2=rt_timer_time(fpstimer);
        fps = (float)((double)1.000000f / return_value_rt_timer_time$2);
      }

      else
        fps = (float)0.000000;
      rt_timer_start(fpstimer);
      outfilename[(signed long int)0] = (char)0;
      if(opt.nosave == 1)
      {
        if(node == 0)
        {
          printf("\rRendering Frame: %9d   %10.4f FPS       ", frameno, fps);
          fflush(stdout);
        }

      }

      else
      {
        sprintf(outfilename, opt.outfilename, frameno);
        if(node == 0)
        {
          printf("\rRendering Frame to %s   (%10.4f FPS)       ", (const void *)outfilename, fps);
          fflush(stdout);
        }

      }
      rt_outputfile(scene, outfilename);
      rt_camera_position(scene, cmc, cmv, cmu);
      rt_renderscene(scene);
      if(!(dh == ((struct anon$3 *)NULL)))
        tachyon_display_draw(dh);

      frameno = frameno + 1;
    }
    while(TRUE);

  __CPROVER_DUMP_L10:
    ;
    rt_timer_stop(animationtimer);
    double return_value_rt_timer_time$3;
    return_value_rt_timer_time$3=rt_timer_time(animationtimer);
    fps = (float)((double)frameno / return_value_rt_timer_time$3);
    if(node == 0)
    {
      printf("\rCompleted animation of %d frames                            \n", frameno);
      double return_value_rt_timer_time$4;
      return_value_rt_timer_time$4=rt_timer_time(animationtimer);
      printf("Animation Time: %10.4f seconds  (Averaged %7.4f FPS)\n", return_value_rt_timer_time$4, fps);
    }

    rt_timer_destroy(fpstimer);
    fclose(camfp);
  }

  else
  {
    if(node == 0)
    {
      printf("Couldn't open camera file: %s\n", (const void *)opt.camfilename);
      printf("Aborting render.\n");
    }

    rt_deletescene(scene);
    rt_finalize();
    return -1;
  }
  if(node == 0)
  {
    printf("\nFinished Running Camera.\n");
    if(!(dh == ((struct anon$3 *)NULL)))
      tachyon_display_delete(dh);

  }

  rt_deletescene(scene);
  rt_finalize();
  return 0;
}

// c::apitextotex
// file ../src/api.c line 590
void apitextotex(struct anon$7 *apitex, struct anon$25 *tx)
{
  struct anon$35 *tex = (struct anon$35 *)tx;
  tex->img = NULL;
  struct anon$34 *return_value_LoadMIPMap$1;
  struct anon$34 *return_value_LoadMIPMap$2;
  struct anon$34 *return_value_LoadMIPMap$3;
  struct anon$34 *return_value_LoadMIPMap$4;
  switch(apitex->texturefunc)
  {

    case 1:
      {
        tex->texfunc = (struct anon$4 (*)(const void *, const void *, void *))checker_texture;
        goto __CPROVER_DUMP_L12;
      }
    case 2:
      {
        tex->texfunc = (struct anon$4 (*)(const void *, const void *, void *))grit_texture;
        goto __CPROVER_DUMP_L12;
      }
    case 3:
      {
        tex->texfunc = (struct anon$4 (*)(const void *, const void *, void *))marble_texture;
        goto __CPROVER_DUMP_L12;
      }
    case 4:
      {
        tex->texfunc = (struct anon$4 (*)(const void *, const void *, void *))wood_texture;
        goto __CPROVER_DUMP_L12;
      }
    case 5:
      {
        tex->texfunc = (struct anon$4 (*)(const void *, const void *, void *))gnoise_texture;
        goto __CPROVER_DUMP_L12;
      }
    case 6:
      {
        tex->texfunc = (struct anon$4 (*)(const void *, const void *, void *))cyl_checker_texture;
        goto __CPROVER_DUMP_L12;
      }
    case 7:
      {
        tex->texfunc = (struct anon$4 (*)(const void *, const void *, void *))image_cyl_texture;
        return_value_LoadMIPMap$1=LoadMIPMap(apitex->imap, 0);
        tex->img = (void *)return_value_LoadMIPMap$1;
        goto __CPROVER_DUMP_L12;
      }
    case 8:
      {
        tex->texfunc = (struct anon$4 (*)(const void *, const void *, void *))image_sphere_texture;
        return_value_LoadMIPMap$2=LoadMIPMap(apitex->imap, 0);
        tex->img = (void *)return_value_LoadMIPMap$2;
        goto __CPROVER_DUMP_L12;
      }
    case 9:
      {
        tex->texfunc = (struct anon$4 (*)(const void *, const void *, void *))image_plane_texture;
        return_value_LoadMIPMap$3=LoadMIPMap(apitex->imap, 0);
        tex->img = (void *)return_value_LoadMIPMap$3;
        goto __CPROVER_DUMP_L12;
      }
    case 10:
      {
        tex->texfunc = (struct anon$4 (*)(const void *, const void *, void *))image_volume_texture;
        return_value_LoadMIPMap$4=LoadMIPMap(apitex->imap, 0);
        tex->img = (void *)return_value_LoadMIPMap$4;
        goto __CPROVER_DUMP_L12;
      }
    case 0:

      default:
        {
          tex->texfunc = (struct anon$4 (*)(const void *, const void *, void *))constant_texture;
          goto __CPROVER_DUMP_L12;
        }
  }

__CPROVER_DUMP_L12:
  ;
  tex->ctr = apitex->ctr;
  tex->rot = apitex->rot;
  tex->scale = apitex->scale;
  tex->uaxs = apitex->uaxs;
  tex->vaxs = apitex->vaxs;
  tex->waxs = apitex->waxs;
  tex->ambient = (float)apitex->ambient;
  tex->diffuse = (float)apitex->diffuse;
  tex->specular = (float)apitex->specular;
  tex->opacity = (float)apitex->opacity;
  tex->col = apitex->col;
  tex->flags = (unsigned int)0;
  if(apitex->opacity >= 9.999900e-1)
    tex->flags = (unsigned int)1;

  tex->phong = (float)0.000000;
  tex->phongexp = (float)0.000000;
  tex->phongtype = 0;
  tex->outline = (float)0.000000;
  tex->outlinewidth = (float)0.000000;
}

// c::atof
// file /usr/include/x86_64-linux-gnu/bits/stdlib-float.h line 26
double atof(const char *__nptr)
{
  double return_value_strtod$1;
  return_value_strtod$1=strtod(__nptr, ((char **)NULL));
  return return_value_strtod$1;
}

// c::atoi
// file /usr/include/stdlib.h line 278
signed int atoi(const char *__nptr)
{
  signed long int return_value_strtol$1;
  return_value_strtol$1=strtol(__nptr, ((char **)NULL), 10);
  return (signed int)return_value_strtol$1;
}

// c::atol
// file /usr/include/stdlib.h line 283
signed long int atol(const char *__nptr)
{
  signed long int return_value_strtol$1;
  return_value_strtol$1=strtol(__nptr, ((char **)NULL), 10);
  return return_value_strtol$1;
}

// c::atoll
// file /usr/include/stdlib.h line 292
signed long long int atoll(const char *__nptr)
{
  signed long long int return_value_strtoll$1;
  return_value_strtoll$1=strtoll(__nptr, ((char **)NULL), 10);
  return return_value_strtoll$1;
}

// c::axis_to_quat
// file ../demosrc/trackball.c line 206
void axis_to_quat(float *a, float phi, float *q)
{
  vnormal(a);
  vcopy(a, q);
  double return_value_sin$1;
  return_value_sin$1=sin((double)phi / 2.000000);
  vscale(q, (float)return_value_sin$1);
  double return_value_cos$2;
  return_value_cos$2=cos((double)phi / 2.000000);
  q[(signed long int)3] = (float)return_value_cos$2;
}

// c::bcopy
// file /usr/include/x86_64-linux-gnu/bits/string3.h line 89
void bcopy(const void *__src, void *__dest, unsigned long int __len)
{
  __builtin___memmove_chk(__dest, __src, (unsigned int)__len, 18446744073709551615ul);
}

// c::box_bbox
// file ../src/box.c line 15
signed int box_bbox(void *obj, struct anon$0 *min, struct anon$0 *max)
{
  struct anon$26 *b = (struct anon$26 *)obj;
  *min = b->min;
  *max = b->max;
  return 1;
}

// c::box_intersect
// file ../src/box.c line 44
void box_intersect(const struct anon$26 *bx, struct ray_t$link36 *ry)
{
  double a;
  double tx1;
  double tx2;
  double ty1;
  double ty2;
  double tz1;
  double tz2;
  double tnear;
  double tfar;
  tnear = -1.000000e+18;
  tfar = 1.000000e+18;
  _Bool tmp_if_expr$1;
  if(IEEE_FLOAT_EQUAL(ry->d.x, 0.000000))
  {
    if(ry->o.x < bx->min.x)
      tmp_if_expr$1 = TRUE;

    else
      tmp_if_expr$1 = ry->o.x > bx->max.x ? TRUE : FALSE;
    if(tmp_if_expr$1)
      return;

  }

  else
  {
    tx1 = (bx->min.x - ry->o.x) / ry->d.x;
    tx2 = (bx->max.x - ry->o.x) / ry->d.x;
    if(tx1 > tx2)
    {
      a = tx1;
      tx1 = tx2;
      tx2 = a;
    }

    if(tx1 > tnear)
      tnear = tx1;

    if(tx2 < tfar)
      tfar = tx2;

  }
  if(tnear > tfar)
    return;

  if(tfar < 0.000000)
    return;

  _Bool tmp_if_expr$2;
  if(IEEE_FLOAT_EQUAL(ry->d.y, 0.000000))
  {
    if(ry->o.y < bx->min.y)
      tmp_if_expr$2 = TRUE;

    else
      tmp_if_expr$2 = ry->o.y > bx->max.y ? TRUE : FALSE;
    if(tmp_if_expr$2)
      return;

  }

  else
  {
    ty1 = (bx->min.y - ry->o.y) / ry->d.y;
    ty2 = (bx->max.y - ry->o.y) / ry->d.y;
    if(ty1 > ty2)
    {
      a = ty1;
      ty1 = ty2;
      ty2 = a;
    }

    if(ty1 > tnear)
      tnear = ty1;

    if(ty2 < tfar)
      tfar = ty2;

  }
  if(tnear > tfar)
    return;

  if(tfar < 0.000000)
    return;

  _Bool tmp_if_expr$3;
  if(IEEE_FLOAT_EQUAL(ry->d.z, 0.000000))
  {
    if(ry->o.z < bx->min.z)
      tmp_if_expr$3 = TRUE;

    else
      tmp_if_expr$3 = ry->o.z > bx->max.z ? TRUE : FALSE;
    if(tmp_if_expr$3)
      return;

  }

  else
  {
    tz1 = (bx->min.z - ry->o.z) / ry->d.z;
    tz2 = (bx->max.z - ry->o.z) / ry->d.z;
    if(tz1 > tz2)
    {
      a = tz1;
      tz1 = tz2;
      tz2 = a;
    }

    if(tz1 > tnear)
      tnear = tz1;

    if(tz2 < tfar)
      tfar = tz2;

  }
  if(tnear > tfar)
    return;

  if(tfar < 0.000000)
    return;

  ry->add_intersection(tnear, (const struct anon$15 *)bx, ry);
  ry->add_intersection(tfar, (struct anon$15 *)bx, ry);
}

// c::box_normal
// file ../src/box.c line 94
void box_normal(const struct anon$26 *bx, const struct anon$0 *pnt, struct ray_t$link36 *incident, struct anon$0 *N)
{
  struct anon$0 a;
  struct anon$0 b;
  struct anon$0 c;
  double t;
  c.x = (bx->max.x + bx->min.x) / 2.000000;
  c.y = (bx->max.y + bx->min.y) / 2.000000;
  c.z = (bx->max.z + bx->min.z) / 2.000000;
  VSub((struct anon$0 *)pnt, &c, N);
  b = *N;
  a.x=fabs(N->x);
  a.y=fabs(N->y);
  a.z=fabs(N->z);
  N->x = 0.000000;
  N->y = 0.000000;
  N->z = 0.000000;
  t = a.x > (a.y > a.z ? a.y : a.z) ? a.x : (a.y > a.z ? a.y : a.z);
  if(IEEE_FLOAT_EQUAL(t, a.x))
    N->x = b.x;

  if(IEEE_FLOAT_EQUAL(t, a.y))
    N->y = b.y;

  if(IEEE_FLOAT_EQUAL(t, a.z))
    N->z = b.z;

  VNorm(N);
  double return_value_VDot$1;
  return_value_VDot$1=VDot(N, &incident->d);
  if(return_value_VDot$1 > 0.000000)
  {
    N->x = -N->x;
    N->y = -N->y;
    N->z = -N->z;
  }

}

// c::build_rotmatrix
// file ../demosrc/trackball.c line 302
void build_rotmatrix(float (*m)[4l], float *q)
{
  m[(signed long int)0][(signed long int)0] = (float)(1.000000 - 2.000000 * (double)(q[(signed long int)1] * q[(signed long int)1] + q[(signed long int)2] * q[(signed long int)2]));
  m[(signed long int)0][(signed long int)1] = (float)(2.000000 * (double)(q[(signed long int)0] * q[(signed long int)1] - q[(signed long int)2] * q[(signed long int)3]));
  m[(signed long int)0][(signed long int)2] = (float)(2.000000 * (double)(q[(signed long int)2] * q[(signed long int)0] + q[(signed long int)1] * q[(signed long int)3]));
  m[(signed long int)0][(signed long int)3] = (float)0.000000;
  m[(signed long int)1][(signed long int)0] = (float)(2.000000 * (double)(q[(signed long int)0] * q[(signed long int)1] + q[(signed long int)2] * q[(signed long int)3]));
  m[(signed long int)1][(signed long int)1] = (float)(1.000000 - 2.000000 * (double)(q[(signed long int)2] * q[(signed long int)2] + q[(signed long int)0] * q[(signed long int)0]));
  m[(signed long int)1][(signed long int)2] = (float)(2.000000 * (double)(q[(signed long int)1] * q[(signed long int)2] - q[(signed long int)0] * q[(signed long int)3]));
  m[(signed long int)1][(signed long int)3] = (float)0.000000;
  m[(signed long int)2][(signed long int)0] = (float)(2.000000 * (double)(q[(signed long int)2] * q[(signed long int)0] - q[(signed long int)1] * q[(signed long int)3]));
  m[(signed long int)2][(signed long int)1] = (float)(2.000000 * (double)(q[(signed long int)1] * q[(signed long int)2] + q[(signed long int)0] * q[(signed long int)3]));
  m[(signed long int)2][(signed long int)2] = (float)(1.000000 - 2.000000 * (double)(q[(signed long int)1] * q[(signed long int)1] + q[(signed long int)0] * q[(signed long int)0]));
  m[(signed long int)2][(signed long int)3] = (float)0.000000;
  m[(signed long int)3][(signed long int)0] = (float)0.000000;
  m[(signed long int)3][(signed long int)1] = (float)0.000000;
  m[(signed long int)3][(signed long int)2] = (float)0.000000;
  m[(signed long int)3][(signed long int)3] = (float)1.000000;
}

// c::bzero
// file /usr/include/x86_64-linux-gnu/bits/string3.h line 95
void bzero(void *__dest, unsigned long int __len)
{
  __builtin___memset_chk(__dest, 0, (unsigned int)__len, 18446744073709551615ul);
}

// c::cam_aa_dof_ray
// file ../src/camera.c line 285
struct anon$4 cam_aa_dof_ray(struct ray_t$link210 *ry, double x, double y)
{
  struct anon$4 col;
  struct anon$4 avcol;
  signed int alias;
  struct anon$31$link211 *scene = ry->scene;
  float scale;
  double dx;
  double dy;
  col=cam_dof_ray(ry, x, y);
  alias = 1;
  while(scene->antialiasing >= alias)
  {
    float jxy[2l];
    jitter_offset2f(&ry->randval, jxy);
    dx = (double)jxy[(signed long int)0] * ry->scene->camera.aperture * (double)ry->scene->hres;
    dy = (double)jxy[(signed long int)1] * ry->scene->camera.aperture * (double)ry->scene->vres;
    ry->o.x = ry->scene->camera.center.x + dx * ry->scene->camera.iplaneright.x + dy * ry->scene->camera.iplaneup.x;
    ry->o.y = ry->scene->camera.center.y + dx * ry->scene->camera.iplaneright.y + dy * ry->scene->camera.iplaneup.y;
    ry->o.z = ry->scene->camera.center.z + dx * ry->scene->camera.iplaneright.z + dy * ry->scene->camera.iplaneup.z;
    jitter_offset2f(&ry->randval, jxy);
    avcol=cam_dof_ray(ry, x + (double)jxy[(signed long int)0], y + (double)jxy[(signed long int)1]);
    col.r = col.r + avcol.r;
    col.g = col.g + avcol.g;
    col.b = col.b + avcol.b;
    alias = alias + 1;
  }
  scale = 1.000000f / ((float)scene->antialiasing + 1.000000f);
  col.r = col.r * scale;
  col.g = col.g * scale;
  col.b = col.b * scale;
  return col;
}

// c::cam_aa_fisheye_ray
// file ../src/camera.c line 565
struct anon$4 cam_aa_fisheye_ray(struct ray_t$link210 *ry, double x, double y)
{
  struct anon$4 col;
  struct anon$4 avcol;
  signed int alias;
  struct anon$31$link211 *scene = ry->scene;
  float scale;
  col=cam_fisheye_ray(ry, x, y);
  alias = 1;
  while(scene->antialiasing >= alias)
  {
    float jxy[2l];
    jitter_offset2f(&ry->randval, jxy);
    avcol=cam_fisheye_ray(ry, x + (double)jxy[(signed long int)0], y + (double)jxy[(signed long int)1]);
    col.r = col.r + avcol.r;
    col.g = col.g + avcol.g;
    col.b = col.b + avcol.b;
    alias = alias + 1;
  }
  scale = 1.000000f / ((float)scene->antialiasing + 1.000000f);
  col.r = col.r * scale;
  col.g = col.g * scale;
  col.b = col.b * scale;
  return col;
}

// c::cam_aa_orthographic_ray
// file ../src/camera.c line 461
struct anon$4 cam_aa_orthographic_ray(struct ray_t$link210 *ry, double x, double y)
{
  struct anon$4 col;
  struct anon$4 avcol;
  signed int alias;
  struct anon$31$link211 *scene = ry->scene;
  float scale;
  col=cam_orthographic_ray(ry, x, y);
  alias = 1;
  while(scene->antialiasing >= alias)
  {
    float jxy[2l];
    jitter_offset2f(&ry->randval, jxy);
    avcol=cam_orthographic_ray(ry, x + (double)jxy[(signed long int)0], y + (double)jxy[(signed long int)1]);
    col.r = col.r + avcol.r;
    col.g = col.g + avcol.g;
    col.b = col.b + avcol.b;
    alias = alias + 1;
  }
  scale = 1.000000f / ((float)scene->antialiasing + 1.000000f);
  col.r = col.r * scale;
  col.g = col.g * scale;
  col.b = col.b * scale;
  return col;
}

// c::cam_aa_perspective_ray
// file ../src/camera.c line 383
struct anon$4 cam_aa_perspective_ray(struct ray_t$link210 *ry, double x, double y)
{
  struct anon$4 col;
  struct anon$4 avcol;
  signed int alias;
  struct anon$31$link211 *scene = ry->scene;
  float scale;
  col=cam_perspective_ray(ry, x, y);
  alias = 1;
  while(scene->antialiasing >= alias)
  {
    float jxy[2l];
    jitter_offset2f(&ry->randval, jxy);
    avcol=cam_perspective_ray(ry, x + (double)jxy[(signed long int)0], y + (double)jxy[(signed long int)1]);
    col.r = col.r + avcol.r;
    col.g = col.g + avcol.g;
    col.b = col.b + avcol.b;
    alias = alias + 1;
  }
  scale = 1.000000f / ((float)scene->antialiasing + 1.000000f);
  col.r = col.r * scale;
  col.g = col.g * scale;
  col.b = col.b * scale;
  return col;
}

// c::cam_dof_ray
// file ../src/camera.c line 340
struct anon$4 cam_dof_ray(struct ray_t$link210 *ry, double x, double y)
{
  double rdx;
  double rdy;
  double rdz;
  double len;
  struct anon$31$link211 *scene = ry->scene;
  rdx = (scene->camera.lowleft.x + x * scene->camera.iplaneright.x + y * scene->camera.iplaneup.x) - ry->o.x;
  rdy = (scene->camera.lowleft.y + x * scene->camera.iplaneright.y + y * scene->camera.iplaneup.y) - ry->o.y;
  rdz = (scene->camera.lowleft.z + x * scene->camera.iplaneright.z + y * scene->camera.iplaneup.z) - ry->o.z;
  double return_value_sqrt$1;
  return_value_sqrt$1=sqrt(rdx * rdx + rdy * rdy + rdz * rdz);
  len = 1.000000 / return_value_sqrt$1;
  ry->d.x = rdx * len;
  ry->d.y = rdy * len;
  ry->d.z = rdz * len;
  ry->maxdist = 1.000000e+18;
  ry->opticdist = 0.000000;
  ry->flags = (unsigned int)(1 | 2);
  ry->serial = ry->serial + 1ul;
  intersect_objects(ry);
  struct anon$4 return_value;
  return_value=scene->shader((void *)ry);
  return return_value;
}

// c::cam_fisheye_ray
// file ../src/camera.c line 529
struct anon$4 cam_fisheye_ray(struct ray_t$link210 *ry, double x, double y)
{
  double ax;
  double ay;
  struct anon$31$link211 *scene = ry->scene;
  ax = scene->camera.left + x * scene->camera.psx;
  ay = scene->camera.bottom + y * scene->camera.psy;
  double return_value_cos$1;
  return_value_cos$1=cos(ay);
  double return_value_cos$2;
  return_value_cos$2=cos(ax);
  double return_value_sin$3;
  return_value_sin$3=sin(ax);
  double return_value_sin$4;
  return_value_sin$4=sin(ay);
  ry->d.x = return_value_cos$1 * (return_value_cos$2 * scene->camera.viewvec.x + return_value_sin$3 * scene->camera.rightvec.x) + return_value_sin$4 * scene->camera.upvec.x;
  double return_value_cos$5;
  return_value_cos$5=cos(ay);
  double return_value_cos$6;
  return_value_cos$6=cos(ax);
  double return_value_sin$7;
  return_value_sin$7=sin(ax);
  double return_value_sin$8;
  return_value_sin$8=sin(ay);
  ry->d.y = return_value_cos$5 * (return_value_cos$6 * scene->camera.viewvec.y + return_value_sin$7 * scene->camera.rightvec.y) + return_value_sin$8 * scene->camera.upvec.y;
  double return_value_cos$9;
  return_value_cos$9=cos(ay);
  double return_value_cos$10;
  return_value_cos$10=cos(ax);
  double return_value_sin$11;
  return_value_sin$11=sin(ax);
  double return_value_sin$12;
  return_value_sin$12=sin(ay);
  ry->d.z = return_value_cos$9 * (return_value_cos$10 * scene->camera.viewvec.z + return_value_sin$11 * scene->camera.rightvec.z) + return_value_sin$12 * scene->camera.upvec.z;
  ry->maxdist = 1.000000e+18;
  ry->opticdist = 0.000000;
  ry->flags = (unsigned int)(1 | 2);
  ry->serial = ry->serial + 1ul;
  intersect_objects(ry);
  struct anon$4 return_value;
  return_value=scene->shader((void *)ry);
  return return_value;
}

// c::cam_orthographic_ray
// file ../src/camera.c line 495
struct anon$4 cam_orthographic_ray(struct ray_t$link210 *ry, double x, double y)
{
  struct anon$31$link211 *scene = ry->scene;
  ry->o.x = scene->camera.lowleft.x + x * scene->camera.iplaneright.x + y * scene->camera.iplaneup.x;
  ry->o.y = scene->camera.lowleft.y + x * scene->camera.iplaneright.y + y * scene->camera.iplaneup.y;
  ry->o.z = scene->camera.lowleft.z + x * scene->camera.iplaneright.z + y * scene->camera.iplaneup.z;
  ry->maxdist = 1.000000e+18;
  ry->opticdist = 0.000000;
  ry->flags = (unsigned int)(1 | 2);
  ry->serial = ry->serial + 1ul;
  intersect_objects(ry);
  struct anon$4 return_value;
  return_value=scene->shader((void *)ry);
  return return_value;
}

// c::cam_perspective_ray
// file ../src/camera.c line 417
struct anon$4 cam_perspective_ray(struct ray_t$link210 *ry, double x, double y)
{
  double rdx;
  double rdy;
  double rdz;
  double len;
  struct anon$31$link211 *scene = ry->scene;
  rdx = scene->camera.lowleft.x + x * scene->camera.iplaneright.x + y * scene->camera.iplaneup.x;
  rdy = scene->camera.lowleft.y + x * scene->camera.iplaneright.y + y * scene->camera.iplaneup.y;
  rdz = scene->camera.lowleft.z + x * scene->camera.iplaneright.z + y * scene->camera.iplaneup.z;
  double return_value_sqrt$1;
  return_value_sqrt$1=sqrt(rdx * rdx + rdy * rdy + rdz * rdz);
  len = 1.000000 / return_value_sqrt$1;
  ry->d.x = rdx * len;
  ry->d.y = rdy * len;
  ry->d.z = rdz * len;
  ry->maxdist = 1.000000e+18;
  ry->opticdist = 0.000000;
  ry->flags = (unsigned int)(1 | 2);
  ry->serial = ry->serial + 1ul;
  intersect_objects(ry);
  struct anon$4 return_value;
  return_value=scene->shader((void *)ry);
  return return_value;
}

// c::camera_init
// file ../src/camera.c line 20
void camera_init(struct anon$31$link211 *scene)
{
  double sx;
  double sy;
  switch(scene->camera.projection)
  {

    case 0:
      {
        if(scene->antialiasing > 0)
          scene->camera.cam_ray = (struct anon$4 (*)(void *, double, double))cam_aa_perspective_ray;

        else
          scene->camera.cam_ray = (struct anon$4 (*)(void *, double, double))cam_perspective_ray;
        goto __CPROVER_DUMP_L10;
      }
    case 2:
      {
        scene->camera.cam_ray = (struct anon$4 (*)(void *, double, double))cam_aa_dof_ray;
        goto __CPROVER_DUMP_L10;
      }
    case 1:
      {
        if(scene->antialiasing > 0)
          scene->camera.cam_ray = (struct anon$4 (*)(void *, double, double))cam_aa_orthographic_ray;

        else
          scene->camera.cam_ray = (struct anon$4 (*)(void *, double, double))cam_orthographic_ray;
        goto __CPROVER_DUMP_L10;
      }
    case 3:
      if(scene->antialiasing > 0)
        scene->camera.cam_ray = (struct anon$4 (*)(void *, double, double))cam_aa_fisheye_ray;

      else
        scene->camera.cam_ray = (struct anon$4 (*)(void *, double, double))cam_fisheye_ray;
    default:
      {

      __CPROVER_DUMP_L10:
        ;
        sx = (double)scene->hres;
        sy = (double)scene->vres;
        switch(scene->camera.projection)
        {

          case 1:
            {
              scene->camera.projcent = scene->camera.center;
              scene->camera.lowleft.x = scene->camera.projcent.x + scene->camera.left * scene->camera.rightvec.x + scene->camera.bottom * scene->camera.upvec.x;
              scene->camera.lowleft.y = scene->camera.projcent.y + scene->camera.left * scene->camera.rightvec.y + scene->camera.bottom * scene->camera.upvec.y;
              scene->camera.lowleft.z = scene->camera.projcent.z + scene->camera.left * scene->camera.rightvec.z + scene->camera.bottom * scene->camera.upvec.z;
              goto __CPROVER_DUMP_L15;
            }
          case 2:
            {
              scene->camera.projcent.x = scene->camera.center.x + scene->camera.focallength * scene->camera.viewvec.x;
              scene->camera.projcent.y = scene->camera.center.y + scene->camera.focallength * scene->camera.viewvec.y;
              scene->camera.projcent.z = scene->camera.center.z + scene->camera.focallength * scene->camera.viewvec.z;
              scene->camera.lowleft.x = scene->camera.projcent.x + scene->camera.left * scene->camera.rightvec.x + scene->camera.bottom * scene->camera.upvec.x;
              scene->camera.lowleft.y = scene->camera.projcent.y + scene->camera.left * scene->camera.rightvec.y + scene->camera.bottom * scene->camera.upvec.y;
              scene->camera.lowleft.z = scene->camera.projcent.z + scene->camera.left * scene->camera.rightvec.z + scene->camera.bottom * scene->camera.upvec.z;
              goto __CPROVER_DUMP_L15;
            }
          case 3:
            {
              scene->camera.projcent.x = scene->camera.center.x + scene->camera.focallength * scene->camera.viewvec.x;
              scene->camera.projcent.y = scene->camera.center.y + scene->camera.focallength * scene->camera.viewvec.y;
              scene->camera.projcent.z = scene->camera.center.z + scene->camera.focallength * scene->camera.viewvec.z;
              goto __CPROVER_DUMP_L15;
            }
          case 0:

            default:
              {
                scene->camera.projcent.x = scene->camera.center.x + scene->camera.focallength * scene->camera.viewvec.x;
                scene->camera.projcent.y = scene->camera.center.y + scene->camera.focallength * scene->camera.viewvec.y;
                scene->camera.projcent.z = scene->camera.center.z + scene->camera.focallength * scene->camera.viewvec.z;
                scene->camera.lowleft.x = (scene->camera.projcent.x + scene->camera.left * scene->camera.rightvec.x + scene->camera.bottom * scene->camera.upvec.x) - scene->camera.center.x;
                scene->camera.lowleft.y = (scene->camera.projcent.y + scene->camera.left * scene->camera.rightvec.y + scene->camera.bottom * scene->camera.upvec.y) - scene->camera.center.y;
                scene->camera.lowleft.z = (scene->camera.projcent.z + scene->camera.left * scene->camera.rightvec.z + scene->camera.bottom * scene->camera.upvec.z) - scene->camera.center.z;
              }
        }

      __CPROVER_DUMP_L15:
        ;
        scene->camera.px = scene->camera.right - scene->camera.left;
        scene->camera.py = scene->camera.top - scene->camera.bottom;
        scene->camera.psx = scene->camera.px / (double)scene->hres;
        scene->camera.psy = scene->camera.py / (double)scene->vres;
        scene->camera.iplaneright.x = (scene->camera.px * scene->camera.rightvec.x) / sx;
        scene->camera.iplaneright.y = (scene->camera.px * scene->camera.rightvec.y) / sx;
        scene->camera.iplaneright.z = (scene->camera.px * scene->camera.rightvec.z) / sx;
        scene->camera.iplaneup.x = (scene->camera.py * scene->camera.upvec.x) / sy;
        scene->camera.iplaneup.y = (scene->camera.py * scene->camera.upvec.y) / sy;
        scene->camera.iplaneup.z = (scene->camera.py * scene->camera.upvec.z) / sy;
      }
  }
}

// c::cameradof
// file ../src/camera.h line 12
void cameradof(struct anon$14 *camera, double focallength, double aperture)
{
  camera->focallength = focallength;
  camera->aperture = aperture;
}

// c::camerafrustum
// file ../src/camera.h line 13
void camerafrustum(struct anon$14 *camera, double left, double right, double bottom, double top)
{
  camera->left = left;
  camera->right = right;
  camera->bottom = bottom;
  camera->top = top;
}

// c::cameraposition
// file ../src/camera.h line 15
void cameraposition(struct anon$14 *camera, struct anon$0 center, struct anon$0 viewvec, struct anon$0 upvec)
{
  struct anon$0 newupvec;
  struct anon$0 newviewvec;
  struct anon$0 newrightvec;
  VCross(&upvec, &viewvec, &newrightvec);
  VNorm(&newrightvec);
  VCross(&viewvec, &newrightvec, &newupvec);
  VNorm(&newupvec);
  newviewvec = viewvec;
  VNorm(&newviewvec);
  camera->center = center;
  camera->viewvec = newviewvec;
  camera->rightvec = newrightvec;
  camera->upvec = newupvec;
}

// c::cameraprojection
// file ../src/camera.h line 11
void cameraprojection(struct anon$14 *camera, signed int mode)
{
  camera->projection = mode;
}

// c::camerasetup
// file ../src/camera.h line 10
void camerasetup(struct anon$31$link211 *scene, double zoom, struct anon$0 center, struct anon$0 viewvec, struct anon$0 upvec)
{
  double sx;
  double sy;
  struct anon$14 *camera = &scene->camera;
  struct anon$0 newupvec;
  struct anon$0 newviewvec;
  struct anon$0 newrightvec;
  VCross(&upvec, &viewvec, &newrightvec);
  VNorm(&newrightvec);
  VCross(&viewvec, &newrightvec, &newupvec);
  VNorm(&newupvec);
  newviewvec = viewvec;
  VNorm(&newviewvec);
  camera->camzoom = zoom;
  camera->center = center;
  camera->viewvec = newviewvec;
  camera->rightvec = newrightvec;
  camera->upvec = newupvec;
  sx = (double)scene->hres;
  sy = (double)scene->vres;
  camera->px = ((sx / sy) / scene->aspectratio) / scene->camera.camzoom;
  camera->py = 1.000000 / scene->camera.camzoom;
  camera->psx = camera->px / sx;
  camera->psy = camera->py / sy;
  camera->left = -5.000000e-1 * camera->px;
  camera->right = 5.000000e-1 * camera->px;
  camera->bottom = -5.000000e-1 * camera->py;
  camera->top = 5.000000e-1 * camera->py;
  camera->focallength = 1.000000;
}

// c::camray_init
// file ../src/camera.c line 158
void camray_init(struct anon$31$link211 *scene, struct ray_t$link210 *primary, unsigned long int serial, unsigned long int *mbox, unsigned int randval)
{
  if(!((4096u & scene->flags) == 0u))
    primary->add_intersection = add_clipped_intersection;

  else
    primary->add_intersection = add_regular_intersection;
  primary->serial = serial;
  primary->mbox = mbox;
  primary->scene = scene;
  primary->depth = (unsigned int)scene->raydepth;
  primary->randval = randval;
  rng_frand_init(&primary->frng);
  primary->d = scene->camera.viewvec;
  primary->o = scene->camera.center;
}

// c::cellbound
// file ../src/grid.c line 128
static signed int cellbound(const struct anon$50 *g, const struct anon$51 *index, struct anon$0 *cmin, struct anon$0 *cmax)
{
  struct anon$0 min;
  struct anon$0 max;
  struct anon$0 cellmin;
  struct anon$0 cellmax;
  struct objectlist *cur;
  signed int numinbounds = 0;
  cur = g->cells[(signed long int)(index->z * g->xsize * g->ysize + index->y * g->xsize + index->x)];
  if(cur == ((struct objectlist *)NULL))
    return 0;

  cellmin.x = (double)index->x * g->voxsize.x + g->min.x;
  cellmin.y = (double)index->y * g->voxsize.y + g->min.y;
  cellmin.z = (double)index->z * g->voxsize.z + g->min.z;
  cellmax.x = cellmin.x + g->voxsize.x;
  cellmax.y = cellmin.y + g->voxsize.y;
  cellmax.z = cellmin.z + g->voxsize.z;
  cmin->x = 1.000000e+18;
  cmin->y = 1.000000e+18;
  cmin->z = 1.000000e+18;
  cmax->x = -1.000000e+18;
  cmax->y = -1.000000e+18;
  cmax->z = -1.000000e+18;
  double tmp_if_expr$1;
  double tmp_if_expr$2;
  double tmp_if_expr$3;
  double tmp_if_expr$4;
  double tmp_if_expr$5;
  double tmp_if_expr$6;
  while(!(cur == ((struct objectlist *)NULL)))
  {
    min.x = -1.000000e+18;
    min.y = -1.000000e+18;
    min.z = -1.000000e+18;
    max.x = 1.000000e+18;
    max.y = 1.000000e+18;
    max.z = 1.000000e+18;
    signed int return_value;
    return_value=cur->obj->methods->bbox((void *)cur->obj, &min, &max);
    if(!(return_value == 0))
    {
      if(min.x >= cellmin.x)
      {
        if(max.x <= cellmax.x)
        {
          if(min.y >= cellmin.y)
          {
            if(max.y <= cellmax.y)
            {
              if(min.z >= cellmin.z)
              {
                if(max.z <= cellmax.z)
                {
                  if(cmin->x < min.x)
                    tmp_if_expr$1 = cmin->x;

                  else
                    tmp_if_expr$1 = min.x;
                  cmin->x = tmp_if_expr$1;
                  if(cmin->y < min.y)
                    tmp_if_expr$2 = cmin->y;

                  else
                    tmp_if_expr$2 = min.y;
                  cmin->y = tmp_if_expr$2;
                  if(cmin->z < min.z)
                    tmp_if_expr$3 = cmin->z;

                  else
                    tmp_if_expr$3 = min.z;
                  cmin->z = tmp_if_expr$3;
                  if(cmax->x > max.x)
                    tmp_if_expr$4 = cmax->x;

                  else
                    tmp_if_expr$4 = max.x;
                  cmax->x = tmp_if_expr$4;
                  if(cmax->y > max.y)
                    tmp_if_expr$5 = cmax->y;

                  else
                    tmp_if_expr$5 = max.y;
                  cmax->y = tmp_if_expr$5;
                  if(cmax->z > max.z)
                    tmp_if_expr$6 = cmax->z;

                  else
                    tmp_if_expr$6 = max.z;
                  cmax->z = tmp_if_expr$6;
                  numinbounds = numinbounds + 1;
                }

              }

            }

          }

        }

      }

    }

    cur = cur->next;
  }
  if(cmax->x + -cmin->x < 5.000000e-8)
  {
    cmax->x = cmax->x + 5.000000e-8;
    cmin->x = cmin->x - 5.000000e-8;
  }

  if(cmax->y + -cmin->y < 5.000000e-8)
  {
    cmax->y = cmax->y + 5.000000e-8;
    cmin->y = cmin->y - 5.000000e-8;
  }

  if(cmax->z + -cmin->z < 5.000000e-8)
  {
    cmax->z = cmax->z + 5.000000e-8;
    cmin->z = cmin->z - 5.000000e-8;
  }

  return numinbounds;
}

// c::checker_texture
// file ../src/texture.h line 20
struct anon$4 checker_texture(const struct anon$0 *hit, const struct anon$25 *tx, struct ray_t$link234 *ry)
{
  signed long int x;
  signed long int y;
  signed long int z;
  double xh;
  double yh;
  double zh;
  struct anon$4 col;
  struct anon$35 *tex = (struct anon$35 *)tx;
  xh = hit->x - tex->ctr.x;
  double return_value_fabs$1;
  return_value_fabs$1=fabs(xh);
  x = (signed long int)(return_value_fabs$1 * (double)3 + 5.000000e-1);
  x = x % (signed long int)2;
  yh = hit->y - tex->ctr.y;
  double return_value_fabs$2;
  return_value_fabs$2=fabs(yh);
  y = (signed long int)(return_value_fabs$2 * (double)3 + 5.000000e-1);
  y = y % (signed long int)2;
  zh = hit->z - tex->ctr.z;
  double return_value_fabs$3;
  return_value_fabs$3=fabs(zh);
  z = (signed long int)(return_value_fabs$3 * (double)3 + 5.000000e-1);
  z = z % (signed long int)2;
  if((x + y + z) % 2l == 1l)
  {
    col.r = (float)1.000000;
    col.g = (float)2.000000e-1;
    col.b = (float)0.000000;
  }

  else
  {
    col.r = (float)0.000000;
    col.g = (float)2.000000e-1;
    col.b = (float)1.000000;
  }
  return col;
}

// c::clear_normals
// file ../demosrc/ac3dparse.c line 304
static void clear_normals(struct anon$0 *normals, signed int numverts)
{
  struct anon$0 tmp;
  signed int i;
  tmp.z = 0.000000;
  tmp.y = tmp.z;
  tmp.x = tmp.y;
  i = 0;
  while(!(i >= numverts))
  {
    normals[(signed long int)i] = tmp;
    i = i + 1;
  }
}

// c::closest_intersection
// file ../src/intersect.c line 96
signed int closest_intersection(double *t, const struct anon$15 **obj, struct ray_t$link0 *ry)
{
  if(ry->intstruct.num > 0)
  {
    *t = ry->intstruct.closest.t;
    *obj = ry->intstruct.closest.obj;
  }

  return ry->intstruct.num;
}

// c::closetgafile
// file ../src/tgafile.c line 166
void closetgafile(void *voidhandle)
{
  struct anon$72 *tga = (struct anon$72 *)voidhandle;
  fclose(tga->ofp);
  free((void *)tga);
}

// c::compare
// file ../demosrc/getargs.c line 20
static signed int compare(const char *a, const char *b)
{
  unsigned long int return_value_strlen$1;
  return_value_strlen$1=strlen(a);
  unsigned long int return_value_strlen$2;
  return_value_strlen$2=strlen(b);
  if(!(return_value_strlen$1 == return_value_strlen$2))
    return -1;

  unsigned long int return_value_strlen$3;
  return_value_strlen$3=strlen(a);
  signed int return_value_strupncmp$4;
  return_value_strupncmp$4=strupncmp(a, b, (signed int)return_value_strlen$3);
  return return_value_strupncmp$4;
}

// c::confstr
// file /usr/include/x86_64-linux-gnu/bits/unistd.h line 240
unsigned long int confstr(signed int __name, char *__buf, unsigned long int __len)
{
  unsigned long int return_value___confstr_chk$1;
  unsigned long int return_value___confstr_chk_warn$2;
  unsigned long int return_value___confstr_alias$3;
  return_value___confstr_alias$3=__confstr_alias(__name, __buf, __len);
  return return_value___confstr_alias$3;
}

// c::constant_texture
// file ../src/texture.h line 15
struct anon$4 constant_texture(const struct anon$0 *hit, const struct anon$25 *tx, struct ray_t$link234 *ry)
{
  struct anon$35 *tex = (struct anon$35 *)tx;
  return tex->col;
}

// c::countobj
// file ../src/grid.c line 191
static signed int countobj(struct anon$15 *root)
{
  struct anon$15 *cur;
  signed int numobj = 0;
  cur = root;
  while(!(cur == ((struct anon$15 *)NULL)))
  {
    cur = (struct anon$15 *)cur->nextobj;
    numobj = numobj + 1;
  }
  return numobj;
}

// c::create_render_threads
// file ../src/render.c line 61
void create_render_threads(struct anon$30$link108 *scene)
{
  struct anon$45 *parms;
  unsigned long int *threads;
  struct barrier_struct$link117 *bar;
  signed int thr;
  void *return_value_malloc$1;
  return_value_malloc$1=malloc((unsigned long int)scene->numthreads * 8ul /*[[unsigned long int]]*/);
  threads = (unsigned long int *)return_value_malloc$1;
  void *return_value_malloc$2;
  return_value_malloc$2=malloc((unsigned long int)scene->numthreads * 64ul /*[[struct anon$45]]*/);
  parms = (struct anon$45 *)return_value_malloc$2;
  bar=rt_thread_barrier_init(scene->numthreads);
  thr = 0;
  while(!(thr >= scene->numthreads))
  {
    (parms + (signed long int)thr)->tid = thr;
    (parms + (signed long int)thr)->nthr = scene->numthreads;
    (parms + (signed long int)thr)->scene = scene;
    void *return_value_calloc$3;
    return_value_calloc$3=calloc(8ul /*[[unsigned long int]]*/ * (unsigned long int)scene->objgroup.numobjects + (unsigned long int)32, (unsigned long int)1);
    (parms + (signed long int)thr)->local_mbox = (unsigned long int *)return_value_calloc$3;
    (parms + (signed long int)thr)->serialno = (unsigned long int)1;
    (parms + (signed long int)thr)->runbar = bar;
    if(scene->nodes == 1)
    {
      (parms + (signed long int)thr)->startx = 1;
      (parms + (signed long int)thr)->stopx = scene->hres;
      (parms + (signed long int)thr)->xinc = 1;
      (parms + (signed long int)thr)->starty = thr + 1;
      (parms + (signed long int)thr)->stopy = scene->vres;
      (parms + (signed long int)thr)->yinc = scene->numthreads;
    }

    else
    {
      (parms + (signed long int)thr)->startx = thr + 1;
      (parms + (signed long int)thr)->stopx = scene->hres;
      (parms + (signed long int)thr)->xinc = scene->numthreads;
      (parms + (signed long int)thr)->starty = scene->mynode + 1;
      (parms + (signed long int)thr)->stopy = scene->vres;
      (parms + (signed long int)thr)->yinc = scene->nodes;
    }
    thr = thr + 1;
  }
  scene->threadparms = (void *)parms;
  scene->threads = (void *)threads;
  thr = 1;
  while(!(thr >= scene->numthreads))
  {
    rt_thread_create(&threads[(signed long int)thr], thread_slave, (void *)&parms[(signed long int)thr]);
    thr = thr + 1;
  }
}

// c::createtgafile
// file ../src/tgafile.c line 20
signed int createtgafile(char *name, unsigned short int width, unsigned short int height)
{
  signed int filesize;
  struct _IO_FILE$link43 *ofp;
  filesize = (3 * (signed int)width * (signed int)height + 18) - 10;
  if(name == ((char *)NULL))
    return 5;

  else
  {
    ofp=fopen(name, "w+b");
    if(ofp == ((struct _IO_FILE$link43 *)NULL))
    {
      char msgtxt[2048l];
      sprintf(msgtxt, "Cannot create %s for output!", name);
      rt_ui_message(200, msgtxt);
      rt_ui_message(300, "Rendering Aborted.");
      return 5;
    }

    fputc(0, ofp);
    fputc(0, ofp);
    fputc(2, ofp);
    fputc(0, ofp);
    fputc(0, ofp);
    fputc(0, ofp);
    fputc(0, ofp);
    fputc(0, ofp);
    fputc(0, ofp);
    fputc(0, ofp);
    fputc(0, ofp);
    fputc(0, ofp);
    fputc((signed int)width & 255, ofp);
    fputc((signed int)width >> 8 & 255, ofp);
    fputc((signed int)height & 255, ofp);
    fputc((signed int)height >> 8 & 255, ofp);
    fputc(24, ofp);
    fputc(32, ofp);
    fseek(ofp, (signed long int)filesize, 0);
    fprintf(ofp, "9876543210");
    fclose(ofp);
  }
  return 0;
}

// c::cyl_checker_texture
// file ../src/texture.h line 21
struct anon$4 cyl_checker_texture(const struct anon$0 *hit, const struct anon$25 *tx, struct ray_t$link234 *ry)
{
  signed long int x;
  signed long int y;
  struct anon$0 rh;
  double u;
  double v;
  struct anon$4 col;
  struct anon$35 *tex = (struct anon$35 *)tx;
  rh.x = hit->x - tex->ctr.x;
  rh.y = hit->y - tex->ctr.y;
  rh.z = hit->z - tex->ctr.z;
  xyztocyl(rh, 1.000000, &u, &v);
  double return_value_fabs$1;
  return_value_fabs$1=fabs(u);
  x = (signed long int)(return_value_fabs$1 * 18.000000);
  x = x % (signed long int)2;
  double return_value_fabs$2;
  return_value_fabs$2=fabs(v);
  y = (signed long int)(return_value_fabs$2 * 10.000000);
  y = y % (signed long int)2;
  if((x + y) % 2l == 1l)
  {
    col.r = (float)1.000000;
    col.g = (float)2.000000e-1;
    col.b = (float)0.000000;
  }

  else
  {
    col.r = (float)0.000000;
    col.g = (float)2.000000e-1;
    col.b = (float)1.000000;
  }
  return col;
}

// c::cylinder_bbox
// file ../src/cylinder.c line 46
static signed int cylinder_bbox(void *obj, struct anon$0 *min, struct anon$0 *max)
{
  return 0;
}

// c::cylinder_intersect
// file ../src/cylinder.c line 50
static void cylinder_intersect(const struct anon$64 *cyl, struct ray_t$link162 *ry)
{
  struct anon$0 rc;
  struct anon$0 n;
  struct anon$0 D;
  struct anon$0 O;
  double t;
  double s;
  double tin;
  double tout;
  double ln;
  double d;
  rc.x = ry->o.x - cyl->ctr.x;
  rc.y = ry->o.y - cyl->ctr.y;
  rc.z = ry->o.z - cyl->ctr.z;
  VCross(&ry->d, &cyl->axis, &n);
  ln=sqrt(n.x * n.x + n.y * n.y + n.z * n.z);
  if(IEEE_FLOAT_EQUAL(ln, 0.000000))
  {
    d = rc.x * cyl->axis.x + rc.y * cyl->axis.y + rc.z * cyl->axis.z;
    D.x = rc.x - d * cyl->axis.x;
    D.y = rc.y - d * cyl->axis.y;
    D.z = rc.z - d * cyl->axis.z;
    d = D.x * D.x + D.y * D.y + D.z * D.z;
    d=sqrt(d);
    tin = -1.000000e+18;
    tout = 1.000000e+18;
  }

  n.x = n.x / ln;
  n.y = n.y / ln;
  n.z = n.z / ln;
  d = rc.x * n.x + rc.y * n.y + rc.z * n.z;
  d=fabs(d);
  if(d <= cyl->rad)
  {
    VCross(&rc, &cyl->axis, &O);
    t = O.x * n.x + O.y * n.y + O.z * n.z;
    t = -t / ln;
    VCross(&n, &cyl->axis, &O);
    ln=sqrt(O.x * O.x + O.y * O.y + O.z * O.z);
    O.x = O.x / ln;
    O.y = O.y / ln;
    O.z = O.z / ln;
    s = ry->d.x * O.x + ry->d.y * O.y + ry->d.z * O.z;
    double return_value_sqrt$1;
    return_value_sqrt$1=sqrt(cyl->rad * cyl->rad - d * d);
    s=fabs(return_value_sqrt$1 / s);
    tin = t - s;
    ry->add_intersection(tin, (struct anon$15 *)cyl, ry);
    tout = t + s;
    ry->add_intersection(tout, (struct anon$15 *)cyl, ry);
  }

}

// c::cylinder_normal
// file ../src/cylinder.c line 101
static void cylinder_normal(const struct anon$64 *cyl, const struct anon$0 *pnt, struct ray_t$link162 *incident, struct anon$0 *N)
{
  struct anon$0 a;
  struct anon$0 b;
  double t;
  double invlen;
  double invlen2;
  a.x = pnt->x - cyl->ctr.x;
  a.y = pnt->y - cyl->ctr.y;
  a.z = pnt->z - cyl->ctr.z;
  b = cyl->axis;
  double return_value_sqrt$1;
  return_value_sqrt$1=sqrt(b.x * b.x + b.y * b.y + b.z * b.z);
  invlen = 1.000000 / return_value_sqrt$1;
  b.x = b.x * invlen;
  b.y = b.y * invlen;
  b.z = b.z * invlen;
  t = a.x * b.x + a.y * b.y + a.z * b.z;
  N->x = pnt->x - (b.x * t + cyl->ctr.x);
  N->y = pnt->y - (b.y * t + cyl->ctr.y);
  N->z = pnt->z - (b.z * t + cyl->ctr.z);
  double return_value_sqrt$2;
  return_value_sqrt$2=sqrt(N->x * N->x + N->y * N->y + N->z * N->z);
  invlen2 = 1.000000 / return_value_sqrt$2;
  N->x = N->x * invlen2;
  N->y = N->y * invlen2;
  N->z = N->z * invlen2;
  double return_value_VDot$3;
  return_value_VDot$3=VDot(N, &incident->d);
  if(return_value_VDot$3 > 0.000000)
  {
    N->x = -N->x;
    N->y = -N->y;
    N->z = -N->z;
  }

}

// c::degtorad
// file ../demosrc/parse.c line 120
double degtorad(double deg)
{
  double tmp = (deg * 3.141593e+0) / 180.000000;
  return tmp;
}

// c::degvectoradvec
// file ../demosrc/parse.c line 126
static void degvectoradvec(struct anon$0 *degvec)
{
  struct anon$0 tmp;
  tmp.x=degtorad(degvec->x);
  tmp.y=degtorad(degvec->y);
  tmp.z=degtorad(degvec->z);
  *degvec = tmp;
}

// c::destroy_render_threads
// file ../src/render.h line 8
void destroy_render_threads(struct anon$30$link108 *scene)
{
  struct anon$45 *parms = (struct anon$45 *)scene->threadparms;
  unsigned long int *threads = (unsigned long int *)scene->threads;
  signed int thr;
  if(!(scene->threads == NULL))
  {
    rt_thread_barrier((parms + (signed long int)0)->runbar, 0);
    thr = 1;
    while(!(thr >= parms->nthr))
    {
      rt_thread_join(threads[(signed long int)thr], (void **)NULL);
      thr = thr + 1;
    }
    rt_thread_barrier_destroy((parms + (signed long int)0)->runbar);
    free(scene->threads);
  }

  if(!(scene->threadparms == NULL))
  {
    thr = 0;
    while(!(thr >= parms->nthr))
    {
      if(!((parms + (signed long int)thr)->local_mbox == ((unsigned long int *)NULL)))
        free((void *)(parms + (signed long int)thr)->local_mbox);

      thr = thr + 1;
    }
    free(scene->threadparms);
  }

  scene->threads = NULL;
  scene->threadparms = NULL;
}

// c::directional_light_shade_diffuse
// file ../src/light.c line 139
static double directional_light_shade_diffuse(struct directional_light_t$link271 *li, struct anon$19 *shadevars)
{
  double inten;
  shadevars->L = li->dir;
  shadevars->Llen = 1.000000e+18;
  inten = shadevars->N.x * li->dir.x + shadevars->N.y * li->dir.y + shadevars->N.z * li->dir.z;
  return inten;
}

// c::dprintf
// file /usr/include/x86_64-linux-gnu/bits/stdio2.h line 139
signed int dprintf(signed int __fd, const char * restrict __fmt, ...)
{
  void *return_value___builtin_va_arg_pack$1;
  return_value___builtin_va_arg_pack$1=__builtin_va_arg_pack();
  signed int return_value___dprintf_chk$2;
  return_value___dprintf_chk$2=__dprintf_chk(__fd, 2 - 1, __fmt, return_value___builtin_va_arg_pack$1);
  return return_value___dprintf_chk$2;
}

// c::engrid_cell
// file ../src/grid.c line 304
static signed int engrid_cell(struct anon$44$link94 *scene, signed int boundthresh, struct anon$50 *gold, struct anon$51 *index)
{
  struct anon$0 gmin;
  struct anon$0 gmax;
  struct anon$0 gsize;
  double len;
  signed int numobj;
  signed int numcbrt;
  signed int xs;
  signed int ys;
  signed int zs;
  struct anon$50 *g;
  struct objectlist **list;
  struct objectlist *newobj;
  signed int numsucceeded;
  list = &gold->cells[(signed long int)(index->z * gold->xsize * gold->ysize + index->y * gold->xsize + index->x)];
  if(*list == ((struct objectlist *)NULL))
    return 0;

  numobj=cellbound(gold, index, &gmin, &gmax);
  VSub(&gmax, &gmin, &gsize);
  len = 1.000000 / ((gsize.x > gsize.y ? gsize.x : gsize.y) > gsize.z ? (gsize.x > gsize.y ? gsize.x : gsize.y) : gsize.z);
  gsize.x = gsize.x * len;
  gsize.y = gsize.y * len;
  gsize.z = gsize.z * len;
  double tmp_if_expr$4;
  double return_value_pow$1;
  double tmp_if_expr$3;
  double return_value_pow$2;
  if(!(boundthresh >= numobj))
  {
    if((double)(2 * numobj) > 0.000000)
    {
      return_value_pow$1=pow((double)(2 * numobj), 1.000000 / 3.000000);
      tmp_if_expr$4 = return_value_pow$1;
    }

    else
    {
      if((double)(2 * numobj) < 0.000000)
      {
        return_value_pow$2=pow((double)-(2 * numobj), 1.000000 / 3.000000);
        tmp_if_expr$3 = -return_value_pow$2;
      }

      else
        tmp_if_expr$3 = 0.000000;
      tmp_if_expr$4 = tmp_if_expr$3;
    }
    numcbrt = (signed int)tmp_if_expr$4;
    xs = (signed int)((double)numcbrt * gsize.x);
    if(xs < 1)
      xs = 1;

    ys = (signed int)((double)numcbrt * gsize.y);
    if(ys < 1)
      ys = 1;

    zs = (signed int)((double)numcbrt * gsize.z);
    if(zs < 1)
      zs = 1;

    struct anon$15 *return_value_newgrid$5;
    return_value_newgrid$5=newgrid(scene, xs, ys, zs, gmin, gmax);
    g = (struct anon$50 *)return_value_newgrid$5;
    numsucceeded=engrid_objectlist(g, list);
    if(!(scene->verbosemode == 0))
    {
      if(scene->mynode == 0)
        gridstats(xs, ys, zs, numsucceeded);

    }

    void *return_value_malloc$6;
    return_value_malloc$6=malloc(16ul /*[[struct objectlist]]*/);
    newobj = (struct objectlist *)return_value_malloc$6;
    newobj->obj = (struct anon$15 *)g;
    newobj->next = *list;
    *list = newobj;
    g->nextobj = (void *)gold->objects;
    gold->objects = (struct anon$15 *)g;
  }

  return 1;
}

// c::engrid_object
// file ../src/grid.c line 383
static signed int engrid_object(struct anon$50 *g, struct anon$15 *obj, signed int addtolist)
{
  struct anon$0 omin;
  struct anon$0 omax;
  struct anon$51 low;
  struct anon$51 high;
  signed int x;
  signed int y;
  signed int z;
  signed int zindex;
  signed int yindex;
  signed int voxindex;
  struct objectlist *tmp;
  signed int return_value;
  return_value=obj->methods->bbox((void *)obj, &omin, &omax);
  _Bool tmp_if_expr$3;
  signed int return_value_pos2grid$2;
  if(!(return_value == 0))
  {
    signed int return_value_pos2grid$1;
    return_value_pos2grid$1=pos2grid(g, &omin, &low);
    if(return_value_pos2grid$1 == 0)
      tmp_if_expr$3 = TRUE;

    else
    {
      return_value_pos2grid$2=pos2grid(g, &omax, &high);
      tmp_if_expr$3 = !(return_value_pos2grid$2 != 0) ? TRUE : FALSE;
    }
    if(tmp_if_expr$3)
      return 0;

  }

  else
    return 0;
  if(!(addtolist == 0))
  {
    obj->nextobj = (void *)g->objects;
    g->objects = obj;
  }

  z = low.z;
  while(high.z >= z)
  {
    zindex = z * g->xsize * g->ysize;
    y = low.y;
    while(high.y >= y)
    {
      yindex = y * g->xsize;
      x = low.x;
      while(high.x >= x)
      {
        voxindex = x + yindex + zindex;
        void *return_value_malloc$4;
        return_value_malloc$4=malloc(16ul /*[[struct objectlist]]*/);
        tmp = (struct objectlist *)return_value_malloc$4;
        tmp->next = g->cells[(signed long int)voxindex];
        tmp->obj = obj;
        g->cells[(signed long int)voxindex] = tmp;
        x = x + 1;
      }
      y = y + 1;
    }
    z = z + 1;
  }
  return 1;
}

// c::engrid_objectlist
// file ../src/grid.c line 355
static signed int engrid_objectlist(struct anon$50 *g, struct objectlist **list)
{
  struct objectlist *cur;
  struct objectlist *next;
  struct objectlist **prev;
  signed int numsucceeded = 0;
  if(*list == ((struct objectlist *)NULL))
    return 0;

  prev = list;
  cur = *list;
  while(!(cur == ((struct objectlist *)NULL)))
  {
    next = cur->next;
    signed int return_value_engrid_object$1;
    return_value_engrid_object$1=engrid_object(g, cur->obj, 0);
    if(!(return_value_engrid_object$1 == 0))
    {
      *prev = next;
      free((void *)cur);
      numsucceeded = numsucceeded + 1;
    }

    else
      prev = &cur->next;
    cur = next;
  }
  return numsucceeded;
}

// c::engrid_objlist
// file ../src/grid.c line 277
static signed int engrid_objlist(struct anon$50 *g, struct anon$15 **list)
{
  struct anon$15 *cur;
  struct anon$15 *next;
  struct anon$15 **prev;
  signed int numsucceeded = 0;
  if(*list == ((struct anon$15 *)NULL))
    return 0;

  prev = list;
  cur = *list;
  while(!(cur == ((struct anon$15 *)NULL)))
  {
    next = (struct anon$15 *)cur->nextobj;
    signed int return_value_engrid_object$1;
    return_value_engrid_object$1=engrid_object(g, cur, 1);
    if(!(return_value_engrid_object$1 == 0))
    {
      *prev = next;
      numsucceeded = numsucceeded + 1;
    }

    else
      prev = (struct anon$15 **)&cur->nextobj;
    cur = next;
  }
  return numsucceeded;
}

// c::engrid_scene
// file ../src/grid.h line 8
signed int engrid_scene(struct anon$44$link94 *scene, signed int boundthresh)
{
  struct anon$50 *g;
  signed int numobj;
  signed int numcbrt;
  struct anon$0 gmin = (struct anon$0){ .x=(double)0, .y=(double)0, .z=(double)0 };
  struct anon$0 gmax = (struct anon$0){ .x=(double)0, .y=(double)0, .z=(double)0 };
  struct anon$51 index;
  char msgtxt[128l];
  signed int numsucceeded;
  if(scene->objgroup.boundedobj == ((struct anon$15 *)NULL))
    return 0;

  numobj=countobj(scene->objgroup.boundedobj);
  if(scene->mynode == 0)
  {
    sprintf(msgtxt, "Scene contains %d objects.", numobj);
    rt_ui_message(100, msgtxt);
  }

  double tmp_if_expr$4;
  double return_value_pow$1;
  double tmp_if_expr$3;
  double return_value_pow$2;
  if(!(boundthresh >= numobj))
  {
    if((double)(4 * numobj) > 0.000000)
    {
      return_value_pow$1=pow((double)(4 * numobj), 1.000000 / 3.000000);
      tmp_if_expr$4 = return_value_pow$1;
    }

    else
    {
      if((double)(4 * numobj) < 0.000000)
      {
        return_value_pow$2=pow((double)-(4 * numobj), 1.000000 / 3.000000);
        tmp_if_expr$3 = -return_value_pow$2;
      }

      else
        tmp_if_expr$3 = 0.000000;
      tmp_if_expr$4 = tmp_if_expr$3;
    }
    numcbrt = (signed int)tmp_if_expr$4;
    globalbound(&scene->objgroup.boundedobj, &gmin, &gmax);
    if(!(scene->verbosemode == 0))
    {
      if(scene->mynode == 0)
      {
        char engrid_scene$$1$$2$$1$$t[256l];
        sprintf(engrid_scene$$1$$2$$1$$t, "Global bounds: %g %g %g -> %g %g %g", gmin.x, gmin.y, gmin.z, gmax.x, gmax.y, gmax.z);
        rt_ui_message(100, engrid_scene$$1$$2$$1$$t);
        sprintf(engrid_scene$$1$$2$$1$$t, "Creating top level grid: X:%d Y:%d Z:%d", numcbrt, numcbrt, numcbrt);
        rt_ui_message(100, engrid_scene$$1$$2$$1$$t);
      }

    }

    struct anon$15 *return_value_newgrid$5;
    return_value_newgrid$5=newgrid(scene, numcbrt, numcbrt, numcbrt, gmin, gmax);
    g = (struct anon$50 *)return_value_newgrid$5;
    numsucceeded=engrid_objlist(g, &scene->objgroup.boundedobj);
    if(!(scene->verbosemode == 0))
    {
      if(scene->mynode == 0)
        gridstats(numcbrt, numcbrt, numcbrt, numsucceeded);

    }

    if(!(scene->verbosemode == 0))
    {
      if(scene->mynode == 0)
      {
        char engrid_scene$$1$$2$$2$$t[256l];
        numobj=countobj(scene->objgroup.boundedobj);
        sprintf(engrid_scene$$1$$2$$2$$t, "Scene contains %d non-gridded objects\n", numobj);
        rt_ui_message(100, engrid_scene$$1$$2$$2$$t);
      }

    }

    g->nextobj = (void *)scene->objgroup.boundedobj;
    scene->objgroup.boundedobj = (struct anon$15 *)g;
    index.z = 0;
    while(!(index.z >= g->zsize))
    {
      index.y = 0;
      while(!(index.y >= g->ysize))
      {
        index.x = 0;
        while(!(index.x >= g->xsize))
        {
          engrid_cell(scene, boundthresh, g, &index);
          index.x = index.x + 1;
        }
        index.y = index.y + 1;
      }
      index.z = index.z + 1;
    }
  }

  return 1;
}

// c::ext_volume_texture
// file ../src/extvol.c line 107
struct anon$4 ext_volume_texture(const struct anon$0 *hit, const struct anon$25 *tx, struct ray_t$link67 *ry)
{
  struct anon$4 col;
  struct anon$4 col2;
  struct anon$26 *bx;
  struct anon$29 *xvol;
  double a;
  double tx1;
  double tx2;
  double ty1;
  double ty2;
  double tz1;
  double tz2;
  double tnear;
  double tfar;
  double t;
  double tdist;
  double dt;
  double ddt;
  double sum;
  double tt;
  struct anon$0 pnt;
  struct anon$0 bln;
  double scalar;
  double transval;
  struct point_light_t$link179 *li;
  struct anon$4 diffint;
  struct anon$0 N;
  struct anon$0 L;
  double inten;
  struct anon$35 *tex = (struct anon$35 *)tx;
  bx = (struct anon$26 *)tex->obj;
  xvol = (struct anon$29 *)tex->obj;
  col.r = (float)0.000000;
  col.g = (float)0.000000;
  col.b = (float)0.000000;
  tnear = -1.000000e+18;
  tfar = 1.000000e+18;
  _Bool tmp_if_expr$1;
  if(IEEE_FLOAT_EQUAL(ry->d.x, 0.000000))
  {
    if(ry->o.x < bx->min.x)
      tmp_if_expr$1 = TRUE;

    else
      tmp_if_expr$1 = ry->o.x > bx->max.x ? TRUE : FALSE;
    if(tmp_if_expr$1)
      return col;

  }

  else
  {
    tx1 = (bx->min.x - ry->o.x) / ry->d.x;
    tx2 = (bx->max.x - ry->o.x) / ry->d.x;
    if(tx1 > tx2)
    {
      a = tx1;
      tx1 = tx2;
      tx2 = a;
    }

    if(tx1 > tnear)
      tnear = tx1;

    if(tx2 < tfar)
      tfar = tx2;

  }
  if(tnear > tfar)
    return col;

  if(tfar < 0.000000)
    return col;

  _Bool tmp_if_expr$2;
  if(IEEE_FLOAT_EQUAL(ry->d.y, 0.000000))
  {
    if(ry->o.y < bx->min.y)
      tmp_if_expr$2 = TRUE;

    else
      tmp_if_expr$2 = ry->o.y > bx->max.y ? TRUE : FALSE;
    if(tmp_if_expr$2)
      return col;

  }

  else
  {
    ty1 = (bx->min.y - ry->o.y) / ry->d.y;
    ty2 = (bx->max.y - ry->o.y) / ry->d.y;
    if(ty1 > ty2)
    {
      a = ty1;
      ty1 = ty2;
      ty2 = a;
    }

    if(ty1 > tnear)
      tnear = ty1;

    if(ty2 < tfar)
      tfar = ty2;

  }
  if(tnear > tfar)
    return col;

  if(tfar < 0.000000)
    return col;

  _Bool tmp_if_expr$3;
  if(IEEE_FLOAT_EQUAL(ry->d.z, 0.000000))
  {
    if(ry->o.z < bx->min.z)
      tmp_if_expr$3 = TRUE;

    else
      tmp_if_expr$3 = ry->o.z > bx->max.z ? TRUE : FALSE;
    if(tmp_if_expr$3)
      return col;

  }

  else
  {
    tz1 = (bx->min.z - ry->o.z) / ry->d.z;
    tz2 = (bx->max.z - ry->o.z) / ry->d.z;
    if(tz1 > tz2)
    {
      a = tz1;
      tz1 = tz2;
      tz2 = a;
    }

    if(tz1 > tnear)
      tnear = tz1;

    if(tz2 < tfar)
      tfar = tz2;

  }
  if(tnear > tfar)
    return col;

  if(tfar < 0.000000)
    return col;

  if(tnear < 0.000000)
    tnear = 0.000000;

  tdist = (double)xvol->samples;
  tt = xvol->opacity / tdist;
  bln.x=fabs(bx->min.x - bx->max.x);
  bln.y=fabs(bx->min.y - bx->max.y);
  bln.z=fabs(bx->min.z - bx->max.z);
  dt = 1.000000 / tdist;
  sum = 0.000000;
  t = tnear;
  while(t <= tfar)
  {
    if(sum < 1.000000)
    {
      pnt.x = ((ry->o.x + ry->d.x * t) - bx->min.x) / bln.x;
      pnt.y = ((ry->o.y + ry->d.y * t) - bx->min.y) / bln.y;
      pnt.z = ((ry->o.z + ry->d.z * t) - bx->min.z) / bln.z;
      scalar=xvol->evaluator(pnt.x, pnt.y, pnt.z);
      transval = tt * scalar;
      sum = sum + transval;
      col2=ExtVoxelColor(scalar);
      col.r = col.r + (float)(transval * (double)col2.r * xvol->ambient);
      col.g = col.g + (float)(transval * (double)col2.g * xvol->ambient);
      col.b = col.b + (float)(transval * (double)col2.b * xvol->ambient);
      ddt = dt;
      if(xvol->diffuse > 0.000000)
      {
        double return_value;
        return_value=xvol->evaluator(pnt.x - ddt, pnt.y, pnt.z);
        double return_value_1;
        return_value_1=xvol->evaluator(pnt.x + ddt, pnt.y, pnt.z);
        N.x = (return_value - return_value_1) * 8.000000 * tt;
        double return_value_2;
        return_value_2=xvol->evaluator(pnt.x, pnt.y - ddt, pnt.z);
        double return_value_3;
        return_value_3=xvol->evaluator(pnt.x, pnt.y + ddt, pnt.z);
        N.y = (return_value_2 - return_value_3) * 8.000000 * tt;
        double return_value_4;
        return_value_4=xvol->evaluator(pnt.x, pnt.y, pnt.z - ddt);
        double return_value_5;
        return_value_5=xvol->evaluator(pnt.x, pnt.y, pnt.z + ddt);
        N.z = (return_value_4 - return_value_5) * 8.000000 * tt;
        if(N.x * N.x + N.y * N.y + N.z * N.z > 0.000000)
        {
          struct list$link70 *cur;
          diffint.r = (float)0.000000;
          diffint.g = (float)0.000000;
          diffint.b = (float)0.000000;
          cur = ry->scene->lightlist;
          while(!(cur == ((struct list$link70 *)NULL)))
          {
            li = (struct point_light_t$link179 *)cur->item;
            L.x = li->ctr.x - hit->x;
            L.y = li->ctr.y - hit->y;
            L.z = li->ctr.z - hit->z;
            VNorm(&L);
            inten = N.x * L.x + N.y * L.y + N.z * L.z;
            if(inten > 0.000000)
            {
              struct anon$35 *litex = (struct anon$35 *)li->tex;
              diffint.r = diffint.r + (float)(inten * (double)litex->col.r);
              diffint.g = diffint.g + (float)(inten * (double)litex->col.g);
              diffint.b = diffint.b + (float)(inten * (double)litex->col.b);
            }

            cur = cur->next;
          }
          col.r = col.r + (float)((double)(col2.r * diffint.r) * xvol->diffuse);
          col.g = col.g + (float)((double)(col2.g * diffint.g) * xvol->diffuse);
          col.b = col.b + (float)((double)(col2.b * diffint.b) * xvol->diffuse);
        }

      }

    }

    else
      sum = 1.000000;
    t = t + dt;
  }
  if(sum < 1.000000)
  {
    struct anon$4 transcol;
    struct anon$19 shadevars;
    shadevars.hit = *hit;
    transcol=shade_transmission(ry, &shadevars, 1.000000 - sum);
    col.r = col.r + transcol.r;
    col.g = col.g + transcol.g;
    col.b = col.b + transcol.b;
  }

  return col;
}

// c::extvol_bbox
// file ../src/extvol.c line 23
signed int extvol_bbox(void *obj, struct anon$0 *min, struct anon$0 *max)
{
  struct anon$26 *b = (struct anon$26 *)obj;
  *min = b->min;
  *max = b->max;
  return 1;
}

// c::fakeimage
// file ../src/imageio.c line 26
static signed int fakeimage(char *name, signed int *xres, signed int *yres, unsigned char **imgdata)
{
  signed int i;
  signed int imgsize;
  char msgtxt[2048l];
  sprintf(msgtxt, "Error loading image %s.  Faking it using solid gray.", name);
  rt_ui_message(100, msgtxt);
  *xres = 4;
  *yres = 4;
  imgsize = 3 * *xres * *yres;
  void *return_value_malloc$1;
  return_value_malloc$1=malloc((unsigned long int)imgsize);
  *imgdata = (unsigned char *)return_value_malloc$1;
  i = 0;
  while(!(i >= imgsize))
  {
    (*imgdata)[(signed long int)i] = (unsigned char)255;
    i = i + 1;
  }
  return 0;
}

// c::fcylinder_bbox
// file ../src/cylinder.c line 150
static signed int fcylinder_bbox(void *obj, struct anon$0 *min, struct anon$0 *max)
{
  struct anon$64 *c = (struct anon$64 *)obj;
  struct anon$0 mintmp;
  struct anon$0 maxtmp;
  mintmp.x = c->ctr.x;
  mintmp.y = c->ctr.y;
  mintmp.z = c->ctr.z;
  maxtmp.x = c->ctr.x + c->axis.x;
  maxtmp.y = c->ctr.y + c->axis.y;
  maxtmp.z = c->ctr.z + c->axis.z;
  min->x = mintmp.x < maxtmp.x ? mintmp.x : maxtmp.x;
  min->y = mintmp.y < maxtmp.y ? mintmp.y : maxtmp.y;
  min->z = mintmp.z < maxtmp.z ? mintmp.z : maxtmp.z;
  min->x = min->x - c->rad;
  min->y = min->y - c->rad;
  min->z = min->z - c->rad;
  max->x = mintmp.x > maxtmp.x ? mintmp.x : maxtmp.x;
  max->y = mintmp.y > maxtmp.y ? mintmp.y : maxtmp.y;
  max->z = mintmp.z > maxtmp.z ? mintmp.z : maxtmp.z;
  max->x = max->x + c->rad;
  max->y = max->y + c->rad;
  max->z = max->z + c->rad;
  return 1;
}

// c::fcylinder_intersect
// file ../src/cylinder.c line 179
static void fcylinder_intersect(const struct anon$64 *cyl, struct ray_t$link162 *ry)
{
  struct anon$0 rc;
  struct anon$0 n;
  struct anon$0 O;
  struct anon$0 hit;
  struct anon$0 tmp2;
  struct anon$0 ctmp4;
  double t;
  double s;
  double tin;
  double tout;
  double ln;
  double d;
  double tmp;
  double tmp3;
  rc.x = ry->o.x - cyl->ctr.x;
  rc.y = ry->o.y - cyl->ctr.y;
  rc.z = ry->o.z - cyl->ctr.z;
  VCross(&ry->d, &cyl->axis, &n);
  ln=sqrt(n.x * n.x + n.y * n.y + n.z * n.z);
  if(IEEE_FLOAT_EQUAL(ln, 0.000000))
    return;

  n.x = n.x / ln;
  n.y = n.y / ln;
  n.z = n.z / ln;
  d = rc.x * n.x + rc.y * n.y + rc.z * n.z;
  d=fabs(d);
  double return_value_sqrt$2;
  double return_value_sqrt$3;
  if(d <= cyl->rad)
  {
    VCross(&rc, &cyl->axis, &O);
    t = O.x * n.x + O.y * n.y + O.z * n.z;
    t = -t / ln;
    VCross(&n, &cyl->axis, &O);
    ln=sqrt(O.x * O.x + O.y * O.y + O.z * O.z);
    O.x = O.x / ln;
    O.y = O.y / ln;
    O.z = O.z / ln;
    s = ry->d.x * O.x + ry->d.y * O.y + ry->d.z * O.z;
    double return_value_sqrt$1;
    return_value_sqrt$1=sqrt(cyl->rad * cyl->rad - d * d);
    s=fabs(return_value_sqrt$1 / s);
    tin = t - s;
    hit.x = ry->o.x + ry->d.x * tin;
    hit.y = ry->o.y + ry->d.y * tin;
    hit.z = ry->o.z + ry->d.z * tin;
    ctmp4 = cyl->axis;
    VNorm(&ctmp4);
    tmp2.x = hit.x - cyl->ctr.x;
    tmp2.y = hit.y - cyl->ctr.y;
    tmp2.z = hit.z - cyl->ctr.z;
    tmp = tmp2.x * ctmp4.x + tmp2.y * ctmp4.y + tmp2.z * ctmp4.z;
    tmp3 = cyl->axis.x * cyl->axis.x + cyl->axis.y * cyl->axis.y + cyl->axis.z * cyl->axis.z;
    if(tmp > 0.000000)
    {
      return_value_sqrt$2=sqrt(tmp3);
      if(tmp < return_value_sqrt$2)
        ry->add_intersection(tin, (struct anon$15 *)cyl, ry);

    }

    tout = t + s;
    hit.x = ry->o.x + ry->d.x * tout;
    hit.y = ry->o.y + ry->d.y * tout;
    hit.z = ry->o.z + ry->d.z * tout;
    tmp2.x = hit.x - cyl->ctr.x;
    tmp2.y = hit.y - cyl->ctr.y;
    tmp2.z = hit.z - cyl->ctr.z;
    tmp = tmp2.x * ctmp4.x + tmp2.y * ctmp4.y + tmp2.z * ctmp4.z;
    tmp3 = cyl->axis.x * cyl->axis.x + cyl->axis.y * cyl->axis.y + cyl->axis.z * cyl->axis.z;
    if(tmp > 0.000000)
    {
      return_value_sqrt$3=sqrt(tmp3);
      if(tmp < return_value_sqrt$3)
        ry->add_intersection(tout, (struct anon$15 *)cyl, ry);

    }

  }

}

// c::feof_unlocked
// file /usr/include/x86_64-linux-gnu/bits/stdio.h line 125
signed int feof_unlocked(struct _IO_FILE *__stream)
{
  return (signed int)((__stream->_flags & 16) != 0);
}

// c::ferror_unlocked
// file /usr/include/x86_64-linux-gnu/bits/stdio.h line 132
signed int ferror_unlocked(struct _IO_FILE *__stream)
{
  return (signed int)((__stream->_flags & 32) != 0);
}

// c::fgetc_unlocked
// file /usr/include/x86_64-linux-gnu/bits/stdio.h line 53
signed int fgetc_unlocked(struct _IO_FILE *__fp)
{
  signed int tmp_if_expr$3;
  signed int return_value___uflow$1;
  char *tmp_post$2;
  if(__fp->_IO_read_ptr >= __fp->_IO_read_end)
  {
    return_value___uflow$1=__uflow(__fp);
    tmp_if_expr$3 = return_value___uflow$1;
  }

  else
  {
    tmp_post$2 = __fp->_IO_read_ptr;
    __fp->_IO_read_ptr = __fp->_IO_read_ptr + 1l;
    tmp_if_expr$3 = (signed int)*((unsigned char *)tmp_post$2);
  }
  return tmp_if_expr$3;
}

// c::fgets
// file /usr/include/x86_64-linux-gnu/bits/stdio2.h line 253
char * fgets(char * restrict __s, signed int __n, struct _IO_FILE * restrict __stream)
{
  char *return_value___fgets_chk$1;
  char *return_value___fgets_chk_warn$2;
  if(FALSE)
  {

  __CPROVER_DUMP_L1:
    ;
    return_value___fgets_chk$1=__fgets_chk(__s, 18446744073709551615ul, __n, __stream);
    return return_value___fgets_chk$1;
    if((unsigned long int)__n > 18446744073709551615ul)
    {
      return_value___fgets_chk_warn$2=__fgets_chk_warn(__s, 18446744073709551615ul, __n, __stream);
      return return_value___fgets_chk_warn$2;
    }

  }

  char *return_value___fgets_alias$3;
  return_value___fgets_alias$3=__fgets_alias(__s, __n, __stream);
  return return_value___fgets_alias$3;
}

// c::find_texture
// file ../demosrc/parse.c line 108
static void * find_texture(struct anon$6 *ph, const char *name)
{
  signed int i;
  i=rt_hash_lookup(&ph->texhash, name);
  if(!(i == -1))
    return (ph->textable + (signed long int)i)->tex;

  printf("Undefined texture '%s', using default. \n", name);
  return ph->defaulttex.tex;
}

// c::fly_scene
// file ../demosrc/main.c line 126
static signed int fly_scene(struct anon$1 opt, void *scene, signed int node)
{
  struct anon$3 *dh = (struct anon$3 *)NULL;
  signed int done = 0;
  signed int frameno = 0;
  float fps;
  void *fpstimer;
  void *animationtimer;
  char outfilename[1l];
  if(node == 0)
    dh=tachyon_display_create(scene);

  rt_set_ui_message((void (*)(signed int, char *))NULL);
  rt_set_ui_progress((void (*)(signed int))NULL);
  if(node == 0)
    printf("Interactive Camera Flight\n");

  outfilename[(signed long int)0] = (char)0;
  rt_outputfile(scene, outfilename);
  fpstimer=rt_timer_create();
  animationtimer=rt_timer_create();
  rt_timer_start(animationtimer);
  while(done == 0)
  {
    if(!(frameno == 0))
    {
      rt_timer_stop(fpstimer);
      double return_value_rt_timer_time$1;
      return_value_rt_timer_time$1=rt_timer_time(fpstimer);
      fps = (float)((double)1.000000f / return_value_rt_timer_time$1);
    }

    else
      fps = (float)0.000000;
    rt_timer_start(fpstimer);
    if(node == 0)
    {
      printf("\rRendering Frame: %9d   %10.4f FPS       ", frameno, fps);
      fflush(stdout);
    }

    rt_renderscene(scene);
    if(!(dh == ((struct anon$3 *)NULL)))
      tachyon_display_draw(dh);

    frameno = frameno + 1;
  }
  rt_timer_stop(animationtimer);
  double return_value_rt_timer_time$2;
  return_value_rt_timer_time$2=rt_timer_time(animationtimer);
  fps = (float)((double)frameno / return_value_rt_timer_time$2);
  if(node == 0)
  {
    printf("\rCompleted animation of %d frames                            \n", frameno);
    double return_value_rt_timer_time$3;
    return_value_rt_timer_time$3=rt_timer_time(animationtimer);
    printf("Animation Time: %10.4f seconds  (Averaged %7.4f FPS)\n", return_value_rt_timer_time$3, fps);
  }

  rt_timer_destroy(fpstimer);
  if(node == 0)
  {
    printf("\nFinished Running Camera.\n");
    if(!(dh == ((struct anon$3 *)NULL)))
      tachyon_display_delete(dh);

  }

  rt_deletescene(scene);
  rt_finalize();
  return 0;
}

// c::fog_color
// file ../src/shade.c line 628
struct anon$4 fog_color(struct ray_t$link1 *incident, struct anon$4 col, double t)
{
  struct fogdata_t$link3 *fog = &incident->scene->fog;
  float fogcoord = (float)t;
  if(fog->type == 1)
  {
    double hitz = incident->d.z * t;
    fogcoord = (float)((incident->flags & (unsigned int)1) != 0u ? hitz : t);
  }

  struct anon$4 return_value;
  return_value=incident->scene->fog.fog_fctn(fog, col, (double)fogcoord);
  return return_value;
}

// c::fog_color_exp
// file ../src/shade.h line 27
struct anon$4 fog_color_exp(struct fogdata_t$link3 *fog, struct anon$4 col, double r)
{
  struct anon$4 c;
  double f;
  double v = fog->density * (r - fog->start);
  f=exp(-v);
  if(f > 1.000000)
    f = 1.000000;

  else
    if(f < 0.000000)
      f = 0.000000;

  c.r = (float)(f * (double)col.r + ((double)1 - f) * (double)fog->col.r);
  c.g = (float)(f * (double)col.g + ((double)1 - f) * (double)fog->col.g);
  c.b = (float)(f * (double)col.b + ((double)1 - f) * (double)fog->col.b);
  return c;
}

// c::fog_color_exp2
// file ../src/shade.h line 28
struct anon$4 fog_color_exp2(struct fogdata_t$link3 *fog, struct anon$4 col, double r)
{
  struct anon$4 c;
  double f;
  double v = fog->density * (r - fog->start);
  f=exp(-v * v);
  if(f > 1.000000)
    f = 1.000000;

  else
    if(f < 0.000000)
      f = 0.000000;

  c.r = (float)(f * (double)col.r + ((double)1 - f) * (double)fog->col.r);
  c.g = (float)(f * (double)col.g + ((double)1 - f) * (double)fog->col.g);
  c.b = (float)(f * (double)col.b + ((double)1 - f) * (double)fog->col.b);
  return c;
}

// c::fog_color_linear
// file ../src/shade.h line 26
struct anon$4 fog_color_linear(struct fogdata_t$link3 *fog, struct anon$4 col, double r)
{
  struct anon$4 c;
  double f = ((fog->end - r) / (fog->end - fog->start)) * fog->density;
  if(f > 1.000000)
    f = 1.000000;

  else
    if(f < 0.000000)
      f = 0.000000;

  c.r = (float)(f * (double)col.r + ((double)1 - f) * (double)fog->col.r);
  c.g = (float)(f * (double)col.g + ((double)1 - f) * (double)fog->col.g);
  c.b = (float)(f * (double)col.b + ((double)1 - f) * (double)fog->col.b);
  return c;
}

// c::fprintf
// file /usr/include/x86_64-linux-gnu/bits/stdio2.h line 95
signed int fprintf(struct _IO_FILE * restrict __stream, const char * restrict __fmt, ...)
{
  void *return_value___builtin_va_arg_pack$1;
  return_value___builtin_va_arg_pack$1=__builtin_va_arg_pack();
  signed int return_value___fprintf_chk$2;
  return_value___fprintf_chk$2=__fprintf_chk(__stream, 2 - 1, __fmt, return_value___builtin_va_arg_pack$1);
  return return_value___fprintf_chk$2;
}

// c::fputc_unlocked
// file /usr/include/x86_64-linux-gnu/bits/stdio.h line 88
signed int fputc_unlocked(signed int __c, struct _IO_FILE *__stream)
{
  signed int tmp_if_expr$3;
  signed int return_value___overflow$1;
  char *tmp_post$2;
  if(__stream->_IO_write_ptr >= __stream->_IO_write_end)
  {
    return_value___overflow$1=__overflow(__stream, (signed int)(unsigned char)__c);
    tmp_if_expr$3 = return_value___overflow$1;
  }

  else
  {
    tmp_post$2 = __stream->_IO_write_ptr;
    __stream->_IO_write_ptr = __stream->_IO_write_ptr + 1l;
    *tmp_post$2 = (char)__c;
    tmp_if_expr$3 = (signed int)(unsigned char)*tmp_post$2;
  }
  return tmp_if_expr$3;
}

// c::fread
// file /usr/include/x86_64-linux-gnu/bits/stdio2.h line 282
unsigned long int fread(void * restrict __ptr, unsigned long int __size, unsigned long int __n, struct _IO_FILE * restrict __stream)
{
  unsigned long int return_value___fread_chk$1;
  unsigned long int return_value___fread_chk_warn$2;
  if(FALSE)
  {

  __CPROVER_DUMP_L1:
    ;
    return_value___fread_chk$1=__fread_chk(__ptr, 18446744073709551615ul, __size, __n, __stream);
    return return_value___fread_chk$1;
    if(__n * __size > 18446744073709551615ul)
    {
      return_value___fread_chk_warn$2=__fread_chk_warn(__ptr, 18446744073709551615ul, __size, __n, __stream);
      return return_value___fread_chk_warn$2;
    }

  }

  unsigned long int return_value___fread_alias$3;
  return_value___fread_alias$3=__fread_alias(__ptr, __size, __n, __stream);
  return return_value___fread_alias$3;
}

// c::fread_unlocked
// file /usr/include/x86_64-linux-gnu/bits/stdio2.h line 343
unsigned long int fread_unlocked(void * restrict __ptr, unsigned long int __size, unsigned long int __n, struct _IO_FILE * restrict __stream)
{
  unsigned long int return_value___fread_unlocked_chk$1;
  unsigned long int return_value___fread_unlocked_chk_warn$2;
  if(FALSE)
  {

  __CPROVER_DUMP_L1:
    ;
    return_value___fread_unlocked_chk$1=__fread_unlocked_chk(__ptr, 18446744073709551615ul, __size, __n, __stream);
    return return_value___fread_unlocked_chk$1;
    if(__n * __size > 18446744073709551615ul)
    {
      return_value___fread_unlocked_chk_warn$2=__fread_unlocked_chk_warn(__ptr, 18446744073709551615ul, __size, __n, __stream);
      return return_value___fread_unlocked_chk_warn$2;
    }

  }

  signed int tmp_if_expr$5;
  signed int return_value___uflow$3;
  char *tmp_post$4;
  char *tmp_post$6;
  if(FALSE)
  {
    if(FALSE)
    {
      if((__n | __size) < 4294967296ul)
      {
        if(__n * __size <= 8ul)
        {
          unsigned long int __cnt = __size * __n;
          char *__cptr = (char *)__ptr;
          if(__cnt == 0ul)
            return (unsigned long int)0;

          while(__cnt > 0ul)
          {
            signed int __c;
            if(__stream->_IO_read_ptr >= __stream->_IO_read_end)
            {
              return_value___uflow$3=__uflow(__stream);
              tmp_if_expr$5 = return_value___uflow$3;
            }

            else
            {
              tmp_post$4 = __stream->_IO_read_ptr;
              __stream->_IO_read_ptr = __stream->_IO_read_ptr + 1l;
              tmp_if_expr$5 = (signed int)*((unsigned char *)tmp_post$4);
            }
            __c = tmp_if_expr$5;
            if(!(__c == -1))
              goto __CPROVER_DUMP_L8;

            goto __CPROVER_DUMP_L9;

          __CPROVER_DUMP_L8:
            ;
            tmp_post$6 = __cptr;
            __cptr = __cptr + 1l;
            *tmp_post$6 = (char)__c;
            __cnt = __cnt - 1ul;
          }

        __CPROVER_DUMP_L9:
          ;
          return (unsigned long int)(__cptr - (char *)__ptr) / __size;
        }

      }

    }

  }

  unsigned long int return_value___fread_unlocked_alias$7;
  return_value___fread_unlocked_alias$7=__fread_unlocked_alias(__ptr, __size, __n, __stream);
  return return_value___fread_unlocked_alias$7;
}

// c::free_light_special
// file ../src/light.h line 36
void free_light_special(void *voidlight)
{
  struct light_t$link272 *l = (struct light_t$link272 *)voidlight;
  if(l->shade_diffuse == (double (*)(struct light_t$link272 *, struct anon$19 *))directional_light_shade_diffuse)
    free((void *)l);

}

// c::free_objects
// file ../src/intersect.h line 9
void free_objects(struct anon$15 *start)
{
  struct anon$15 *cur;
  struct anon$15 *next;
  cur = start;
  while(!(cur == ((struct anon$15 *)NULL)))
  {
    next = (struct anon$15 *)cur->nextobj;
    cur->methods->freeobj((void *)cur);
    cur = next;
  }
}

// c::free_standard_texture
// file ../src/texture.c line 50
void free_standard_texture(void *voidtex)
{
  struct anon$35 *tex = (struct anon$35 *)voidtex;
  _Bool tmp_if_expr$1;
  _Bool tmp_if_expr$2;
  _Bool tmp_if_expr$3;
  if(!(tex->img == NULL))
  {
    if(tex->texfunc == (struct anon$4 (*)(const void *, const void *, void *))image_plane_texture)
      tmp_if_expr$1 = TRUE;

    else
      tmp_if_expr$1 = tex->texfunc == (struct anon$4 (*)(const void *, const void *, void *))image_cyl_texture ? TRUE : FALSE;
    if(tmp_if_expr$1)
      tmp_if_expr$2 = TRUE;

    else
      tmp_if_expr$2 = tex->texfunc == (struct anon$4 (*)(const void *, const void *, void *))image_sphere_texture ? TRUE : FALSE;
    if(tmp_if_expr$2)
      tmp_if_expr$3 = TRUE;

    else
      tmp_if_expr$3 = tex->texfunc == (struct anon$4 (*)(const void *, const void *, void *))image_volume_texture ? TRUE : FALSE;
    if(tmp_if_expr$3)
    {
      FreeMIPMap((struct anon$34 *)tex->img);
      tex->img = NULL;
    }

    else
      printf("XXX Doh, unrecognized image map type!\n");
  }

  free((void *)tex);
}

// c::free_tex_table
// file ../demosrc/parse.c line 66
static void free_tex_table(struct anon$6 *ph, void *scene)
{
  signed int i;
  rt_hash_destroy(&ph->texhash);
  i = 0;
  while(!(i >= ph->numtextures))
  {
    free((void *)(ph->textable + (signed long int)i)->name);
    i = i + 1;
  }
  free((void *)ph->textable);
  ph->textable = (struct anon$5 *)NULL;
  ph->numtextures = 0;
}

// c::freeoptions
// file ../demosrc/getargs.h line 41
void freeoptions(struct anon$1 *opt)
{
  if(!(opt->filenames == ((char **)NULL)))
  {
    signed int i = 0;
    while(!(i >= opt->numfiles))
    {
      if(!(opt->filenames[(signed long int)i] == ((char *)NULL)))
        free((void *)opt->filenames[(signed long int)i]);

      i = i + 1;
    }
    free((void *)opt->filenames);
  }

}

// c::fstat
// file /usr/include/x86_64-linux-gnu/sys/stat.h line 468
signed int fstat(signed int __fd, struct stat *__statbuf)
{
  signed int return_value___fxstat$1;
  return_value___fxstat$1=__fxstat(1, __fd, __statbuf);
  return return_value___fxstat$1;
}

// c::fstatat
// file /usr/include/x86_64-linux-gnu/sys/stat.h line 475
signed int fstatat(signed int __fd, const char *__filename, struct stat *__statbuf, signed int __flag)
{
  signed int return_value___fxstatat$1;
  return_value___fxstatat$1=__fxstatat(1, __fd, __filename, __statbuf, __flag);
  return return_value___fxstatat$1;
}

// c::full_shader
// file ../src/shade.h line 13
struct anon$4 full_shader(struct ray_t$link1 *incident)
{
  struct anon$4 col;
  struct anon$4 diffuse;
  struct anon$4 ambocccol;
  struct anon$4 phongcol;
  struct anon$19 shadevars;
  struct ray_t$link1 shadowray;
  double inten;
  double t = 1.000000e+18;
  const struct anon$15 *obj;
  signed int numints;
  struct list$link4 *cur;
  numints=closest_intersection(&t, &obj, incident);
  if(numints < 1)
  {
    col=incident->scene->bgtexfunc(incident);
    if(!(incident->scene->fog.fog_fctn == ((struct anon$4 (*)(struct fogdata_t$link3 *, struct anon$4, double))NULL)))
      col=fog_color(incident, col, t);

    return col;
  }

  shadevars.hit.x = incident->o.x + incident->d.x * t;
  shadevars.hit.y = incident->o.y + incident->d.y * t;
  shadevars.hit.z = incident->o.z + incident->d.z * t;
  incident->opticdist = incident->opticdist + t;
  obj->methods->normal((const void *)obj, (const void *)&shadevars.hit, (const void *)incident, (void *)&shadevars.N);
  col=obj->tex->texfunc((const void *)&shadevars.hit, (const void *)obj->tex, (void *)incident);
  if(!((2u & obj->tex->flags) == 0u))
    return col;

  diffuse.r = (float)0.000000;
  diffuse.g = (float)0.000000;
  diffuse.b = (float)0.000000;
  ambocccol = diffuse;
  phongcol = diffuse;
  _Bool tmp_if_expr$2;
  if((double)obj->tex->diffuse > 1.959000e-3)
    tmp_if_expr$2 = TRUE;

  else
    tmp_if_expr$2 = (double)obj->tex->phong > 1.959000e-3 ? TRUE : FALSE;
  if(tmp_if_expr$2)
  {
    double light_scale = incident->scene->light_scale;
    cur = incident->scene->lightlist;
    if(!((4096u & incident->scene->flags) == 0u))
      shadowray.add_intersection = add_clipped_shadow_intersection;

    else
      shadowray.add_intersection = add_shadow_intersection;
    shadowray.serial = incident->serial + (unsigned long int)1;
    shadowray.mbox = incident->mbox;
    shadowray.scene = incident->scene;
    while(!(cur == ((struct list$link4 *)NULL)))
    {
      struct light_t *li = (struct light_t *)cur->item;
      double return_value;
      return_value=li->shade_diffuse(li, &shadevars);
      inten = light_scale * return_value;
      if(inten > 1.959000e-3)
      {
        shadowray.o = shadevars.hit;
        shadowray.d = shadevars.L;
        shadowray.maxdist = shadevars.Llen;
        shadowray.flags = (unsigned int)4;
        shadowray.serial = shadowray.serial + 1ul;
        intersect_objects(&shadowray);
        signed int return_value_shadow_intersection$1;
        return_value_shadow_intersection$1=shadow_intersection(&shadowray);
        if(return_value_shadow_intersection$1 == 0)
        {
          inten = inten * shadowray.intstruct.shadowfilter;
          ColorAddS(&diffuse, &((struct anon$35 *)li->tex)->col, inten);
          if((double)obj->tex->phong > 1.959000e-3)
          {
            double phongval;
            double return_value_1;
            return_value_1=incident->scene->phongfunc(incident, &shadevars, (double)obj->tex->phongexp);
            phongval = light_scale * return_value_1;
            if(obj->tex->phongtype == 1)
              ColorAddS(&phongcol, &col, phongval * (double)obj->tex->phong);

            else
              ColorAddS(&phongcol, &((struct anon$35 *)li->tex)->col, phongval * (double)obj->tex->phong);
          }

        }

      }

      cur = cur->next;
    }
    incident->serial = shadowray.serial;
    if(incident->scene->ambocc.numsamples > 0)
      ambocccol=shade_ambient_occlusion(incident, &shadevars);

  }

  diffuse.r = diffuse.r + ambocccol.r;
  diffuse.g = diffuse.g + ambocccol.g;
  diffuse.b = diffuse.b + ambocccol.b;
  if(obj->tex->outline > 0.000000f)
  {
    double outlinefactor;
    double edgefactor;
    edgefactor=VDot(&shadevars.N, &incident->d);
    edgefactor = edgefactor * edgefactor;
    edgefactor = 1.000000 - edgefactor;
    double return_value_pow$3;
    return_value_pow$3=pow(edgefactor, (1.000000 - (double)obj->tex->outlinewidth) * 32.000000);
    edgefactor = 1.000000 - return_value_pow$3;
    outlinefactor = (1.000000 - (double)obj->tex->outline) + edgefactor * (double)obj->tex->outline;
    ColorScale(&diffuse, (double)obj->tex->diffuse * outlinefactor);
  }

  else
    ColorScale(&diffuse, (double)obj->tex->diffuse);
  col.r = col.r * (diffuse.r + obj->tex->ambient);
  col.g = col.g * (diffuse.g + obj->tex->ambient);
  col.b = col.b * (diffuse.b + obj->tex->ambient);
  if((double)obj->tex->phong > 1.959000e-3)
    ColorAccum(&col, &phongcol);

  if((double)obj->tex->specular > 1.959000e-3)
  {
    struct anon$4 specol;
    specol=shade_reflection(incident, &shadevars, (double)obj->tex->specular);
    ColorAccum(&col, &specol);
  }

  if((double)obj->tex->opacity < 9.980410e-1)
  {
    struct anon$4 transcol;
    transcol=shade_transmission(incident, &shadevars, 1.000000 - (double)obj->tex->opacity);
    if(incident->scene->transmode == 1)
      ColorScale(&col, (double)obj->tex->opacity);

    ColorAccum(&col, &transcol);
  }

  if(!(incident->scene->fog.fog_fctn == ((struct anon$4 (*)(struct fogdata_t$link3 *, struct anon$4, double))NULL)))
    col=fog_color(incident, col, t);

  return col;
}

// c::gamma
// file /usr/include/x86_64-linux-gnu/bits/math-finite.h line 289
double gamma(double __d)
{
  signed int __local_signgam = 0;
  double return_value_lgamma_r$1;
  return_value_lgamma_r$1=lgamma_r(__d, &__local_signgam);
  return return_value_lgamma_r$1;
}

// c::gamma_rgb96f
// file ../src/imageio.h line 24
void gamma_rgb96f(signed int xres, signed int yres, float *fimg, float gamma)
{
  float invgamma = (float)(1.000000 / (double)gamma);
  signed int i;
  signed int sz = xres * yres * 3;
  i = 0;
  double return_value_pow$1;
  while(!(i >= sz))
  {
    return_value_pow$1=pow((double)fimg[(signed long int)i], (double)invgamma);
    fimg[(signed long int)i] = (float)return_value_pow$1;
    i = i + 1;
  }
}

// c::gammaf
// file /usr/include/x86_64-linux-gnu/bits/math-finite.h line 298
float gammaf(float __d)
{
  signed int __local_signgam = 0;
  float return_value_lgammaf_r$1;
  return_value_lgammaf_r$1=lgammaf_r(__d, &__local_signgam);
  return return_value_lgammaf_r$1;
}

// c::gammal
// file /usr/include/x86_64-linux-gnu/bits/math-finite.h line 308
long double gammal(long double __d)
{
  signed int __local_signgam = 0;
  long double return_value_lgammal_r$1;
  return_value_lgammal_r$1=lgammal_r(__d, &__local_signgam);
  return return_value_lgammal_r$1;
}

// c::gen_triangles
// file ../demosrc/ac3dparse.c line 353
static void gen_triangles(void *scene, struct tri_list_t *tlist, struct anon$0 *vertex, struct anon$0 *normal)
{
  struct tri_list_t *cur = tlist;
  while(!(cur == ((struct tri_list_t *)NULL)))
  {
    if(!(cur->smooth == 0))
      rt_stri(scene, textable[(signed long int)cur->texnum].tex, vertex[(signed long int)cur->v0], vertex[(signed long int)cur->v1], vertex[(signed long int)cur->v2], normal[(signed long int)cur->v0], normal[(signed long int)cur->v1], normal[(signed long int)cur->v2]);

    else
      rt_tri(scene, textable[(signed long int)cur->texnum].tex, vertex[(signed long int)cur->v0], vertex[(signed long int)cur->v1], vertex[(signed long int)cur->v2]);
    cur = cur->next;
  }
}

// c::getargs
// file ../demosrc/getargs.h line 38
signed int getargs(signed int argc, char **argv, struct anon$1 *opt, signed int node)
{
  signed int i;
  signed int rc;
  if(opt == ((struct anon$1 *)NULL))
    return -1;

  if(argc < 2)
  {
    if(node == 0)
      printusage(argv);

    return -1;
  }

  initoptions(opt);
  i = 1;
  _Bool tmp_if_expr$4;
  while(!(i >= argc))
  {
    if((signed int)*argv[(signed long int)i] == 45)
      tmp_if_expr$4 = TRUE;

    else
      tmp_if_expr$4 = (signed int)argv[(signed long int)i][(signed long int)0] == 43 ? TRUE : FALSE;
    if(tmp_if_expr$4)
    {
      rc=getparm(argc, argv, i, opt, node);
      if(!(rc == -1))
        i = i + rc;

      else
      {
        if(node == 0)
          printusage(argv);

        return -1;
      }
    }

    else
    {
      void *return_value_realloc$1;
      return_value_realloc$1=realloc((void *)opt->filenames, 8ul /*[[char *]]*/ * (unsigned long int)(opt->numfiles + 10));
      opt->filenames = (char **)return_value_realloc$1;
      unsigned long int return_value_strlen$2;
      return_value_strlen$2=strlen(argv[(signed long int)i]);
      void *return_value_malloc$3;
      return_value_malloc$3=malloc(1ul /*[[char]]*/ * return_value_strlen$2 + (unsigned long int)1);
      opt->filenames[(signed long int)opt->numfiles] = (char *)return_value_malloc$3;
      strcpy(opt->filenames[(signed long int)opt->numfiles], argv[(signed long int)i]);
      opt->numfiles = opt->numfiles + 1;
      i = i + 1;
    }
  }
  if(opt->numfiles == 0)
  {
    if(node == 0)
    {
      printf("Missing model file name!\n");
      printusage(argv);
    }

    return -1;
  }

  return 0;
}

// c::getc_unlocked
// file /usr/include/x86_64-linux-gnu/bits/stdio.h line 63
signed int getc_unlocked(struct _IO_FILE *__fp)
{
  signed int tmp_if_expr$3;
  signed int return_value___uflow$1;
  char *tmp_post$2;
  if(__fp->_IO_read_ptr >= __fp->_IO_read_end)
  {
    return_value___uflow$1=__uflow(__fp);
    tmp_if_expr$3 = return_value___uflow$1;
  }

  else
  {
    tmp_post$2 = __fp->_IO_read_ptr;
    __fp->_IO_read_ptr = __fp->_IO_read_ptr + 1l;
    tmp_if_expr$3 = (signed int)*((unsigned char *)tmp_post$2);
  }
  return tmp_if_expr$3;
}

// c::getcameraposition
// file ../src/camera.h line 17
void getcameraposition(struct anon$14 *camera, struct anon$0 *center, struct anon$0 *viewvec, struct anon$0 *upvec, struct anon$0 *rightvec)
{
  *center = camera->center;
  *viewvec = camera->viewvec;
  *upvec = camera->upvec;
  *rightvec = camera->rightvec;
}

// c::getchar
// file /usr/include/x86_64-linux-gnu/bits/stdio.h line 44
signed int getchar(void)
{
  signed int return_value__IO_getc$1;
  return_value__IO_getc$1=_IO_getc(stdin);
  return return_value__IO_getc$1;
}

// c::getchar_unlocked
// file /usr/include/x86_64-linux-gnu/bits/stdio.h line 70
signed int getchar_unlocked(void)
{
  signed int tmp_if_expr$3;
  signed int return_value___uflow$1;
  char *tmp_post$2;
  if(stdin->_IO_read_ptr >= stdin->_IO_read_end)
  {
    return_value___uflow$1=__uflow(stdin);
    tmp_if_expr$3 = return_value___uflow$1;
  }

  else
  {
    tmp_post$2 = stdin->_IO_read_ptr;
    stdin->_IO_read_ptr = stdin->_IO_read_ptr + 1l;
    tmp_if_expr$3 = (signed int)*((unsigned char *)tmp_post$2);
  }
  return tmp_if_expr$3;
}

// c::getcwd
// file /usr/include/x86_64-linux-gnu/bits/unistd.h line 200
char * getcwd(char *__buf, unsigned long int __size)
{
  char *return_value___getcwd_chk$1;
  char *return_value___getcwd_chk_warn$2;
  char *return_value___getcwd_alias$3;
  return_value___getcwd_alias$3=__getcwd_alias(__buf, __size);
  return return_value___getcwd_alias$3;
}

// c::getdomainname
// file /usr/include/x86_64-linux-gnu/bits/unistd.h line 373
signed int getdomainname(char *__buf, unsigned long int __buflen)
{
  signed int return_value___getdomainname_chk$1;
  signed int return_value___getdomainname_chk_warn$2;
  signed int return_value___getdomainname_alias$3;
  return_value___getdomainname_alias$3=__getdomainname_alias(__buf, __buflen);
  return return_value___getdomainname_alias$3;
}

// c::getgroups
// file /usr/include/x86_64-linux-gnu/bits/unistd.h line 265
signed int getgroups(signed int __size, unsigned int *__list)
{
  signed int return_value___getgroups_chk$1;
  signed int return_value___getgroups_chk_warn$2;
  if(FALSE)
  {

  __CPROVER_DUMP_L1:
    ;
    return_value___getgroups_chk$1=__getgroups_chk(__size, __list, 18446744073709551615ul);
    return return_value___getgroups_chk$1;
    if(4ul /*[[unsigned int]]*/ * (unsigned long int)__size > 18446744073709551615ul)
    {
      return_value___getgroups_chk_warn$2=__getgroups_chk_warn(__size, __list, 18446744073709551615ul);
      return return_value___getgroups_chk_warn$2;
    }

  }

  signed int return_value___getgroups_alias$3;
  return_value___getgroups_alias$3=__getgroups_alias(__size, __list);
  return return_value___getgroups_alias$3;
}

// c::gethostname
// file /usr/include/x86_64-linux-gnu/bits/unistd.h line 344
signed int gethostname(char *__buf, unsigned long int __buflen)
{
  signed int return_value___gethostname_chk$1;
  signed int return_value___gethostname_chk_warn$2;
  signed int return_value___gethostname_alias$3;
  return_value___gethostname_alias$3=__gethostname_alias(__buf, __buflen);
  return return_value___gethostname_alias$3;
}

// c::getint
// file ../src/ppm.c line 18
static signed int getint(struct _IO_FILE$link40 *dfile)
{
  char ch[256l];
  signed int i;
  signed int num = 0;
  while(num == 0)
  {
    fscanf(dfile, "%s", (const void *)ch);
    while((signed int)ch[0l] == 35)
      fgets(ch, 256, dfile);
    num=sscanf(ch, "%d", &i);
  }
  return i;
}

// c::getlogin_r
// file /usr/include/x86_64-linux-gnu/bits/unistd.h line 317
signed int getlogin_r(char *__buf, unsigned long int __buflen)
{
  signed int return_value___getlogin_r_chk$1;
  signed int return_value___getlogin_r_chk_warn$2;
  signed int return_value___getlogin_r_alias$3;
  return_value___getlogin_r_alias$3=__getlogin_r_alias(__buf, __buflen);
  return return_value___getlogin_r_alias$3;
}

// c::getparm
// file ../demosrc/getargs.c line 327
static signed int getparm(signed int argc, char **argv, signed int num, struct anon$1 *opt, signed int node)
{
  signed int tmp_statement_expression$1;
  unsigned long int getparm$$1$$1$$__s1_len;
  unsigned long int getparm$$1$$1$$__s2_len;
  _Bool tmp_if_expr$3;
  unsigned int return_value___builtin_strlen$2;
  if(TRUE)
  {
    if(!((unsigned long int)("-o" + 1l) + -((unsigned long int)"-o") == 1ul))
      goto __CPROVER_DUMP_L1;

    return_value___builtin_strlen$2=__builtin_strlen("-o");
    getparm$$1$$1$$__s2_len = (unsigned long int)return_value___builtin_strlen$2;
    tmp_if_expr$3 = getparm$$1$$1$$__s2_len < (unsigned long int)4 ? TRUE : FALSE;
  }

  else
  {

  __CPROVER_DUMP_L1:
    ;
    tmp_if_expr$3 = FALSE;
  }
  signed int tmp_if_expr$6;
  signed int tmp_statement_expression$4;
  signed int return_value___builtin_strcmp$5;
  if(tmp_if_expr$3)
  {
    const unsigned char *getparm$$1$$1$$2$$__s1 = (const unsigned char *)(const char *)argv[(signed long int)num];
    signed int getparm$$1$$1$$2$$__result = (signed int)getparm$$1$$1$$2$$__s1[(signed long int)0] - (signed int)((const unsigned char *)(const char *)"-o")[(signed long int)0];
    if(getparm$$1$$1$$__s2_len > 0ul)
    {
      if(getparm$$1$$1$$2$$__result == 0)
      {
        getparm$$1$$1$$2$$__result = (signed int)getparm$$1$$1$$2$$__s1[(signed long int)1] - (signed int)((const unsigned char *)(const char *)"-o")[(signed long int)1];
        if(getparm$$1$$1$$__s2_len > 1ul)
        {
          if(getparm$$1$$1$$2$$__result == 0)
          {
            getparm$$1$$1$$2$$__result = (signed int)getparm$$1$$1$$2$$__s1[(signed long int)2] - (signed int)((const unsigned char *)(const char *)"-o")[(signed long int)2];
            if(getparm$$1$$1$$__s2_len > 2ul)
            {
              if(getparm$$1$$1$$2$$__result == 0)
                getparm$$1$$1$$2$$__result = (signed int)getparm$$1$$1$$2$$__s1[(signed long int)3] - (signed int)((const unsigned char *)(const char *)"-o")[(signed long int)3];

            }

          }

        }

      }

    }

    tmp_statement_expression$4 = getparm$$1$$1$$2$$__result;
    tmp_if_expr$6 = tmp_statement_expression$4;
  }

  else
  {
    return_value___builtin_strcmp$5=__builtin_strcmp(argv[(signed long int)num], "-o");
    tmp_if_expr$6 = return_value___builtin_strcmp$5;
  }
  tmp_statement_expression$1 = tmp_if_expr$6;
  if(tmp_statement_expression$1 == 0)
  {
    opt->useoutfilename = 1;
    sscanf(argv[(signed long int)(num + 1)], "%s", (char *)&opt->outfilename);
    return 2;
  }

  signed int tmp_statement_expression$7;
  unsigned long int getparm$$1$$3$$__s1_len;
  unsigned long int getparm$$1$$3$$__s2_len;
  _Bool tmp_if_expr$9;
  unsigned int return_value___builtin_strlen$8;
  if(TRUE)
  {
    if(!((unsigned long int)("-numthreads" + 1l) + -((unsigned long int)"-numthreads") == 1ul))
      goto __CPROVER_DUMP_L7;

    return_value___builtin_strlen$8=__builtin_strlen("-numthreads");
    getparm$$1$$3$$__s2_len = (unsigned long int)return_value___builtin_strlen$8;
    tmp_if_expr$9 = getparm$$1$$3$$__s2_len < (unsigned long int)4 ? TRUE : FALSE;
  }

  else
  {

  __CPROVER_DUMP_L7:
    ;
    tmp_if_expr$9 = FALSE;
  }
  signed int tmp_if_expr$12;
  signed int tmp_statement_expression$10;
  signed int return_value___builtin_strcmp$11;
  if(tmp_if_expr$9)
  {
    const unsigned char *getparm$$1$$3$$2$$__s1 = (const unsigned char *)(const char *)argv[(signed long int)num];
    signed int getparm$$1$$3$$2$$__result = (signed int)getparm$$1$$3$$2$$__s1[(signed long int)0] - (signed int)((const unsigned char *)(const char *)"-numthreads")[(signed long int)0];
    if(getparm$$1$$3$$__s2_len > 0ul)
    {
      if(getparm$$1$$3$$2$$__result == 0)
      {
        getparm$$1$$3$$2$$__result = (signed int)getparm$$1$$3$$2$$__s1[(signed long int)1] - (signed int)((const unsigned char *)(const char *)"-numthreads")[(signed long int)1];
        if(getparm$$1$$3$$__s2_len > 1ul)
        {
          if(getparm$$1$$3$$2$$__result == 0)
          {
            getparm$$1$$3$$2$$__result = (signed int)getparm$$1$$3$$2$$__s1[(signed long int)2] - (signed int)((const unsigned char *)(const char *)"-numthreads")[(signed long int)2];
            if(getparm$$1$$3$$__s2_len > 2ul)
            {
              if(getparm$$1$$3$$2$$__result == 0)
                getparm$$1$$3$$2$$__result = (signed int)getparm$$1$$3$$2$$__s1[(signed long int)3] - (signed int)((const unsigned char *)(const char *)"-numthreads")[(signed long int)3];

            }

          }

        }

      }

    }

    tmp_statement_expression$10 = getparm$$1$$3$$2$$__result;
    tmp_if_expr$12 = tmp_statement_expression$10;
  }

  else
  {
    return_value___builtin_strcmp$11=__builtin_strcmp(argv[(signed long int)num], "-numthreads");
    tmp_if_expr$12 = return_value___builtin_strcmp$11;
  }
  tmp_statement_expression$7 = tmp_if_expr$12;
  if(tmp_statement_expression$7 == 0)
  {
    sscanf(argv[(signed long int)(num + 1)], "%d", &opt->numthreads);
    return 2;
  }

  signed int tmp_statement_expression$13;
  unsigned long int getparm$$1$$5$$__s1_len;
  unsigned long int getparm$$1$$5$$__s2_len;
  _Bool tmp_if_expr$15;
  unsigned int return_value___builtin_strlen$14;
  if(TRUE)
  {
    if(!((unsigned long int)("-camfile" + 1l) + -((unsigned long int)"-camfile") == 1ul))
      goto __CPROVER_DUMP_L13;

    return_value___builtin_strlen$14=__builtin_strlen("-camfile");
    getparm$$1$$5$$__s2_len = (unsigned long int)return_value___builtin_strlen$14;
    tmp_if_expr$15 = getparm$$1$$5$$__s2_len < (unsigned long int)4 ? TRUE : FALSE;
  }

  else
  {

  __CPROVER_DUMP_L13:
    ;
    tmp_if_expr$15 = FALSE;
  }
  signed int tmp_if_expr$18;
  signed int tmp_statement_expression$16;
  signed int return_value___builtin_strcmp$17;
  if(tmp_if_expr$15)
  {
    const unsigned char *getparm$$1$$5$$2$$__s1 = (const unsigned char *)(const char *)argv[(signed long int)num];
    signed int getparm$$1$$5$$2$$__result = (signed int)getparm$$1$$5$$2$$__s1[(signed long int)0] - (signed int)((const unsigned char *)(const char *)"-camfile")[(signed long int)0];
    if(getparm$$1$$5$$__s2_len > 0ul)
    {
      if(getparm$$1$$5$$2$$__result == 0)
      {
        getparm$$1$$5$$2$$__result = (signed int)getparm$$1$$5$$2$$__s1[(signed long int)1] - (signed int)((const unsigned char *)(const char *)"-camfile")[(signed long int)1];
        if(getparm$$1$$5$$__s2_len > 1ul)
        {
          if(getparm$$1$$5$$2$$__result == 0)
          {
            getparm$$1$$5$$2$$__result = (signed int)getparm$$1$$5$$2$$__s1[(signed long int)2] - (signed int)((const unsigned char *)(const char *)"-camfile")[(signed long int)2];
            if(getparm$$1$$5$$__s2_len > 2ul)
            {
              if(getparm$$1$$5$$2$$__result == 0)
                getparm$$1$$5$$2$$__result = (signed int)getparm$$1$$5$$2$$__s1[(signed long int)3] - (signed int)((const unsigned char *)(const char *)"-camfile")[(signed long int)3];

            }

          }

        }

      }

    }

    tmp_statement_expression$16 = getparm$$1$$5$$2$$__result;
    tmp_if_expr$18 = tmp_statement_expression$16;
  }

  else
  {
    return_value___builtin_strcmp$17=__builtin_strcmp(argv[(signed long int)num], "-camfile");
    tmp_if_expr$18 = return_value___builtin_strcmp$17;
  }
  tmp_statement_expression$13 = tmp_if_expr$18;
  if(tmp_statement_expression$13 == 0)
  {
    opt->usecamfile = 1;
    sscanf(argv[(signed long int)(num + 1)], "%s", &opt->camfilename[(signed long int)0]);
    return 2;
  }

  signed int tmp_statement_expression$19;
  unsigned long int getparm$$1$$7$$__s1_len;
  unsigned long int getparm$$1$$7$$__s2_len;
  _Bool tmp_if_expr$21;
  unsigned int return_value___builtin_strlen$20;
  if(TRUE)
  {
    if(!((unsigned long int)("-nosave" + 1l) + -((unsigned long int)"-nosave") == 1ul))
      goto __CPROVER_DUMP_L19;

    return_value___builtin_strlen$20=__builtin_strlen("-nosave");
    getparm$$1$$7$$__s2_len = (unsigned long int)return_value___builtin_strlen$20;
    tmp_if_expr$21 = getparm$$1$$7$$__s2_len < (unsigned long int)4 ? TRUE : FALSE;
  }

  else
  {

  __CPROVER_DUMP_L19:
    ;
    tmp_if_expr$21 = FALSE;
  }
  signed int tmp_if_expr$24;
  signed int tmp_statement_expression$22;
  signed int return_value___builtin_strcmp$23;
  if(tmp_if_expr$21)
  {
    const unsigned char *getparm$$1$$7$$2$$__s1 = (const unsigned char *)(const char *)argv[(signed long int)num];
    signed int getparm$$1$$7$$2$$__result = (signed int)getparm$$1$$7$$2$$__s1[(signed long int)0] - (signed int)((const unsigned char *)(const char *)"-nosave")[(signed long int)0];
    if(getparm$$1$$7$$__s2_len > 0ul)
    {
      if(getparm$$1$$7$$2$$__result == 0)
      {
        getparm$$1$$7$$2$$__result = (signed int)getparm$$1$$7$$2$$__s1[(signed long int)1] - (signed int)((const unsigned char *)(const char *)"-nosave")[(signed long int)1];
        if(getparm$$1$$7$$__s2_len > 1ul)
        {
          if(getparm$$1$$7$$2$$__result == 0)
          {
            getparm$$1$$7$$2$$__result = (signed int)getparm$$1$$7$$2$$__s1[(signed long int)2] - (signed int)((const unsigned char *)(const char *)"-nosave")[(signed long int)2];
            if(getparm$$1$$7$$__s2_len > 2ul)
            {
              if(getparm$$1$$7$$2$$__result == 0)
                getparm$$1$$7$$2$$__result = (signed int)getparm$$1$$7$$2$$__s1[(signed long int)3] - (signed int)((const unsigned char *)(const char *)"-nosave")[(signed long int)3];

            }

          }

        }

      }

    }

    tmp_statement_expression$22 = getparm$$1$$7$$2$$__result;
    tmp_if_expr$24 = tmp_statement_expression$22;
  }

  else
  {
    return_value___builtin_strcmp$23=__builtin_strcmp(argv[(signed long int)num], "-nosave");
    tmp_if_expr$24 = return_value___builtin_strcmp$23;
  }
  tmp_statement_expression$19 = tmp_if_expr$24;
  if(tmp_statement_expression$19 == 0)
  {
    opt->nosave = 1;
    return 1;
  }

  signed int tmp_statement_expression$43;
  unsigned long int getparm$$1$$9$$__s1_len;
  unsigned long int getparm$$1$$9$$__s2_len;
  _Bool tmp_if_expr$45;
  unsigned int return_value___builtin_strlen$44;
  if(TRUE)
  {
    if(!((unsigned long int)("-normalfixup" + 1l) + -((unsigned long int)"-normalfixup") == 1ul))
      goto __CPROVER_DUMP_L25;

    return_value___builtin_strlen$44=__builtin_strlen("-normalfixup");
    getparm$$1$$9$$__s2_len = (unsigned long int)return_value___builtin_strlen$44;
    tmp_if_expr$45 = getparm$$1$$9$$__s2_len < (unsigned long int)4 ? TRUE : FALSE;
  }

  else
  {

  __CPROVER_DUMP_L25:
    ;
    tmp_if_expr$45 = FALSE;
  }
  signed int tmp_if_expr$48;
  signed int tmp_statement_expression$46;
  signed int return_value___builtin_strcmp$47;
  if(tmp_if_expr$45)
  {
    const unsigned char *getparm$$1$$9$$2$$__s1 = (const unsigned char *)(const char *)argv[(signed long int)num];
    signed int getparm$$1$$9$$2$$__result = (signed int)getparm$$1$$9$$2$$__s1[(signed long int)0] - (signed int)((const unsigned char *)(const char *)"-normalfixup")[(signed long int)0];
    if(getparm$$1$$9$$__s2_len > 0ul)
    {
      if(getparm$$1$$9$$2$$__result == 0)
      {
        getparm$$1$$9$$2$$__result = (signed int)getparm$$1$$9$$2$$__s1[(signed long int)1] - (signed int)((const unsigned char *)(const char *)"-normalfixup")[(signed long int)1];
        if(getparm$$1$$9$$__s2_len > 1ul)
        {
          if(getparm$$1$$9$$2$$__result == 0)
          {
            getparm$$1$$9$$2$$__result = (signed int)getparm$$1$$9$$2$$__s1[(signed long int)2] - (signed int)((const unsigned char *)(const char *)"-normalfixup")[(signed long int)2];
            if(getparm$$1$$9$$__s2_len > 2ul)
            {
              if(getparm$$1$$9$$2$$__result == 0)
                getparm$$1$$9$$2$$__result = (signed int)getparm$$1$$9$$2$$__s1[(signed long int)3] - (signed int)((const unsigned char *)(const char *)"-normalfixup")[(signed long int)3];

            }

          }

        }

      }

    }

    tmp_statement_expression$46 = getparm$$1$$9$$2$$__result;
    tmp_if_expr$48 = tmp_statement_expression$46;
  }

  else
  {
    return_value___builtin_strcmp$47=__builtin_strcmp(argv[(signed long int)num], "-normalfixup");
    tmp_if_expr$48 = return_value___builtin_strcmp$47;
  }
  tmp_statement_expression$43 = tmp_if_expr$48;
  signed int tmp_statement_expression$37;
  _Bool tmp_if_expr$39;
  unsigned int return_value___builtin_strlen$38;
  signed int tmp_if_expr$42;
  signed int tmp_statement_expression$40;
  signed int return_value___builtin_strcmp$41;
  signed int tmp_statement_expression$31;
  _Bool tmp_if_expr$33;
  unsigned int return_value___builtin_strlen$32;
  signed int tmp_if_expr$36;
  signed int tmp_statement_expression$34;
  signed int return_value___builtin_strcmp$35;
  signed int tmp_statement_expression$25;
  _Bool tmp_if_expr$27;
  unsigned int return_value___builtin_strlen$26;
  signed int tmp_if_expr$30;
  signed int tmp_statement_expression$28;
  signed int return_value___builtin_strcmp$29;
  if(tmp_statement_expression$43 == 0)
  {
    char tmp[1024l];
    sscanf(argv[(signed long int)(num + 1)], "%s", (const void *)tmp);
    unsigned long int getparm$$1$$10$$1$$__s1_len;
    unsigned long int getparm$$1$$10$$1$$__s2_len;
    if(TRUE)
    {
      if(!((unsigned long int)("off" + 1l) + -((unsigned long int)"off") == 1ul))
        goto __CPROVER_DUMP_L30;

      return_value___builtin_strlen$38=__builtin_strlen("off");
      getparm$$1$$10$$1$$__s2_len = (unsigned long int)return_value___builtin_strlen$38;
      tmp_if_expr$39 = getparm$$1$$10$$1$$__s2_len < (unsigned long int)4 ? TRUE : FALSE;
    }

    else
    {

    __CPROVER_DUMP_L30:
      ;
      tmp_if_expr$39 = FALSE;
    }
    if(tmp_if_expr$39)
    {
      const unsigned char *getparm$$1$$10$$1$$2$$__s1 = (const unsigned char *)(const char *)tmp;
      signed int getparm$$1$$10$$1$$2$$__result = (signed int)getparm$$1$$10$$1$$2$$__s1[(signed long int)0] - (signed int)((const unsigned char *)(const char *)"off")[(signed long int)0];
      if(getparm$$1$$10$$1$$__s2_len > 0ul)
      {
        if(getparm$$1$$10$$1$$2$$__result == 0)
        {
          getparm$$1$$10$$1$$2$$__result = (signed int)getparm$$1$$10$$1$$2$$__s1[(signed long int)1] - (signed int)((const unsigned char *)(const char *)"off")[(signed long int)1];
          if(getparm$$1$$10$$1$$__s2_len > 1ul)
          {
            if(getparm$$1$$10$$1$$2$$__result == 0)
            {
              getparm$$1$$10$$1$$2$$__result = (signed int)getparm$$1$$10$$1$$2$$__s1[(signed long int)2] - (signed int)((const unsigned char *)(const char *)"off")[(signed long int)2];
              if(getparm$$1$$10$$1$$__s2_len > 2ul)
              {
                if(getparm$$1$$10$$1$$2$$__result == 0)
                  getparm$$1$$10$$1$$2$$__result = (signed int)getparm$$1$$10$$1$$2$$__s1[(signed long int)3] - (signed int)((const unsigned char *)(const char *)"off")[(signed long int)3];

              }

            }

          }

        }

      }

      tmp_statement_expression$40 = getparm$$1$$10$$1$$2$$__result;
      tmp_if_expr$42 = tmp_statement_expression$40;
    }

    else
    {
      return_value___builtin_strcmp$41=__builtin_strcmp(tmp, "off");
      tmp_if_expr$42 = return_value___builtin_strcmp$41;
    }
    tmp_statement_expression$37 = tmp_if_expr$42;
    if(tmp_statement_expression$37 == 0)
      opt->normalfixupmode = 0;

    else
    {
      unsigned long int getparm$$1$$10$$3$$__s1_len;
      unsigned long int getparm$$1$$10$$3$$__s2_len;
      if(TRUE)
      {
        if(!((unsigned long int)("flip" + 1l) + -((unsigned long int)"flip") == 1ul))
          goto __CPROVER_DUMP_L36;

        return_value___builtin_strlen$32=__builtin_strlen("flip");
        getparm$$1$$10$$3$$__s2_len = (unsigned long int)return_value___builtin_strlen$32;
        tmp_if_expr$33 = getparm$$1$$10$$3$$__s2_len < (unsigned long int)4 ? TRUE : FALSE;
      }

      else
      {

      __CPROVER_DUMP_L36:
        ;
        tmp_if_expr$33 = FALSE;
      }
      if(tmp_if_expr$33)
      {
        const unsigned char *getparm$$1$$10$$3$$2$$__s1 = (const unsigned char *)(const char *)tmp;
        signed int getparm$$1$$10$$3$$2$$__result = (signed int)getparm$$1$$10$$3$$2$$__s1[(signed long int)0] - (signed int)((const unsigned char *)(const char *)"flip")[(signed long int)0];
        if(getparm$$1$$10$$3$$__s2_len > 0ul)
        {
          if(getparm$$1$$10$$3$$2$$__result == 0)
          {
            getparm$$1$$10$$3$$2$$__result = (signed int)getparm$$1$$10$$3$$2$$__s1[(signed long int)1] - (signed int)((const unsigned char *)(const char *)"flip")[(signed long int)1];
            if(getparm$$1$$10$$3$$__s2_len > 1ul)
            {
              if(getparm$$1$$10$$3$$2$$__result == 0)
              {
                getparm$$1$$10$$3$$2$$__result = (signed int)getparm$$1$$10$$3$$2$$__s1[(signed long int)2] - (signed int)((const unsigned char *)(const char *)"flip")[(signed long int)2];
                if(getparm$$1$$10$$3$$__s2_len > 2ul)
                {
                  if(getparm$$1$$10$$3$$2$$__result == 0)
                    getparm$$1$$10$$3$$2$$__result = (signed int)getparm$$1$$10$$3$$2$$__s1[(signed long int)3] - (signed int)((const unsigned char *)(const char *)"flip")[(signed long int)3];

                }

              }

            }

          }

        }

        tmp_statement_expression$34 = getparm$$1$$10$$3$$2$$__result;
        tmp_if_expr$36 = tmp_statement_expression$34;
      }

      else
      {
        return_value___builtin_strcmp$35=__builtin_strcmp(tmp, "flip");
        tmp_if_expr$36 = return_value___builtin_strcmp$35;
      }
      tmp_statement_expression$31 = tmp_if_expr$36;
      if(tmp_statement_expression$31 == 0)
        opt->normalfixupmode = 1;

      else
      {
        unsigned long int getparm$$1$$10$$5$$__s1_len;
        unsigned long int getparm$$1$$10$$5$$__s2_len;
        if(TRUE)
        {
          if(!((unsigned long int)("guess" + 1l) + -((unsigned long int)"guess") == 1ul))
            goto __CPROVER_DUMP_L42;

          return_value___builtin_strlen$26=__builtin_strlen("guess");
          getparm$$1$$10$$5$$__s2_len = (unsigned long int)return_value___builtin_strlen$26;
          tmp_if_expr$27 = getparm$$1$$10$$5$$__s2_len < (unsigned long int)4 ? TRUE : FALSE;
        }

        else
        {

        __CPROVER_DUMP_L42:
          ;
          tmp_if_expr$27 = FALSE;
        }
        if(tmp_if_expr$27)
        {
          const unsigned char *getparm$$1$$10$$5$$2$$__s1 = (const unsigned char *)(const char *)tmp;
          signed int getparm$$1$$10$$5$$2$$__result = (signed int)getparm$$1$$10$$5$$2$$__s1[(signed long int)0] - (signed int)((const unsigned char *)(const char *)"guess")[(signed long int)0];
          if(getparm$$1$$10$$5$$__s2_len > 0ul)
          {
            if(getparm$$1$$10$$5$$2$$__result == 0)
            {
              getparm$$1$$10$$5$$2$$__result = (signed int)getparm$$1$$10$$5$$2$$__s1[(signed long int)1] - (signed int)((const unsigned char *)(const char *)"guess")[(signed long int)1];
              if(getparm$$1$$10$$5$$__s2_len > 1ul)
              {
                if(getparm$$1$$10$$5$$2$$__result == 0)
                {
                  getparm$$1$$10$$5$$2$$__result = (signed int)getparm$$1$$10$$5$$2$$__s1[(signed long int)2] - (signed int)((const unsigned char *)(const char *)"guess")[(signed long int)2];
                  if(getparm$$1$$10$$5$$__s2_len > 2ul)
                  {
                    if(getparm$$1$$10$$5$$2$$__result == 0)
                      getparm$$1$$10$$5$$2$$__result = (signed int)getparm$$1$$10$$5$$2$$__s1[(signed long int)3] - (signed int)((const unsigned char *)(const char *)"guess")[(signed long int)3];

                  }

                }

              }

            }

          }

          tmp_statement_expression$28 = getparm$$1$$10$$5$$2$$__result;
          tmp_if_expr$30 = tmp_statement_expression$28;
        }

        else
        {
          return_value___builtin_strcmp$29=__builtin_strcmp(tmp, "guess");
          tmp_if_expr$30 = return_value___builtin_strcmp$29;
        }
        tmp_statement_expression$25 = tmp_if_expr$30;
        if(tmp_statement_expression$25 == 0)
          opt->normalfixupmode = 2;

      }
    }
    return 2;
  }

  signed int tmp_statement_expression$49;
  unsigned long int getparm$$1$$11$$__s1_len;
  unsigned long int getparm$$1$$11$$__s2_len;
  _Bool tmp_if_expr$51;
  unsigned int return_value___builtin_strlen$50;
  if(TRUE)
  {
    if(!((unsigned long int)("-aasamples" + 1l) + -((unsigned long int)"-aasamples") == 1ul))
      goto __CPROVER_DUMP_L49;

    return_value___builtin_strlen$50=__builtin_strlen("-aasamples");
    getparm$$1$$11$$__s2_len = (unsigned long int)return_value___builtin_strlen$50;
    tmp_if_expr$51 = getparm$$1$$11$$__s2_len < (unsigned long int)4 ? TRUE : FALSE;
  }

  else
  {

  __CPROVER_DUMP_L49:
    ;
    tmp_if_expr$51 = FALSE;
  }
  signed int tmp_if_expr$54;
  signed int tmp_statement_expression$52;
  signed int return_value___builtin_strcmp$53;
  if(tmp_if_expr$51)
  {
    const unsigned char *getparm$$1$$11$$2$$__s1 = (const unsigned char *)(const char *)argv[(signed long int)num];
    signed int getparm$$1$$11$$2$$__result = (signed int)getparm$$1$$11$$2$$__s1[(signed long int)0] - (signed int)((const unsigned char *)(const char *)"-aasamples")[(signed long int)0];
    if(getparm$$1$$11$$__s2_len > 0ul)
    {
      if(getparm$$1$$11$$2$$__result == 0)
      {
        getparm$$1$$11$$2$$__result = (signed int)getparm$$1$$11$$2$$__s1[(signed long int)1] - (signed int)((const unsigned char *)(const char *)"-aasamples")[(signed long int)1];
        if(getparm$$1$$11$$__s2_len > 1ul)
        {
          if(getparm$$1$$11$$2$$__result == 0)
          {
            getparm$$1$$11$$2$$__result = (signed int)getparm$$1$$11$$2$$__s1[(signed long int)2] - (signed int)((const unsigned char *)(const char *)"-aasamples")[(signed long int)2];
            if(getparm$$1$$11$$__s2_len > 2ul)
            {
              if(getparm$$1$$11$$2$$__result == 0)
                getparm$$1$$11$$2$$__result = (signed int)getparm$$1$$11$$2$$__s1[(signed long int)3] - (signed int)((const unsigned char *)(const char *)"-aasamples")[(signed long int)3];

            }

          }

        }

      }

    }

    tmp_statement_expression$52 = getparm$$1$$11$$2$$__result;
    tmp_if_expr$54 = tmp_statement_expression$52;
  }

  else
  {
    return_value___builtin_strcmp$53=__builtin_strcmp(argv[(signed long int)num], "-aasamples");
    tmp_if_expr$54 = return_value___builtin_strcmp$53;
  }
  tmp_statement_expression$49 = tmp_if_expr$54;
  if(tmp_statement_expression$49 == 0)
  {
    sscanf(argv[(signed long int)(num + 1)], "%d", &opt->aa_maxsamples);
    return 2;
  }

  signed int tmp_statement_expression$55;
  unsigned long int getparm$$1$$13$$__s1_len;
  unsigned long int getparm$$1$$13$$__s2_len;
  _Bool tmp_if_expr$57;
  unsigned int return_value___builtin_strlen$56;
  if(TRUE)
  {
    if(!((unsigned long int)("-V" + 1l) + -((unsigned long int)"-V") == 1ul))
      goto __CPROVER_DUMP_L55;

    return_value___builtin_strlen$56=__builtin_strlen("-V");
    getparm$$1$$13$$__s2_len = (unsigned long int)return_value___builtin_strlen$56;
    tmp_if_expr$57 = getparm$$1$$13$$__s2_len < (unsigned long int)4 ? TRUE : FALSE;
  }

  else
  {

  __CPROVER_DUMP_L55:
    ;
    tmp_if_expr$57 = FALSE;
  }
  signed int tmp_if_expr$60;
  signed int tmp_statement_expression$58;
  signed int return_value___builtin_strcmp$59;
  if(tmp_if_expr$57)
  {
    const unsigned char *getparm$$1$$13$$2$$__s1 = (const unsigned char *)(const char *)argv[(signed long int)num];
    signed int getparm$$1$$13$$2$$__result = (signed int)getparm$$1$$13$$2$$__s1[(signed long int)0] - (signed int)((const unsigned char *)(const char *)"-V")[(signed long int)0];
    if(getparm$$1$$13$$__s2_len > 0ul)
    {
      if(getparm$$1$$13$$2$$__result == 0)
      {
        getparm$$1$$13$$2$$__result = (signed int)getparm$$1$$13$$2$$__s1[(signed long int)1] - (signed int)((const unsigned char *)(const char *)"-V")[(signed long int)1];
        if(getparm$$1$$13$$__s2_len > 1ul)
        {
          if(getparm$$1$$13$$2$$__result == 0)
          {
            getparm$$1$$13$$2$$__result = (signed int)getparm$$1$$13$$2$$__s1[(signed long int)2] - (signed int)((const unsigned char *)(const char *)"-V")[(signed long int)2];
            if(getparm$$1$$13$$__s2_len > 2ul)
            {
              if(getparm$$1$$13$$2$$__result == 0)
                getparm$$1$$13$$2$$__result = (signed int)getparm$$1$$13$$2$$__s1[(signed long int)3] - (signed int)((const unsigned char *)(const char *)"-V")[(signed long int)3];

            }

          }

        }

      }

    }

    tmp_statement_expression$58 = getparm$$1$$13$$2$$__result;
    tmp_if_expr$60 = tmp_statement_expression$58;
  }

  else
  {
    return_value___builtin_strcmp$59=__builtin_strcmp(argv[(signed long int)num], "-V");
    tmp_if_expr$60 = return_value___builtin_strcmp$59;
  }
  tmp_statement_expression$55 = tmp_if_expr$60;
  if(tmp_statement_expression$55 == 0)
  {
    opt->verbosemode = 0;
    return 1;
  }

  signed int tmp_statement_expression$61;
  unsigned long int getparm$$1$$15$$__s1_len;
  unsigned long int getparm$$1$$15$$__s2_len;
  _Bool tmp_if_expr$63;
  unsigned int return_value___builtin_strlen$62;
  if(TRUE)
  {
    if(!((unsigned long int)("+V" + 1l) + -((unsigned long int)"+V") == 1ul))
      goto __CPROVER_DUMP_L61;

    return_value___builtin_strlen$62=__builtin_strlen("+V");
    getparm$$1$$15$$__s2_len = (unsigned long int)return_value___builtin_strlen$62;
    tmp_if_expr$63 = getparm$$1$$15$$__s2_len < (unsigned long int)4 ? TRUE : FALSE;
  }

  else
  {

  __CPROVER_DUMP_L61:
    ;
    tmp_if_expr$63 = FALSE;
  }
  signed int tmp_if_expr$66;
  signed int tmp_statement_expression$64;
  signed int return_value___builtin_strcmp$65;
  if(tmp_if_expr$63)
  {
    const unsigned char *getparm$$1$$15$$2$$__s1 = (const unsigned char *)(const char *)argv[(signed long int)num];
    signed int getparm$$1$$15$$2$$__result = (signed int)getparm$$1$$15$$2$$__s1[(signed long int)0] - (signed int)((const unsigned char *)(const char *)"+V")[(signed long int)0];
    if(getparm$$1$$15$$__s2_len > 0ul)
    {
      if(getparm$$1$$15$$2$$__result == 0)
      {
        getparm$$1$$15$$2$$__result = (signed int)getparm$$1$$15$$2$$__s1[(signed long int)1] - (signed int)((const unsigned char *)(const char *)"+V")[(signed long int)1];
        if(getparm$$1$$15$$__s2_len > 1ul)
        {
          if(getparm$$1$$15$$2$$__result == 0)
          {
            getparm$$1$$15$$2$$__result = (signed int)getparm$$1$$15$$2$$__s1[(signed long int)2] - (signed int)((const unsigned char *)(const char *)"+V")[(signed long int)2];
            if(getparm$$1$$15$$__s2_len > 2ul)
            {
              if(getparm$$1$$15$$2$$__result == 0)
                getparm$$1$$15$$2$$__result = (signed int)getparm$$1$$15$$2$$__s1[(signed long int)3] - (signed int)((const unsigned char *)(const char *)"+V")[(signed long int)3];

            }

          }

        }

      }

    }

    tmp_statement_expression$64 = getparm$$1$$15$$2$$__result;
    tmp_if_expr$66 = tmp_statement_expression$64;
  }

  else
  {
    return_value___builtin_strcmp$65=__builtin_strcmp(argv[(signed long int)num], "+V");
    tmp_if_expr$66 = return_value___builtin_strcmp$65;
  }
  tmp_statement_expression$61 = tmp_if_expr$66;
  if(tmp_statement_expression$61 == 0)
  {
    opt->verbosemode = 1;
    return 1;
  }

  signed int tmp_statement_expression$67;
  unsigned long int getparm$$1$$17$$__s1_len;
  unsigned long int getparm$$1$$17$$__s2_len;
  _Bool tmp_if_expr$69;
  unsigned int return_value___builtin_strlen$68;
  if(TRUE)
  {
    if(!((unsigned long int)("-nobounding" + 1l) + -((unsigned long int)"-nobounding") == 1ul))
      goto __CPROVER_DUMP_L67;

    return_value___builtin_strlen$68=__builtin_strlen("-nobounding");
    getparm$$1$$17$$__s2_len = (unsigned long int)return_value___builtin_strlen$68;
    tmp_if_expr$69 = getparm$$1$$17$$__s2_len < (unsigned long int)4 ? TRUE : FALSE;
  }

  else
  {

  __CPROVER_DUMP_L67:
    ;
    tmp_if_expr$69 = FALSE;
  }
  signed int tmp_if_expr$72;
  signed int tmp_statement_expression$70;
  signed int return_value___builtin_strcmp$71;
  if(tmp_if_expr$69)
  {
    const unsigned char *getparm$$1$$17$$2$$__s1 = (const unsigned char *)(const char *)argv[(signed long int)num];
    signed int getparm$$1$$17$$2$$__result = (signed int)getparm$$1$$17$$2$$__s1[(signed long int)0] - (signed int)((const unsigned char *)(const char *)"-nobounding")[(signed long int)0];
    if(getparm$$1$$17$$__s2_len > 0ul)
    {
      if(getparm$$1$$17$$2$$__result == 0)
      {
        getparm$$1$$17$$2$$__result = (signed int)getparm$$1$$17$$2$$__s1[(signed long int)1] - (signed int)((const unsigned char *)(const char *)"-nobounding")[(signed long int)1];
        if(getparm$$1$$17$$__s2_len > 1ul)
        {
          if(getparm$$1$$17$$2$$__result == 0)
          {
            getparm$$1$$17$$2$$__result = (signed int)getparm$$1$$17$$2$$__s1[(signed long int)2] - (signed int)((const unsigned char *)(const char *)"-nobounding")[(signed long int)2];
            if(getparm$$1$$17$$__s2_len > 2ul)
            {
              if(getparm$$1$$17$$2$$__result == 0)
                getparm$$1$$17$$2$$__result = (signed int)getparm$$1$$17$$2$$__s1[(signed long int)3] - (signed int)((const unsigned char *)(const char *)"-nobounding")[(signed long int)3];

            }

          }

        }

      }

    }

    tmp_statement_expression$70 = getparm$$1$$17$$2$$__result;
    tmp_if_expr$72 = tmp_statement_expression$70;
  }

  else
  {
    return_value___builtin_strcmp$71=__builtin_strcmp(argv[(signed long int)num], "-nobounding");
    tmp_if_expr$72 = return_value___builtin_strcmp$71;
  }
  tmp_statement_expression$67 = tmp_if_expr$72;
  if(tmp_statement_expression$67 == 0)
  {
    opt->boundmode = 0;
    return 1;
  }

  signed int tmp_statement_expression$73;
  unsigned long int getparm$$1$$19$$__s1_len;
  unsigned long int getparm$$1$$19$$__s2_len;
  _Bool tmp_if_expr$75;
  unsigned int return_value___builtin_strlen$74;
  if(TRUE)
  {
    if(!((unsigned long int)("-boundthresh" + 1l) + -((unsigned long int)"-boundthresh") == 1ul))
      goto __CPROVER_DUMP_L73;

    return_value___builtin_strlen$74=__builtin_strlen("-boundthresh");
    getparm$$1$$19$$__s2_len = (unsigned long int)return_value___builtin_strlen$74;
    tmp_if_expr$75 = getparm$$1$$19$$__s2_len < (unsigned long int)4 ? TRUE : FALSE;
  }

  else
  {

  __CPROVER_DUMP_L73:
    ;
    tmp_if_expr$75 = FALSE;
  }
  signed int tmp_if_expr$78;
  signed int tmp_statement_expression$76;
  signed int return_value___builtin_strcmp$77;
  if(tmp_if_expr$75)
  {
    const unsigned char *getparm$$1$$19$$2$$__s1 = (const unsigned char *)(const char *)argv[(signed long int)num];
    signed int getparm$$1$$19$$2$$__result = (signed int)getparm$$1$$19$$2$$__s1[(signed long int)0] - (signed int)((const unsigned char *)(const char *)"-boundthresh")[(signed long int)0];
    if(getparm$$1$$19$$__s2_len > 0ul)
    {
      if(getparm$$1$$19$$2$$__result == 0)
      {
        getparm$$1$$19$$2$$__result = (signed int)getparm$$1$$19$$2$$__s1[(signed long int)1] - (signed int)((const unsigned char *)(const char *)"-boundthresh")[(signed long int)1];
        if(getparm$$1$$19$$__s2_len > 1ul)
        {
          if(getparm$$1$$19$$2$$__result == 0)
          {
            getparm$$1$$19$$2$$__result = (signed int)getparm$$1$$19$$2$$__s1[(signed long int)2] - (signed int)((const unsigned char *)(const char *)"-boundthresh")[(signed long int)2];
            if(getparm$$1$$19$$__s2_len > 2ul)
            {
              if(getparm$$1$$19$$2$$__result == 0)
                getparm$$1$$19$$2$$__result = (signed int)getparm$$1$$19$$2$$__s1[(signed long int)3] - (signed int)((const unsigned char *)(const char *)"-boundthresh")[(signed long int)3];

            }

          }

        }

      }

    }

    tmp_statement_expression$76 = getparm$$1$$19$$2$$__result;
    tmp_if_expr$78 = tmp_statement_expression$76;
  }

  else
  {
    return_value___builtin_strcmp$77=__builtin_strcmp(argv[(signed long int)num], "-boundthresh");
    tmp_if_expr$78 = return_value___builtin_strcmp$77;
  }
  tmp_statement_expression$73 = tmp_if_expr$78;
  if(tmp_statement_expression$73 == 0)
  {
    sscanf(argv[(signed long int)(num + 1)], "%d", &opt->boundthresh);
    return 2;
  }

  signed int tmp_statement_expression$79;
  unsigned long int getparm$$1$$21$$__s1_len;
  unsigned long int getparm$$1$$21$$__s2_len;
  _Bool tmp_if_expr$81;
  unsigned int return_value___builtin_strlen$80;
  if(TRUE)
  {
    if(!((unsigned long int)("-fullshade" + 1l) + -((unsigned long int)"-fullshade") == 1ul))
      goto __CPROVER_DUMP_L79;

    return_value___builtin_strlen$80=__builtin_strlen("-fullshade");
    getparm$$1$$21$$__s2_len = (unsigned long int)return_value___builtin_strlen$80;
    tmp_if_expr$81 = getparm$$1$$21$$__s2_len < (unsigned long int)4 ? TRUE : FALSE;
  }

  else
  {

  __CPROVER_DUMP_L79:
    ;
    tmp_if_expr$81 = FALSE;
  }
  signed int tmp_if_expr$84;
  signed int tmp_statement_expression$82;
  signed int return_value___builtin_strcmp$83;
  if(tmp_if_expr$81)
  {
    const unsigned char *getparm$$1$$21$$2$$__s1 = (const unsigned char *)(const char *)argv[(signed long int)num];
    signed int getparm$$1$$21$$2$$__result = (signed int)getparm$$1$$21$$2$$__s1[(signed long int)0] - (signed int)((const unsigned char *)(const char *)"-fullshade")[(signed long int)0];
    if(getparm$$1$$21$$__s2_len > 0ul)
    {
      if(getparm$$1$$21$$2$$__result == 0)
      {
        getparm$$1$$21$$2$$__result = (signed int)getparm$$1$$21$$2$$__s1[(signed long int)1] - (signed int)((const unsigned char *)(const char *)"-fullshade")[(signed long int)1];
        if(getparm$$1$$21$$__s2_len > 1ul)
        {
          if(getparm$$1$$21$$2$$__result == 0)
          {
            getparm$$1$$21$$2$$__result = (signed int)getparm$$1$$21$$2$$__s1[(signed long int)2] - (signed int)((const unsigned char *)(const char *)"-fullshade")[(signed long int)2];
            if(getparm$$1$$21$$__s2_len > 2ul)
            {
              if(getparm$$1$$21$$2$$__result == 0)
                getparm$$1$$21$$2$$__result = (signed int)getparm$$1$$21$$2$$__s1[(signed long int)3] - (signed int)((const unsigned char *)(const char *)"-fullshade")[(signed long int)3];

            }

          }

        }

      }

    }

    tmp_statement_expression$82 = getparm$$1$$21$$2$$__result;
    tmp_if_expr$84 = tmp_statement_expression$82;
  }

  else
  {
    return_value___builtin_strcmp$83=__builtin_strcmp(argv[(signed long int)num], "-fullshade");
    tmp_if_expr$84 = return_value___builtin_strcmp$83;
  }
  tmp_statement_expression$79 = tmp_if_expr$84;
  if(tmp_statement_expression$79 == 0)
  {
    opt->shadermode = 5;
    return 1;
  }

  signed int tmp_statement_expression$85;
  unsigned long int getparm$$1$$23$$__s1_len;
  unsigned long int getparm$$1$$23$$__s2_len;
  _Bool tmp_if_expr$87;
  unsigned int return_value___builtin_strlen$86;
  if(TRUE)
  {
    if(!((unsigned long int)("-mediumshade" + 1l) + -((unsigned long int)"-mediumshade") == 1ul))
      goto __CPROVER_DUMP_L85;

    return_value___builtin_strlen$86=__builtin_strlen("-mediumshade");
    getparm$$1$$23$$__s2_len = (unsigned long int)return_value___builtin_strlen$86;
    tmp_if_expr$87 = getparm$$1$$23$$__s2_len < (unsigned long int)4 ? TRUE : FALSE;
  }

  else
  {

  __CPROVER_DUMP_L85:
    ;
    tmp_if_expr$87 = FALSE;
  }
  signed int tmp_if_expr$90;
  signed int tmp_statement_expression$88;
  signed int return_value___builtin_strcmp$89;
  if(tmp_if_expr$87)
  {
    const unsigned char *getparm$$1$$23$$2$$__s1 = (const unsigned char *)(const char *)argv[(signed long int)num];
    signed int getparm$$1$$23$$2$$__result = (signed int)getparm$$1$$23$$2$$__s1[(signed long int)0] - (signed int)((const unsigned char *)(const char *)"-mediumshade")[(signed long int)0];
    if(getparm$$1$$23$$__s2_len > 0ul)
    {
      if(getparm$$1$$23$$2$$__result == 0)
      {
        getparm$$1$$23$$2$$__result = (signed int)getparm$$1$$23$$2$$__s1[(signed long int)1] - (signed int)((const unsigned char *)(const char *)"-mediumshade")[(signed long int)1];
        if(getparm$$1$$23$$__s2_len > 1ul)
        {
          if(getparm$$1$$23$$2$$__result == 0)
          {
            getparm$$1$$23$$2$$__result = (signed int)getparm$$1$$23$$2$$__s1[(signed long int)2] - (signed int)((const unsigned char *)(const char *)"-mediumshade")[(signed long int)2];
            if(getparm$$1$$23$$__s2_len > 2ul)
            {
              if(getparm$$1$$23$$2$$__result == 0)
                getparm$$1$$23$$2$$__result = (signed int)getparm$$1$$23$$2$$__s1[(signed long int)3] - (signed int)((const unsigned char *)(const char *)"-mediumshade")[(signed long int)3];

            }

          }

        }

      }

    }

    tmp_statement_expression$88 = getparm$$1$$23$$2$$__result;
    tmp_if_expr$90 = tmp_statement_expression$88;
  }

  else
  {
    return_value___builtin_strcmp$89=__builtin_strcmp(argv[(signed long int)num], "-mediumshade");
    tmp_if_expr$90 = return_value___builtin_strcmp$89;
  }
  tmp_statement_expression$85 = tmp_if_expr$90;
  if(tmp_statement_expression$85 == 0)
  {
    opt->shadermode = 3;
    return 1;
  }

  signed int tmp_statement_expression$91;
  unsigned long int getparm$$1$$25$$__s1_len;
  unsigned long int getparm$$1$$25$$__s2_len;
  _Bool tmp_if_expr$93;
  unsigned int return_value___builtin_strlen$92;
  if(TRUE)
  {
    if(!((unsigned long int)("-lowshade" + 1l) + -((unsigned long int)"-lowshade") == 1ul))
      goto __CPROVER_DUMP_L91;

    return_value___builtin_strlen$92=__builtin_strlen("-lowshade");
    getparm$$1$$25$$__s2_len = (unsigned long int)return_value___builtin_strlen$92;
    tmp_if_expr$93 = getparm$$1$$25$$__s2_len < (unsigned long int)4 ? TRUE : FALSE;
  }

  else
  {

  __CPROVER_DUMP_L91:
    ;
    tmp_if_expr$93 = FALSE;
  }
  signed int tmp_if_expr$96;
  signed int tmp_statement_expression$94;
  signed int return_value___builtin_strcmp$95;
  if(tmp_if_expr$93)
  {
    const unsigned char *getparm$$1$$25$$2$$__s1 = (const unsigned char *)(const char *)argv[(signed long int)num];
    signed int getparm$$1$$25$$2$$__result = (signed int)getparm$$1$$25$$2$$__s1[(signed long int)0] - (signed int)((const unsigned char *)(const char *)"-lowshade")[(signed long int)0];
    if(getparm$$1$$25$$__s2_len > 0ul)
    {
      if(getparm$$1$$25$$2$$__result == 0)
      {
        getparm$$1$$25$$2$$__result = (signed int)getparm$$1$$25$$2$$__s1[(signed long int)1] - (signed int)((const unsigned char *)(const char *)"-lowshade")[(signed long int)1];
        if(getparm$$1$$25$$__s2_len > 1ul)
        {
          if(getparm$$1$$25$$2$$__result == 0)
          {
            getparm$$1$$25$$2$$__result = (signed int)getparm$$1$$25$$2$$__s1[(signed long int)2] - (signed int)((const unsigned char *)(const char *)"-lowshade")[(signed long int)2];
            if(getparm$$1$$25$$__s2_len > 2ul)
            {
              if(getparm$$1$$25$$2$$__result == 0)
                getparm$$1$$25$$2$$__result = (signed int)getparm$$1$$25$$2$$__s1[(signed long int)3] - (signed int)((const unsigned char *)(const char *)"-lowshade")[(signed long int)3];

            }

          }

        }

      }

    }

    tmp_statement_expression$94 = getparm$$1$$25$$2$$__result;
    tmp_if_expr$96 = tmp_statement_expression$94;
  }

  else
  {
    return_value___builtin_strcmp$95=__builtin_strcmp(argv[(signed long int)num], "-lowshade");
    tmp_if_expr$96 = return_value___builtin_strcmp$95;
  }
  tmp_statement_expression$91 = tmp_if_expr$96;
  if(tmp_statement_expression$91 == 0)
  {
    opt->shadermode = 2;
    return 1;
  }

  signed int tmp_statement_expression$97;
  unsigned long int getparm$$1$$27$$__s1_len;
  unsigned long int getparm$$1$$27$$__s2_len;
  _Bool tmp_if_expr$99;
  unsigned int return_value___builtin_strlen$98;
  if(TRUE)
  {
    if(!((unsigned long int)("-lowestshade" + 1l) + -((unsigned long int)"-lowestshade") == 1ul))
      goto __CPROVER_DUMP_L97;

    return_value___builtin_strlen$98=__builtin_strlen("-lowestshade");
    getparm$$1$$27$$__s2_len = (unsigned long int)return_value___builtin_strlen$98;
    tmp_if_expr$99 = getparm$$1$$27$$__s2_len < (unsigned long int)4 ? TRUE : FALSE;
  }

  else
  {

  __CPROVER_DUMP_L97:
    ;
    tmp_if_expr$99 = FALSE;
  }
  signed int tmp_if_expr$102;
  signed int tmp_statement_expression$100;
  signed int return_value___builtin_strcmp$101;
  if(tmp_if_expr$99)
  {
    const unsigned char *getparm$$1$$27$$2$$__s1 = (const unsigned char *)(const char *)argv[(signed long int)num];
    signed int getparm$$1$$27$$2$$__result = (signed int)getparm$$1$$27$$2$$__s1[(signed long int)0] - (signed int)((const unsigned char *)(const char *)"-lowestshade")[(signed long int)0];
    if(getparm$$1$$27$$__s2_len > 0ul)
    {
      if(getparm$$1$$27$$2$$__result == 0)
      {
        getparm$$1$$27$$2$$__result = (signed int)getparm$$1$$27$$2$$__s1[(signed long int)1] - (signed int)((const unsigned char *)(const char *)"-lowestshade")[(signed long int)1];
        if(getparm$$1$$27$$__s2_len > 1ul)
        {
          if(getparm$$1$$27$$2$$__result == 0)
          {
            getparm$$1$$27$$2$$__result = (signed int)getparm$$1$$27$$2$$__s1[(signed long int)2] - (signed int)((const unsigned char *)(const char *)"-lowestshade")[(signed long int)2];
            if(getparm$$1$$27$$__s2_len > 2ul)
            {
              if(getparm$$1$$27$$2$$__result == 0)
                getparm$$1$$27$$2$$__result = (signed int)getparm$$1$$27$$2$$__s1[(signed long int)3] - (signed int)((const unsigned char *)(const char *)"-lowestshade")[(signed long int)3];

            }

          }

        }

      }

    }

    tmp_statement_expression$100 = getparm$$1$$27$$2$$__result;
    tmp_if_expr$102 = tmp_statement_expression$100;
  }

  else
  {
    return_value___builtin_strcmp$101=__builtin_strcmp(argv[(signed long int)num], "-lowestshade");
    tmp_if_expr$102 = return_value___builtin_strcmp$101;
  }
  tmp_statement_expression$97 = tmp_if_expr$102;
  if(tmp_statement_expression$97 == 0)
  {
    opt->shadermode = 1;
    return 1;
  }

  signed int tmp_statement_expression$103;
  unsigned long int getparm$$1$$29$$__s1_len;
  unsigned long int getparm$$1$$29$$__s2_len;
  _Bool tmp_if_expr$105;
  unsigned int return_value___builtin_strlen$104;
  if(TRUE)
  {
    if(!((unsigned long int)("-rescale_lights" + 1l) + -((unsigned long int)"-rescale_lights") == 1ul))
      goto __CPROVER_DUMP_L103;

    return_value___builtin_strlen$104=__builtin_strlen("-rescale_lights");
    getparm$$1$$29$$__s2_len = (unsigned long int)return_value___builtin_strlen$104;
    tmp_if_expr$105 = getparm$$1$$29$$__s2_len < (unsigned long int)4 ? TRUE : FALSE;
  }

  else
  {

  __CPROVER_DUMP_L103:
    ;
    tmp_if_expr$105 = FALSE;
  }
  signed int tmp_if_expr$108;
  signed int tmp_statement_expression$106;
  signed int return_value___builtin_strcmp$107;
  if(tmp_if_expr$105)
  {
    const unsigned char *getparm$$1$$29$$2$$__s1 = (const unsigned char *)(const char *)argv[(signed long int)num];
    signed int getparm$$1$$29$$2$$__result = (signed int)getparm$$1$$29$$2$$__s1[(signed long int)0] - (signed int)((const unsigned char *)(const char *)"-rescale_lights")[(signed long int)0];
    if(getparm$$1$$29$$__s2_len > 0ul)
    {
      if(getparm$$1$$29$$2$$__result == 0)
      {
        getparm$$1$$29$$2$$__result = (signed int)getparm$$1$$29$$2$$__s1[(signed long int)1] - (signed int)((const unsigned char *)(const char *)"-rescale_lights")[(signed long int)1];
        if(getparm$$1$$29$$__s2_len > 1ul)
        {
          if(getparm$$1$$29$$2$$__result == 0)
          {
            getparm$$1$$29$$2$$__result = (signed int)getparm$$1$$29$$2$$__s1[(signed long int)2] - (signed int)((const unsigned char *)(const char *)"-rescale_lights")[(signed long int)2];
            if(getparm$$1$$29$$__s2_len > 2ul)
            {
              if(getparm$$1$$29$$2$$__result == 0)
                getparm$$1$$29$$2$$__result = (signed int)getparm$$1$$29$$2$$__s1[(signed long int)3] - (signed int)((const unsigned char *)(const char *)"-rescale_lights")[(signed long int)3];

            }

          }

        }

      }

    }

    tmp_statement_expression$106 = getparm$$1$$29$$2$$__result;
    tmp_if_expr$108 = tmp_statement_expression$106;
  }

  else
  {
    return_value___builtin_strcmp$107=__builtin_strcmp(argv[(signed long int)num], "-rescale_lights");
    tmp_if_expr$108 = return_value___builtin_strcmp$107;
  }
  tmp_statement_expression$103 = tmp_if_expr$108;
  if(tmp_statement_expression$103 == 0)
  {
    sscanf(argv[(signed long int)(num + 1)], "%f", &opt->rescale_lights);
    return 2;
  }

  signed int tmp_statement_expression$109;
  unsigned long int getparm$$1$$31$$__s1_len;
  unsigned long int getparm$$1$$31$$__s2_len;
  _Bool tmp_if_expr$111;
  unsigned int return_value___builtin_strlen$110;
  if(TRUE)
  {
    if(!((unsigned long int)("-auto_skylight" + 1l) + -((unsigned long int)"-auto_skylight") == 1ul))
      goto __CPROVER_DUMP_L109;

    return_value___builtin_strlen$110=__builtin_strlen("-auto_skylight");
    getparm$$1$$31$$__s2_len = (unsigned long int)return_value___builtin_strlen$110;
    tmp_if_expr$111 = getparm$$1$$31$$__s2_len < (unsigned long int)4 ? TRUE : FALSE;
  }

  else
  {

  __CPROVER_DUMP_L109:
    ;
    tmp_if_expr$111 = FALSE;
  }
  signed int tmp_if_expr$114;
  signed int tmp_statement_expression$112;
  signed int return_value___builtin_strcmp$113;
  if(tmp_if_expr$111)
  {
    const unsigned char *getparm$$1$$31$$2$$__s1 = (const unsigned char *)(const char *)argv[(signed long int)num];
    signed int getparm$$1$$31$$2$$__result = (signed int)getparm$$1$$31$$2$$__s1[(signed long int)0] - (signed int)((const unsigned char *)(const char *)"-auto_skylight")[(signed long int)0];
    if(getparm$$1$$31$$__s2_len > 0ul)
    {
      if(getparm$$1$$31$$2$$__result == 0)
      {
        getparm$$1$$31$$2$$__result = (signed int)getparm$$1$$31$$2$$__s1[(signed long int)1] - (signed int)((const unsigned char *)(const char *)"-auto_skylight")[(signed long int)1];
        if(getparm$$1$$31$$__s2_len > 1ul)
        {
          if(getparm$$1$$31$$2$$__result == 0)
          {
            getparm$$1$$31$$2$$__result = (signed int)getparm$$1$$31$$2$$__s1[(signed long int)2] - (signed int)((const unsigned char *)(const char *)"-auto_skylight")[(signed long int)2];
            if(getparm$$1$$31$$__s2_len > 2ul)
            {
              if(getparm$$1$$31$$2$$__result == 0)
                getparm$$1$$31$$2$$__result = (signed int)getparm$$1$$31$$2$$__s1[(signed long int)3] - (signed int)((const unsigned char *)(const char *)"-auto_skylight")[(signed long int)3];

            }

          }

        }

      }

    }

    tmp_statement_expression$112 = getparm$$1$$31$$2$$__result;
    tmp_if_expr$114 = tmp_statement_expression$112;
  }

  else
  {
    return_value___builtin_strcmp$113=__builtin_strcmp(argv[(signed long int)num], "-auto_skylight");
    tmp_if_expr$114 = return_value___builtin_strcmp$113;
  }
  tmp_statement_expression$109 = tmp_if_expr$114;
  if(tmp_statement_expression$109 == 0)
  {
    sscanf(argv[(signed long int)(num + 1)], "%f", &opt->auto_skylight);
    return 2;
  }

  signed int tmp_statement_expression$115;
  unsigned long int getparm$$1$$33$$__s1_len;
  unsigned long int getparm$$1$$33$$__s2_len;
  _Bool tmp_if_expr$117;
  unsigned int return_value___builtin_strlen$116;
  if(TRUE)
  {
    if(!((unsigned long int)("-add_skylight" + 1l) + -((unsigned long int)"-add_skylight") == 1ul))
      goto __CPROVER_DUMP_L115;

    return_value___builtin_strlen$116=__builtin_strlen("-add_skylight");
    getparm$$1$$33$$__s2_len = (unsigned long int)return_value___builtin_strlen$116;
    tmp_if_expr$117 = getparm$$1$$33$$__s2_len < (unsigned long int)4 ? TRUE : FALSE;
  }

  else
  {

  __CPROVER_DUMP_L115:
    ;
    tmp_if_expr$117 = FALSE;
  }
  signed int tmp_if_expr$120;
  signed int tmp_statement_expression$118;
  signed int return_value___builtin_strcmp$119;
  if(tmp_if_expr$117)
  {
    const unsigned char *getparm$$1$$33$$2$$__s1 = (const unsigned char *)(const char *)argv[(signed long int)num];
    signed int getparm$$1$$33$$2$$__result = (signed int)getparm$$1$$33$$2$$__s1[(signed long int)0] - (signed int)((const unsigned char *)(const char *)"-add_skylight")[(signed long int)0];
    if(getparm$$1$$33$$__s2_len > 0ul)
    {
      if(getparm$$1$$33$$2$$__result == 0)
      {
        getparm$$1$$33$$2$$__result = (signed int)getparm$$1$$33$$2$$__s1[(signed long int)1] - (signed int)((const unsigned char *)(const char *)"-add_skylight")[(signed long int)1];
        if(getparm$$1$$33$$__s2_len > 1ul)
        {
          if(getparm$$1$$33$$2$$__result == 0)
          {
            getparm$$1$$33$$2$$__result = (signed int)getparm$$1$$33$$2$$__s1[(signed long int)2] - (signed int)((const unsigned char *)(const char *)"-add_skylight")[(signed long int)2];
            if(getparm$$1$$33$$__s2_len > 2ul)
            {
              if(getparm$$1$$33$$2$$__result == 0)
                getparm$$1$$33$$2$$__result = (signed int)getparm$$1$$33$$2$$__s1[(signed long int)3] - (signed int)((const unsigned char *)(const char *)"-add_skylight")[(signed long int)3];

            }

          }

        }

      }

    }

    tmp_statement_expression$118 = getparm$$1$$33$$2$$__result;
    tmp_if_expr$120 = tmp_statement_expression$118;
  }

  else
  {
    return_value___builtin_strcmp$119=__builtin_strcmp(argv[(signed long int)num], "-add_skylight");
    tmp_if_expr$120 = return_value___builtin_strcmp$119;
  }
  tmp_statement_expression$115 = tmp_if_expr$120;
  if(tmp_statement_expression$115 == 0)
  {
    sscanf(argv[(signed long int)(num + 1)], "%f", &opt->add_skylight);
    return 2;
  }

  signed int tmp_statement_expression$121;
  unsigned long int getparm$$1$$35$$__s1_len;
  unsigned long int getparm$$1$$35$$__s2_len;
  _Bool tmp_if_expr$123;
  unsigned int return_value___builtin_strlen$122;
  if(TRUE)
  {
    if(!((unsigned long int)("-skylight_samples" + 1l) + -((unsigned long int)"-skylight_samples") == 1ul))
      goto __CPROVER_DUMP_L121;

    return_value___builtin_strlen$122=__builtin_strlen("-skylight_samples");
    getparm$$1$$35$$__s2_len = (unsigned long int)return_value___builtin_strlen$122;
    tmp_if_expr$123 = getparm$$1$$35$$__s2_len < (unsigned long int)4 ? TRUE : FALSE;
  }

  else
  {

  __CPROVER_DUMP_L121:
    ;
    tmp_if_expr$123 = FALSE;
  }
  signed int tmp_if_expr$126;
  signed int tmp_statement_expression$124;
  signed int return_value___builtin_strcmp$125;
  if(tmp_if_expr$123)
  {
    const unsigned char *getparm$$1$$35$$2$$__s1 = (const unsigned char *)(const char *)argv[(signed long int)num];
    signed int getparm$$1$$35$$2$$__result = (signed int)getparm$$1$$35$$2$$__s1[(signed long int)0] - (signed int)((const unsigned char *)(const char *)"-skylight_samples")[(signed long int)0];
    if(getparm$$1$$35$$__s2_len > 0ul)
    {
      if(getparm$$1$$35$$2$$__result == 0)
      {
        getparm$$1$$35$$2$$__result = (signed int)getparm$$1$$35$$2$$__s1[(signed long int)1] - (signed int)((const unsigned char *)(const char *)"-skylight_samples")[(signed long int)1];
        if(getparm$$1$$35$$__s2_len > 1ul)
        {
          if(getparm$$1$$35$$2$$__result == 0)
          {
            getparm$$1$$35$$2$$__result = (signed int)getparm$$1$$35$$2$$__s1[(signed long int)2] - (signed int)((const unsigned char *)(const char *)"-skylight_samples")[(signed long int)2];
            if(getparm$$1$$35$$__s2_len > 2ul)
            {
              if(getparm$$1$$35$$2$$__result == 0)
                getparm$$1$$35$$2$$__result = (signed int)getparm$$1$$35$$2$$__s1[(signed long int)3] - (signed int)((const unsigned char *)(const char *)"-skylight_samples")[(signed long int)3];

            }

          }

        }

      }

    }

    tmp_statement_expression$124 = getparm$$1$$35$$2$$__result;
    tmp_if_expr$126 = tmp_statement_expression$124;
  }

  else
  {
    return_value___builtin_strcmp$125=__builtin_strcmp(argv[(signed long int)num], "-skylight_samples");
    tmp_if_expr$126 = return_value___builtin_strcmp$125;
  }
  tmp_statement_expression$121 = tmp_if_expr$126;
  if(tmp_statement_expression$121 == 0)
  {
    sscanf(argv[(signed long int)(num + 1)], "%d", &opt->skylight_samples);
    return 2;
  }

  signed int tmp_statement_expression$127;
  unsigned long int getparm$$1$$37$$__s1_len;
  unsigned long int getparm$$1$$37$$__s2_len;
  _Bool tmp_if_expr$129;
  unsigned int return_value___builtin_strlen$128;
  if(TRUE)
  {
    if(!((unsigned long int)("-shade_phong" + 1l) + -((unsigned long int)"-shade_phong") == 1ul))
      goto __CPROVER_DUMP_L127;

    return_value___builtin_strlen$128=__builtin_strlen("-shade_phong");
    getparm$$1$$37$$__s2_len = (unsigned long int)return_value___builtin_strlen$128;
    tmp_if_expr$129 = getparm$$1$$37$$__s2_len < (unsigned long int)4 ? TRUE : FALSE;
  }

  else
  {

  __CPROVER_DUMP_L127:
    ;
    tmp_if_expr$129 = FALSE;
  }
  signed int tmp_if_expr$132;
  signed int tmp_statement_expression$130;
  signed int return_value___builtin_strcmp$131;
  if(tmp_if_expr$129)
  {
    const unsigned char *getparm$$1$$37$$2$$__s1 = (const unsigned char *)(const char *)argv[(signed long int)num];
    signed int getparm$$1$$37$$2$$__result = (signed int)getparm$$1$$37$$2$$__s1[(signed long int)0] - (signed int)((const unsigned char *)(const char *)"-shade_phong")[(signed long int)0];
    if(getparm$$1$$37$$__s2_len > 0ul)
    {
      if(getparm$$1$$37$$2$$__result == 0)
      {
        getparm$$1$$37$$2$$__result = (signed int)getparm$$1$$37$$2$$__s1[(signed long int)1] - (signed int)((const unsigned char *)(const char *)"-shade_phong")[(signed long int)1];
        if(getparm$$1$$37$$__s2_len > 1ul)
        {
          if(getparm$$1$$37$$2$$__result == 0)
          {
            getparm$$1$$37$$2$$__result = (signed int)getparm$$1$$37$$2$$__s1[(signed long int)2] - (signed int)((const unsigned char *)(const char *)"-shade_phong")[(signed long int)2];
            if(getparm$$1$$37$$__s2_len > 2ul)
            {
              if(getparm$$1$$37$$2$$__result == 0)
                getparm$$1$$37$$2$$__result = (signed int)getparm$$1$$37$$2$$__s1[(signed long int)3] - (signed int)((const unsigned char *)(const char *)"-shade_phong")[(signed long int)3];

            }

          }

        }

      }

    }

    tmp_statement_expression$130 = getparm$$1$$37$$2$$__result;
    tmp_if_expr$132 = tmp_statement_expression$130;
  }

  else
  {
    return_value___builtin_strcmp$131=__builtin_strcmp(argv[(signed long int)num], "-shade_phong");
    tmp_if_expr$132 = return_value___builtin_strcmp$131;
  }
  tmp_statement_expression$127 = tmp_if_expr$132;
  if(tmp_statement_expression$127 == 0)
  {
    opt->phongfunc = 3;
    return 1;
  }

  signed int tmp_statement_expression$133;
  unsigned long int getparm$$1$$39$$__s1_len;
  unsigned long int getparm$$1$$39$$__s2_len;
  _Bool tmp_if_expr$135;
  unsigned int return_value___builtin_strlen$134;
  if(TRUE)
  {
    if(!((unsigned long int)("-shade_blinn" + 1l) + -((unsigned long int)"-shade_blinn") == 1ul))
      goto __CPROVER_DUMP_L133;

    return_value___builtin_strlen$134=__builtin_strlen("-shade_blinn");
    getparm$$1$$39$$__s2_len = (unsigned long int)return_value___builtin_strlen$134;
    tmp_if_expr$135 = getparm$$1$$39$$__s2_len < (unsigned long int)4 ? TRUE : FALSE;
  }

  else
  {

  __CPROVER_DUMP_L133:
    ;
    tmp_if_expr$135 = FALSE;
  }
  signed int tmp_if_expr$138;
  signed int tmp_statement_expression$136;
  signed int return_value___builtin_strcmp$137;
  if(tmp_if_expr$135)
  {
    const unsigned char *getparm$$1$$39$$2$$__s1 = (const unsigned char *)(const char *)argv[(signed long int)num];
    signed int getparm$$1$$39$$2$$__result = (signed int)getparm$$1$$39$$2$$__s1[(signed long int)0] - (signed int)((const unsigned char *)(const char *)"-shade_blinn")[(signed long int)0];
    if(getparm$$1$$39$$__s2_len > 0ul)
    {
      if(getparm$$1$$39$$2$$__result == 0)
      {
        getparm$$1$$39$$2$$__result = (signed int)getparm$$1$$39$$2$$__s1[(signed long int)1] - (signed int)((const unsigned char *)(const char *)"-shade_blinn")[(signed long int)1];
        if(getparm$$1$$39$$__s2_len > 1ul)
        {
          if(getparm$$1$$39$$2$$__result == 0)
          {
            getparm$$1$$39$$2$$__result = (signed int)getparm$$1$$39$$2$$__s1[(signed long int)2] - (signed int)((const unsigned char *)(const char *)"-shade_blinn")[(signed long int)2];
            if(getparm$$1$$39$$__s2_len > 2ul)
            {
              if(getparm$$1$$39$$2$$__result == 0)
                getparm$$1$$39$$2$$__result = (signed int)getparm$$1$$39$$2$$__s1[(signed long int)3] - (signed int)((const unsigned char *)(const char *)"-shade_blinn")[(signed long int)3];

            }

          }

        }

      }

    }

    tmp_statement_expression$136 = getparm$$1$$39$$2$$__result;
    tmp_if_expr$138 = tmp_statement_expression$136;
  }

  else
  {
    return_value___builtin_strcmp$137=__builtin_strcmp(argv[(signed long int)num], "-shade_blinn");
    tmp_if_expr$138 = return_value___builtin_strcmp$137;
  }
  tmp_statement_expression$133 = tmp_if_expr$138;
  if(tmp_statement_expression$133 == 0)
  {
    opt->phongfunc = 2;
    return 1;
  }

  signed int tmp_statement_expression$139;
  unsigned long int getparm$$1$$41$$__s1_len;
  unsigned long int getparm$$1$$41$$__s2_len;
  _Bool tmp_if_expr$141;
  unsigned int return_value___builtin_strlen$140;
  if(TRUE)
  {
    if(!((unsigned long int)("-shade_blinn_fast" + 1l) + -((unsigned long int)"-shade_blinn_fast") == 1ul))
      goto __CPROVER_DUMP_L139;

    return_value___builtin_strlen$140=__builtin_strlen("-shade_blinn_fast");
    getparm$$1$$41$$__s2_len = (unsigned long int)return_value___builtin_strlen$140;
    tmp_if_expr$141 = getparm$$1$$41$$__s2_len < (unsigned long int)4 ? TRUE : FALSE;
  }

  else
  {

  __CPROVER_DUMP_L139:
    ;
    tmp_if_expr$141 = FALSE;
  }
  signed int tmp_if_expr$144;
  signed int tmp_statement_expression$142;
  signed int return_value___builtin_strcmp$143;
  if(tmp_if_expr$141)
  {
    const unsigned char *getparm$$1$$41$$2$$__s1 = (const unsigned char *)(const char *)argv[(signed long int)num];
    signed int getparm$$1$$41$$2$$__result = (signed int)getparm$$1$$41$$2$$__s1[(signed long int)0] - (signed int)((const unsigned char *)(const char *)"-shade_blinn_fast")[(signed long int)0];
    if(getparm$$1$$41$$__s2_len > 0ul)
    {
      if(getparm$$1$$41$$2$$__result == 0)
      {
        getparm$$1$$41$$2$$__result = (signed int)getparm$$1$$41$$2$$__s1[(signed long int)1] - (signed int)((const unsigned char *)(const char *)"-shade_blinn_fast")[(signed long int)1];
        if(getparm$$1$$41$$__s2_len > 1ul)
        {
          if(getparm$$1$$41$$2$$__result == 0)
          {
            getparm$$1$$41$$2$$__result = (signed int)getparm$$1$$41$$2$$__s1[(signed long int)2] - (signed int)((const unsigned char *)(const char *)"-shade_blinn_fast")[(signed long int)2];
            if(getparm$$1$$41$$__s2_len > 2ul)
            {
              if(getparm$$1$$41$$2$$__result == 0)
                getparm$$1$$41$$2$$__result = (signed int)getparm$$1$$41$$2$$__s1[(signed long int)3] - (signed int)((const unsigned char *)(const char *)"-shade_blinn_fast")[(signed long int)3];

            }

          }

        }

      }

    }

    tmp_statement_expression$142 = getparm$$1$$41$$2$$__result;
    tmp_if_expr$144 = tmp_statement_expression$142;
  }

  else
  {
    return_value___builtin_strcmp$143=__builtin_strcmp(argv[(signed long int)num], "-shade_blinn_fast");
    tmp_if_expr$144 = return_value___builtin_strcmp$143;
  }
  tmp_statement_expression$139 = tmp_if_expr$144;
  if(tmp_statement_expression$139 == 0)
  {
    opt->phongfunc = 1;
    return 1;
  }

  signed int tmp_statement_expression$145;
  unsigned long int getparm$$1$$43$$__s1_len;
  unsigned long int getparm$$1$$43$$__s2_len;
  _Bool tmp_if_expr$147;
  unsigned int return_value___builtin_strlen$146;
  if(TRUE)
  {
    if(!((unsigned long int)("-shade_nullphong" + 1l) + -((unsigned long int)"-shade_nullphong") == 1ul))
      goto __CPROVER_DUMP_L145;

    return_value___builtin_strlen$146=__builtin_strlen("-shade_nullphong");
    getparm$$1$$43$$__s2_len = (unsigned long int)return_value___builtin_strlen$146;
    tmp_if_expr$147 = getparm$$1$$43$$__s2_len < (unsigned long int)4 ? TRUE : FALSE;
  }

  else
  {

  __CPROVER_DUMP_L145:
    ;
    tmp_if_expr$147 = FALSE;
  }
  signed int tmp_if_expr$150;
  signed int tmp_statement_expression$148;
  signed int return_value___builtin_strcmp$149;
  if(tmp_if_expr$147)
  {
    const unsigned char *getparm$$1$$43$$2$$__s1 = (const unsigned char *)(const char *)argv[(signed long int)num];
    signed int getparm$$1$$43$$2$$__result = (signed int)getparm$$1$$43$$2$$__s1[(signed long int)0] - (signed int)((const unsigned char *)(const char *)"-shade_nullphong")[(signed long int)0];
    if(getparm$$1$$43$$__s2_len > 0ul)
    {
      if(getparm$$1$$43$$2$$__result == 0)
      {
        getparm$$1$$43$$2$$__result = (signed int)getparm$$1$$43$$2$$__s1[(signed long int)1] - (signed int)((const unsigned char *)(const char *)"-shade_nullphong")[(signed long int)1];
        if(getparm$$1$$43$$__s2_len > 1ul)
        {
          if(getparm$$1$$43$$2$$__result == 0)
          {
            getparm$$1$$43$$2$$__result = (signed int)getparm$$1$$43$$2$$__s1[(signed long int)2] - (signed int)((const unsigned char *)(const char *)"-shade_nullphong")[(signed long int)2];
            if(getparm$$1$$43$$__s2_len > 2ul)
            {
              if(getparm$$1$$43$$2$$__result == 0)
                getparm$$1$$43$$2$$__result = (signed int)getparm$$1$$43$$2$$__s1[(signed long int)3] - (signed int)((const unsigned char *)(const char *)"-shade_nullphong")[(signed long int)3];

            }

          }

        }

      }

    }

    tmp_statement_expression$148 = getparm$$1$$43$$2$$__result;
    tmp_if_expr$150 = tmp_statement_expression$148;
  }

  else
  {
    return_value___builtin_strcmp$149=__builtin_strcmp(argv[(signed long int)num], "-shade_nullphong");
    tmp_if_expr$150 = return_value___builtin_strcmp$149;
  }
  tmp_statement_expression$145 = tmp_if_expr$150;
  if(tmp_statement_expression$145 == 0)
  {
    opt->phongfunc = 0;
    return 1;
  }

  signed int tmp_statement_expression$151;
  unsigned long int getparm$$1$$45$$__s1_len;
  unsigned long int getparm$$1$$45$$__s2_len;
  _Bool tmp_if_expr$153;
  unsigned int return_value___builtin_strlen$152;
  if(TRUE)
  {
    if(!((unsigned long int)("-trans_orig" + 1l) + -((unsigned long int)"-trans_orig") == 1ul))
      goto __CPROVER_DUMP_L151;

    return_value___builtin_strlen$152=__builtin_strlen("-trans_orig");
    getparm$$1$$45$$__s2_len = (unsigned long int)return_value___builtin_strlen$152;
    tmp_if_expr$153 = getparm$$1$$45$$__s2_len < (unsigned long int)4 ? TRUE : FALSE;
  }

  else
  {

  __CPROVER_DUMP_L151:
    ;
    tmp_if_expr$153 = FALSE;
  }
  signed int tmp_if_expr$156;
  signed int tmp_statement_expression$154;
  signed int return_value___builtin_strcmp$155;
  if(tmp_if_expr$153)
  {
    const unsigned char *getparm$$1$$45$$2$$__s1 = (const unsigned char *)(const char *)argv[(signed long int)num];
    signed int getparm$$1$$45$$2$$__result = (signed int)getparm$$1$$45$$2$$__s1[(signed long int)0] - (signed int)((const unsigned char *)(const char *)"-trans_orig")[(signed long int)0];
    if(getparm$$1$$45$$__s2_len > 0ul)
    {
      if(getparm$$1$$45$$2$$__result == 0)
      {
        getparm$$1$$45$$2$$__result = (signed int)getparm$$1$$45$$2$$__s1[(signed long int)1] - (signed int)((const unsigned char *)(const char *)"-trans_orig")[(signed long int)1];
        if(getparm$$1$$45$$__s2_len > 1ul)
        {
          if(getparm$$1$$45$$2$$__result == 0)
          {
            getparm$$1$$45$$2$$__result = (signed int)getparm$$1$$45$$2$$__s1[(signed long int)2] - (signed int)((const unsigned char *)(const char *)"-trans_orig")[(signed long int)2];
            if(getparm$$1$$45$$__s2_len > 2ul)
            {
              if(getparm$$1$$45$$2$$__result == 0)
                getparm$$1$$45$$2$$__result = (signed int)getparm$$1$$45$$2$$__s1[(signed long int)3] - (signed int)((const unsigned char *)(const char *)"-trans_orig")[(signed long int)3];

            }

          }

        }

      }

    }

    tmp_statement_expression$154 = getparm$$1$$45$$2$$__result;
    tmp_if_expr$156 = tmp_statement_expression$154;
  }

  else
  {
    return_value___builtin_strcmp$155=__builtin_strcmp(argv[(signed long int)num], "-trans_orig");
    tmp_if_expr$156 = return_value___builtin_strcmp$155;
  }
  tmp_statement_expression$151 = tmp_if_expr$156;
  if(tmp_statement_expression$151 == 0)
  {
    opt->transmode = 0;
    return 1;
  }

  signed int tmp_statement_expression$157;
  unsigned long int getparm$$1$$47$$__s1_len;
  unsigned long int getparm$$1$$47$$__s2_len;
  _Bool tmp_if_expr$159;
  unsigned int return_value___builtin_strlen$158;
  if(TRUE)
  {
    if(!((unsigned long int)("-trans_vmd" + 1l) + -((unsigned long int)"-trans_vmd") == 1ul))
      goto __CPROVER_DUMP_L157;

    return_value___builtin_strlen$158=__builtin_strlen("-trans_vmd");
    getparm$$1$$47$$__s2_len = (unsigned long int)return_value___builtin_strlen$158;
    tmp_if_expr$159 = getparm$$1$$47$$__s2_len < (unsigned long int)4 ? TRUE : FALSE;
  }

  else
  {

  __CPROVER_DUMP_L157:
    ;
    tmp_if_expr$159 = FALSE;
  }
  signed int tmp_if_expr$162;
  signed int tmp_statement_expression$160;
  signed int return_value___builtin_strcmp$161;
  if(tmp_if_expr$159)
  {
    const unsigned char *getparm$$1$$47$$2$$__s1 = (const unsigned char *)(const char *)argv[(signed long int)num];
    signed int getparm$$1$$47$$2$$__result = (signed int)getparm$$1$$47$$2$$__s1[(signed long int)0] - (signed int)((const unsigned char *)(const char *)"-trans_vmd")[(signed long int)0];
    if(getparm$$1$$47$$__s2_len > 0ul)
    {
      if(getparm$$1$$47$$2$$__result == 0)
      {
        getparm$$1$$47$$2$$__result = (signed int)getparm$$1$$47$$2$$__s1[(signed long int)1] - (signed int)((const unsigned char *)(const char *)"-trans_vmd")[(signed long int)1];
        if(getparm$$1$$47$$__s2_len > 1ul)
        {
          if(getparm$$1$$47$$2$$__result == 0)
          {
            getparm$$1$$47$$2$$__result = (signed int)getparm$$1$$47$$2$$__s1[(signed long int)2] - (signed int)((const unsigned char *)(const char *)"-trans_vmd")[(signed long int)2];
            if(getparm$$1$$47$$__s2_len > 2ul)
            {
              if(getparm$$1$$47$$2$$__result == 0)
                getparm$$1$$47$$2$$__result = (signed int)getparm$$1$$47$$2$$__s1[(signed long int)3] - (signed int)((const unsigned char *)(const char *)"-trans_vmd")[(signed long int)3];

            }

          }

        }

      }

    }

    tmp_statement_expression$160 = getparm$$1$$47$$2$$__result;
    tmp_if_expr$162 = tmp_statement_expression$160;
  }

  else
  {
    return_value___builtin_strcmp$161=__builtin_strcmp(argv[(signed long int)num], "-trans_vmd");
    tmp_if_expr$162 = return_value___builtin_strcmp$161;
  }
  tmp_statement_expression$157 = tmp_if_expr$162;
  if(tmp_statement_expression$157 == 0)
  {
    opt->transmode = 1;
    return 1;
  }

  signed int tmp_statement_expression$163;
  unsigned long int getparm$$1$$49$$__s1_len;
  unsigned long int getparm$$1$$49$$__s2_len;
  _Bool tmp_if_expr$165;
  unsigned int return_value___builtin_strlen$164;
  if(TRUE)
  {
    if(!((unsigned long int)("-fog_normal" + 1l) + -((unsigned long int)"-fog_normal") == 1ul))
      goto __CPROVER_DUMP_L163;

    return_value___builtin_strlen$164=__builtin_strlen("-fog_normal");
    getparm$$1$$49$$__s2_len = (unsigned long int)return_value___builtin_strlen$164;
    tmp_if_expr$165 = getparm$$1$$49$$__s2_len < (unsigned long int)4 ? TRUE : FALSE;
  }

  else
  {

  __CPROVER_DUMP_L163:
    ;
    tmp_if_expr$165 = FALSE;
  }
  signed int tmp_if_expr$168;
  signed int tmp_statement_expression$166;
  signed int return_value___builtin_strcmp$167;
  if(tmp_if_expr$165)
  {
    const unsigned char *getparm$$1$$49$$2$$__s1 = (const unsigned char *)(const char *)argv[(signed long int)num];
    signed int getparm$$1$$49$$2$$__result = (signed int)getparm$$1$$49$$2$$__s1[(signed long int)0] - (signed int)((const unsigned char *)(const char *)"-fog_normal")[(signed long int)0];
    if(getparm$$1$$49$$__s2_len > 0ul)
    {
      if(getparm$$1$$49$$2$$__result == 0)
      {
        getparm$$1$$49$$2$$__result = (signed int)getparm$$1$$49$$2$$__s1[(signed long int)1] - (signed int)((const unsigned char *)(const char *)"-fog_normal")[(signed long int)1];
        if(getparm$$1$$49$$__s2_len > 1ul)
        {
          if(getparm$$1$$49$$2$$__result == 0)
          {
            getparm$$1$$49$$2$$__result = (signed int)getparm$$1$$49$$2$$__s1[(signed long int)2] - (signed int)((const unsigned char *)(const char *)"-fog_normal")[(signed long int)2];
            if(getparm$$1$$49$$__s2_len > 2ul)
            {
              if(getparm$$1$$49$$2$$__result == 0)
                getparm$$1$$49$$2$$__result = (signed int)getparm$$1$$49$$2$$__s1[(signed long int)3] - (signed int)((const unsigned char *)(const char *)"-fog_normal")[(signed long int)3];

            }

          }

        }

      }

    }

    tmp_statement_expression$166 = getparm$$1$$49$$2$$__result;
    tmp_if_expr$168 = tmp_statement_expression$166;
  }

  else
  {
    return_value___builtin_strcmp$167=__builtin_strcmp(argv[(signed long int)num], "-fog_normal");
    tmp_if_expr$168 = return_value___builtin_strcmp$167;
  }
  tmp_statement_expression$163 = tmp_if_expr$168;
  if(tmp_statement_expression$163 == 0)
  {
    opt->fogmode = 0;
    return 1;
  }

  signed int tmp_statement_expression$169;
  unsigned long int getparm$$1$$51$$__s1_len;
  unsigned long int getparm$$1$$51$$__s2_len;
  _Bool tmp_if_expr$171;
  unsigned int return_value___builtin_strlen$170;
  if(TRUE)
  {
    if(!((unsigned long int)("-fog_vmd" + 1l) + -((unsigned long int)"-fog_vmd") == 1ul))
      goto __CPROVER_DUMP_L169;

    return_value___builtin_strlen$170=__builtin_strlen("-fog_vmd");
    getparm$$1$$51$$__s2_len = (unsigned long int)return_value___builtin_strlen$170;
    tmp_if_expr$171 = getparm$$1$$51$$__s2_len < (unsigned long int)4 ? TRUE : FALSE;
  }

  else
  {

  __CPROVER_DUMP_L169:
    ;
    tmp_if_expr$171 = FALSE;
  }
  signed int tmp_if_expr$174;
  signed int tmp_statement_expression$172;
  signed int return_value___builtin_strcmp$173;
  if(tmp_if_expr$171)
  {
    const unsigned char *getparm$$1$$51$$2$$__s1 = (const unsigned char *)(const char *)argv[(signed long int)num];
    signed int getparm$$1$$51$$2$$__result = (signed int)getparm$$1$$51$$2$$__s1[(signed long int)0] - (signed int)((const unsigned char *)(const char *)"-fog_vmd")[(signed long int)0];
    if(getparm$$1$$51$$__s2_len > 0ul)
    {
      if(getparm$$1$$51$$2$$__result == 0)
      {
        getparm$$1$$51$$2$$__result = (signed int)getparm$$1$$51$$2$$__s1[(signed long int)1] - (signed int)((const unsigned char *)(const char *)"-fog_vmd")[(signed long int)1];
        if(getparm$$1$$51$$__s2_len > 1ul)
        {
          if(getparm$$1$$51$$2$$__result == 0)
          {
            getparm$$1$$51$$2$$__result = (signed int)getparm$$1$$51$$2$$__s1[(signed long int)2] - (signed int)((const unsigned char *)(const char *)"-fog_vmd")[(signed long int)2];
            if(getparm$$1$$51$$__s2_len > 2ul)
            {
              if(getparm$$1$$51$$2$$__result == 0)
                getparm$$1$$51$$2$$__result = (signed int)getparm$$1$$51$$2$$__s1[(signed long int)3] - (signed int)((const unsigned char *)(const char *)"-fog_vmd")[(signed long int)3];

            }

          }

        }

      }

    }

    tmp_statement_expression$172 = getparm$$1$$51$$2$$__result;
    tmp_if_expr$174 = tmp_statement_expression$172;
  }

  else
  {
    return_value___builtin_strcmp$173=__builtin_strcmp(argv[(signed long int)num], "-fog_vmd");
    tmp_if_expr$174 = return_value___builtin_strcmp$173;
  }
  tmp_statement_expression$169 = tmp_if_expr$174;
  if(tmp_statement_expression$169 == 0)
  {
    opt->fogmode = 1;
    return 1;
  }

  signed int tmp_statement_expression$175;
  unsigned long int getparm$$1$$53$$__s1_len;
  unsigned long int getparm$$1$$53$$__s2_len;
  _Bool tmp_if_expr$177;
  unsigned int return_value___builtin_strlen$176;
  if(TRUE)
  {
    if(!((unsigned long int)("-res" + 1l) + -((unsigned long int)"-res") == 1ul))
      goto __CPROVER_DUMP_L175;

    return_value___builtin_strlen$176=__builtin_strlen("-res");
    getparm$$1$$53$$__s2_len = (unsigned long int)return_value___builtin_strlen$176;
    tmp_if_expr$177 = getparm$$1$$53$$__s2_len < (unsigned long int)4 ? TRUE : FALSE;
  }

  else
  {

  __CPROVER_DUMP_L175:
    ;
    tmp_if_expr$177 = FALSE;
  }
  signed int tmp_if_expr$180;
  signed int tmp_statement_expression$178;
  signed int return_value___builtin_strcmp$179;
  if(tmp_if_expr$177)
  {
    const unsigned char *getparm$$1$$53$$2$$__s1 = (const unsigned char *)(const char *)argv[(signed long int)num];
    signed int getparm$$1$$53$$2$$__result = (signed int)getparm$$1$$53$$2$$__s1[(signed long int)0] - (signed int)((const unsigned char *)(const char *)"-res")[(signed long int)0];
    if(getparm$$1$$53$$__s2_len > 0ul)
    {
      if(getparm$$1$$53$$2$$__result == 0)
      {
        getparm$$1$$53$$2$$__result = (signed int)getparm$$1$$53$$2$$__s1[(signed long int)1] - (signed int)((const unsigned char *)(const char *)"-res")[(signed long int)1];
        if(getparm$$1$$53$$__s2_len > 1ul)
        {
          if(getparm$$1$$53$$2$$__result == 0)
          {
            getparm$$1$$53$$2$$__result = (signed int)getparm$$1$$53$$2$$__s1[(signed long int)2] - (signed int)((const unsigned char *)(const char *)"-res")[(signed long int)2];
            if(getparm$$1$$53$$__s2_len > 2ul)
            {
              if(getparm$$1$$53$$2$$__result == 0)
                getparm$$1$$53$$2$$__result = (signed int)getparm$$1$$53$$2$$__s1[(signed long int)3] - (signed int)((const unsigned char *)(const char *)"-res")[(signed long int)3];

            }

          }

        }

      }

    }

    tmp_statement_expression$178 = getparm$$1$$53$$2$$__result;
    tmp_if_expr$180 = tmp_statement_expression$178;
  }

  else
  {
    return_value___builtin_strcmp$179=__builtin_strcmp(argv[(signed long int)num], "-res");
    tmp_if_expr$180 = return_value___builtin_strcmp$179;
  }
  tmp_statement_expression$175 = tmp_if_expr$180;
  if(tmp_statement_expression$175 == 0)
  {
    sscanf(argv[(signed long int)(num + 1)], "%d", &opt->xsize);
    sscanf(argv[(signed long int)(num + 2)], "%d", &opt->ysize);
    return 3;
  }

  signed int tmp_statement_expression$181;
  unsigned long int getparm$$1$$55$$__s1_len;
  unsigned long int getparm$$1$$55$$__s2_len;
  _Bool tmp_if_expr$183;
  unsigned int return_value___builtin_strlen$182;
  if(TRUE)
  {
    if(!((unsigned long int)("-cropoutputauto" + 1l) + -((unsigned long int)"-cropoutputauto") == 1ul))
      goto __CPROVER_DUMP_L181;

    return_value___builtin_strlen$182=__builtin_strlen("-cropoutputauto");
    getparm$$1$$55$$__s2_len = (unsigned long int)return_value___builtin_strlen$182;
    tmp_if_expr$183 = getparm$$1$$55$$__s2_len < (unsigned long int)4 ? TRUE : FALSE;
  }

  else
  {

  __CPROVER_DUMP_L181:
    ;
    tmp_if_expr$183 = FALSE;
  }
  signed int tmp_if_expr$186;
  signed int tmp_statement_expression$184;
  signed int return_value___builtin_strcmp$185;
  if(tmp_if_expr$183)
  {
    const unsigned char *getparm$$1$$55$$2$$__s1 = (const unsigned char *)(const char *)argv[(signed long int)num];
    signed int getparm$$1$$55$$2$$__result = (signed int)getparm$$1$$55$$2$$__s1[(signed long int)0] - (signed int)((const unsigned char *)(const char *)"-cropoutputauto")[(signed long int)0];
    if(getparm$$1$$55$$__s2_len > 0ul)
    {
      if(getparm$$1$$55$$2$$__result == 0)
      {
        getparm$$1$$55$$2$$__result = (signed int)getparm$$1$$55$$2$$__s1[(signed long int)1] - (signed int)((const unsigned char *)(const char *)"-cropoutputauto")[(signed long int)1];
        if(getparm$$1$$55$$__s2_len > 1ul)
        {
          if(getparm$$1$$55$$2$$__result == 0)
          {
            getparm$$1$$55$$2$$__result = (signed int)getparm$$1$$55$$2$$__s1[(signed long int)2] - (signed int)((const unsigned char *)(const char *)"-cropoutputauto")[(signed long int)2];
            if(getparm$$1$$55$$__s2_len > 2ul)
            {
              if(getparm$$1$$55$$2$$__result == 0)
                getparm$$1$$55$$2$$__result = (signed int)getparm$$1$$55$$2$$__s1[(signed long int)3] - (signed int)((const unsigned char *)(const char *)"-cropoutputauto")[(signed long int)3];

            }

          }

        }

      }

    }

    tmp_statement_expression$184 = getparm$$1$$55$$2$$__result;
    tmp_if_expr$186 = tmp_statement_expression$184;
  }

  else
  {
    return_value___builtin_strcmp$185=__builtin_strcmp(argv[(signed long int)num], "-cropoutputauto");
    tmp_if_expr$186 = return_value___builtin_strcmp$185;
  }
  tmp_statement_expression$181 = tmp_if_expr$186;
  if(tmp_statement_expression$181 == 0)
  {
    opt->cropmode = 2;
    return 1;
  }

  signed int tmp_statement_expression$187;
  unsigned long int getparm$$1$$57$$__s1_len;
  unsigned long int getparm$$1$$57$$__s2_len;
  _Bool tmp_if_expr$189;
  unsigned int return_value___builtin_strlen$188;
  if(TRUE)
  {
    if(!((unsigned long int)("-cropoutput" + 1l) + -((unsigned long int)"-cropoutput") == 1ul))
      goto __CPROVER_DUMP_L187;

    return_value___builtin_strlen$188=__builtin_strlen("-cropoutput");
    getparm$$1$$57$$__s2_len = (unsigned long int)return_value___builtin_strlen$188;
    tmp_if_expr$189 = getparm$$1$$57$$__s2_len < (unsigned long int)4 ? TRUE : FALSE;
  }

  else
  {

  __CPROVER_DUMP_L187:
    ;
    tmp_if_expr$189 = FALSE;
  }
  signed int tmp_if_expr$192;
  signed int tmp_statement_expression$190;
  signed int return_value___builtin_strcmp$191;
  if(tmp_if_expr$189)
  {
    const unsigned char *getparm$$1$$57$$2$$__s1 = (const unsigned char *)(const char *)argv[(signed long int)num];
    signed int getparm$$1$$57$$2$$__result = (signed int)getparm$$1$$57$$2$$__s1[(signed long int)0] - (signed int)((const unsigned char *)(const char *)"-cropoutput")[(signed long int)0];
    if(getparm$$1$$57$$__s2_len > 0ul)
    {
      if(getparm$$1$$57$$2$$__result == 0)
      {
        getparm$$1$$57$$2$$__result = (signed int)getparm$$1$$57$$2$$__s1[(signed long int)1] - (signed int)((const unsigned char *)(const char *)"-cropoutput")[(signed long int)1];
        if(getparm$$1$$57$$__s2_len > 1ul)
        {
          if(getparm$$1$$57$$2$$__result == 0)
          {
            getparm$$1$$57$$2$$__result = (signed int)getparm$$1$$57$$2$$__s1[(signed long int)2] - (signed int)((const unsigned char *)(const char *)"-cropoutput")[(signed long int)2];
            if(getparm$$1$$57$$__s2_len > 2ul)
            {
              if(getparm$$1$$57$$2$$__result == 0)
                getparm$$1$$57$$2$$__result = (signed int)getparm$$1$$57$$2$$__s1[(signed long int)3] - (signed int)((const unsigned char *)(const char *)"-cropoutput")[(signed long int)3];

            }

          }

        }

      }

    }

    tmp_statement_expression$190 = getparm$$1$$57$$2$$__result;
    tmp_if_expr$192 = tmp_statement_expression$190;
  }

  else
  {
    return_value___builtin_strcmp$191=__builtin_strcmp(argv[(signed long int)num], "-cropoutput");
    tmp_if_expr$192 = return_value___builtin_strcmp$191;
  }
  tmp_statement_expression$187 = tmp_if_expr$192;
  if(tmp_statement_expression$187 == 0)
  {
    opt->cropmode = 1;
    sscanf(argv[(signed long int)(num + 1)], "%d", &opt->cropxres);
    sscanf(argv[(signed long int)(num + 2)], "%d", &opt->cropyres);
    sscanf(argv[(signed long int)(num + 3)], "%d", &opt->cropxstart);
    sscanf(argv[(signed long int)(num + 4)], "%d", &opt->cropystart);
    return 5;
  }

  signed int tmp_statement_expression$193;
  unsigned long int getparm$$1$$59$$__s1_len;
  unsigned long int getparm$$1$$59$$__s2_len;
  _Bool tmp_if_expr$195;
  unsigned int return_value___builtin_strlen$194;
  if(TRUE)
  {
    if(!((unsigned long int)("-clamp" + 1l) + -((unsigned long int)"-clamp") == 1ul))
      goto __CPROVER_DUMP_L193;

    return_value___builtin_strlen$194=__builtin_strlen("-clamp");
    getparm$$1$$59$$__s2_len = (unsigned long int)return_value___builtin_strlen$194;
    tmp_if_expr$195 = getparm$$1$$59$$__s2_len < (unsigned long int)4 ? TRUE : FALSE;
  }

  else
  {

  __CPROVER_DUMP_L193:
    ;
    tmp_if_expr$195 = FALSE;
  }
  signed int tmp_if_expr$198;
  signed int tmp_statement_expression$196;
  signed int return_value___builtin_strcmp$197;
  if(tmp_if_expr$195)
  {
    const unsigned char *getparm$$1$$59$$2$$__s1 = (const unsigned char *)(const char *)argv[(signed long int)num];
    signed int getparm$$1$$59$$2$$__result = (signed int)getparm$$1$$59$$2$$__s1[(signed long int)0] - (signed int)((const unsigned char *)(const char *)"-clamp")[(signed long int)0];
    if(getparm$$1$$59$$__s2_len > 0ul)
    {
      if(getparm$$1$$59$$2$$__result == 0)
      {
        getparm$$1$$59$$2$$__result = (signed int)getparm$$1$$59$$2$$__s1[(signed long int)1] - (signed int)((const unsigned char *)(const char *)"-clamp")[(signed long int)1];
        if(getparm$$1$$59$$__s2_len > 1ul)
        {
          if(getparm$$1$$59$$2$$__result == 0)
          {
            getparm$$1$$59$$2$$__result = (signed int)getparm$$1$$59$$2$$__s1[(signed long int)2] - (signed int)((const unsigned char *)(const char *)"-clamp")[(signed long int)2];
            if(getparm$$1$$59$$__s2_len > 2ul)
            {
              if(getparm$$1$$59$$2$$__result == 0)
                getparm$$1$$59$$2$$__result = (signed int)getparm$$1$$59$$2$$__s1[(signed long int)3] - (signed int)((const unsigned char *)(const char *)"-clamp")[(signed long int)3];

            }

          }

        }

      }

    }

    tmp_statement_expression$196 = getparm$$1$$59$$2$$__result;
    tmp_if_expr$198 = tmp_statement_expression$196;
  }

  else
  {
    return_value___builtin_strcmp$197=__builtin_strcmp(argv[(signed long int)num], "-clamp");
    tmp_if_expr$198 = return_value___builtin_strcmp$197;
  }
  tmp_statement_expression$193 = tmp_if_expr$198;
  if(tmp_statement_expression$193 == 0)
  {
    opt->imgprocess = 0;
    return 1;
  }

  signed int tmp_statement_expression$199;
  unsigned long int getparm$$1$$61$$__s1_len;
  unsigned long int getparm$$1$$61$$__s2_len;
  _Bool tmp_if_expr$201;
  unsigned int return_value___builtin_strlen$200;
  if(TRUE)
  {
    if(!((unsigned long int)("-normalize" + 1l) + -((unsigned long int)"-normalize") == 1ul))
      goto __CPROVER_DUMP_L199;

    return_value___builtin_strlen$200=__builtin_strlen("-normalize");
    getparm$$1$$61$$__s2_len = (unsigned long int)return_value___builtin_strlen$200;
    tmp_if_expr$201 = getparm$$1$$61$$__s2_len < (unsigned long int)4 ? TRUE : FALSE;
  }

  else
  {

  __CPROVER_DUMP_L199:
    ;
    tmp_if_expr$201 = FALSE;
  }
  signed int tmp_if_expr$204;
  signed int tmp_statement_expression$202;
  signed int return_value___builtin_strcmp$203;
  if(tmp_if_expr$201)
  {
    const unsigned char *getparm$$1$$61$$2$$__s1 = (const unsigned char *)(const char *)argv[(signed long int)num];
    signed int getparm$$1$$61$$2$$__result = (signed int)getparm$$1$$61$$2$$__s1[(signed long int)0] - (signed int)((const unsigned char *)(const char *)"-normalize")[(signed long int)0];
    if(getparm$$1$$61$$__s2_len > 0ul)
    {
      if(getparm$$1$$61$$2$$__result == 0)
      {
        getparm$$1$$61$$2$$__result = (signed int)getparm$$1$$61$$2$$__s1[(signed long int)1] - (signed int)((const unsigned char *)(const char *)"-normalize")[(signed long int)1];
        if(getparm$$1$$61$$__s2_len > 1ul)
        {
          if(getparm$$1$$61$$2$$__result == 0)
          {
            getparm$$1$$61$$2$$__result = (signed int)getparm$$1$$61$$2$$__s1[(signed long int)2] - (signed int)((const unsigned char *)(const char *)"-normalize")[(signed long int)2];
            if(getparm$$1$$61$$__s2_len > 2ul)
            {
              if(getparm$$1$$61$$2$$__result == 0)
                getparm$$1$$61$$2$$__result = (signed int)getparm$$1$$61$$2$$__s1[(signed long int)3] - (signed int)((const unsigned char *)(const char *)"-normalize")[(signed long int)3];

            }

          }

        }

      }

    }

    tmp_statement_expression$202 = getparm$$1$$61$$2$$__result;
    tmp_if_expr$204 = tmp_statement_expression$202;
  }

  else
  {
    return_value___builtin_strcmp$203=__builtin_strcmp(argv[(signed long int)num], "-normalize");
    tmp_if_expr$204 = return_value___builtin_strcmp$203;
  }
  tmp_statement_expression$199 = tmp_if_expr$204;
  if(tmp_statement_expression$199 == 0)
  {
    opt->imgprocess = 1;
    return 1;
  }

  signed int tmp_statement_expression$205;
  unsigned long int getparm$$1$$63$$__s1_len;
  unsigned long int getparm$$1$$63$$__s2_len;
  _Bool tmp_if_expr$207;
  unsigned int return_value___builtin_strlen$206;
  if(TRUE)
  {
    if(!((unsigned long int)("-gamma" + 1l) + -((unsigned long int)"-gamma") == 1ul))
      goto __CPROVER_DUMP_L205;

    return_value___builtin_strlen$206=__builtin_strlen("-gamma");
    getparm$$1$$63$$__s2_len = (unsigned long int)return_value___builtin_strlen$206;
    tmp_if_expr$207 = getparm$$1$$63$$__s2_len < (unsigned long int)4 ? TRUE : FALSE;
  }

  else
  {

  __CPROVER_DUMP_L205:
    ;
    tmp_if_expr$207 = FALSE;
  }
  signed int tmp_if_expr$210;
  signed int tmp_statement_expression$208;
  signed int return_value___builtin_strcmp$209;
  if(tmp_if_expr$207)
  {
    const unsigned char *getparm$$1$$63$$2$$__s1 = (const unsigned char *)(const char *)argv[(signed long int)num];
    signed int getparm$$1$$63$$2$$__result = (signed int)getparm$$1$$63$$2$$__s1[(signed long int)0] - (signed int)((const unsigned char *)(const char *)"-gamma")[(signed long int)0];
    if(getparm$$1$$63$$__s2_len > 0ul)
    {
      if(getparm$$1$$63$$2$$__result == 0)
      {
        getparm$$1$$63$$2$$__result = (signed int)getparm$$1$$63$$2$$__s1[(signed long int)1] - (signed int)((const unsigned char *)(const char *)"-gamma")[(signed long int)1];
        if(getparm$$1$$63$$__s2_len > 1ul)
        {
          if(getparm$$1$$63$$2$$__result == 0)
          {
            getparm$$1$$63$$2$$__result = (signed int)getparm$$1$$63$$2$$__s1[(signed long int)2] - (signed int)((const unsigned char *)(const char *)"-gamma")[(signed long int)2];
            if(getparm$$1$$63$$__s2_len > 2ul)
            {
              if(getparm$$1$$63$$2$$__result == 0)
                getparm$$1$$63$$2$$__result = (signed int)getparm$$1$$63$$2$$__s1[(signed long int)3] - (signed int)((const unsigned char *)(const char *)"-gamma")[(signed long int)3];

            }

          }

        }

      }

    }

    tmp_statement_expression$208 = getparm$$1$$63$$2$$__result;
    tmp_if_expr$210 = tmp_statement_expression$208;
  }

  else
  {
    return_value___builtin_strcmp$209=__builtin_strcmp(argv[(signed long int)num], "-gamma");
    tmp_if_expr$210 = return_value___builtin_strcmp$209;
  }
  tmp_statement_expression$205 = tmp_if_expr$210;
  if(tmp_statement_expression$205 == 0)
  {
    opt->imgprocess = 2;
    sscanf(argv[(signed long int)(num + 1)], "%f", &opt->imggamma);
    return 2;
  }

  signed int tmp_statement_expression$217;
  unsigned long int getparm$$1$$65$$__s1_len;
  unsigned long int getparm$$1$$65$$__s2_len;
  _Bool tmp_if_expr$219;
  unsigned int return_value___builtin_strlen$218;
  if(TRUE)
  {
    if(!((unsigned long int)("-format" + 1l) + -((unsigned long int)"-format") == 1ul))
      goto __CPROVER_DUMP_L211;

    return_value___builtin_strlen$218=__builtin_strlen("-format");
    getparm$$1$$65$$__s2_len = (unsigned long int)return_value___builtin_strlen$218;
    tmp_if_expr$219 = getparm$$1$$65$$__s2_len < (unsigned long int)4 ? TRUE : FALSE;
  }

  else
  {

  __CPROVER_DUMP_L211:
    ;
    tmp_if_expr$219 = FALSE;
  }
  signed int tmp_if_expr$222;
  signed int tmp_statement_expression$220;
  signed int return_value___builtin_strcmp$221;
  if(tmp_if_expr$219)
  {
    const unsigned char *getparm$$1$$65$$2$$__s1 = (const unsigned char *)(const char *)argv[(signed long int)num];
    signed int getparm$$1$$65$$2$$__result = (signed int)getparm$$1$$65$$2$$__s1[(signed long int)0] - (signed int)((const unsigned char *)(const char *)"-format")[(signed long int)0];
    if(getparm$$1$$65$$__s2_len > 0ul)
    {
      if(getparm$$1$$65$$2$$__result == 0)
      {
        getparm$$1$$65$$2$$__result = (signed int)getparm$$1$$65$$2$$__s1[(signed long int)1] - (signed int)((const unsigned char *)(const char *)"-format")[(signed long int)1];
        if(getparm$$1$$65$$__s2_len > 1ul)
        {
          if(getparm$$1$$65$$2$$__result == 0)
          {
            getparm$$1$$65$$2$$__result = (signed int)getparm$$1$$65$$2$$__s1[(signed long int)2] - (signed int)((const unsigned char *)(const char *)"-format")[(signed long int)2];
            if(getparm$$1$$65$$__s2_len > 2ul)
            {
              if(getparm$$1$$65$$2$$__result == 0)
                getparm$$1$$65$$2$$__result = (signed int)getparm$$1$$65$$2$$__s1[(signed long int)3] - (signed int)((const unsigned char *)(const char *)"-format")[(signed long int)3];

            }

          }

        }

      }

    }

    tmp_statement_expression$220 = getparm$$1$$65$$2$$__result;
    tmp_if_expr$222 = tmp_statement_expression$220;
  }

  else
  {
    return_value___builtin_strcmp$221=__builtin_strcmp(argv[(signed long int)num], "-format");
    tmp_if_expr$222 = return_value___builtin_strcmp$221;
  }
  tmp_statement_expression$217 = tmp_if_expr$222;
  signed int return_value_compare$215;
  signed int return_value_compare$214;
  signed int return_value_compare$213;
  signed int return_value_compare$212;
  signed int return_value_compare$211;
  if(tmp_statement_expression$217 == 0)
  {
    char str[80l];
    sscanf(argv[(signed long int)(num + 1)], "%s", &str[(signed long int)0]);
    signed int return_value_compare$216;
    return_value_compare$216=compare(str, "TARGA");
    if(return_value_compare$216 == 0)
      opt->outimageformat = 0;

    else
    {
      return_value_compare$215=compare(str, "BMP");
      if(return_value_compare$215 == 0)
        opt->outimageformat = 4;

      else
      {
        return_value_compare$214=compare(str, "PPM48");
        if(return_value_compare$214 == 0)
          opt->outimageformat = 6;

        else
        {
          return_value_compare$213=compare(str, "PPM");
          if(return_value_compare$213 == 0)
            opt->outimageformat = 1;

          else
          {
            return_value_compare$212=compare(str, "PSD48");
            if(return_value_compare$212 == 0)
              opt->outimageformat = 7;

            else
            {
              return_value_compare$211=compare(str, "RGB");
              if(return_value_compare$211 == 0)
                opt->outimageformat = 2;

              else
                if(node == 0)
                  printf("Unknown/Unsupported Image Format: %s, defaulting to Targa...\n", (const void *)str);

            }
          }
        }
      }
    }
    return 2;
  }

  if(node == 0)
    printf("Unrecognized parameter/option flag: %s\n", argv[(signed long int)num]);

  return -1;
}

// c::gets
// file /usr/include/x86_64-linux-gnu/bits/stdio2.h line 233
char * gets(char *__str)
{
  char *return_value___gets_chk$1;
  char *return_value___gets_warn$2;
  return_value___gets_warn$2=__gets_warn(__str);
  return return_value___gets_warn$2;
}

// c::getwd
// file /usr/include/x86_64-linux-gnu/bits/unistd.h line 221
char * getwd(char *__buf)
{
  char *return_value___getwd_chk$1;
  char *return_value___getwd_warn$2;
  return_value___getwd_warn$2=__getwd_warn(__buf);
  return return_value___getwd_warn$2;
}

// c::globalbound
// file ../src/grid.c line 98
static void globalbound(struct anon$15 **rootlist, struct anon$0 *gmin, struct anon$0 *gmax)
{
  struct anon$0 min;
  struct anon$0 max;
  struct anon$15 *cur;
  if(*rootlist == ((struct anon$15 *)NULL))
    return;

  gmin->x = 1.000000e+18;
  gmin->y = 1.000000e+18;
  gmin->z = 1.000000e+18;
  gmax->x = -1.000000e+18;
  gmax->y = -1.000000e+18;
  gmax->z = -1.000000e+18;
  cur = *rootlist;
  double tmp_if_expr$1;
  double tmp_if_expr$2;
  double tmp_if_expr$3;
  double tmp_if_expr$4;
  double tmp_if_expr$5;
  double tmp_if_expr$6;
  while(!(cur == ((struct anon$15 *)NULL)))
  {
    min.x = -1.000000e+18;
    min.y = -1.000000e+18;
    min.z = -1.000000e+18;
    max.x = 1.000000e+18;
    max.y = 1.000000e+18;
    max.z = 1.000000e+18;
    signed int return_value;
    return_value=cur->methods->bbox((void *)cur, &min, &max);
    if(!(return_value == 0))
    {
      if(gmin->x < min.x)
        tmp_if_expr$1 = gmin->x;

      else
        tmp_if_expr$1 = min.x;
      gmin->x = tmp_if_expr$1;
      if(gmin->y < min.y)
        tmp_if_expr$2 = gmin->y;

      else
        tmp_if_expr$2 = min.y;
      gmin->y = tmp_if_expr$2;
      if(gmin->z < min.z)
        tmp_if_expr$3 = gmin->z;

      else
        tmp_if_expr$3 = min.z;
      gmin->z = tmp_if_expr$3;
      if(gmax->x > max.x)
        tmp_if_expr$4 = gmax->x;

      else
        tmp_if_expr$4 = max.x;
      gmax->x = tmp_if_expr$4;
      if(gmax->y > max.y)
        tmp_if_expr$5 = gmax->y;

      else
        tmp_if_expr$5 = max.y;
      gmax->y = tmp_if_expr$5;
      if(gmax->z > max.z)
        tmp_if_expr$6 = gmax->z;

      else
        tmp_if_expr$6 = max.z;
      gmax->z = tmp_if_expr$6;
    }

    cur = (struct anon$15 *)cur->nextobj;
  }
}

// c::glwin_create
// file ../demosrc/glwin.c line 427
void * glwin_create(const char *wintitle, signed int width, signed int height)
{
  return NULL;
}

// c::glwin_destroy
// file ../demosrc/glwin.c line 431
void glwin_destroy(void *voidhandle)
{
  return;
}

// c::glwin_draw_image
// file ../demosrc/glwin.c line 443
void glwin_draw_image(void *voidhandle, signed int xsize, signed int ysize, unsigned char *img)
{
  return;
}

// c::glwin_handle_events
// file ../demosrc/glwin.c line 439
signed int glwin_handle_events(void *voidhandle)
{
  return 0;
}

// c::glwin_swap_buffers
// file ../demosrc/glwin.c line 435
void glwin_swap_buffers(void *voidhandle)
{
  return;
}

// c::gnoise_texture
// file ../src/texture.h line 25
struct anon$4 gnoise_texture(const struct anon$0 *hit, const struct anon$25 *tx, struct ray_t$link234 *ry)
{
  struct anon$4 col;
  double f;
  struct anon$35 *tex = (struct anon$35 *)tx;
  signed int return_value_Noise$1;
  return_value_Noise$1=Noise(hit->x - tex->ctr.x, hit->y - tex->ctr.y, hit->z - tex->ctr.z);
  f = (double)return_value_Noise$1;
  if(f < 1.000000e-2)
    f = 1.000000e-2;

  if(f > 1.000000)
    f = 1.000000;

  col.r = (float)((double)tex->col.r * f);
  col.g = (float)((double)tex->col.g * f);
  col.b = (float)((double)tex->col.b * f);
  return col;
}

// c::gnu_dev_major
// file /usr/include/x86_64-linux-gnu/sys/sysmacros.h line 44
unsigned int gnu_dev_major(unsigned long long int __dev)
{
  return (unsigned int)(__dev >> 8 & (unsigned long int)4095 | (unsigned long int)((unsigned int)(__dev >> 32) & (unsigned int)~4095));
}

// c::gnu_dev_makedev
// file /usr/include/x86_64-linux-gnu/sys/sysmacros.h line 56
unsigned long long int gnu_dev_makedev(unsigned int __major, unsigned int __minor)
{
  return (unsigned long int)(__minor & (unsigned int)255 | (__major & (unsigned int)4095) << 8) | (unsigned long long int)(__minor & (unsigned int)~255) << 12 | (unsigned long long int)(__major & (unsigned int)~4095) << 32;
}

// c::gnu_dev_minor
// file /usr/include/x86_64-linux-gnu/sys/sysmacros.h line 50
unsigned int gnu_dev_minor(unsigned long long int __dev)
{
  return (unsigned int)(__dev & (unsigned long int)255 | (unsigned long int)((unsigned int)(__dev >> 12) & (unsigned int)~255));
}

// c::grid_bbox
// file ../src/grid.c line 62
static signed int grid_bbox(void *obj, struct anon$0 *min, struct anon$0 *max)
{
  struct anon$50 *g = (struct anon$50 *)obj;
  *min = g->min;
  *max = g->max;
  return 1;
}

// c::grid_bounds_intersect
// file ../src/grid.c line 622
static signed int grid_bounds_intersect(const struct anon$50 *g, struct ray_t$link93 *ry, double *hitnear, double *hitfar)
{
  double a;
  double tx1;
  double tx2;
  double ty1;
  double ty2;
  double tz1;
  double tz2;
  double tnear;
  double tfar;
  tnear = -1.000000e+18;
  tfar = 1.000000e+18;
  _Bool tmp_if_expr$1;
  if(IEEE_FLOAT_EQUAL(ry->d.x, 0.000000))
  {
    if(ry->o.x < g->min.x)
      tmp_if_expr$1 = TRUE;

    else
      tmp_if_expr$1 = ry->o.x > g->max.x ? TRUE : FALSE;
    if(tmp_if_expr$1)
      return 0;

  }

  else
  {
    tx1 = (g->min.x - ry->o.x) / ry->d.x;
    tx2 = (g->max.x - ry->o.x) / ry->d.x;
    if(tx1 > tx2)
    {
      a = tx1;
      tx1 = tx2;
      tx2 = a;
    }

    if(tx1 > tnear)
      tnear = tx1;

    if(tx2 < tfar)
      tfar = tx2;

  }
  if(tnear > tfar)
    return 0;

  if(tfar < 0.000000)
    return 0;

  _Bool tmp_if_expr$2;
  if(IEEE_FLOAT_EQUAL(ry->d.y, 0.000000))
  {
    if(ry->o.y < g->min.y)
      tmp_if_expr$2 = TRUE;

    else
      tmp_if_expr$2 = ry->o.y > g->max.y ? TRUE : FALSE;
    if(tmp_if_expr$2)
      return 0;

  }

  else
  {
    ty1 = (g->min.y - ry->o.y) / ry->d.y;
    ty2 = (g->max.y - ry->o.y) / ry->d.y;
    if(ty1 > ty2)
    {
      a = ty1;
      ty1 = ty2;
      ty2 = a;
    }

    if(ty1 > tnear)
      tnear = ty1;

    if(ty2 < tfar)
      tfar = ty2;

  }
  if(tnear > tfar)
    return 0;

  if(tfar < 0.000000)
    return 0;

  _Bool tmp_if_expr$3;
  if(IEEE_FLOAT_EQUAL(ry->d.z, 0.000000))
  {
    if(ry->o.z < g->min.z)
      tmp_if_expr$3 = TRUE;

    else
      tmp_if_expr$3 = ry->o.z > g->max.z ? TRUE : FALSE;
    if(tmp_if_expr$3)
      return 0;

  }

  else
  {
    tz1 = (g->min.z - ry->o.z) / ry->d.z;
    tz2 = (g->max.z - ry->o.z) / ry->d.z;
    if(tz1 > tz2)
    {
      a = tz1;
      tz1 = tz2;
      tz2 = a;
    }

    if(tz1 > tnear)
      tnear = tz1;

    if(tz2 < tfar)
      tfar = tz2;

  }
  if(tnear > tfar)
    return 0;

  if(tfar < 0.000000)
    return 0;

  if(tnear < 0.000000)
    *hitnear = 0.000000;

  else
    *hitnear = tnear;
  *hitfar = tfar;
  return 1;
}

// c::grid_free
// file ../src/grid.c line 71
static void grid_free(void *v)
{
  signed int i;
  signed int numvoxels;
  struct anon$50 *g = (struct anon$50 *)v;
  numvoxels = g->xsize * g->ysize * g->zsize;
  i = 0;
  while(!(i >= numvoxels))
  {
    struct objectlist *lcur;
    struct objectlist *lnext;
    lcur = g->cells[(signed long int)i];
    while(!(lcur == ((struct objectlist *)NULL)))
    {
      lnext = lcur->next;
      free((void *)lcur);
      lcur = lnext;
    }
    i = i + 1;
  }
  free((void *)g->cells);
  free_objects(g->objects);
  free((void *)g);
}

// c::grid_intersect
// file ../src/grid.c line 465
static void grid_intersect(const struct anon$50 *g, struct ray_t$link93 *ry)
{
  double tnear;
  double tfar;
  struct anon$0 curpos;
  struct anon$0 tmax;
  struct anon$0 tdelta;
  struct anon$51 curvox;
  struct anon$51 step;
  struct anon$51 out;
  signed int voxindex;
  signed int SY;
  signed int SZ;
  unsigned long int serial;
  unsigned long int *mbox;
  struct objectlist *cur;
  if(!((8u & ry->flags) == 0u))
    return;

  signed int return_value_grid_bounds_intersect$1;
  return_value_grid_bounds_intersect$1=grid_bounds_intersect(g, ry, &tnear, &tfar);
  if(return_value_grid_bounds_intersect$1 == 0)
    return;

  if(ry->maxdist < tnear)
    return;

  serial = ry->serial;
  mbox = ry->mbox;
  curpos.x = ry->o.x + ry->d.x * tnear;
  curpos.y = ry->o.y + ry->d.y * tnear;
  curpos.z = ry->o.z + ry->d.z * tnear;
  curvox.x = (signed int)((double)(curpos.x - g->min.x) / g->voxsize.x);
  curvox.y = (signed int)((double)(curpos.y - g->min.y) / g->voxsize.y);
  curvox.z = (signed int)((double)(curpos.z - g->min.z) / g->voxsize.z);
  if(curvox.x == g->xsize)
    curvox.x = curvox.x - 1;

  if(curvox.y == g->ysize)
    curvox.y = curvox.y - 1;

  if(curvox.z == g->zsize)
    curvox.z = curvox.z - 1;

  if(ry->d.x < -5.000000e-8)
  {
    tmax.x = tnear + (((double)curvox.x * g->voxsize.x + g->min.x) - curpos.x) / ry->d.x;
    tdelta.x = g->voxsize.x / -ry->d.x;
    step.x = -1;
    out.x = -1;
  }

  else
    if(ry->d.x > 5.000000e-8)
    {
      tmax.x = tnear + (((double)(curvox.x + 1) * g->voxsize.x + g->min.x) - curpos.x) / ry->d.x;
      tdelta.x = g->voxsize.x / ry->d.x;
      step.x = 1;
      out.x = g->xsize;
    }

    else
    {
      tmax.x = 1.000000e+18;
      tdelta.x = 0.000000;
      step.x = 0;
      out.x = 0;
    }
  if(ry->d.y < -5.000000e-8)
  {
    tmax.y = tnear + (((double)curvox.y * g->voxsize.y + g->min.y) - curpos.y) / ry->d.y;
    tdelta.y = g->voxsize.y / -ry->d.y;
    step.y = -1;
    out.y = -1;
  }

  else
    if(ry->d.y > 5.000000e-8)
    {
      tmax.y = tnear + (((double)(curvox.y + 1) * g->voxsize.y + g->min.y) - curpos.y) / ry->d.y;
      tdelta.y = g->voxsize.y / ry->d.y;
      step.y = 1;
      out.y = g->ysize;
    }

    else
    {
      tmax.y = 1.000000e+18;
      tdelta.y = 0.000000;
      step.y = 0;
      out.y = 0;
    }
  if(ry->d.z < -5.000000e-8)
  {
    tmax.z = tnear + (((double)curvox.z * g->voxsize.z + g->min.z) - curpos.z) / ry->d.z;
    tdelta.z = g->voxsize.z / -ry->d.z;
    step.z = -1;
    out.z = -1;
  }

  else
    if(ry->d.z > 5.000000e-8)
    {
      tmax.z = tnear + (((double)(curvox.z + 1) * g->voxsize.z + g->min.z) - curpos.z) / ry->d.z;
      tdelta.z = g->voxsize.z / ry->d.z;
      step.z = 1;
      out.z = g->zsize;
    }

    else
    {
      tmax.z = 1.000000e+18;
      tdelta.z = 0.000000;
      step.z = 0;
      out.z = 0;
    }
  SY = step.y * g->xsize;
  SZ = step.z * g->xsize * g->ysize;
  voxindex = curvox.z * g->xsize * g->ysize + curvox.y * g->xsize + curvox.x;
  cur = g->cells[(signed long int)voxindex];
  while(!(cur == ((struct objectlist *)NULL)))
  {
    if(!(mbox[(signed long int)cur->obj->id] == serial))
    {
      mbox[(signed long int)cur->obj->id] = serial;
      cur->obj->methods->intersect((const void *)cur->obj, (void *)ry);
    }

    cur = cur->next;
  }
  while((8u & ry->flags) == 0u)
  {
    if(tmax.x < tmax.y)
    {
      if(!(tmax.x < tmax.z))
        goto __CPROVER_DUMP_L19;

      curvox.x = curvox.x + step.x;
      if(ry->maxdist < tmax.x || curvox.x == out.x)
        goto __CPROVER_DUMP_L25;

      tmax.x = tmax.x + tdelta.x;
      voxindex = voxindex + step.x;
    }

    else
    {

    __CPROVER_DUMP_L19:
      ;
      if(tmax.z < tmax.y)
      {
        curvox.z = curvox.z + step.z;
        if(ry->maxdist < tmax.z || curvox.z == out.z)
          goto __CPROVER_DUMP_L25;

        tmax.z = tmax.z + tdelta.z;
        voxindex = voxindex + SZ;
      }

      else
      {
        curvox.y = curvox.y + step.y;
        if(ry->maxdist < tmax.y || curvox.y == out.y)
          goto __CPROVER_DUMP_L25;

        tmax.y = tmax.y + tdelta.y;
        voxindex = voxindex + SY;
      }
    }
    cur = g->cells[(signed long int)voxindex];
    while(!(cur == ((struct objectlist *)NULL)))
    {
      if(!(mbox[(signed long int)cur->obj->id] == serial))
      {
        mbox[(signed long int)cur->obj->id] = serial;
        cur->obj->methods->intersect((const void *)cur->obj, (void *)ry);
      }

      cur = cur->next;
    }
  }

__CPROVER_DUMP_L25:
  ;
}

// c::gridstats
// file ../src/grid.c line 205
static void gridstats(signed int xs, signed int ys, signed int zs, signed int numobj)
{
  char t[256l];
  signed int numcells = xs * ys * zs;
  sprintf(t, "Grid:  X:%3d  Y:%3d  Z:%3d  Cells:%9d  Obj:%9d  Obj/Cell: %7.3f", xs, ys, zs, numcells, numobj, (float)numobj / (float)numcells);
  rt_ui_message(100, t);
}

// c::grit_texture
// file ../src/texture.h line 22
struct anon$4 grit_texture(const struct anon$0 *hit, const struct anon$25 *tx, struct ray_t$link234 *ry)
{
  signed int rnum;
  double fnum;
  struct anon$4 col;
  struct anon$35 *tex = (struct anon$35 *)tx;
  signed int return_value_rand$1;
  return_value_rand$1=rand();
  rnum = return_value_rand$1 % 4096;
  fnum = ((double)rnum / 4096.000000) * 2.000000e-1 + 8.000000e-1;
  col.r = (float)((double)tex->col.r * fnum);
  col.g = (float)((double)tex->col.g * fnum);
  col.b = (float)((double)tex->col.b * fnum);
  return col;
}

// c::hash
// file ../src/hash.c line 30
static signed int hash(struct rt_hash_t *tptr, const char *key)
{
  signed int i = 0;
  signed int hashvalue;
  const char *tmp_post$1;
  while(!((signed int)*key == 0))
  {
    tmp_post$1 = key;
    key = key + 1l;
    i = (i << 3) + ((signed int)*tmp_post$1 - 48);
  }
  hashvalue = i * 1103515249 >> tptr->downshift & tptr->mask;
  if(hashvalue < 0)
    hashvalue = 0;

  return hashvalue;
}

// c::image_crop_rgb24
// file ../src/imageio.h line 29
unsigned char * image_crop_rgb24(signed int xres, signed int yres, unsigned char *img, signed int szx, signed int szy, signed int sx, signed int sy)
{
  unsigned char *cropped;
  signed int x;
  signed int y;
  void *return_value_malloc$1;
  return_value_malloc$1=malloc((unsigned long int)(szx * szy * 3) * 1ul /*[[unsigned char]]*/);
  cropped = (unsigned char *)return_value_malloc$1;
  memset((void *)cropped, 0, (unsigned long int)(szx * szy * 3) * 1ul /*[[unsigned char]]*/);
  y = 0;
  while(!(y >= szy))
  {
    signed int oaddr = ((y + sy) * xres + sx) * 3;
    if(y + sy >= 0)
    {
      if(!(y + sy >= yres))
      {
        x = 0;
        while(!(x >= szx))
        {
          if(x + sx >= 0)
          {
            if(!(x + sx >= xres))
            {
              signed int addr = (szx * y + x) * 3;
              cropped[(signed long int)addr] = img[(signed long int)(oaddr + x * 3)];
              cropped[(signed long int)(addr + 1)] = img[(signed long int)(oaddr + x * 3 + 1)];
              cropped[(signed long int)(addr + 2)] = img[(signed long int)(oaddr + x * 3 + 2)];
            }

          }

          x = x + 1;
        }
      }

    }

    y = y + 1;
  }
  return cropped;
}

// c::image_crop_rgb96f
// file ../src/imageio.h line 27
float * image_crop_rgb96f(signed int xres, signed int yres, float *fimg, signed int szx, signed int szy, signed int sx, signed int sy)
{
  float *cropped;
  signed int x;
  signed int y;
  void *return_value_malloc$1;
  return_value_malloc$1=malloc((unsigned long int)(szx * szy * 3) * 4ul /*[[float]]*/);
  cropped = (float *)return_value_malloc$1;
  memset((void *)cropped, 0, (unsigned long int)(szx * szy * 3) * 4ul /*[[float]]*/);
  y = 0;
  while(!(y >= szy))
  {
    signed int oaddr = ((y + sy) * xres + sx) * 3;
    if(y + sy >= 0)
    {
      if(!(y + sy >= yres))
      {
        x = 0;
        while(!(x >= szx))
        {
          if(x + sx >= 0)
          {
            if(!(x + sx >= xres))
            {
              signed int addr = (szx * y + x) * 3;
              cropped[(signed long int)addr] = fimg[(signed long int)(oaddr + x * 3)];
              cropped[(signed long int)(addr + 1)] = fimg[(signed long int)(oaddr + x * 3 + 1)];
              cropped[(signed long int)(addr + 2)] = fimg[(signed long int)(oaddr + x * 3 + 2)];
            }

          }

          x = x + 1;
        }
      }

    }

    y = y + 1;
  }
  return cropped;
}

// c::image_cyl_texture
// file ../src/texture.h line 16
struct anon$4 image_cyl_texture(const struct anon$0 *hit, const struct anon$25 *tx, struct ray_t$link234 *ry)
{
  struct anon$0 rh;
  double u;
  double v;
  double miprad;
  double maxscale;
  double cyrad;
  struct anon$35 *tex = (struct anon$35 *)tx;
  rh.x = hit->x - tex->ctr.x;
  rh.z = hit->y - tex->ctr.y;
  rh.y = hit->z - tex->ctr.z;
  xyztocyl(rh, 1.000000, &u, &v);
  u = u * tex->scale.x;
  u = u + tex->rot.x;
  u = u - (double)(signed int)u;
  if(u < 0.000000)
    u = u + 1.000000;

  v = v * tex->scale.y;
  v = v + tex->rot.y;
  v = v - (double)(signed int)v;
  if(v < 0.000000)
    v = v + 1.000000;

  double return_value_sqrt$1;
  return_value_sqrt$1=sqrt(rh.x * rh.x + rh.y * rh.y + rh.z * rh.z);
  cyrad = 5.000000e-8 + 8.000000 * return_value_sqrt$1;
  double return_value_fabs$2;
  return_value_fabs$2=fabs(tex->scale.x);
  double return_value_fabs$3;
  return_value_fabs$3=fabs(tex->scale.y);
  double tmp_if_expr$4;
  if(return_value_fabs$2 > return_value_fabs$3)
    tmp_if_expr$4 = tex->scale.x;

  else
    tmp_if_expr$4 = tex->scale.y;
  maxscale = tmp_if_expr$4;
  double return_value_fabs$5;
  return_value_fabs$5=fabs(maxscale);
  miprad = (5.000000e-2 * ry->opticdist * return_value_fabs$5) / cyrad;
  struct anon$4 return_value_MIPMap$6;
  return_value_MIPMap$6=MIPMap((const struct anon$34 *)tex->img, u, v, miprad);
  return return_value_MIPMap$6;
}

// c::image_plane_texture
// file ../src/texture.h line 18
struct anon$4 image_plane_texture(const struct anon$0 *hit, const struct anon$25 *tx, struct ray_t$link234 *ry)
{
  struct anon$0 pnt;
  double u;
  double v;
  double miprad;
  double maxscale;
  struct anon$35 *tex = (struct anon$35 *)tx;
  pnt.x = hit->x - tex->ctr.x;
  pnt.y = hit->y - tex->ctr.y;
  pnt.z = hit->z - tex->ctr.z;
  u = tex->uaxs.x * pnt.x + tex->uaxs.y * pnt.y + tex->uaxs.z * pnt.z;
  v = tex->vaxs.x * pnt.x + tex->vaxs.y * pnt.y + tex->vaxs.z * pnt.z;
  u = u * tex->scale.x;
  u = u + tex->rot.x;
  u = u - (double)(signed int)u;
  if(u < 0.000000)
    u = u + 1.000000;

  v = v * tex->scale.y;
  v = v + tex->rot.y;
  v = v - (double)(signed int)v;
  if(v < 0.000000)
    v = v + 1.000000;

  double return_value_fabs$1;
  return_value_fabs$1=fabs(tex->scale.x);
  double return_value_fabs$2;
  return_value_fabs$2=fabs(tex->scale.y);
  double tmp_if_expr$3;
  if(return_value_fabs$1 > return_value_fabs$2)
    tmp_if_expr$3 = tex->scale.x;

  else
    tmp_if_expr$3 = tex->scale.y;
  maxscale = tmp_if_expr$3;
  double return_value_fabs$4;
  return_value_fabs$4=fabs(maxscale);
  miprad = 5.000000e-2 * ry->opticdist * return_value_fabs$4;
  struct anon$4 return_value_MIPMap$5;
  return_value_MIPMap$5=MIPMap((const struct anon$34 *)tex->img, u, v, miprad);
  return return_value_MIPMap$5;
}

// c::image_rgb24_from_rgb96f
// file ../src/imageio.c line 150
unsigned char * image_rgb24_from_rgb96f(signed int xres, signed int yres, float *fimg)
{
  unsigned char *img;
  signed int x;
  signed int y;
  signed int R;
  signed int G;
  signed int B;
  void *return_value_malloc$1;
  return_value_malloc$1=malloc((unsigned long int)(xres * yres * 3));
  img = (unsigned char *)return_value_malloc$1;
  y = 0;
  while(!(y >= yres))
  {
    x = 0;
    while(!(x >= xres))
    {
      signed int addr = (xres * y + x) * 3;
      R = (signed int)(fimg[(signed long int)addr] * 255.000000f);
      G = (signed int)(fimg[(signed long int)(addr + 1)] * 255.000000f);
      B = (signed int)(fimg[(signed long int)(addr + 2)] * 255.000000f);
      if(R > 255)
        R = 255;

      if(R < 0)
        R = 0;

      img[(signed long int)addr] = (unsigned char)R;
      if(G > 255)
        G = 255;

      if(G < 0)
        G = 0;

      img[(signed long int)(addr + 1)] = (unsigned char)G;
      if(B > 255)
        B = 255;

      if(B < 0)
        B = 0;

      img[(signed long int)(addr + 2)] = (unsigned char)B;
      x = x + 1;
    }
    y = y + 1;
  }
  return img;
}

// c::image_rgb48be_from_rgb96f
// file ../src/imageio.c line 232
unsigned char * image_rgb48be_from_rgb96f(signed int xres, signed int yres, float *fimg)
{
  signed int x;
  signed int y;
  signed int R;
  signed int G;
  signed int B;
  unsigned char *img;
  void *return_value_malloc$1;
  return_value_malloc$1=malloc((unsigned long int)(xres * yres * 6));
  img = (unsigned char *)return_value_malloc$1;
  y = 0;
  while(!(y >= yres))
  {
    x = 0;
    while(!(x >= xres))
    {
      signed int faddr = (xres * y + x) * 3;
      signed int iaddr = faddr * 2;
      R = (signed int)(fimg[(signed long int)faddr] * 65535.000000f);
      G = (signed int)(fimg[(signed long int)(faddr + 1)] * 65535.000000f);
      B = (signed int)(fimg[(signed long int)(faddr + 2)] * 65535.000000f);
      if(R > 65535)
        R = 65535;

      if(R < 0)
        R = 0;

      img[(signed long int)iaddr] = (unsigned char)(R >> 8 & 255);
      img[(signed long int)(iaddr + 1)] = (unsigned char)(R & 255);
      if(G > 65535)
        G = 65535;

      if(G < 0)
        G = 0;

      img[(signed long int)(iaddr + 2)] = (unsigned char)(G >> 8 & 255);
      img[(signed long int)(iaddr + 3)] = (unsigned char)(G & 255);
      if(B > 65535)
        B = 65535;

      if(B < 0)
        B = 0;

      img[(signed long int)(iaddr + 4)] = (unsigned char)(B >> 8 & 255);
      img[(signed long int)(iaddr + 5)] = (unsigned char)(B & 255);
      x = x + 1;
    }
    y = y + 1;
  }
  return img;
}

// c::image_rgb48bepl_from_rgb96f
// file ../src/imageio.c line 266
unsigned char * image_rgb48bepl_from_rgb96f(signed int xres, signed int yres, float *fimg)
{
  signed int x;
  signed int y;
  signed int R;
  signed int G;
  signed int B;
  signed int sz;
  unsigned char *img;
  void *return_value_malloc$1;
  return_value_malloc$1=malloc((unsigned long int)(xres * yres * 6));
  img = (unsigned char *)return_value_malloc$1;
  sz = xres * yres * 2;
  y = 0;
  while(!(y >= yres))
  {
    x = 0;
    while(!(x >= xres))
    {
      signed int addr = xres * y + x;
      signed int faddr = addr * 3;
      signed int iaddr = addr * 2;
      signed int raddr = iaddr;
      signed int gaddr = iaddr + sz;
      signed int baddr = iaddr + sz * 2;
      R = (signed int)(fimg[(signed long int)faddr] * 65535.000000f);
      G = (signed int)(fimg[(signed long int)(faddr + 1)] * 65535.000000f);
      B = (signed int)(fimg[(signed long int)(faddr + 2)] * 65535.000000f);
      if(R > 65535)
        R = 65535;

      if(R < 0)
        R = 0;

      img[(signed long int)raddr] = (unsigned char)(R >> 8 & 255);
      img[(signed long int)(raddr + 1)] = (unsigned char)(R & 255);
      if(G > 65535)
        G = 65535;

      if(G < 0)
        G = 0;

      img[(signed long int)gaddr] = (unsigned char)(G >> 8 & 255);
      img[(signed long int)(gaddr + 1)] = (unsigned char)(G & 255);
      if(B > 65535)
        B = 65535;

      if(B < 0)
        B = 0;

      img[(signed long int)baddr] = (unsigned char)(B >> 8 & 255);
      img[(signed long int)(baddr + 1)] = (unsigned char)(B & 255);
      x = x + 1;
    }
    y = y + 1;
  }
  return img;
}

// c::image_sphere_texture
// file ../src/texture.h line 17
struct anon$4 image_sphere_texture(const struct anon$0 *hit, const struct anon$25 *tx, struct ray_t$link234 *ry)
{
  struct anon$0 rh;
  double u;
  double v;
  double miprad;
  double maxscale;
  double sprad;
  struct anon$35 *tex = (struct anon$35 *)tx;
  rh.x = hit->x - tex->ctr.x;
  rh.y = hit->y - tex->ctr.y;
  rh.z = hit->z - tex->ctr.z;
  xyztospr(rh, &u, &v);
  u = u * tex->scale.x;
  u = u + tex->rot.x;
  u = u - (double)(signed int)u;
  if(u < 0.000000)
    u = u + 1.000000;

  v = v * tex->scale.y;
  v = v + tex->rot.y;
  v = v - (double)(signed int)v;
  if(v < 0.000000)
    v = v + 1.000000;

  double return_value_sqrt$1;
  return_value_sqrt$1=sqrt(rh.x * rh.x + rh.y * rh.y + rh.z * rh.z);
  sprad = 5.000000e-8 + 8.000000 * return_value_sqrt$1;
  double return_value_fabs$2;
  return_value_fabs$2=fabs(tex->scale.x);
  double return_value_fabs$3;
  return_value_fabs$3=fabs(tex->scale.y);
  double tmp_if_expr$4;
  if(return_value_fabs$2 > return_value_fabs$3)
    tmp_if_expr$4 = tex->scale.x;

  else
    tmp_if_expr$4 = tex->scale.y;
  maxscale = tmp_if_expr$4;
  double return_value_fabs$5;
  return_value_fabs$5=fabs(maxscale);
  miprad = (5.000000e-2 * ry->opticdist * return_value_fabs$5) / sprad;
  struct anon$4 return_value_MIPMap$6;
  return_value_MIPMap$6=MIPMap((const struct anon$34 *)tex->img, u, v, miprad);
  return return_value_MIPMap$6;
}

// c::image_volume_texture
// file ../src/texture.h line 19
struct anon$4 image_volume_texture(const struct anon$0 *hit, const struct anon$25 *tx, struct ray_t$link234 *ry)
{
  struct anon$0 pnt;
  double u;
  double v;
  double w;
  double miprad;
  double maxscale;
  struct anon$35 *tex = (struct anon$35 *)tx;
  pnt.x = hit->x - tex->ctr.x;
  pnt.y = hit->y - tex->ctr.y;
  pnt.z = hit->z - tex->ctr.z;
  u = tex->uaxs.x * pnt.x + tex->uaxs.y * pnt.y + tex->uaxs.z * pnt.z;
  v = tex->vaxs.x * pnt.x + tex->vaxs.y * pnt.y + tex->vaxs.z * pnt.z;
  w = tex->waxs.x * pnt.x + tex->waxs.y * pnt.y + tex->waxs.z * pnt.z;
  u = u * tex->scale.x;
  u = u + tex->rot.x;
  u = u - (double)(signed int)u;
  if(u < 0.000000)
    u = u + 1.000000;

  v = v * tex->scale.y;
  v = v + tex->rot.y;
  v = v - (double)(signed int)v;
  if(v < 0.000000)
    v = v + 1.000000;

  w = w * tex->scale.z;
  w = w + tex->rot.z;
  w = w - (double)(signed int)w;
  if(w < 0.000000)
    w = w + 1.000000;

  double return_value_fabs$1;
  return_value_fabs$1=fabs(tex->scale.x);
  double return_value_fabs$2;
  return_value_fabs$2=fabs(tex->scale.y);
  double tmp_if_expr$3;
  if(return_value_fabs$1 > return_value_fabs$2)
    tmp_if_expr$3 = tex->scale.x;

  else
    tmp_if_expr$3 = tex->scale.y;
  maxscale = tmp_if_expr$3;
  double return_value_fabs$4;
  return_value_fabs$4=fabs(tex->scale.z);
  double return_value_fabs$5;
  return_value_fabs$5=fabs(maxscale);
  if(return_value_fabs$4 > return_value_fabs$5)
    maxscale = tex->scale.z;

  double return_value_fabs$6;
  return_value_fabs$6=fabs(maxscale);
  miprad = 5.000000e-2 * ry->opticdist * return_value_fabs$6;
  struct anon$4 return_value_VolMIPMap$7;
  return_value_VolMIPMap$7=VolMIPMap((const struct anon$34 *)tex->img, u, v, w, miprad);
  return return_value_VolMIPMap$7;
}

// c::initoptions
// file ../demosrc/getargs.c line 127
static void initoptions(struct anon$1 *opt)
{
  memset((void *)opt, 0, 12408ul /*[[struct anon$1]]*/);
  void *return_value_malloc$1;
  return_value_malloc$1=malloc(8ul /*[[char *]]*/ * (unsigned long int)10);
  opt->filenames = (char **)return_value_malloc$1;
  opt->numfiles = 0;
  opt->useoutfilename = -1;
  opt->outimageformat = -1;
  opt->xsize = 0;
  opt->ysize = 0;
  opt->verbosemode = -1;
  opt->aa_maxsamples = -1;
  opt->boundmode = -1;
  opt->boundthresh = -1;
  opt->usecamfile = -1;
  opt->shadermode = -1;
  opt->phongfunc = -1;
  opt->transmode = -1;
  opt->fogmode = -1;
  opt->normalfixupmode = -1;
  opt->imgprocess = -1;
  opt->imggamma = (float)1.000000;
  opt->numthreads = -1;
  opt->nosave = -1;
  opt->rescale_lights = (float)1.000000;
  opt->auto_skylight = (float)0.000000;
  opt->add_skylight = (float)0.000000;
  opt->skylight_samples = 128;
  opt->cropmode = 0;
  opt->cropxres = 0;
  opt->cropyres = 0;
  opt->cropxstart = 0;
  opt->cropystart = 0;
}

// c::intersect_objects
// file ../src/intersect.h line 10
void intersect_objects(struct ray_t$link0 *ry)
{
  struct anon$15 *cur;
  struct anon$15 temp;
  ry->intstruct.num = 0;
  ry->intstruct.shadowfilter = 1.000000;
  temp.nextobj = (void *)ry->scene->objgroup.unboundedobj;
  cur = &temp;
  do
  {
    cur = (struct anon$15 *)cur->nextobj;
    if(cur == ((struct anon$15 *)NULL))
      goto __CPROVER_DUMP_L2;

    cur->methods->intersect((const void *)cur, (void *)ry);
  }
  while(TRUE);

__CPROVER_DUMP_L2:
  ;
  temp.nextobj = (void *)ry->scene->objgroup.boundedobj;
  cur = &temp;
  do
  {
    cur = (struct anon$15 *)cur->nextobj;
    if(cur == ((struct anon$15 *)NULL))
      goto __CPROVER_DUMP_L4;

    cur->methods->intersect((const void *)cur, (void *)ry);
  }
  while(TRUE);

__CPROVER_DUMP_L4:
  ;
}

// c::jitter_disc2f
// file ../src/util.c line 596
void jitter_disc2f(unsigned int *pval, float *dir)
{
  float dx;
  float dy;
  do
  {
    unsigned int return_value_rt_rand$1;
    return_value_rt_rand$1=rt_rand(pval);
    dx = (float)((double)return_value_rt_rand$1 / 4.294967e+9 - (double)5.000000e-1f);
    unsigned int return_value_rt_rand$2;
    return_value_rt_rand$2=rt_rand(pval);
    dy = (float)((double)return_value_rt_rand$2 / 4.294967e+9 - (double)5.000000e-1f);
  }
  while(dx * dx + dy * dy > 2.500000e-1f);
  dir[(signed long int)0] = dx;
  dir[(signed long int)1] = dy;
}

// c::jitter_offset2f
// file ../src/util.h line 89
void jitter_offset2f(unsigned int *pval, float *xy)
{
  unsigned int return_value_rt_rand$1;
  return_value_rt_rand$1=rt_rand(pval);
  xy[(signed long int)0] = (float)((double)return_value_rt_rand$1 / 4.294967e+9 - 5.000000e-1);
  unsigned int return_value_rt_rand$2;
  return_value_rt_rand$2=rt_rand(pval);
  xy[(signed long int)1] = (float)((double)return_value_rt_rand$2 / 4.294967e+9 - 5.000000e-1);
}

// c::jitter_sphere3f
// file ../src/util.c line 608
void jitter_sphere3f(struct anon$18 *rngh, float *dir)
{
  float dx;
  float dy;
  float dz;
  float len;
  float invlen;
  do
  {
    float return_value_rng_frand$1;
    return_value_rng_frand$1=rng_frand(rngh);
    dx = return_value_rng_frand$1 - 5.000000e-1f;
    float return_value_rng_frand$2;
    return_value_rng_frand$2=rng_frand(rngh);
    dy = return_value_rng_frand$2 - 5.000000e-1f;
    float return_value_rng_frand$3;
    return_value_rng_frand$3=rng_frand(rngh);
    dz = return_value_rng_frand$3 - 5.000000e-1f;
    len = dx * dx + dy * dy + dz * dz;
  }
  while(len > 2.500000e-1f);
  double return_value_sqrt$4;
  return_value_sqrt$4=sqrt((double)len);
  invlen = (float)((double)1.000000f / return_value_sqrt$4);
  dir[(signed long int)0] = dx * invlen;
  dir[(signed long int)1] = dy * invlen;
  dir[(signed long int)2] = dz * invlen;
}

// c::lgamma
// file /usr/include/x86_64-linux-gnu/bits/math-finite.h line 256
double lgamma(double __d)
{
  signed int __local_signgam = 0;
  double return_value_lgamma_r$1;
  return_value_lgamma_r$1=lgamma_r(__d, &__local_signgam);
  return return_value_lgamma_r$1;
}

// c::lgammaf
// file /usr/include/x86_64-linux-gnu/bits/math-finite.h line 265
float lgammaf(float __d)
{
  signed int __local_signgam = 0;
  float return_value_lgammaf_r$1;
  return_value_lgammaf_r$1=lgammaf_r(__d, &__local_signgam);
  return return_value_lgammaf_r$1;
}

// c::lgammal
// file /usr/include/x86_64-linux-gnu/bits/math-finite.h line 275
long double lgammal(long double __d)
{
  signed int __local_signgam = 0;
  long double return_value_lgammal_r$1;
  return_value_lgammal_r$1=lgammal_r(__d, &__local_signgam);
  return return_value_lgammal_r$1;
}

// c::light_bbox
// file ../src/light.c line 234
static signed int light_bbox(void *obj, struct anon$0 *min, struct anon$0 *max)
{
  return 0;
}

// c::light_complex_attenuation
// file ../src/light.c line 201
static double light_complex_attenuation(void *vli, double Llen)
{
  struct point_light_t$link242 *li = (struct point_light_t$link242 *)vli;
  return 1.000000 / (li->Kc + (li->Kl + li->Kq * Llen) * Llen);
}

// c::light_intersect
// file ../src/light.c line 239
static void light_intersect(struct point_light_t$link242 *l, struct ray_t$link255 *ry)
{
  double b;
  double disc;
  double t1;
  double t2;
  double temp;
  struct anon$0 V;
  if(!((4u & ry->flags) == 0u))
    return;

  V.x = l->ctr.x - ry->o.x;
  V.y = l->ctr.y - ry->o.y;
  V.z = l->ctr.z - ry->o.z;
  b = V.x * ry->d.x + V.y * ry->d.y + V.z * ry->d.z;
  temp = V.x * V.x + V.y * V.y + V.z * V.z;
  disc = (b * b + l->rad * l->rad) - temp;
  if(disc <= 0.000000)
    return;

  disc=sqrt(disc);
  t2 = b + disc;
  if(t2 <= 5.000000e-8)
    return;

  ry->add_intersection(t2, (struct anon$15 *)l, ry);
  t1 = b - disc;
  if(t1 > 5.000000e-8)
    ry->add_intersection(t1, (struct anon$15 *)l, ry);

}

// c::light_no_attenuation
// file ../src/light.c line 197
static double light_no_attenuation(void *vli, double Llen)
{
  return 1.000000;
}

// c::light_no_falloff
// file ../src/light.c line 210
static double light_no_falloff(void *vli, struct anon$0 *L)
{
  return 1.000000;
}

// c::light_normal
// file ../src/light.c line 266
static void light_normal(struct point_light_t$link242 *l, const struct anon$0 *pnt, struct ray_t$link255 *incident, struct anon$0 *N)
{
  double invlen;
  N->x = pnt->x - l->ctr.x;
  N->y = pnt->y - l->ctr.y;
  N->z = pnt->z - l->ctr.z;
  double return_value_sqrt$1;
  return_value_sqrt$1=sqrt(N->x * N->x + N->y * N->y + N->z * N->z);
  invlen = 1.000000 / return_value_sqrt$1;
  N->x = N->x * invlen;
  N->y = N->y * invlen;
  N->z = N->z * invlen;
  double return_value_VDot$2;
  return_value_VDot$2=VDot(N, &incident->d);
  if(return_value_VDot$2 > 0.000000)
  {
    N->x = -N->x;
    N->y = -N->y;
    N->z = -N->z;
  }

}

// c::light_set_attenuation
// file ../src/light.h line 48
void light_set_attenuation(struct point_light_t$link242 *li, double Kc, double Kl, double Kq)
{
  li->Kc = Kc;
  li->Kl = Kl;
  li->Kq = Kq;
  li->attenuationfunc = light_complex_attenuation;
  li->shade_diffuse = point_light_shade_diffuse;
}

// c::light_spotlight_falloff
// file ../src/light.c line 215
static double light_spotlight_falloff(void *vli, struct anon$0 *L)
{
  struct point_light_t$link242 *li = (struct point_light_t$link242 *)vli;
  double ang;
  double cang = li->spotdir.x * L->x + li->spotdir.y * L->y + li->spotdir.z * L->z;
  ang=acos(-cang);
  if(ang > li->fallstart)
  {
    if(ang > li->fallend)
      return 0.000000;

    else
      return 1.000000 - (ang - li->fallstart) / (li->fallend - li->fallstart);
  }

  return 1.000000;
}

// c::low_shader
// file ../src/shade.h line 11
struct anon$4 low_shader(struct ray_t$link1 *incident)
{
  signed int numints;
  const struct anon$15 *obj;
  struct anon$0 hit;
  double t = 1.000000e+18;
  numints=closest_intersection(&t, &obj, incident);
  if(numints < 1)
  {
    struct anon$4 return_value;
    return_value=incident->scene->bgtexfunc(incident);
    return return_value;
  }

  hit.x = incident->o.x + incident->d.x * t;
  hit.y = incident->o.y + incident->d.y * t;
  hit.z = incident->o.z + incident->d.z * t;
  incident->opticdist = 1.000000e+18;
  struct anon$4 return_value_1;
  return_value_1=obj->tex->texfunc((const void *)&hit, (const void *)obj->tex, (void *)incident);
  return return_value_1;
}

// c::lowest_shader
// file ../src/shade.h line 10
struct anon$4 lowest_shader(struct ray_t$link1 *incident)
{
  signed int numints;
  const struct anon$15 *obj;
  double t = 1.000000e+18;
  struct anon$4 col;
  numints=closest_intersection(&t, &obj, incident);
  if(numints < 1)
  {
    col.r = (float)0.000000;
    col.g = (float)0.000000;
    col.b = (float)0.000000;
    return col;
  }

  col.r = (float)1.000000;
  col.g = (float)1.000000;
  col.b = (float)1.000000;
  return col;
}

// c::lstat
// file /usr/include/x86_64-linux-gnu/sys/stat.h line 461
signed int lstat(const char *__path, struct stat *__statbuf)
{
  signed int return_value___lxstat$1;
  return_value___lxstat$1=__lxstat(1, __path, __statbuf);
  return return_value___lxstat$1;
}

// c::main
// file ../demosrc/main.c line 331
signed int main(signed int argc, char **argv)
{
  void *scene;
  unsigned int rc;
  struct anon$1 opt;
  char *filename;
  signed int node;
  signed int fileindex;
  void *parsetimer;
  node=rt_initialize(&argc, &argv);
  rt_set_ui_message(my_ui_message);
  rt_set_ui_progress(my_ui_progress);
  if(node == 0)
  {
    printf("Tachyon Parallel/Multiprocessor Ray Tracer   Version %s   \n", (const void *)"0.98.9");
    printf("Copyright 1994-2010,    John E. Stone <john.stone@gmail.com> \n");
    printf("------------------------------------------------------------ \n");
  }

  signed int return_value_getargs$1;
  return_value_getargs$1=getargs(argc, argv, &opt, node);
  rc = (unsigned int)return_value_getargs$1;
  if(!(rc == 0u))
  {
    rt_finalize();
    exit((signed int)rc);
  }

  if(opt.numfiles > 1)
    printf("Rendering %d scene files.\n", opt.numfiles);

  fileindex = 0;
  _Bool tmp_if_expr$7;
  char *return_value_strstr$6;
  char *return_value_strstr$2;
  _Bool tmp_if_expr$4;
  char *return_value_strstr$3;
  double return_value_rt_timer_time$8;
  unsigned long int return_value_strlen$11;
  while(!(fileindex >= opt.numfiles))
  {
    scene=rt_newscene();
    presceneoptions(&opt, scene);
    filename = opt.filenames[(signed long int)fileindex];
    if(opt.numfiles > 1)
      printf("\nRendering scene file %d of %d, %s\n", fileindex + 1, opt.numfiles, filename);

    parsetimer=rt_timer_create();
    rt_timer_start(parsetimer);
    char *return_value_strstr$5;
    return_value_strstr$5=strstr(filename, ".nff");
    if(!(return_value_strstr$5 == ((char *)NULL)))
      tmp_if_expr$7 = TRUE;

    else
    {
      return_value_strstr$6=strstr(filename, ".NFF");
      tmp_if_expr$7 = return_value_strstr$6 != ((char *)NULL) ? TRUE : FALSE;
    }
    if(tmp_if_expr$7)
      rc=ParseNFF(filename, scene);

    else
    {
      return_value_strstr$2=strstr(filename, ".ac");
      if(!(return_value_strstr$2 == ((char *)NULL)))
        tmp_if_expr$4 = TRUE;

      else
      {
        return_value_strstr$3=strstr(filename, ".AC");
        tmp_if_expr$4 = return_value_strstr$3 != ((char *)NULL) ? TRUE : FALSE;
      }
      if(tmp_if_expr$4)
        rc=ParseAC3D(filename, scene);

      else
        rc=readmodel(filename, scene);
    }
    rt_timer_stop(parsetimer);
    if(rc == 0u)
    {
      if(node == 0)
      {
        return_value_rt_timer_time$8=rt_timer_time(parsetimer);
        printf("Scene Parsing Time: %10.4f seconds\n", return_value_rt_timer_time$8);
      }

    }

    rt_timer_destroy(parsetimer);
    if(!(rc == 0u))
    {
      if(!(node == 0))
        goto __CPROVER_DUMP_L22;

      switch(rc)
      {

        case (unsigned int)1:
          {
            printf("Parser failed due to nonexistent input file: %s\n", filename);
            goto __CPROVER_DUMP_L19;
          }
        case (unsigned int)2:
          {
            printf("Parser failed due to nonexistent included file.\n");
            goto __CPROVER_DUMP_L19;
          }
        case (unsigned int)4:
          {
            printf("Parser failed due to an input file syntax error.\n");
            goto __CPROVER_DUMP_L19;
          }
        case (unsigned int)8:
          {
            printf("Parser unexpectedly hit an end of file.\n");
            goto __CPROVER_DUMP_L19;
          }
        case (unsigned int)16:
          printf("Parser ran out of memory.\n");
        default:
          {

          __CPROVER_DUMP_L19:
            ;
            if(!(1 + fileindex >= opt.numfiles))
              printf("Aborting render, continuing with next scene file...\n");

            else
              printf("Aborting render.\n");
            rt_deletescene(scene);
          }
      }
    }

    else
    {

    __CPROVER_DUMP_L22:
      ;
      postsceneoptions(&opt, scene);
      if(opt.usecamfile == 1)
      {
        signed int return_value_animate_scene$9;
        return_value_animate_scene$9=animate_scene(opt, scene, node);
        return return_value_animate_scene$9;
      }

      else
      {
        return_value_strlen$11=strlen(opt.spaceball);
        if(return_value_strlen$11 > 0ul)
        {
          signed int return_value_fly_scene$10;
          return_value_fly_scene$10=fly_scene(opt, scene, node);
          return return_value_fly_scene$10;
        }

        else
        {
          if(opt.numfiles > 1)
          {
            if(!(opt.nosave == 1))
            {
              char multioutfilename[4096l];
              sprintf(multioutfilename, opt.outfilename, fileindex);
              rt_outputfile(scene, multioutfilename);
            }

          }

          rt_renderscene(scene);
        }
      }
      rt_deletescene(scene);
    }
    fileindex = fileindex + 1;
  }
  rt_finalize();
  freeoptions(&opt);
  return 0;
}

// c::marble_texture
// file ../src/texture.h line 24
struct anon$4 marble_texture(const struct anon$0 *hit, const struct anon$25 *tx, struct ray_t$link234 *ry)
{
  double i;
  double d;
  double x;
  double y;
  double z;
  struct anon$4 col;
  x = hit->x;
  y = hit->y;
  z = hit->z;
  x = x * 1.000000;
  signed int return_value_Noise$1;
  return_value_Noise$1=Noise(x, y * 1.000000, z * 1.000000);
  d = x + 6.000000e-4 * (double)return_value_Noise$1;
  d = d * (double)((signed int)d % 25);
  double return_value_fabs$2;
  return_value_fabs$2=fabs((d - 10.000000) - 20.000000 * (double)(signed int)d * 5.000000e-2);
  i = 0.000000 + 1.000000e-1 * return_value_fabs$2;
  if(i > 1.000000)
    i = 1.000000;

  if(i < 0.000000)
    i = 0.000000;

  double return_value_sin$3;
  return_value_sin$3=sin(i * 6.280000e+0);
  col.r = (float)((1.000000 + return_value_sin$3) / 2.000000);
  double return_value_sin$4;
  return_value_sin$4=sin(i * 1.628000e+1);
  col.g = (float)((1.000000 + return_value_sin$4) / 2.000000);
  double return_value_cos$5;
  return_value_cos$5=cos(i * 3.028000e+1);
  col.b = (float)((1.000000 + return_value_cos$5) / 2.000000);
  return col;
}

// c::max_objectid
// file ../src/intersect.c line 16
unsigned int max_objectid(struct anon$32$link4 *scene)
{
  return (unsigned int)scene->objgroup.numobjects;
}

// c::mbstowcs
// file /usr/include/x86_64-linux-gnu/bits/stdlib.h line 113
unsigned long int mbstowcs(signed int * restrict __dst, const char * restrict __src, unsigned long int __len)
{
  unsigned long int return_value___mbstowcs_chk$1;
  unsigned long int return_value___mbstowcs_chk_warn$2;
  unsigned long int return_value___mbstowcs_alias$3;
  return_value___mbstowcs_alias$3=__mbstowcs_alias(__dst, __src, __len);
  return return_value___mbstowcs_alias$3;
}

// c::medium_shader
// file ../src/shade.h line 12
struct anon$4 medium_shader(struct ray_t$link1 *incident)
{
  struct anon$4 col;
  struct anon$4 diffuse;
  struct anon$4 phongcol;
  struct anon$19 shadevars;
  double inten;
  double t = 1.000000e+18;
  const struct anon$15 *obj;
  signed int numints;
  struct list$link4 *cur;
  numints=closest_intersection(&t, &obj, incident);
  if(numints < 1)
  {
    col=incident->scene->bgtexfunc(incident);
    if(!(incident->scene->fog.fog_fctn == ((struct anon$4 (*)(struct fogdata_t$link3 *, struct anon$4, double))NULL)))
      col=fog_color(incident, col, t);

    return col;
  }

  shadevars.hit.x = incident->o.x + incident->d.x * t;
  shadevars.hit.y = incident->o.y + incident->d.y * t;
  shadevars.hit.z = incident->o.z + incident->d.z * t;
  incident->opticdist = incident->opticdist + t;
  obj->methods->normal((const void *)obj, (const void *)&shadevars.hit, (const void *)incident, (void *)&shadevars.N);
  col=obj->tex->texfunc((const void *)&shadevars.hit, (const void *)obj->tex, (void *)incident);
  if(!((2u & obj->tex->flags) == 0u))
    return col;

  diffuse.r = (float)0.000000;
  diffuse.g = (float)0.000000;
  diffuse.b = (float)0.000000;
  phongcol = diffuse;
  _Bool tmp_if_expr$1;
  if((double)obj->tex->diffuse > 1.959000e-3)
    tmp_if_expr$1 = TRUE;

  else
    tmp_if_expr$1 = (double)obj->tex->phong > 1.959000e-3 ? TRUE : FALSE;
  if(tmp_if_expr$1)
  {
    double light_scale = incident->scene->light_scale;
    cur = incident->scene->lightlist;
    while(!(cur == ((struct list$link4 *)NULL)))
    {
      struct light_t *li = (struct light_t *)cur->item;
      double return_value;
      return_value=li->shade_diffuse(li, &shadevars);
      inten = light_scale * return_value;
      if(inten > 1.959000e-3)
      {
        ColorAddS(&diffuse, &((struct anon$35 *)li->tex)->col, inten);
        if((double)obj->tex->phong > 1.959000e-3)
        {
          double phongval;
          double return_value_1;
          return_value_1=incident->scene->phongfunc(incident, &shadevars, (double)obj->tex->phongexp);
          phongval = light_scale * return_value_1;
          if(obj->tex->phongtype == 1)
            ColorAddS(&phongcol, &col, phongval * (double)obj->tex->phong);

          else
            ColorAddS(&phongcol, &((struct anon$35 *)li->tex)->col, phongval * (double)obj->tex->phong);
        }

      }

      cur = cur->next;
    }
  }

  if(obj->tex->outline > 0.000000f)
  {
    double outlinefactor;
    double edgefactor;
    edgefactor=VDot(&shadevars.N, &incident->d);
    edgefactor = edgefactor * edgefactor;
    edgefactor = 1.000000 - edgefactor;
    double return_value_pow$2;
    return_value_pow$2=pow(edgefactor, (1.000000 - (double)obj->tex->outlinewidth) * 32.000000);
    edgefactor = 1.000000 - return_value_pow$2;
    outlinefactor = (1.000000 - (double)obj->tex->outline) + edgefactor * (double)obj->tex->outline;
    ColorScale(&diffuse, (double)obj->tex->diffuse * outlinefactor);
  }

  else
    ColorScale(&diffuse, (double)obj->tex->diffuse);
  col.r = col.r * (diffuse.r + obj->tex->ambient);
  col.g = col.g * (diffuse.g + obj->tex->ambient);
  col.b = col.b * (diffuse.b + obj->tex->ambient);
  if((double)obj->tex->phong > 1.959000e-3)
    ColorAccum(&col, &phongcol);

  if((double)obj->tex->specular > 1.959000e-3)
  {
    struct anon$4 specol;
    specol=shade_reflection(incident, &shadevars, (double)obj->tex->specular);
    ColorAccum(&col, &specol);
  }

  if((double)obj->tex->opacity < 9.980410e-1)
  {
    struct anon$4 transcol;
    transcol=shade_transmission(incident, &shadevars, 1.000000 - (double)obj->tex->opacity);
    if(incident->scene->transmode == 1)
      ColorScale(&col, (double)obj->tex->opacity);

    ColorAccum(&col, &transcol);
  }

  if(!(incident->scene->fog.fog_fctn == ((struct anon$4 (*)(struct fogdata_t$link3 *, struct anon$4, double))NULL)))
    col=fog_color(incident, col, t);

  return col;
}

// c::memcpy
// file /usr/include/x86_64-linux-gnu/bits/string3.h line 48
void * memcpy(void * restrict __dest, const void * restrict __src, unsigned long int __len)
{
  void *return_value___builtin___memcpy_chk$1;
  return_value___builtin___memcpy_chk$1=__builtin___memcpy_chk(__dest, __src, (unsigned int)__len, 18446744073709551615ul);
  return return_value___builtin___memcpy_chk$1;
}

// c::memmove
// file /usr/include/x86_64-linux-gnu/bits/string3.h line 55
void * memmove(void *__dest, const void *__src, unsigned long int __len)
{
  char *return_value___builtin___memmove_chk$1;
  return_value___builtin___memmove_chk$1=__builtin___memmove_chk(__dest, __src, (unsigned int)__len, 18446744073709551615ul);
  return (void *)return_value___builtin___memmove_chk$1;
}

// c::memset
// file /usr/include/x86_64-linux-gnu/bits/string3.h line 76
void * memset(void *__dest, signed int __ch, unsigned long int __len)
{
  if(FALSE)
  {
    if(__len == 0ul)
    {

    __CPROVER_DUMP_L1:
      ;
      __warn_memset_zero_len();
      return __dest;
    }

  }

  void *return_value___builtin___memset_chk$1;
  return_value___builtin___memset_chk$1=__builtin___memset_chk(__dest, __ch, (unsigned int)__len, 18446744073709551615ul);
  return return_value___builtin___memset_chk$1;
}

// c::minmax_rgb96f
// file ../src/imageio.c line 107
void minmax_rgb96f(signed int xres, signed int yres, const float *fimg, float *min, float *max)
{
  signed int i;
  signed int sz;
  float minval;
  float maxval = fimg[(signed long int)0];
  minval = maxval;
  sz = xres * yres * 3;
  i = 0;
  while(!(i >= sz))
  {
    if(fimg[(signed long int)i] > maxval)
      maxval = fimg[(signed long int)i];

    if(fimg[(signed long int)i] < minval)
      minval = fimg[(signed long int)i];

    i = i + 1;
  }
  if(!(min == ((float *)NULL)))
    *min = minval;

  if(!(max == ((float *)NULL)))
    *max = maxval;

}

// c::mknod
// file /usr/include/x86_64-linux-gnu/sys/stat.h line 484
signed int mknod(const char *__path, unsigned int __mode, unsigned long int __dev)
{
  signed int return_value___xmknod$1;
  return_value___xmknod$1=__xmknod(0, __path, __mode, &__dev);
  return return_value___xmknod$1;
}

// c::mknodat
// file /usr/include/x86_64-linux-gnu/sys/stat.h line 492
signed int mknodat(signed int __fd, const char *__path, unsigned int __mode, unsigned long int __dev)
{
  signed int return_value___xmknodat$1;
  return_value___xmknodat$1=__xmknodat(0, __fd, __path, __mode, &__dev);
  return return_value___xmknodat$1;
}

// c::my_ui_message
// file ../demosrc/main.c line 52
static void my_ui_message(signed int a, char *msg)
{
  printf("%s\n", msg);
}

// c::my_ui_progress
// file ../demosrc/main.c line 56
static void my_ui_progress(signed int percent)
{
  printf("\rRendering Progress:       %3d%% complete            \r", percent);
  fflush(stdout);
}

// c::new_objectid
// file ../src/intersect.h line 8
unsigned int new_objectid(struct anon$32$link4 *scene)
{
  signed int tmp_post$1 = scene->objgroup.numobjects;
  scene->objgroup.numobjects = scene->objgroup.numobjects + 1;
  return (unsigned int)tmp_post$1;
}

// c::new_standard_texture
// file ../src/texture.h line 31
struct anon$25 * new_standard_texture(void)
{
  struct anon$35 *tex;
  void *return_value_malloc$1;
  return_value_malloc$1=malloc(232ul /*[[struct anon$35]]*/);
  tex = (struct anon$35 *)return_value_malloc$1;
  tex->methods = &standard_methods;
  return (struct anon$25 *)tex;
}

// c::new_texture
// file ../src/texture.c line 29
struct anon$25 * new_texture(void)
{
  struct anon$25 *tex;
  void *return_value_malloc$1;
  return_value_malloc$1=malloc(56ul /*[[struct anon$25]]*/);
  tex = (struct anon$25 *)return_value_malloc$1;
  tex->methods = &normal_methods;
  return tex;
}

// c::new_vcstri_texture
// file ../src/texture.h line 32
struct anon$25 * new_vcstri_texture(void)
{
  struct anon$36 *tex;
  void *return_value_malloc$1;
  return_value_malloc$1=malloc(104ul /*[[struct anon$36]]*/);
  tex = (struct anon$36 *)return_value_malloc$1;
  tex->methods = &vcstri_methods;
  return (struct anon$25 *)tex;
}

// c::newbox
// file ../src/box.h line 15
struct anon$26 * newbox(void *tex, struct anon$0 min, struct anon$0 max)
{
  struct anon$26 *b;
  void *return_value_malloc$1;
  return_value_malloc$1=malloc(88ul /*[[struct anon$26]]*/);
  b = (struct anon$26 *)return_value_malloc$1;
  memset((void *)b, 0, 88ul /*[[struct anon$26]]*/);
  b->methods = &box_methods;
  b->tex = (struct anon$25 *)tex;
  b->min = min;
  b->max = max;
  return b;
}

// c::newcylinder
// file ../src/cylinder.h line 7
struct anon$15 * newcylinder(void *tex, struct anon$0 ctr, struct anon$0 axis, double rad)
{
  struct anon$64 *c;
  void *return_value_malloc$1;
  return_value_malloc$1=malloc(96ul /*[[struct anon$64]]*/);
  c = (struct anon$64 *)return_value_malloc$1;
  memset((void *)c, 0, 96ul /*[[struct anon$64]]*/);
  c->methods = &cylinder_methods;
  c->tex = (struct anon$25 *)tex;
  c->ctr = ctr;
  c->axis = axis;
  c->rad = rad;
  return (struct anon$15 *)c;
}

// c::newdirectionallight
// file ../src/light.h line 38
struct directional_light_t$link271 * newdirectionallight(void *tex, struct anon$0 dir)
{
  struct directional_light_t$link271 *l;
  void *return_value_malloc$1;
  return_value_malloc$1=malloc(72ul /*[[struct directional_light_t]]*/);
  l = (struct directional_light_t$link271 *)return_value_malloc$1;
  memset((void *)l, 0, 72ul /*[[struct directional_light_t]]*/);
  l->methods = &light_methods;
  l->shade_diffuse = directional_light_shade_diffuse;
  l->tex = (struct anon$25 *)tex;
  l->tex->flags = (unsigned int)(1 | 2);
  l->tex->diffuse = (float)0.000000;
  l->tex->specular = (float)0.000000;
  l->tex->opacity = (float)1.000000;
  l->dir.x = -dir.x;
  l->dir.y = -dir.y;
  l->dir.z = -dir.z;
  return l;
}

// c::newextvol
// file ../src/extvol.h line 19
struct anon$29 * newextvol(void *voidtex, struct anon$0 min, struct anon$0 max, signed int samples, double (*evaluator)(double, double, double))
{
  struct anon$29 *xvol;
  struct anon$35 *tex;
  struct anon$35 *xvoltex;
  tex = (struct anon$35 *)voidtex;
  void *return_value_malloc$1;
  return_value_malloc$1=malloc(128ul /*[[struct anon$29]]*/);
  xvol = (struct anon$29 *)return_value_malloc$1;
  memset((void *)xvol, 0, 128ul /*[[struct anon$29]]*/);
  xvol->methods = &extvol_methods;
  xvol->min = min;
  xvol->max = max;
  xvol->evaluator = evaluator;
  xvol->ambient = (double)tex->ambient;
  xvol->diffuse = (double)tex->diffuse;
  xvol->opacity = (double)tex->opacity;
  xvol->samples = samples;
  void *return_value_malloc$2;
  return_value_malloc$2=malloc(232ul /*[[struct anon$35]]*/);
  xvoltex = (struct anon$35 *)return_value_malloc$2;
  memset((void *)xvoltex, 0, 232ul /*[[struct anon$35]]*/);
  xvoltex->ctr.x = 0.000000;
  xvoltex->ctr.y = 0.000000;
  xvoltex->ctr.z = 0.000000;
  xvoltex->rot = xvoltex->ctr;
  xvoltex->scale = xvoltex->ctr;
  xvoltex->uaxs = xvoltex->ctr;
  xvoltex->vaxs = xvoltex->ctr;
  xvoltex->flags = (unsigned int)0;
  xvoltex->col = tex->col;
  xvoltex->ambient = (float)1.000000;
  xvoltex->diffuse = (float)0.000000;
  xvoltex->specular = (float)0.000000;
  xvoltex->opacity = (float)1.000000;
  xvoltex->img = NULL;
  xvoltex->texfunc = (struct anon$4 (*)(const void *, const void *, void *))ext_volume_texture;
  xvoltex->obj = (void *)xvol;
  xvol->tex = (struct anon$25 *)xvoltex;
  return xvol;
}

// c::newfcylinder
// file ../src/cylinder.h line 8
struct anon$15 * newfcylinder(void *tex, struct anon$0 ctr, struct anon$0 axis, double rad)
{
  struct anon$64 *c;
  void *return_value_malloc$1;
  return_value_malloc$1=malloc(96ul /*[[struct anon$64]]*/);
  c = (struct anon$64 *)return_value_malloc$1;
  memset((void *)c, 0, 96ul /*[[struct anon$64]]*/);
  c->methods = &fcylinder_methods;
  c->tex = (struct anon$25 *)tex;
  c->ctr = ctr;
  c->axis = axis;
  c->rad = rad;
  return (struct anon$15 *)c;
}

// c::newgrid
// file ../src/grid.c line 32
struct anon$15 * newgrid(struct anon$44$link94 *scene, signed int xsize, signed int ysize, signed int zsize, struct anon$0 min, struct anon$0 max)
{
  struct anon$50 *g;
  signed int numcells;
  void *return_value_malloc$1;
  return_value_malloc$1=malloc(144ul /*[[struct anon$50]]*/);
  g = (struct anon$50 *)return_value_malloc$1;
  memset((void *)g, 0, 144ul /*[[struct anon$50]]*/);
  g->methods = &grid_methods;
  g->id=new_objectid(scene);
  g->xsize = xsize;
  g->ysize = ysize;
  g->zsize = zsize;
  numcells = xsize * ysize * zsize;
  g->min = min;
  g->max = max;
  VSub(&g->max, &g->min, &g->voxsize);
  g->voxsize.x = g->voxsize.x / (double)g->xsize;
  g->voxsize.y = g->voxsize.y / (double)g->ysize;
  g->voxsize.z = g->voxsize.z / (double)g->zsize;
  void *return_value_malloc$2;
  return_value_malloc$2=malloc((unsigned long int)numcells * 8ul /*[[struct objectlist *]]*/);
  g->cells = (struct objectlist **)return_value_malloc$2;
  memset((void *)g->cells, 0, (unsigned long int)numcells * 8ul /*[[struct objectlist *]]*/);
  return (struct anon$15 *)g;
}

// c::newplane
// file ../src/plane.h line 8
struct anon$15 * newplane(void *tex, struct anon$0 ctr, struct anon$0 norm)
{
  struct anon$55 *p;
  void *return_value_malloc$1;
  return_value_malloc$1=malloc(72ul /*[[struct anon$55]]*/);
  p = (struct anon$55 *)return_value_malloc$1;
  memset((void *)p, 0, 72ul /*[[struct anon$55]]*/);
  p->methods = &plane_methods;
  p->tex = (struct anon$25 *)tex;
  p->norm = norm;
  VNorm(&p->norm);
  double return_value_VDot$2;
  return_value_VDot$2=VDot(&ctr, &p->norm);
  p->d = -return_value_VDot$2;
  return (struct anon$15 *)p;
}

// c::newpointlight
// file ../src/light.h line 40
struct point_light_t$link242 * newpointlight(void *tex, struct anon$0 ctr, double rad)
{
  struct point_light_t$link242 *l;
  void *return_value_malloc$1;
  return_value_malloc$1=malloc(160ul /*[[struct point_light_t]]*/);
  l = (struct point_light_t$link242 *)return_value_malloc$1;
  memset((void *)l, 0, 160ul /*[[struct point_light_t]]*/);
  l->methods = &light_methods;
  l->shade_diffuse = simple_point_light_shade_diffuse;
  l->tex = (struct anon$25 *)tex;
  l->tex->flags = (unsigned int)(1 | 2);
  l->tex->diffuse = (float)0.000000;
  l->tex->specular = (float)0.000000;
  l->tex->opacity = (float)1.000000;
  l->ctr = ctr;
  l->rad = rad;
  l->attenuationfunc = light_no_attenuation;
  l->Kc = 1.000000;
  l->Kl = 0.000000;
  l->Kq = 0.000000;
  l->spotfunc = light_no_falloff;
  l->spotdir.x = 0.000000;
  l->spotdir.y = 0.000000;
  l->spotdir.z = 1.000000;
  l->fallstart = 3.000000e-1;
  l->fallend = 7.000000e-1;
  return l;
}

// c::newquadric
// file ../src/quadric.h line 21
struct anon$28 * newquadric(void)
{
  struct anon$28 *q;
  void *return_value_malloc$1;
  return_value_malloc$1=malloc(144ul /*[[struct anon$28]]*/);
  q = (struct anon$28 *)return_value_malloc$1;
  memset((void *)q, 0, 144ul /*[[struct anon$28]]*/);
  q->ctr.x = 0.000000;
  q->ctr.y = 0.000000;
  q->ctr.z = 0.000000;
  q->methods = &quadric_methods;
  return q;
}

// c::newring
// file ../src/ring.h line 7
struct anon$15 * newring(void *tex, struct anon$0 ctr, struct anon$0 norm, double inrad, double outrad)
{
  struct anon$58 *r;
  void *return_value_malloc$1;
  return_value_malloc$1=malloc(104ul /*[[struct anon$58]]*/);
  r = (struct anon$58 *)return_value_malloc$1;
  memset((void *)r, 0, 104ul /*[[struct anon$58]]*/);
  r->methods = &ring_methods;
  r->tex = (struct anon$25 *)tex;
  r->ctr = ctr;
  r->norm = norm;
  VNorm(&r->norm);
  r->inrad = inrad;
  r->outrad = outrad;
  return (struct anon$15 *)r;
}

// c::newscalarvol
// file ../src/vol.h line 9
void * newscalarvol(void *voidtex, struct anon$0 min, struct anon$0 max, signed int xs, signed int ys, signed int zs, const char *fname, struct anon$10 *invol)
{
  struct anon$35 *tx;
  struct anon$35 *tex;
  struct anon$10 *vol;
  tex = (struct anon$35 *)voidtex;
  tex->flags = (unsigned int)0;
  void *return_value_malloc$1;
  return_value_malloc$1=malloc(232ul /*[[struct anon$35]]*/);
  tx = (struct anon$35 *)return_value_malloc$1;
  if(invol == ((struct anon$10 *)NULL))
  {
    void *return_value_malloc$2;
    return_value_malloc$2=malloc(128ul /*[[struct anon$10]]*/);
    vol = (struct anon$10 *)return_value_malloc$2;
    vol->loaded = 0;
    vol->data = (unsigned char *)NULL;
  }

  else
    vol = invol;
  vol->opacity = (double)tex->opacity;
  vol->xres = xs;
  vol->yres = ys;
  vol->zres = zs;
  strcpy(vol->name, fname);
  tx->ctr.x = 0.000000;
  tx->ctr.y = 0.000000;
  tx->ctr.z = 0.000000;
  tx->rot = tx->ctr;
  tx->scale = tx->ctr;
  tx->uaxs = tx->ctr;
  tx->vaxs = tx->ctr;
  tx->flags = (unsigned int)0;
  tx->col = tex->col;
  tx->ambient = (float)1.000000;
  tx->diffuse = (float)0.000000;
  tx->phong = (float)0.000000;
  tx->phongexp = (float)0.000000;
  tx->phongtype = 0;
  tx->specular = (float)0.000000;
  tx->opacity = (float)1.000000;
  tx->outline = (float)0.000000;
  tx->outlinewidth = (float)0.000000;
  tx->img = (void *)vol;
  tx->texfunc = (struct anon$4 (*)(const void *, const void *, void *))scalar_volume_texture;
  struct anon$26 *return_value_newbox$3;
  return_value_newbox$3=newbox((void *)tx, min, max);
  tx->obj = (void *)return_value_newbox$3;
  if(vol->loaded == 0)
    LoadVol(vol);

  if(vol->loaded == 0)
  {
    tx->texfunc = (struct anon$4 (*)(const void *, const void *, void *))constant_texture;
    tx->img = NULL;
    free((void *)vol);
  }

  return (void *)tx->obj;
}

// c::newsphere
// file ../src/sphere.h line 7
struct anon$15 * newsphere(void *tex, struct anon$0 ctr, double rad)
{
  struct anon$53 *s;
  void *return_value_malloc$1;
  return_value_malloc$1=malloc(72ul /*[[struct anon$53]]*/);
  s = (struct anon$53 *)return_value_malloc$1;
  memset((void *)s, 0, 72ul /*[[struct anon$53]]*/);
  s->methods = &sphere_methods;
  s->tex = (struct anon$25 *)tex;
  s->ctr = ctr;
  s->rad = rad;
  return (struct anon$15 *)s;
}

// c::newspotlight
// file ../src/light.h line 41
struct point_light_t$link242 * newspotlight(void *tex, struct anon$0 ctr, double rad, struct anon$0 dir, double fallstart, double fallend)
{
  struct point_light_t$link242 *l;
  void *return_value_malloc$1;
  return_value_malloc$1=malloc(160ul /*[[struct point_light_t]]*/);
  l = (struct point_light_t$link242 *)return_value_malloc$1;
  memset((void *)l, 0, 160ul /*[[struct point_light_t]]*/);
  l->methods = &light_methods;
  l->shade_diffuse = point_light_shade_diffuse;
  l->tex = (struct anon$25 *)tex;
  l->tex->flags = (unsigned int)(1 | 2);
  l->tex->diffuse = (float)0.000000;
  l->tex->specular = (float)0.000000;
  l->tex->opacity = (float)1.000000;
  l->ctr = ctr;
  l->rad = rad;
  l->attenuationfunc = light_no_attenuation;
  l->Kc = 1.000000;
  l->Kl = 0.000000;
  l->Kq = 0.000000;
  l->spotfunc = light_spotlight_falloff;
  l->spotdir = dir;
  l->fallstart = fallstart;
  l->fallend = fallend;
  return l;
}

// c::newstri
// file ../src/triangle.h line 8
struct anon$15 * newstri(void *tex, struct anon$0 v0, struct anon$0 v1, struct anon$0 v2, struct anon$0 n0, struct anon$0 n1, struct anon$0 n2)
{
  struct anon$61 *t;
  struct anon$0 edge1;
  struct anon$0 edge2;
  struct anon$0 edge3;
  VSub(&v1, &v0, &edge1);
  VSub(&v2, &v0, &edge2);
  VSub(&v2, &v1, &edge3);
  double return_value_VLength$4;
  return_value_VLength$4=VLength(&edge1);
  double return_value_VLength$3;
  double return_value_VLength$2;
  if(return_value_VLength$4 >= 5.000000e-8)
  {
    return_value_VLength$3=VLength(&edge2);
    if(return_value_VLength$3 >= 5.000000e-8)
    {
      return_value_VLength$2=VLength(&edge3);
      if(return_value_VLength$2 >= 5.000000e-8)
      {
        void *return_value_malloc$1;
        return_value_malloc$1=malloc(184ul /*[[struct anon$61]]*/);
        t = (struct anon$61 *)return_value_malloc$1;
        t->nextobj = NULL;
        t->methods = &stri_methods;
        t->tex = (struct anon$25 *)tex;
        t->v0 = v0;
        t->edge1 = edge1;
        t->edge2 = edge2;
        t->n0 = n0;
        t->n1 = n1;
        t->n2 = n2;
        return (struct anon$15 *)t;
      }

    }

  }

  return (struct anon$15 *)NULL;
}

// c::newtri
// file ../src/triangle.h line 7
struct anon$15 * newtri(void *tex, struct anon$0 v0, struct anon$0 v1, struct anon$0 v2)
{
  struct anon$60 *t;
  struct anon$0 edge1;
  struct anon$0 edge2;
  struct anon$0 edge3;
  VSub(&v1, &v0, &edge1);
  VSub(&v2, &v0, &edge2);
  VSub(&v2, &v1, &edge3);
  double return_value_VLength$4;
  return_value_VLength$4=VLength(&edge1);
  double return_value_VLength$3;
  double return_value_VLength$2;
  if(return_value_VLength$4 >= 5.000000e-8)
  {
    return_value_VLength$3=VLength(&edge2);
    if(return_value_VLength$3 >= 5.000000e-8)
    {
      return_value_VLength$2=VLength(&edge3);
      if(return_value_VLength$2 >= 5.000000e-8)
      {
        void *return_value_malloc$1;
        return_value_malloc$1=malloc(112ul /*[[struct anon$60]]*/);
        t = (struct anon$60 *)return_value_malloc$1;
        t->nextobj = NULL;
        t->methods = &tri_methods;
        t->tex = (struct anon$25 *)tex;
        t->v0 = v0;
        t->edge1 = edge1;
        t->edge2 = edge2;
        return (struct anon$15 *)t;
      }

    }

  }

  return (struct anon$15 *)NULL;
}

// c::newvcstri
// file ../src/triangle.h line 10
struct anon$15 * newvcstri(void *voidtex, struct anon$0 v0, struct anon$0 v1, struct anon$0 v2, struct anon$0 n0, struct anon$0 n1, struct anon$0 n2, struct anon$4 c0, struct anon$4 c1, struct anon$4 c2)
{
  struct anon$62 *t;
  struct anon$0 edge1;
  struct anon$0 edge2;
  struct anon$0 edge3;
  struct anon$36 *tex = (struct anon$36 *)voidtex;
  VSub(&v1, &v0, &edge1);
  VSub(&v2, &v0, &edge2);
  VSub(&v2, &v1, &edge3);
  double return_value_VLength$4;
  return_value_VLength$4=VLength(&edge1);
  double return_value_VLength$3;
  double return_value_VLength$2;
  if(return_value_VLength$4 >= 5.000000e-8)
  {
    return_value_VLength$3=VLength(&edge2);
    if(return_value_VLength$3 >= 5.000000e-8)
    {
      return_value_VLength$2=VLength(&edge3);
      if(return_value_VLength$2 >= 5.000000e-8)
      {
        void *return_value_malloc$1;
        return_value_malloc$1=malloc(224ul /*[[struct anon$62]]*/);
        t = (struct anon$62 *)return_value_malloc$1;
        t->nextobj = NULL;
        t->methods = &stri_methods;
        t->v0 = v0;
        t->edge1 = edge1;
        t->edge2 = edge2;
        t->n0 = n0;
        t->n1 = n1;
        t->n2 = n2;
        tex->c0 = c0;
        tex->c1 = c1;
        tex->c2 = c2;
        tex->obj = (void *)t;
        tex->texfunc = (struct anon$4 (*)(const void *, const void *, void *))vcstri_color;
        t->tex = (struct anon$25 *)tex;
        return (struct anon$15 *)t;
      }

    }

  }

  return (struct anon$15 *)NULL;
}

// c::normalize
// file ../demosrc/ac3dparse.c line 316
static void normalize(struct anon$0 *vec)
{
  double length;
  length=sqrt(vec->x * vec->x + vec->y * vec->y + vec->z * vec->z);
  vec->x = vec->x / length;
  vec->y = vec->y / length;
  vec->z = vec->z / length;
}

// c::normalize_quat
// file ../demosrc/trackball.c line 288
static void normalize_quat(float *q)
{
  signed int i;
  float mag = q[(signed long int)0] * q[(signed long int)0] + q[(signed long int)1] * q[(signed long int)1] + q[(signed long int)2] * q[(signed long int)2] + q[(signed long int)3] * q[(signed long int)3];
  i = 0;
  while(i < 4)
  {
    q[(signed long int)i] = q[(signed long int)i] / mag;
    i = i + 1;
  }
}

// c::normalize_rgb96f
// file ../src/imageio.h line 23
void normalize_rgb96f(signed int xres, signed int yres, float *fimg)
{
  signed int i;
  signed int sz;
  float min;
  float max;
  float scale;
  sz = xres * yres * 3;
  minmax_rgb96f(xres, yres, fimg, &min, &max);
  scale = (float)(1.000000 / (double)(max - min));
  i = 0;
  while(!(i >= sz))
  {
    fimg[(signed long int)i] = (fimg[(signed long int)i] - min) * scale;
    i = i + 1;
  }
}

// c::open
// file /usr/include/x86_64-linux-gnu/bits/fcntl2.h line 41
signed int open(const char *__path, signed int __oflag, ...)
{
  signed int return_value___builtin_va_arg_pack_len$1;
  return_value___builtin_va_arg_pack_len$1=__builtin_va_arg_pack_len();
  if(return_value___builtin_va_arg_pack_len$1 > 1)
    __open_too_many_args();

  signed int return_value___builtin_va_arg_pack_len$3;
  signed int return_value___builtin_va_arg_pack_len$7;
  return_value___builtin_va_arg_pack_len$7=__builtin_va_arg_pack_len();
  signed int return_value___open_2$6;
  if(return_value___builtin_va_arg_pack_len$7 < 1)
  {
    return_value___open_2$6=__open_2(__path, __oflag);
    return return_value___open_2$6;
  }

  void *return_value___builtin_va_arg_pack$8;
  return_value___builtin_va_arg_pack$8=__builtin_va_arg_pack();
  signed int return_value___open_alias$9;
  return_value___open_alias$9=__open_alias(__path, __oflag, return_value___builtin_va_arg_pack$8);
  return return_value___open_alias$9;
}

// c::openat
// file /usr/include/x86_64-linux-gnu/bits/fcntl2.h line 117
signed int openat(signed int __fd, const char *__path, signed int __oflag, ...)
{
  signed int return_value___builtin_va_arg_pack_len$1;
  return_value___builtin_va_arg_pack_len$1=__builtin_va_arg_pack_len();
  if(return_value___builtin_va_arg_pack_len$1 > 1)
    __openat_too_many_args();

  signed int return_value___builtin_va_arg_pack_len$3;
  signed int return_value___builtin_va_arg_pack_len$7;
  return_value___builtin_va_arg_pack_len$7=__builtin_va_arg_pack_len();
  signed int return_value___openat_2$6;
  if(return_value___builtin_va_arg_pack_len$7 < 1)
  {
    return_value___openat_2$6=__openat_2(__fd, __path, __oflag);
    return return_value___openat_2$6;
  }

  void *return_value___builtin_va_arg_pack$8;
  return_value___builtin_va_arg_pack$8=__builtin_va_arg_pack();
  signed int return_value___openat_alias$9;
  return_value___openat_alias$9=__openat_alias(__fd, __path, __oflag, return_value___builtin_va_arg_pack$8);
  return return_value___openat_alias$9;
}

// c::opentgafile
// file ../src/tgafile.c line 66
void * opentgafile(char *filename)
{
  struct anon$72 *tga;
  void *return_value_malloc$1;
  return_value_malloc$1=malloc(16ul /*[[struct anon$72]]*/);
  tga = (struct anon$72 *)return_value_malloc$1;
  tga->ofp=fopen(filename, "r+b");
  if(tga->ofp == ((struct _IO_FILE$link43 *)NULL))
  {
    char msgtxt[2048l];
    sprintf(msgtxt, "Cannot open %s for output!", filename);
    rt_ui_message(200, msgtxt);
    rt_ui_message(300, "Rendering Aborted.");
    return NULL;
  }

  fseek(tga->ofp, (signed long int)12, 0);
  signed int return_value_fgetc$2;
  return_value_fgetc$2=fgetc(tga->ofp);
  tga->width = (unsigned short int)return_value_fgetc$2;
  signed int return_value_fgetc$3;
  return_value_fgetc$3=fgetc(tga->ofp);
  tga->width = tga->width | (unsigned short int)(return_value_fgetc$3 << 8);
  signed int return_value_fgetc$4;
  return_value_fgetc$4=fgetc(tga->ofp);
  tga->height = (unsigned short int)return_value_fgetc$4;
  signed int return_value_fgetc$5;
  return_value_fgetc$5=fgetc(tga->ofp);
  tga->height = tga->height | (unsigned short int)(return_value_fgetc$5 << 8);
  return (void *)tga;
}

// c::plane_bbox
// file ../src/plane.c line 39
static signed int plane_bbox(void *obj, struct anon$0 *min, struct anon$0 *max)
{
  return 0;
}

// c::plane_intersect
// file ../src/plane.c line 43
static void plane_intersect(const struct anon$55 *pln, struct ray_t$link233 *ry)
{
  double t;
  double td;
  t = -(pln->d + pln->norm.x * ry->o.x + pln->norm.y * ry->o.y + pln->norm.z * ry->o.z);
  td = pln->norm.x * ry->d.x + pln->norm.y * ry->d.y + pln->norm.z * ry->d.z;
  if(IEEE_FLOAT_NOTEQUAL(td, 0.000000))
  {
    t = t / td;
    if(t > 0.000000)
      ry->add_intersection(t, (struct anon$15 *)pln, ry);

  }

}

// c::plane_normal
// file ../src/plane.c line 61
static void plane_normal(const struct anon$55 *pln, const struct anon$0 *pnt, struct ray_t$link233 *incident, struct anon$0 *N)
{
  *N = pln->norm;
  double return_value_VDot$1;
  return_value_VDot$1=VDot(N, &incident->d);
  if(return_value_VDot$1 > 0.000000)
  {
    N->x = -N->x;
    N->y = -N->y;
    N->z = -N->z;
  }

}

// c::point_light_shade_diffuse
// file ../src/light.c line 174
static double point_light_shade_diffuse(struct point_light_t$link242 *li, struct anon$19 *shadevars)
{
  double inten;
  double len;
  shadevars->L.x = li->ctr.x - shadevars->hit.x;
  shadevars->L.y = li->ctr.y - shadevars->hit.y;
  shadevars->L.z = li->ctr.z - shadevars->hit.z;
  double return_value_sqrt$1;
  return_value_sqrt$1=sqrt(shadevars->L.x * shadevars->L.x + shadevars->L.y * shadevars->L.y + shadevars->L.z * shadevars->L.z);
  len = return_value_sqrt$1 + 5.000000e-8;
  shadevars->L.x = shadevars->L.x / len;
  shadevars->L.y = shadevars->L.y / len;
  shadevars->L.z = shadevars->L.z / len;
  shadevars->Llen = len;
  inten = shadevars->N.x * shadevars->L.x + shadevars->N.y * shadevars->L.y + shadevars->N.z * shadevars->L.z;
  double return_value;
  return_value=li->attenuationfunc((void *)li, shadevars->Llen);
  inten = inten * return_value;
  double return_value_1;
  return_value_1=li->spotfunc((void *)li, &shadevars->L);
  inten = inten * return_value_1;
  return inten;
}

// c::pos2grid
// file ../src/grid.c line 438
static signed int pos2grid(struct anon$50 *g, struct anon$0 *pos, struct anon$51 *index)
{
  index->x = (signed int)((double)(pos->x - g->min.x) / g->voxsize.x);
  index->y = (signed int)((double)(pos->y - g->min.y) / g->voxsize.y);
  index->z = (signed int)((double)(pos->z - g->min.z) / g->voxsize.z);
  if(index->x == g->xsize)
    index->x = index->x - 1;

  if(index->y == g->ysize)
    index->y = index->y - 1;

  if(index->z == g->zsize)
    index->z = index->z - 1;

  _Bool tmp_if_expr$1;
  if(index->x < 0)
    tmp_if_expr$1 = TRUE;

  else
    tmp_if_expr$1 = index->x > g->xsize ? TRUE : FALSE;
  _Bool tmp_if_expr$2;
  if(tmp_if_expr$1)
    tmp_if_expr$2 = TRUE;

  else
    tmp_if_expr$2 = index->y < 0 ? TRUE : FALSE;
  _Bool tmp_if_expr$3;
  if(tmp_if_expr$2)
    tmp_if_expr$3 = TRUE;

  else
    tmp_if_expr$3 = index->y > g->ysize ? TRUE : FALSE;
  _Bool tmp_if_expr$4;
  if(tmp_if_expr$3)
    tmp_if_expr$4 = TRUE;

  else
    tmp_if_expr$4 = index->z < 0 ? TRUE : FALSE;
  _Bool tmp_if_expr$5;
  if(tmp_if_expr$4)
    tmp_if_expr$5 = TRUE;

  else
    tmp_if_expr$5 = index->z > g->zsize ? TRUE : FALSE;
  if(tmp_if_expr$5)
    return 0;

  _Bool tmp_if_expr$6;
  if(pos->x < g->min.x)
    tmp_if_expr$6 = TRUE;

  else
    tmp_if_expr$6 = pos->x > g->max.x ? TRUE : FALSE;
  _Bool tmp_if_expr$7;
  if(tmp_if_expr$6)
    tmp_if_expr$7 = TRUE;

  else
    tmp_if_expr$7 = pos->y < g->min.y ? TRUE : FALSE;
  _Bool tmp_if_expr$8;
  if(tmp_if_expr$7)
    tmp_if_expr$8 = TRUE;

  else
    tmp_if_expr$8 = pos->y > g->max.y ? TRUE : FALSE;
  _Bool tmp_if_expr$9;
  if(tmp_if_expr$8)
    tmp_if_expr$9 = TRUE;

  else
    tmp_if_expr$9 = pos->z < g->min.z ? TRUE : FALSE;
  _Bool tmp_if_expr$10;
  if(tmp_if_expr$9)
    tmp_if_expr$10 = TRUE;

  else
    tmp_if_expr$10 = pos->z > g->max.z ? TRUE : FALSE;
  if(tmp_if_expr$10)
    return 0;

  return 1;
}

// c::postsceneoptions
// file ../demosrc/getargs.h line 40
signed int postsceneoptions(struct anon$1 *opt, void *scene)
{
  if(opt->outimageformat == -1)
    opt->outimageformat = 0;

  if(opt->xsize > 0)
  {
    if(opt->ysize > 0)
      rt_resolution(scene, opt->xsize, opt->ysize);

  }

  if(!(opt->cropmode == 0))
  {
    if(opt->cropmode == 1)
      rt_crop_output(scene, opt->cropxres, opt->cropyres, opt->cropxstart, opt->cropystart);

    else
    {
      signed int xs;
      signed int ys;
      rt_get_resolution(scene, &xs, &ys);
      rt_crop_output(scene, 100, 100, xs / 2 - 50, ys / 2 - 50);
    }
  }

  if(opt->useoutfilename == -1)
  {
    if(!(opt->usecamfile == -1))
      strcpy(opt->outfilename, "cam.%04d");

    else
      if(opt->numfiles > 1)
        strcpy(opt->outfilename, "outfile.%04d");

      else
        strcpy(opt->outfilename, "outfile");
    switch(opt->outimageformat)
    {

      case 1:
        {
          strcat(opt->outfilename, ".ppm");
          goto __CPROVER_DUMP_L16;
        }
      case 4:
        {
          strcat(opt->outfilename, ".bmp");
          goto __CPROVER_DUMP_L16;
        }
      case 2:
        {
          strcat(opt->outfilename, ".rgb");
          goto __CPROVER_DUMP_L16;
        }
      case 3:
        {
          strcat(opt->outfilename, ".jpg");
          goto __CPROVER_DUMP_L16;
        }
      case 5:
        {
          strcat(opt->outfilename, ".png");
          goto __CPROVER_DUMP_L16;
        }
      case 7:
        {
          strcat(opt->outfilename, ".psd");
          goto __CPROVER_DUMP_L16;
        }
      case 6:
        {
          strcat(opt->outfilename, ".ppm");
          goto __CPROVER_DUMP_L16;
        }
      case 0:

        default:
          strcat(opt->outfilename, ".tga");
    }
  }


__CPROVER_DUMP_L16:
  ;
  if(opt->nosave == 1)
    strcpy(opt->outfilename, "");

  if(opt->rescale_lights < 1.000000f)
    rt_rescale_lights(scene, (double)opt->rescale_lights);

  if(opt->auto_skylight > 0.000000f)
  {
    struct anon$4 postsceneoptions$$1$$7$$col;
    float lightscale = (float)(1.000000 - (double)opt->auto_skylight);
    if(lightscale < 0.000000f)
      lightscale = (float)0.000000;

    rt_rescale_lights(scene, (double)lightscale);
    postsceneoptions$$1$$7$$col.r = opt->auto_skylight;
    postsceneoptions$$1$$7$$col.g = opt->auto_skylight;
    postsceneoptions$$1$$7$$col.b = opt->auto_skylight;
    rt_ambient_occlusion(scene, opt->skylight_samples, postsceneoptions$$1$$7$$col);
  }

  else
    if(opt->add_skylight > 0.000000f)
    {
      struct anon$4 postsceneoptions$$1$$8$$col;
      postsceneoptions$$1$$8$$col.r = opt->add_skylight;
      postsceneoptions$$1$$8$$col.g = opt->add_skylight;
      postsceneoptions$$1$$8$$col.b = opt->add_skylight;
      rt_ambient_occlusion(scene, opt->skylight_samples, postsceneoptions$$1$$8$$col);
    }

  rt_outputformat(scene, opt->outimageformat);
  rt_outputfile(scene, opt->outfilename);
  if(!(opt->imgprocess == -1))
    switch(opt->imgprocess)
    {

      case 0:
        {
          rt_image_clamp(scene);
          goto __CPROVER_DUMP_L25;
        }
      case 1:
        {
          rt_image_normalize(scene);
          goto __CPROVER_DUMP_L25;
        }
      case 2:
        rt_image_gamma(scene, opt->imggamma);
      default:
        ;
    }


__CPROVER_DUMP_L25:
  ;
  if(opt->verbosemode == 1)
    rt_verbose(scene, 1);

  if(opt->verbosemode == 0)
    rt_verbose(scene, 0);

  if(!(opt->aa_maxsamples == -1))
    rt_aa_maxsamples(scene, opt->aa_maxsamples);

  if(!(opt->boundmode == -1))
    rt_boundmode(scene, opt->boundmode);

  if(!(opt->boundthresh == -1))
    rt_boundthresh(scene, opt->boundthresh);

  if(!(opt->shadermode == -1))
    rt_shadermode(scene, opt->shadermode);

  if(!(opt->phongfunc == -1))
    rt_phong_shader(scene, opt->phongfunc);

  if(!(opt->transmode == -1))
    rt_trans_mode(scene, opt->transmode);

  if(!(opt->fogmode == -1))
    rt_fog_rendering_mode(scene, opt->fogmode);

  if(!(opt->numthreads == -1))
    rt_set_numthreads(scene, opt->numthreads);

  return 0;
}

// c::presceneoptions
// file ../demosrc/getargs.h line 39
signed int presceneoptions(struct anon$1 *opt, void *scene)
{
  if(!(opt->normalfixupmode == -1))
    rt_normal_fixup_mode(scene, opt->normalfixupmode);

  return 0;
}

// c::printf
// file /usr/include/x86_64-linux-gnu/bits/stdio2.h line 102
signed int printf(const char * restrict __fmt, ...)
{
  void *return_value___builtin_va_arg_pack$1;
  return_value___builtin_va_arg_pack$1=__builtin_va_arg_pack();
  signed int return_value___printf_chk$2;
  return_value___printf_chk$2=__printf_chk(2 - 1, __fmt, return_value___builtin_va_arg_pack$1);
  return return_value___printf_chk$2;
}

// c::printusage
// file ../demosrc/getargs.c line 27
static void printusage(char **argv)
{
  printf("Usage: \n");
  printf("  %s modelfile [options] \n", argv[(signed long int)0]);
  printf("\n");
  printf("Model file formats supported:\n");
  printf("  filename.dat -- The model files originated with this package.\n");
  printf("  filaname.ac  -- AC3D model files.\n");
  printf("  filename.nff -- The NFF scene format used by Eric Haines' SPD.\n");
  printf("\n");
  printf("Valid options:  (** denotes default behaviour)\n");
  printf("----------------------------------------------\n");
  printf("Message Options:\n");
  printf(" +V verbose messages on \n");
  printf(" -V verbose messages off **\n");
  printf("\n");
  printf("Speed Tuning Options:\n");
  printf(" -numthreads xxx   (** default is auto-determined)\n");
  printf(" -nobounding\n");
  printf(" -boundthresh xxx  (** default threshold is 16)\n");
  printf("\n");
  printf("Shading Options:\n");
  printf("  -fullshade    best quality rendering (and slowest) **\n");
  printf("  -mediumshade  good quality rendering, but no shadows\n");
  printf("  -lowshade     low quality rendering, preview (and fast)\n");
  printf("  -lowestshade  worst quality rendering, preview (and fastest)\n");
  printf("\n");
  printf("Lighting Options:\n");
  printf("  -rescale_lights xxx rescale light intensity values by\n");
  printf("                      specified factor (performed before other\n");
  printf("                      lighting overrides take effect)\n");
  printf("  -auto_skylight xxx  force use of ambient occlusion lighting,\n");
  printf("                      auto-rescaling direct light sources to  \n");
  printf("                      compensate for ambient occlusion factor.\n");
  printf("                      (use value 0.7 as a good starting point)\n");
  printf("  -add_skylight xxx   force use of ambient occlusion lighting,\n");
  printf("                      manually-rescaling direct light sources to\n");
  printf("                      compensate for ambient occlusion factor.\n");
  printf("  -skylight_samples xxx number of sample rays to shoot.\n");
  printf("\n");
  printf("Specular Highlight Shading Options:\n");
  printf("  -shade_phong       Phong specular highlights\n");
  printf("  -shade_blinn       Blinn's specular highlights**\n");
  printf("  -shade_blinn_fast  fast approximation to Blinn's highlights\n");
  printf("  -shade_nullphong   disable specular highlights\n");
  printf("\n");
  printf("Transparency Shading Options:\n");
  printf("  -trans_orig        Original implementation**\n");
  printf("  -trans_vmd         Opacity post-multiply used by VMD\n");
  printf("\n");
  printf("Fog Shading Options:\n");
  printf("  -fog_radial        Radial fog implementation**\n");
  printf("  -fog_vmd           Planar OpenGL-like fog used by VMD\n");
  printf("\n");
  printf("Surface Normal/Winding Order Fixup Mode:\n");
  printf("  -normalfixup [off | flip | guess]  (**off is default)\n");
  printf("\n");
  printf("Antialiasing Options:\n");
  printf("  -aasamples xxx  (maximum supersamples taken per pixel)\n");
  printf("                  (** default is 0, or scene file determined)\n");
  printf("\n");
  printf("Output Options:\n");
  printf("  -res Xres Yres  override scene-defined output image size\n");
  printf("  -o outfile.tga  set output file name\n");
  printf("  -clamp          clamp pixel values to [0 to 1) (** default)\n");
  printf("  -normalize      normalize pixel values to [0 to 1)\n");
  printf("  -gamma val      normalize apply gamma correction\n");
  printf("  -format BMP     24-bit Windows BMP  (uncompressed)\n");
  printf("  -format JPEG    XXX Not compiled into this binary XXX\n");
  printf("  -format PNG     XXX Not compiled into this binary XXX\n");
  printf("  -format PPM     24-bit PPM          (uncompressed)\n");
  printf("  -format PPM48   48-bit PPM          (uncompressed)\n");
  printf("  -format PSD48   48-bit PSD          (uncompressed)\n");
  printf("  -format RGB     24-bit SGI RGB      (uncompressed)\n");
  printf("  -format TARGA   24-bit Targa        (uncompressed) **\n");
  printf("\n");
  printf("Animation Related Options:\n");
  printf(" -camfile filename.cam  Animate using file of camera positions.\n");
  printf(" -nosave                Disable writing of output frames to disk\n");
  printf("                        (only used for doing real-time rendering)\n");
  printf("\n");
}

// c::pthread_equal
// file /usr/include/pthread.h line 1144
signed int pthread_equal(unsigned long int __thread1, unsigned long int __thread2)
{
  return (signed int)(__thread1 == __thread2);
}

// c::ptsname_r
// file /usr/include/x86_64-linux-gnu/bits/stdlib.h line 64
signed int ptsname_r(signed int __fd, char *__buf, unsigned long int __buflen)
{
  signed int return_value___ptsname_r_chk$1;
  signed int return_value___ptsname_r_chk_warn$2;
  signed int return_value___ptsname_r_alias$3;
  return_value___ptsname_r_alias$3=__ptsname_r_alias(__fd, __buf, __buflen);
  return return_value___ptsname_r_alias$3;
}

// c::putbyte
// file ../src/sgirgb.c line 14
static void putbyte(struct _IO_FILE$link42 *outf, unsigned char val)
{
  unsigned char buf[1l];
  buf[(signed long int)0] = val;
  fwrite((const void *)buf, (unsigned long int)1, (unsigned long int)1, outf);
}

// c::putc_unlocked
// file /usr/include/x86_64-linux-gnu/bits/stdio.h line 98
signed int putc_unlocked(signed int __c, struct _IO_FILE *__stream)
{
  signed int tmp_if_expr$3;
  signed int return_value___overflow$1;
  char *tmp_post$2;
  if(__stream->_IO_write_ptr >= __stream->_IO_write_end)
  {
    return_value___overflow$1=__overflow(__stream, (signed int)(unsigned char)__c);
    tmp_if_expr$3 = return_value___overflow$1;
  }

  else
  {
    tmp_post$2 = __stream->_IO_write_ptr;
    __stream->_IO_write_ptr = __stream->_IO_write_ptr + 1l;
    *tmp_post$2 = (char)__c;
    tmp_if_expr$3 = (signed int)(unsigned char)*tmp_post$2;
  }
  return tmp_if_expr$3;
}

// c::putchar
// file /usr/include/x86_64-linux-gnu/bits/stdio.h line 79
signed int putchar(signed int __c)
{
  signed int return_value__IO_putc$1;
  return_value__IO_putc$1=_IO_putc(__c, stdout);
  return return_value__IO_putc$1;
}

// c::putchar_unlocked
// file /usr/include/x86_64-linux-gnu/bits/stdio.h line 105
signed int putchar_unlocked(signed int __c)
{
  signed int tmp_if_expr$3;
  signed int return_value___overflow$1;
  char *tmp_post$2;
  if(stdout->_IO_write_ptr >= stdout->_IO_write_end)
  {
    return_value___overflow$1=__overflow(stdout, (signed int)(unsigned char)__c);
    tmp_if_expr$3 = return_value___overflow$1;
  }

  else
  {
    tmp_post$2 = stdout->_IO_write_ptr;
    stdout->_IO_write_ptr = stdout->_IO_write_ptr + 1l;
    *tmp_post$2 = (char)__c;
    tmp_if_expr$3 = (signed int)(unsigned char)*tmp_post$2;
  }
  return tmp_if_expr$3;
}

// c::putint
// file ../src/sgirgb.c line 27
static void putint(struct _IO_FILE$link42 *outf, unsigned int val)
{
  unsigned char buf[4l];
  buf[(signed long int)0] = (unsigned char)(val >> 24);
  buf[(signed long int)1] = (unsigned char)(val >> 16);
  buf[(signed long int)2] = (unsigned char)(val >> 8);
  buf[(signed long int)3] = (unsigned char)(val & (unsigned int)255);
  fwrite((const void *)buf, (unsigned long int)4, (unsigned long int)1, outf);
}

// c::putshort
// file ../src/sgirgb.c line 20
static void putshort(struct _IO_FILE$link42 *outf, unsigned short int val)
{
  unsigned char buf[2l];
  buf[(signed long int)0] = (unsigned char)((signed int)val >> 8);
  buf[(signed long int)1] = (unsigned char)((signed int)val & 255);
  fwrite((const void *)buf, (unsigned long int)2, (unsigned long int)1, outf);
}

// c::quadric_bbox
// file ../src/quadric.c line 15
signed int quadric_bbox(void *obj, struct anon$0 *min, struct anon$0 *max)
{
  return 0;
}

// c::quadric_intersect
// file ../src/quadric.c line 39
void quadric_intersect(const struct anon$28 *q, struct ray_t$link247 *ry)
{
  double Aq;
  double Bq;
  double Cq;
  double t1;
  double t2;
  double disc;
  struct anon$0 rd;
  struct anon$0 ro;
  rd = ry->d;
  VNorm(&rd);
  ro.x = ry->o.x - q->ctr.x;
  ro.y = ry->o.y - q->ctr.y;
  ro.z = ry->o.z - q->ctr.z;
  Aq = q->mat.a * rd.x * rd.x + 2.000000 * q->mat.b * rd.x * rd.y + 2.000000 * q->mat.c * rd.x * rd.z + q->mat.e * rd.y * rd.y + 2.000000 * q->mat.f * rd.y * rd.z + q->mat.h * rd.z * rd.z;
  Bq = 2.000000 * (q->mat.a * ro.x * rd.x + q->mat.b * (ro.x * rd.y + rd.x * ro.y) + q->mat.c * (ro.x * rd.z + rd.x * ro.z) + q->mat.d * rd.x + q->mat.e * ro.y * rd.y + q->mat.f * (ro.y * rd.z + rd.y * ro.z) + q->mat.g * rd.y + q->mat.h * ro.z * rd.z + q->mat.i * rd.z);
  Cq = q->mat.a * ro.x * ro.x + 2.000000 * q->mat.b * ro.x * ro.y + 2.000000 * q->mat.c * ro.x * ro.z + 2.000000 * q->mat.d * ro.x + q->mat.e * ro.y * ro.y + 2.000000 * q->mat.f * ro.y * ro.z + 2.000000 * q->mat.g * ro.y + q->mat.h * ro.z * ro.z + 2.000000 * q->mat.i * ro.z + q->mat.j;
  if(IEEE_FLOAT_EQUAL(Aq, 0.000000))
  {
    t1 = -Cq / Bq;
    ry->add_intersection(t1, (struct anon$15 *)q, ry);
  }

  else
  {
    disc = Bq * Bq - 4.000000 * Aq * Cq;
    if(disc > 0.000000)
    {
      disc=sqrt(disc);
      t1 = (-Bq + disc) / (2.000000 * Aq);
      t2 = (-Bq - disc) / (2.000000 * Aq);
      ry->add_intersection(t1, (struct anon$15 *)q, ry);
      ry->add_intersection(t2, (struct anon$15 *)q, ry);
    }

  }
}

// c::quadric_normal
// file ../src/quadric.c line 100
void quadric_normal(const struct anon$28 *q, const struct anon$0 *pnt, struct ray_t$link247 *incident, struct anon$0 *N)
{
  double invlen;
  N->x = q->mat.a * (pnt->x - q->ctr.x) + q->mat.b * (pnt->y - q->ctr.y) + q->mat.c * (pnt->z - q->ctr.z) + q->mat.d;
  N->y = q->mat.b * (pnt->x - q->ctr.x) + q->mat.e * (pnt->y - q->ctr.y) + q->mat.f * (pnt->z - q->ctr.z) + q->mat.g;
  N->z = q->mat.c * (pnt->x - q->ctr.x) + q->mat.f * (pnt->y - q->ctr.y) + q->mat.h * (pnt->z - q->ctr.z) + q->mat.i;
  double return_value_sqrt$1;
  return_value_sqrt$1=sqrt(N->x * N->x + N->y * N->y + N->z * N->z);
  invlen = 1.000000 / return_value_sqrt$1;
  N->x = N->x * invlen;
  N->y = N->y * invlen;
  N->z = N->z * invlen;
  double return_value_VDot$2;
  return_value_VDot$2=VDot(N, &incident->d);
  if(return_value_VDot$2 > 0.000000)
  {
    N->x = -N->x;
    N->y = -N->y;
    N->z = -N->z;
  }

}

// c::read
// file /usr/include/x86_64-linux-gnu/bits/unistd.h line 34
signed long int read(signed int __fd, void *__buf, unsigned long int __nbytes)
{
  signed long int return_value___read_chk$1;
  signed long int return_value___read_chk_warn$2;
  signed long int return_value___read_alias$3;
  return_value___read_alias$3=__read_alias(__fd, __buf, __nbytes);
  return return_value___read_alias$3;
}

// c::readimage
// file ../src/imageio.h line 18
signed int readimage(struct anon$33 *img)
{
  signed int rc;
  signed int xres;
  signed int yres;
  signed int zres;
  unsigned char *imgdata;
  char *name = img->name;
  char msgtxt[2048l];
  xres = 1;
  yres = 1;
  zres = 1;
  char *return_value_strstr$8;
  return_value_strstr$8=strstr(name, ".ppm");
  char *return_value_strstr$7;
  char *return_value_strstr$6;
  char *return_value_strstr$5;
  char *return_value_strstr$4;
  char *return_value_strstr$3;
  char *return_value_strstr$2;
  char *return_value_strstr$1;
  if(!(return_value_strstr$8 == ((char *)NULL)))
    rc=readppm(name, &xres, &yres, &imgdata);

  else
  {
    return_value_strstr$7=strstr(name, ".tga");
    if(!(return_value_strstr$7 == ((char *)NULL)))
      rc=readtga(name, &xres, &yres, &imgdata);

    else
    {
      return_value_strstr$6=strstr(name, ".jpg");
      if(!(return_value_strstr$6 == ((char *)NULL)))
        rc=readjpeg(name, &xres, &yres, &imgdata);

      else
      {
        return_value_strstr$5=strstr(name, ".png");
        if(!(return_value_strstr$5 == ((char *)NULL)))
          rc=readpng(name, &xres, &yres, &imgdata);

        else
        {
          return_value_strstr$4=strstr(name, ".gif");
          if(!(return_value_strstr$4 == ((char *)NULL)))
            rc = 2;

          else
          {
            return_value_strstr$3=strstr(name, ".tiff");
            if(!(return_value_strstr$3 == ((char *)NULL)))
              rc = 2;

            else
            {
              return_value_strstr$2=strstr(name, ".rgb");
              if(!(return_value_strstr$2 == ((char *)NULL)))
                rc = 2;

              else
              {
                return_value_strstr$1=strstr(name, ".xpm");
                if(!(return_value_strstr$1 == ((char *)NULL)))
                  rc = 2;

                else
                  rc=readppm(name, &xres, &yres, &imgdata);
              }
            }
          }
        }
      }
    }
  }
  switch(rc)
  {

    case 4:
      {
        sprintf(msgtxt, "Short read encountered while loading image %s", name);
        rt_ui_message(100, msgtxt);
        rc = 0;
        goto __CPROVER_DUMP_L12;
      }
    case 2:
      {
        sprintf(msgtxt, "Cannot read unsupported format for image %s", name);
        rt_ui_message(100, msgtxt);
      }
    default:
      {

      __CPROVER_DUMP_L12:
        ;
        if(!(rc == 0))
          rc=fakeimage(name, &xres, &yres, &imgdata);

        if(rc == 0)
        {
          img->xres = xres;
          img->yres = yres;
          img->zres = zres;
          img->bpp = 3;
          img->data = imgdata;
        }

        return rc;
      }
  }
}

// c::readjpeg
// file ../src/jpeg.h line 7
signed int readjpeg(char *name, signed int *xres, signed int *yres, unsigned char **imgdata)
{
  return 2;
}

// c::readlink
// file /usr/include/x86_64-linux-gnu/bits/unistd.h line 139
signed long int readlink(const char * restrict __path, char * restrict __buf, unsigned long int __len)
{
  signed long int return_value___readlink_chk$1;
  signed long int return_value___readlink_chk_warn$2;
  signed long int return_value___readlink_alias$3;
  return_value___readlink_alias$3=__readlink_alias(__path, __buf, __len);
  return return_value___readlink_alias$3;
}

// c::readlinkat
// file /usr/include/x86_64-linux-gnu/bits/unistd.h line 173
signed long int readlinkat(signed int __fd, const char * restrict __path, char * restrict __buf, unsigned long int __len)
{
  signed long int return_value___readlinkat_chk$1;
  signed long int return_value___readlinkat_chk_warn$2;
  signed long int return_value___readlinkat_alias$3;
  return_value___readlinkat_alias$3=__readlinkat_alias(__fd, __path, __buf, __len);
  return return_value___readlinkat_alias$3;
}

// c::readmodel
// file ../demosrc/parse.h line 14
unsigned int readmodel(const char *modelfile, void *scene)
{
  struct anon$6 ph;
  unsigned int rc;
  signed int done;
  memset((void *)&ph, 0, 80ul /*[[struct anon$6]]*/);
  ph.filename = modelfile;
  ph.ifp=fopen(modelfile, "r");
  if(ph.ifp == ((struct _IO_FILE$link13 *)NULL))
    return (unsigned int)1;

  reset_tex_table(&ph, scene);
  rc = (unsigned int)0;
  done = 0;
  signed int return_value_stringcmp$1;
  while(done == 0)
  {
    char tmp[256l];
    fscanf(ph.ifp, "%s", (const void *)tmp);
    signed int return_value_stringcmp$2;
    return_value_stringcmp$2=stringcmp(tmp, "BEGIN_SCENE");
    if(return_value_stringcmp$2 == 0)
      done = 1;

    else
    {
      return_value_stringcmp$1=stringcmp(tmp, "#");
      if(return_value_stringcmp$1 == 0)
      {
        signed int c;
        while(TRUE)
        {
          c=fgetc(ph.ifp);
          if(c == 10 || c == -1)
            goto __CPROVER_DUMP_L5;

        }
      }

      else
      {
        fclose(ph.ifp);
        return (unsigned int)4;
      }
    }

  __CPROVER_DUMP_L5:
    ;
  }
  unsigned int return_value_GetScenedefs$3;
  return_value_GetScenedefs$3=GetScenedefs(&ph, scene);
  rc = rc | return_value_GetScenedefs$3;
  if(rc == 0u)
  {
    ph.numobjectsparsed = 0;
    do
    {
      rc=GetObject(&ph, scene);
      if(!(rc == 0u))
        goto __CPROVER_DUMP_L10;

      ph.numobjectsparsed = ph.numobjectsparsed + 1;
    }
    while(TRUE);

  __CPROVER_DUMP_L10:
    ;
    if(rc == 8u)
      rc = (unsigned int)0;

  }

  fclose(ph.ifp);
  free_tex_table(&ph, scene);
  return rc;
}

// c::readpng
// file ../src/pngfile.h line 7
signed int readpng(char *name, signed int *xres, signed int *yres, unsigned char **imgdata)
{
  return 2;
}

// c::readppm
// file ../src/ppm.h line 11
signed int readppm(char *name, signed int *xres, signed int *yres, unsigned char **imgdata)
{
  char data[256l];
  struct _IO_FILE$link40 *ifp;
  signed int i;
  signed int bytesread;
  signed int datasize;
  ifp=fopen(name, "r");
  if(ifp == ((struct _IO_FILE$link40 *)NULL))
    return 1;

  fscanf(ifp, "%s", (const void *)data);
  signed int tmp_statement_expression$1;
  unsigned long int __s1_len;
  unsigned long int __s2_len;
  _Bool tmp_if_expr$3;
  unsigned int return_value___builtin_strlen$2;
  if(TRUE)
  {
    if(!((unsigned long int)("P6" + 1l) + -((unsigned long int)"P6") == 1ul))
      goto __CPROVER_DUMP_L2;

    return_value___builtin_strlen$2=__builtin_strlen("P6");
    __s2_len = (unsigned long int)return_value___builtin_strlen$2;
    tmp_if_expr$3 = __s2_len < (unsigned long int)4 ? TRUE : FALSE;
  }

  else
  {

  __CPROVER_DUMP_L2:
    ;
    tmp_if_expr$3 = FALSE;
  }
  signed int tmp_if_expr$6;
  signed int tmp_statement_expression$4;
  signed int return_value___builtin_strcmp$5;
  if(tmp_if_expr$3)
  {
    const unsigned char *__s1 = (const unsigned char *)(const char *)data;
    signed int __result = (signed int)__s1[(signed long int)0] - (signed int)((const unsigned char *)(const char *)"P6")[(signed long int)0];
    if(__s2_len > 0ul)
    {
      if(__result == 0)
      {
        __result = (signed int)__s1[(signed long int)1] - (signed int)((const unsigned char *)(const char *)"P6")[(signed long int)1];
        if(__s2_len > 1ul)
        {
          if(__result == 0)
          {
            __result = (signed int)__s1[(signed long int)2] - (signed int)((const unsigned char *)(const char *)"P6")[(signed long int)2];
            if(__s2_len > 2ul)
            {
              if(__result == 0)
                __result = (signed int)__s1[(signed long int)3] - (signed int)((const unsigned char *)(const char *)"P6")[(signed long int)3];

            }

          }

        }

      }

    }

    tmp_statement_expression$4 = __result;
    tmp_if_expr$6 = tmp_statement_expression$4;
  }

  else
  {
    return_value___builtin_strcmp$5=__builtin_strcmp(data, "P6");
    tmp_if_expr$6 = return_value___builtin_strcmp$5;
  }
  tmp_statement_expression$1 = tmp_if_expr$6;
  if(!(tmp_statement_expression$1 == 0))
  {
    fclose(ifp);
    return 2;
  }

  *xres=getint(ifp);
  *yres=getint(ifp);
  i=getint(ifp);
  fread((void *)&i, (unsigned long int)1, (unsigned long int)1, ifp);
  datasize = 3 * *xres * *yres;
  void *return_value_malloc$7;
  return_value_malloc$7=malloc((unsigned long int)datasize);
  *imgdata = (unsigned char *)return_value_malloc$7;
  unsigned long int return_value_fread$8;
  return_value_fread$8=fread((void *)*imgdata, (unsigned long int)1, (unsigned long int)datasize, ifp);
  bytesread = (signed int)return_value_fread$8;
  fclose(ifp);
  if(!(bytesread == datasize))
    return 4;

  return 0;
}

// c::readtga
// file ../src/tgafile.h line 12
signed int readtga(char *name, signed int *xres, signed int *yres, unsigned char **imgdata)
{
  signed int format;
  signed int width;
  signed int height;
  signed int w1;
  signed int w2;
  signed int h1;
  signed int h2;
  signed int depth;
  signed int flags;
  signed int imgsize;
  signed int bytesread;
  signed int i;
  signed int tmp;
  struct _IO_FILE$link43 *ifp;
  ifp=fopen(name, "r");
  if(ifp == ((struct _IO_FILE$link43 *)NULL))
    return 1;

  _IO_getc(ifp);
  _IO_getc(ifp);
  format=_IO_getc(ifp);
  _IO_getc(ifp);
  _IO_getc(ifp);
  _IO_getc(ifp);
  _IO_getc(ifp);
  _IO_getc(ifp);
  _IO_getc(ifp);
  _IO_getc(ifp);
  _IO_getc(ifp);
  _IO_getc(ifp);
  w1=_IO_getc(ifp);
  w2=_IO_getc(ifp);
  h1=_IO_getc(ifp);
  h2=_IO_getc(ifp);
  depth=_IO_getc(ifp);
  flags=_IO_getc(ifp);
  if(format == 2)
  {
    if(depth != 24)
      goto __CPROVER_DUMP_L2;

  }

  else
  {

  __CPROVER_DUMP_L2:
    ;
    fclose(ifp);
    return 2;
  }
  width = w2 << 8 | w1;
  height = h2 << 8 | h1;
  imgsize = 3 * width * height;
  void *return_value_malloc$1;
  return_value_malloc$1=malloc((unsigned long int)imgsize);
  *imgdata = (unsigned char *)return_value_malloc$1;
  unsigned long int return_value_fread$2;
  return_value_fread$2=fread((void *)*imgdata, (unsigned long int)1, (unsigned long int)imgsize, ifp);
  bytesread = (signed int)return_value_fread$2;
  fclose(ifp);
  if(flags == 32)
  {
    signed int rowsize = 3 * width;
    unsigned char *copytmp;
    void *return_value_malloc$3;
    return_value_malloc$3=malloc((unsigned long int)rowsize);
    copytmp = (unsigned char *)return_value_malloc$3;
    i = 0;
    while(!(i >= height / 2))
    {
      memcpy((void *)copytmp, (const void *)&(*imgdata)[(signed long int)(rowsize * i)], (unsigned long int)rowsize);
      memcpy((void *)&(*imgdata)[(signed long int)(rowsize * i)], (const void *)&(*imgdata)[(signed long int)(rowsize * ((height - 1) - i))], (unsigned long int)rowsize);
      memcpy((void *)&(*imgdata)[(signed long int)(rowsize * ((height - 1) - i))], (const void *)copytmp, (unsigned long int)rowsize);
      i = i + 1;
    }
    free((void *)copytmp);
  }

  i = 0;
  while(!(i >= imgsize))
  {
    tmp = (signed int)(*imgdata)[(signed long int)i];
    (*imgdata)[(signed long int)i] = (*imgdata)[(signed long int)(i + 2)];
    (*imgdata)[(signed long int)(i + 2)] = (unsigned char)tmp;
    i = i + 3;
  }
  *xres = width;
  *yres = height;
  if(!(bytesread == imgsize))
    return 4;

  return 0;
}

// c::realpath
// file /usr/include/x86_64-linux-gnu/bits/stdlib.h line 37
char * realpath(const char * restrict __name, char * restrict __resolved)
{
  char *return_value___realpath_alias$2;
  return_value___realpath_alias$2=__realpath_alias(__name, __resolved);
  return return_value___realpath_alias$2;
}

// c::rebuild_table
// file ../src/hash.c line 50
static void rebuild_table(struct rt_hash_t *tptr)
{
  struct hash_node_t **old_bucket;
  struct hash_node_t *old_hash;
  struct hash_node_t *tmp;
  signed int old_size;
  signed int h;
  signed int i;
  old_bucket = tptr->bucket;
  old_size = tptr->size;
  rt_hash_init(tptr, old_size << 1);
  i = 0;
  while(!(i >= old_size))
  {
    old_hash = old_bucket[(signed long int)i];
    while(!(old_hash == ((struct hash_node_t *)NULL)))
    {
      tmp = old_hash;
      old_hash = old_hash->next;
      h=hash(tptr, tmp->key);
      tmp->next = tptr->bucket[(signed long int)h];
      tptr->bucket[(signed long int)h] = tmp;
      tptr->entries = tptr->entries + 1;
    }
    i = i + 1;
  }
  free((void *)old_bucket);
  return;
}

// c::rendercheck
// file ../src/render.c line 168
static void rendercheck(struct anon$30$link108 *scene)
{
  double runtime;
  void *stth;
  if(!(scene->verbosemode == 0))
  {
    if(scene->mynode == 0)
    {
      char rendercheck$$1$$1$$msgtxt[1024l];
      signed int i;
      signed int totalcpus;
      double totalspeed;
      rt_ui_message(100, "CPU Information:");
      totalspeed = 0.000000;
      totalcpus = 0;
      i = 0;
      while(!(i >= scene->nodes))
      {
        sprintf(rendercheck$$1$$1$$msgtxt, "  Node %4d: %2d CPUs, CPU Speed %4.2f, Node Speed %6.2f Name: %s", i, (scene->cpuinfo + (signed long int)i)->numcpus, (scene->cpuinfo + (signed long int)i)->cpuspeed, (scene->cpuinfo + (signed long int)i)->nodespeed, (const void *)(scene->cpuinfo + (signed long int)i)->machname);
        rt_ui_message(100, rendercheck$$1$$1$$msgtxt);
        totalcpus = totalcpus + (scene->cpuinfo + (signed long int)i)->numcpus;
        totalspeed = totalspeed + (scene->cpuinfo + (signed long int)i)->nodespeed;
        i = i + 1;
      }
      sprintf(rendercheck$$1$$1$$msgtxt, "  Total CPUs: %d", totalcpus);
      rt_ui_message(100, rendercheck$$1$$1$$msgtxt);
      sprintf(rendercheck$$1$$1$$msgtxt, "  Total Speed: %f\n", totalspeed);
      rt_ui_message(100, rendercheck$$1$$1$$msgtxt);
    }

  }

  rt_barrier_sync();
  stth=rt_timer_create();
  rt_timer_start(stth);
  rt_autoshader(scene);
  if(scene->boundmode == 1)
    engrid_scene(scene, scene->boundthresh);

  if(!(scene->cliplist == ((struct list$link110 *)NULL)))
    scene->flags = scene->flags | (unsigned int)4096;

  if(!(scene->imginternal == 0))
  {
    if(!(scene->img == NULL))
    {
      free(scene->img);
      scene->img = NULL;
    }

  }

  if(scene->img == NULL)
  {
    scene->imginternal = 1;
    if(!(scene->verbosemode == 0))
    {
      if(scene->mynode == 0)
        rt_ui_message(100, "Allocating Image Buffer.");

    }

    if(scene->imgbufformat == 0)
      scene->img=malloc((unsigned long int)(scene->hres * scene->vres * 3));

    else
      if(scene->imgbufformat == 1)
        scene->img=malloc(4ul /*[[float]]*/ * (unsigned long int)scene->hres * (unsigned long int)scene->vres * (unsigned long int)3);

      else
        rt_ui_message(100, "Illegal image buffer format specifier!");
    if(scene->img == NULL)
    {
      scene->imginternal = 0;
      rt_ui_message(100, "Warning: Failed To Allocate Image Buffer!");
    }

  }

  destroy_render_threads(scene);
  create_render_threads(scene);
  scene->parbuf=rt_init_scanlinereceives(scene);
  scene->scenecheck = 0;
  rt_timer_stop(stth);
  runtime=rt_timer_time(stth);
  rt_timer_destroy(stth);
  if(scene->mynode == 0)
  {
    char rendercheck$$1$$5$$msgtxt[256l];
    sprintf(rendercheck$$1$$5$$msgtxt, "Preprocessing Time: %10.4f seconds", runtime);
    rt_ui_message(100, rendercheck$$1$$5$$msgtxt);
  }

}

// c::renderio
// file ../src/render.c line 273
static void renderio(struct anon$30$link108 *scene)
{
  double iotime;
  char msgtxt[256l];
  void *ioth;
  ioth=rt_timer_create();
  rt_timer_start(ioth);
  if(scene->imgbufformat == 1)
  {
    if(!((1 & scene->imgprocess) == 0))
    {
      normalize_rgb96f(scene->hres, scene->vres, (float *)scene->img);
      rt_ui_message(100, "Post-processing: normalizing pixel values.");
    }

    if(!((2 & scene->imgprocess) == 0))
    {
      gamma_rgb96f(scene->hres, scene->vres, (float *)scene->img, scene->imggamma);
      rt_ui_message(100, "Post-processing: gamma correcting pixel values.");
    }

  }

  else
    if(scene->imgbufformat == 0)
    {
      if(!((3 & scene->imgprocess) == 0))
        rt_ui_message(100, "Can't post-process 24-bit integer image data");

    }

  if(scene->imgcrop.cropmode == 0)
    writeimage(scene->outfilename, scene->hres, scene->vres, scene->img, scene->imgbufformat, scene->imgfileformat);

  else
    if(scene->imgbufformat == 1)
    {
      float *renderio$$1$$4$$1$$imgcrop;
      renderio$$1$$4$$1$$imgcrop=image_crop_rgb96f(scene->hres, scene->vres, (float *)scene->img, scene->imgcrop.xres, scene->imgcrop.yres, scene->imgcrop.xstart, scene->imgcrop.ystart);
      writeimage(scene->outfilename, scene->imgcrop.xres, scene->imgcrop.yres, (void *)renderio$$1$$4$$1$$imgcrop, scene->imgbufformat, scene->imgfileformat);
      free((void *)renderio$$1$$4$$1$$imgcrop);
    }

    else
      if(scene->imgbufformat == 0)
      {
        unsigned char *renderio$$1$$4$$2$$imgcrop;
        renderio$$1$$4$$2$$imgcrop=image_crop_rgb24(scene->hres, scene->vres, (unsigned char *)scene->img, scene->imgcrop.xres, scene->imgcrop.yres, scene->imgcrop.xstart, scene->imgcrop.ystart);
        writeimage(scene->outfilename, scene->imgcrop.xres, scene->imgcrop.yres, (void *)renderio$$1$$4$$2$$imgcrop, scene->imgbufformat, scene->imgfileformat);
        free((void *)renderio$$1$$4$$2$$imgcrop);
      }

  rt_timer_stop(ioth);
  iotime=rt_timer_time(ioth);
  rt_timer_destroy(ioth);
  sprintf(msgtxt, "    Image I/O Time: %10.4f seconds", iotime);
  rt_ui_message(100, msgtxt);
}

// c::renderscene
// file ../src/render.h line 9
void renderscene(struct anon$30$link108 *scene)
{
  double runtime;
  void *rtth;
  if(!(scene->scenecheck == 0))
    rendercheck(scene);

  if(scene->mynode == 0)
    rt_ui_progress(0);

  rtth=rt_timer_create();
  rt_timer_start(rtth);
  camera_init(scene);
  rt_thread_barrier(((struct anon$45 *)scene->threadparms + (signed long int)0)->runbar, 1);
  thread_trace(&((struct anon$45 *)scene->threadparms)[(signed long int)0]);
  rt_timer_stop(rtth);
  runtime=rt_timer_time(rtth);
  rt_timer_destroy(rtth);
  if(scene->mynode == 0)
  {
    char msgtxt[256l];
    rt_ui_progress(100);
    sprintf(msgtxt, "\n  Ray Tracing Time: %10.4f seconds", runtime);
    rt_ui_message(100, msgtxt);
    if(!(scene->writeimagefile == 0))
      renderio(scene);

  }

}

// c::renormalize_normals
// file ../demosrc/ac3dparse.c line 324
static void renormalize_normals(struct anon$0 *normals, signed int numverts)
{
  signed int i = 0;
  while(!(i >= numverts))
  {
    normalize(&normals[(signed long int)i]);
    i = i + 1;
  }
}

// c::reset_tex_table
// file ../demosrc/parse.c line 45
static void reset_tex_table(struct anon$6 *ph, void *scene)
{
  struct anon$7 apitex;
  ph->maxtextures = 512;
  ph->numtextures = 0;
  void *return_value_malloc$1;
  return_value_malloc$1=malloc((unsigned long int)ph->maxtextures * 16ul /*[[struct anon$5]]*/);
  ph->textable = (struct anon$5 *)return_value_malloc$1;
  memset((void *)ph->textable, 0, (unsigned long int)ph->maxtextures * 16ul /*[[struct anon$5]]*/);
  apitex.col.r = (float)1.000000;
  apitex.col.g = (float)1.000000;
  apitex.col.b = (float)1.000000;
  apitex.ambient = 1.000000e-1;
  apitex.diffuse = 9.000000e-1;
  apitex.specular = 0.000000;
  apitex.opacity = 1.000000;
  apitex.texturefunc = 0;
  ph->defaulttex.tex=rt_texture(scene, &apitex);
  rt_hash_init(&ph->texhash, 1024);
}

// c::reset_tex_table$link39
// file ../demosrc/ac3dparse.c line 58
static void reset_tex_table$link39(void)
{
  numtextures = 0;
  memset((void *)&textable, 0, 262144ul /*[[struct anon$11 [8192l]]]*/);
}

// c::ring_bbox
// file ../src/ring.c line 41
static signed int ring_bbox(void *obj, struct anon$0 *min, struct anon$0 *max)
{
  struct anon$58 *r = (struct anon$58 *)obj;
  min->x = r->ctr.x - r->outrad;
  min->y = r->ctr.y - r->outrad;
  min->z = r->ctr.z - r->outrad;
  max->x = r->ctr.x + r->outrad;
  max->y = r->ctr.y + r->outrad;
  max->z = r->ctr.z + r->outrad;
  return 1;
}

// c::ring_intersect
// file ../src/ring.c line 54
static void ring_intersect(const struct anon$58 *rng, struct ray_t$link108 *ry)
{
  double d;
  double t;
  double td;
  struct anon$0 hit;
  struct anon$0 pnt;
  double return_value_VDot$1;
  return_value_VDot$1=VDot(&rng->ctr, &rng->norm);
  d = -return_value_VDot$1;
  double return_value_VDot$2;
  return_value_VDot$2=VDot(&rng->norm, &ry->o);
  t = -(d + return_value_VDot$2);
  td=VDot(&rng->norm, &ry->d);
  if(IEEE_FLOAT_NOTEQUAL(td, 0.000000))
  {
    t = t / td;
    if(t >= 0.000000)
    {
      hit=Raypnt(ry, t);
      pnt.x = hit.x - rng->ctr.x;
      pnt.y = hit.y - rng->ctr.y;
      pnt.z = hit.z - rng->ctr.z;
      td = pnt.x * pnt.x + pnt.y * pnt.y + pnt.z * pnt.z;
      td=sqrt(td);
      if(td > rng->inrad)
      {
        if(td < rng->outrad)
          ry->add_intersection(t, (struct anon$15 *)rng, ry);

      }

    }

  }

}

// c::ring_normal
// file ../src/ring.c line 76
static void ring_normal(const struct anon$58 *rng, const struct anon$0 *pnt, struct ray_t$link108 *incident, struct anon$0 *N)
{
  *N = rng->norm;
  double return_value_VDot$1;
  return_value_VDot$1=VDot(N, &incident->d);
  if(return_value_VDot$1 > 0.000000)
  {
    N->x = -N->x;
    N->y = -N->y;
    N->z = -N->z;
  }

}

// c::rng_drand
// file ../src/util.c line 558
double rng_drand(struct anon$18 *rngh)
{
  unsigned int return_value_rng_urand$1;
  return_value_rng_urand$1=rng_urand(rngh);
  return (double)return_value_rng_urand$1 / 4.294967e+9;
}

// c::rng_drand_init
// file ../src/util.c line 554
void rng_drand_init(struct anon$18 *rngh)
{
  rng_urand_init(rngh);
}

// c::rng_drand_seed
// file ../src/util.c line 562
void rng_drand_seed(struct anon$18 *rngh, unsigned int seed)
{
  rng_urand_seed(rngh, seed);
}

// c::rng_frand
// file ../src/util.c line 546
float rng_frand(struct anon$18 *rngh)
{
  unsigned int return_value_rng_urand$1;
  return_value_rng_urand$1=rng_urand(rngh);
  return (float)((double)return_value_rng_urand$1 / 4.294967e+9);
}

// c::rng_frand_init
// file ../src/util.h line 76
void rng_frand_init(struct anon$18 *rngh)
{
  rng_urand_init(rngh);
}

// c::rng_frand_seed
// file ../src/util.c line 550
void rng_frand_seed(struct anon$18 *rngh, unsigned int seed)
{
  rng_urand_seed(rngh, seed);
}

// c::rng_seed_from_tid_nodeid
// file ../src/util.h line 87
unsigned int rng_seed_from_tid_nodeid(signed int tid, signed int node)
{
  unsigned int seedbuf[11l] = { (unsigned int)12345678, (unsigned int)3498711, (unsigned int)19872134, (unsigned int)1004141, (unsigned int)1275987, (unsigned int)23904273, (unsigned int)2091097, (unsigned int)19872727, (unsigned int)31337, (unsigned int)20872837, (unsigned int)1020733 };
  return seedbuf[(signed long int)(tid % 11)] + (unsigned int)(node * 31337);
}

// c::rng_urand
// file ../src/util.c line 487
unsigned int rng_urand(struct anon$18 *rngh)
{
  rngh->x = rngh->x * (unsigned int)69069 + (unsigned int)1;
  rngh->y = rngh->y ^ rngh->y << 13;
  rngh->y = rngh->y ^ rngh->y >> 17;
  rngh->y = rngh->y ^ rngh->y << 5;
  rngh->k = (rngh->z >> 2) + (rngh->w >> 3) + (rngh->c >> 2);
  rngh->m = rngh->w + rngh->w + rngh->z + rngh->c;
  rngh->z = rngh->w;
  rngh->w = rngh->m;
  rngh->c = rngh->k >> 30;
  return rngh->x + rngh->y + rngh->w;
}

// c::rng_urand_init
// file ../src/util.c line 469
void rng_urand_init(struct anon$18 *rngh)
{
  rngh->x = (unsigned int)1;
  rngh->y = (unsigned int)2;
  rngh->z = (unsigned int)4;
  rngh->w = (unsigned int)8;
  rngh->c = (unsigned int)0;
  rngh->k = (unsigned int)0;
  rngh->m = (unsigned int)0;
}

// c::rng_urand_seed
// file ../src/util.c line 479
void rng_urand_seed(struct anon$18 *rngh, unsigned int seed)
{
  rngh->x = seed | (unsigned int)1;
  rngh->y = seed | (unsigned int)2;
  rngh->z = seed | (unsigned int)4;
  rngh->w = seed | (unsigned int)8;
  rngh->c = seed | (unsigned int)0;
}

// c::rt_aa_maxsamples
// file ../src/tachyon.h line 146
void rt_aa_maxsamples(void *voidscene, signed int maxsamples)
{
  struct anon$17 *scene = (struct anon$17 *)voidscene;
  if(maxsamples >= 0)
    scene->antialiasing = maxsamples;

  else
    scene->antialiasing = 0;
}

// c::rt_allocate_reqbuf
// file ../src/parallel.c line 141
void * rt_allocate_reqbuf(signed int count)
{
  return NULL;
}

// c::rt_ambient_occlusion
// file ../src/tachyon.h line 377
void rt_ambient_occlusion(void *voidscene, signed int numsamples, struct anon$4 col)
{
  struct anon$17 *scene = (struct anon$17 *)voidscene;
  scene->ambocc.numsamples = numsamples;
  scene->ambocc.col.r = col.r;
  scene->ambocc.col.g = col.g;
  scene->ambocc.col.b = col.b;
}

// c::rt_autoshader
// file ../src/render.c line 28
static void rt_autoshader(struct anon$30$link108 *scene)
{
  if(scene->shader == ((struct anon$4 (*)(void *))NULL))
    scene->shader = (struct anon$4 (*)(void *))full_shader;

}

// c::rt_background
// file ../src/tachyon.h line 214
void rt_background(void *voidscene, struct anon$4 col)
{
  struct anon$17 *scene = (struct anon$17 *)voidscene;
  scene->bgtex.background.r = col.r;
  scene->bgtex.background.g = col.g;
  scene->bgtex.background.b = col.b;
}

// c::rt_background_mode
// file ../src/api.c line 311
void rt_background_mode(void *voidscene, signed int mode)
{
  struct anon$17 *scene = (struct anon$17 *)voidscene;
  if(!(mode == 1))
  {
    if(mode == 0)
      goto __CPROVER_DUMP_L2;

  }

  else
  {
    scene->bgtexfunc = sky_sphere_background_texture;
    goto __CPROVER_DUMP_L3;
  }

__CPROVER_DUMP_L2:
  ;
  scene->bgtexfunc = solid_background_texture;

__CPROVER_DUMP_L3:
  ;
}

// c::rt_background_sky_sphere
// file ../src/api.c line 292
void rt_background_sky_sphere(void *voidscene, struct anon$0 up, double topval, double botval, struct anon$4 topcol, struct anon$4 botcol)
{
  struct anon$17 *scene = (struct anon$17 *)voidscene;
  scene->bgtex.gradient = up;
  scene->bgtex.gradtopval = topval;
  scene->bgtex.gradbotval = botval;
  scene->bgtex.backgroundtop.r = topcol.r;
  scene->bgtex.backgroundtop.g = topcol.g;
  scene->bgtex.backgroundtop.b = topcol.b;
  scene->bgtex.backgroundbot.r = botcol.r;
  scene->bgtex.backgroundbot.g = botcol.g;
  scene->bgtex.backgroundbot.b = botcol.b;
}

// c::rt_barrier_sync
// file ../src/parallel.c line 67
void rt_barrier_sync(void)
{
  ;
}

// c::rt_boundmode
// file ../src/tachyon.h line 262
void rt_boundmode(void *voidscene, signed int mode)
{
  struct anon$17 *scene = (struct anon$17 *)voidscene;
  scene->boundmode = mode;
  scene->scenecheck = 1;
}

// c::rt_boundthresh
// file ../src/tachyon.h line 274
void rt_boundthresh(void *voidscene, signed int threshold)
{
  struct anon$17 *scene = (struct anon$17 *)voidscene;
  if(threshold > 1)
    scene->boundthresh = threshold;

  else
  {
    signed int return_value_rt_mynode$1;
    return_value_rt_mynode$1=rt_mynode();
    if(return_value_rt_mynode$1 == 0)
    {
      rt_ui_message(100, "Out-of-range automatic bounding threshold.\n");
      rt_ui_message(100, "Automatic bounding threshold reset to default.\n");
    }

    scene->boundthresh = 16;
  }
  scene->scenecheck = 1;
}

// c::rt_box
// file ../src/tachyon.h line 387
void rt_box(void *scene, void *tex, struct anon$0 min, struct anon$0 max)
{
  struct anon$26 *return_value_newbox$1;
  return_value_newbox$1=newbox(tex, min, max);
  add_bounded_object((struct anon$17 *)scene, (struct anon$15 *)return_value_newbox$1);
}

// c::rt_camera_dof
// file ../src/tachyon.h line 312
void rt_camera_dof(void *voidscene, double focallength, double aperture)
{
  struct anon$17 *scene = (struct anon$17 *)voidscene;
  cameradof(&scene->camera, focallength, aperture);
}

// c::rt_camera_frustum
// file ../src/tachyon.h line 327
void rt_camera_frustum(void *voidscene, double left, double right, double bottom, double top)
{
  struct anon$17 *scene = (struct anon$17 *)voidscene;
  camerafrustum(&scene->camera, left, right, bottom, top);
}

// c::rt_camera_position
// file ../src/tachyon.h line 317
void rt_camera_position(void *voidscene, struct anon$0 camcent, struct anon$0 viewvec, struct anon$0 upvec)
{
  struct anon$17 *scene = (struct anon$17 *)voidscene;
  cameraposition(&scene->camera, camcent, viewvec, upvec);
}

// c::rt_camera_projection
// file ../src/tachyon.h line 307
void rt_camera_projection(void *voidscene, signed int mode)
{
  struct anon$17 *scene = (struct anon$17 *)voidscene;
  cameraprojection(&scene->camera, mode);
}

// c::rt_camera_setup
// file ../src/tachyon.h line 301
void rt_camera_setup(void *voidscene, double zoom, double aspectratio, signed int antialiasing, signed int raydepth, struct anon$0 camcent, struct anon$0 viewvec, struct anon$0 upvec)
{
  struct anon$17 *scene = (struct anon$17 *)voidscene;
  camerasetup(scene, zoom, camcent, viewvec, upvec);
  scene->aspectratio = aspectratio;
  rt_aa_maxsamples(voidscene, antialiasing);
  scene->raydepth = raydepth;
}

// c::rt_clip_dv
// file ../src/api.c line 1029
void rt_clip_dv(void *voidscene, signed int numplanes, double *planes)
{
  struct list *lst;
  struct anon$22 *clip;
  signed int i;
  struct anon$17 *scene = (struct anon$17 *)voidscene;
  void *return_value_malloc$1;
  return_value_malloc$1=malloc(16ul /*[[struct anon$22]]*/);
  clip = (struct anon$22 *)return_value_malloc$1;
  clip->numplanes = numplanes;
  void *return_value_malloc$2;
  return_value_malloc$2=malloc((unsigned long int)numplanes * 8ul /*[[double]]*/ * (unsigned long int)4);
  clip->planes = (double *)return_value_malloc$2;
  i = 0;
  while(!(i >= 4 * numplanes))
  {
    clip->planes[(signed long int)i] = planes[(signed long int)i];
    i = i + 1;
  }
  void *return_value_malloc$3;
  return_value_malloc$3=malloc(16ul /*[[struct list]]*/);
  lst = (struct list *)return_value_malloc$3;
  lst->item = (void *)clip;
  lst->next = scene->cliplist;
  scene->cliplist = lst;
  scene->curclipgroup = clip;
}

// c::rt_clip_fv
// file ../src/tachyon.h line 433
void rt_clip_fv(void *voidscene, signed int numplanes, float *planes)
{
  struct list *lst;
  struct anon$22 *clip;
  signed int i;
  struct anon$17 *scene = (struct anon$17 *)voidscene;
  void *return_value_malloc$1;
  return_value_malloc$1=malloc(16ul /*[[struct anon$22]]*/);
  clip = (struct anon$22 *)return_value_malloc$1;
  clip->numplanes = numplanes;
  void *return_value_malloc$2;
  return_value_malloc$2=malloc((unsigned long int)numplanes * 8ul /*[[double]]*/ * (unsigned long int)4);
  clip->planes = (double *)return_value_malloc$2;
  i = 0;
  while(!(i >= 4 * numplanes))
  {
    clip->planes[(signed long int)i] = (double)planes[(signed long int)i];
    i = i + 1;
  }
  void *return_value_malloc$3;
  return_value_malloc$3=malloc(16ul /*[[struct list]]*/);
  lst = (struct list *)return_value_malloc$3;
  lst->item = (void *)clip;
  lst->next = scene->cliplist;
  scene->cliplist = lst;
  scene->curclipgroup = clip;
}

// c::rt_clip_off
// file ../src/tachyon.h line 435
void rt_clip_off(void *voidscene)
{
  struct anon$17 *scene = (struct anon$17 *)voidscene;
  scene->curclipgroup = (struct anon$22 *)NULL;
}

// c::rt_color
// file ../src/tachyon.h line 60
struct anon$4 rt_color(double r, double g, double b)
{
  struct anon$4 c;
  c.r = (float)r;
  c.g = (float)g;
  c.b = (float)b;
  return c;
}

// c::rt_cond_broadcast
// file ../src/threads.c line 386
signed int rt_cond_broadcast(union anon$42 *cvp)
{
  signed int status = 0;
  status=pthread_cond_broadcast(cvp);
  return status;
}

// c::rt_cond_destroy
// file ../src/threads.c line 271
signed int rt_cond_destroy(union anon$42 *cvp)
{
  signed int status = 0;
  status=pthread_cond_destroy(cvp);
  return status;
}

// c::rt_cond_init
// file ../src/threads.c line 235
signed int rt_cond_init(union anon$42 *cvp)
{
  signed int status = 0;
  status=pthread_cond_init(cvp, (const union anon$43 *)NULL);
  return status;
}

// c::rt_cond_signal
// file ../src/threads.c line 354
signed int rt_cond_signal(union anon$42 *cvp)
{
  signed int status = 0;
  status=pthread_cond_signal(cvp);
  return status;
}

// c::rt_cond_wait
// file ../src/threads.c line 295
signed int rt_cond_wait(union anon$42 *cvp, union anon$40 *mp)
{
  signed int status = 0;
  status=pthread_cond_wait(cvp, mp);
  return status;
}

// c::rt_crop_disable
// file ../src/api.c line 206
void rt_crop_disable(void *voidscene)
{
  struct anon$17 *scene = (struct anon$17 *)voidscene;
  scene->imgcrop.cropmode = 0;
  scene->imgcrop.xres = 0;
  scene->imgcrop.yres = 0;
  scene->imgcrop.xstart = 0;
  scene->imgcrop.ystart = 0;
}

// c::rt_crop_output
// file ../src/tachyon.h line 138
void rt_crop_output(void *voidscene, signed int hres, signed int vres, signed int sx, signed int sy)
{
  struct anon$17 *scene = (struct anon$17 *)voidscene;
  scene->imgcrop.cropmode = 1;
  scene->imgcrop.xres = hres;
  scene->imgcrop.yres = vres;
  scene->imgcrop.xstart = sx;
  scene->imgcrop.ystart = sy;
}

// c::rt_cylinder
// file ../src/tachyon.h line 421
void rt_cylinder(void *scene, void *tex, struct anon$0 ctr, struct anon$0 axis, double rad)
{
  struct anon$15 *return_value_newcylinder$1;
  return_value_newcylinder$1=newcylinder(tex, ctr, axis, rad);
  add_unbounded_object((struct anon$17 *)scene, return_value_newcylinder$1);
}

// c::rt_define_image
// file ../src/tachyon.h line 347
void rt_define_image(const char *name, signed int xs, signed int ys, signed int zs, unsigned char *rgb)
{
  AllocateImageRGB24(name, xs, ys, zs, rgb);
}

// c::rt_delete_scanlinereceives
// file ../src/parallel.h line 22
void rt_delete_scanlinereceives(void *voidhandle)
{
  ;
}

// c::rt_deletescene
// file ../src/tachyon.h line 100
void rt_deletescene(void *voidscene)
{
  struct anon$17 *scene = (struct anon$17 *)voidscene;
  struct list *cur;
  struct list *next;
  if(!(scene == ((struct anon$17 *)NULL)))
  {
    if(!(scene->imginternal == 0))
      free(scene->img);

    destroy_render_threads(scene);
    if(!(scene->parbuf == NULL))
      rt_delete_scanlinereceives(scene->parbuf);

    cur = scene->lightlist;
    while(!(cur == ((struct list *)NULL)))
    {
      next = cur->next;
      free_light_special(cur->item);
      free((void *)cur);
      cur = next;
    }
    cur = scene->texlist;
    while(!(cur == ((struct list *)NULL)))
    {
      next = cur->next;
      ((struct anon$25 *)cur->item)->methods->freetex(cur->item);
      free((void *)cur);
      cur = next;
    }
    cur = scene->cliplist;
    while(!(cur == ((struct list *)NULL)))
    {
      next = cur->next;
      free((void *)((struct anon$22 *)cur->item)->planes);
      free(cur->item);
      free((void *)cur);
      cur = next;
    }
    FreeTextures();
    free((void *)scene->cpuinfo);
    free_objects(scene->objgroup.boundedobj);
    free_objects(scene->objgroup.unboundedobj);
    free((void *)scene);
  }

}

// c::rt_directional_light
// file ../src/tachyon.h line 363
void * rt_directional_light(void *voidscene, void *tex, struct anon$0 dir)
{
  struct directional_light_t *li;
  struct anon$17 *scene = (struct anon$17 *)voidscene;
  struct list *lst;
  VNorm(&dir);
  li=newdirectionallight(tex, dir);
  void *return_value_malloc$1;
  return_value_malloc$1=malloc(16ul /*[[struct list]]*/);
  lst = (struct list *)return_value_malloc$1;
  lst->item = (void *)li;
  lst->next = scene->lightlist;
  scene->lightlist = lst;
  scene->numlights = scene->numlights + 1;
  return (void *)li;
}

// c::rt_extvol
// file ../src/api.c line 843
void rt_extvol(void *scene, void *tex, struct anon$0 min, struct anon$0 max, signed int samples, double (*evaluator)(double, double, double))
{
  struct anon$29 *return_value_newextvol$1;
  return_value_newextvol$1=newextvol(tex, min, max, samples, evaluator);
  add_bounded_object((struct anon$17 *)scene, (struct anon$15 *)return_value_newextvol$1);
}

// c::rt_fcylinder
// file ../src/tachyon.h line 423
void rt_fcylinder(void *scene, void *tex, struct anon$0 ctr, struct anon$0 axis, double rad)
{
  struct anon$15 *return_value_newfcylinder$1;
  return_value_newfcylinder$1=newfcylinder(tex, ctr, axis, rad);
  add_bounded_object((struct anon$17 *)scene, return_value_newfcylinder$1);
}

// c::rt_finalize
// file ../src/tachyon.h line 85
void rt_finalize(void)
{
  FreeTextures();
  rt_par_finish();
}

// c::rt_fog_mode
// file ../src/tachyon.h line 241
void rt_fog_mode(void *voidscene, signed int mode)
{
  struct anon$17 *scene = (struct anon$17 *)voidscene;
  switch(mode)
  {

    case 1:
      {
        scene->fog.fog_fctn = fog_color_linear;
        goto __CPROVER_DUMP_L5;
      }
    case 2:
      {
        scene->fog.fog_fctn = fog_color_exp;
        goto __CPROVER_DUMP_L5;
      }
    case 3:
      {
        scene->fog.fog_fctn = fog_color_exp2;
        goto __CPROVER_DUMP_L5;
      }
    case 0:

      default:
        scene->fog.fog_fctn = (struct anon$4 (*)(struct fogdata_t *, struct anon$4, double))NULL;
  }

__CPROVER_DUMP_L5:
  ;
}

// c::rt_fog_parms
// file ../src/tachyon.h line 246
void rt_fog_parms(void *voidscene, struct anon$4 col, double start, double end, double density)
{
  struct anon$17 *scene = (struct anon$17 *)voidscene;
  scene->fog.col = col;
  scene->fog.start = start;
  scene->fog.end = end;
  scene->fog.density = density;
}

// c::rt_fog_rendering_mode
// file ../src/tachyon.h line 236
void rt_fog_rendering_mode(void *voidscene, signed int mode)
{
  struct anon$17 *scene = (struct anon$17 *)voidscene;
  if(!(mode == 1))
  {
    if(mode == 0)
      goto __CPROVER_DUMP_L2;

  }

  else
  {
    scene->fog.type = 1;
    goto __CPROVER_DUMP_L3;
  }

__CPROVER_DUMP_L2:
  ;
  scene->fog.type = 0;

__CPROVER_DUMP_L3:
  ;
}

// c::rt_free_reqbuf
// file ../src/parallel.c line 160
void rt_free_reqbuf(void *voidhandle)
{
  ;
}

// c::rt_get_camera_position
// file ../src/api.c line 165
void rt_get_camera_position(void *voidscene, struct anon$0 *camcent, struct anon$0 *viewvec, struct anon$0 *upvec, struct anon$0 *rightvec)
{
  struct anon$17 *scene = (struct anon$17 *)voidscene;
  getcameraposition(&scene->camera, camcent, viewvec, upvec, rightvec);
}

// c::rt_get_resolution
// file ../src/tachyon.h line 131
void rt_get_resolution(void *voidscene, signed int *hres, signed int *vres)
{
  struct anon$17 *scene = (struct anon$17 *)voidscene;
  *hres = scene->hres;
  *vres = scene->vres;
}

// c::rt_getcpuinfo
// file ../src/parallel.h line 13
signed int rt_getcpuinfo(struct anon$13 **nodes)
{
  signed int numnodes;
  numnodes=rt_numnodes();
  signed int mynode;
  mynode=rt_mynode();
  void *return_value_malloc$1;
  return_value_malloc$1=malloc((unsigned long int)numnodes * 536ul /*[[struct anon$13]]*/);
  *nodes = (struct anon$13 *)return_value_malloc$1;
  (*nodes + (signed long int)mynode)->numcpus=rt_thread_numprocessors();
  (*nodes + (signed long int)mynode)->cpuspeed = 1.000000;
  (*nodes + (signed long int)mynode)->nodespeed = (double)(*nodes + (signed long int)mynode)->numcpus * (*nodes + (signed long int)mynode)->cpuspeed;
  gethostname((*nodes + (signed long int)mynode)->machname, (unsigned long int)511);
  return numnodes;
}

// c::rt_hash_delete
// file ../src/hash.c line 173
signed int rt_hash_delete(struct rt_hash_t *tptr, const char *key)
{
  struct hash_node_t *node;
  struct hash_node_t *last;
  signed int data;
  signed int h;
  h=hash(tptr, key);
  node = tptr->bucket[(signed long int)h];
  signed int tmp_statement_expression$1;
  while(!(node == ((struct hash_node_t *)NULL)))
  {
    unsigned long int __s1_len;
    unsigned long int __s2_len;
    signed int return_value___builtin_strcmp$2;
    return_value___builtin_strcmp$2=__builtin_strcmp(node->key, key);
    tmp_statement_expression$1 = return_value___builtin_strcmp$2;
    if(tmp_statement_expression$1 == 0)
      goto __CPROVER_DUMP_L2;

    node = node->next;
  }

__CPROVER_DUMP_L2:
  ;
  if(node == ((struct hash_node_t *)NULL))
    return -1;

  _Bool tmp_if_expr$3;
  if(node == tptr->bucket[(signed long int)h])
    tptr->bucket[(signed long int)h] = node->next;

  else
  {
    last = tptr->bucket[(signed long int)h];
    do
    {
      if(!(last == ((struct hash_node_t *)NULL)))
        tmp_if_expr$3 = last->next != ((struct hash_node_t *)NULL) ? TRUE : FALSE;

      else
        tmp_if_expr$3 = FALSE;
      if(!tmp_if_expr$3)
        goto __CPROVER_DUMP_L8;

      if(last->next == node)
        goto __CPROVER_DUMP_L8;

      last = last->next;
    }
    while(TRUE);

  __CPROVER_DUMP_L8:
    ;
    last->next = node->next;
  }
  data = node->data;
  free((void *)node);
  return data;
}

// c::rt_hash_destroy
// file ../src/hash.h line 29
void rt_hash_destroy(struct rt_hash_t *tptr)
{
  struct hash_node_t *node;
  struct hash_node_t *last;
  signed int i = 0;
  while(!(i >= tptr->size))
  {
    node = tptr->bucket[(signed long int)i];
    while(!(node == ((struct hash_node_t *)NULL)))
    {
      last = node;
      node = node->next;
      free((void *)last);
    }
    i = i + 1;
  }
  if(!(tptr->bucket == ((struct hash_node_t **)NULL)))
  {
    free((void *)tptr->bucket);
    memset((void *)tptr, 0, 24ul /*[[struct rt_hash_t]]*/);
  }

}

// c::rt_hash_init
// file ../src/hash.h line 25
void rt_hash_init(struct rt_hash_t *tptr, signed int buckets)
{
  if(buckets == 0)
    buckets = 16;

  tptr->entries = 0;
  tptr->size = 2;
  tptr->mask = 1;
  tptr->downshift = 29;
  while(!(tptr->size >= buckets))
  {
    tptr->size = tptr->size << 1;
    tptr->mask = (tptr->mask << 1) + 1;
    tptr->downshift = tptr->downshift - 1;
  }
  void *return_value_calloc$1;
  return_value_calloc$1=calloc((unsigned long int)tptr->size, 8ul /*[[struct hash_node_t *]]*/);
  tptr->bucket = (struct hash_node_t **)return_value_calloc$1;
  return;
}

// c::rt_hash_insert
// file ../src/hash.h line 27
signed int rt_hash_insert(struct rt_hash_t *tptr, const char *key, signed int data)
{
  signed int tmp;
  struct hash_node_t *node;
  signed int h;
  tmp=rt_hash_lookup(tptr, key);
  if(!(tmp == -1))
    return tmp;

  while((double)tptr->entries >= 5.000000e-1 * (double)tptr->size)
    rebuild_table(tptr);
  h=hash(tptr, key);
  void *return_value_malloc$1;
  return_value_malloc$1=malloc(24ul /*[[struct hash_node_t]]*/);
  node = (struct hash_node_t *)return_value_malloc$1;
  node->data = data;
  node->key = key;
  node->next = tptr->bucket[(signed long int)h];
  tptr->bucket[(signed long int)h] = node;
  tptr->entries = tptr->entries + 1;
  return -1;
}

// c::rt_hash_lookup
// file ../src/hash.h line 26
signed int rt_hash_lookup(struct rt_hash_t *tptr, const char *key)
{
  signed int h;
  struct hash_node_t *node;
  h=hash(tptr, key);
  node = tptr->bucket[(signed long int)h];
  signed int tmp_statement_expression$1;
  while(!(node == ((struct hash_node_t *)NULL)))
  {
    unsigned long int __s1_len;
    unsigned long int __s2_len;
    signed int return_value___builtin_strcmp$2;
    return_value___builtin_strcmp$2=__builtin_strcmp(node->key, key);
    tmp_statement_expression$1 = return_value___builtin_strcmp$2;
    if(tmp_statement_expression$1 == 0)
      goto __CPROVER_DUMP_L2;

    node = node->next;
  }

__CPROVER_DUMP_L2:
  ;
  signed int tmp_if_expr$3;
  if(!(node == ((struct hash_node_t *)NULL)))
    tmp_if_expr$3 = node->data;

  else
    tmp_if_expr$3 = -1;
  return tmp_if_expr$3;
}

// c::rt_hash_stats
// file ../src/hash.c line 260
char * rt_hash_stats(struct rt_hash_t *tptr)
{
  static char buf[1024l];
  float return_value_alos$1;
  return_value_alos$1=alos(tptr);
  sprintf(buf, "%u slots, %u entries, and %1.2f ALOS", (signed int)tptr->size, (signed int)tptr->entries, return_value_alos$1);
  return buf;
}

// c::rt_heightfield
// file ../src/apigeom.c line 37
void rt_heightfield(void *scene, void *tex, struct anon$0 ctr, signed int m, signed int n, double *field, double wx, double wy)
{
  signed int xx;
  signed int yy;
  struct anon$0 v0;
  struct anon$0 v1;
  struct anon$0 v2;
  double xoff;
  double yoff;
  double zoff;
  xoff = ctr.x - wx / 2.000000;
  yoff = ctr.z - wy / 2.000000;
  zoff = ctr.y;
  yy = 0;
  while(!(yy >= -1 + n))
  {
    xx = 0;
    while(!(xx >= -1 + m))
    {
      v0.x = (wx * (double)xx) / ((double)m * 1.000000) + xoff;
      v0.y = field[(signed long int)(yy * m + xx)] + zoff;
      v0.z = (wy * (double)yy) / ((double)n * 1.000000) + yoff;
      v1.x = (wx * (double)(xx + 1)) / ((double)m * 1.000000) + xoff;
      v1.y = field[(signed long int)(yy * m + xx + 1)] + zoff;
      v1.z = (wy * (double)yy) / ((double)n * 1.000000) + yoff;
      v2.x = (wx * (double)(xx + 1)) / ((double)m * 1.000000) + xoff;
      v2.y = field[(signed long int)((yy + 1) * m + xx + 1)] + zoff;
      v2.z = (wy * (double)(yy + 1)) / ((double)n * 1.000000) + yoff;
      rt_tri(scene, tex, v1, v0, v2);
      v0.x = (wx * (double)xx) / ((double)m * 1.000000) + xoff;
      v0.y = field[(signed long int)(yy * m + xx)] + zoff;
      v0.z = (wy * (double)yy) / ((double)n * 1.000000) + yoff;
      v1.x = (wx * (double)xx) / ((double)m * 1.000000) + xoff;
      v1.y = field[(signed long int)((yy + 1) * m + xx)] + zoff;
      v1.z = (wy * (double)(yy + 1)) / ((double)n * 1.000000) + yoff;
      v2.x = (wx * (double)(xx + 1)) / ((double)m * 1.000000) + xoff;
      v2.y = field[(signed long int)((yy + 1) * m + xx + 1)] + zoff;
      v2.z = (wy * (double)(yy + 1)) / ((double)n * 1.000000) + yoff;
      rt_tri(scene, tex, v0, v1, v2);
      xx = xx + 1;
    }
    yy = yy + 1;
  }
}

// c::rt_image_clamp
// file ../src/tachyon.h line 168
void rt_image_clamp(void *voidscene)
{
  struct anon$17 *scene = (struct anon$17 *)voidscene;
  scene->imgprocess = 0;
}

// c::rt_image_gamma
// file ../src/tachyon.h line 180
void rt_image_gamma(void *voidscene, float gamma)
{
  struct anon$17 *scene = (struct anon$17 *)voidscene;
  scene->imggamma = gamma;
  scene->imgprocess = 1 | 2;
}

// c::rt_image_normalize
// file ../src/tachyon.h line 174
void rt_image_normalize(void *voidscene)
{
  struct anon$17 *scene = (struct anon$17 *)voidscene;
  scene->imgprocess = 1;
}

// c::rt_init_scanlinereceives
// file ../src/parallel.c line 179
void * rt_init_scanlinereceives(struct anon$39$link111 *scene)
{
  return NULL;
}

// c::rt_initialize
// file ../src/tachyon.h line 75
signed int rt_initialize(signed int *argc, char ***argv)
{
  InitTextures();
  if(parinitted == 0)
  {
    rt_par_init(argc, argv);
    parinitted = 1;
  }

  signed int return_value_rt_mynode$1;
  return_value_rt_mynode$1=rt_mynode();
  return return_value_rt_mynode$1;
}

// c::rt_landscape
// file ../src/tachyon.h line 416
void rt_landscape(void *scene, void *tex, signed int m, signed int n, struct anon$0 ctr, double wx, double wy)
{
  signed int totalsize;
  signed int x;
  signed int y;
  double *field;
  unsigned int rndval;
  totalsize = m * n;
  rndval = (unsigned int)totalsize;
  void *return_value_malloc$1;
  return_value_malloc$1=malloc((unsigned long int)totalsize * 8ul /*[[double]]*/);
  field = (double *)return_value_malloc$1;
  y = 0;
  while(!(y >= n))
  {
    x = 0;
    while(!(x >= m))
    {
      field[(signed long int)(x + y * m)] = 0.000000;
      x = x + 1;
    }
    y = y + 1;
  }
  unsigned int return_value_rt_rand$2;
  return_value_rt_rand$2=rt_rand(&rndval);
  field[(signed long int)(0 + 0)] = (double)return_value_rt_rand$2 / 4.294967e+9;
  unsigned int return_value_rt_rand$3;
  return_value_rt_rand$3=rt_rand(&rndval);
  field[(signed long int)(m - 1)] = (double)return_value_rt_rand$3 / 4.294967e+9;
  unsigned int return_value_rt_rand$4;
  return_value_rt_rand$4=rt_rand(&rndval);
  field[(signed long int)(0 + m * (n - 1))] = (double)return_value_rt_rand$4 / 4.294967e+9;
  unsigned int return_value_rt_rand$5;
  return_value_rt_rand$5=rt_rand(&rndval);
  field[(signed long int)((m - 1) + m * (n - 1))] = (double)return_value_rt_rand$5 / 4.294967e+9;
  subdivide(field, m, n, wx, wy, 0, 0, m - 1, n - 1, &rndval);
  rt_sheightfield(scene, tex, ctr, m, n, field, wx, wy);
  free((void *)field);
}

// c::rt_light
// file ../src/tachyon.h line 359
void * rt_light(void *voidscene, void *tex, struct anon$0 ctr, double rad)
{
  struct point_light_t *li;
  struct anon$17 *scene = (struct anon$17 *)voidscene;
  struct list *lst;
  li=newpointlight(tex, ctr, rad);
  void *return_value_malloc$1;
  return_value_malloc$1=malloc(16ul /*[[struct list]]*/);
  lst = (struct list *)return_value_malloc$1;
  lst->item = (void *)li;
  lst->next = scene->lightlist;
  scene->lightlist = lst;
  scene->numlights = scene->numlights + 1;
  add_bounded_object((struct anon$17 *)scene, (struct anon$15 *)li);
  return (void *)li;
}

// c::rt_light_attenuation
// file ../src/tachyon.h line 371
void rt_light_attenuation(void *vli, double Kc, double Kl, double Kq)
{
  light_set_attenuation((struct point_light_t *)vli, Kc, Kl, Kq);
}

// c::rt_mutex_destroy
// file ../src/threads.c line 212
signed int rt_mutex_destroy(union anon$40 *mp)
{
  signed int status = 0;
  status=pthread_mutex_destroy(mp);
  return status;
}

// c::rt_mutex_init
// file ../src/threads.c line 149
signed int rt_mutex_init(union anon$40 *mp)
{
  signed int status = 0;
  status=pthread_mutex_init(mp, ((const union anon$43 *)NULL));
  return status;
}

// c::rt_mutex_lock
// file ../src/threads.c line 170
signed int rt_mutex_lock(union anon$40 *mp)
{
  signed int status = 0;
  status=pthread_mutex_lock(mp);
  return status;
}

// c::rt_mutex_unlock
// file ../src/threads.c line 191
signed int rt_mutex_unlock(union anon$40 *mp)
{
  signed int status = 0;
  status=pthread_mutex_unlock(mp);
  return status;
}

// c::rt_mynode
// file ../src/parallel.h line 11
signed int rt_mynode(void)
{
  signed int a = 0;
  return a;
}

// c::rt_newscene
// file ../src/tachyon.h line 92
void * rt_newscene(void)
{
  struct anon$17 *scene;
  void *voidscene;
  struct anon$4 bgcolor;
  bgcolor=rt_color(0.000000, 0.000000, 0.000000);
  struct anon$4 ambcolor;
  ambcolor=rt_color(1.000000, 1.000000, 1.000000);
  void *return_value_malloc$1;
  return_value_malloc$1=malloc(960ul /*[[struct anon$17]]*/);
  scene = (struct anon$17 *)return_value_malloc$1;
  memset((void *)scene, 0, 960ul /*[[struct anon$17]]*/);
  voidscene = (void *)scene;
  rt_outputfile(voidscene, "/tmp/outfile.tga");
  rt_crop_disable(voidscene);
  rt_outputformat(voidscene, 0);
  rt_resolution(voidscene, 512, 512);
  rt_verbose(voidscene, 0);
  rt_image_gamma(voidscene, (float)2.200000e+0);
  rt_image_clamp(voidscene);
  rt_rawimage_rgb96f(voidscene, (float *)NULL);
  rt_boundmode(voidscene, 1);
  rt_boundthresh(voidscene, 16);
  struct anon$0 return_value_rt_vector$2;
  return_value_rt_vector$2=rt_vector(0.000000, 0.000000, 0.000000);
  struct anon$0 return_value_rt_vector$3;
  return_value_rt_vector$3=rt_vector(0.000000, 0.000000, 1.000000);
  struct anon$0 return_value_rt_vector$4;
  return_value_rt_vector$4=rt_vector(0.000000, 1.000000, 0.000000);
  rt_camera_setup(voidscene, 1.000000, 1.000000, 0, 6, return_value_rt_vector$2, return_value_rt_vector$3, return_value_rt_vector$4);
  rt_camera_dof(voidscene, 1.000000, 0.000000);
  rt_shadermode(voidscene, 0);
  rt_rescale_lights(voidscene, 1.000000);
  rt_phong_shader(voidscene, 2);
  rt_background(voidscene, bgcolor);
  struct anon$0 return_value_rt_vector$5;
  return_value_rt_vector$5=rt_vector(0.000000, 1.000000, 0.000000);
  struct anon$4 return_value_rt_color$6;
  return_value_rt_color$6=rt_color(0.000000, 0.000000, 0.000000);
  struct anon$4 return_value_rt_color$7;
  return_value_rt_color$7=rt_color(0.000000, 0.000000, 5.000000e-1);
  rt_background_sky_sphere(voidscene, return_value_rt_vector$5, 3.000000e-1, (double)0, return_value_rt_color$6, return_value_rt_color$7);
  rt_background_mode(voidscene, 0);
  rt_ambient_occlusion(voidscene, 0, ambcolor);
  rt_fog_rendering_mode(voidscene, 0);
  rt_fog_mode(voidscene, 0);
  rt_fog_parms(voidscene, bgcolor, 0.000000, 1.000000, 1.000000);
  rt_trans_mode(voidscene, 0);
  rt_normal_fixup_mode(voidscene, 0);
  scene->objgroup.boundedobj = (struct anon$15 *)NULL;
  scene->objgroup.unboundedobj = (struct anon$15 *)NULL;
  scene->objgroup.numobjects = 0;
  scene->texlist = (struct list *)NULL;
  scene->lightlist = (struct list *)NULL;
  scene->cliplist = (struct list *)NULL;
  scene->numlights = 0;
  scene->scenecheck = 1;
  scene->parbuf = NULL;
  scene->threads = NULL;
  scene->threadparms = NULL;
  scene->flags = (unsigned int)0;
  rt_set_numthreads(voidscene, -1);
  scene->nodes=rt_getcpuinfo(&scene->cpuinfo);
  scene->mynode=rt_mynode();
  return (void *)scene;
}

// c::rt_normal_fixup_mode
// file ../src/tachyon.h line 162
void rt_normal_fixup_mode(void *voidscene, signed int mode)
{
  struct anon$17 *scene = (struct anon$17 *)voidscene;
  switch(mode)
  {

    case 2:
      {
        scene->normalfixupmode = 2;
        goto __CPROVER_DUMP_L4;
      }
    case 1:
      {
        scene->normalfixupmode = 1;
        goto __CPROVER_DUMP_L4;
      }
    case 0:

      default:
        scene->normalfixupmode = 0;
  }

__CPROVER_DUMP_L4:
  ;
}

// c::rt_numnodes
// file ../src/parallel.c line 57
signed int rt_numnodes(void)
{
  signed int a = 1;
  return a;
}

// c::rt_outputfile
// file ../src/tachyon.h line 114
void rt_outputfile(void *voidscene, const char *outname)
{
  struct anon$17 *scene = (struct anon$17 *)voidscene;
  unsigned long int return_value_strlen$1;
  return_value_strlen$1=strlen(outname);
  if(return_value_strlen$1 > 0ul)
  {
    strcpy((char *)&scene->outfilename, outname);
    scene->writeimagefile = 1;
  }

  else
    scene->writeimagefile = 0;
}

// c::rt_outputformat
// file ../src/tachyon.h line 121
void rt_outputformat(void *voidscene, signed int format)
{
  struct anon$17 *scene = (struct anon$17 *)voidscene;
  scene->imgfileformat = format;
}

// c::rt_par_finish
// file ../src/parallel.h line 10
signed int rt_par_finish(void)
{
  signed int a = 0;
  return a;
}

// c::rt_par_init
// file ../src/parallel.h line 9
signed int rt_par_init(signed int *argc, char ***argv)
{
  signed int a = 0;
  a=rt_mynode();
  return a;
}

// c::rt_phong_shader
// file ../src/tachyon.h line 292
void rt_phong_shader(void *voidscene, signed int mode)
{
  struct anon$17 *scene = (struct anon$17 *)voidscene;
  switch(mode)
  {

    case 0:
      {
        scene->phongfunc = shade_nullphong;
        goto __CPROVER_DUMP_L5;
      }
    case 1:
      {
        scene->phongfunc = shade_blinn_fast;
        goto __CPROVER_DUMP_L5;
      }
    case 2:
      {
        scene->phongfunc = shade_blinn;
        goto __CPROVER_DUMP_L5;
      }
    case 3:

      default:
        scene->phongfunc = shade_phong;
  }

__CPROVER_DUMP_L5:
  ;
}

// c::rt_plane
// file ../src/tachyon.h line 390
void rt_plane(void *scene, void *tex, struct anon$0 ctr, struct anon$0 norm)
{
  struct anon$15 *return_value_newplane$1;
  return_value_newplane$1=newplane(tex, ctr, norm);
  add_unbounded_object((struct anon$17 *)scene, return_value_newplane$1);
}

// c::rt_polycylinder
// file ../src/tachyon.h line 425
void rt_polycylinder(void *scene, void *tex, struct anon$0 *points, signed int numpts, double rad)
{
  struct anon$0 a;
  signed int i;
  if(!(points == ((struct anon$0 *)NULL)))
  {
    if(numpts == 0)
      goto __CPROVER_DUMP_L1;

  }

  else
  {

  __CPROVER_DUMP_L1:
    ;
    return;
  }
  if(numpts > 0)
  {
    rt_sphere(scene, tex, points[(signed long int)0], rad);
    if(numpts > 1)
    {
      i = 1;
      while(!(i >= numpts))
      {
        a.x = (points + (signed long int)i)->x - (points + (signed long int)(i - 1))->x;
        a.y = (points + (signed long int)i)->y - (points + (signed long int)(i - 1))->y;
        a.z = (points + (signed long int)i)->z - (points + (signed long int)(i - 1))->z;
        rt_fcylinder(scene, tex, points[(signed long int)(i - 1)], a, rad);
        rt_sphere(scene, tex, points[(signed long int)i], rad);
        i = i + 1;
      }
    }

  }

}

// c::rt_quadsphere
// file ../src/api.c line 981
void rt_quadsphere(void *scene, void *tex, struct anon$0 ctr, double rad)
{
  struct anon$28 *q;
  double factor;
  struct anon$28 *return_value_newquadric$1;
  return_value_newquadric$1=newquadric();
  q = (struct anon$28 *)return_value_newquadric$1;
  factor = 1.000000 / (rad * rad);
  q->tex = (struct anon$25 *)tex;
  q->ctr = ctr;
  q->mat.a = factor;
  q->mat.b = 0.000000;
  q->mat.c = 0.000000;
  q->mat.d = 0.000000;
  q->mat.e = factor;
  q->mat.f = 0.000000;
  q->mat.g = 0.000000;
  q->mat.h = factor;
  q->mat.i = 0.000000;
  q->mat.j = -1.000000;
  add_unbounded_object((struct anon$17 *)scene, (struct anon$15 *)q);
}

// c::rt_rand
// file ../src/util.h line 19
unsigned int rt_rand(unsigned int *idum)
{
  *idum = (unsigned int)1099087573 * *idum;
  return *idum;
}

// c::rt_rawimage_rgb24
// file ../src/api.c line 229
void rt_rawimage_rgb24(void *voidscene, unsigned char *img)
{
  struct anon$17 *scene = (struct anon$17 *)voidscene;
  scene->img = (void *)img;
  scene->imginternal = 0;
  scene->imgbufformat = 0;
  scene->scenecheck = 1;
}

// c::rt_rawimage_rgb96f
// file ../src/api.c line 238
void rt_rawimage_rgb96f(void *voidscene, float *img)
{
  struct anon$17 *scene = (struct anon$17 *)voidscene;
  scene->img = (void *)img;
  scene->imginternal = 0;
  scene->imgbufformat = 1;
  scene->scenecheck = 1;
}

// c::rt_renderscene
// file ../src/tachyon.h line 107
void rt_renderscene(void *voidscene)
{
  struct anon$17 *scene = (struct anon$17 *)voidscene;
  renderscene(scene);
}

// c::rt_rescale_lights
// file ../src/tachyon.h line 357
void rt_rescale_lights(void *voidscene, double lightscale)
{
  struct anon$17 *scene = (struct anon$17 *)voidscene;
  scene->light_scale = lightscale;
}

// c::rt_resolution
// file ../src/tachyon.h line 130
void rt_resolution(void *voidscene, signed int hres, signed int vres)
{
  struct anon$17 *scene = (struct anon$17 *)voidscene;
  scene->hres = hres;
  scene->vres = vres;
  scene->scenecheck = 1;
}

// c::rt_ring
// file ../src/tachyon.h line 393
void rt_ring(void *scene, void *tex, struct anon$0 ctr, struct anon$0 norm, double a, double b)
{
  struct anon$15 *return_value_newring$1;
  return_value_newring$1=newring(tex, ctr, norm, a, b);
  add_bounded_object((struct anon$17 *)scene, return_value_newring$1);
}

// c::rt_rwlock_init
// file ../src/threads.c line 423
signed int rt_rwlock_init(struct rwlock_struct *rwp)
{
  signed int status = 0;
  pthread_mutex_init(&rwp->lock, (const union anon$43 *)NULL);
  pthread_cond_init(&rwp->rdrs_ok, (const union anon$43 *)NULL);
  pthread_cond_init(&rwp->wrtr_ok, (const union anon$43 *)NULL);
  rwp->rwlock = 0;
  rwp->waiting_writers = (unsigned int)0;
  return status;
}

// c::rt_rwlock_readlock
// file ../src/threads.c line 443
signed int rt_rwlock_readlock(struct rwlock_struct *rwp)
{
  signed int status = 0;
  pthread_mutex_lock(&rwp->lock);
  while(TRUE)
  {
    if(rwp->rwlock < 0)
      goto __CPROVER_DUMP_L2;

    if(rwp->waiting_writers != 0u)
      goto __CPROVER_DUMP_L2;

    goto __CPROVER_DUMP_L3;

  __CPROVER_DUMP_L2:
    ;
    pthread_cond_wait(&rwp->rdrs_ok, &rwp->lock);
  }

__CPROVER_DUMP_L3:
  ;
  rwp->rwlock = rwp->rwlock + 1;
  pthread_mutex_unlock(&rwp->lock);
  return status;
}

// c::rt_rwlock_unlock
// file ../src/threads.c line 486
signed int rt_rwlock_unlock(struct rwlock_struct *rwp)
{
  signed int status = 0;
  signed int ww;
  signed int wr;
  pthread_mutex_lock(&rwp->lock);
  if(rwp->rwlock > 0)
    rwp->rwlock = rwp->rwlock - 1;

  else
    rwp->rwlock = 0;
  _Bool tmp_if_expr$1;
  if(!(rwp->waiting_writers == 0u))
    tmp_if_expr$1 = rwp->rwlock == 0 ? TRUE : FALSE;

  else
    tmp_if_expr$1 = FALSE;
  ww = (signed int)tmp_if_expr$1;
  wr = (signed int)(rwp->waiting_writers == (unsigned int)0);
  pthread_mutex_unlock(&rwp->lock);
  if(!(ww == 0))
    pthread_cond_signal(&rwp->wrtr_ok);

  else
    if(!(wr == 0))
      pthread_cond_signal(&rwp->rdrs_ok);

  return status;
}

// c::rt_rwlock_writelock
// file ../src/threads.c line 463
signed int rt_rwlock_writelock(struct rwlock_struct *rwp)
{
  signed int status = 0;
  pthread_mutex_lock(&rwp->lock);
  while(!(rwp->rwlock == 0))
  {
    rwp->waiting_writers = rwp->waiting_writers + 1u;
    pthread_cond_wait(&rwp->wrtr_ok, &rwp->lock);
    rwp->waiting_writers = rwp->waiting_writers - 1u;
  }
  rwp->rwlock = -1;
  pthread_mutex_unlock(&rwp->lock);
  return status;
}

// c::rt_scalarvol
// file ../src/tachyon.h line 382
void rt_scalarvol(void *scene, void *tex, struct anon$0 min, struct anon$0 max, signed int xs, signed int ys, signed int zs, const char *fname, struct anon$10 *invol)
{
  void *return_value_newscalarvol$1;
  return_value_newscalarvol$1=newscalarvol(tex, min, max, xs, ys, zs, fname, invol);
  add_bounded_object((struct anon$17 *)scene, (struct anon$15 *)return_value_newscalarvol$1);
}

// c::rt_sendrecvscanline
// file ../src/parallel.c line 285
void rt_sendrecvscanline(void *voidhandle)
{
  ;
}

// c::rt_set_numthreads
// file ../src/tachyon.h line 207
void rt_set_numthreads(void *voidscene, signed int numthreads)
{
  struct anon$17 *scene = (struct anon$17 *)voidscene;
  if(numthreads > 0)
    scene->numthreads = numthreads;

  else
    scene->numthreads=rt_thread_numprocessors();
  rt_thread_setconcurrency(scene->numthreads);
  scene->scenecheck = 1;
}

// c::rt_set_ui_message
// file ../src/tachyon.h line 62
void rt_set_ui_message(void (*func)(signed int, char *))
{
  rt_static_ui_message = func;
}

// c::rt_set_ui_progress
// file ../src/tachyon.h line 63
void rt_set_ui_progress(void (*func)(signed int))
{
  rt_static_ui_progress = func;
}

// c::rt_shadermode
// file ../src/tachyon.h line 284
void rt_shadermode(void *voidscene, signed int mode)
{
  struct anon$17 *scene = (struct anon$17 *)voidscene;
  switch(mode)
  {

    case 1:
      {
        scene->shader = (struct anon$4 (*)(void *))lowest_shader;
        goto __CPROVER_DUMP_L7;
      }
    case 2:
      {
        scene->shader = (struct anon$4 (*)(void *))low_shader;
        goto __CPROVER_DUMP_L7;
      }
    case 3:
      {
        scene->shader = (struct anon$4 (*)(void *))medium_shader;
        goto __CPROVER_DUMP_L7;
      }
    case 4:
      {
        scene->shader = (struct anon$4 (*)(void *))full_shader;
        goto __CPROVER_DUMP_L7;
      }
    case 5:
      {
        scene->shader = (struct anon$4 (*)(void *))full_shader;
        goto __CPROVER_DUMP_L7;
      }
    case 0:

      default:
        scene->shader = (struct anon$4 (*)(void *))NULL;
  }

__CPROVER_DUMP_L7:
  ;
}

// c::rt_shared_iterator_destroy
// file ../src/threads.c line 790
signed int rt_shared_iterator_destroy(struct rt_shared_iterator_struct *it)
{
  rt_mutex_destroy(&it->mtx);
  return 0;
}

// c::rt_shared_iterator_getfatalerror
// file ../src/threads.c line 890
signed int rt_shared_iterator_getfatalerror(struct rt_shared_iterator_struct *it)
{
  signed int rc = 0;
  rt_mutex_lock(&it->mtx);
  if(!(it->fatalerror == 0))
    rc = -1;

  rt_mutex_unlock(&it->mtx);
  return rc;
}

// c::rt_shared_iterator_init
// file ../src/threads.c line 780
signed int rt_shared_iterator_init(struct rt_shared_iterator_struct *it)
{
  memset((void *)it, 0, 56ul /*[[struct rt_shared_iterator_struct]]*/);
  rt_mutex_init(&it->mtx);
  return 0;
}

// c::rt_shared_iterator_next
// file ../src/threads.c line 815
signed int rt_shared_iterator_next(struct rt_shared_iterator_struct *it, signed int *current)
{
  signed int rc = 0;
  rt_mutex_lock(&it->mtx);
  if(it->fatalerror == 0)
  {
    *current = it->current;
    it->current = it->current + 1;
    if(*current >= it->end)
    {
      *current = 0;
      rc = -1;
    }

  }

  else
    rc = -1;
  rt_mutex_unlock(&it->mtx);
  return rc;
}

// c::rt_shared_iterator_next_block
// file ../src/threads.c line 841
signed int rt_shared_iterator_next_block(struct rt_shared_iterator_struct *it, signed int reqsize, signed int *start, signed int *end)
{
  signed int rc = 0;
  rt_mutex_lock(&it->mtx);
  if(it->fatalerror == 0)
  {
    *start = it->current;
    it->current = it->current + reqsize;
    *end = it->current;
    if(*start >= it->end)
    {
      *start = 0;
      *end = 0;
      rc = -1;
    }

    if(!(it->end >= *end))
      *end = it->end;

  }

  else
    rc = -1;
  rt_mutex_unlock(&it->mtx);
  return rc;
}

// c::rt_shared_iterator_set
// file ../src/threads.c line 799
signed int rt_shared_iterator_set(struct rt_shared_iterator_struct *it, signed int start, signed int end)
{
  rt_mutex_lock(&it->mtx);
  it->start = start;
  it->current = start;
  it->end = end;
  it->fatalerror = 0;
  rt_mutex_unlock(&it->mtx);
  return 0;
}

// c::rt_shared_iterator_setfatalerror
// file ../src/threads.c line 877
signed int rt_shared_iterator_setfatalerror(struct rt_shared_iterator_struct *it)
{
  rt_mutex_lock(&it->mtx);
  it->fatalerror = 1;
  rt_mutex_unlock(&it->mtx);
  return 0;
}

// c::rt_sheightfield
// file ../src/apigeom.c line 81
static void rt_sheightfield(void *scene, void *tex, struct anon$0 ctr, signed int m, signed int n, double *field, double wx, double wy)
{
  struct anon$0 *vertices;
  struct anon$0 *normals;
  struct anon$0 offset;
  double xinc;
  double yinc;
  signed int x;
  signed int y;
  signed int addr;
  void *return_value_malloc$1;
  return_value_malloc$1=malloc((unsigned long int)(m * n) * 24ul /*[[struct anon$0]]*/);
  vertices = (struct anon$0 *)return_value_malloc$1;
  void *return_value_malloc$2;
  return_value_malloc$2=malloc((unsigned long int)(m * n) * 24ul /*[[struct anon$0]]*/);
  normals = (struct anon$0 *)return_value_malloc$2;
  offset.x = ctr.x - wx / 2.000000;
  offset.y = ctr.z - wy / 2.000000;
  offset.z = ctr.y;
  xinc = wx / ((double)m - (double)1);
  yinc = wy / ((double)n - (double)1);
  y = 0;
  while(!(y >= n))
  {
    x = 0;
    while(!(x >= m))
    {
      addr = y * m + x;
      vertices[(signed long int)addr]=rt_vector((double)x * xinc + offset.x, field[(signed long int)addr] + offset.z, (double)y * yinc + offset.y);
      x = x + 1;
    }
    y = y + 1;
  }
  x = 1;
  while(!(x >= m))
  {
    normals[(signed long int)((n - 1) * m + x)]=rt_vector(0.000000, 1.000000, 0.000000);
    normals[(signed long int)x] = normals[(signed long int)((n - 1) * m + x)];
    x = x + 1;
  }
  y = 1;
  while(!(y >= n))
  {
    normals[(signed long int)(y * m + (m - 1))]=rt_vector(0.000000, 1.000000, 0.000000);
    normals[(signed long int)(y * m)] = normals[(signed long int)(y * m + (m - 1))];
    y = y + 1;
  }
  y = 1;
  while(!(y >= -1 + n))
  {
    x = 1;
    while(!(x >= -1 + m))
    {
      addr = y * m + x;
      normals[(signed long int)addr]=rt_vector(-(field[(signed long int)(addr + 1)] - field[(signed long int)(addr - 1)]) / (2.000000 * xinc), 1.000000, -(field[(signed long int)(addr + m)] - field[(signed long int)(addr - m)]) / (2.000000 * yinc));
      VNorm(&normals[(signed long int)addr]);
      x = x + 1;
    }
    y = y + 1;
  }
  y = 0;
  while(!(y >= -1 + n))
  {
    x = 0;
    while(!(x >= -1 + m))
    {
      addr = y * m + x;
      rt_stri(scene, tex, vertices[(signed long int)addr], vertices[(signed long int)(addr + 1 + m)], vertices[(signed long int)(addr + 1)], normals[(signed long int)addr], normals[(signed long int)(addr + 1 + m)], normals[(signed long int)(addr + 1)]);
      rt_stri(scene, tex, vertices[(signed long int)addr], vertices[(signed long int)(addr + m)], vertices[(signed long int)(addr + 1 + m)], normals[(signed long int)addr], normals[(signed long int)(addr + m)], normals[(signed long int)(addr + 1 + m)]);
      x = x + 1;
    }
    y = y + 1;
  }
  free((void *)normals);
  free((void *)vertices);
}

// c::rt_sphere
// file ../src/tachyon.h line 379
void rt_sphere(void *scene, void *tex, struct anon$0 ctr, double rad)
{
  struct anon$15 *return_value_newsphere$1;
  return_value_newsphere$1=newsphere(tex, ctr, rad);
  add_bounded_object((struct anon$17 *)scene, return_value_newsphere$1);
}

// c::rt_spotlight
// file ../src/tachyon.h line 367
void * rt_spotlight(void *voidscene, void *tex, struct anon$0 ctr, double rad, struct anon$0 dir, double start, double end)
{
  double fallstart;
  double fallend;
  struct point_light_t *li;
  struct anon$17 *scene = (struct anon$17 *)voidscene;
  struct list *lst;
  fallstart = (start * 3.141593e+0) / 180.000000;
  fallend = (end * 3.141593e+0) / 180.000000;
  VNorm(&dir);
  li=newspotlight(tex, ctr, rad, dir, fallstart, fallend);
  void *return_value_malloc$1;
  return_value_malloc$1=malloc(16ul /*[[struct list]]*/);
  lst = (struct list *)return_value_malloc$1;
  lst->item = (void *)li;
  lst->next = scene->lightlist;
  scene->lightlist = lst;
  scene->numlights = scene->numlights + 1;
  add_bounded_object(scene, (struct anon$15 *)li);
  return (void *)li;
}

// c::rt_start_scanlinereceives
// file ../src/parallel.c line 245
void rt_start_scanlinereceives(void *voidhandle)
{
  ;
}

// c::rt_stri
// file ../src/tachyon.h line 399
void rt_stri(void *voidscene, void *tex, struct anon$0 v0, struct anon$0 v1, struct anon$0 v2, struct anon$0 n0, struct anon$0 n1, struct anon$0 n2)
{
  struct anon$17 *scene = (struct anon$17 *)voidscene;
  struct anon$15 *o;
  o=newstri(tex, v0, v1, v2, n0, n1, n2);
  if(!(o == ((struct anon$15 *)NULL)))
  {
    if(!(scene->normalfixupmode == 0))
      stri_normal_fixup(o, scene->normalfixupmode);

    add_bounded_object(scene, o);
  }

}

// c::rt_tex_outline
// file ../src/tachyon.h line 430
void rt_tex_outline(void *voidtex, double outline, double outlinewidth)
{
  struct anon$25 *tex = (struct anon$25 *)voidtex;
  tex->outline = (float)outline;
  tex->outlinewidth = (float)outlinewidth;
}

// c::rt_tex_phong
// file ../src/tachyon.h line 428
void rt_tex_phong(void *voidtex, double phong, double phongexp, signed int type)
{
  struct anon$25 *tex = (struct anon$25 *)voidtex;
  tex->phong = (float)phong;
  tex->phongexp = (float)phongexp;
  tex->phongtype = type;
}

// c::rt_texture
// file ../src/tachyon.h line 340
void * rt_texture(void *sc, struct anon$7 *apitex)
{
  struct anon$17 *scene = (struct anon$17 *)sc;
  struct anon$25 *tex;
  struct list *lst;
  tex=new_standard_texture();
  apitextotex(apitex, tex);
  void *return_value_malloc$1;
  return_value_malloc$1=malloc(16ul /*[[struct list]]*/);
  lst = (struct list *)return_value_malloc$1;
  lst->item = (void *)tex;
  lst->next = scene->texlist;
  scene->texlist = lst;
  return (void *)tex;
}

// c::rt_texture_copy_standard
// file ../src/api.c line 702
void * rt_texture_copy_standard(void *sc, void *oldtex)
{
  struct anon$25 *newtex;
  newtex=new_standard_texture();
  memcpy((void *)newtex, oldtex, 232ul /*[[struct anon$35]]*/);
  return (void *)newtex;
}

// c::rt_texture_copy_vcstri
// file ../src/tachyon.h line 354
void * rt_texture_copy_vcstri(void *sc, void *oldtex)
{
  struct anon$25 *newtex;
  newtex=new_vcstri_texture();
  memcpy((void *)newtex, oldtex, 104ul /*[[struct anon$36]]*/);
  return (void *)newtex;
}

// c::rt_thread_barrier
// file ../src/threads.c line 541
signed int rt_thread_barrier(struct barrier_struct *barrier, signed int increment)
{
  signed int my_phase;
  signed int my_result;
  rt_mutex_lock(&barrier->lock);
  my_phase = barrier->phase;
  barrier->sum = barrier->sum + increment;
  barrier->n_waiting = barrier->n_waiting + 1;
  if(barrier->n_waiting == barrier->n_clients)
  {
    barrier->result = barrier->sum;
    barrier->sum = 0;
    barrier->n_waiting = 0;
    barrier->phase = 1 - my_phase;
    rt_cond_broadcast(&barrier->wait_cv);
  }

  while(barrier->phase == my_phase)
    rt_cond_wait(&barrier->wait_cv, &barrier->lock);
  my_result = barrier->result;
  rt_mutex_unlock(&barrier->lock);
  return my_result;
}

// c::rt_thread_barrier_destroy
// file ../src/threads.c line 533
void rt_thread_barrier_destroy(struct barrier_struct *barrier)
{
  rt_mutex_destroy(&barrier->lock);
  rt_cond_destroy(&barrier->wait_cv);
  free((void *)barrier);
}

// c::rt_thread_barrier_init
// file ../src/threads.c line 516
struct barrier_struct * rt_thread_barrier_init(signed int n_clients)
{
  struct barrier_struct *barrier;
  void *return_value_malloc$1;
  return_value_malloc$1=malloc(176ul /*[[struct barrier_struct]]*/);
  barrier = (struct barrier_struct *)return_value_malloc$1;
  if(!(barrier == ((struct barrier_struct *)NULL)))
  {
    barrier->n_clients = n_clients;
    barrier->n_waiting = 0;
    barrier->phase = 0;
    barrier->sum = 0;
    rt_mutex_init(&barrier->lock);
    rt_cond_init(&barrier->wait_cv);
  }

  return barrier;
}

// c::rt_thread_create
// file ../src/threads.c line 84
signed int rt_thread_create(unsigned long int *thr, void * (*fctn)(void *), void *arg)
{
  signed int status = 0;
  status=pthread_create(thr, (const union pthread_attr_t *)NULL, fctn, arg);
  return status;
}

// c::rt_thread_join
// file ../src/threads.c line 122
signed int rt_thread_join(unsigned long int thr, void **stat)
{
  signed int status = 0;
  status=pthread_join(thr, stat);
  return status;
}

// c::rt_thread_numprocessors
// file ../src/threads.h line 126
signed int rt_thread_numprocessors(void)
{
  signed int a = 1;
  signed long int return_value_sysconf$1;
  return_value_sysconf$1=sysconf(84);
  a = (signed int)return_value_sysconf$1;
  return a;
}

// c::rt_thread_run_barrier
// file ../src/threads.c line 603
void * (*rt_thread_run_barrier(struct rt_run_barrier_struct *barrier, void * (*fctn)(void *), void *parms, void **rsltparms))(void *)
{
  signed int my_phase;
  void * (*my_result)(void *);
  rt_mutex_lock(&barrier->lock);
  my_phase = barrier->phase;
  if(!(fctn == ((void * (*)(void *))NULL)))
    barrier->fctn = fctn;

  if(!(parms == NULL))
    barrier->parms = parms;

  barrier->n_waiting = barrier->n_waiting + 1;
  if(barrier->n_waiting == barrier->n_clients)
  {
    barrier->rslt = barrier->fctn;
    barrier->rsltparms = barrier->parms;
    barrier->fctn = (void * (*)(void *))NULL;
    barrier->parms = NULL;
    barrier->n_waiting = 0;
    barrier->phase = 1 - my_phase;
    rt_cond_broadcast(&barrier->wait_cv);
  }

  while(barrier->phase == my_phase)
    rt_cond_wait(&barrier->wait_cv, &barrier->lock);
  my_result = barrier->rslt;
  if(!(rsltparms == ((void **)NULL)))
    *rsltparms = barrier->rsltparms;

  rt_mutex_unlock(&barrier->lock);
  return my_result;
}

// c::rt_thread_run_barrier_destroy
// file ../src/threads.c line 592
void rt_thread_run_barrier_destroy(struct rt_run_barrier_struct *barrier)
{
  rt_mutex_destroy(&barrier->lock);
  rt_cond_destroy(&barrier->wait_cv);
}

// c::rt_thread_run_barrier_init
// file ../src/threads.c line 576
signed int rt_thread_run_barrier_init(struct rt_run_barrier_struct *barrier, signed int n_clients)
{
  if(!(barrier == ((struct rt_run_barrier_struct *)NULL)))
  {
    barrier->n_clients = n_clients;
    barrier->n_waiting = 0;
    barrier->phase = 0;
    barrier->fctn = (void * (*)(void *))NULL;
    rt_mutex_init(&barrier->lock);
    rt_cond_init(&barrier->wait_cv);
  }

  return 0;
}

// c::rt_thread_setconcurrency
// file ../src/threads.h line 127
signed int rt_thread_setconcurrency(signed int nthr)
{
  signed int status = 0;
  return status;
}

// c::rt_threadpool_create
// file ../src/threads.c line 672
struct rt_threadpool_struct * rt_threadpool_create(signed int workercount)
{
  signed int i;
  struct rt_threadpool_struct *thrpool = (struct rt_threadpool_struct *)NULL;
  void *return_value_malloc$1;
  return_value_malloc$1=malloc(224ul /*[[struct rt_threadpool_struct]]*/);
  thrpool = (struct rt_threadpool_struct *)return_value_malloc$1;
  if(thrpool == ((struct rt_threadpool_struct *)NULL))
    return (struct rt_threadpool_struct *)NULL;

  memset((void *)thrpool, 0, 224ul /*[[struct rt_threadpool_struct]]*/);
  thrpool->workercount = workercount;
  rt_thread_run_barrier_init(&thrpool->runbar, workercount + 1);
  void *return_value_malloc$2;
  return_value_malloc$2=malloc(8ul /*[[unsigned long int]]*/ * (unsigned long int)workercount);
  thrpool->threads = (unsigned long int *)return_value_malloc$2;
  void *return_value_malloc$3;
  return_value_malloc$3=malloc(88ul /*[[struct rt_threadpool_workerdata_struct]]*/ * (unsigned long int)workercount);
  thrpool->workerdata = (struct rt_threadpool_workerdata_struct *)return_value_malloc$3;
  memset((void *)thrpool->workerdata, 0, 88ul /*[[struct rt_threadpool_workerdata_struct]]*/ * (unsigned long int)workercount);
  i = 0;
  while(!(i >= workercount))
  {
    (thrpool->workerdata + (signed long int)i)->threadid = i;
    (thrpool->workerdata + (signed long int)i)->threadcount = workercount;
    (thrpool->workerdata + (signed long int)i)->thrpool = (void *)thrpool;
    i = i + 1;
  }
  i = 0;
  while(!(i >= workercount))
  {
    rt_thread_create(&thrpool->threads[(signed long int)i], rt_threadpool_workerproc, (void *)&thrpool->workerdata[(signed long int)i]);
    i = i + 1;
  }
  return thrpool;
}

// c::rt_threadpool_destroy
// file ../src/threads.c line 731
signed int rt_threadpool_destroy(struct rt_threadpool_struct *thrpool)
{
  signed int i;
  rt_thread_run_barrier(&thrpool->runbar, (void * (*)(void *))NULL, NULL, (void **)NULL);
  i = 0;
  while(!(i >= thrpool->workercount))
  {
    rt_thread_join(thrpool->threads[(signed long int)i], (void **)NULL);
    i = i + 1;
  }
  rt_thread_run_barrier_destroy(&thrpool->runbar);
  free((void *)thrpool->threads);
  free((void *)thrpool->workerdata);
  free((void *)thrpool);
  return 0;
}

// c::rt_threadpool_launch
// file ../src/threads.c line 710
signed int rt_threadpool_launch(struct rt_threadpool_struct *thrpool, void * (*fctn)(void *), void *parms, signed int blocking)
{
  rt_thread_run_barrier(&thrpool->runbar, fctn, parms, (void **)NULL);
  if(!(blocking == 0))
    rt_thread_run_barrier(&thrpool->runbar, rt_threadpool_workersync, NULL, (void **)NULL);

  return 0;
}

// c::rt_threadpool_wait
// file ../src/threads.c line 724
signed int rt_threadpool_wait(struct rt_threadpool_struct *thrpool)
{
  rt_thread_run_barrier(&thrpool->runbar, rt_threadpool_workersync, NULL, (void **)NULL);
  return 0;
}

// c::rt_threadpool_worker_getdata
// file ../src/threads.c line 770
signed int rt_threadpool_worker_getdata(void *voiddata, void **clientdata)
{
  struct rt_threadpool_workerdata_struct *worker = (struct rt_threadpool_workerdata_struct *)voiddata;
  if(!(clientdata == ((void **)NULL)))
    *clientdata = worker->parms;

  return 0;
}

// c::rt_threadpool_worker_getid
// file ../src/threads.c line 757
signed int rt_threadpool_worker_getid(void *voiddata, signed int *threadid, signed int *threadcount)
{
  struct rt_threadpool_workerdata_struct *worker = (struct rt_threadpool_workerdata_struct *)voiddata;
  if(!(threadid == ((signed int *)NULL)))
    *threadid = worker->threadid;

  if(!(threadcount == ((signed int *)NULL)))
    *threadcount = worker->threadcount;

  return 0;
}

// c::rt_threadpool_workerproc
// file ../src/threads.c line 654
static void * rt_threadpool_workerproc(void *voidparms)
{
  void * (*fctn)(void *);
  struct rt_threadpool_workerdata_struct *workerdata = (struct rt_threadpool_workerdata_struct *)voidparms;
  struct rt_threadpool_struct *thrpool = (struct rt_threadpool_struct *)workerdata->thrpool;
  do
  {
    fctn=rt_thread_run_barrier(&thrpool->runbar, (void * (*)(void *))NULL, NULL, &workerdata->parms);
    if(fctn == ((void * (*)(void *))NULL))
      goto __CPROVER_DUMP_L2;

    fctn((void *)workerdata);
  }
  while(TRUE);

__CPROVER_DUMP_L2:
  ;
  return NULL;
}

// c::rt_threadpool_workersync
// file ../src/threads.c line 667
static void * rt_threadpool_workersync(void *voidparms)
{
  return NULL;
}

// c::rt_timer_create
// file ../src/util.h line 11
void * rt_timer_create(void)
{
  struct anon$69 *t;
  void *return_value_malloc$1;
  return_value_malloc$1=malloc(40ul /*[[struct anon$69]]*/);
  t = (struct anon$69 *)return_value_malloc$1;
  memset((void *)t, 0, 40ul /*[[struct anon$69]]*/);
  return (void *)t;
}

// c::rt_timer_destroy
// file ../src/util.h line 12
void rt_timer_destroy(void *v)
{
  free(v);
}

// c::rt_timer_start
// file ../src/util.h line 13
void rt_timer_start(void *v)
{
  struct anon$69 *t = (struct anon$69 *)v;
  gettimeofday(&t->starttime, &t->tz);
}

// c::rt_timer_stop
// file ../src/util.h line 14
void rt_timer_stop(void *v)
{
  struct anon$69 *t = (struct anon$69 *)v;
  gettimeofday(&t->endtime, &t->tz);
}

// c::rt_timer_time
// file ../src/util.h line 15
double rt_timer_time(void *v)
{
  struct anon$69 *t = (struct anon$69 *)v;
  double ttime = (double)(t->endtime.tv_sec - t->starttime.tv_sec) + (double)(t->endtime.tv_usec - t->starttime.tv_usec) / 1.000000e+6;
  return ttime;
}

// c::rt_timer_timenow
// file ../src/util.c line 223
double rt_timer_timenow(void *v)
{
  rt_timer_stop(v);
  double return_value_rt_timer_time$1;
  return_value_rt_timer_time$1=rt_timer_time(v);
  return return_value_rt_timer_time$1;
}

// c::rt_trans_mode
// file ../src/tachyon.h line 252
void rt_trans_mode(void *voidscene, signed int mode)
{
  struct anon$17 *scene = (struct anon$17 *)voidscene;
  scene->transmode = mode;
}

// c::rt_tri
// file ../src/tachyon.h line 396
void rt_tri(void *voidscene, void *tex, struct anon$0 v0, struct anon$0 v1, struct anon$0 v2)
{
  struct anon$17 *scene = (struct anon$17 *)voidscene;
  struct anon$15 *o;
  o=newtri(tex, v0, v1, v2);
  if(!(o == ((struct anon$15 *)NULL)))
    add_bounded_object(scene, o);

}

// c::rt_tristripscnv3fv
// file ../src/api.c line 903
void rt_tristripscnv3fv(void *voidscene, void *tex, signed int numverts, const float *cnv, signed int numstrips, signed int *vertsperstrip, signed int *facets)
{
  signed int strip;
  signed int t;
  signed int v;
  signed int stripaddr[2l][3l] = { { 0, 1, 2 }, { 1, 0, 2 } };
  struct anon$17 *scene = (struct anon$17 *)voidscene;
  strip = 0;
  v = 0;
  while(!(strip >= numstrips))
  {
    t = 0;
    while(!(t >= -2 + vertsperstrip[(signed long int)strip]))
    {
      struct anon$0 v0;
      struct anon$0 v1;
      struct anon$0 v2;
      struct anon$0 n0;
      struct anon$0 n1;
      struct anon$0 n2;
      struct anon$4 c0;
      struct anon$4 c1;
      struct anon$4 c2;
      signed int a0;
      signed int a1;
      signed int a2;
      struct list *lst;
      struct anon$15 *o;
      struct anon$36 *newtex;
      void *return_value_rt_texture_copy_vcstri$1;
      return_value_rt_texture_copy_vcstri$1=rt_texture_copy_vcstri((void *)scene, tex);
      newtex = (struct anon$36 *)return_value_rt_texture_copy_vcstri$1;
      void *return_value_malloc$2;
      return_value_malloc$2=malloc(16ul /*[[struct list]]*/);
      lst = (struct list *)return_value_malloc$2;
      lst->item = (void *)tex;
      lst->next = scene->texlist;
      scene->texlist = lst;
      a0 = facets[(signed long int)(v + stripaddr[(signed long int)(t & 1)][(signed long int)0])] * 10;
      a1 = facets[(signed long int)(v + stripaddr[(signed long int)(t & 1)][(signed long int)1])] * 10;
      a2 = facets[(signed long int)(v + stripaddr[(signed long int)(t & 1)][(signed long int)2])] * 10;
      c0.r = cnv[(signed long int)(a0 + 0)];
      c0.g = cnv[(signed long int)(a0 + 1)];
      c0.b = cnv[(signed long int)(a0 + 2)];
      n0.x = (double)cnv[(signed long int)(a0 + 4)];
      n0.y = (double)cnv[(signed long int)(a0 + 5)];
      n0.z = (double)cnv[(signed long int)(a0 + 6)];
      v0.x = (double)cnv[(signed long int)(a0 + 7)];
      v0.y = (double)cnv[(signed long int)(a0 + 8)];
      v0.z = (double)cnv[(signed long int)(a0 + 9)];
      c1.r = cnv[(signed long int)(a1 + 0)];
      c1.g = cnv[(signed long int)(a1 + 1)];
      c1.b = cnv[(signed long int)(a1 + 2)];
      n1.x = (double)cnv[(signed long int)(a1 + 4)];
      n1.y = (double)cnv[(signed long int)(a1 + 5)];
      n1.z = (double)cnv[(signed long int)(a1 + 6)];
      v1.x = (double)cnv[(signed long int)(a1 + 7)];
      v1.y = (double)cnv[(signed long int)(a1 + 8)];
      v1.z = (double)cnv[(signed long int)(a1 + 9)];
      c2.r = cnv[(signed long int)(a2 + 0)];
      c2.g = cnv[(signed long int)(a2 + 1)];
      c2.b = cnv[(signed long int)(a2 + 2)];
      n2.x = (double)cnv[(signed long int)(a2 + 4)];
      n2.y = (double)cnv[(signed long int)(a2 + 5)];
      n2.z = (double)cnv[(signed long int)(a2 + 6)];
      v2.x = (double)cnv[(signed long int)(a2 + 7)];
      v2.y = (double)cnv[(signed long int)(a2 + 8)];
      v2.z = (double)cnv[(signed long int)(a2 + 9)];
      o=newvcstri((void *)newtex, v0, v1, v2, n0, n1, n2, c0, c1, c2);
      if(!(scene->normalfixupmode == 0))
        vcstri_normal_fixup(o, scene->normalfixupmode);

      add_bounded_object((struct anon$17 *)scene, o);
      v = v + 1;
      t = t + 1;
    }
    v = v + 2;
    strip = strip + 1;
  }
}

// c::rt_ui_checkaction
// file ../src/ui.c line 35
signed int rt_ui_checkaction(void)
{
  signed int return_value;
  if(!(rt_static_ui_checkaction == ((signed int (*)(void))NULL)))
  {
    return_value=rt_static_ui_checkaction();
    return return_value;
  }

  else
    return 0;
}

// c::rt_ui_message
// file ../src/ui.h line 17
void rt_ui_message(signed int level, char *msg)
{
  if(!(rt_static_ui_message == ((void (*)(signed int, char *))NULL)))
    rt_static_ui_message(level, msg);

}

// c::rt_ui_progress
// file ../src/ui.h line 18
void rt_ui_progress(signed int percent)
{
  if(!(rt_static_ui_progress == ((void (*)(signed int))NULL)))
    rt_static_ui_progress(percent);

}

// c::rt_vcstri
// file ../src/tachyon.h line 403
void rt_vcstri(void *voidscene, void *tex, struct anon$0 v0, struct anon$0 v1, struct anon$0 v2, struct anon$0 n0, struct anon$0 n1, struct anon$0 n2, struct anon$4 c0, struct anon$4 c1, struct anon$4 c2)
{
  struct anon$17 *scene = (struct anon$17 *)voidscene;
  struct anon$15 *o;
  o=newvcstri(tex, v0, v1, v2, n0, n1, n2, c0, c1, c2);
  if(!(o == ((struct anon$15 *)NULL)))
  {
    if(!(scene->normalfixupmode == 0))
      vcstri_normal_fixup(o, scene->normalfixupmode);

    add_bounded_object(scene, o);
  }

}

// c::rt_vector
// file ../src/tachyon.h line 59
struct anon$0 rt_vector(double x, double y, double z)
{
  struct anon$0 v;
  v.x = x;
  v.y = y;
  v.z = z;
  return v;
}

// c::rt_verbose
// file ../src/tachyon.h line 154
void rt_verbose(void *voidscene, signed int v)
{
  struct anon$17 *scene = (struct anon$17 *)voidscene;
  scene->verbosemode = v;
}

// c::rt_waitscanlines
// file ../src/parallel.c line 257
void rt_waitscanlines(void *voidhandle)
{
  ;
}

// c::scalar_volume_texture
// file ../src/vol.c line 139
struct anon$4 scalar_volume_texture(const struct anon$0 *hit, const struct anon$25 *tx, struct ray_t$link213 *ry)
{
  struct anon$4 col;
  struct anon$4 col2;
  struct anon$26 *bx;
  double a;
  double tx1;
  double tx2;
  double ty1;
  double ty2;
  double tz1;
  double tz2;
  double tnear;
  double tfar;
  double t;
  double tdist;
  double dt;
  double sum;
  double tt;
  struct anon$0 pnt;
  struct anon$0 bln;
  struct anon$10 *vol;
  double scalar;
  double transval;
  signed int x;
  signed int y;
  signed int z;
  unsigned char *ptr;
  struct anon$35 *tex = (struct anon$35 *)tx;
  bx = (struct anon$26 *)tex->obj;
  vol = (struct anon$10 *)((struct anon$35 *)bx->tex)->img;
  col.r = (float)0.000000;
  col.g = (float)0.000000;
  col.b = (float)0.000000;
  tnear = -1.000000e+18;
  tfar = 1.000000e+18;
  _Bool tmp_if_expr$1;
  if(IEEE_FLOAT_EQUAL(ry->d.x, 0.000000))
  {
    if(ry->o.x < bx->min.x)
      tmp_if_expr$1 = TRUE;

    else
      tmp_if_expr$1 = ry->o.x > bx->max.x ? TRUE : FALSE;
    if(tmp_if_expr$1)
      return col;

  }

  else
  {
    tx1 = (bx->min.x - ry->o.x) / ry->d.x;
    tx2 = (bx->max.x - ry->o.x) / ry->d.x;
    if(tx1 > tx2)
    {
      a = tx1;
      tx1 = tx2;
      tx2 = a;
    }

    if(tx1 > tnear)
      tnear = tx1;

    if(tx2 < tfar)
      tfar = tx2;

  }
  if(tnear > tfar)
    return col;

  if(tfar < 0.000000)
    return col;

  _Bool tmp_if_expr$2;
  if(IEEE_FLOAT_EQUAL(ry->d.y, 0.000000))
  {
    if(ry->o.y < bx->min.y)
      tmp_if_expr$2 = TRUE;

    else
      tmp_if_expr$2 = ry->o.y > bx->max.y ? TRUE : FALSE;
    if(tmp_if_expr$2)
      return col;

  }

  else
  {
    ty1 = (bx->min.y - ry->o.y) / ry->d.y;
    ty2 = (bx->max.y - ry->o.y) / ry->d.y;
    if(ty1 > ty2)
    {
      a = ty1;
      ty1 = ty2;
      ty2 = a;
    }

    if(ty1 > tnear)
      tnear = ty1;

    if(ty2 < tfar)
      tfar = ty2;

  }
  if(tnear > tfar)
    return col;

  if(tfar < 0.000000)
    return col;

  _Bool tmp_if_expr$3;
  if(IEEE_FLOAT_EQUAL(ry->d.z, 0.000000))
  {
    if(ry->o.z < bx->min.z)
      tmp_if_expr$3 = TRUE;

    else
      tmp_if_expr$3 = ry->o.z > bx->max.z ? TRUE : FALSE;
    if(tmp_if_expr$3)
      return col;

  }

  else
  {
    tz1 = (bx->min.z - ry->o.z) / ry->d.z;
    tz2 = (bx->max.z - ry->o.z) / ry->d.z;
    if(tz1 > tz2)
    {
      a = tz1;
      tz1 = tz2;
      tz2 = a;
    }

    if(tz1 > tnear)
      tnear = tz1;

    if(tz2 < tfar)
      tfar = tz2;

  }
  if(tnear > tfar)
    return col;

  if(tfar < 0.000000)
    return col;

  if(tnear < 0.000000)
    tnear = 0.000000;

  tdist=sqrt((double)(vol->xres * vol->xres + vol->yres * vol->yres + vol->zres * vol->zres));
  tt = vol->opacity / tdist;
  bln.x=fabs(bx->min.x - bx->max.x);
  bln.y=fabs(bx->min.y - bx->max.y);
  bln.z=fabs(bx->min.z - bx->max.z);
  double return_value_sqrt$4;
  return_value_sqrt$4=sqrt(bln.x * bln.x + bln.y * bln.y + bln.z * bln.z);
  dt = return_value_sqrt$4 / tdist;
  sum = 0.000000;
  t = tnear;
  while(t <= tfar)
  {
    pnt.x = ((ry->o.x + ry->d.x * t) - bx->min.x) / bln.x;
    pnt.y = ((ry->o.y + ry->d.y * t) - bx->min.y) / bln.y;
    pnt.z = ((ry->o.z + ry->d.z * t) - bx->min.z) / bln.z;
    x = (signed int)(((double)vol->xres - 1.500000e+0) * pnt.x + 5.000000e-1);
    y = (signed int)(((double)vol->yres - 1.500000e+0) * pnt.y + 5.000000e-1);
    z = (signed int)(((double)vol->zres - 1.500000e+0) * pnt.z + 5.000000e-1);
    ptr = vol->data + (signed long int)(vol->xres * vol->yres * z + vol->xres * y + x);
    scalar = (double)((double)1.000000 * (double)(signed int)ptr[(signed long int)0]) / 255.000000;
    sum = sum + tt * scalar;
    transval = tt * scalar;
    col2=VoxelColor(scalar);
    if(sum < 1.000000)
    {
      col.r = col.r + (float)(transval * (double)col2.r);
      col.g = col.g + (float)(transval * (double)col2.g);
      col.b = col.b + (float)(transval * (double)col2.b);
      if(sum < 0.000000)
        sum = 0.000000;

    }

    else
      sum = 1.000000;
    t = t + dt;
  }
  if(sum < 1.000000)
  {
    struct anon$4 transcol;
    struct anon$19 shadevars;
    shadevars.hit = *hit;
    transcol=shade_transmission(ry, &shadevars, 1.000000 - sum);
    col.r = col.r + transcol.r;
    col.g = col.g + transcol.g;
    col.b = col.b + transcol.b;
  }

  return col;
}

// c::scalarvol_bbox
// file ../src/vol.c line 23
signed int scalarvol_bbox(void *obj, struct anon$0 *min, struct anon$0 *max)
{
  struct anon$26 *b = (struct anon$26 *)obj;
  *min = b->min;
  *max = b->max;
  return 1;
}

// c::shade_ambient_occlusion
// file ../src/shade.c line 367
struct anon$4 shade_ambient_occlusion(struct ray_t$link1 *incident, const struct anon$19 *shadevars)
{
  struct ray_t$link1 ambray;
  struct anon$4 ambcol;
  signed int i;
  double ndotambl;
  double inten = 0.000000;
  double lightscale = 2.000000 / (double)incident->scene->ambocc.numsamples;
  ambray.o = shadevars->hit;
  ambray.d = shadevars->N;
  ambray.o=Raypnt(&ambray, 5.000000e-8);
  ambray.serial = incident->serial + (unsigned long int)1;
  ambray.randval = incident->randval;
  ambray.frng = incident->frng;
  if(!((4096u & incident->scene->flags) == 0u))
    ambray.add_intersection = add_clipped_shadow_intersection;

  else
    ambray.add_intersection = add_shadow_intersection;
  ambray.mbox = incident->mbox;
  ambray.scene = incident->scene;
  i = 0;
  while(!(i >= incident->scene->ambocc.numsamples))
  {
    float dir[3l];
    ambray.maxdist = 1.000000e+18;
    ambray.flags = (unsigned int)4;
    ambray.serial = ambray.serial + 1ul;
    jitter_sphere3f(&ambray.frng, dir);
    ambray.d.x = (double)dir[(signed long int)0];
    ambray.d.y = (double)dir[(signed long int)1];
    ambray.d.z = (double)dir[(signed long int)2];
    ndotambl=VDot(&ambray.d, &shadevars->N);
    if(ndotambl < 0.000000)
    {
      ndotambl = -ndotambl;
      ambray.d.x = -ambray.d.x;
      ambray.d.y = -ambray.d.y;
      ambray.d.z = -ambray.d.z;
    }

    intersect_objects(&ambray);
    signed int return_value_shadow_intersection$1;
    return_value_shadow_intersection$1=shadow_intersection(&ambray);
    if(return_value_shadow_intersection$1 == 0)
    {
      ndotambl = ndotambl * ambray.intstruct.shadowfilter;
      inten = inten + ndotambl;
    }

    i = i + 1;
  }
  ambcol.r = (float)(lightscale * inten * (double)incident->scene->ambocc.col.r);
  ambcol.g = (float)(lightscale * inten * (double)incident->scene->ambocc.col.g);
  ambcol.b = (float)(lightscale * inten * (double)incident->scene->ambocc.col.b);
  incident->serial = ambray.serial + (unsigned long int)1;
  incident->frng = ambray.frng;
  return ambcol;
}

// c::shade_blinn
// file ../src/shade.h line 21
double shade_blinn(struct ray_t$link1 *incident, const struct anon$19 *shadevars, double specpower)
{
  struct anon$0 H;
  double inten;
  H.x = shadevars->L.x - incident->d.x;
  H.y = shadevars->L.y - incident->d.y;
  H.z = shadevars->L.z - incident->d.z;
  inten = shadevars->N.x * H.x + shadevars->N.y * H.y + shadevars->N.z * H.z;
  if(inten > 1.959000e-3)
  {
    double return_value_sqrt$1;
    return_value_sqrt$1=sqrt(H.x * H.x + H.y * H.y + H.z * H.z);
    inten = inten / return_value_sqrt$1;
    inten=pow(inten, specpower);
  }

  else
    inten = 0.000000;
  return inten;
}

// c::shade_blinn_fast
// file ../src/shade.h line 22
double shade_blinn_fast(struct ray_t$link1 *incident, const struct anon$19 *shadevars, double specpower)
{
  struct anon$0 H;
  double inten;
  H.x = shadevars->L.x - incident->d.x;
  H.y = shadevars->L.y - incident->d.y;
  H.z = shadevars->L.z - incident->d.z;
  inten = shadevars->N.x * H.x + shadevars->N.y * H.y + shadevars->N.z * H.z;
  if(inten > 0.000000)
  {
    double return_value_sqrt$1;
    return_value_sqrt$1=sqrt(H.x * H.x + H.y * H.y + H.z * H.z);
    inten = inten / return_value_sqrt$1;
    inten = inten / ((specpower - specpower * inten) + inten);
  }

  else
    inten = 0.000000;
  return inten;
}

// c::shade_nullphong
// file ../src/shade.h line 20
double shade_nullphong(struct ray_t$link1 *incident, const struct anon$19 *shadevars, double specpower)
{
  return 0.000000;
}

// c::shade_phong
// file ../src/shade.h line 19
double shade_phong(struct ray_t$link1 *incident, const struct anon$19 *shadevars, double specpower)
{
  struct anon$0 R;
  struct anon$0 V;
  struct anon$0 LL;
  double inten;
  LL = shadevars->L;
  VScale(&LL, -1.000000);
  VAddS(-2.000000 * (LL.x * shadevars->N.x + LL.y * shadevars->N.y + LL.z * shadevars->N.z), &shadevars->N, &LL, &R);
  V = incident->d;
  VScale(&V, -1.000000);
  VNorm(&R);
  inten=VDot(&V, &R);
  if(inten > 0.000000)
    inten=pow(inten, specpower);

  else
    inten = 0.000000;
  return inten;
}

// c::shade_reflection
// file ../src/shade.c line 444
struct anon$4 shade_reflection(struct ray_t$link1 *incident, const struct anon$19 *shadevars, double specular)
{
  struct ray_t$link1 specray;
  struct anon$4 col;
  struct anon$0 R;
  if(incident->depth <= 1u)
  {
    struct anon$4 return_value;
    return_value=incident->scene->bgtexfunc(incident);
    return return_value;
  }

  specray.depth = incident->depth - (unsigned int)1;
  VAddS(-2.000000 * (incident->d.x * shadevars->N.x + incident->d.y * shadevars->N.y + incident->d.z * shadevars->N.z), &shadevars->N, &incident->d, &R);
  specray.o = shadevars->hit;
  specray.d = R;
  specray.o=Raypnt(&specray, 5.000000e-8);
  specray.maxdist = 1.000000e+18;
  specray.opticdist = incident->opticdist;
  specray.add_intersection = incident->add_intersection;
  specray.flags = (unsigned int)2;
  specray.serial = incident->serial + (unsigned long int)1;
  specray.mbox = incident->mbox;
  specray.scene = incident->scene;
  specray.randval = incident->randval;
  specray.frng = incident->frng;
  intersect_objects(&specray);
  col=specray.scene->shader((void *)&specray);
  incident->serial = specray.serial;
  incident->frng = specray.frng;
  ColorScale(&col, specular);
  return col;
}

// c::shade_transmission
// file ../src/shade.h line 15
struct anon$4 shade_transmission(struct ray_t$link1 *incident, const struct anon$19 *shadevars, double trans)
{
  struct ray_t$link1 transray;
  struct anon$4 col;
  if(incident->depth <= 1u)
  {
    struct anon$4 return_value;
    return_value=incident->scene->bgtexfunc(incident);
    return return_value;
  }

  transray.depth = incident->depth - (unsigned int)1;
  transray.o = shadevars->hit;
  transray.d = incident->d;
  transray.o=Raypnt(&transray, 5.000000e-8);
  transray.maxdist = 1.000000e+18;
  transray.opticdist = incident->opticdist;
  transray.add_intersection = incident->add_intersection;
  transray.depth = incident->depth - (unsigned int)1;
  transray.flags = (unsigned int)2;
  transray.serial = incident->serial + (unsigned long int)1;
  transray.mbox = incident->mbox;
  transray.scene = incident->scene;
  transray.randval = incident->randval;
  transray.frng = incident->frng;
  intersect_objects(&transray);
  col=transray.scene->shader((void *)&transray);
  incident->serial = transray.serial;
  incident->frng = transray.frng;
  ColorScale(&col, trans);
  return col;
}

// c::shadow_intersection
// file ../src/intersect.c line 168
signed int shadow_intersection(struct ray_t$link0 *ry)
{
  if(ry->intstruct.num > 0)
    return 1;

  return 0;
}

// c::simple_point_light_shade_diffuse
// file ../src/light.c line 152
static double simple_point_light_shade_diffuse(struct point_light_t$link242 *li, struct anon$19 *shadevars)
{
  double inten;
  double len;
  shadevars->L.x = li->ctr.x - shadevars->hit.x;
  shadevars->L.y = li->ctr.y - shadevars->hit.y;
  shadevars->L.z = li->ctr.z - shadevars->hit.z;
  double return_value_sqrt$1;
  return_value_sqrt$1=sqrt(shadevars->L.x * shadevars->L.x + shadevars->L.y * shadevars->L.y + shadevars->L.z * shadevars->L.z);
  len = return_value_sqrt$1 + 5.000000e-8;
  shadevars->L.x = shadevars->L.x / len;
  shadevars->L.y = shadevars->L.y / len;
  shadevars->L.z = shadevars->L.z / len;
  shadevars->Llen = len;
  inten = shadevars->N.x * shadevars->L.x + shadevars->N.y * shadevars->L.y + shadevars->N.z * shadevars->L.z;
  return inten;
}

// c::sky_sphere_background_texture
// file ../src/texture.h line 12
struct anon$4 sky_sphere_background_texture(struct ray_t$link234 *ry)
{
  struct anon$4 col;
  double IdotG;
  IdotG=VDot(&ry->d, &ry->scene->bgtex.gradient);
  double range = ry->scene->bgtex.gradtopval - ry->scene->bgtex.gradbotval;
  double val = (IdotG - ry->scene->bgtex.gradbotval) / range;
  if(val < 0.000000)
    val = 0.000000;

  if(val > 1.000000)
    val = 1.000000;

  col.r = (float)(val * (double)ry->scene->bgtex.backgroundtop.r + (1.000000 - val) * (double)ry->scene->bgtex.backgroundbot.r);
  col.g = (float)(val * (double)ry->scene->bgtex.backgroundtop.g + (1.000000 - val) * (double)ry->scene->bgtex.backgroundbot.g);
  col.b = (float)(val * (double)ry->scene->bgtex.backgroundtop.b + (1.000000 - val) * (double)ry->scene->bgtex.backgroundbot.b);
  return col;
}

// c::snprintf
// file /usr/include/x86_64-linux-gnu/bits/stdio2.h line 61
signed int snprintf(char * restrict __s, unsigned long int __n, const char * restrict __fmt, ...)
{
  void *return_value___builtin_va_arg_pack$1;
  return_value___builtin_va_arg_pack$1=__builtin_va_arg_pack();
  signed int return_value___builtin___snprintf_chk$2;
  return_value___builtin___snprintf_chk$2=__builtin___snprintf_chk(__s, __n, 2 - 1, 18446744073709551615ul, __fmt, return_value___builtin_va_arg_pack$1);
  return return_value___builtin___snprintf_chk$2;
}

// c::solid_background_texture
// file ../src/texture.h line 11
struct anon$4 solid_background_texture(struct ray_t$link234 *ry)
{
  return ry->scene->bgtex.background;
}

// c::sphere_bbox
// file ../src/sphere.c line 38
static signed int sphere_bbox(void *obj, struct anon$0 *min, struct anon$0 *max)
{
  struct anon$53 *s = (struct anon$53 *)obj;
  min->x = s->ctr.x - s->rad;
  min->y = s->ctr.y - s->rad;
  min->z = s->ctr.z - s->rad;
  max->x = s->ctr.x + s->rad;
  max->y = s->ctr.y + s->rad;
  max->z = s->ctr.z + s->rad;
  return 1;
}

// c::sphere_intersect
// file ../src/sphere.c line 51
static void sphere_intersect(const struct anon$53 *spr, struct ray_t$link199 *ry)
{
  double b;
  double disc;
  double t1;
  double t2;
  double temp;
  struct anon$0 V;
  V.x = spr->ctr.x - ry->o.x;
  V.y = spr->ctr.y - ry->o.y;
  V.z = spr->ctr.z - ry->o.z;
  b = V.x * ry->d.x + V.y * ry->d.y + V.z * ry->d.z;
  temp = V.x * V.x + V.y * V.y + V.z * V.z;
  disc = (b * b + spr->rad * spr->rad) - temp;
  if(disc <= 0.000000)
    return;

  disc=sqrt(disc);
  t2 = b + disc;
  if(t2 <= 5.000000e-8)
    return;

  ry->add_intersection(t2, (struct anon$15 *)spr, ry);
  t1 = b - disc;
  if(t1 > 5.000000e-8)
    ry->add_intersection(t1, (struct anon$15 *)spr, ry);

}

// c::sphere_normal
// file ../src/sphere.c line 74
static void sphere_normal(const struct anon$53 *spr, const struct anon$0 *pnt, struct ray_t$link199 *incident, struct anon$0 *N)
{
  double invlen;
  N->x = pnt->x - spr->ctr.x;
  N->y = pnt->y - spr->ctr.y;
  N->z = pnt->z - spr->ctr.z;
  double return_value_sqrt$1;
  return_value_sqrt$1=sqrt(N->x * N->x + N->y * N->y + N->z * N->z);
  invlen = 1.000000 / return_value_sqrt$1;
  N->x = N->x * invlen;
  N->y = N->y * invlen;
  N->z = N->z * invlen;
  double return_value_VDot$2;
  return_value_VDot$2=VDot(N, &incident->d);
  if(return_value_VDot$2 > 0.000000)
  {
    N->x = -N->x;
    N->y = -N->y;
    N->z = -N->z;
  }

}

// c::sprintf
// file /usr/include/x86_64-linux-gnu/bits/stdio2.h line 31
signed int sprintf(char * restrict __s, const char * restrict __fmt, ...)
{
  void *return_value___builtin_va_arg_pack$1;
  return_value___builtin_va_arg_pack$1=__builtin_va_arg_pack();
  signed int return_value___builtin___sprintf_chk$2;
  return_value___builtin___sprintf_chk$2=__builtin___sprintf_chk(__s, 2 - 1, 18446744073709551615ul, __fmt, return_value___builtin_va_arg_pack$1);
  return return_value___builtin___sprintf_chk$2;
}

// c::stat
// file /usr/include/x86_64-linux-gnu/sys/stat.h line 454
signed int stat(const char *__path, struct stat *__statbuf)
{
  signed int return_value___xstat$1;
  return_value___xstat$1=__xstat(1, __path, __statbuf);
  return return_value___xstat$1;
}

// c::stpncpy
// file /usr/include/x86_64-linux-gnu/bits/string3.h line 130
char * stpncpy(char *__dest, const char *__src, unsigned long int __n)
{
  char *return_value___stpncpy_chk$1;
  if(FALSE)
  {

  __CPROVER_DUMP_L1:
    ;
    return_value___stpncpy_chk$1=__stpncpy_chk(__dest, __src, __n, 18446744073709551615ul);
    return return_value___stpncpy_chk$1;
  }

  char *return_value___stpncpy_alias$2;
  return_value___stpncpy_alias$2=__stpncpy_alias(__dest, __src, __n);
  return return_value___stpncpy_alias$2;
}

// c::strcat
// file /usr/include/x86_64-linux-gnu/bits/string3.h line 140
char * strcat(char * restrict __dest, const char * restrict __src)
{
  char *return_value___builtin___strcat_chk$1;
  return_value___builtin___strcat_chk$1=__builtin___strcat_chk(__dest, __src, 18446744073709551615ul);
  return return_value___builtin___strcat_chk$1;
}

// c::strcpy
// file /usr/include/x86_64-linux-gnu/bits/string3.h line 102
char * strcpy(char * restrict __dest, const char * restrict __src)
{
  char *return_value___builtin___strcpy_chk$1;
  return_value___builtin___strcpy_chk$1=__builtin___strcpy_chk(__dest, __src, 18446744073709551615ul);
  return return_value___builtin___strcpy_chk$1;
}

// c::stri_normal
// file ../src/triangle.c line 312
static void stri_normal(const struct anon$61 *trn, const struct anon$0 *hit, struct ray_t$link241 *incident, struct anon$0 *N)
{
  double U;
  double V;
  double W;
  double lensqr;
  double invlen;
  struct anon$0 P;
  struct anon$0 tmp;
  struct anon$0 norm;
  norm.x = trn->edge1.y * trn->edge2.z - trn->edge1.z * trn->edge2.y;
  norm.y = trn->edge1.z * trn->edge2.x - trn->edge1.x * trn->edge2.z;
  norm.z = trn->edge1.x * trn->edge2.y - trn->edge1.y * trn->edge2.x;
  lensqr = norm.x * norm.x + norm.y * norm.y + norm.z * norm.z;
  P.x = hit->x - trn->v0.x;
  P.y = hit->y - trn->v0.y;
  P.z = hit->z - trn->v0.z;
  tmp.x = P.y * trn->edge2.z - P.z * trn->edge2.y;
  tmp.y = P.z * trn->edge2.x - P.x * trn->edge2.z;
  tmp.z = P.x * trn->edge2.y - P.y * trn->edge2.x;
  U = (tmp.x * norm.x + tmp.y * norm.y + tmp.z * norm.z) / lensqr;
  tmp.x = trn->edge1.y * P.z - trn->edge1.z * P.y;
  tmp.y = trn->edge1.z * P.x - trn->edge1.x * P.z;
  tmp.z = trn->edge1.x * P.y - trn->edge1.y * P.x;
  V = (tmp.x * norm.x + tmp.y * norm.y + tmp.z * norm.z) / lensqr;
  W = 1.000000 - (U + V);
  N->x = W * trn->n0.x + U * trn->n1.x + V * trn->n2.x;
  N->y = W * trn->n0.y + U * trn->n1.y + V * trn->n2.y;
  N->z = W * trn->n0.z + U * trn->n1.z + V * trn->n2.z;
  double return_value_sqrt$1;
  return_value_sqrt$1=sqrt(N->x * N->x + N->y * N->y + N->z * N->z);
  invlen = 1.000000 / return_value_sqrt$1;
  N->x = N->x * invlen;
  N->y = N->y * invlen;
  N->z = N->z * invlen;
  double return_value_VDot$2;
  return_value_VDot$2=VDot(&norm, &incident->d);
  if(return_value_VDot$2 > 0.000000)
  {
    N->x = -N->x;
    N->y = -N->y;
    N->z = -N->z;
  }

}

// c::stri_normal_fixup
// file ../src/triangle.h line 9
void stri_normal_fixup(struct anon$15 *otri, signed int mode)
{
  struct anon$61 *t = (struct anon$61 *)otri;
  switch(mode)
  {

    case 2:
      {
        t->methods = &stri_methods_guess;
        goto __CPROVER_DUMP_L4;
      }
    case 1:
      {
        t->methods = &stri_methods_reverse;
        goto __CPROVER_DUMP_L4;
      }
    case 0:

      default:
        t->methods = &stri_methods;
  }

__CPROVER_DUMP_L4:
  ;
}

// c::stri_normal_guess
// file ../src/triangle.c line 419
static void stri_normal_guess(const struct anon$61 *trn, const struct anon$0 *hit, struct ray_t$link241 *incident, struct anon$0 *N)
{
  double U;
  double V;
  double W;
  double lensqr;
  double invlen;
  struct anon$0 P;
  struct anon$0 tmp;
  struct anon$0 norm;
  norm.x = trn->edge1.y * trn->edge2.z - trn->edge1.z * trn->edge2.y;
  norm.y = trn->edge1.z * trn->edge2.x - trn->edge1.x * trn->edge2.z;
  norm.z = trn->edge1.x * trn->edge2.y - trn->edge1.y * trn->edge2.x;
  lensqr = norm.x * norm.x + norm.y * norm.y + norm.z * norm.z;
  P.x = hit->x - trn->v0.x;
  P.y = hit->y - trn->v0.y;
  P.z = hit->z - trn->v0.z;
  tmp.x = P.y * trn->edge2.z - P.z * trn->edge2.y;
  tmp.y = P.z * trn->edge2.x - P.x * trn->edge2.z;
  tmp.z = P.x * trn->edge2.y - P.y * trn->edge2.x;
  U = (tmp.x * norm.x + tmp.y * norm.y + tmp.z * norm.z) / lensqr;
  tmp.x = trn->edge1.y * P.z - trn->edge1.z * P.y;
  tmp.y = trn->edge1.z * P.x - trn->edge1.x * P.z;
  tmp.z = trn->edge1.x * P.y - trn->edge1.y * P.x;
  V = (tmp.x * norm.x + tmp.y * norm.y + tmp.z * norm.z) / lensqr;
  W = 1.000000 - (U + V);
  N->x = W * trn->n0.x + U * trn->n1.x + V * trn->n2.x;
  N->y = W * trn->n0.y + U * trn->n1.y + V * trn->n2.y;
  N->z = W * trn->n0.z + U * trn->n1.z + V * trn->n2.z;
  double return_value_sqrt$1;
  return_value_sqrt$1=sqrt(N->x * N->x + N->y * N->y + N->z * N->z);
  invlen = 1.000000 / return_value_sqrt$1;
  N->x = N->x * invlen;
  N->y = N->y * invlen;
  N->z = N->z * invlen;
  double return_value_VDot$2;
  return_value_VDot$2=VDot(N, &incident->d);
  if(return_value_VDot$2 > 0.000000)
  {
    N->x = -N->x;
    N->y = -N->y;
    N->z = -N->z;
  }

}

// c::stri_normal_reverse
// file ../src/triangle.c line 379
static void stri_normal_reverse(const struct anon$61 *trn, const struct anon$0 *hit, struct ray_t$link241 *incident, struct anon$0 *N)
{
  double U;
  double V;
  double W;
  double lensqr;
  double invlen;
  struct anon$0 P;
  struct anon$0 tmp;
  struct anon$0 norm;
  norm.x = trn->edge1.y * trn->edge2.z - trn->edge1.z * trn->edge2.y;
  norm.y = trn->edge1.z * trn->edge2.x - trn->edge1.x * trn->edge2.z;
  norm.z = trn->edge1.x * trn->edge2.y - trn->edge1.y * trn->edge2.x;
  lensqr = norm.x * norm.x + norm.y * norm.y + norm.z * norm.z;
  P.x = hit->x - trn->v0.x;
  P.y = hit->y - trn->v0.y;
  P.z = hit->z - trn->v0.z;
  tmp.x = P.y * trn->edge2.z - P.z * trn->edge2.y;
  tmp.y = P.z * trn->edge2.x - P.x * trn->edge2.z;
  tmp.z = P.x * trn->edge2.y - P.y * trn->edge2.x;
  U = (tmp.x * norm.x + tmp.y * norm.y + tmp.z * norm.z) / lensqr;
  tmp.x = trn->edge1.y * P.z - trn->edge1.z * P.y;
  tmp.y = trn->edge1.z * P.x - trn->edge1.x * P.z;
  tmp.z = trn->edge1.x * P.y - trn->edge1.y * P.x;
  V = (tmp.x * norm.x + tmp.y * norm.y + tmp.z * norm.z) / lensqr;
  W = 1.000000 - (U + V);
  N->x = W * trn->n0.x + U * trn->n1.x + V * trn->n2.x;
  N->y = W * trn->n0.y + U * trn->n1.y + V * trn->n2.y;
  N->z = W * trn->n0.z + U * trn->n1.z + V * trn->n2.z;
  double return_value_sqrt$1;
  return_value_sqrt$1=sqrt(N->x * N->x + N->y * N->y + N->z * N->z);
  invlen = 1.000000 / return_value_sqrt$1;
  N->x = N->x * invlen;
  N->y = N->y * invlen;
  N->z = N->z * invlen;
  double return_value_VDot$2;
  return_value_VDot$2=VDot(&norm, &incident->d);
  if(return_value_VDot$2 < 0.000000)
  {
    N->x = -N->x;
    N->y = -N->y;
    N->z = -N->z;
  }

}

// c::stringcmp
// file ../demosrc/parse.c line 28
static signed int stringcmp(const char *a, const char *b)
{
  signed int i;
  signed int s;
  signed int l;
  unsigned long int return_value_strlen$1;
  return_value_strlen$1=strlen(a);
  s = (signed int)return_value_strlen$1;
  unsigned long int return_value_strlen$2;
  return_value_strlen$2=strlen(b);
  l = (signed int)return_value_strlen$2;
  if(!(s == l))
    return 1;

  i = 0;
  signed int tmp_statement_expression$3;
  signed int tmp_if_expr$5;
  const signed int **return_value___ctype_toupper_loc$6;
  while(!(i >= s))
  {
    signed int __res;
    if(FALSE)
    {
      if(FALSE)
      {
        signed int __c = (signed int)a[(signed long int)i];
        if(!(__c < -128))
        {
          if(__c > 255)
            goto __CPROVER_DUMP_L3;

        }

        else
        {

        __CPROVER_DUMP_L3:
          ;
          tmp_if_expr$5 = __c;
          goto __CPROVER_DUMP_L5;
        }
        const signed int **return_value___ctype_toupper_loc$4;
        return_value___ctype_toupper_loc$4=__ctype_toupper_loc();
        tmp_if_expr$5 = (*return_value___ctype_toupper_loc$4)[(signed long int)__c];

      __CPROVER_DUMP_L5:
        ;
        __res = tmp_if_expr$5;
      }

      else
        __res=toupper((signed int)a[(signed long int)i]);
    }

    else
    {
      return_value___ctype_toupper_loc$6=__ctype_toupper_loc();
      __res = (*return_value___ctype_toupper_loc$6)[(signed long int)(signed int)a[(signed long int)i]];
    }
    tmp_statement_expression$3 = __res;
    if(!(tmp_statement_expression$3 == (signed int)b[(signed long int)i]))
      return 1;

    i = i + 1;
  }
  return 0;
}

// c::stringcmp$link93
// file ../demosrc/ac3dparse.c line 25
static signed int stringcmp$link93(char *a$link91, char *b$link92)
{
  signed int i$link94;
  signed int s$link96;
  signed int l$link97;
  unsigned long int return_value_strlen$1$link244;
  return_value_strlen$1$link244=strlen(a$link91);
  s$link96 = (signed int)return_value_strlen$1$link244;
  unsigned long int return_value_strlen$2$link246;
  return_value_strlen$2$link246=strlen(b$link92);
  l$link97 = (signed int)return_value_strlen$2$link246;
  if(!(s$link96 == l$link97))
    return 1;

  i$link94 = 0;
  signed int tmp_statement_expression$3$link247;
  signed int tmp_if_expr$5$link249;
  const signed int **return_value___ctype_toupper_loc$6$link250;
  signed int tmp_statement_expression$7;
  signed int tmp_if_expr$9;
  const signed int **return_value___ctype_toupper_loc$10;
  while(!(i$link94 >= s$link96))
  {
    signed int __res$link99;
    if(FALSE)
    {
      if(FALSE)
      {
        signed int __c$link102 = (signed int)a$link91[(signed long int)i$link94];
        if(!(__c$link102 < -128))
        {
          if(__c$link102 > 255)
            goto __CPROVER_DUMP_L3;

        }

        else
        {

        __CPROVER_DUMP_L3:
          ;
          tmp_if_expr$5$link249 = __c$link102;
          goto __CPROVER_DUMP_L5;
        }
        const signed int **return_value___ctype_toupper_loc$4$link248;
        return_value___ctype_toupper_loc$4$link248=__ctype_toupper_loc();
        tmp_if_expr$5$link249 = (*return_value___ctype_toupper_loc$4$link248)[(signed long int)__c$link102];

      __CPROVER_DUMP_L5:
        ;
        __res$link99 = tmp_if_expr$5$link249;
      }

      else
        __res$link99=toupper((signed int)a$link91[(signed long int)i$link94]);
    }

    else
    {
      return_value___ctype_toupper_loc$6$link250=__ctype_toupper_loc();
      __res$link99 = (*return_value___ctype_toupper_loc$6$link250)[(signed long int)(signed int)a$link91[(signed long int)i$link94]];
    }
    tmp_statement_expression$3$link247 = __res$link99;
    signed int __res;
    if(FALSE)
    {
      if(FALSE)
      {
        signed int __c = (signed int)b$link92[(signed long int)i$link94];
        if(!(__c < -128))
        {
          if(__c > 255)
            goto __CPROVER_DUMP_L10;

        }

        else
        {

        __CPROVER_DUMP_L10:
          ;
          tmp_if_expr$9 = __c;
          goto __CPROVER_DUMP_L12;
        }
        const signed int **return_value___ctype_toupper_loc$8;
        return_value___ctype_toupper_loc$8=__ctype_toupper_loc();
        tmp_if_expr$9 = (*return_value___ctype_toupper_loc$8)[(signed long int)__c];

      __CPROVER_DUMP_L12:
        ;
        __res = tmp_if_expr$9;
      }

      else
        __res=toupper((signed int)b$link92[(signed long int)i$link94]);
    }

    else
    {
      return_value___ctype_toupper_loc$10=__ctype_toupper_loc();
      __res = (*return_value___ctype_toupper_loc$10)[(signed long int)(signed int)b$link92[(signed long int)i$link94]];
    }
    tmp_statement_expression$7 = __res;
    if(!(tmp_statement_expression$3$link247 == tmp_statement_expression$7))
      return 1;

    i$link94 = i$link94 + 1;
  }
  return 0;
}

// c::strncat
// file /usr/include/x86_64-linux-gnu/bits/string3.h line 147
char * strncat(char * restrict __dest, const char * restrict __src, unsigned long int __len)
{
  char *return_value___builtin___strncat_chk$1;
  return_value___builtin___strncat_chk$1=__builtin___strncat_chk(__dest, __src, (unsigned int)__len, 18446744073709551615ul);
  return return_value___builtin___strncat_chk$1;
}

// c::strncpy
// file /usr/include/x86_64-linux-gnu/bits/string3.h line 117
char * strncpy(char * restrict __dest, const char * restrict __src, unsigned long int __len)
{
  char *return_value___builtin___strncpy_chk$1;
  return_value___builtin___strncpy_chk$1=__builtin___strncpy_chk(__dest, __src, (unsigned int)__len, 18446744073709551615ul);
  return return_value___builtin___strncpy_chk$1;
}

// c::strupncmp
// file ../demosrc/getargs.c line 9
static signed int strupncmp(const char *a, const char *b, signed int n)
{
  signed int tmp_post$1;
  signed int tmp_statement_expression$10;
  signed int tmp_if_expr$12;
  const signed int **return_value___ctype_toupper_loc$13;
  signed int tmp_statement_expression$14;
  signed int tmp_if_expr$16;
  const signed int **return_value___ctype_toupper_loc$17;
  signed int tmp_statement_expression$2;
  signed int tmp_if_expr$4;
  const signed int **return_value___ctype_toupper_loc$5;
  signed int tmp_statement_expression$6;
  signed int tmp_if_expr$8;
  const signed int **return_value___ctype_toupper_loc$9;
  do
  {
    tmp_post$1 = n;
    n = n - 1;
    if(!(tmp_post$1 > 0))
      goto __CPROVER_DUMP_L32;

    signed int strupncmp$$1$$1$$1$$__res;
    if(FALSE)
    {
      if(FALSE)
      {
        signed int strupncmp$$1$$1$$1$$1$$1$$__c = (signed int)*a;
        if(!(strupncmp$$1$$1$$1$$1$$1$$__c < -128))
        {
          if(strupncmp$$1$$1$$1$$1$$1$$__c > 255)
            goto __CPROVER_DUMP_L2;

        }

        else
        {

        __CPROVER_DUMP_L2:
          ;
          tmp_if_expr$12 = strupncmp$$1$$1$$1$$1$$1$$__c;
          goto __CPROVER_DUMP_L4;
        }
        const signed int **return_value___ctype_toupper_loc$11;
        return_value___ctype_toupper_loc$11=__ctype_toupper_loc();
        tmp_if_expr$12 = (*return_value___ctype_toupper_loc$11)[(signed long int)strupncmp$$1$$1$$1$$1$$1$$__c];

      __CPROVER_DUMP_L4:
        ;
        strupncmp$$1$$1$$1$$__res = tmp_if_expr$12;
      }

      else
        strupncmp$$1$$1$$1$$__res=toupper((signed int)*a);
    }

    else
    {
      return_value___ctype_toupper_loc$13=__ctype_toupper_loc();
      strupncmp$$1$$1$$1$$__res = (*return_value___ctype_toupper_loc$13)[(signed long int)(signed int)*a];
    }
    tmp_statement_expression$10 = strupncmp$$1$$1$$1$$__res;
    signed int strupncmp$$1$$1$$2$$__res;
    if(FALSE)
    {
      if(FALSE)
      {
        signed int strupncmp$$1$$1$$2$$1$$1$$__c = (signed int)*b;
        if(!(strupncmp$$1$$1$$2$$1$$1$$__c < -128))
        {
          if(strupncmp$$1$$1$$2$$1$$1$$__c > 255)
            goto __CPROVER_DUMP_L9;

        }

        else
        {

        __CPROVER_DUMP_L9:
          ;
          tmp_if_expr$16 = strupncmp$$1$$1$$2$$1$$1$$__c;
          goto __CPROVER_DUMP_L11;
        }
        const signed int **return_value___ctype_toupper_loc$15;
        return_value___ctype_toupper_loc$15=__ctype_toupper_loc();
        tmp_if_expr$16 = (*return_value___ctype_toupper_loc$15)[(signed long int)strupncmp$$1$$1$$2$$1$$1$$__c];

      __CPROVER_DUMP_L11:
        ;
        strupncmp$$1$$1$$2$$__res = tmp_if_expr$16;
      }

      else
        strupncmp$$1$$1$$2$$__res=toupper((signed int)*b);
    }

    else
    {
      return_value___ctype_toupper_loc$17=__ctype_toupper_loc();
      strupncmp$$1$$1$$2$$__res = (*return_value___ctype_toupper_loc$17)[(signed long int)(signed int)*b];
    }
    tmp_statement_expression$14 = strupncmp$$1$$1$$2$$__res;
    if(!(tmp_statement_expression$10 == tmp_statement_expression$14))
    {
      signed int strupncmp$$1$$1$$3$$1$$__res;
      if(FALSE)
      {
        if(FALSE)
        {
          signed int strupncmp$$1$$1$$3$$1$$1$$1$$__c = (signed int)*b;
          if(!(strupncmp$$1$$1$$3$$1$$1$$1$$__c < -128))
          {
            if(strupncmp$$1$$1$$3$$1$$1$$1$$__c > 255)
              goto __CPROVER_DUMP_L16;

          }

          else
          {

          __CPROVER_DUMP_L16:
            ;
            tmp_if_expr$4 = strupncmp$$1$$1$$3$$1$$1$$1$$__c;
            goto __CPROVER_DUMP_L18;
          }
          const signed int **return_value___ctype_toupper_loc$3;
          return_value___ctype_toupper_loc$3=__ctype_toupper_loc();
          tmp_if_expr$4 = (*return_value___ctype_toupper_loc$3)[(signed long int)strupncmp$$1$$1$$3$$1$$1$$1$$__c];

        __CPROVER_DUMP_L18:
          ;
          strupncmp$$1$$1$$3$$1$$__res = tmp_if_expr$4;
        }

        else
          strupncmp$$1$$1$$3$$1$$__res=toupper((signed int)*b);
      }

      else
      {
        return_value___ctype_toupper_loc$5=__ctype_toupper_loc();
        strupncmp$$1$$1$$3$$1$$__res = (*return_value___ctype_toupper_loc$5)[(signed long int)(signed int)*b];
      }
      tmp_statement_expression$2 = strupncmp$$1$$1$$3$$1$$__res;
      signed int strupncmp$$1$$1$$3$$2$$__res;
      if(FALSE)
      {
        if(FALSE)
        {
          signed int strupncmp$$1$$1$$3$$2$$1$$1$$__c = (signed int)*a;
          if(!(strupncmp$$1$$1$$3$$2$$1$$1$$__c < -128))
          {
            if(strupncmp$$1$$1$$3$$2$$1$$1$$__c > 255)
              goto __CPROVER_DUMP_L23;

          }

          else
          {

          __CPROVER_DUMP_L23:
            ;
            tmp_if_expr$8 = strupncmp$$1$$1$$3$$2$$1$$1$$__c;
            goto __CPROVER_DUMP_L25;
          }
          const signed int **return_value___ctype_toupper_loc$7;
          return_value___ctype_toupper_loc$7=__ctype_toupper_loc();
          tmp_if_expr$8 = (*return_value___ctype_toupper_loc$7)[(signed long int)strupncmp$$1$$1$$3$$2$$1$$1$$__c];

        __CPROVER_DUMP_L25:
          ;
          strupncmp$$1$$1$$3$$2$$__res = tmp_if_expr$8;
        }

        else
          strupncmp$$1$$1$$3$$2$$__res=toupper((signed int)*a);
      }

      else
      {
        return_value___ctype_toupper_loc$9=__ctype_toupper_loc();
        strupncmp$$1$$1$$3$$2$$__res = (*return_value___ctype_toupper_loc$9)[(signed long int)(signed int)*a];
      }
      tmp_statement_expression$6 = strupncmp$$1$$1$$3$$2$$__res;
      return tmp_statement_expression$2 - tmp_statement_expression$6;
    }

    if((signed int)*a == 0)
      return 0;

    a = a + 1l;
    b = b + 1l;
  }
  while(TRUE);

__CPROVER_DUMP_L32:
  ;
  return 0;
}

// c::subdivide
// file ../src/apigeom.c line 166
static void subdivide(double *base, signed int xres, signed int yres, double wx, double wy, signed int x1, signed int y1, signed int x2, signed int y2, unsigned int *rndval)
{
  signed int x;
  signed int y;
  if(x2 + -x1 < 2)
  {
    if(y2 + -y1 < 2)
      return;

  }

  x = (x1 + x2) / 2;
  y = (y1 + y2) / 2;
  adjust(base, xres, yres, wx, wy, x1, y1, x, y1, x2, y1, rndval);
  adjust(base, xres, yres, wx, wy, x2, y1, x2, y, x2, y2, rndval);
  adjust(base, xres, yres, wx, wy, x1, y2, x, y2, x2, y2, rndval);
  adjust(base, xres, yres, wx, wy, x1, y1, x1, y, x1, y2, rndval);
  if(IEEE_FLOAT_EQUAL(*((signed long int)y * (signed long int)xres + base + (signed long int)x), 0.000000))
    base[(signed long int)(x + xres * y)] = (base[(signed long int)(x1 + xres * y1)] + base[(signed long int)(x2 + xres * y1)] + base[(signed long int)(x2 + xres * y2)] + base[(signed long int)(x1 + xres * y2)]) / 4.000000;

  subdivide(base, xres, yres, wx, wy, x1, y1, x, y, rndval);
  subdivide(base, xres, yres, wx, wy, x, y1, x2, y, rndval);
  subdivide(base, xres, yres, wx, wy, x, y, x2, y2, rndval);
  subdivide(base, xres, yres, wx, wy, x1, y, x, y2, rndval);
}

// c::tachyon_display_create
// file ../demosrc/main.c line 65
static struct anon$3 * tachyon_display_create(void *scene)
{
  struct anon$3 *dh;
  void *return_value_malloc$1;
  return_value_malloc$1=malloc(8ul /*[[struct anon$3]]*/);
  dh = (struct anon$3 *)return_value_malloc$1;
  if(!(dh == ((struct anon$3 *)NULL)))
  {
    memset((void *)dh, 0, 8ul /*[[struct anon$3]]*/);
    rt_get_resolution(scene, &dh->xsize, &dh->ysize);
  }

  return dh;
}

// c::tachyon_display_delete
// file ../demosrc/main.c line 110
static void tachyon_display_delete(struct anon$3 *dh)
{
  ;
}

// c::tachyon_display_draw
// file ../demosrc/main.c line 98
static void tachyon_display_draw(struct anon$3 *dh)
{
  ;
}

// c::tb_project_to_sphere
// file ../demosrc/trackball.c line 219
static float tb_project_to_sphere(float r, float x, float y)
{
  float d;
  float t;
  float z;
  double return_value_sqrt$1;
  return_value_sqrt$1=sqrt((double)(x * x + y * y));
  d = (float)return_value_sqrt$1;
  if((double)d < (double)r * 7.071068e-1)
  {
    double return_value_sqrt$2;
    return_value_sqrt$2=sqrt((double)(r * r - d * d));
    z = (float)return_value_sqrt$2;
  }

  else
  {
    t = (float)((double)r / 1.414214e+0);
    z = (t * t) / d;
  }
  return z;
}

// c::tgamma
// file /usr/include/x86_64-linux-gnu/bits/math-finite.h line 428
double tgamma(double __d)
{
  signed int __local_signgam = 0;
  double __res;
  __res=__gamma_r_finite(__d, &__local_signgam);
  return __local_signgam < 0 ? -__res : __res;
}

// c::tgammaf
// file /usr/include/x86_64-linux-gnu/bits/math-finite.h line 435
float tgammaf(float __d)
{
  signed int __local_signgam = 0;
  float __res;
  __res=__gammaf_r_finite(__d, &__local_signgam);
  return __local_signgam < 0 ? -__res : __res;
}

// c::tgammal
// file /usr/include/x86_64-linux-gnu/bits/math-finite.h line 443
long double tgammal(long double __d)
{
  signed int __local_signgam = 0;
  long double __res;
  __res=__gammal_r_finite(__d, &__local_signgam);
  return __local_signgam < 0 ? -__res : __res;
}

// c::thread_slave
// file ../src/render.c line 47
void * thread_slave(void *voidparms)
{
  struct anon$45 *parms = (struct anon$45 *)voidparms;
  signed int return_value_rt_thread_barrier$1;
  do
  {
    return_value_rt_thread_barrier$1=rt_thread_barrier(parms->runbar, 0);
    if(return_value_rt_thread_barrier$1 == 0)
      goto __CPROVER_DUMP_L2;

    thread_trace(parms);
  }
  while(TRUE);

__CPROVER_DUMP_L2:
  ;
  return NULL;
}

// c::thread_trace
// file ../src/trace.h line 23
void * thread_trace(struct anon$46$link123 *t)
{
  unsigned long int *local_mbox = (unsigned long int *)NULL;
  struct anon$48$link120 *scene;
  struct anon$4 col;
  struct ray_t$link119 primary;
  signed int x;
  signed int y;
  signed int do_ui;
  signed int hskip;
  signed int startx;
  signed int stopx;
  signed int xinc;
  signed int starty;
  signed int stopy;
  signed int yinc;
  signed int hsize;
  signed int vres;
  startx = t->startx;
  stopx = t->stopx;
  xinc = t->xinc;
  starty = t->starty;
  stopy = t->stopy;
  yinc = t->yinc;
  scene = t->scene;
  hsize = scene->hres * 3;
  vres = scene->vres;
  hskip = xinc * 3;
  _Bool tmp_if_expr$1;
  if(scene->mynode == 0)
    tmp_if_expr$1 = t->tid == 0 ? TRUE : FALSE;

  else
    tmp_if_expr$1 = FALSE;
  do_ui = (signed int)tmp_if_expr$1;
  void *return_value_calloc$2;
  if(t->local_mbox == ((unsigned long int *)NULL))
  {
    return_value_calloc$2=calloc(8ul /*[[unsigned long int]]*/ * (unsigned long int)scene->objgroup.numobjects, (unsigned long int)1);
    local_mbox = (unsigned long int *)return_value_calloc$2;
  }

  else
    local_mbox = t->local_mbox;
  unsigned int return_value_rng_seed_from_tid_nodeid$3;
  return_value_rng_seed_from_tid_nodeid$3=rng_seed_from_tid_nodeid(t->tid, scene->mynode);
  camray_init(scene, &primary, t->serialno, local_mbox, return_value_rng_seed_from_tid_nodeid$3);
  if(scene->imgbufformat == 0)
  {
    signed int thread_trace$$1$$1$$addr;
    signed int R;
    signed int G;
    signed int B;
    unsigned char *thread_trace$$1$$1$$img = (unsigned char *)scene->img;
    struct anon$18 thread_trace$$1$$1$$cachefrng = primary.frng;
    y = starty;
    while(stopy >= y)
    {
      thread_trace$$1$$1$$addr = hsize * (y - 1) + 3 * (startx - 1);
      x = startx;
      while(stopx >= x)
      {
        primary.frng = thread_trace$$1$$1$$cachefrng;
        col=scene->camera.cam_ray((void *)&primary, (double)x, (double)y);
        R = (signed int)(col.r * 255.000000f);
        G = (signed int)(col.g * 255.000000f);
        B = (signed int)(col.b * 255.000000f);
        if(R > 255)
          R = 255;

        if(R < 0)
          R = 0;

        thread_trace$$1$$1$$img[(signed long int)thread_trace$$1$$1$$addr] = (unsigned char)R;
        if(G > 255)
          G = 255;

        if(G < 0)
          G = 0;

        thread_trace$$1$$1$$img[(signed long int)(thread_trace$$1$$1$$addr + 1)] = (unsigned char)G;
        if(B > 255)
          B = 255;

        if(B < 0)
          B = 0;

        thread_trace$$1$$1$$img[(signed long int)(thread_trace$$1$$1$$addr + 2)] = (unsigned char)B;
        thread_trace$$1$$1$$addr = thread_trace$$1$$1$$addr + hskip;
        x = x + xinc;
      }
      if(!(do_ui == 0))
      {
        if((-1 + y) % 16 == 0)
          rt_ui_progress((100 * y) / vres);

      }

      y = y + yinc;
    }
  }

  else
  {
    signed int thread_trace$$1$$2$$addr;
    float *thread_trace$$1$$2$$img = (float *)scene->img;
    struct anon$18 thread_trace$$1$$2$$cachefrng = primary.frng;
    y = starty;
    while(stopy >= y)
    {
      thread_trace$$1$$2$$addr = hsize * (y - 1) + 3 * (startx - 1);
      x = startx;
      while(stopx >= x)
      {
        primary.frng = thread_trace$$1$$2$$cachefrng;
        col=scene->camera.cam_ray((void *)&primary, (double)x, (double)y);
        thread_trace$$1$$2$$img[(signed long int)thread_trace$$1$$2$$addr] = col.r;
        thread_trace$$1$$2$$img[(signed long int)(thread_trace$$1$$2$$addr + 1)] = col.g;
        thread_trace$$1$$2$$img[(signed long int)(thread_trace$$1$$2$$addr + 2)] = col.b;
        thread_trace$$1$$2$$addr = thread_trace$$1$$2$$addr + hskip;
        x = x + xinc;
      }
      if(!(do_ui == 0))
      {
        if((-1 + y) % 16 == 0)
          rt_ui_progress((100 * y) / vres);

      }

      y = y + yinc;
    }
  }
  t->serialno = primary.serial + (unsigned long int)1;
  if(t->local_mbox == ((unsigned long int *)NULL))
  {
    if(!(local_mbox == ((unsigned long int *)NULL)))
      free((void *)local_mbox);

  }

  if(scene->nodes == 1)
    rt_thread_barrier(t->runbar, 1);

  return NULL;
}

// c::tlist_add_tri
// file ../demosrc/ac3dparse.c line 273
static void tlist_add_tri(struct tri_list_t **tlist, signed int v0, signed int v1, signed int v2, signed int smooth, signed int texnum)
{
  struct tri_list_t *newlist;
  void *return_value_malloc$1;
  return_value_malloc$1=malloc(32ul /*[[struct tri_list_t]]*/);
  newlist = (struct tri_list_t *)return_value_malloc$1;
  newlist->v0 = v0;
  newlist->v1 = v1;
  newlist->v2 = v2;
  newlist->smooth = smooth;
  newlist->texnum = texnum;
  newlist->next = *tlist;
  *tlist = newlist;
}

// c::tlist_delete
// file ../demosrc/ac3dparse.c line 288
static void tlist_delete(struct tri_list_t **tlist)
{
  struct tri_list_t *tmp;
  struct tri_list_t *next;
  tmp = *tlist;
  while(!(tmp == ((struct tri_list_t *)NULL)))
  {
    next = tmp->next;
    free((void *)tmp);
    tmp = next;
  }
  *tlist = (struct tri_list_t *)NULL;
}

// c::tolower
// file /usr/include/ctype.h line 216
signed int tolower(signed int __c)
{
  signed int tmp_if_expr$2;
  const signed int **return_value___ctype_tolower_loc$1;
  if(__c >= -128)
  {
    if(!(__c < 256))
      goto __CPROVER_DUMP_L1;

    return_value___ctype_tolower_loc$1=__ctype_tolower_loc();
    tmp_if_expr$2 = (*return_value___ctype_tolower_loc$1)[(signed long int)__c];
  }

  else
  {

  __CPROVER_DUMP_L1:
    ;
    tmp_if_expr$2 = __c;
  }
  return tmp_if_expr$2;
}

// c::toupper
// file /usr/include/ctype.h line 222
signed int toupper(signed int __c)
{
  signed int tmp_if_expr$2;
  const signed int **return_value___ctype_toupper_loc$1;
  if(__c >= -128)
  {
    if(!(__c < 256))
      goto __CPROVER_DUMP_L1;

    return_value___ctype_toupper_loc$1=__ctype_toupper_loc();
    tmp_if_expr$2 = (*return_value___ctype_toupper_loc$1)[(signed long int)__c];
  }

  else
  {

  __CPROVER_DUMP_L1:
    ;
    tmp_if_expr$2 = __c;
  }
  return tmp_if_expr$2;
}

// c::trace
// file ../src/trace.c line 21
struct anon$4 trace(struct ray_t$link119 *primary)
{
  if(primary->depth > 0u)
  {
    intersect_objects(primary);
    struct anon$4 return_value;
    return_value=primary->scene->shader((void *)primary);
    return return_value;
  }

  struct anon$4 return_value_1;
  return_value_1=primary->scene->bgtexfunc(primary);
  return return_value_1;
}

// c::trackball
// file ../demosrc/trackball.c line 160
void trackball(float *q, float p1x, float p1y, float p2x, float p2y)
{
  float a[3l];
  float phi;
  float p1[3l];
  float p2[3l];
  float d[3l];
  float t;
  if(IEEE_FLOAT_EQUAL(p1x, p2x))
  {
    if(IEEE_FLOAT_EQUAL(p1y, p2y))
    {
      vzero(q);
      q[(signed long int)3] = (float)1.000000;
      return;
    }

  }

  float return_value_tb_project_to_sphere$1;
  return_value_tb_project_to_sphere$1=tb_project_to_sphere((float)8.000000e-1, p1x, p1y);
  vset(p1, p1x, p1y, return_value_tb_project_to_sphere$1);
  float return_value_tb_project_to_sphere$2;
  return_value_tb_project_to_sphere$2=tb_project_to_sphere((float)8.000000e-1, p2x, p2y);
  vset(p2, p2x, p2y, return_value_tb_project_to_sphere$2);
  vcross(p2, p1, a);
  vsub(p1, p2, d);
  float return_value_vlength$3;
  return_value_vlength$3=vlength(d);
  t = (float)((double)return_value_vlength$3 / (2.000000 * 8.000000e-1));
  if(t > 1.000000f)
    t = (float)1.000000;

  if(t < -1.000000f)
    t = (float)-1.000000;

  double return_value_asin$4;
  return_value_asin$4=asin((double)t);
  phi = (float)(2.000000 * return_value_asin$4);
  axis_to_quat(a, phi, q);
}

// c::tri_bbox
// file ../src/triangle.c line 209
static signed int tri_bbox(void *obj, struct anon$0 *min, struct anon$0 *max)
{
  struct anon$60 *t = (struct anon$60 *)obj;
  struct anon$0 v1;
  struct anon$0 v2;
  VAdd(&t->v0, &t->edge1, &v1);
  VAdd(&t->v0, &t->edge2, &v2);
  double tmp_if_expr$1;
  if(t->v0.x < (v1.x < v2.x ? v1.x : v2.x))
    tmp_if_expr$1 = t->v0.x;

  else
    tmp_if_expr$1 = v1.x < v2.x ? v1.x : v2.x;
  min->x = tmp_if_expr$1;
  double tmp_if_expr$2;
  if(t->v0.y < (v1.y < v2.y ? v1.y : v2.y))
    tmp_if_expr$2 = t->v0.y;

  else
    tmp_if_expr$2 = v1.y < v2.y ? v1.y : v2.y;
  min->y = tmp_if_expr$2;
  double tmp_if_expr$3;
  if(t->v0.z < (v1.z < v2.z ? v1.z : v2.z))
    tmp_if_expr$3 = t->v0.z;

  else
    tmp_if_expr$3 = v1.z < v2.z ? v1.z : v2.z;
  min->z = tmp_if_expr$3;
  double tmp_if_expr$4;
  if(t->v0.x > (v1.x > v2.x ? v1.x : v2.x))
    tmp_if_expr$4 = t->v0.x;

  else
    tmp_if_expr$4 = v1.x > v2.x ? v1.x : v2.x;
  max->x = tmp_if_expr$4;
  double tmp_if_expr$5;
  if(t->v0.y > (v1.y > v2.y ? v1.y : v2.y))
    tmp_if_expr$5 = t->v0.y;

  else
    tmp_if_expr$5 = v1.y > v2.y ? v1.y : v2.y;
  max->y = tmp_if_expr$5;
  double tmp_if_expr$6;
  if(t->v0.z > (v1.z > v2.z ? v1.z : v2.z))
    tmp_if_expr$6 = t->v0.z;

  else
    tmp_if_expr$6 = v1.z > v2.z ? v1.z : v2.z;
  max->z = tmp_if_expr$6;
  return 1;
}

// c::tri_intersect
// file ../src/triangle.c line 227
static void tri_intersect(const struct anon$60 *trn, struct ray_t$link241 *ry)
{
  struct anon$0 tvec;
  struct anon$0 pvec;
  struct anon$0 qvec;
  double det;
  double inv_det;
  double t;
  double u;
  double v;
  pvec.x = ry->d.y * trn->edge2.z - ry->d.z * trn->edge2.y;
  pvec.y = ry->d.z * trn->edge2.x - ry->d.x * trn->edge2.z;
  pvec.z = ry->d.x * trn->edge2.y - ry->d.y * trn->edge2.x;
  det = trn->edge1.x * pvec.x + trn->edge1.y * pvec.y + trn->edge1.z * pvec.z;
  if(det > -5.000000e-8)
  {
    if(det < 5.000000e-8)
      return;

  }

  inv_det = 1.000000 / det;
  tvec.x = ry->o.x - trn->v0.x;
  tvec.y = ry->o.y - trn->v0.y;
  tvec.z = ry->o.z - trn->v0.z;
  u = (tvec.x * pvec.x + tvec.y * pvec.y + tvec.z * pvec.z) * inv_det;
  if(!(u < 0.000000))
  {
    if(u > 1.000000)
      goto __CPROVER_DUMP_L2;

  }

  else
  {

  __CPROVER_DUMP_L2:
    ;
    return;
  }
  qvec.x = tvec.y * trn->edge1.z - tvec.z * trn->edge1.y;
  qvec.y = tvec.z * trn->edge1.x - tvec.x * trn->edge1.z;
  qvec.z = tvec.x * trn->edge1.y - tvec.y * trn->edge1.x;
  v = (ry->d.x * qvec.x + ry->d.y * qvec.y + ry->d.z * qvec.z) * inv_det;
  if(!(v < 0.000000))
  {
    if(u + v > 1.000000)
      goto __CPROVER_DUMP_L4;

  }

  else
  {

  __CPROVER_DUMP_L4:
    ;
    return;
  }
  t = (trn->edge2.x * qvec.x + trn->edge2.y * qvec.y + trn->edge2.z * qvec.z) * inv_det;
  ry->add_intersection(t, (struct anon$15 *)trn, ry);
}

// c::tri_normal
// file ../demosrc/ac3dparse.c line 332
static struct anon$0 tri_normal(struct anon$0 *v0, struct anon$0 *v1, struct anon$0 *v2)
{
  struct anon$0 U;
  struct anon$0 V;
  struct anon$0 norm;
  U.x = v1->x - v0->x;
  U.y = v1->y - v0->y;
  U.z = v1->z - v0->z;
  V.x = v2->x - v0->x;
  V.y = v2->y - v0->y;
  V.z = v2->z - v0->z;
  norm.x = U.y * V.z - U.z * V.y;
  norm.y = U.z * V.x - U.x * V.z;
  norm.z = U.x * V.y - U.y * V.x;
  normalize(&norm);
  return norm;
}

// c::tri_normal$link249
// file ../src/triangle.c line 293
static void tri_normal$link249(const struct anon$60 *trn, const struct anon$0 *hit, struct ray_t$link241 *incident, struct anon$0 *N)
{
  double invlen;
  N->x = trn->edge1.y * trn->edge2.z - trn->edge1.z * trn->edge2.y;
  N->y = trn->edge1.z * trn->edge2.x - trn->edge1.x * trn->edge2.z;
  N->z = trn->edge1.x * trn->edge2.y - trn->edge1.y * trn->edge2.x;
  double return_value_sqrt$1;
  return_value_sqrt$1=sqrt(N->x * N->x + N->y * N->y + N->z * N->z);
  invlen = 1.000000 / return_value_sqrt$1;
  N->x = N->x * invlen;
  N->y = N->y * invlen;
  N->z = N->z * invlen;
  double return_value_VDot$2;
  return_value_VDot$2=VDot(N, &incident->d);
  if(return_value_VDot$2 > 0.000000)
  {
    N->x = -N->x;
    N->y = -N->y;
    N->z = -N->z;
  }

}

// c::ttyname_r
// file /usr/include/x86_64-linux-gnu/bits/unistd.h line 291
signed int ttyname_r(signed int __fd, char *__buf, unsigned long int __buflen)
{
  signed int return_value___ttyname_r_chk$1;
  signed int return_value___ttyname_r_chk_warn$2;
  signed int return_value___ttyname_r_alias$3;
  return_value___ttyname_r_alias$3=__ttyname_r_alias(__fd, __buf, __buflen);
  return return_value___ttyname_r_alias$3;
}

// c::vadd
// file ../demosrc/trackball.c line 140
void vadd(const float *src1, const float *src2, float *dst)
{
  dst[(signed long int)0] = src1[(signed long int)0] + src2[(signed long int)0];
  dst[(signed long int)1] = src1[(signed long int)1] + src2[(signed long int)1];
  dst[(signed long int)2] = src1[(signed long int)2] + src2[(signed long int)2];
}

// c::vcopy
// file ../demosrc/trackball.c line 95
void vcopy(const float *v1, float *v2)
{
  signed int i = 0;
  while(i < 3)
  {
    v2[(signed long int)i] = v1[(signed long int)i];
    i = i + 1;
  }
}

// c::vcross
// file ../demosrc/trackball.c line 103
void vcross(const float *v1, const float *v2, float *cross)
{
  float temp[3l];
  temp[(signed long int)0] = v1[(signed long int)1] * v2[(signed long int)2] - v1[(signed long int)2] * v2[(signed long int)1];
  temp[(signed long int)1] = v1[(signed long int)2] * v2[(signed long int)0] - v1[(signed long int)0] * v2[(signed long int)2];
  temp[(signed long int)2] = v1[(signed long int)0] * v2[(signed long int)1] - v1[(signed long int)1] * v2[(signed long int)0];
  vcopy(temp, cross);
}

// c::vcstri_color
// file ../src/triangle.c line 351
struct anon$4 vcstri_color(const struct anon$0 *hit, const struct anon$25 *tx, struct ray_t$link241 *incident)
{
  struct anon$36 *tex = (struct anon$36 *)tx;
  const struct anon$62 *trn = (struct anon$62 *)tex->obj;
  double U;
  double V;
  double W;
  double lensqr;
  struct anon$0 P;
  struct anon$0 tmp;
  struct anon$0 norm;
  struct anon$4 col;
  norm.x = trn->edge1.y * trn->edge2.z - trn->edge1.z * trn->edge2.y;
  norm.y = trn->edge1.z * trn->edge2.x - trn->edge1.x * trn->edge2.z;
  norm.z = trn->edge1.x * trn->edge2.y - trn->edge1.y * trn->edge2.x;
  lensqr = norm.x * norm.x + norm.y * norm.y + norm.z * norm.z;
  P.x = hit->x - trn->v0.x;
  P.y = hit->y - trn->v0.y;
  P.z = hit->z - trn->v0.z;
  tmp.x = P.y * trn->edge2.z - P.z * trn->edge2.y;
  tmp.y = P.z * trn->edge2.x - P.x * trn->edge2.z;
  tmp.z = P.x * trn->edge2.y - P.y * trn->edge2.x;
  U = (tmp.x * norm.x + tmp.y * norm.y + tmp.z * norm.z) / lensqr;
  tmp.x = trn->edge1.y * P.z - trn->edge1.z * P.y;
  tmp.y = trn->edge1.z * P.x - trn->edge1.x * P.z;
  tmp.z = trn->edge1.x * P.y - trn->edge1.y * P.x;
  V = (tmp.x * norm.x + tmp.y * norm.y + tmp.z * norm.z) / lensqr;
  W = 1.000000 - (U + V);
  col.r = (float)(W * (double)tex->c0.r + U * (double)tex->c1.r + V * (double)tex->c2.r);
  col.g = (float)(W * (double)tex->c0.g + U * (double)tex->c1.g + V * (double)tex->c2.g);
  col.b = (float)(W * (double)tex->c0.b + U * (double)tex->c1.b + V * (double)tex->c2.b);
  return col;
}

// c::vcstri_normal_fixup
// file ../src/triangle.h line 12
void vcstri_normal_fixup(struct anon$15 *otri, signed int mode)
{
  struct anon$62 *t = (struct anon$62 *)otri;
  switch(mode)
  {

    case 2:
      {
        t->methods = &stri_methods_guess;
        goto __CPROVER_DUMP_L4;
      }
    case 1:
      {
        t->methods = &stri_methods_reverse;
        goto __CPROVER_DUMP_L4;
      }
    case 0:

      default:
        t->methods = &stri_methods;
  }

__CPROVER_DUMP_L4:
  ;
}

// c::vdot
// file ../demosrc/trackball.c line 134
float vdot(const float *v1, const float *v2)
{
  return v1[(signed long int)0] * v2[(signed long int)0] + v1[(signed long int)1] * v2[(signed long int)1] + v1[(signed long int)2] * v2[(signed long int)2];
}

// c::vdprintf
// file /usr/include/x86_64-linux-gnu/bits/stdio2.h line 150
signed int vdprintf(signed int __fd, const char * restrict __fmt, void **__ap)
{
  signed int return_value___vdprintf_chk$1;
  return_value___vdprintf_chk$1=__vdprintf_chk(__fd, 2 - 1, __fmt, __ap);
  return return_value___vdprintf_chk$1;
}

// c::vfprintf
// file /usr/include/x86_64-linux-gnu/bits/stdio2.h line 124
signed int vfprintf(struct _IO_FILE * restrict __stream, const char * restrict __fmt, void **__ap)
{
  signed int return_value___vfprintf_chk$1;
  return_value___vfprintf_chk$1=__vfprintf_chk(__stream, 2 - 1, __fmt, __ap);
  return return_value___vfprintf_chk$1;
}

// c::vlength
// file ../demosrc/trackball.c line 114
float vlength(const float *v)
{
  double return_value_sqrt$1;
  return_value_sqrt$1=sqrt((double)(v[(signed long int)0] * v[(signed long int)0] + v[(signed long int)1] * v[(signed long int)1] + v[(signed long int)2] * v[(signed long int)2]));
  return (float)return_value_sqrt$1;
}

// c::vnormal
// file ../demosrc/trackball.c line 128
void vnormal(float *v)
{
  float return_value_vlength$1;
  return_value_vlength$1=vlength(v);
  vscale(v, (float)(1.000000 / (double)return_value_vlength$1));
}

// c::vprintf
// file /usr/include/x86_64-linux-gnu/bits/stdio2.h line 114
signed int vprintf(const char * restrict __fmt, void **__ap)
{
  signed int return_value___vfprintf_chk$1;
  return_value___vfprintf_chk$1=__vfprintf_chk(stdout, 2 - 1, __fmt, __ap);
  return return_value___vfprintf_chk$1;
}

// c::vscale
// file ../demosrc/trackball.c line 120
void vscale(float *v, float div)
{
  v[(signed long int)0] = v[(signed long int)0] * div;
  v[(signed long int)1] = v[(signed long int)1] * div;
  v[(signed long int)2] = v[(signed long int)2] * div;
}

// c::vset
// file ../demosrc/trackball.c line 79
void vset(float *v, float x, float y, float z)
{
  v[(signed long int)0] = x;
  v[(signed long int)1] = y;
  v[(signed long int)2] = z;
}

// c::vsnprintf
// file /usr/include/x86_64-linux-gnu/bits/stdio2.h line 74
signed int vsnprintf(char * restrict __s, unsigned long int __n, const char * restrict __fmt, void **__ap)
{
  signed int return_value___builtin___vsnprintf_chk$1;
  return_value___builtin___vsnprintf_chk$1=__builtin___vsnprintf_chk(__s, __n, 2 - 1, 18446744073709551615ul, __fmt, __ap);
  return return_value___builtin___vsnprintf_chk$1;
}

// c::vsprintf
// file /usr/include/x86_64-linux-gnu/bits/stdio2.h line 43
signed int vsprintf(char * restrict __s, const char * restrict __fmt, void **__ap)
{
  signed int return_value___builtin___vsprintf_chk$1;
  return_value___builtin___vsprintf_chk$1=__builtin___vsprintf_chk(__s, 2 - 1, 18446744073709551615ul, __fmt, __ap);
  return return_value___builtin___vsprintf_chk$1;
}

// c::vsub
// file ../demosrc/trackball.c line 87
void vsub(const float *src1, const float *src2, float *dst)
{
  dst[(signed long int)0] = src1[(signed long int)0] - src2[(signed long int)0];
  dst[(signed long int)1] = src1[(signed long int)1] - src2[(signed long int)1];
  dst[(signed long int)2] = src1[(signed long int)2] - src2[(signed long int)2];
}

// c::vzero
// file ../demosrc/trackball.c line 71
void vzero(float *v)
{
  v[(signed long int)0] = (float)0.000000;
  v[(signed long int)1] = (float)0.000000;
  v[(signed long int)2] = (float)0.000000;
}

// c::wcstombs
// file /usr/include/x86_64-linux-gnu/bits/stdlib.h line 144
unsigned long int wcstombs(char * restrict __dst, const signed int * restrict __src, unsigned long int __len)
{
  unsigned long int return_value___wcstombs_chk$1;
  unsigned long int return_value___wcstombs_chk_warn$2;
  unsigned long int return_value___wcstombs_alias$3;
  return_value___wcstombs_alias$3=__wcstombs_alias(__dst, __src, __len);
  return return_value___wcstombs_alias$3;
}

// c::wctomb
// file /usr/include/x86_64-linux-gnu/bits/stdlib.h line 83
signed int wctomb(char *__s, signed int __wchar)
{
  signed int return_value___wctomb_chk$1;
  signed int return_value___wctomb_alias$2;
  return_value___wctomb_alias$2=__wctomb_alias(__s, __wchar);
  return return_value___wctomb_alias$2;
}

// c::wood_texture
// file ../src/texture.h line 23
struct anon$4 wood_texture(const struct anon$0 *hit, const struct anon$25 *tx, struct ray_t$link234 *ry)
{
  double radius;
  double angle;
  signed int grain;
  struct anon$4 col;
  double x;
  double y;
  double z;
  struct anon$35 *tex = (struct anon$35 *)tx;
  x = (hit->x - tex->ctr.x) / tex->scale.x;
  y = (hit->y - tex->ctr.y) / tex->scale.y;
  z = (hit->z - tex->ctr.z) / tex->scale.z;
  radius=sqrt(x * x + z * z);
  if(IEEE_FLOAT_EQUAL(z, 0.000000))
    angle = 3.141593e+0 / 2.000000;

  else
    angle=atan(x / z);
  double return_value_sin$1;
  return_value_sin$1=sin((double)20 * angle + y / 150.000000);
  radius = radius + 3.000000 * return_value_sin$1;
  grain = (signed int)(radius + 5.000000e-1) % 60;
  if(grain < 40)
  {
    col.r = (float)8.000000e-1;
    col.g = (float)1.000000;
    col.b = (float)2.000000e-1;
  }

  else
  {
    col.r = (float)0.000000;
    col.g = (float)0.000000;
    col.b = (float)0.000000;
  }
  return col;
}

// c::write_le_int16
// file ../src/winbmp.c line 22
static void write_le_int16(struct _IO_FILE$link44 *dfile, signed int num)
{
  fputc(num & 255, dfile);
  fputc(num >> 8 & 255, dfile);
}

// c::write_le_int32
// file ../src/winbmp.c line 15
static void write_le_int32(struct _IO_FILE$link44 *dfile, signed int num)
{
  fputc(num & 255, dfile);
  fputc(num >> 8 & 255, dfile);
  fputc(num >> 16 & 255, dfile);
  fputc(num >> 24 & 255, dfile);
}

// c::writebmp
// file ../src/winbmp.h line 8
signed int writebmp(char *filename, signed int xs, signed int ys, unsigned char *img)
{
  if(!(img == ((unsigned char *)NULL)))
  {
    struct _IO_FILE$link44 *dfile;
    dfile=fopen(filename, "wb");
    if(!(dfile == ((struct _IO_FILE$link44 *)NULL)))
    {
      signed int i;
      signed int y;
      signed int imgdataoffset = 14 + 40;
      signed int rowsz = xs * 3 + 3 & -4;
      signed int imgdatasize = rowsz * ys;
      signed int filesize = imgdataoffset + imgdatasize;
      unsigned char *rowbuf = (unsigned char *)NULL;
      fputc(66, dfile);
      fputc(77, dfile);
      write_le_int32(dfile, filesize);
      write_le_int16(dfile, 0);
      write_le_int16(dfile, 0);
      write_le_int32(dfile, imgdataoffset);
      write_le_int32(dfile, 40);
      write_le_int32(dfile, xs);
      write_le_int32(dfile, ys);
      write_le_int16(dfile, 1);
      write_le_int16(dfile, 24);
      write_le_int32(dfile, 0);
      write_le_int32(dfile, imgdatasize);
      write_le_int32(dfile, 11811);
      write_le_int32(dfile, 11811);
      write_le_int32(dfile, 0);
      write_le_int32(dfile, 0);
      void *return_value_malloc$1;
      return_value_malloc$1=malloc((unsigned long int)rowsz);
      rowbuf = (unsigned char *)return_value_malloc$1;
      if(!(rowbuf == ((unsigned char *)NULL)))
      {
        memset((void *)rowbuf, 0, (unsigned long int)rowsz);
        y = 0;
        while(!(y >= ys))
        {
          signed int addr = xs * 3 * y;
          i = 0;
          while(!(i >= rowsz))
          {
            rowbuf[(signed long int)i] = img[(signed long int)(addr + i + 2)];
            rowbuf[(signed long int)(i + 1)] = img[(signed long int)(addr + i + 1)];
            rowbuf[(signed long int)(i + 2)] = img[(signed long int)(addr + i)];
            i = i + 3;
          }
          fwrite((const void *)rowbuf, (unsigned long int)rowsz, (unsigned long int)1, dfile);
          y = y + 1;
        }
        free((void *)rowbuf);
      }

      fclose(dfile);
    }

  }

  return 0;
}

// c::writeimage
// file ../src/imageio.h line 19
signed int writeimage(char *name, signed int xres, signed int yres, void *img, signed int imgbufferformat, signed int fileformat)
{
  if(img == NULL)
    return 6;

  signed int return_value_writeppm$1;
  signed int return_value_writergb$2;
  signed int return_value_writejpeg$3;
  signed int return_value_writepng$4;
  signed int return_value_writebmp$5;
  signed int return_value_writetga$6;
  if(imgbufferformat == 0)
  {
    unsigned char *writeimage$$1$$1$$imgbuf = (unsigned char *)img;
    switch(fileformat)
    {

      case 1:
        {
          return_value_writeppm$1=writeppm(name, xres, yres, writeimage$$1$$1$$imgbuf);
          return return_value_writeppm$1;
        }
      case 2:
        {
          return_value_writergb$2=writergb(name, xres, yres, writeimage$$1$$1$$imgbuf);
          return return_value_writergb$2;
        }
      case 3:
        {
          return_value_writejpeg$3=writejpeg(name, xres, yres, writeimage$$1$$1$$imgbuf);
          return return_value_writejpeg$3;
        }
      case 5:
        {
          return_value_writepng$4=writepng(name, xres, yres, writeimage$$1$$1$$imgbuf);
          return return_value_writepng$4;
        }
      case 4:
        {
          return_value_writebmp$5=writebmp(name, xres, yres, writeimage$$1$$1$$imgbuf);
          return return_value_writebmp$5;
        }
      case 0:
        {
          return_value_writetga$6=writetga(name, xres, yres, writeimage$$1$$1$$imgbuf);
          return return_value_writetga$6;
        }
      default:
        {
          printf("Unsupported image format combination\n");
          return 2;
        }
    }
  }

  else
  {
    unsigned char *writeimage$$1$$2$$imgbuf = (unsigned char *)img;
    signed int rc;
    switch(fileformat)
    {

      case 1:
        {
          writeimage$$1$$2$$imgbuf=image_rgb24_from_rgb96f(xres, yres, (float *)img);
          rc=writeppm(name, xres, yres, writeimage$$1$$2$$imgbuf);
          free((void *)writeimage$$1$$2$$imgbuf);
          return rc;
        }
      case 2:
        {
          writeimage$$1$$2$$imgbuf=image_rgb24_from_rgb96f(xres, yres, (float *)img);
          rc=writergb(name, xres, yres, writeimage$$1$$2$$imgbuf);
          free((void *)writeimage$$1$$2$$imgbuf);
          return rc;
        }
      case 3:
        {
          writeimage$$1$$2$$imgbuf=image_rgb24_from_rgb96f(xres, yres, (float *)img);
          rc=writejpeg(name, xres, yres, writeimage$$1$$2$$imgbuf);
          free((void *)writeimage$$1$$2$$imgbuf);
          return rc;
        }
      case 5:
        {
          writeimage$$1$$2$$imgbuf=image_rgb24_from_rgb96f(xres, yres, (float *)img);
          rc=writepng(name, xres, yres, writeimage$$1$$2$$imgbuf);
          free((void *)writeimage$$1$$2$$imgbuf);
          return rc;
        }
      case 4:
        {
          writeimage$$1$$2$$imgbuf=image_rgb24_from_rgb96f(xres, yres, (float *)img);
          rc=writebmp(name, xres, yres, writeimage$$1$$2$$imgbuf);
          free((void *)writeimage$$1$$2$$imgbuf);
          return rc;
        }
      case 0:
        {
          writeimage$$1$$2$$imgbuf=image_rgb24_from_rgb96f(xres, yres, (float *)img);
          rc=writetga(name, xres, yres, writeimage$$1$$2$$imgbuf);
          free((void *)writeimage$$1$$2$$imgbuf);
          return rc;
        }
      case 6:
        {
          writeimage$$1$$2$$imgbuf=image_rgb48be_from_rgb96f(xres, yres, (float *)img);
          rc=writeppm48(name, xres, yres, writeimage$$1$$2$$imgbuf);
          free((void *)writeimage$$1$$2$$imgbuf);
          return rc;
        }
      case 7:
        {
          writeimage$$1$$2$$imgbuf=image_rgb48bepl_from_rgb96f(xres, yres, (float *)img);
          rc=writepsd48(name, xres, yres, writeimage$$1$$2$$imgbuf);
          free((void *)writeimage$$1$$2$$imgbuf);
          return rc;
        }
      default:
        {
          printf("Unsupported image format combination\n");
          return 2;
        }
    }
  }
}

// c::writejpeg
// file ../src/jpeg.h line 8
signed int writejpeg(char *name, signed int xres, signed int yres, unsigned char *imgdata)
{
  return 2;
}

// c::writepng
// file ../src/pngfile.h line 8
signed int writepng(char *name, signed int xres, signed int yres, unsigned char *imgdata)
{
  return 2;
}

// c::writeppm
// file ../src/ppm.h line 12
signed int writeppm(char *name, signed int xres, signed int yres, unsigned char *imgdata)
{
  struct _IO_FILE$link40 *ofp;
  signed int y;
  signed int xbytes = 3 * xres;
  ofp=fopen(name, "wb");
  if(ofp == ((struct _IO_FILE$link40 *)NULL))
    return 1;

  fprintf(ofp, "P6\n");
  fprintf(ofp, "%d %d\n", xres, yres);
  fprintf(ofp, "255\n");
  y = 0;
  while(!(y >= yres))
  {
    unsigned long int return_value_fwrite$1;
    return_value_fwrite$1=fwrite((const void *)&imgdata[(signed long int)(((yres - y) - 1) * xbytes)], (unsigned long int)1, (unsigned long int)xbytes, ofp);
    if(!(return_value_fwrite$1 == (unsigned long int)xbytes))
    {
      fclose(ofp);
      return 5;
    }

    y = y + 1;
  }
  fclose(ofp);
  return 0;
}

// c::writeppm48
// file ../src/ppm.h line 13
signed int writeppm48(char *name, signed int xres, signed int yres, unsigned char *imgdata)
{
  struct _IO_FILE$link40 *ofp;
  signed int y;
  signed int xbytes = 6 * xres;
  ofp=fopen(name, "wb");
  if(ofp == ((struct _IO_FILE$link40 *)NULL))
    return 1;

  fprintf(ofp, "P6\n");
  fprintf(ofp, "%d %d\n", xres, yres);
  fprintf(ofp, "65535\n");
  y = 0;
  while(!(y >= yres))
  {
    unsigned long int return_value_fwrite$1;
    return_value_fwrite$1=fwrite((const void *)&imgdata[(signed long int)(((yres - y) - 1) * xbytes)], (unsigned long int)1, (unsigned long int)xbytes, ofp);
    if(!(return_value_fwrite$1 == (unsigned long int)xbytes))
    {
      fclose(ofp);
      return 5;
    }

    y = y + 1;
  }
  fclose(ofp);
  return 0;
}

// c::writepsd48
// file ../src/psd.h line 7
signed int writepsd48(char *name, signed int xres, signed int yres, unsigned char *imgdata)
{
  struct _IO_FILE$link41 *ofp;
  signed int y;
  signed int p;
  char width[4l];
  char height[4l];
  const char *sig = "8BPS";
  const char ver[8l] = { (const char)0, (const char)1, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0 };
  const char chn[2l] = { (const char)0, (const char)3 };
  const char mod[4l] = { (const char)0, (const char)16, (const char)0, (const char)3 };
  const char hdr[14l] = { (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0, (const char)0 };
  ofp=fopen(name, "wb");
  if(ofp == ((struct _IO_FILE$link41 *)NULL))
    return 1;

  width[(signed long int)0] = (char)(xres >> 24 & 255);
  width[(signed long int)1] = (char)(xres >> 16 & 255);
  width[(signed long int)2] = (char)(xres >> 8 & 255);
  width[(signed long int)3] = (char)(xres & 255);
  height[(signed long int)0] = (char)(yres >> 24 & 255);
  height[(signed long int)1] = (char)(yres >> 16 & 255);
  height[(signed long int)2] = (char)(yres >> 8 & 255);
  height[(signed long int)3] = (char)(yres & 255);
  fwrite((const void *)sig, (unsigned long int)4, (unsigned long int)1, ofp);
  fwrite((const void *)ver, (unsigned long int)8, (unsigned long int)1, ofp);
  fwrite((const void *)chn, (unsigned long int)2, (unsigned long int)1, ofp);
  fwrite((const void *)height, (unsigned long int)4, (unsigned long int)1, ofp);
  fwrite((const void *)width, (unsigned long int)4, (unsigned long int)1, ofp);
  fwrite((const void *)mod, (unsigned long int)4, (unsigned long int)1, ofp);
  fwrite((const void *)hdr, (unsigned long int)14, (unsigned long int)1, ofp);
  p = 0;
  while(p < 3)
  {
    signed int paddr = xres * yres * 2 * p;
    y = 0;
    while(!(y >= yres))
    {
      fwrite((const void *)&imgdata[(signed long int)(paddr + ((yres - y) - 1) * xres * 2)], (unsigned long int)1, (unsigned long int)(2 * xres), ofp);
      y = y + 1;
    }
    p = p + 1;
  }
  fclose(ofp);
  return 0;
}

// c::writergb
// file ../src/sgirgb.h line 7
signed int writergb(char *name, signed int xres, signed int yres, unsigned char *imgdata)
{
  struct _IO_FILE$link42 *ofp;
  char iname[80l];
  signed int x;
  signed int y;
  signed int i;
  ofp=fopen(name, "wb");
  if(!(ofp == ((struct _IO_FILE$link42 *)NULL)))
  {
    putshort(ofp, (unsigned short int)474);
    putbyte(ofp, (unsigned char)0);
    putbyte(ofp, (unsigned char)1);
    putshort(ofp, (unsigned short int)3);
    putshort(ofp, (unsigned short int)xres);
    putshort(ofp, (unsigned short int)yres);
    putshort(ofp, (unsigned short int)3);
    putint(ofp, (unsigned int)0);
    putint(ofp, (unsigned int)255);
    i = 0;
    while(i < 4)
    {
      putbyte(ofp, (unsigned char)0);
      i = i + 1;
    }
    strcpy(iname, "Tachyon Ray Tracer Image");
    fwrite((const void *)iname, (unsigned long int)80, (unsigned long int)1, ofp);
    putint(ofp, (unsigned int)0);
    i = 0;
    while(i < 404)
    {
      putbyte(ofp, (unsigned char)0);
      i = i + 1;
    }
    i = 0;
    while(i < 3)
    {
      y = 0;
      while(!(y >= yres))
      {
        x = 0;
        while(!(x >= xres))
        {
          fwrite((const void *)&imgdata[(signed long int)((y * xres + x) * 3 + i)], (unsigned long int)1, (unsigned long int)1, ofp);
          x = x + 1;
        }
        y = y + 1;
      }
      i = i + 1;
    }
    fclose(ofp);
  }

  return 0;
}

// c::writetga
// file ../src/tgafile.h line 13
signed int writetga(char *name, signed int xres, signed int yres, unsigned char *imgdata)
{
  void *outfile;
  signed int rc = 0;
  rc=createtgafile(name, (unsigned short int)xres, (unsigned short int)yres);
  if(rc == 0)
  {
    outfile=opentgafile(name);
    if(outfile == NULL)
      return 5;

    writetgaregion(outfile, 1, 1, xres, yres, imgdata);
    closetgafile(outfile);
  }

  return rc;
}

// c::writetgaregion
// file ../src/tgafile.c line 88
void writetgaregion(void *voidhandle, signed int startx, signed int starty, signed int stopx, signed int stopy, unsigned char *buffer)
{
  signed int x;
  signed int y;
  signed int totalx;
  signed int totaly;
  signed int xbytes;
  signed int widthbytes;
  signed int regionstart;
  unsigned char *bufpos;
  signed int filepos;
  signed int numbytes;
  struct anon$72 *tga = (struct anon$72 *)voidhandle;
  unsigned char *fixbuf;
  totalx = (stopx - startx) + 1;
  totaly = (stopy - starty) + 1;
  xbytes = totalx * 3;
  widthbytes = (signed int)tga->width * 3;
  void *return_value_malloc$1;
  return_value_malloc$1=malloc((unsigned long int)xbytes);
  fixbuf = (unsigned char *)return_value_malloc$1;
  if(fixbuf == ((unsigned char *)NULL))
  {
    rt_ui_message(200, "writetgaregion: failed memory allocation!\n");
    return;
  }

  regionstart = 18 + (startx - 1) * 3 + widthbytes * ((((signed int)tga->height - starty) - totaly) + 1);
  if(totalx == (signed int)tga->width)
  {
    filepos = regionstart;
    if(filepos >= 18)
      fseek(tga->ofp, (signed long int)filepos, 0);

    else
    {
      rt_ui_message(200, "writetgaregion: file ptr out of range!!!\n");
      free((void *)fixbuf);
      return;
    }
    y = 0;
    while(!(y >= totaly))
    {
      bufpos = buffer + (signed long int)(xbytes * ((totaly - y) - 1));
      x = 0;
      while(!(x >= xbytes))
      {
        fixbuf[(signed long int)x] = bufpos[(signed long int)(x + 2)];
        fixbuf[(signed long int)(x + 1)] = bufpos[(signed long int)(x + 1)];
        fixbuf[(signed long int)(x + 2)] = bufpos[(signed long int)x];
        x = x + 3;
      }
      unsigned long int return_value_fwrite$2;
      return_value_fwrite$2=fwrite((const void *)fixbuf, (unsigned long int)1, (unsigned long int)xbytes, tga->ofp);
      numbytes = (signed int)return_value_fwrite$2;
      if(!(numbytes == xbytes))
      {
        char writetgaregion$$1$$2$$3$$2$$msgtxt[256l];
        sprintf(writetgaregion$$1$$2$$3$$2$$msgtxt, "File write problem, %d bytes written.", numbytes);
        rt_ui_message(200, writetgaregion$$1$$2$$3$$2$$msgtxt);
        free((void *)fixbuf);
        return;
      }

      y = y + 1;
    }
  }

  else
  {
    y = 0;
    while(!(y >= totaly))
    {
      bufpos = buffer + (signed long int)(xbytes * ((totaly - y) - 1));
      filepos = regionstart + widthbytes * y;
      if(filepos >= 18)
      {
        fseek(tga->ofp, (signed long int)filepos, 0);
        x = 0;
        while(!(x >= xbytes))
        {
          fixbuf[(signed long int)x] = bufpos[(signed long int)(x + 2)];
          fixbuf[(signed long int)(x + 1)] = bufpos[(signed long int)(x + 1)];
          fixbuf[(signed long int)(x + 2)] = bufpos[(signed long int)x];
          x = x + 3;
        }
        unsigned long int return_value_fwrite$3;
        return_value_fwrite$3=fwrite((const void *)fixbuf, (unsigned long int)1, (unsigned long int)xbytes, tga->ofp);
        numbytes = (signed int)return_value_fwrite$3;
        if(!(numbytes == xbytes))
        {
          char writetgaregion$$1$$3$$1$$1$$2$$msgtxt[256l];
          sprintf(writetgaregion$$1$$3$$1$$1$$2$$msgtxt, "File write problem, %d bytes written.", numbytes);
          rt_ui_message(200, writetgaregion$$1$$3$$1$$1$$2$$msgtxt);
          free((void *)fixbuf);
          return;
        }

      }

      else
      {
        rt_ui_message(200, "writetgaregion: file ptr out of range!!!\n");
        free((void *)fixbuf);
        return;
      }
      y = y + 1;
    }
  }
  free((void *)fixbuf);
}

// c::xytopolar
// file ../src/coordsys.c line 11
void xytopolar(double x, double y, double rad, double *u, double *v)
{
  double r1 = x * x + y * y;
  *v=sqrt(r1 / (rad * rad));
  double return_value_sqrt$1;
  double return_value_acos$2;
  double return_value_sqrt$3;
  double return_value_acos$4;
  if(y < 0.000000)
  {
    return_value_sqrt$1=sqrt(r1);
    return_value_acos$2=acos(x / return_value_sqrt$1);
    *u = 1.000000 - return_value_acos$2 / 6.283185e+0;
  }

  else
  {
    return_value_sqrt$3=sqrt(r1);
    return_value_acos$4=acos(x / return_value_sqrt$3);
    *u = return_value_acos$4 / 6.283185e+0;
  }
}

// c::xyztocyl
// file ../src/coordsys.h line 8
void xyztocyl(struct anon$0 pnt, double height, double *u, double *v)
{
  double r1 = pnt.x * pnt.x + pnt.y * pnt.y;
  *v = pnt.z / height;
  double return_value_sqrt$1;
  double return_value_acos$2;
  double return_value_sqrt$3;
  double return_value_acos$4;
  if(pnt.y < 0.000000)
  {
    return_value_sqrt$1=sqrt(r1);
    return_value_acos$2=acos(pnt.x / return_value_sqrt$1);
    *u = 1.000000 - return_value_acos$2 / 6.283185e+0;
  }

  else
  {
    return_value_sqrt$3=sqrt(r1);
    return_value_acos$4=acos(pnt.x / return_value_sqrt$3);
    *u = return_value_acos$4 / 6.283185e+0;
  }
}

// c::xyztospr
// file ../src/coordsys.h line 9
void xyztospr(struct anon$0 pnt, double *u, double *v)
{
  double r1;
  double phi;
  double theta;
  r1=sqrt(pnt.x * pnt.x + pnt.y * pnt.y + pnt.z * pnt.z);
  phi=acos(-pnt.y / r1);
  *v = phi / 3.141593e+0;
  double return_value_sin$1;
  return_value_sin$1=sin(phi);
  double return_value_acos$2;
  return_value_acos$2=acos((pnt.x / r1) / return_value_sin$1);
  theta = return_value_acos$2 / 6.283185e+0;
  if(pnt.z > 0.000000)
    *u = theta;

  else
    *u = (double)1 - theta;
}

