/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is true */

#line 213 "/usr/lib/gcc/x86_64-linux-gnu/4.7/include/stddef.h"
typedef unsigned long size_t;
#line 140 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 141 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 40 "/usr/lib/gcc/x86_64-linux-gnu/4.7/include/stdarg.h"
typedef __builtin_va_list __gnuc_va_list;
#line 155 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 161 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 246 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 316 "/usr/include/libio.h"
typedef struct _IO_FILE _IO_FILE;
#line 325 "/usr/lib/gcc/x86_64-linux-gnu/4.7/include/stddef.h"
typedef int wchar_t;
#line 158 "src/mpeg2enc.h"
struct motion_data {
   int forw_hor_f_code ;
   int forw_vert_f_code ;
   int sxf ;
   int syf ;
   int back_hor_f_code ;
   int back_vert_f_code ;
   int sxb ;
   int syb ;
};
#line 212 "src/conform.c"
struct level_limits {
   int hor_f_code ;
   int vert_f_code ;
   int hor_size ;
   int vert_size ;
   int sample_rate ;
   int bit_rate ;
   int vbv_buffer_size ;
};
#line 153 "/usr/include/x86_64-linux-gnu/bits/mathinline.h"
union __anonunion___u_3 {
   long double __l ;
   int __i[3] ;
};
#line 153 "/usr/include/x86_64-linux-gnu/bits/mathinline.h"
union __anonunion___u_8 {
   long double __l ;
   int __i[3] ;
};
#line 153 "/usr/include/x86_64-linux-gnu/bits/mathinline.h"
union __anonunion___u_8___0 {
   long double __l ;
   int __i[3] ;
};
#line 143 "src/mpeg2enc.h"
struct mbinfo {
   int mb_type ;
   int motion_type ;
   int dct_type ;
   int mquant ;
   int cbp ;
   int skipped ;
   int MV[2][2][2] ;
   int mv_field_sel[2][2] ;
   int dmvector[2] ;
   double act ;
   int var ;
};
#line 153 "/usr/include/x86_64-linux-gnu/bits/mathinline.h"
union __anonunion___u_8___1 {
   long double __l ;
   int __i[3] ;
};
#line 60 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef unsigned long pthread_t;
#line 63 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
union pthread_attr_t {
   char __size[56] ;
   long __align ;
};
#line 69 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef union pthread_attr_t pthread_attr_t;
#line 202 "src/mpeg2enc.h"
struct Data_Args {
   unsigned char *oldorg ;
   unsigned char *neworg ;
   unsigned char *oldref ;
   unsigned char *newref ;
   unsigned char *cur ;
   unsigned char *curref ;
   int sxf ;
   int syf ;
   int sxb ;
   int syb ;
   struct mbinfo *mbi ;
   int secondfield ;
   int ipflag ;
   unsigned char **reff ;
   unsigned char **refb ;
   unsigned char **pd_cur ;
   unsigned char *pred ;
   unsigned char *dte_cur ;
   unsigned char **trfm_cur ;
   short **blocks ;
   int prev_mquant ;
   unsigned char **itrfm_cur ;
};
#line 217
struct ME_Args;
#line 217
struct Pred_Args;
#line 217
struct DTE_Args;
#line 217
struct Trfm_Args;
#line 217
struct IQunt_Args;
#line 217
struct PPict_Args;
#line 217 "src/mpeg2enc.h"
struct thread_data {
   struct ME_Args *me_ptr ;
   struct Pred_Args *pd_ptr ;
   struct DTE_Args *dte_ptr ;
   struct Trfm_Args *trfm_ptr ;
   struct IQunt_Args *iqt_ptr ;
   struct Trfm_Args *itrfm_ptr ;
   struct PPict_Args *pp_ptr ;
   struct Data_Args *data_ptr ;
   int s_height ;
   int e_height ;
   int s_mbh ;
   int e_mbh ;
   int mode ;
   int id ;
   int pp_smbh ;
   int pp_embh ;
};
#line 83 "src/vlc.h"
struct __anonstruct_VLCtable_6 {
   unsigned char code ;
   char len ;
};
#line 83 "src/vlc.h"
typedef struct __anonstruct_VLCtable_6 VLCtable;
#line 90 "src/vlc.h"
struct __anonstruct_sVLCtable_7 {
   unsigned short code ;
   char len ;
};
#line 90 "src/vlc.h"
typedef struct __anonstruct_sVLCtable_7 sVLCtable;
#line 153 "/usr/include/x86_64-linux-gnu/bits/mathinline.h"
union __anonunion___u_8___2 {
   long double __l ;
   int __i[3] ;
};
/* compiler builtin: 
   int __builtin___vsprintf_chk(char * , int  , unsigned long  , char const   * ,
                                __builtin_va_list  ) ;  */
/* compiler builtin: 
   unsigned long __builtin_object_size(void * , int  ) ;  */
/* compiler builtin: 
   int __builtin___sprintf_chk(char * , int  , unsigned long  , char const   *  , ...) ;  */
/* compiler builtin: 
   int __builtin___snprintf_chk(char * , unsigned long  , int  , unsigned long  ,
                                char const   *  , ...) ;  */
/* compiler builtin: 
   int __builtin___vsnprintf_chk(char * , unsigned long  , int  , unsigned long  ,
                                 char const   * , __builtin_va_list  ) ;  */
/* compiler builtin: 
   long __builtin_expect(long  , long  ) ;  */
/* compiler builtin: 
   int __builtin_va_arg_pack(void) ;  */
#line 1 "conform.o"
#pragma merger("0","/tmp/cil-bMrEuybu.i","-O4")
#line 392 "/usr/include/libio.h"
extern int __uflow(_IO_FILE * ) ;
#line 393
extern int __overflow(_IO_FILE * , int  ) ;
#line 435
extern int _IO_getc(_IO_FILE *__fp ) ;
#line 436
extern int _IO_putc(int __c , _IO_FILE *__fp ) ;
#line 168 "/usr/include/stdio.h"
extern struct _IO_FILE *stdin ;
#line 169
extern struct _IO_FILE *stdout ;
#line 170
extern struct _IO_FILE *stderr ;
#line 356
__inline extern int ( __attribute__((__artificial__, __always_inline__)) fprintf)(FILE * __restrict  __stream ,
                                                                                  char const   * __restrict  __fmt 
                                                                                  , ...) ;
#line 362
__inline extern int ( __attribute__((__artificial__, __always_inline__)) printf)(char const   * __restrict  __fmt 
                                                                                 , ...) ;
#line 364
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__, __artificial__,
__always_inline__)) sprintf)(char * __restrict  __s , char const   * __restrict  __fmt 
                             , ...) ;
#line 371
__inline extern int ( __attribute__((__artificial__, __always_inline__)) vfprintf)(FILE * __restrict  __stream ,
                                                                                   char const   * __restrict  __fmt ,
                                                                                   __gnuc_va_list __ap ) ;
#line 377
__inline extern int ( __attribute__((__artificial__, __always_inline__)) vprintf)(char const   * __restrict  __fmt ,
                                                                                  __gnuc_va_list __ap ) ;
#line 379
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__, __artificial__,
__always_inline__)) vsprintf)(char * __restrict  __s , char const   * __restrict  __fmt ,
                              __gnuc_va_list __ap ) ;
#line 386
__inline extern  __attribute__((__nothrow__)) int ( /* format attribute */ __attribute__((__leaf__,
__artificial__, __always_inline__)) snprintf)(char * __restrict  __s , size_t __n ,
                                              char const   * __restrict  __fmt  , ...) ;
#line 390
__inline extern  __attribute__((__nothrow__)) int ( /* format attribute */ __attribute__((__leaf__,
__artificial__, __always_inline__)) vsnprintf)(char * __restrict  __s , size_t __n ,
                                               char const   * __restrict  __fmt ,
                                               __gnuc_va_list __ap ) ;
#line 412
__inline extern int ( /* format attribute */ __attribute__((__artificial__, __always_inline__)) vdprintf)(int __fd ,
                                                                                                          char const   * __restrict  __fmt ,
                                                                                                          __gnuc_va_list __ap ) ;
#line 415
__inline extern int ( /* format attribute */ __attribute__((__artificial__, __always_inline__)) dprintf)(int __fd ,
                                                                                                         char const   * __restrict  __fmt 
                                                                                                         , ...) ;
#line 538
__inline extern int getchar(void) ;
#line 550
__inline extern int getc_unlocked(FILE *__fp ) ;
#line 551
__inline extern int getchar_unlocked(void) ;
#line 561
__inline extern int fgetc_unlocked(FILE *__fp ) ;
#line 580
__inline extern int putchar(int __c ) ;
#line 594
__inline extern int fputc_unlocked(int __c , FILE *__stream ) ;
#line 602
__inline extern int putc_unlocked(int __c , FILE *__stream ) ;
#line 603
__inline extern int putchar_unlocked(int __c ) ;
#line 622
__inline extern char *( __attribute__((__warn_unused_result__, __artificial__, __always_inline__)) fgets)(char * __restrict  __s ,
                                                                                                          int __n ,
                                                                                                          FILE * __restrict  __stream ) ;
#line 638
__inline extern char *( __attribute__((__warn_unused_result__, __artificial__, __always_inline__)) gets)(char *__str )  __attribute__((__deprecated__)) ;
#line 709
__inline extern size_t ( __attribute__((__warn_unused_result__, __artificial__, __always_inline__)) fread)(void * __restrict  __ptr ,
                                                                                                           size_t __size ,
                                                                                                           size_t __n ,
                                                                                                           FILE * __restrict  __stream ) ;
#line 737
__inline extern size_t ( __attribute__((__warn_unused_result__, __artificial__, __always_inline__)) fread_unlocked)(void * __restrict  __ptr ,
                                                                                                                    size_t __size ,
                                                                                                                    size_t __n ,
                                                                                                                    FILE * __restrict  __stream ) ;
#line 836
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__warn_unused_result__,
__leaf__)) feof_unlocked)(FILE *__stream ) ;
#line 837
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__warn_unused_result__,
__leaf__)) ferror_unlocked)(FILE *__stream ) ;
#line 43 "/usr/include/x86_64-linux-gnu/bits/stdio.h"
__inline extern int getchar(void) 
{ 
  int tmp ;

  {
#line 46
  tmp = _IO_getc(stdin);
#line 46
  return (tmp);
}
}
#line 52 "/usr/include/x86_64-linux-gnu/bits/stdio.h"
__inline extern int fgetc_unlocked(FILE *__fp ) 
{ 
  int tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  long tmp___3 ;

  {
#line 55
  tmp___3 = __builtin_expect((long )((unsigned long )__fp->_IO_read_ptr >= (unsigned long )__fp->_IO_read_end),
                             0L);
#line 55
  if (tmp___3) {
#line 55
    tmp___0 = __uflow(__fp);
#line 55
    tmp___2 = tmp___0;
  } else {
#line 55
    tmp___1 = __fp->_IO_read_ptr;
#line 55
    (__fp->_IO_read_ptr) ++;
#line 55
    tmp___2 = (int )*((unsigned char *)tmp___1);
  }
#line 55
  return (tmp___2);
}
}
#line 69 "/usr/include/x86_64-linux-gnu/bits/stdio.h"
__inline extern int getchar_unlocked(void) 
{ 
  int tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  long tmp___3 ;

  {
#line 72
  tmp___3 = __builtin_expect((long )((unsigned long )stdin->_IO_read_ptr >= (unsigned long )stdin->_IO_read_end),
                             0L);
#line 72
  if (tmp___3) {
#line 72
    tmp___0 = __uflow(stdin);
#line 72
    tmp___2 = tmp___0;
  } else {
#line 72
    tmp___1 = stdin->_IO_read_ptr;
#line 72
    (stdin->_IO_read_ptr) ++;
#line 72
    tmp___2 = (int )*((unsigned char *)tmp___1);
  }
#line 72
  return (tmp___2);
}
}
#line 78 "/usr/include/x86_64-linux-gnu/bits/stdio.h"
__inline extern int putchar(int __c ) 
{ 
  int tmp ;

  {
#line 81
  tmp = _IO_putc(__c, stdout);
#line 81
  return (tmp);
}
}
#line 87 "/usr/include/x86_64-linux-gnu/bits/stdio.h"
__inline extern int fputc_unlocked(int __c , FILE *__stream ) 
{ 
  int tmp___0 ;
  char *tmp___1 ;
  char tmp___2 ;
  int tmp___3 ;
  long tmp___4 ;

  {
#line 90
  tmp___4 = __builtin_expect((long )((unsigned long )__stream->_IO_write_ptr >= (unsigned long )__stream->_IO_write_end),
                             0L);
#line 90
  if (tmp___4) {
#line 90
    tmp___0 = __overflow(__stream, (int )((unsigned char )__c));
#line 90
    tmp___3 = tmp___0;
  } else {
#line 90
    tmp___1 = __stream->_IO_write_ptr;
#line 90
    (__stream->_IO_write_ptr) ++;
#line 90
    tmp___2 = (char )__c;
#line 90
    *tmp___1 = tmp___2;
#line 90
    tmp___3 = (int )((unsigned char )tmp___2);
  }
#line 90
  return (tmp___3);
}
}
#line 104 "/usr/include/x86_64-linux-gnu/bits/stdio.h"
__inline extern int putchar_unlocked(int __c ) 
{ 
  int tmp___0 ;
  char *tmp___1 ;
  char tmp___2 ;
  int tmp___3 ;
  long tmp___4 ;

  {
#line 107
  tmp___4 = __builtin_expect((long )((unsigned long )stdout->_IO_write_ptr >= (unsigned long )stdout->_IO_write_end),
                             0L);
#line 107
  if (tmp___4) {
#line 107
    tmp___0 = __overflow(stdout, (int )((unsigned char )__c));
#line 107
    tmp___3 = tmp___0;
  } else {
#line 107
    tmp___1 = stdout->_IO_write_ptr;
#line 107
    (stdout->_IO_write_ptr) ++;
#line 107
    tmp___2 = (char )__c;
#line 107
    *tmp___1 = tmp___2;
#line 107
    tmp___3 = (int )((unsigned char )tmp___2);
  }
#line 107
  return (tmp___3);
}
}
#line 124
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__warn_unused_result__,
__leaf__)) feof_unlocked)(FILE *__stream ) ;
#line 124 "/usr/include/x86_64-linux-gnu/bits/stdio.h"
__inline extern int ( __attribute__((__warn_unused_result__, __leaf__)) feof_unlocked)(FILE *__stream ) 
{ 


  {
#line 127
  return ((__stream->_flags & 16) != 0);
}
}
#line 131
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__warn_unused_result__,
__leaf__)) ferror_unlocked)(FILE *__stream ) ;
#line 131 "/usr/include/x86_64-linux-gnu/bits/stdio.h"
__inline extern int ( __attribute__((__warn_unused_result__, __leaf__)) ferror_unlocked)(FILE *__stream ) 
{ 


  {
#line 134
  return ((__stream->_flags & 32) != 0);
}
}
#line 30 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__, __artificial__,
__always_inline__)) sprintf)(char * __restrict  __s , char const   * __restrict  __fmt 
                             , ...) ;
#line 30 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern int ( __attribute__((__leaf__, __artificial__, __always_inline__)) sprintf)(char * __restrict  __s ,
                                                                                            char const   * __restrict  __fmt 
                                                                                            , ...) 
{ 
  unsigned long tmp ;
  int tmp___0 ;

  {
#line 33
  tmp = __builtin_object_size((void *)__s, 1);
#line 33
  tmp___0 = __builtin___sprintf_chk((char *)__s, 1, tmp, (char const   *)__fmt, __builtin_va_arg_pack());
#line 33
  return (tmp___0);
}
}
#line 42
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__, __artificial__,
__always_inline__)) vsprintf)(char * __restrict  __s , char const   * __restrict  __fmt ,
                              __gnuc_va_list __ap ) ;
#line 42 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern int ( __attribute__((__leaf__, __artificial__, __always_inline__)) vsprintf)(char * __restrict  __s ,
                                                                                             char const   * __restrict  __fmt ,
                                                                                             __gnuc_va_list __ap ) 
{ 
  unsigned long tmp ;
  int tmp___0 ;

  {
#line 46
  tmp = __builtin_object_size((void *)__s, 1);
#line 46
  tmp___0 = __builtin___vsprintf_chk((char *)__s, 1, tmp, (char const   *)__fmt, __ap);
#line 46
  return (tmp___0);
}
}
#line 60
__inline extern  __attribute__((__nothrow__)) int ( /* format attribute */ __attribute__((__leaf__,
__artificial__, __always_inline__)) snprintf)(char * __restrict  __s , size_t __n ,
                                              char const   * __restrict  __fmt  , ...) ;
#line 60 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern int ( /* format attribute */ __attribute__((__leaf__, __artificial__,
__always_inline__)) snprintf)(char * __restrict  __s , size_t __n , char const   * __restrict  __fmt 
                              , ...) 
{ 
  unsigned long tmp ;
  int tmp___0 ;

  {
#line 64
  tmp = __builtin_object_size((void *)__s, 1);
#line 64
  tmp___0 = __builtin___snprintf_chk((char *)__s, __n, 1, tmp, (char const   *)__fmt,
                                     __builtin_va_arg_pack());
#line 64
  return (tmp___0);
}
}
#line 73
__inline extern  __attribute__((__nothrow__)) int ( /* format attribute */ __attribute__((__leaf__,
__artificial__, __always_inline__)) vsnprintf)(char * __restrict  __s , size_t __n ,
                                               char const   * __restrict  __fmt ,
                                               __gnuc_va_list __ap ) ;
#line 73 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern int ( /* format attribute */ __attribute__((__leaf__, __artificial__,
__always_inline__)) vsnprintf)(char * __restrict  __s , size_t __n , char const   * __restrict  __fmt ,
                               __gnuc_va_list __ap ) 
{ 
  unsigned long tmp ;
  int tmp___0 ;

  {
#line 77
  tmp = __builtin_object_size((void *)__s, 1);
#line 77
  tmp___0 = __builtin___vsnprintf_chk((char *)__s, __n, 1, tmp, (char const   *)__fmt,
                                      __ap);
#line 77
  return (tmp___0);
}
}
#line 85
extern int __fprintf_chk(FILE * __restrict  __stream , int __flag , char const   * __restrict  __format 
                         , ...) ;
#line 87
extern int __printf_chk(int __flag , char const   * __restrict  __format  , ...) ;
#line 88
extern int __vfprintf_chk(FILE * __restrict  __stream , int __flag , char const   * __restrict  __format ,
                          __gnuc_va_list __ap ) ;
#line 94 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern int ( __attribute__((__artificial__, __always_inline__)) fprintf)(FILE * __restrict  __stream ,
                                                                                  char const   * __restrict  __fmt 
                                                                                  , ...) 
{ 
  int tmp ;

  {
#line 97
  tmp = __fprintf_chk(__stream, 1, __fmt, __builtin_va_arg_pack());
#line 97
  return (tmp);
}
}
#line 101 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern int ( __attribute__((__artificial__, __always_inline__)) printf)(char const   * __restrict  __fmt 
                                                                                 , ...) 
{ 
  int tmp ;

  {
#line 104
  tmp = __printf_chk(1, __fmt, __builtin_va_arg_pack());
#line 104
  return (tmp);
}
}
#line 113 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern int ( __attribute__((__artificial__, __always_inline__)) vprintf)(char const   * __restrict  __fmt ,
                                                                                  __gnuc_va_list __ap ) 
{ 
  int tmp ;

  {
#line 117
  tmp = __vfprintf_chk((FILE * __restrict  )stdout, 1, __fmt, __ap);
#line 117
  return (tmp);
}
}
#line 123 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern int ( __attribute__((__artificial__, __always_inline__)) vfprintf)(FILE * __restrict  __stream ,
                                                                                   char const   * __restrict  __fmt ,
                                                                                   __gnuc_va_list __ap ) 
{ 
  int tmp ;

  {
#line 127
  tmp = __vfprintf_chk(__stream, 1, __fmt, __ap);
#line 127
  return (tmp);
}
}
#line 131
extern int ( /* format attribute */  __dprintf_chk)(int __fd , int __flag , char const   * __restrict  __fmt 
                                                    , ...) ;
#line 133
extern int ( /* format attribute */  __vdprintf_chk)(int __fd , int __flag , char const   * __restrict  __fmt ,
                                                     __gnuc_va_list __arg ) ;
#line 138 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern int ( /* format attribute */ __attribute__((__artificial__, __always_inline__)) dprintf)(int __fd ,
                                                                                                         char const   * __restrict  __fmt 
                                                                                                         , ...) 
{ 
  int tmp ;

  {
#line 141
  tmp = __dprintf_chk(__fd, 1, __fmt, __builtin_va_arg_pack());
#line 141
  return (tmp);
}
}
#line 149 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern int ( /* format attribute */ __attribute__((__artificial__, __always_inline__)) vdprintf)(int __fd ,
                                                                                                          char const   * __restrict  __fmt ,
                                                                                                          __gnuc_va_list __ap ) 
{ 
  int tmp ;

  {
#line 152
  tmp = __vdprintf_chk(__fd, 1, __fmt, __ap);
#line 152
  return (tmp);
}
}
#line 227
extern char *( __attribute__((__warn_unused_result__)) __gets_chk)(char *__str , size_t  ) ;
#line 228
extern char *( __attribute__((__warn_unused_result__)) __gets_warn)(char *__str )  __asm__("gets") __attribute__((__warning__("please use fgets or getline instead, gets can\'t specify buffer size"))) ;
#line 232
__inline extern char *( __attribute__((__warn_unused_result__, __artificial__, __always_inline__)) gets)(char *__str )  __attribute__((__deprecated__)) ;
#line 232 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern char *( __attribute__((__warn_unused_result__, __artificial__, __always_inline__)) gets)(char *__str ) 
{ 
  unsigned long tmp ;
  char *tmp___0 ;
  unsigned long tmp___1 ;
  char *tmp___2 ;

  {
#line 235
  tmp___1 = __builtin_object_size((void *)__str, 1);
#line 235
  if (tmp___1 != 0xffffffffffffffffUL) {
#line 236
    tmp = __builtin_object_size((void *)__str, 1);
#line 236
    tmp___0 = __gets_chk(__str, tmp);
#line 236
    return (tmp___0);
  }
#line 237
  tmp___2 = __gets_warn(__str);
#line 237
  return (tmp___2);
}
}
#line 241
extern char *( __attribute__((__warn_unused_result__)) __fgets_chk)(char * __restrict  __s ,
                                                                    size_t __size ,
                                                                    int __n , FILE * __restrict  __stream ) ;
#line 243
extern char *( __attribute__((__warn_unused_result__)) __fgets_alias)(char * __restrict  __s ,
                                                                      int __n , FILE * __restrict  __stream )  __asm__("fgets")  ;
#line 246
extern char *( __attribute__((__warn_unused_result__)) __fgets_chk_warn)(char * __restrict  __s ,
                                                                         size_t __size ,
                                                                         int __n ,
                                                                         FILE * __restrict  __stream )  __asm__("__fgets_chk") __attribute__((__warning__("fgets called with bigger size than length of destination buffer"))) ;
#line 252 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern char *( __attribute__((__warn_unused_result__, __artificial__, __always_inline__)) fgets)(char * __restrict  __s ,
                                                                                                          int __n ,
                                                                                                          FILE * __restrict  __stream ) 
{ 
  unsigned long tmp ;
  char *tmp___0 ;
  unsigned long tmp___1 ;
  char *tmp___2 ;
  unsigned long tmp___3 ;
  unsigned long tmp___4 ;
  char *tmp___5 ;

  {
#line 255
  tmp___4 = __builtin_object_size((void *)__s, 1);
#line 255
  if (tmp___4 != 0xffffffffffffffffUL) {
#line 258
    tmp = __builtin_object_size((void *)__s, 1);
#line 258
    tmp___0 = __fgets_chk(__s, tmp, __n, __stream);
#line 258
    return (tmp___0);
#line 260
    tmp___3 = __builtin_object_size((void *)__s, 1);
#line 260
    if ((size_t )__n > tmp___3) {
#line 261
      tmp___1 = __builtin_object_size((void *)__s, 1);
#line 261
      tmp___2 = __fgets_chk_warn(__s, tmp___1, __n, __stream);
#line 261
      return (tmp___2);
    }
  }
#line 263
  tmp___5 = __fgets_alias(__s, __n, __stream);
#line 263
  return (tmp___5);
}
}
#line 266
extern size_t ( __attribute__((__warn_unused_result__)) __fread_chk)(void * __restrict  __ptr ,
                                                                     size_t __ptrlen ,
                                                                     size_t __size ,
                                                                     size_t __n ,
                                                                     FILE * __restrict  __stream ) ;
#line 269
extern size_t ( __attribute__((__warn_unused_result__)) __fread_alias)(void * __restrict  __ptr ,
                                                                       size_t __size ,
                                                                       size_t __n ,
                                                                       FILE * __restrict  __stream )  __asm__("fread")  ;
#line 273
extern size_t ( __attribute__((__warn_unused_result__)) __fread_chk_warn)(void * __restrict  __ptr ,
                                                                          size_t __ptrlen ,
                                                                          size_t __size ,
                                                                          size_t __n ,
                                                                          FILE * __restrict  __stream )  __asm__("__fread_chk") __attribute__((__warning__("fread called with bigger size * nmemb than length of destination buffer"))) ;
#line 281 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern size_t ( __attribute__((__warn_unused_result__, __artificial__, __always_inline__)) fread)(void * __restrict  __ptr ,
                                                                                                           size_t __size ,
                                                                                                           size_t __n ,
                                                                                                           FILE * __restrict  __stream ) 
{ 
  unsigned long tmp ;
  size_t tmp___0 ;
  unsigned long tmp___1 ;
  size_t tmp___2 ;
  unsigned long tmp___3 ;
  unsigned long tmp___4 ;
  size_t tmp___5 ;

  {
#line 285
  tmp___4 = __builtin_object_size((void *)__ptr, 0);
#line 285
  if (tmp___4 != 0xffffffffffffffffUL) {
#line 290
    tmp = __builtin_object_size((void *)__ptr, 0);
#line 290
    tmp___0 = __fread_chk(__ptr, tmp, __size, __n, __stream);
#line 290
    return (tmp___0);
#line 292
    tmp___3 = __builtin_object_size((void *)__ptr, 0);
#line 292
    if (__size * __n > tmp___3) {
#line 293
      tmp___1 = __builtin_object_size((void *)__ptr, 0);
#line 293
      tmp___2 = __fread_chk_warn(__ptr, tmp___1, __size, __n, __stream);
#line 293
      return (tmp___2);
    }
  }
#line 295
  tmp___5 = __fread_alias(__ptr, __size, __n, __stream);
#line 295
  return (tmp___5);
}
}
#line 327
extern size_t ( __attribute__((__warn_unused_result__)) __fread_unlocked_chk)(void * __restrict  __ptr ,
                                                                              size_t __ptrlen ,
                                                                              size_t __size ,
                                                                              size_t __n ,
                                                                              FILE * __restrict  __stream ) ;
#line 330
extern size_t ( __attribute__((__warn_unused_result__)) __fread_unlocked_alias)(void * __restrict  __ptr ,
                                                                                size_t __size ,
                                                                                size_t __n ,
                                                                                FILE * __restrict  __stream )  __asm__("fread_unlocked")  ;
#line 334
extern size_t ( __attribute__((__warn_unused_result__)) __fread_unlocked_chk_warn)(void * __restrict  __ptr ,
                                                                                   size_t __ptrlen ,
                                                                                   size_t __size ,
                                                                                   size_t __n ,
                                                                                   FILE * __restrict  __stream )  __asm__("__fread_unlocked_chk") __attribute__((__warning__("fread_unlocked called with bigger size * nmemb than length of destination buffer"))) ;
#line 342 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern size_t ( __attribute__((__warn_unused_result__, __artificial__, __always_inline__)) fread_unlocked)(void * __restrict  __ptr ,
                                                                                                                    size_t __size ,
                                                                                                                    size_t __n ,
                                                                                                                    FILE * __restrict  __stream ) 
{ 
  unsigned long tmp ;
  size_t tmp___0 ;
  unsigned long tmp___1 ;
  size_t tmp___2 ;
  unsigned long tmp___3 ;
  unsigned long tmp___4 ;
  size_t tmp___11 ;

  {
#line 346
  tmp___4 = __builtin_object_size((void *)__ptr, 0);
#line 346
  if (tmp___4 != 0xffffffffffffffffUL) {
#line 351
    tmp = __builtin_object_size((void *)__ptr, 0);
#line 351
    tmp___0 = __fread_unlocked_chk(__ptr, tmp, __size, __n, __stream);
#line 351
    return (tmp___0);
#line 354
    tmp___3 = __builtin_object_size((void *)__ptr, 0);
#line 354
    if (__size * __n > tmp___3) {
#line 355
      tmp___1 = __builtin_object_size((void *)__ptr, 0);
#line 355
      tmp___2 = __fread_unlocked_chk_warn(__ptr, tmp___1, __size, __n, __stream);
#line 355
      return (tmp___2);
    }
  }
#line 380
  tmp___11 = __fread_unlocked_alias(__ptr, __size, __n, __stream);
#line 380
  return (tmp___11);
}
}
#line 144 "/usr/include/stdlib.h"
__inline extern  __attribute__((__nothrow__)) double ( __attribute__((__warn_unused_result__,
__nonnull__(1), __leaf__)) atof)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 147
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__warn_unused_result__,
__nonnull__(1), __leaf__)) atoi)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 150
__inline extern  __attribute__((__nothrow__)) long ( __attribute__((__warn_unused_result__,
__nonnull__(1), __leaf__)) atol)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 157
__inline extern  __attribute__((__nothrow__)) long long ( __attribute__((__warn_unused_result__,
__nonnull__(1), __leaf__)) atoll)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 164
extern  __attribute__((__nothrow__)) double ( __attribute__((__nonnull__(1), __leaf__)) strtod)(char const   * __restrict  __nptr ,
                                                                                                char ** __restrict  __endptr ) ;
#line 183
extern  __attribute__((__nothrow__)) long ( __attribute__((__nonnull__(1), __leaf__)) strtol)(char const   * __restrict  __nptr ,
                                                                                              char ** __restrict  __endptr ,
                                                                                              int __base ) ;
#line 209
extern  __attribute__((__nothrow__)) long long ( __attribute__((__nonnull__(1), __leaf__)) strtoll)(char const   * __restrict  __nptr ,
                                                                                                    char ** __restrict  __endptr ,
                                                                                                    int __base ) ;
#line 277
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__warn_unused_result__,
__nonnull__(1), __leaf__)) atoi)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 277 "/usr/include/stdlib.h"
__inline extern int ( __attribute__((__warn_unused_result__, __nonnull__(1), __leaf__)) atoi)(char const   *__nptr ) 
{ 
  long tmp ;

  {
#line 280
  tmp = strtol((char const   * __restrict  )__nptr, (char ** __restrict  )((char **)((void *)0)),
               10);
#line 280
  return ((int )tmp);
}
}
#line 282
__inline extern  __attribute__((__nothrow__)) long ( __attribute__((__warn_unused_result__,
__nonnull__(1), __leaf__)) atol)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 282 "/usr/include/stdlib.h"
__inline extern long ( __attribute__((__warn_unused_result__, __nonnull__(1), __leaf__)) atol)(char const   *__nptr ) 
{ 
  long tmp ;

  {
#line 285
  tmp = strtol((char const   * __restrict  )__nptr, (char ** __restrict  )((char **)((void *)0)),
               10);
#line 285
  return (tmp);
}
}
#line 291
__inline extern  __attribute__((__nothrow__)) long long ( __attribute__((__warn_unused_result__,
__nonnull__(1), __leaf__)) atoll)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 291 "/usr/include/stdlib.h"
__inline extern long long ( __attribute__((__warn_unused_result__, __nonnull__(1),
__leaf__)) atoll)(char const   *__nptr ) 
{ 
  long long tmp ;

  {
#line 294
  tmp = strtoll((char const   * __restrict  )__nptr, (char ** __restrict  )((char **)((void *)0)),
                10);
#line 294
  return (tmp);
}
}
#line 32 "/usr/include/x86_64-linux-gnu/sys/sysmacros.h"
__inline extern  __attribute__((__nothrow__)) unsigned int ( __attribute__((__leaf__)) gnu_dev_major)(unsigned long long __dev )  __attribute__((__const__)) ;
#line 35
__inline extern  __attribute__((__nothrow__)) unsigned int ( __attribute__((__leaf__)) gnu_dev_minor)(unsigned long long __dev )  __attribute__((__const__)) ;
#line 38
__inline extern  __attribute__((__nothrow__)) unsigned long long ( __attribute__((__leaf__)) gnu_dev_makedev)(unsigned int __major ,
                                                                                                              unsigned int __minor )  __attribute__((__const__)) ;
#line 43
__inline extern  __attribute__((__nothrow__)) unsigned int ( __attribute__((__leaf__)) gnu_dev_major)(unsigned long long __dev )  __attribute__((__const__)) ;
#line 43 "/usr/include/x86_64-linux-gnu/sys/sysmacros.h"
__inline extern unsigned int ( __attribute__((__leaf__)) gnu_dev_major)(unsigned long long __dev ) 
{ 


  {
#line 46
  return ((unsigned int )(((__dev >> 8) & 4095ULL) | (unsigned long long )((unsigned int )(__dev >> 32) & 4294963200U)));
}
}
#line 49
__inline extern  __attribute__((__nothrow__)) unsigned int ( __attribute__((__leaf__)) gnu_dev_minor)(unsigned long long __dev )  __attribute__((__const__)) ;
#line 49 "/usr/include/x86_64-linux-gnu/sys/sysmacros.h"
__inline extern unsigned int ( __attribute__((__leaf__)) gnu_dev_minor)(unsigned long long __dev ) 
{ 


  {
#line 52
  return ((unsigned int )((__dev & 255ULL) | (unsigned long long )((unsigned int )(__dev >> 12) & 4294967040U)));
}
}
#line 55
__inline extern  __attribute__((__nothrow__)) unsigned long long ( __attribute__((__leaf__)) gnu_dev_makedev)(unsigned int __major ,
                                                                                                              unsigned int __minor )  __attribute__((__const__)) ;
#line 55 "/usr/include/x86_64-linux-gnu/sys/sysmacros.h"
__inline extern unsigned long long ( __attribute__((__leaf__)) gnu_dev_makedev)(unsigned int __major ,
                                                                                unsigned int __minor ) 
{ 


  {
#line 58
  return (((unsigned long long )((__minor & 255U) | ((__major & 4095U) << 8)) | ((unsigned long long )(__minor & 4294967040U) << 12)) | ((unsigned long long )(__major & 4294963200U) << 32));
}
}
#line 733 "/usr/include/stdlib.h"
__inline extern  __attribute__((__nothrow__)) char *( __attribute__((__warn_unused_result__,
__leaf__, __artificial__, __always_inline__)) realpath)(char const   * __restrict  __name ,
                                                        char * __restrict  __resolved ) ;
#line 866
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__warn_unused_result__,
__leaf__, __artificial__, __always_inline__)) wctomb)(char *__s , wchar_t __wchar ) ;
#line 870
__inline extern  __attribute__((__nothrow__)) size_t ( __attribute__((__leaf__, __artificial__,
__always_inline__)) mbstowcs)(wchar_t * __restrict  __dst , char const   * __restrict  __src ,
                              size_t __len ) ;
#line 873
__inline extern  __attribute__((__nothrow__)) size_t ( __attribute__((__leaf__, __artificial__,
__always_inline__)) wcstombs)(char * __restrict  __dst , wchar_t const   * __restrict  __src ,
                              size_t __len ) ;
#line 25 "/usr/include/x86_64-linux-gnu/bits/stdlib-float.h"
__inline extern  __attribute__((__nothrow__)) double ( __attribute__((__warn_unused_result__,
__nonnull__(1), __leaf__)) atof)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 25 "/usr/include/x86_64-linux-gnu/bits/stdlib-float.h"
__inline extern double ( __attribute__((__warn_unused_result__, __nonnull__(1), __leaf__)) atof)(char const   *__nptr ) 
{ 
  double tmp ;

  {
#line 28
  tmp = strtod((char const   * __restrict  )__nptr, (char ** __restrict  )((char **)((void *)0)));
#line 28
  return (tmp);
}
}
#line 23 "/usr/include/x86_64-linux-gnu/bits/stdlib.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__warn_unused_result__,
__leaf__)) __realpath_chk)(char const   * __restrict  __name , char * __restrict  __resolved ,
                           size_t __resolvedlen ) ;
#line 26
extern  __attribute__((__nothrow__)) char *( __attribute__((__warn_unused_result__,
__leaf__)) __realpath_alias)(char const   * __restrict  __name , char * __restrict  __resolved )  __asm__("realpath")  ;
#line 36
__inline extern  __attribute__((__nothrow__)) char *( __attribute__((__warn_unused_result__,
__leaf__, __artificial__, __always_inline__)) realpath)(char const   * __restrict  __name ,
                                                        char * __restrict  __resolved ) ;
#line 36 "/usr/include/x86_64-linux-gnu/bits/stdlib.h"
__inline extern char *( __attribute__((__warn_unused_result__, __leaf__, __artificial__,
__always_inline__)) realpath)(char const   * __restrict  __name , char * __restrict  __resolved ) 
{ 
  unsigned long tmp ;
  char *tmp___0 ;
  unsigned long tmp___1 ;
  char *tmp___2 ;

  {
#line 39
  tmp___1 = __builtin_object_size((void *)__resolved, 1);
#line 39
  if (tmp___1 != 0xffffffffffffffffUL) {
#line 45
    tmp = __builtin_object_size((void *)__resolved, 1);
#line 45
    tmp___0 = __realpath_chk(__name, __resolved, tmp);
#line 45
    return (tmp___0);
  }
#line 48
  tmp___2 = __realpath_alias(__name, __resolved);
#line 48
  return (tmp___2);
}
}
#line 52
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2), __leaf__)) __ptsname_r_chk)(int __fd ,
                                                                                                      char *__buf ,
                                                                                                      size_t __buflen ,
                                                                                                      size_t __nreal ) ;
#line 54
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2), __leaf__)) __ptsname_r_alias)(int __fd ,
                                                                                                        char *__buf ,
                                                                                                        size_t __buflen )  __asm__("ptsname_r")  ;
#line 57
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2), __leaf__)) __ptsname_r_chk_warn)(int __fd ,
                                                                                                           char *__buf ,
                                                                                                           size_t __buflen ,
                                                                                                           size_t __nreal )  __asm__("__ptsname_r_chk") __attribute__((__warning__("ptsname_r called with buflen bigger than size of buf"))) ;
#line 63
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__, __artificial__,
__always_inline__)) ptsname_r)(int __fd , char *__buf , size_t __buflen ) ;
#line 63 "/usr/include/x86_64-linux-gnu/bits/stdlib.h"
__inline extern int ( __attribute__((__leaf__, __artificial__, __always_inline__)) ptsname_r)(int __fd ,
                                                                                              char *__buf ,
                                                                                              size_t __buflen ) 
{ 
  unsigned long tmp ;
  int tmp___0 ;
  unsigned long tmp___1 ;
  int tmp___2 ;
  unsigned long tmp___3 ;
  unsigned long tmp___4 ;
  int tmp___5 ;

  {
#line 66
  tmp___4 = __builtin_object_size((void *)__buf, 1);
#line 66
  if (tmp___4 != 0xffffffffffffffffUL) {
#line 69
    tmp = __builtin_object_size((void *)__buf, 1);
#line 69
    tmp___0 = __ptsname_r_chk(__fd, __buf, __buflen, tmp);
#line 69
    return (tmp___0);
#line 70
    tmp___3 = __builtin_object_size((void *)__buf, 1);
#line 70
    if (__buflen > tmp___3) {
#line 71
      tmp___1 = __builtin_object_size((void *)__buf, 1);
#line 71
      tmp___2 = __ptsname_r_chk_warn(__fd, __buf, __buflen, tmp___1);
#line 71
      return (tmp___2);
    }
  }
#line 73
  tmp___5 = __ptsname_r_alias(__fd, __buf, __buflen);
#line 73
  return (tmp___5);
}
}
#line 77
extern  __attribute__((__nothrow__)) int ( __attribute__((__warn_unused_result__,
__leaf__)) __wctomb_chk)(char *__s , wchar_t __wchar , size_t __buflen ) ;
#line 79
extern  __attribute__((__nothrow__)) int ( __attribute__((__warn_unused_result__,
__leaf__)) __wctomb_alias)(char *__s , wchar_t __wchar )  __asm__("wctomb")  ;
#line 82
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__warn_unused_result__,
__leaf__, __artificial__, __always_inline__)) wctomb)(char *__s , wchar_t __wchar ) ;
#line 82 "/usr/include/x86_64-linux-gnu/bits/stdlib.h"
__inline extern int ( __attribute__((__warn_unused_result__, __leaf__, __artificial__,
__always_inline__)) wctomb)(char *__s , wchar_t __wchar ) 
{ 
  unsigned long tmp ;
  int tmp___0 ;
  unsigned long tmp___1 ;
  unsigned long tmp___2 ;
  int tmp___3 ;

  {
#line 92
  tmp___1 = __builtin_object_size((void *)__s, 1);
#line 92
  if (tmp___1 != 0xffffffffffffffffUL) {
#line 92
    tmp___2 = __builtin_object_size((void *)__s, 1);
#line 92
    if (16UL > tmp___2) {
#line 93
      tmp = __builtin_object_size((void *)__s, 1);
#line 93
      tmp___0 = __wctomb_chk(__s, __wchar, tmp);
#line 93
      return (tmp___0);
    }
  }
#line 94
  tmp___3 = __wctomb_alias(__s, __wchar);
#line 94
  return (tmp___3);
}
}
#line 98
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__leaf__)) __mbstowcs_chk)(wchar_t * __restrict  __dst ,
                                                                                        char const   * __restrict  __src ,
                                                                                        size_t __len ,
                                                                                        size_t __dstlen ) ;
#line 101
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__leaf__)) __mbstowcs_alias)(wchar_t * __restrict  __dst ,
                                                                                          char const   * __restrict  __src ,
                                                                                          size_t __len )  __asm__("mbstowcs")  ;
#line 105
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__leaf__)) __mbstowcs_chk_warn)(wchar_t * __restrict  __dst ,
                                                                                             char const   * __restrict  __src ,
                                                                                             size_t __len ,
                                                                                             size_t __dstlen )  __asm__("__mbstowcs_chk") __attribute__((__warning__("mbstowcs called with dst buffer smaller than len * sizeof (wchar_t)"))) ;
#line 112
__inline extern  __attribute__((__nothrow__)) size_t ( __attribute__((__leaf__, __artificial__,
__always_inline__)) mbstowcs)(wchar_t * __restrict  __dst , char const   * __restrict  __src ,
                              size_t __len ) ;
#line 112 "/usr/include/x86_64-linux-gnu/bits/stdlib.h"
__inline extern size_t ( __attribute__((__leaf__, __artificial__, __always_inline__)) mbstowcs)(wchar_t * __restrict  __dst ,
                                                                                                char const   * __restrict  __src ,
                                                                                                size_t __len ) 
{ 
  unsigned long tmp ;
  size_t tmp___0 ;
  unsigned long tmp___1 ;
  size_t tmp___2 ;
  unsigned long tmp___3 ;
  unsigned long tmp___4 ;
  size_t tmp___5 ;

  {
#line 116
  tmp___4 = __builtin_object_size((void *)__dst, 1);
#line 116
  if (tmp___4 != 0xffffffffffffffffUL) {
#line 119
    tmp = __builtin_object_size((void *)__dst, 1);
#line 119
    tmp___0 = __mbstowcs_chk(__dst, __src, __len, tmp / sizeof(wchar_t ));
#line 119
    return (tmp___0);
#line 122
    tmp___3 = __builtin_object_size((void *)__dst, 1);
#line 122
    if (__len > tmp___3 / sizeof(wchar_t )) {
#line 123
      tmp___1 = __builtin_object_size((void *)__dst, 1);
#line 123
      tmp___2 = __mbstowcs_chk_warn(__dst, __src, __len, tmp___1 / sizeof(wchar_t ));
#line 123
      return (tmp___2);
    }
  }
#line 126
  tmp___5 = __mbstowcs_alias(__dst, __src, __len);
#line 126
  return (tmp___5);
}
}
#line 130
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__leaf__)) __wcstombs_chk)(char * __restrict  __dst ,
                                                                                        wchar_t const   * __restrict  __src ,
                                                                                        size_t __len ,
                                                                                        size_t __dstlen ) ;
#line 133
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__leaf__)) __wcstombs_alias)(char * __restrict  __dst ,
                                                                                          wchar_t const   * __restrict  __src ,
                                                                                          size_t __len )  __asm__("wcstombs")  ;
#line 137
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__leaf__)) __wcstombs_chk_warn)(char * __restrict  __dst ,
                                                                                             wchar_t const   * __restrict  __src ,
                                                                                             size_t __len ,
                                                                                             size_t __dstlen )  __asm__("__wcstombs_chk") __attribute__((__warning__("wcstombs called with dst buffer smaller than len"))) ;
#line 143
__inline extern  __attribute__((__nothrow__)) size_t ( __attribute__((__leaf__, __artificial__,
__always_inline__)) wcstombs)(char * __restrict  __dst , wchar_t const   * __restrict  __src ,
                              size_t __len ) ;
#line 143 "/usr/include/x86_64-linux-gnu/bits/stdlib.h"
__inline extern size_t ( __attribute__((__leaf__, __artificial__, __always_inline__)) wcstombs)(char * __restrict  __dst ,
                                                                                                wchar_t const   * __restrict  __src ,
                                                                                                size_t __len ) 
{ 
  unsigned long tmp ;
  size_t tmp___0 ;
  unsigned long tmp___1 ;
  size_t tmp___2 ;
  unsigned long tmp___3 ;
  unsigned long tmp___4 ;
  size_t tmp___5 ;

  {
#line 147
  tmp___4 = __builtin_object_size((void *)__dst, 1);
#line 147
  if (tmp___4 != 0xffffffffffffffffUL) {
#line 150
    tmp = __builtin_object_size((void *)__dst, 1);
#line 150
    tmp___0 = __wcstombs_chk(__dst, __src, __len, tmp);
#line 150
    return (tmp___0);
#line 151
    tmp___3 = __builtin_object_size((void *)__dst, 1);
#line 151
    if (__len > tmp___3) {
#line 152
      tmp___1 = __builtin_object_size((void *)__dst, 1);
#line 152
      tmp___2 = __wcstombs_chk_warn(__dst, __src, __len, tmp___1);
#line 152
      return (tmp___2);
    }
  }
#line 154
  tmp___5 = __wcstombs_alias(__dst, __src, __len);
#line 154
  return (tmp___5);
}
}
#line 98 "src/global.h"
void range_checks(void) ;
#line 99
void profile_and_level_checks(void) ;
#line 122
void error(char *text ) ;
#line 357
struct motion_data *motion_data ;
#line 370
int quiet ;
#line 375
int M ;
#line 379
int mpeg1 ;
#line 380
int fieldpic ;
#line 384
int horizontal_size ;
#line 384
int vertical_size ;
#line 389
int aspectratio ;
#line 390
int frame_rate_code ;
#line 391
double frame_rate ;
#line 392
double bit_rate ;
#line 393
int vbv_buffer_size ;
#line 401
int profile ;
#line 401
int level ;
#line 402
int prog_seq ;
#line 403
int chroma_format ;
#line 409
int video_format ;
#line 410
int color_primaries ;
#line 411
int transfer_characteristics ;
#line 412
int matrix_coefficients ;
#line 413
int display_horizontal_size ;
#line 413
int display_vertical_size ;
#line 427
int dc_prec ;
#line 436
int repeatfirst ;
#line 88 "src/conform.c"
void range_checks(void) 
{ 
  int i ;

  {
#line 94
  if (horizontal_size < 1) {
#line 95
    error((char *)"horizontal_size must be between 1 and 16383");
  } else
#line 94
  if (horizontal_size > 16383) {
#line 95
    error((char *)"horizontal_size must be between 1 and 16383");
  }
#line 96
  if (mpeg1) {
#line 96
    if (horizontal_size > 4095) {
#line 97
      error((char *)"horizontal_size must be less than 4096 (MPEG-1)");
    }
  }
#line 98
  if ((horizontal_size & 4095) == 0) {
#line 99
    error((char *)"horizontal_size must not be a multiple of 4096");
  }
#line 100
  if (chroma_format != 3) {
#line 100
    if (horizontal_size % 2 != 0) {
#line 101
      error((char *)"horizontal_size must be a even (4:2:0 / 4:2:2)");
    }
  }
#line 103
  if (vertical_size < 1) {
#line 104
    error((char *)"vertical_size must be between 1 and 16383");
  } else
#line 103
  if (vertical_size > 16383) {
#line 104
    error((char *)"vertical_size must be between 1 and 16383");
  }
#line 105
  if (mpeg1) {
#line 105
    if (vertical_size > 4095) {
#line 106
      error((char *)"vertical size must be less than 4096 (MPEG-1)");
    }
  }
#line 107
  if ((vertical_size & 4095) == 0) {
#line 108
    error((char *)"vertical_size must not be a multiple of 4096");
  }
#line 109
  if (chroma_format == 1) {
#line 109
    if (vertical_size % 2 != 0) {
#line 110
      error((char *)"vertical_size must be a even (4:2:0)");
    }
  }
#line 111
  if (fieldpic) {
#line 113
    if (vertical_size % 2 != 0) {
#line 114
      error((char *)"vertical_size must be a even (field pictures)");
    }
#line 115
    if (chroma_format == 1) {
#line 115
      if (vertical_size % 4 != 0) {
#line 116
        error((char *)"vertical_size must be a multiple of 4 (4:2:0 field pictures)");
      }
    }
  }
#line 119
  if (mpeg1) {
#line 121
    if (aspectratio < 1) {
#line 122
      error((char *)"pel_aspect_ratio must be between 1 and 14 (MPEG-1)");
    } else
#line 121
    if (aspectratio > 14) {
#line 122
      error((char *)"pel_aspect_ratio must be between 1 and 14 (MPEG-1)");
    }
  } else
#line 126
  if (aspectratio < 1) {
#line 127
    error((char *)"aspect_ratio_information must be 1, 2, 3 or 4");
  } else
#line 126
  if (aspectratio > 4) {
#line 127
    error((char *)"aspect_ratio_information must be 1, 2, 3 or 4");
  }
#line 130
  if (frame_rate_code < 1) {
#line 131
    error((char *)"frame_rate code must be between 1 and 8");
  } else
#line 130
  if (frame_rate_code > 8) {
#line 131
    error((char *)"frame_rate code must be between 1 and 8");
  }
#line 133
  if (bit_rate <= 0.0) {
#line 134
    error((char *)"bit_rate must be positive");
  }
#line 135
  if (bit_rate > (double )((1 << 30) - 1) * 400.0) {
#line 136
    error((char *)"bit_rate must be less than 429 Gbit/s");
  }
#line 137
  if (mpeg1) {
#line 137
    if (bit_rate > (double )((1 << 18) - 1) * 400.0) {
#line 138
      error((char *)"bit_rate must be less than 104 Mbit/s (MPEG-1)");
    }
  }
#line 140
  if (vbv_buffer_size < 1) {
#line 141
    error((char *)"vbv_buffer_size must be in range 1..(2^18-1)");
  } else
#line 140
  if (vbv_buffer_size > 262143) {
#line 141
    error((char *)"vbv_buffer_size must be in range 1..(2^18-1)");
  }
#line 142
  if (mpeg1) {
#line 142
    if (vbv_buffer_size >= 1024) {
#line 143
      error((char *)"vbv_buffer_size must be less than 1024 (MPEG-1)");
    }
  }
#line 145
  if (chroma_format < 1) {
#line 146
    error((char *)"chroma_format must be in range 1...3");
  } else
#line 145
  if (chroma_format > 3) {
#line 146
    error((char *)"chroma_format must be in range 1...3");
  }
#line 148
  if (video_format < 0) {
#line 149
    error((char *)"video_format must be in range 0...4");
  } else
#line 148
  if (video_format > 4) {
#line 149
    error((char *)"video_format must be in range 0...4");
  }
#line 151
  if (color_primaries < 1) {
#line 152
    error((char *)"color_primaries must be in range 1...2 or 4...7");
  } else
#line 151
  if (color_primaries > 7) {
#line 152
    error((char *)"color_primaries must be in range 1...2 or 4...7");
  } else
#line 151
  if (color_primaries == 3) {
#line 152
    error((char *)"color_primaries must be in range 1...2 or 4...7");
  }
#line 154
  if (transfer_characteristics < 1) {
#line 156
    error((char *)"transfer_characteristics must be in range 1...2 or 4...7");
  } else
#line 154
  if (transfer_characteristics > 7) {
#line 156
    error((char *)"transfer_characteristics must be in range 1...2 or 4...7");
  } else
#line 154
  if (transfer_characteristics == 3) {
#line 156
    error((char *)"transfer_characteristics must be in range 1...2 or 4...7");
  }
#line 158
  if (matrix_coefficients < 1) {
#line 159
    error((char *)"matrix_coefficients must be in range 1...2 or 4...7");
  } else
#line 158
  if (matrix_coefficients > 7) {
#line 159
    error((char *)"matrix_coefficients must be in range 1...2 or 4...7");
  } else
#line 158
  if (matrix_coefficients == 3) {
#line 159
    error((char *)"matrix_coefficients must be in range 1...2 or 4...7");
  }
#line 161
  if (display_horizontal_size < 0) {
#line 162
    error((char *)"display_horizontal_size must be in range 0...16383");
  } else
#line 161
  if (display_horizontal_size > 16383) {
#line 162
    error((char *)"display_horizontal_size must be in range 0...16383");
  }
#line 163
  if (display_vertical_size < 0) {
#line 164
    error((char *)"display_vertical_size must be in range 0...16383");
  } else
#line 163
  if (display_vertical_size > 16383) {
#line 164
    error((char *)"display_vertical_size must be in range 0...16383");
  }
#line 166
  if (dc_prec < 0) {
#line 167
    error((char *)"intra_dc_precision must be in range 0...3");
  } else
#line 166
  if (dc_prec > 3) {
#line 167
    error((char *)"intra_dc_precision must be in range 0...3");
  }
#line 169
  i = 0;
#line 169
  while (i < M) {
#line 171
    if ((motion_data + i)->forw_hor_f_code < 1) {
#line 172
      error((char *)"f_code must be between 1 and 9");
    } else
#line 171
    if ((motion_data + i)->forw_hor_f_code > 9) {
#line 172
      error((char *)"f_code must be between 1 and 9");
    }
#line 173
    if ((motion_data + i)->forw_vert_f_code < 1) {
#line 174
      error((char *)"f_code must be between 1 and 9");
    } else
#line 173
    if ((motion_data + i)->forw_vert_f_code > 9) {
#line 174
      error((char *)"f_code must be between 1 and 9");
    }
#line 175
    if (mpeg1) {
#line 175
      if ((motion_data + i)->forw_hor_f_code > 7) {
#line 176
        error((char *)"f_code must be le less than 8");
      }
    }
#line 177
    if (mpeg1) {
#line 177
      if ((motion_data + i)->forw_vert_f_code > 7) {
#line 178
        error((char *)"f_code must be le less than 8");
      }
    }
#line 179
    if ((motion_data + i)->sxf <= 0) {
#line 180
      error((char *)"search window must be positive");
    }
#line 181
    if ((motion_data + i)->syf <= 0) {
#line 182
      error((char *)"search window must be positive");
    }
#line 183
    if (i != 0) {
#line 185
      if ((motion_data + i)->back_hor_f_code < 1) {
#line 186
        error((char *)"f_code must be between 1 and 9");
      } else
#line 185
      if ((motion_data + i)->back_hor_f_code > 9) {
#line 186
        error((char *)"f_code must be between 1 and 9");
      }
#line 187
      if ((motion_data + i)->back_vert_f_code < 1) {
#line 188
        error((char *)"f_code must be between 1 and 9");
      } else
#line 187
      if ((motion_data + i)->back_vert_f_code > 9) {
#line 188
        error((char *)"f_code must be between 1 and 9");
      }
#line 189
      if (mpeg1) {
#line 189
        if ((motion_data + i)->back_hor_f_code > 7) {
#line 190
          error((char *)"f_code must be le less than 8");
        }
      }
#line 191
      if (mpeg1) {
#line 191
        if ((motion_data + i)->back_vert_f_code > 7) {
#line 192
          error((char *)"f_code must be le less than 8");
        }
      }
#line 193
      if ((motion_data + i)->sxb <= 0) {
#line 194
        error((char *)"search window must be positive");
      }
#line 195
      if ((motion_data + i)->syb <= 0) {
#line 196
        error((char *)"search window must be positive");
      }
    }
#line 169
    i ++;
  }
#line 199
  return;
}
}
#line 202 "src/conform.c"
static char profile_level_defined[5][4]  = { {        (char)1,        (char)1,        (char)1,        (char)0}, 
   {        (char)0,        (char)1,        (char)0,        (char)0}, 
   {        (char)0,        (char)0,        (char)1,        (char)1}, 
   {        (char)1,        (char)1,        (char)1,        (char)1}, 
   {        (char)0,        (char)0,        (char)1,        (char)0}};
#line 212 "src/conform.c"
static struct level_limits maxval_tab[4]  = {      {9, 5, 1920, 1152, 62668800, 80, 597}, 
        {9, 5, 1440, 1152, 47001600, 60, 448}, 
        {8, 5, 1920, 1152, 620000000, 15, 112}, 
        {7, 4, 352, 288, 3041280, 4, 29}};
#line 239 "src/conform.c"
void profile_and_level_checks(void) 
{ 
  int i ;
  struct level_limits *maxval ;

  {
#line 244
  if (profile < 0) {
#line 245
    error((char *)"profile must be between 0 and 15");
  } else
#line 244
  if (profile > 15) {
#line 245
    error((char *)"profile must be between 0 and 15");
  }
#line 247
  if (level < 0) {
#line 248
    error((char *)"level must be between 0 and 15");
  } else
#line 247
  if (level > 15) {
#line 248
    error((char *)"level must be between 0 and 15");
  }
#line 250
  if (profile >= 8) {
#line 252
    if (! quiet) {
#line 253
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Warning: profile uses a reserved value, conformance checks skipped\n");
    }
#line 254
    return;
  }
#line 257
  if (profile < 1) {
#line 258
    error((char *)"undefined Profile");
  } else
#line 257
  if (profile > 5) {
#line 258
    error((char *)"undefined Profile");
  }
#line 260
  if (profile == 3) {
#line 261
    error((char *)"This encoder currently generates no scalable bitstreams");
  } else
#line 260
  if (profile == 2) {
#line 261
    error((char *)"This encoder currently generates no scalable bitstreams");
  }
#line 263
  if (level < 4) {
#line 264
    error((char *)"undefined Level");
  } else
#line 263
  if (level > 10) {
#line 264
    error((char *)"undefined Level");
  } else
#line 263
  if (level & 1) {
#line 264
    error((char *)"undefined Level");
  }
#line 266
  maxval = & maxval_tab[(level - 4) >> 1];
#line 269
  if (! profile_level_defined[profile - 1][(level - 4) >> 1]) {
#line 270
    error((char *)"undefined profile@level combination");
  }
#line 275
  if (profile == 5) {
#line 275
    if (M != 1) {
#line 276
      error((char *)"Simple Profile does not allow B pictures");
    }
  }
#line 278
  if (profile != 1) {
#line 278
    if (chroma_format != 1) {
#line 279
      error((char *)"chroma format must be 4:2:0 in specified Profile");
    }
  }
#line 281
  if (profile == 1) {
#line 281
    if (chroma_format == 3) {
#line 282
      error((char *)"chroma format must be 4:2:0 or 4:2:2 in High Profile");
    }
  }
#line 284
  if (profile >= 4) {
#line 286
    if (frame_rate_code <= 2) {
#line 286
      if (repeatfirst) {
#line 287
        error((char *)"repeat_first_first must be zero");
      }
    }
#line 288
    if (frame_rate_code <= 6) {
#line 288
      if (prog_seq) {
#line 288
        if (repeatfirst) {
#line 289
          error((char *)"repeat_first_first must be zero");
        }
      }
    }
  }
#line 292
  if (profile != 1) {
#line 292
    if (dc_prec == 3) {
#line 293
      error((char *)"11 bit DC precision only allowed in High Profile");
    }
  }
#line 299
  if (frame_rate_code > 5) {
#line 299
    if (level >= 8) {
#line 300
      error((char *)"Picture rate greater than permitted in specified Level");
    }
  }
#line 302
  i = 0;
#line 302
  while (i < M) {
#line 304
    if ((motion_data + i)->forw_hor_f_code > maxval->hor_f_code) {
#line 305
      error((char *)"forward horizontal f_code greater than permitted in specified Level");
    }
#line 307
    if ((motion_data + i)->forw_vert_f_code > maxval->vert_f_code) {
#line 308
      error((char *)"forward vertical f_code greater than permitted in specified Level");
    }
#line 310
    if (i != 0) {
#line 312
      if ((motion_data + i)->back_hor_f_code > maxval->hor_f_code) {
#line 313
        error((char *)"backward horizontal f_code greater than permitted in specified Level");
      }
#line 315
      if ((motion_data + i)->back_vert_f_code > maxval->vert_f_code) {
#line 316
        error((char *)"backward vertical f_code greater than permitted in specified Level");
      }
    }
#line 302
    i ++;
  }
#line 321
  if (horizontal_size > maxval->hor_size) {
#line 322
    error((char *)"Horizontal size is greater than permitted in specified Level");
  }
#line 324
  if (vertical_size > maxval->vert_size) {
#line 325
    error((char *)"Horizontal size is greater than permitted in specified Level");
  }
#line 328
  if ((double )(horizontal_size * vertical_size) * frame_rate > (double )maxval->sample_rate) {
#line 329
    error((char *)"Sample rate is greater than permitted in specified Level");
  }
#line 332
  if (bit_rate > 1.0e6 * (double )maxval->bit_rate) {
#line 333
    error((char *)"Bit rate is greater than permitted in specified Level");
  }
#line 336
  if (vbv_buffer_size > maxval->vbv_buffer_size) {
#line 337
    error((char *)"vbv_buffer_size exceeds High Level limit");
  }
#line 338
  return;
}
}
#line 1 "fdctref.o"
#pragma merger("0","/tmp/cil-KguSLNVv.i","-O4")
#line 350 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h"
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__, __always_inline__)) __signbit)(double __x )  __attribute__((__const__)) ;
#line 350
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__, __always_inline__)) __signbitf)(float __x )  __attribute__((__const__)) ;
#line 350
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__, __always_inline__)) __signbitl)(long double __x )  __attribute__((__const__)) ;
#line 126 "/usr/include/x86_64-linux-gnu/bits/mathinline.h"
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__, __always_inline__)) __signbitf)(float __x )  __attribute__((__const__)) ;
#line 126 "/usr/include/x86_64-linux-gnu/bits/mathinline.h"
__inline extern int ( __attribute__((__leaf__, __always_inline__)) __signbitf)(float __x ) 
{ 
  int __m ;

  {
#line 131
  __asm__  ("pmovmskb %1, %0": "=r" (__m): "x" (__x));
#line 132
  return ((__m & 8) != 0);
}
}
#line 138
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__, __always_inline__)) __signbit)(double __x )  __attribute__((__const__)) ;
#line 138 "/usr/include/x86_64-linux-gnu/bits/mathinline.h"
__inline extern int ( __attribute__((__leaf__, __always_inline__)) __signbit)(double __x ) 
{ 
  int __m ;

  {
#line 143
  __asm__  ("pmovmskb %1, %0": "=r" (__m): "x" (__x));
#line 144
  return ((__m & 128) != 0);
}
}
#line 150
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__, __always_inline__)) __signbitl)(long double __x )  __attribute__((__const__)) ;
#line 150 "/usr/include/x86_64-linux-gnu/bits/mathinline.h"
__inline extern int ( __attribute__((__leaf__, __always_inline__)) __signbitl)(long double __x ) 
{ 
  union __anonunion___u_3 __u ;

  {
#line 153
  __u.__l = __x;
#line 154
  return ((__u.__i[2] & 32768) != 0);
}
}
#line 102 "src/global.h"
void init_fdct(void) ;
#line 103
void fdct(short *block ) ;
#line 106 "src/fdctref.c"
void init_fdct(void) 
{ 


  {
#line 130
  return;
}
}
#line 159 "src/fdctref.c"
static short const   _tg_1_16  =    (short const   )13036;
#line 160 "src/fdctref.c"
static short const   _tg_2_16  =    (short const   )27146;
#line 161 "src/fdctref.c"
static short const   _tg_3_16  =    (short const   )-21746;
#line 163 "src/fdctref.c"
static short const   _ocos_4_16  =    (short const   )23170;
#line 164 "src/fdctref.c"
static short const   _one_corr  =    (short const   )1;
#line 167 "src/fdctref.c"
static short tab_frw_01234567[256]  = 
#line 167
  {      (short)16384,      (short)16384,      (short)21407,      (short)-8867, 
        (short)16384,      (short)-16384,      (short)8867,      (short)21407, 
        (short)16384,      (short)16384,      (short)8867,      (short)-21407, 
        (short)-16384,      (short)16384,      (short)-21407,      (short)-8867, 
        (short)22725,      (short)12873,      (short)19266,      (short)-22725, 
        (short)12873,      (short)4520,      (short)4520,      (short)19266, 
        (short)19266,      (short)4520,      (short)-4520,      (short)-12873, 
        (short)-22725,      (short)19266,      (short)-12873,      (short)-22725, 
        (short)22725,      (short)22725,      (short)29692,      (short)-12299, 
        (short)22725,      (short)-22725,      (short)12299,      (short)29692, 
        (short)22725,      (short)22725,      (short)12299,      (short)-29692, 
        (short)-22725,      (short)22725,      (short)-29692,      (short)-12299, 
        (short)31521,      (short)17855,      (short)26722,      (short)-31521, 
        (short)17855,      (short)6270,      (short)6270,      (short)26722, 
        (short)26722,      (short)6270,      (short)-6270,      (short)-17855, 
        (short)-31521,      (short)26722,      (short)-17855,      (short)-31521, 
        (short)21407,      (short)21407,      (short)27969,      (short)-11585, 
        (short)21407,      (short)-21407,      (short)11585,      (short)27969, 
        (short)21407,      (short)21407,      (short)11585,      (short)-27969, 
        (short)-21407,      (short)21407,      (short)-27969,      (short)-11585, 
        (short)29692,      (short)16819,      (short)25172,      (short)-29692, 
        (short)16819,      (short)5906,      (short)5906,      (short)25172, 
        (short)25172,      (short)5906,      (short)-5906,      (short)-16819, 
        (short)-29692,      (short)25172,      (short)-16819,      (short)-29692, 
        (short)19266,      (short)19266,      (short)25172,      (short)-10426, 
        (short)19266,      (short)-19266,      (short)10426,      (short)25172, 
        (short)19266,      (short)19266,      (short)10426,      (short)-25172, 
        (short)-19266,      (short)19266,      (short)-25172,      (short)-10426, 
        (short)26722,      (short)15137,      (short)22654,      (short)-26722, 
        (short)15137,      (short)5315,      (short)5315,      (short)22654, 
        (short)22654,      (short)5315,      (short)-5315,      (short)-15137, 
        (short)-26722,      (short)22654,      (short)-15137,      (short)-26722, 
        (short)16384,      (short)16384,      (short)21407,      (short)-8867, 
        (short)16384,      (short)-16384,      (short)8867,      (short)21407, 
        (short)16384,      (short)16384,      (short)8867,      (short)-21407, 
        (short)-16384,      (short)16384,      (short)-21407,      (short)-8867, 
        (short)22725,      (short)12873,      (short)19266,      (short)-22725, 
        (short)12873,      (short)4520,      (short)4520,      (short)19266, 
        (short)19266,      (short)4520,      (short)-4520,      (short)-12873, 
        (short)-22725,      (short)19266,      (short)-12873,      (short)-22725, 
        (short)19266,      (short)19266,      (short)25172,      (short)-10426, 
        (short)19266,      (short)-19266,      (short)10426,      (short)25172, 
        (short)19266,      (short)19266,      (short)10426,      (short)-25172, 
        (short)-19266,      (short)19266,      (short)-25172,      (short)-10426, 
        (short)26722,      (short)15137,      (short)22654,      (short)-26722, 
        (short)15137,      (short)5315,      (short)5315,      (short)22654, 
        (short)22654,      (short)5315,      (short)-5315,      (short)-15137, 
        (short)-26722,      (short)22654,      (short)-15137,      (short)-26722, 
        (short)21407,      (short)21407,      (short)27969,      (short)-11585, 
        (short)21407,      (short)-21407,      (short)11585,      (short)27969, 
        (short)21407,      (short)21407,      (short)11585,      (short)-27969, 
        (short)-21407,      (short)21407,      (short)-27969,      (short)-11585, 
        (short)29692,      (short)16819,      (short)25172,      (short)-29692, 
        (short)16819,      (short)5906,      (short)5906,      (short)25172, 
        (short)25172,      (short)5906,      (short)-5906,      (short)-16819, 
        (short)-29692,      (short)25172,      (short)-16819,      (short)-29692, 
        (short)22725,      (short)22725,      (short)29692,      (short)-12299, 
        (short)22725,      (short)-22725,      (short)12299,      (short)29692, 
        (short)22725,      (short)22725,      (short)12299,      (short)-29692, 
        (short)-22725,      (short)22725,      (short)-29692,      (short)-12299, 
        (short)31521,      (short)17855,      (short)26722,      (short)-31521, 
        (short)17855,      (short)6270,      (short)6270,      (short)26722, 
        (short)26722,      (short)6270,      (short)-6270,      (short)-17855, 
        (short)-31521,      (short)26722,      (short)-17855,      (short)-31521};
#line 706 "src/fdctref.c"
void fdct(short *block ) 
{ 
  int a0 ;
  int a1 ;
  int a2 ;
  int a3 ;
  int b0 ;
  int b1 ;
  int b2 ;
  int b3 ;
  short *sptr ;
  short *optr ;
  short *tf ;
  int j ;
  short t0 ;
  short t1 ;
  short t2 ;
  short t3 ;
  short t4 ;
  short t5 ;
  short t6 ;
  short t7 ;
  short tp03 ;
  short tm03 ;
  short tp12 ;
  short tm12 ;
  short tp65 ;
  short tm65 ;
  short tp465 ;
  short tm465 ;
  short tp765 ;
  short tm765 ;
  short xt[80] ;

  {
#line 717
  sptr = block;
#line 718
  optr = block;
#line 720
  j = 0;
#line 720
  while (j < 8) {
#line 722
    xt[7] = *(sptr + 56);
#line 723
    xt[6] = *(sptr + 48);
#line 724
    xt[5] = *(sptr + 40);
#line 725
    xt[4] = *(sptr + 32);
#line 727
    xt[3] = *(sptr + 24);
#line 728
    xt[2] = *(sptr + 16);
#line 729
    xt[1] = *(sptr + 8);
#line 730
    xt[0] = *(sptr + 0);
#line 733
    t0 = (short )(((int )xt[0] + (int )xt[7]) << 2);
#line 734
    t1 = (short )(((int )xt[1] + (int )xt[6]) << 2);
#line 735
    t2 = (short )(((int )xt[2] + (int )xt[5]) << 2);
#line 736
    t3 = (short )(((int )xt[3] + (int )xt[4]) << 2);
#line 737
    t4 = (short )(((int )xt[3] - (int )xt[4]) << 2);
#line 738
    t5 = (short )(((int )xt[2] - (int )xt[5]) << 3);
#line 739
    t6 = (short )(((int )xt[1] - (int )xt[6]) << 3);
#line 740
    t7 = (short )(((int )xt[0] - (int )xt[7]) << 2);
#line 742
    tp03 = (short )((int )t0 + (int )t3);
#line 743
    tm03 = (short )((int )t0 - (int )t3);
#line 744
    tp12 = (short )((int )t1 + (int )t2);
#line 745
    tm12 = (short )((int )t1 - (int )t2);
#line 747
    *(optr + 0) = (short )((int )tp03 + (int )tp12);
#line 748
    *(optr + 32) = (short )((int )tp03 - (int )tp12);
#line 749
    *(optr + 16) = (short )((int )tm03 + (int )((short )((int )tm12 * (int )_tg_2_16 >> 16)));
#line 750
    *(optr + 16) = (short )((int )*(optr + 16) | (int )_one_corr);
#line 751
    *(optr + 48) = (short )((int )((short )((int )tm03 * (int )_tg_2_16 >> 16)) - (int )tm12);
#line 752
    *(optr + 48) = (short )((int )*(optr + 48) | (int )_one_corr);
#line 754
    tp65 = (short )(((int )t6 + (int )t5) * (int )_ocos_4_16 >> 16);
#line 755
    tp65 = (short )((int )tp65 | (int )_one_corr);
#line 756
    tm65 = (short )(((int )t6 - (int )t5) * (int )_ocos_4_16 >> 16);
#line 758
    tp765 = (short )((int )t7 + (int )tp65);
#line 759
    tm765 = (short )((int )t7 - (int )tp65);
#line 760
    tp465 = (short )((int )t4 + (int )tm65);
#line 761
    tm465 = (short )((int )t4 - (int )tm65);
#line 763
    *(optr + 8) = (short )((int )tp765 + (int )((short )((int )tp465 * (int )_tg_1_16 >> 16)));
#line 764
    *(optr + 8) = (short )((int )*(optr + 8) | (int )_one_corr);
#line 765
    *(optr + 56) = (short )((int )((short )((int )tp765 * (int )_tg_1_16 >> 16)) - (int )tp465);
#line 767
    *(optr + 40) = (short )(((int )((short )((int )tm765 * (int )_tg_3_16 >> 16)) + (int )tm465) + (int )tm765);
#line 769
    *(optr + 24) = (short )((int )((short )((int )tm465 * (int )_tg_3_16 >> 16)) + (int )tm465);
#line 770
    *(optr + 24) = (short )((int )tm765 - (int )*(optr + 24));
#line 772
    sptr ++;
#line 773
    optr ++;
#line 720
    j ++;
  }
#line 785
  sptr = block;
#line 786
  optr = block;
#line 787
  tf = & tab_frw_01234567[0];
#line 789
  j = 0;
#line 789
  while (j < 8) {
#line 792
    xt[3] = (short )((int )*(sptr + 3) + (int )*(sptr + 4));
#line 793
    xt[2] = (short )((int )*(sptr + 2) + (int )*(sptr + 5));
#line 794
    xt[1] = (short )((int )*(sptr + 1) + (int )*(sptr + 6));
#line 795
    xt[0] = (short )((int )*(sptr + 0) + (int )*(sptr + 7));
#line 797
    xt[7] = (short )((int )*(sptr + 3) - (int )*(sptr + 4));
#line 798
    xt[6] = (short )((int )*(sptr + 2) - (int )*(sptr + 5));
#line 799
    xt[5] = (short )((int )*(sptr + 1) - (int )*(sptr + 6));
#line 800
    xt[4] = (short )((int )*(sptr + 0) - (int )*(sptr + 7));
#line 813
    a3 = ((int )xt[0] * (int )*(tf + 6) + (int )xt[2] * (int )*(tf + 7)) + ((int )xt[1] * (int )*(tf + 14) + (int )xt[3] * (int )*(tf + 15));
#line 814
    a2 = ((int )xt[0] * (int )*(tf + 4) + (int )xt[2] * (int )*(tf + 5)) + ((int )xt[1] * (int )*(tf + 12) + (int )xt[3] * (int )*(tf + 13));
#line 815
    a1 = ((int )xt[0] * (int )*(tf + 2) + (int )xt[2] * (int )*(tf + 3)) + ((int )xt[1] * (int )*(tf + 10) + (int )xt[3] * (int )*(tf + 11));
#line 816
    a0 = ((int )xt[0] * (int )*(tf + 0) + (int )xt[2] * (int )*(tf + 1)) + ((int )xt[1] * (int )*(tf + 8) + (int )xt[3] * (int )*(tf + 9));
#line 818
    b3 = ((int )xt[4] * (int )*(tf + 22) + (int )xt[6] * (int )*(tf + 23)) + ((int )xt[5] * (int )*(tf + 30) + (int )xt[7] * (int )*(tf + 31));
#line 819
    b2 = ((int )xt[4] * (int )*(tf + 20) + (int )xt[6] * (int )*(tf + 21)) + ((int )xt[5] * (int )*(tf + 28) + (int )xt[7] * (int )*(tf + 29));
#line 820
    b1 = ((int )xt[4] * (int )*(tf + 18) + (int )xt[6] * (int )*(tf + 19)) + ((int )xt[5] * (int )*(tf + 26) + (int )xt[7] * (int )*(tf + 27));
#line 821
    b0 = ((int )xt[4] * (int )*(tf + 16) + (int )xt[6] * (int )*(tf + 17)) + ((int )xt[5] * (int )*(tf + 24) + (int )xt[7] * (int )*(tf + 25));
#line 823
    tf += 32;
#line 830
    a3 = (a3 + (1 << 18)) >> 19;
#line 831
    a2 = (a2 + (1 << 18)) >> 19;
#line 832
    a1 = (a1 + (1 << 18)) >> 19;
#line 833
    a0 = (a0 + (1 << 18)) >> 19;
#line 835
    b3 = (b3 + (1 << 18)) >> 19;
#line 836
    b2 = (b2 + (1 << 18)) >> 19;
#line 837
    b1 = (b1 + (1 << 18)) >> 19;
#line 838
    b0 = (b0 + (1 << 18)) >> 19;
#line 845
    if (a3 > 2047) {
#line 845
      a3 = 2047;
    } else {
#line 845
      a3 = a3;
    }
#line 846
    if (a2 > 2047) {
#line 846
      a2 = 2047;
    } else {
#line 846
      a2 = a2;
    }
#line 847
    if (a1 > 2047) {
#line 847
      a1 = 2047;
    } else {
#line 847
      a1 = a1;
    }
#line 848
    if (a0 > 2047) {
#line 848
      a0 = 2047;
    } else {
#line 848
      a0 = a0;
    }
#line 849
    if (b3 > 2047) {
#line 849
      b3 = 2047;
    } else {
#line 849
      b3 = b3;
    }
#line 850
    if (b2 > 2047) {
#line 850
      b2 = 2047;
    } else {
#line 850
      b2 = b2;
    }
#line 851
    if (b1 > 2047) {
#line 851
      b1 = 2047;
    } else {
#line 851
      b1 = b1;
    }
#line 852
    if (b0 > 2047) {
#line 852
      b0 = 2047;
    } else {
#line 852
      b0 = b0;
    }
#line 854
    if (a3 < -2048) {
#line 854
      a3 = -2048;
    } else {
#line 854
      a3 = a3;
    }
#line 855
    if (a2 < -2048) {
#line 855
      a2 = -2048;
    } else {
#line 855
      a2 = a2;
    }
#line 856
    if (a1 < -2048) {
#line 856
      a1 = -2048;
    } else {
#line 856
      a1 = a1;
    }
#line 857
    if (a0 < -2048) {
#line 857
      a0 = -2048;
    } else {
#line 857
      a0 = a0;
    }
#line 858
    if (b3 < -2048) {
#line 858
      b3 = -2048;
    } else {
#line 858
      b3 = b3;
    }
#line 859
    if (b2 < -2048) {
#line 859
      b2 = -2048;
    } else {
#line 859
      b2 = b2;
    }
#line 860
    if (b1 < -2048) {
#line 860
      b1 = -2048;
    } else {
#line 860
      b1 = b1;
    }
#line 861
    if (b0 < -2048) {
#line 861
      b0 = -2048;
    } else {
#line 861
      b0 = b0;
    }
#line 865
    *(optr + 3) = (short )b1;
#line 866
    *(optr + 2) = (short )a1;
#line 867
    *(optr + 1) = (short )b0;
#line 868
    *(optr + 0) = (short )a0;
#line 870
    *(optr + 7) = (short )b3;
#line 871
    *(optr + 6) = (short )a3;
#line 872
    *(optr + 5) = (short )b2;
#line 873
    *(optr + 4) = (short )a2;
#line 875
    sptr += 8;
#line 876
    optr += 8;
#line 789
    j ++;
  }
#line 878
  return;
}
}
#line 1 "puthdr.o"
#pragma merger("0","/tmp/cil-ymnniQcn.i","-O4")
#line 179 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h"
extern  __attribute__((__nothrow__)) double ( __attribute__((__leaf__)) ceil)(double __x )  __attribute__((__const__)) ;
#line 150 "/usr/include/x86_64-linux-gnu/bits/mathinline.h"
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__, __always_inline__)) __signbitl)(long double __x )  __attribute__((__const__)) ;
#line 150 "/usr/include/x86_64-linux-gnu/bits/mathinline.h"
__inline extern int ( __attribute__((__leaf__, __always_inline__)) __signbitl)(long double __x ) 
{ 
  union __anonunion___u_8 __u ;

  {
#line 153
  __u.__l = __x;
#line 154
  return ((__u.__i[2] & 32768) != 0);
}
}
#line 134 "src/global.h"
void putbits(int val , int n ) ;
#line 135
void alignbits(void) ;
#line 144
void putseqhdr(void) ;
#line 145
void putseqext(void) ;
#line 146
void putseqdispext(void) ;
#line 147
void putuserdata(char *userdata ) ;
#line 148
void putgophdr(int frame , int closed_gop ) ;
#line 149
void putpicthdr(void) ;
#line 150
void putpictcodext(void) ;
#line 151
void putseqend(void) ;
#line 219
void calc_vbv_delay(void) ;
#line 263
unsigned char zig_zag_scan[64] ;
#line 347
unsigned char intra_q[64] ;
#line 347
unsigned char inter_q[64] ;
#line 378
int tc0 ;
#line 394
int constrparms ;
#line 395
int load_iquant ;
#line 395
int load_niquant ;
#line 418
int temp_ref ;
#line 419
int pict_type ;
#line 420
int vbv_delay ;
#line 425
int forw_hor_f_code ;
#line 425
int forw_vert_f_code ;
#line 426
int back_hor_f_code ;
#line 426
int back_vert_f_code ;
#line 428
int pict_struct ;
#line 429
int topfirst ;
#line 431
int frame_pred_dct ;
#line 433
int q_scale_type ;
#line 434
int intravlc ;
#line 435
int altscan ;
#line 437
int prog_frame ;
#line 87 "src/puthdr.c"
static int frametotc(int frame ) ;
#line 93 "src/puthdr.c"
void putseqhdr(void) 
{ 
  int i ;
  double tmp ;

  {
#line 97
  alignbits();
#line 98
  putbits(435, 32);
#line 99
  putbits(horizontal_size, 12);
#line 100
  putbits(vertical_size, 12);
#line 101
  putbits(aspectratio, 4);
#line 102
  putbits(frame_rate_code, 4);
#line 103
  tmp = ceil(bit_rate / 400.0);
#line 103
  putbits((int )tmp, 18);
#line 104
  putbits(1, 1);
#line 105
  putbits(vbv_buffer_size, 10);
#line 106
  putbits(constrparms, 1);
#line 108
  putbits(load_iquant, 1);
#line 109
  if (load_iquant) {
#line 110
    i = 0;
#line 110
    while (i < 64) {
#line 111
      putbits((int )intra_q[zig_zag_scan[i]], 8);
#line 110
      i ++;
    }
  }
#line 113
  putbits(load_niquant, 1);
#line 114
  if (load_niquant) {
#line 115
    i = 0;
#line 115
    while (i < 64) {
#line 116
      putbits((int )inter_q[zig_zag_scan[i]], 8);
#line 115
      i ++;
    }
  }
#line 117
  return;
}
}
#line 120 "src/puthdr.c"
void putseqext(void) 
{ 
  double tmp ;

  {
#line 122
  alignbits();
#line 123
  putbits(437, 32);
#line 124
  putbits(1, 4);
#line 125
  putbits((profile << 4) | level, 8);
#line 126
  putbits(prog_seq, 1);
#line 127
  putbits(chroma_format, 2);
#line 128
  putbits(horizontal_size >> 12, 2);
#line 129
  putbits(vertical_size >> 12, 2);
#line 130
  tmp = ceil(bit_rate / 400.0);
#line 130
  putbits((int )tmp >> 18, 12);
#line 131
  putbits(1, 1);
#line 132
  putbits(vbv_buffer_size >> 10, 8);
#line 133
  putbits(0, 1);
#line 134
  putbits(0, 2);
#line 135
  putbits(0, 5);
#line 136
  return;
}
}
#line 142 "src/puthdr.c"
void putseqdispext(void) 
{ 


  {
#line 144
  alignbits();
#line 145
  putbits(437, 32);
#line 146
  putbits(2, 4);
#line 147
  putbits(video_format, 3);
#line 148
  putbits(1, 1);
#line 149
  putbits(color_primaries, 8);
#line 150
  putbits(transfer_characteristics, 8);
#line 151
  putbits(matrix_coefficients, 8);
#line 152
  putbits(display_horizontal_size, 14);
#line 153
  putbits(1, 1);
#line 154
  putbits(display_vertical_size, 14);
#line 155
  return;
}
}
#line 161 "src/puthdr.c"
void putuserdata(char *userdata ) 
{ 
  char *tmp ;

  {
#line 164
  alignbits();
#line 165
  putbits(434, 32);
#line 166
  while (*userdata) {
#line 167
    tmp = userdata;
#line 167
    userdata ++;
#line 167
    putbits((int )*tmp, 8);
  }
#line 168
  return;
}
}
#line 174 "src/puthdr.c"
void putgophdr(int frame , int closed_gop ) 
{ 
  int tc ;

  {
#line 179
  alignbits();
#line 180
  putbits(440, 32);
#line 181
  tc = frametotc(tc0 + frame);
#line 182
  putbits(tc, 25);
#line 183
  putbits(closed_gop, 1);
#line 184
  putbits(0, 1);
#line 185
  return;
}
}
#line 191 "src/puthdr.c"
static int frametotc(int frame ) 
{ 
  int fps ;
  int pict ;
  int sec ;
  int minute ;
  int hour ;
  int tc ;

  {
#line 196
  fps = (int )(frame_rate + 0.5);
#line 197
  pict = frame % fps;
#line 198
  frame = (frame - pict) / fps;
#line 199
  sec = frame % 60;
#line 200
  frame = (frame - sec) / 60;
#line 201
  minute = frame % 60;
#line 202
  frame = (frame - minute) / 60;
#line 203
  hour = frame % 24;
#line 204
  tc = ((((hour << 19) | (minute << 13)) | (1 << 12)) | (sec << 6)) | pict;
#line 206
  return (tc);
}
}
#line 210 "src/puthdr.c"
void putpicthdr(void) 
{ 


  {
#line 212
  alignbits();
#line 213
  putbits(256, 32);
#line 214
  calc_vbv_delay();
#line 215
  putbits(temp_ref, 10);
#line 216
  putbits(pict_type, 3);
#line 217
  putbits(vbv_delay, 16);
#line 219
  if (pict_type == 2) {
#line 219
    goto _L;
  } else
#line 219
  if (pict_type == 3) {
    _L: /* CIL Label */ 
#line 221
    putbits(0, 1);
#line 222
    if (mpeg1) {
#line 223
      putbits(forw_hor_f_code, 3);
    } else {
#line 225
      putbits(7, 3);
    }
  }
#line 228
  if (pict_type == 3) {
#line 230
    putbits(0, 1);
#line 231
    if (mpeg1) {
#line 232
      putbits(back_hor_f_code, 3);
    } else {
#line 234
      putbits(7, 3);
    }
  }
#line 237
  putbits(0, 1);
#line 238
  return;
}
}
#line 244 "src/puthdr.c"
void putpictcodext(void) 
{ 
  int tmp ;

  {
#line 246
  alignbits();
#line 247
  putbits(437, 32);
#line 248
  putbits(8, 4);
#line 249
  putbits(forw_hor_f_code, 4);
#line 250
  putbits(forw_vert_f_code, 4);
#line 251
  putbits(back_hor_f_code, 4);
#line 252
  putbits(back_vert_f_code, 4);
#line 253
  putbits(dc_prec, 2);
#line 254
  putbits(pict_struct, 2);
#line 255
  if (pict_struct == 3) {
#line 255
    tmp = topfirst;
  } else {
#line 255
    tmp = 0;
  }
#line 255
  putbits(tmp, 1);
#line 256
  putbits(frame_pred_dct, 1);
#line 257
  putbits(0, 1);
#line 258
  putbits(q_scale_type, 1);
#line 259
  putbits(intravlc, 1);
#line 260
  putbits(altscan, 1);
#line 261
  putbits(repeatfirst, 1);
#line 262
  putbits(prog_frame, 1);
#line 263
  putbits(prog_frame, 1);
#line 264
  putbits(0, 1);
#line 265
  return;
}
}
#line 268 "src/puthdr.c"
void putseqend(void) 
{ 


  {
#line 270
  alignbits();
#line 271
  putbits(439, 32);
#line 272
  return;
}
}
#line 1 "readpic.o"
#pragma merger("0","/tmp/cil-cqy5aczD.i","-O4")
#line 237 "/usr/include/stdio.h"
extern int fclose(FILE *__stream ) ;
#line 272
extern FILE *( __attribute__((__warn_unused_result__)) fopen)(char const   * __restrict  __filename ,
                                                              char const   * __restrict  __modes ) ;
#line 531
extern int fgetc(FILE *__stream ) ;
#line 465 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__warn_unused_result__,
__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 222 "src/global.h"
void readframe(char *fname , unsigned char **frame ) ;
#line 359
unsigned char *clp ;
#line 365
char errortext[256] ;
#line 368
int inputtype ;
#line 385
int width ;
#line 385
int height ;
#line 386
int chrom_width ;
#line 386
int chrom_height ;
#line 87 "src/readpic.c"
static void read_y_u_v(char *fname , unsigned char **frame ) ;
#line 88
static void read_yuv(char *fname , unsigned char **frame ) ;
#line 89
static void read_ppm(char *fname , unsigned char **frame ) ;
#line 90
static void border_extend(unsigned char *frame , int w1 , int h1 , int w2 , int h2 ) ;
#line 92
static void conv444to422(unsigned char *src , unsigned char *dst ) ;
#line 93
static void conv422to420(unsigned char *src , unsigned char *dst ) ;
#line 94
static int pbm_getint(FILE *file ) ;
#line 96 "src/readpic.c"
void readframe(char *fname , unsigned char **frame ) 
{ 


  {
#line 100
  switch (inputtype) {
  case 0: 
#line 103
  read_y_u_v(fname, frame);
#line 104
  break;
  case 1: 
#line 106
  read_yuv(fname, frame);
#line 107
  break;
  case 2: 
#line 109
  read_ppm(fname, frame);
#line 110
  break;
  default: 
#line 112
  break;
  }
#line 114
  return;
}
}
#line 116 "src/readpic.c"
static void read_y_u_v(char *fname , unsigned char **frame ) 
{ 
  int i ;
  int chrom_hsize ;
  int chrom_vsize ;
  char name[128] ;
  FILE *fd ;

  {
#line 125
  if (chroma_format == 3) {
#line 125
    chrom_hsize = horizontal_size;
  } else {
#line 125
    chrom_hsize = horizontal_size >> 1;
  }
#line 127
  if (chroma_format != 1) {
#line 127
    chrom_vsize = vertical_size;
  } else {
#line 127
    chrom_vsize = vertical_size >> 1;
  }
#line 130
  sprintf((char * __restrict  )(name), (char const   * __restrict  )"%s.Y", fname);
#line 131
  fd = fopen((char const   * __restrict  )(name), (char const   * __restrict  )"rb");
#line 131
  if (! fd) {
#line 133
    sprintf((char * __restrict  )(errortext), (char const   * __restrict  )"Couldn\'t open %s\n",
            name);
#line 134
    error(errortext);
  }
#line 136
  i = 0;
#line 136
  while (i < vertical_size) {
#line 137
    fread((void * __restrict  )(*(frame + 0) + i * width), (size_t )1, (size_t )horizontal_size,
          (FILE * __restrict  )fd);
#line 136
    i ++;
  }
#line 138
  fclose(fd);
#line 139
  border_extend(*(frame + 0), horizontal_size, vertical_size, width, height);
#line 141
  sprintf((char * __restrict  )(name), (char const   * __restrict  )"%s.U", fname);
#line 142
  fd = fopen((char const   * __restrict  )(name), (char const   * __restrict  )"rb");
#line 142
  if (! fd) {
#line 144
    sprintf((char * __restrict  )(errortext), (char const   * __restrict  )"Couldn\'t open %s\n",
            name);
#line 145
    error(errortext);
  }
#line 147
  i = 0;
#line 147
  while (i < chrom_vsize) {
#line 148
    fread((void * __restrict  )(*(frame + 1) + i * chrom_width), (size_t )1, (size_t )chrom_hsize,
          (FILE * __restrict  )fd);
#line 147
    i ++;
  }
#line 149
  fclose(fd);
#line 150
  border_extend(*(frame + 1), chrom_hsize, chrom_vsize, chrom_width, chrom_height);
#line 152
  sprintf((char * __restrict  )(name), (char const   * __restrict  )"%s.V", fname);
#line 153
  fd = fopen((char const   * __restrict  )(name), (char const   * __restrict  )"rb");
#line 153
  if (! fd) {
#line 155
    sprintf((char * __restrict  )(errortext), (char const   * __restrict  )"Couldn\'t open %s\n",
            name);
#line 156
    error(errortext);
  }
#line 158
  i = 0;
#line 158
  while (i < chrom_vsize) {
#line 159
    fread((void * __restrict  )(*(frame + 2) + i * chrom_width), (size_t )1, (size_t )chrom_hsize,
          (FILE * __restrict  )fd);
#line 158
    i ++;
  }
#line 160
  fclose(fd);
#line 161
  border_extend(*(frame + 2), chrom_hsize, chrom_vsize, chrom_width, chrom_height);
#line 162
  return;
}
}
#line 164 "src/readpic.c"
static void read_yuv(char *fname , unsigned char **frame ) 
{ 
  int i ;
  int chrom_hsize ;
  int chrom_vsize ;
  char name[128] ;
  FILE *fd ;

  {
#line 173
  if (chroma_format == 3) {
#line 173
    chrom_hsize = horizontal_size;
  } else {
#line 173
    chrom_hsize = horizontal_size >> 1;
  }
#line 175
  if (chroma_format != 1) {
#line 175
    chrom_vsize = vertical_size;
  } else {
#line 175
    chrom_vsize = vertical_size >> 1;
  }
#line 178
  sprintf((char * __restrict  )(name), (char const   * __restrict  )"%s.yuv", fname);
#line 179
  fd = fopen((char const   * __restrict  )(name), (char const   * __restrict  )"rb");
#line 179
  if (! fd) {
#line 181
    sprintf((char * __restrict  )(errortext), (char const   * __restrict  )"Couldn\'t open %s\n",
            name);
#line 182
    error(errortext);
  }
#line 186
  i = 0;
#line 186
  while (i < vertical_size) {
#line 187
    fread((void * __restrict  )(*(frame + 0) + i * width), (size_t )1, (size_t )horizontal_size,
          (FILE * __restrict  )fd);
#line 186
    i ++;
  }
#line 188
  border_extend(*(frame + 0), horizontal_size, vertical_size, width, height);
#line 191
  i = 0;
#line 191
  while (i < chrom_vsize) {
#line 192
    fread((void * __restrict  )(*(frame + 1) + i * chrom_width), (size_t )1, (size_t )chrom_hsize,
          (FILE * __restrict  )fd);
#line 191
    i ++;
  }
#line 193
  border_extend(*(frame + 1), chrom_hsize, chrom_vsize, chrom_width, chrom_height);
#line 196
  i = 0;
#line 196
  while (i < chrom_vsize) {
#line 197
    fread((void * __restrict  )(*(frame + 2) + i * chrom_width), (size_t )1, (size_t )chrom_hsize,
          (FILE * __restrict  )fd);
#line 196
    i ++;
  }
#line 198
  border_extend(*(frame + 2), chrom_hsize, chrom_vsize, chrom_width, chrom_height);
#line 200
  fclose(fd);
#line 201
  return;
}
}
#line 214 "src/readpic.c"
static unsigned char *u444  ;
#line 214 "src/readpic.c"
static unsigned char *v444  ;
#line 214 "src/readpic.c"
static unsigned char *u422  ;
#line 214 "src/readpic.c"
static unsigned char *v422  ;
#line 215 "src/readpic.c"
static double coef[7][3]  = { {        0.2125,        0.7154,        0.0721}, 
   {        0.299,        0.587,        0.114}, 
   {        0.299,        0.587,        0.114}, 
   {        0.30,        0.59,        0.11}, 
   {        0.299,        0.587,        0.114}, 
   {        0.299,        0.587,        0.114}, 
   {        0.212,        0.701,        0.087}};
#line 203 "src/readpic.c"
static void read_ppm(char *fname , unsigned char **frame ) 
{ 
  int i ;
  int j ;
  int r___0 ;
  int g ;
  int b ;
  double y ;
  double u ;
  double v ;
  double cr ;
  double cg ;
  double cb ;
  double cu ;
  double cv ;
  char name[128] ;
  FILE *fd ;
  unsigned char *yp ;
  unsigned char *up ;
  unsigned char *vp ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;

  {
#line 224
  i = matrix_coefficients;
#line 225
  if (i > 8) {
#line 226
    i = 3;
  }
#line 228
  cr = coef[i - 1][0];
#line 229
  cg = coef[i - 1][1];
#line 230
  cb = coef[i - 1][2];
#line 231
  cu = 0.5 / (1.0 - cb);
#line 232
  cv = 0.5 / (1.0 - cr);
#line 234
  if (chroma_format == 3) {
#line 236
    u444 = *(frame + 1);
#line 237
    v444 = *(frame + 2);
  } else
#line 241
  if (! u444) {
#line 243
    tmp = malloc((size_t )(width * height));
#line 243
    u444 = (unsigned char *)tmp;
#line 243
    if (! u444) {
#line 244
      error((char *)"malloc failed");
    }
#line 245
    tmp___0 = malloc((size_t )(width * height));
#line 245
    v444 = (unsigned char *)tmp___0;
#line 245
    if (! v444) {
#line 246
      error((char *)"malloc failed");
    }
#line 247
    if (chroma_format == 1) {
#line 249
      tmp___1 = malloc((size_t )((width >> 1) * height));
#line 249
      u422 = (unsigned char *)tmp___1;
#line 249
      if (! u422) {
#line 250
        error((char *)"malloc failed");
      }
#line 251
      tmp___2 = malloc((size_t )((width >> 1) * height));
#line 251
      v422 = (unsigned char *)tmp___2;
#line 251
      if (! v422) {
#line 252
        error((char *)"malloc failed");
      }
    }
  }
#line 257
  sprintf((char * __restrict  )(name), (char const   * __restrict  )"%s.ppm", fname);
#line 259
  fd = fopen((char const   * __restrict  )(name), (char const   * __restrict  )"rb");
#line 259
  if (! fd) {
#line 261
    sprintf((char * __restrict  )(errortext), (char const   * __restrict  )"Couldn\'t open %s\n",
            name);
#line 262
    error(errortext);
  }
#line 266
  fgetc(fd);
#line 266
  fgetc(fd);
#line 267
  pbm_getint(fd);
#line 267
  pbm_getint(fd);
#line 267
  pbm_getint(fd);
#line 269
  i = 0;
#line 269
  while (i < vertical_size) {
#line 271
    yp = *(frame + 0) + i * width;
#line 272
    up = u444 + i * width;
#line 273
    vp = v444 + i * width;
#line 275
    j = 0;
#line 275
    while (j < horizontal_size) {
#line 277
      r___0 = fgetc(fd);
#line 277
      g = fgetc(fd);
#line 277
      b = fgetc(fd);
#line 279
      y = (cr * (double )r___0 + cg * (double )g) + cb * (double )b;
#line 280
      u = cu * ((double )b - y);
#line 281
      v = cv * ((double )r___0 - y);
#line 282
      *(yp + j) = (unsigned char )((219.0 / 256.0) * y + 16.5);
#line 283
      *(up + j) = (unsigned char )((224.0 / 256.0) * u + 128.5);
#line 284
      *(vp + j) = (unsigned char )((224.0 / 256.0) * v + 128.5);
#line 275
      j ++;
    }
#line 269
    i ++;
  }
#line 287
  fclose(fd);
#line 289
  border_extend(*(frame + 0), horizontal_size, vertical_size, width, height);
#line 290
  border_extend(u444, horizontal_size, vertical_size, width, height);
#line 291
  border_extend(v444, horizontal_size, vertical_size, width, height);
#line 293
  if (chroma_format == 2) {
#line 295
    conv444to422(u444, *(frame + 1));
#line 296
    conv444to422(v444, *(frame + 2));
  }
#line 299
  if (chroma_format == 1) {
#line 301
    conv444to422(u444, u422);
#line 302
    conv444to422(v444, v422);
#line 303
    conv422to420(u422, *(frame + 1));
#line 304
    conv422to420(v422, *(frame + 2));
  }
#line 306
  return;
}
}
#line 308 "src/readpic.c"
static void border_extend(unsigned char *frame , int w1 , int h1 , int w2 , int h2 ) 
{ 
  int i ;
  int j ;
  unsigned char *fp ;

  {
#line 317
  j = 0;
#line 317
  while (j < h1) {
#line 319
    fp = frame + j * w2;
#line 320
    i = w1;
#line 320
    while (i < w2) {
#line 321
      *(fp + i) = *(fp + (i - 1));
#line 320
      i ++;
    }
#line 317
    j ++;
  }
#line 326
  j = h1;
#line 326
  while (j < h2) {
#line 328
    fp = frame + j * w2;
#line 329
    i = 0;
#line 329
    while (i < w2) {
#line 330
      *(fp + i) = *(fp + (i - w2));
#line 329
      i ++;
    }
#line 326
    j ++;
  }
#line 332
  return;
}
}
#line 335 "src/readpic.c"
static void conv444to422(unsigned char *src , unsigned char *dst ) 
{ 
  int i ;
  int j ;
  int im5 ;
  int im4 ;
  int im3 ;
  int im2 ;
  int im1 ;
  int ip1 ;
  int ip2 ;
  int ip3 ;
  int ip4 ;
  int ip5 ;
  int ip6 ;

  {
#line 340
  if (mpeg1) {
#line 342
    j = 0;
#line 342
    while (j < height) {
#line 344
      i = 0;
#line 344
      while (i < width) {
#line 346
        if (i < 5) {
#line 346
          im5 = 0;
        } else {
#line 346
          im5 = i - 5;
        }
#line 347
        if (i < 4) {
#line 347
          im4 = 0;
        } else {
#line 347
          im4 = i - 4;
        }
#line 348
        if (i < 3) {
#line 348
          im3 = 0;
        } else {
#line 348
          im3 = i - 3;
        }
#line 349
        if (i < 2) {
#line 349
          im2 = 0;
        } else {
#line 349
          im2 = i - 2;
        }
#line 350
        if (i < 1) {
#line 350
          im1 = 0;
        } else {
#line 350
          im1 = i - 1;
        }
#line 351
        if (i < width - 1) {
#line 351
          ip1 = i + 1;
        } else {
#line 351
          ip1 = width - 1;
        }
#line 352
        if (i < width - 2) {
#line 352
          ip2 = i + 2;
        } else {
#line 352
          ip2 = width - 1;
        }
#line 353
        if (i < width - 3) {
#line 353
          ip3 = i + 3;
        } else {
#line 353
          ip3 = width - 1;
        }
#line 354
        if (i < width - 4) {
#line 354
          ip4 = i + 4;
        } else {
#line 354
          ip4 = width - 1;
        }
#line 355
        if (i < width - 5) {
#line 355
          ip5 = i + 5;
        } else {
#line 355
          ip5 = width - 1;
        }
#line 356
        if (i < width - 5) {
#line 356
          ip6 = i + 6;
        } else {
#line 356
          ip6 = width - 1;
        }
#line 359
        *(dst + (i >> 1)) = *(clp + (((((((228 * ((int )*(src + i) + (int )*(src + ip1)) + 70 * ((int )*(src + im1) + (int )*(src + ip2))) - 37 * ((int )*(src + im2) + (int )*(src + ip3))) - 21 * ((int )*(src + im3) + (int )*(src + ip4))) + 11 * ((int )*(src + im4) + (int )*(src + ip5))) + 5 * ((int )*(src + im5) + (int )*(src + ip6))) + 256) >> 9));
#line 344
        i += 2;
      }
#line 366
      src += width;
#line 367
      dst += width >> 1;
#line 342
      j ++;
    }
  } else {
#line 373
    j = 0;
#line 373
    while (j < height) {
#line 375
      i = 0;
#line 375
      while (i < width) {
#line 377
        if (i < 5) {
#line 377
          im5 = 0;
        } else {
#line 377
          im5 = i - 5;
        }
#line 378
        if (i < 3) {
#line 378
          im3 = 0;
        } else {
#line 378
          im3 = i - 3;
        }
#line 379
        if (i < 1) {
#line 379
          im1 = 0;
        } else {
#line 379
          im1 = i - 1;
        }
#line 380
        if (i < width - 1) {
#line 380
          ip1 = i + 1;
        } else {
#line 380
          ip1 = width - 1;
        }
#line 381
        if (i < width - 3) {
#line 381
          ip3 = i + 3;
        } else {
#line 381
          ip3 = width - 1;
        }
#line 382
        if (i < width - 5) {
#line 382
          ip5 = i + 5;
        } else {
#line 382
          ip5 = width - 1;
        }
#line 385
        *(dst + (i >> 1)) = *(clp + (((((22 * ((int )*(src + im5) + (int )*(src + ip5)) - 52 * ((int )*(src + im3) + (int )*(src + ip3))) + 159 * ((int )*(src + im1) + (int )*(src + ip1))) + 256 * (int )*(src + i)) + 256) >> 9));
#line 375
        i += 2;
      }
#line 388
      src += width;
#line 389
      dst += width >> 1;
#line 373
      j ++;
    }
  }
#line 392
  return;
}
}
#line 395 "src/readpic.c"
static void conv422to420(unsigned char *src , unsigned char *dst ) 
{ 
  int w ;
  int i ;
  int j ;
  int jm6 ;
  int jm5 ;
  int jm4 ;
  int jm3 ;
  int jm2 ;
  int jm1 ;
  int jp1 ;
  int jp2 ;
  int jp3 ;
  int jp4 ;
  int jp5 ;
  int jp6 ;

  {
#line 401
  w = width >> 1;
#line 403
  if (prog_frame) {
#line 406
    i = 0;
#line 406
    while (i < w) {
#line 408
      j = 0;
#line 408
      while (j < height) {
#line 410
        if (j < 5) {
#line 410
          jm5 = 0;
        } else {
#line 410
          jm5 = j - 5;
        }
#line 411
        if (j < 4) {
#line 411
          jm4 = 0;
        } else {
#line 411
          jm4 = j - 4;
        }
#line 412
        if (j < 3) {
#line 412
          jm3 = 0;
        } else {
#line 412
          jm3 = j - 3;
        }
#line 413
        if (j < 2) {
#line 413
          jm2 = 0;
        } else {
#line 413
          jm2 = j - 2;
        }
#line 414
        if (j < 1) {
#line 414
          jm1 = 0;
        } else {
#line 414
          jm1 = j - 1;
        }
#line 415
        if (j < height - 1) {
#line 415
          jp1 = j + 1;
        } else {
#line 415
          jp1 = height - 1;
        }
#line 416
        if (j < height - 2) {
#line 416
          jp2 = j + 2;
        } else {
#line 416
          jp2 = height - 1;
        }
#line 417
        if (j < height - 3) {
#line 417
          jp3 = j + 3;
        } else {
#line 417
          jp3 = height - 1;
        }
#line 418
        if (j < height - 4) {
#line 418
          jp4 = j + 4;
        } else {
#line 418
          jp4 = height - 1;
        }
#line 419
        if (j < height - 5) {
#line 419
          jp5 = j + 5;
        } else {
#line 419
          jp5 = height - 1;
        }
#line 420
        if (j < height - 5) {
#line 420
          jp6 = j + 6;
        } else {
#line 420
          jp6 = height - 1;
        }
#line 423
        *(dst + w * (j >> 1)) = *(clp + (((((((228 * ((int )*(src + w * j) + (int )*(src + w * jp1)) + 70 * ((int )*(src + w * jm1) + (int )*(src + w * jp2))) - 37 * ((int )*(src + w * jm2) + (int )*(src + w * jp3))) - 21 * ((int )*(src + w * jm3) + (int )*(src + w * jp4))) + 11 * ((int )*(src + w * jm4) + (int )*(src + w * jp5))) + 5 * ((int )*(src + w * jm5) + (int )*(src + w * jp6))) + 256) >> 9));
#line 408
        j += 2;
      }
#line 430
      src ++;
#line 431
      dst ++;
#line 406
      i ++;
    }
  } else {
#line 437
    i = 0;
#line 437
    while (i < w) {
#line 439
      j = 0;
#line 439
      while (j < height) {
#line 442
        if (j < 10) {
#line 442
          jm5 = 0;
        } else {
#line 442
          jm5 = j - 10;
        }
#line 443
        if (j < 8) {
#line 443
          jm4 = 0;
        } else {
#line 443
          jm4 = j - 8;
        }
#line 444
        if (j < 6) {
#line 444
          jm3 = 0;
        } else {
#line 444
          jm3 = j - 6;
        }
#line 445
        if (j < 4) {
#line 445
          jm2 = 0;
        } else {
#line 445
          jm2 = j - 4;
        }
#line 446
        if (j < 2) {
#line 446
          jm1 = 0;
        } else {
#line 446
          jm1 = j - 2;
        }
#line 447
        if (j < height - 2) {
#line 447
          jp1 = j + 2;
        } else {
#line 447
          jp1 = height - 2;
        }
#line 448
        if (j < height - 4) {
#line 448
          jp2 = j + 4;
        } else {
#line 448
          jp2 = height - 2;
        }
#line 449
        if (j < height - 6) {
#line 449
          jp3 = j + 6;
        } else {
#line 449
          jp3 = height - 2;
        }
#line 450
        if (j < height - 8) {
#line 450
          jp4 = j + 8;
        } else {
#line 450
          jp4 = height - 2;
        }
#line 451
        if (j < height - 10) {
#line 451
          jp5 = j + 10;
        } else {
#line 451
          jp5 = height - 2;
        }
#line 452
        if (j < height - 12) {
#line 452
          jp6 = j + 12;
        } else {
#line 452
          jp6 = height - 2;
        }
#line 455
        *(dst + w * (j >> 1)) = *(clp + (((((((((((((8 * (int )*(src + w * jm5) + 5 * (int )*(src + w * jm4)) - 30 * (int )*(src + w * jm3)) - 18 * (int )*(src + w * jm2)) + 113 * (int )*(src + w * jm1)) + 242 * (int )*(src + w * j)) + 192 * (int )*(src + w * jp1)) + 35 * (int )*(src + w * jp2)) - 38 * (int )*(src + w * jp3)) - 10 * (int )*(src + w * jp4)) + 11 * (int )*(src + w * jp5)) + 2 * (int )*(src + w * jp6)) + 256) >> 9));
#line 469
        if (j < 9) {
#line 469
          jm6 = 1;
        } else {
#line 469
          jm6 = j - 9;
        }
#line 470
        if (j < 7) {
#line 470
          jm5 = 1;
        } else {
#line 470
          jm5 = j - 7;
        }
#line 471
        if (j < 5) {
#line 471
          jm4 = 1;
        } else {
#line 471
          jm4 = j - 5;
        }
#line 472
        if (j < 3) {
#line 472
          jm3 = 1;
        } else {
#line 472
          jm3 = j - 3;
        }
#line 473
        if (j < 1) {
#line 473
          jm2 = 1;
        } else {
#line 473
          jm2 = j - 1;
        }
#line 474
        if (j < height - 1) {
#line 474
          jm1 = j + 1;
        } else {
#line 474
          jm1 = height - 1;
        }
#line 475
        if (j < height - 3) {
#line 475
          jp1 = j + 3;
        } else {
#line 475
          jp1 = height - 1;
        }
#line 476
        if (j < height - 5) {
#line 476
          jp2 = j + 5;
        } else {
#line 476
          jp2 = height - 1;
        }
#line 477
        if (j < height - 7) {
#line 477
          jp3 = j + 7;
        } else {
#line 477
          jp3 = height - 1;
        }
#line 478
        if (j < height - 9) {
#line 478
          jp4 = j + 9;
        } else {
#line 478
          jp4 = height - 1;
        }
#line 479
        if (j < height - 11) {
#line 479
          jp5 = j + 11;
        } else {
#line 479
          jp5 = height - 1;
        }
#line 480
        if (j < height - 13) {
#line 480
          jp6 = j + 13;
        } else {
#line 480
          jp6 = height - 1;
        }
#line 483
        *(dst + w * ((j >> 1) + 1)) = *(clp + (((((((((((((8 * (int )*(src + w * jp6) + 5 * (int )*(src + w * jp5)) - 30 * (int )*(src + w * jp4)) - 18 * (int )*(src + w * jp3)) + 113 * (int )*(src + w * jp2)) + 242 * (int )*(src + w * jp1)) + 192 * (int )*(src + w * jm1)) + 35 * (int )*(src + w * jm2)) - 38 * (int )*(src + w * jm3)) - 10 * (int )*(src + w * jm4)) + 11 * (int )*(src + w * jm5)) + 2 * (int )*(src + w * jm6)) + 256) >> 9));
#line 439
        j += 4;
      }
#line 496
      src ++;
#line 497
      dst ++;
#line 437
      i ++;
    }
  }
#line 500
  return;
}
}
#line 506 "src/readpic.c"
char pbm_getc(FILE *file ) 
{ 
  char ch ;
  int tmp ;
  int tmp___0 ;

  {
#line 511
  tmp = fgetc(file);
#line 511
  ch = (char )tmp;
#line 513
  if ((int )ch == 35) {
#line 515
    while (1) {
#line 517
      tmp___0 = fgetc(file);
#line 517
      ch = (char )tmp___0;
#line 515
      if ((int )ch != 10) {
#line 515
        if (! ((int )ch != 13)) {
#line 515
          break;
        }
      } else {
#line 515
        break;
      }
    }
  }
#line 522
  return (ch);
}
}
#line 525 "src/readpic.c"
static int pbm_getint(FILE *file ) 
{ 
  char ch ;
  int i ;

  {
#line 531
  while (1) {
#line 533
    ch = pbm_getc(file);
#line 531
    if (! ((int )ch == 32)) {
#line 531
      if (! ((int )ch == 9)) {
#line 531
        if (! ((int )ch == 10)) {
#line 531
          if (! ((int )ch == 13)) {
#line 531
            break;
          }
        }
      }
    }
  }
#line 537
  i = 0;
#line 538
  while (1) {
#line 540
    i = (i * 10 + (int )ch) - 48;
#line 541
    ch = pbm_getc(file);
#line 538
    if ((int )ch >= 48) {
#line 538
      if (! ((int )ch <= 57)) {
#line 538
        break;
      }
    } else {
#line 538
      break;
    }
  }
#line 545
  return (i);
}
}
#line 1 "stats.o"
#pragma merger("0","/tmp/cil-0J2BgPDc.i","-O4")
#line 573 "/usr/include/stdio.h"
extern int fputc(int __c , FILE *__stream ) ;
#line 112 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h"
extern  __attribute__((__nothrow__)) double ( __attribute__((__leaf__)) log10)(double __x ) ;
#line 150 "/usr/include/x86_64-linux-gnu/bits/mathinline.h"
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__, __always_inline__)) __signbitl)(long double __x )  __attribute__((__const__)) ;
#line 150 "/usr/include/x86_64-linux-gnu/bits/mathinline.h"
__inline extern int ( __attribute__((__leaf__, __always_inline__)) __signbitl)(long double __x ) 
{ 
  union __anonunion___u_8___0 __u ;

  {
#line 153
  __u.__l = __x;
#line 154
  return ((__u.__i[2] & 32768) != 0);
}
}
#line 225 "src/global.h"
void calcSNR(unsigned char **org , unsigned char **rec ) ;
#line 226
void stats(void) ;
#line 355
struct mbinfo *mbinfo ;
#line 367
FILE *statfile ;
#line 386
int block_count ;
#line 387
int mb_width ;
#line 388
int width2 ;
#line 388
int mb_height2 ;
#line 388
int chrom_width2 ;
#line 87 "src/stats.c"
static void calcSNR1(unsigned char *org , unsigned char *rec , int lx , int w , int h ,
                     double *pv , double *pe ) ;
#line 91 "src/stats.c"
void calcSNR(unsigned char **org , unsigned char **rec ) 
{ 
  int w ;
  int h ;
  int offs ;
  double v ;
  double e ;
  double tmp ;
  double tmp___0 ;
  double tmp___1 ;
  double tmp___2 ;
  double tmp___3 ;
  double tmp___4 ;

  {
#line 98
  w = horizontal_size;
#line 99
  if (pict_struct == 3) {
#line 99
    h = vertical_size;
  } else {
#line 99
    h = vertical_size >> 1;
  }
#line 100
  if (pict_struct == 2) {
#line 100
    offs = width;
  } else {
#line 100
    offs = 0;
  }
#line 102
  calcSNR1(*(org + 0) + offs, *(rec + 0) + offs, width2, w, h, & v, & e);
#line 103
  tmp = log10(v / e);
#line 103
  tmp___0 = log10((255.0 * 255.0) / e);
#line 103
  fprintf((FILE * __restrict  )statfile, (char const   * __restrict  )"Y: variance=%4.4g, MSE=%3.3g (%3.3g dB), SNR=%3.3g dB\n",
          v, e, 10.0 * tmp___0, 10.0 * tmp);
#line 106
  if (chroma_format != 3) {
#line 108
    w >>= 1;
#line 109
    offs >>= 1;
  }
#line 112
  if (chroma_format == 1) {
#line 113
    h >>= 1;
  }
#line 115
  calcSNR1(*(org + 1) + offs, *(rec + 1) + offs, chrom_width2, w, h, & v, & e);
#line 116
  tmp___1 = log10(v / e);
#line 116
  tmp___2 = log10((255.0 * 255.0) / e);
#line 116
  fprintf((FILE * __restrict  )statfile, (char const   * __restrict  )"U: variance=%4.4g, MSE=%3.3g (%3.3g dB), SNR=%3.3g dB\n",
          v, e, 10.0 * tmp___2, 10.0 * tmp___1);
#line 119
  calcSNR1(*(org + 2) + offs, *(rec + 2) + offs, chrom_width2, w, h, & v, & e);
#line 120
  tmp___3 = log10(v / e);
#line 120
  tmp___4 = log10((255.0 * 255.0) / e);
#line 120
  fprintf((FILE * __restrict  )statfile, (char const   * __restrict  )"V: variance=%4.4g, MSE=%3.3g (%3.3g dB), SNR=%3.3g dB\n",
          v, e, 10.0 * tmp___4, 10.0 * tmp___3);
#line 122
  return;
}
}
#line 124 "src/stats.c"
static void calcSNR1(unsigned char *org , unsigned char *rec , int lx , int w , int h ,
                     double *pv , double *pe ) 
{ 
  int i ;
  int j ;
  double v1 ;
  double s1 ;
  double s2 ;
  double e2 ;

  {
#line 133
  e2 = 0.0;
#line 133
  s2 = e2;
#line 133
  s1 = s2;
#line 135
  j = 0;
#line 135
  while (j < h) {
#line 137
    i = 0;
#line 137
    while (i < w) {
#line 139
      v1 = (double )*(org + i);
#line 140
      s1 += v1;
#line 141
      s2 += v1 * v1;
#line 142
      v1 -= (double )*(rec + i);
#line 143
      e2 += v1 * v1;
#line 137
      i ++;
    }
#line 145
    org += lx;
#line 146
    rec += lx;
#line 135
    j ++;
  }
#line 149
  s1 /= (double )(w * h);
#line 150
  s2 /= (double )(w * h);
#line 151
  e2 /= (double )(w * h);
#line 154
  if (e2 == 0.0) {
#line 155
    e2 = 0.00001;
  }
#line 157
  *pv = s2 - s1 * s1;
#line 158
  *pe = e2;
#line 159
  return;
}
}
#line 161 "src/stats.c"
void stats(void) 
{ 
  int i ;
  int j ;
  int k ;
  int nmb ;
  int mb_type ;
  int n_skipped ;
  int n_intra ;
  int n_ncoded ;
  int n_blocks ;
  int n_interp ;
  int n_forward ;
  int n_backward ;
  struct mbinfo *mbi ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 167
  nmb = mb_width * mb_height2;
#line 169
  n_backward = 0;
#line 169
  n_forward = n_backward;
#line 169
  n_interp = n_forward;
#line 169
  n_blocks = n_interp;
#line 169
  n_ncoded = n_blocks;
#line 169
  n_intra = n_ncoded;
#line 169
  n_skipped = n_intra;
#line 171
  k = 0;
#line 171
  while (k < nmb) {
#line 173
    mbi = mbinfo + k;
#line 174
    if (mbi->skipped) {
#line 175
      n_skipped ++;
    } else
#line 176
    if (mbi->mb_type & 1) {
#line 177
      n_intra ++;
    } else
#line 178
    if (! (mbi->mb_type & 2)) {
#line 179
      n_ncoded ++;
    }
#line 181
    i = 0;
#line 181
    while (i < block_count) {
#line 182
      if (mbi->cbp & (1 << i)) {
#line 183
        n_blocks ++;
      }
#line 181
      i ++;
    }
#line 185
    if (mbi->mb_type & 8) {
#line 187
      if (mbi->mb_type & 4) {
#line 188
        n_interp ++;
      } else {
#line 190
        n_forward ++;
      }
    } else
#line 192
    if (mbi->mb_type & 4) {
#line 193
      n_backward ++;
    }
#line 171
    k ++;
  }
#line 196
  fprintf((FILE * __restrict  )statfile, (char const   * __restrict  )"\npicture statistics:\n");
#line 197
  fprintf((FILE * __restrict  )statfile, (char const   * __restrict  )" # of intra coded macroblocks:  %4d (%.1f%%)\n",
          n_intra, (100.0 * (double )n_intra) / (double )nmb);
#line 199
  fprintf((FILE * __restrict  )statfile, (char const   * __restrict  )" # of coded blocks:             %4d (%.1f%%)\n",
          n_blocks, (100.0 * (double )n_blocks) / (double )(block_count * nmb));
#line 201
  fprintf((FILE * __restrict  )statfile, (char const   * __restrict  )" # of not coded macroblocks:    %4d (%.1f%%)\n",
          n_ncoded, (100.0 * (double )n_ncoded) / (double )nmb);
#line 203
  fprintf((FILE * __restrict  )statfile, (char const   * __restrict  )" # of skipped macroblocks:      %4d (%.1f%%)\n",
          n_skipped, (100.0 * (double )n_skipped) / (double )nmb);
#line 205
  fprintf((FILE * __restrict  )statfile, (char const   * __restrict  )" # of forw. pred. macroblocks:  %4d (%.1f%%)\n",
          n_forward, (100.0 * (double )n_forward) / (double )nmb);
#line 207
  fprintf((FILE * __restrict  )statfile, (char const   * __restrict  )" # of backw. pred. macroblocks: %4d (%.1f%%)\n",
          n_backward, (100.0 * (double )n_backward) / (double )nmb);
#line 209
  fprintf((FILE * __restrict  )statfile, (char const   * __restrict  )" # of interpolated macroblocks: %4d (%.1f%%)\n",
          n_interp, (100.0 * (double )n_interp) / (double )nmb);
#line 212
  fprintf((FILE * __restrict  )statfile, (char const   * __restrict  )"\nmacroblock_type map:\n");
#line 214
  k = 0;
#line 216
  j = 0;
#line 216
  while (j < mb_height2) {
#line 218
    i = 0;
#line 218
    while (i < mb_width) {
#line 220
      mbi = mbinfo + k;
#line 221
      mb_type = mbi->mb_type;
#line 222
      if (mbi->skipped) {
#line 223
        fputc('S', statfile);
      } else
#line 224
      if (mb_type & 1) {
#line 225
        fputc('I', statfile);
      } else {
#line 226
        switch (mb_type & 12) {
        case 8: 
#line 229
        if (mbi->motion_type == 1) {
#line 229
          tmp___0 = 'f';
        } else {
#line 229
          if (mbi->motion_type == 3) {
#line 229
            tmp = 'p';
          } else {
#line 229
            tmp = 'F';
          }
#line 229
          tmp___0 = tmp;
        }
#line 229
        fputc(tmp___0, statfile);
#line 231
        break;
        case 4: 
#line 233
        if (mbi->motion_type == 1) {
#line 233
          tmp___1 = 'b';
        } else {
#line 233
          tmp___1 = 'B';
        }
#line 233
        fputc(tmp___1, statfile);
#line 234
        break;
        case 12: 
#line 236
        if (mbi->motion_type == 1) {
#line 236
          tmp___2 = 'd';
        } else {
#line 236
          tmp___2 = 'D';
        }
#line 236
        fputc(tmp___2, statfile);
#line 237
        break;
        default: 
#line 239
        fputc('0', statfile);
#line 239
        break;
        }
      }
#line 242
      if (mb_type & 16) {
#line 243
        fputc('Q', statfile);
      } else
#line 244
      if (mb_type & 3) {
#line 245
        fputc(' ', statfile);
      } else {
#line 247
        fputc('N', statfile);
      }
#line 249
      fputc(' ', statfile);
#line 251
      k ++;
#line 218
      i ++;
    }
#line 253
    fputc('\n', statfile);
#line 216
    j ++;
  }
#line 256
  fprintf((FILE * __restrict  )statfile, (char const   * __restrict  )"\nmquant map:\n");
#line 258
  k = 0;
#line 259
  j = 0;
#line 259
  while (j < mb_height2) {
#line 261
    i = 0;
#line 261
    while (i < mb_width) {
#line 263
      if (i == 0) {
#line 264
        fprintf((FILE * __restrict  )statfile, (char const   * __restrict  )"%3d",
                (mbinfo + k)->mquant);
      } else
#line 263
      if ((mbinfo + k)->mquant != (mbinfo + (k - 1))->mquant) {
#line 264
        fprintf((FILE * __restrict  )statfile, (char const   * __restrict  )"%3d",
                (mbinfo + k)->mquant);
      } else {
#line 266
        fprintf((FILE * __restrict  )statfile, (char const   * __restrict  )"   ");
      }
#line 268
      k ++;
#line 261
      i ++;
    }
#line 270
    fputc('\n', statfile);
#line 259
    j ++;
  }
#line 497
  return;
}
}
#line 1 "putmpg.o"
#pragma merger("0","/tmp/cil-r405wr2d.i","-O4")
#line 139 "src/global.h"
void put_bits(int val , int n , int id ) ;
#line 154
void putintrablk(short *blk , int cc ) ;
#line 155
void putnonintrablk(short *blk ) ;
#line 156
void putmv(int dmv , int f_code ) ;
#line 158
void put_intrablk(short *blk , int cc , int id ) ;
#line 159
void put_nonintrablk(short *blk , int id ) ;
#line 160
void put_mv(int dmv , int f_code , int id ) ;
#line 175
void putDClum(int val ) ;
#line 176
void putDCchrom(int val ) ;
#line 177
void putACfirst(int run , int val ) ;
#line 178
void putAC(int run , int signed_level , int vlcformat ) ;
#line 181
void putmotioncode(int motion_code ) ;
#line 185
void put_DClum(int val , int id ) ;
#line 186
void put_DCchrom(int val , int id ) ;
#line 187
void put_ACfirst(int run , int val , int id ) ;
#line 188
void put_AC(int run , int signed_level , int vlcformat , int id ) ;
#line 191
void put_motioncode(int motion_code , int id ) ;
#line 276
unsigned char alternate_scan[64] ;
#line 350
int dc_dct_pred[3] ;
#line 352
int pt_dc_dct_pred[2][3] ;
#line 86 "src/putmpg.c"
void putintrablk(short *blk , int cc ) 
{ 
  int n ;
  int dct_diff ;
  int run ;
  int signed_level ;
  unsigned char *tmp ;

  {
#line 93
  dct_diff = (int )*(blk + 0) - dc_dct_pred[cc];
#line 94
  dc_dct_pred[cc] = (int )*(blk + 0);
#line 96
  if (cc == 0) {
#line 97
    putDClum(dct_diff);
  } else {
#line 99
    putDCchrom(dct_diff);
  }
#line 102
  run = 0;
#line 103
  n = 1;
#line 103
  while (n < 64) {
#line 106
    if (altscan) {
#line 106
      tmp = alternate_scan;
    } else {
#line 106
      tmp = zig_zag_scan;
    }
#line 106
    signed_level = (int )*(blk + *(tmp + n));
#line 107
    if (signed_level != 0) {
#line 109
      putAC(run, signed_level, intravlc);
#line 110
      run = 0;
    } else {
#line 113
      run ++;
    }
#line 103
    n ++;
  }
#line 117
  if (intravlc) {
#line 118
    putbits(6, 4);
  } else {
#line 120
    putbits(2, 2);
  }
#line 121
  return;
}
}
#line 124 "src/putmpg.c"
void putnonintrablk(short *blk ) 
{ 
  int n ;
  int run ;
  int signed_level ;
  int first ;
  unsigned char *tmp ;

  {
#line 129
  run = 0;
#line 130
  first = 1;
#line 132
  n = 0;
#line 132
  while (n < 64) {
#line 135
    if (altscan) {
#line 135
      tmp = alternate_scan;
    } else {
#line 135
      tmp = zig_zag_scan;
    }
#line 135
    signed_level = (int )*(blk + *(tmp + n));
#line 137
    if (signed_level != 0) {
#line 139
      if (first) {
#line 142
        putACfirst(run, signed_level);
#line 143
        first = 0;
      } else {
#line 146
        putAC(run, signed_level, 0);
      }
#line 148
      run = 0;
    } else {
#line 151
      run ++;
    }
#line 132
    n ++;
  }
#line 155
  putbits(2, 2);
#line 156
  return;
}
}
#line 159 "src/putmpg.c"
void putmv(int dmv , int f_code ) 
{ 
  int r_size ;
  int f ;
  int vmin ;
  int vmax ;
  int dv ;
  int temp ;
  int motion_code ;
  int motion_residual ;
  int tmp ;

  {
#line 164
  r_size = f_code - 1;
#line 165
  f = 1 << r_size;
#line 166
  vmin = -16 * f;
#line 167
  vmax = 16 * f - 1;
#line 168
  dv = 32 * f;
#line 171
  if (dmv > vmax) {
#line 172
    dmv -= dv;
  } else
#line 173
  if (dmv < vmin) {
#line 174
    dmv += dv;
  }
#line 177
  if (dmv < vmin) {
#line 177
    goto _L;
  } else
#line 177
  if (dmv > vmax) {
    _L: /* CIL Label */ 
#line 178
    if (! quiet) {
#line 179
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"invalid motion vector\n");
    }
  }
#line 182
  if (dmv < 0) {
#line 182
    tmp = - dmv;
  } else {
#line 182
    tmp = dmv;
  }
#line 182
  temp = (tmp + f) - 1;
#line 183
  motion_code = temp >> r_size;
#line 184
  if (dmv < 0) {
#line 185
    motion_code = - motion_code;
  }
#line 186
  motion_residual = temp & (f - 1);
#line 188
  putmotioncode(motion_code);
#line 190
  if (r_size != 0) {
#line 190
    if (motion_code != 0) {
#line 191
      putbits(motion_residual, r_size);
    }
  }
#line 192
  return;
}
}
#line 195 "src/putmpg.c"
void put_mv(int dmv , int f_code , int id ) 
{ 
  int r_size ;
  int f ;
  int vmin ;
  int vmax ;
  int dv ;
  int temp ;
  int motion_code ;
  int motion_residual ;
  int tmp ;

  {
#line 200
  r_size = f_code - 1;
#line 201
  f = 1 << r_size;
#line 202
  vmin = -16 * f;
#line 203
  vmax = 16 * f - 1;
#line 204
  dv = 32 * f;
#line 207
  if (dmv > vmax) {
#line 208
    dmv -= dv;
  } else
#line 209
  if (dmv < vmin) {
#line 210
    dmv += dv;
  }
#line 213
  if (dmv < vmin) {
#line 213
    goto _L;
  } else
#line 213
  if (dmv > vmax) {
    _L: /* CIL Label */ 
#line 214
    if (! quiet) {
#line 215
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"invalid motion vector\n");
    }
  }
#line 218
  if (dmv < 0) {
#line 218
    tmp = - dmv;
  } else {
#line 218
    tmp = dmv;
  }
#line 218
  temp = (tmp + f) - 1;
#line 219
  motion_code = temp >> r_size;
#line 220
  if (dmv < 0) {
#line 221
    motion_code = - motion_code;
  }
#line 222
  motion_residual = temp & (f - 1);
#line 224
  put_motioncode(motion_code, id);
#line 226
  if (r_size != 0) {
#line 226
    if (motion_code != 0) {
#line 227
      put_bits(motion_residual, r_size, id);
    }
  }
#line 228
  return;
}
}
#line 229 "src/putmpg.c"
void put_intrablk(short *blk , int cc , int id ) 
{ 
  int n ;
  int dct_diff ;
  int run ;
  int signed_level ;
  unsigned char *tmp ;

  {
#line 236
  dct_diff = (int )*(blk + 0) - pt_dc_dct_pred[id][cc];
#line 237
  pt_dc_dct_pred[id][cc] = (int )*(blk + 0);
#line 239
  if (cc == 0) {
#line 240
    put_DClum(dct_diff, id);
  } else {
#line 242
    put_DCchrom(dct_diff, id);
  }
#line 245
  run = 0;
#line 246
  n = 1;
#line 246
  while (n < 64) {
#line 249
    if (altscan) {
#line 249
      tmp = alternate_scan;
    } else {
#line 249
      tmp = zig_zag_scan;
    }
#line 249
    signed_level = (int )*(blk + *(tmp + n));
#line 250
    if (signed_level != 0) {
#line 252
      put_AC(run, signed_level, intravlc, id);
#line 253
      run = 0;
    } else {
#line 256
      run ++;
    }
#line 246
    n ++;
  }
#line 260
  if (intravlc) {
#line 261
    put_bits(6, 4, id);
  } else {
#line 263
    put_bits(2, 2, id);
  }
#line 264
  return;
}
}
#line 267 "src/putmpg.c"
void put_nonintrablk(short *blk , int id ) 
{ 
  int n ;
  int run ;
  int signed_level ;
  int first ;
  unsigned char *tmp ;

  {
#line 273
  run = 0;
#line 274
  first = 1;
#line 276
  n = 0;
#line 276
  while (n < 64) {
#line 279
    if (altscan) {
#line 279
      tmp = alternate_scan;
    } else {
#line 279
      tmp = zig_zag_scan;
    }
#line 279
    signed_level = (int )*(blk + *(tmp + n));
#line 281
    if (signed_level != 0) {
#line 283
      if (first) {
#line 286
        put_ACfirst(run, signed_level, id);
#line 287
        first = 0;
      } else {
#line 290
        put_AC(run, signed_level, 0, id);
      }
#line 292
      run = 0;
    } else {
#line 295
      run ++;
    }
#line 276
    n ++;
  }
#line 299
  put_bits(2, 2, id);
#line 300
  return;
}
}
#line 1 "idct.o"
#pragma merger("0","/tmp/cil-BYEWrkW_.i","-O4")
#line 106 "src/global.h"
void idct(short *block ) ;
#line 107
void init_idct(void) ;
#line 285 "src/idct.c"
short const   RND_INV_ROW  =    (short const   )2048;
#line 287 "src/idct.c"
short const   RND_INV_CORR  =    (short const   )15;
#line 566 "src/idct.c"
short tab_i_04[32]  = 
#line 566
  {      (short)16384,      (short)21407,      (short)16384,      (short)8867, 
        (short)16384,      (short)8867,      (short)-16384,      (short)-21407, 
        (short)16384,      (short)-8867,      (short)-16384,      (short)21407, 
        (short)16384,      (short)-21407,      (short)16384,      (short)-8867, 
        (short)22725,      (short)19266,      (short)12873,      (short)4520, 
        (short)19266,      (short)-4520,      (short)-22725,      (short)-12873, 
        (short)12873,      (short)-22725,      (short)4520,      (short)19266, 
        (short)4520,      (short)-12873,      (short)19266,      (short)-22725};
#line 580 "src/idct.c"
short tab_i_17[32]  = 
#line 580
  {      (short)22725,      (short)29692,      (short)22725,      (short)12299, 
        (short)22725,      (short)12299,      (short)-22725,      (short)-29692, 
        (short)22725,      (short)-12299,      (short)-22725,      (short)29692, 
        (short)22725,      (short)-29692,      (short)22725,      (short)-12299, 
        (short)31521,      (short)26722,      (short)17855,      (short)6270, 
        (short)26722,      (short)-6270,      (short)-31521,      (short)-17855, 
        (short)17855,      (short)-31521,      (short)6270,      (short)26722, 
        (short)6270,      (short)-17855,      (short)26722,      (short)-31521};
#line 594 "src/idct.c"
short tab_i_26[32]  = 
#line 594
  {      (short)21407,      (short)27969,      (short)21407,      (short)11585, 
        (short)21407,      (short)11585,      (short)-21407,      (short)-27969, 
        (short)21407,      (short)-11585,      (short)-21407,      (short)27969, 
        (short)21407,      (short)-27969,      (short)21407,      (short)-11585, 
        (short)29692,      (short)25172,      (short)16819,      (short)5906, 
        (short)25172,      (short)-5906,      (short)-29692,      (short)-16819, 
        (short)16819,      (short)-29692,      (short)5906,      (short)25172, 
        (short)5906,      (short)-16819,      (short)25172,      (short)-29692};
#line 608 "src/idct.c"
short tab_i_35[32]  = 
#line 608
  {      (short)19266,      (short)25172,      (short)19266,      (short)10426, 
        (short)19266,      (short)10426,      (short)-19266,      (short)-25172, 
        (short)19266,      (short)-10426,      (short)-19266,      (short)25172, 
        (short)19266,      (short)-25172,      (short)19266,      (short)-10426, 
        (short)26722,      (short)22654,      (short)15137,      (short)5315, 
        (short)22654,      (short)-5315,      (short)-26722,      (short)-15137, 
        (short)15137,      (short)-26722,      (short)5315,      (short)22654, 
        (short)5315,      (short)-15137,      (short)22654,      (short)-26722};
#line 742 "src/idct.c"
static void idct_M128ASM_scalar(short *src ) 
{ 
  int a0 ;
  int a1 ;
  int a2 ;
  int a3 ;
  int b0 ;
  int b1 ;
  int b2 ;
  int b3 ;
  int a0___0 ;
  int a1___0 ;
  int a2___0 ;
  int a3___0 ;
  int b0___0 ;
  int b1___0 ;
  int b2___0 ;
  int b3___0 ;
  int a0___1 ;
  int a1___1 ;
  int a2___1 ;
  int a3___1 ;
  int b0___1 ;
  int b1___1 ;
  int b2___1 ;
  int b3___1 ;
  int a0___2 ;
  int a1___2 ;
  int a2___2 ;
  int a3___2 ;
  int b0___2 ;
  int b1___2 ;
  int b2___2 ;
  int b3___2 ;
  int a0___3 ;
  int a1___3 ;
  int a2___3 ;
  int a3___3 ;
  int b0___3 ;
  int b1___3 ;
  int b2___3 ;
  int b3___3 ;
  int a0___4 ;
  int a1___4 ;
  int a2___4 ;
  int a3___4 ;
  int b0___4 ;
  int b1___4 ;
  int b2___4 ;
  int b3___4 ;
  int a0___5 ;
  int a1___5 ;
  int a2___5 ;
  int a3___5 ;
  int b0___5 ;
  int b1___5 ;
  int b2___5 ;
  int b3___5 ;
  int a0___6 ;
  int a1___6 ;
  int a2___6 ;
  int a3___6 ;
  int b0___6 ;
  int b1___6 ;
  int b2___6 ;
  int b3___6 ;
  int t0 ;
  int t1 ;
  int t2 ;
  int t3 ;
  int t4 ;
  int t5 ;
  int t6 ;
  int t7 ;
  int tp03 ;
  int tm03 ;
  int tp12 ;
  int tm12 ;
  int tp65 ;
  int tm65 ;
  int tp465 ;
  int tm465 ;
  int tp765 ;
  int tm765 ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int t0___0 ;
  int t1___0 ;
  int t2___0 ;
  int t3___0 ;
  int t4___0 ;
  int t5___0 ;
  int t6___0 ;
  int t7___0 ;
  int tp03___0 ;
  int tm03___0 ;
  int tp12___0 ;
  int tm12___0 ;
  int tp65___0 ;
  int tm65___0 ;
  int tp465___0 ;
  int tm465___0 ;
  int tp765___0 ;
  int tm765___0 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;
  int tmp___25 ;
  int tmp___26 ;
  int tmp___27 ;
  int tmp___28 ;
  int tmp___29 ;
  int tmp___30 ;
  int t0___1 ;
  int t1___1 ;
  int t2___1 ;
  int t3___1 ;
  int t4___1 ;
  int t5___1 ;
  int t6___1 ;
  int t7___1 ;
  int tp03___1 ;
  int tm03___1 ;
  int tp12___1 ;
  int tm12___1 ;
  int tp65___1 ;
  int tm65___1 ;
  int tp465___1 ;
  int tm465___1 ;
  int tp765___1 ;
  int tm765___1 ;
  int tmp___31 ;
  int tmp___32 ;
  int tmp___33 ;
  int tmp___34 ;
  int tmp___35 ;
  int tmp___36 ;
  int tmp___37 ;
  int tmp___38 ;
  int tmp___39 ;
  int tmp___40 ;
  int tmp___41 ;
  int tmp___42 ;
  int tmp___43 ;
  int tmp___44 ;
  int tmp___45 ;
  int tmp___46 ;
  int t0___2 ;
  int t1___2 ;
  int t2___2 ;
  int t3___2 ;
  int t4___2 ;
  int t5___2 ;
  int t6___2 ;
  int t7___2 ;
  int tp03___2 ;
  int tm03___2 ;
  int tp12___2 ;
  int tm12___2 ;
  int tp65___2 ;
  int tm65___2 ;
  int tp465___2 ;
  int tm465___2 ;
  int tp765___2 ;
  int tm765___2 ;
  int tmp___47 ;
  int tmp___48 ;
  int tmp___49 ;
  int tmp___50 ;
  int tmp___51 ;
  int tmp___52 ;
  int tmp___53 ;
  int tmp___54 ;
  int tmp___55 ;
  int tmp___56 ;
  int tmp___57 ;
  int tmp___58 ;
  int tmp___59 ;
  int tmp___60 ;
  int tmp___61 ;
  int tmp___62 ;
  int t0___3 ;
  int t1___3 ;
  int t2___3 ;
  int t3___3 ;
  int t4___3 ;
  int t5___3 ;
  int t6___3 ;
  int t7___3 ;
  int tp03___3 ;
  int tm03___3 ;
  int tp12___3 ;
  int tm12___3 ;
  int tp65___3 ;
  int tm65___3 ;
  int tp465___3 ;
  int tm465___3 ;
  int tp765___3 ;
  int tm765___3 ;
  int tmp___63 ;
  int tmp___64 ;
  int tmp___65 ;
  int tmp___66 ;
  int tmp___67 ;
  int tmp___68 ;
  int tmp___69 ;
  int tmp___70 ;
  int tmp___71 ;
  int tmp___72 ;
  int tmp___73 ;
  int tmp___74 ;
  int tmp___75 ;
  int tmp___76 ;
  int tmp___77 ;
  int tmp___78 ;
  int t0___4 ;
  int t1___4 ;
  int t2___4 ;
  int t3___4 ;
  int t4___4 ;
  int t5___4 ;
  int t6___4 ;
  int t7___4 ;
  int tp03___4 ;
  int tm03___4 ;
  int tp12___4 ;
  int tm12___4 ;
  int tp65___4 ;
  int tm65___4 ;
  int tp465___4 ;
  int tm465___4 ;
  int tp765___4 ;
  int tm765___4 ;
  int tmp___79 ;
  int tmp___80 ;
  int tmp___81 ;
  int tmp___82 ;
  int tmp___83 ;
  int tmp___84 ;
  int tmp___85 ;
  int tmp___86 ;
  int tmp___87 ;
  int tmp___88 ;
  int tmp___89 ;
  int tmp___90 ;
  int tmp___91 ;
  int tmp___92 ;
  int tmp___93 ;
  int tmp___94 ;
  int t0___5 ;
  int t1___5 ;
  int t2___5 ;
  int t3___5 ;
  int t4___5 ;
  int t5___5 ;
  int t6___5 ;
  int t7___5 ;
  int tp03___5 ;
  int tm03___5 ;
  int tp12___5 ;
  int tm12___5 ;
  int tp65___5 ;
  int tm65___5 ;
  int tp465___5 ;
  int tm465___5 ;
  int tp765___5 ;
  int tm765___5 ;
  int tmp___95 ;
  int tmp___96 ;
  int tmp___97 ;
  int tmp___98 ;
  int tmp___99 ;
  int tmp___100 ;
  int tmp___101 ;
  int tmp___102 ;
  int tmp___103 ;
  int tmp___104 ;
  int tmp___105 ;
  int tmp___106 ;
  int tmp___107 ;
  int tmp___108 ;
  int tmp___109 ;
  int tmp___110 ;
  int t0___6 ;
  int t1___6 ;
  int t2___6 ;
  int t3___6 ;
  int t4___6 ;
  int t5___6 ;
  int t6___6 ;
  int t7___6 ;
  int tp03___6 ;
  int tm03___6 ;
  int tp12___6 ;
  int tm12___6 ;
  int tp65___6 ;
  int tm65___6 ;
  int tp465___6 ;
  int tm465___6 ;
  int tp765___6 ;
  int tm765___6 ;
  int tmp___111 ;
  int tmp___112 ;
  int tmp___113 ;
  int tmp___114 ;
  int tmp___115 ;
  int tmp___116 ;
  int tmp___117 ;
  int tmp___118 ;
  int tmp___119 ;
  int tmp___120 ;
  int tmp___121 ;
  int tmp___122 ;
  int tmp___123 ;
  int tmp___124 ;
  int tmp___125 ;
  int tmp___126 ;

  {
#line 745
  a0 = (((int )*(src + 0) * (int )tab_i_04[0] + (int )*(src + 2) * (int )tab_i_04[1]) + (int )*(src + 4) * (int )tab_i_04[2]) + (int )*(src + 6) * (int )tab_i_04[3];
#line 745
  a1 = (((int )*(src + 0) * (int )tab_i_04[4] + (int )*(src + 2) * (int )tab_i_04[5]) + (int )*(src + 4) * (int )tab_i_04[6]) + (int )*(src + 6) * (int )tab_i_04[7];
#line 745
  a2 = (((int )*(src + 0) * (int )tab_i_04[8] + (int )*(src + 2) * (int )tab_i_04[9]) + (int )*(src + 4) * (int )tab_i_04[10]) + (int )*(src + 6) * (int )tab_i_04[11];
#line 745
  a3 = (((int )*(src + 0) * (int )tab_i_04[12] + (int )*(src + 2) * (int )tab_i_04[13]) + (int )*(src + 4) * (int )tab_i_04[14]) + (int )*(src + 6) * (int )tab_i_04[15];
#line 745
  b0 = (((int )*(src + 1) * (int )tab_i_04[16] + (int )*(src + 3) * (int )tab_i_04[17]) + (int )*(src + 5) * (int )tab_i_04[18]) + (int )*(src + 7) * (int )tab_i_04[19];
#line 745
  b1 = (((int )*(src + 1) * (int )tab_i_04[20] + (int )*(src + 3) * (int )tab_i_04[21]) + (int )*(src + 5) * (int )tab_i_04[22]) + (int )*(src + 7) * (int )tab_i_04[23];
#line 745
  b2 = (((int )*(src + 1) * (int )tab_i_04[24] + (int )*(src + 3) * (int )tab_i_04[25]) + (int )*(src + 5) * (int )tab_i_04[26]) + (int )*(src + 7) * (int )tab_i_04[27];
#line 745
  b3 = (((int )*(src + 1) * (int )tab_i_04[28] + (int )*(src + 3) * (int )tab_i_04[29]) + (int )*(src + 5) * (int )tab_i_04[30]) + (int )*(src + 7) * (int )tab_i_04[31];
#line 745
  *(src + 0) = (short )(((a0 + b0) + (int )RND_INV_ROW) >> 12);
#line 745
  *(src + 1) = (short )(((a1 + b1) + (int )RND_INV_ROW) >> 12);
#line 745
  *(src + 2) = (short )(((a2 + b2) + (int )RND_INV_ROW) >> 12);
#line 745
  *(src + 3) = (short )(((a3 + b3) + (int )RND_INV_ROW) >> 12);
#line 745
  *(src + 4) = (short )(((a3 - b3) + (int )RND_INV_ROW) >> 12);
#line 745
  *(src + 5) = (short )(((a2 - b2) + (int )RND_INV_ROW) >> 12);
#line 745
  *(src + 6) = (short )(((a1 - b1) + (int )RND_INV_ROW) >> 12);
#line 745
  *(src + 7) = (short )(((a0 - b0) + (int )RND_INV_ROW) >> 12);
#line 746
  a0___0 = (((int )*((src + 32) + 0) * (int )tab_i_04[0] + (int )*((src + 32) + 2) * (int )tab_i_04[1]) + (int )*((src + 32) + 4) * (int )tab_i_04[2]) + (int )*((src + 32) + 6) * (int )tab_i_04[3];
#line 746
  a1___0 = (((int )*((src + 32) + 0) * (int )tab_i_04[4] + (int )*((src + 32) + 2) * (int )tab_i_04[5]) + (int )*((src + 32) + 4) * (int )tab_i_04[6]) + (int )*((src + 32) + 6) * (int )tab_i_04[7];
#line 746
  a2___0 = (((int )*((src + 32) + 0) * (int )tab_i_04[8] + (int )*((src + 32) + 2) * (int )tab_i_04[9]) + (int )*((src + 32) + 4) * (int )tab_i_04[10]) + (int )*((src + 32) + 6) * (int )tab_i_04[11];
#line 746
  a3___0 = (((int )*((src + 32) + 0) * (int )tab_i_04[12] + (int )*((src + 32) + 2) * (int )tab_i_04[13]) + (int )*((src + 32) + 4) * (int )tab_i_04[14]) + (int )*((src + 32) + 6) * (int )tab_i_04[15];
#line 746
  b0___0 = (((int )*((src + 32) + 1) * (int )tab_i_04[16] + (int )*((src + 32) + 3) * (int )tab_i_04[17]) + (int )*((src + 32) + 5) * (int )tab_i_04[18]) + (int )*((src + 32) + 7) * (int )tab_i_04[19];
#line 746
  b1___0 = (((int )*((src + 32) + 1) * (int )tab_i_04[20] + (int )*((src + 32) + 3) * (int )tab_i_04[21]) + (int )*((src + 32) + 5) * (int )tab_i_04[22]) + (int )*((src + 32) + 7) * (int )tab_i_04[23];
#line 746
  b2___0 = (((int )*((src + 32) + 1) * (int )tab_i_04[24] + (int )*((src + 32) + 3) * (int )tab_i_04[25]) + (int )*((src + 32) + 5) * (int )tab_i_04[26]) + (int )*((src + 32) + 7) * (int )tab_i_04[27];
#line 746
  b3___0 = (((int )*((src + 32) + 1) * (int )tab_i_04[28] + (int )*((src + 32) + 3) * (int )tab_i_04[29]) + (int )*((src + 32) + 5) * (int )tab_i_04[30]) + (int )*((src + 32) + 7) * (int )tab_i_04[31];
#line 746
  *((src + 32) + 0) = (short )(((a0___0 + b0___0) + (int )RND_INV_ROW) >> 12);
#line 746
  *((src + 32) + 1) = (short )(((a1___0 + b1___0) + (int )RND_INV_ROW) >> 12);
#line 746
  *((src + 32) + 2) = (short )(((a2___0 + b2___0) + (int )RND_INV_ROW) >> 12);
#line 746
  *((src + 32) + 3) = (short )(((a3___0 + b3___0) + (int )RND_INV_ROW) >> 12);
#line 746
  *((src + 32) + 4) = (short )(((a3___0 - b3___0) + (int )RND_INV_ROW) >> 12);
#line 746
  *((src + 32) + 5) = (short )(((a2___0 - b2___0) + (int )RND_INV_ROW) >> 12);
#line 746
  *((src + 32) + 6) = (short )(((a1___0 - b1___0) + (int )RND_INV_ROW) >> 12);
#line 746
  *((src + 32) + 7) = (short )(((a0___0 - b0___0) + (int )RND_INV_ROW) >> 12);
#line 748
  a0___1 = (((int )*((src + 8) + 0) * (int )tab_i_17[0] + (int )*((src + 8) + 2) * (int )tab_i_17[1]) + (int )*((src + 8) + 4) * (int )tab_i_17[2]) + (int )*((src + 8) + 6) * (int )tab_i_17[3];
#line 748
  a1___1 = (((int )*((src + 8) + 0) * (int )tab_i_17[4] + (int )*((src + 8) + 2) * (int )tab_i_17[5]) + (int )*((src + 8) + 4) * (int )tab_i_17[6]) + (int )*((src + 8) + 6) * (int )tab_i_17[7];
#line 748
  a2___1 = (((int )*((src + 8) + 0) * (int )tab_i_17[8] + (int )*((src + 8) + 2) * (int )tab_i_17[9]) + (int )*((src + 8) + 4) * (int )tab_i_17[10]) + (int )*((src + 8) + 6) * (int )tab_i_17[11];
#line 748
  a3___1 = (((int )*((src + 8) + 0) * (int )tab_i_17[12] + (int )*((src + 8) + 2) * (int )tab_i_17[13]) + (int )*((src + 8) + 4) * (int )tab_i_17[14]) + (int )*((src + 8) + 6) * (int )tab_i_17[15];
#line 748
  b0___1 = (((int )*((src + 8) + 1) * (int )tab_i_17[16] + (int )*((src + 8) + 3) * (int )tab_i_17[17]) + (int )*((src + 8) + 5) * (int )tab_i_17[18]) + (int )*((src + 8) + 7) * (int )tab_i_17[19];
#line 748
  b1___1 = (((int )*((src + 8) + 1) * (int )tab_i_17[20] + (int )*((src + 8) + 3) * (int )tab_i_17[21]) + (int )*((src + 8) + 5) * (int )tab_i_17[22]) + (int )*((src + 8) + 7) * (int )tab_i_17[23];
#line 748
  b2___1 = (((int )*((src + 8) + 1) * (int )tab_i_17[24] + (int )*((src + 8) + 3) * (int )tab_i_17[25]) + (int )*((src + 8) + 5) * (int )tab_i_17[26]) + (int )*((src + 8) + 7) * (int )tab_i_17[27];
#line 748
  b3___1 = (((int )*((src + 8) + 1) * (int )tab_i_17[28] + (int )*((src + 8) + 3) * (int )tab_i_17[29]) + (int )*((src + 8) + 5) * (int )tab_i_17[30]) + (int )*((src + 8) + 7) * (int )tab_i_17[31];
#line 748
  *((src + 8) + 0) = (short )(((a0___1 + b0___1) + (int )RND_INV_ROW) >> 12);
#line 748
  *((src + 8) + 1) = (short )(((a1___1 + b1___1) + (int )RND_INV_ROW) >> 12);
#line 748
  *((src + 8) + 2) = (short )(((a2___1 + b2___1) + (int )RND_INV_ROW) >> 12);
#line 748
  *((src + 8) + 3) = (short )(((a3___1 + b3___1) + (int )RND_INV_ROW) >> 12);
#line 748
  *((src + 8) + 4) = (short )(((a3___1 - b3___1) + (int )RND_INV_ROW) >> 12);
#line 748
  *((src + 8) + 5) = (short )(((a2___1 - b2___1) + (int )RND_INV_ROW) >> 12);
#line 748
  *((src + 8) + 6) = (short )(((a1___1 - b1___1) + (int )RND_INV_ROW) >> 12);
#line 748
  *((src + 8) + 7) = (short )(((a0___1 - b0___1) + (int )RND_INV_ROW) >> 12);
#line 749
  a0___2 = (((int )*((src + 56) + 0) * (int )tab_i_17[0] + (int )*((src + 56) + 2) * (int )tab_i_17[1]) + (int )*((src + 56) + 4) * (int )tab_i_17[2]) + (int )*((src + 56) + 6) * (int )tab_i_17[3];
#line 749
  a1___2 = (((int )*((src + 56) + 0) * (int )tab_i_17[4] + (int )*((src + 56) + 2) * (int )tab_i_17[5]) + (int )*((src + 56) + 4) * (int )tab_i_17[6]) + (int )*((src + 56) + 6) * (int )tab_i_17[7];
#line 749
  a2___2 = (((int )*((src + 56) + 0) * (int )tab_i_17[8] + (int )*((src + 56) + 2) * (int )tab_i_17[9]) + (int )*((src + 56) + 4) * (int )tab_i_17[10]) + (int )*((src + 56) + 6) * (int )tab_i_17[11];
#line 749
  a3___2 = (((int )*((src + 56) + 0) * (int )tab_i_17[12] + (int )*((src + 56) + 2) * (int )tab_i_17[13]) + (int )*((src + 56) + 4) * (int )tab_i_17[14]) + (int )*((src + 56) + 6) * (int )tab_i_17[15];
#line 749
  b0___2 = (((int )*((src + 56) + 1) * (int )tab_i_17[16] + (int )*((src + 56) + 3) * (int )tab_i_17[17]) + (int )*((src + 56) + 5) * (int )tab_i_17[18]) + (int )*((src + 56) + 7) * (int )tab_i_17[19];
#line 749
  b1___2 = (((int )*((src + 56) + 1) * (int )tab_i_17[20] + (int )*((src + 56) + 3) * (int )tab_i_17[21]) + (int )*((src + 56) + 5) * (int )tab_i_17[22]) + (int )*((src + 56) + 7) * (int )tab_i_17[23];
#line 749
  b2___2 = (((int )*((src + 56) + 1) * (int )tab_i_17[24] + (int )*((src + 56) + 3) * (int )tab_i_17[25]) + (int )*((src + 56) + 5) * (int )tab_i_17[26]) + (int )*((src + 56) + 7) * (int )tab_i_17[27];
#line 749
  b3___2 = (((int )*((src + 56) + 1) * (int )tab_i_17[28] + (int )*((src + 56) + 3) * (int )tab_i_17[29]) + (int )*((src + 56) + 5) * (int )tab_i_17[30]) + (int )*((src + 56) + 7) * (int )tab_i_17[31];
#line 749
  *((src + 56) + 0) = (short )(((a0___2 + b0___2) + (int )RND_INV_ROW) >> 12);
#line 749
  *((src + 56) + 1) = (short )(((a1___2 + b1___2) + (int )RND_INV_ROW) >> 12);
#line 749
  *((src + 56) + 2) = (short )(((a2___2 + b2___2) + (int )RND_INV_ROW) >> 12);
#line 749
  *((src + 56) + 3) = (short )(((a3___2 + b3___2) + (int )RND_INV_ROW) >> 12);
#line 749
  *((src + 56) + 4) = (short )(((a3___2 - b3___2) + (int )RND_INV_ROW) >> 12);
#line 749
  *((src + 56) + 5) = (short )(((a2___2 - b2___2) + (int )RND_INV_ROW) >> 12);
#line 749
  *((src + 56) + 6) = (short )(((a1___2 - b1___2) + (int )RND_INV_ROW) >> 12);
#line 749
  *((src + 56) + 7) = (short )(((a0___2 - b0___2) + (int )RND_INV_ROW) >> 12);
#line 751
  a0___3 = (((int )*((src + 16) + 0) * (int )tab_i_26[0] + (int )*((src + 16) + 2) * (int )tab_i_26[1]) + (int )*((src + 16) + 4) * (int )tab_i_26[2]) + (int )*((src + 16) + 6) * (int )tab_i_26[3];
#line 751
  a1___3 = (((int )*((src + 16) + 0) * (int )tab_i_26[4] + (int )*((src + 16) + 2) * (int )tab_i_26[5]) + (int )*((src + 16) + 4) * (int )tab_i_26[6]) + (int )*((src + 16) + 6) * (int )tab_i_26[7];
#line 751
  a2___3 = (((int )*((src + 16) + 0) * (int )tab_i_26[8] + (int )*((src + 16) + 2) * (int )tab_i_26[9]) + (int )*((src + 16) + 4) * (int )tab_i_26[10]) + (int )*((src + 16) + 6) * (int )tab_i_26[11];
#line 751
  a3___3 = (((int )*((src + 16) + 0) * (int )tab_i_26[12] + (int )*((src + 16) + 2) * (int )tab_i_26[13]) + (int )*((src + 16) + 4) * (int )tab_i_26[14]) + (int )*((src + 16) + 6) * (int )tab_i_26[15];
#line 751
  b0___3 = (((int )*((src + 16) + 1) * (int )tab_i_26[16] + (int )*((src + 16) + 3) * (int )tab_i_26[17]) + (int )*((src + 16) + 5) * (int )tab_i_26[18]) + (int )*((src + 16) + 7) * (int )tab_i_26[19];
#line 751
  b1___3 = (((int )*((src + 16) + 1) * (int )tab_i_26[20] + (int )*((src + 16) + 3) * (int )tab_i_26[21]) + (int )*((src + 16) + 5) * (int )tab_i_26[22]) + (int )*((src + 16) + 7) * (int )tab_i_26[23];
#line 751
  b2___3 = (((int )*((src + 16) + 1) * (int )tab_i_26[24] + (int )*((src + 16) + 3) * (int )tab_i_26[25]) + (int )*((src + 16) + 5) * (int )tab_i_26[26]) + (int )*((src + 16) + 7) * (int )tab_i_26[27];
#line 751
  b3___3 = (((int )*((src + 16) + 1) * (int )tab_i_26[28] + (int )*((src + 16) + 3) * (int )tab_i_26[29]) + (int )*((src + 16) + 5) * (int )tab_i_26[30]) + (int )*((src + 16) + 7) * (int )tab_i_26[31];
#line 751
  *((src + 16) + 0) = (short )(((a0___3 + b0___3) + (int )RND_INV_ROW) >> 12);
#line 751
  *((src + 16) + 1) = (short )(((a1___3 + b1___3) + (int )RND_INV_ROW) >> 12);
#line 751
  *((src + 16) + 2) = (short )(((a2___3 + b2___3) + (int )RND_INV_ROW) >> 12);
#line 751
  *((src + 16) + 3) = (short )(((a3___3 + b3___3) + (int )RND_INV_ROW) >> 12);
#line 751
  *((src + 16) + 4) = (short )(((a3___3 - b3___3) + (int )RND_INV_ROW) >> 12);
#line 751
  *((src + 16) + 5) = (short )(((a2___3 - b2___3) + (int )RND_INV_ROW) >> 12);
#line 751
  *((src + 16) + 6) = (short )(((a1___3 - b1___3) + (int )RND_INV_ROW) >> 12);
#line 751
  *((src + 16) + 7) = (short )(((a0___3 - b0___3) + (int )RND_INV_ROW) >> 12);
#line 752
  a0___4 = (((int )*((src + 48) + 0) * (int )tab_i_26[0] + (int )*((src + 48) + 2) * (int )tab_i_26[1]) + (int )*((src + 48) + 4) * (int )tab_i_26[2]) + (int )*((src + 48) + 6) * (int )tab_i_26[3];
#line 752
  a1___4 = (((int )*((src + 48) + 0) * (int )tab_i_26[4] + (int )*((src + 48) + 2) * (int )tab_i_26[5]) + (int )*((src + 48) + 4) * (int )tab_i_26[6]) + (int )*((src + 48) + 6) * (int )tab_i_26[7];
#line 752
  a2___4 = (((int )*((src + 48) + 0) * (int )tab_i_26[8] + (int )*((src + 48) + 2) * (int )tab_i_26[9]) + (int )*((src + 48) + 4) * (int )tab_i_26[10]) + (int )*((src + 48) + 6) * (int )tab_i_26[11];
#line 752
  a3___4 = (((int )*((src + 48) + 0) * (int )tab_i_26[12] + (int )*((src + 48) + 2) * (int )tab_i_26[13]) + (int )*((src + 48) + 4) * (int )tab_i_26[14]) + (int )*((src + 48) + 6) * (int )tab_i_26[15];
#line 752
  b0___4 = (((int )*((src + 48) + 1) * (int )tab_i_26[16] + (int )*((src + 48) + 3) * (int )tab_i_26[17]) + (int )*((src + 48) + 5) * (int )tab_i_26[18]) + (int )*((src + 48) + 7) * (int )tab_i_26[19];
#line 752
  b1___4 = (((int )*((src + 48) + 1) * (int )tab_i_26[20] + (int )*((src + 48) + 3) * (int )tab_i_26[21]) + (int )*((src + 48) + 5) * (int )tab_i_26[22]) + (int )*((src + 48) + 7) * (int )tab_i_26[23];
#line 752
  b2___4 = (((int )*((src + 48) + 1) * (int )tab_i_26[24] + (int )*((src + 48) + 3) * (int )tab_i_26[25]) + (int )*((src + 48) + 5) * (int )tab_i_26[26]) + (int )*((src + 48) + 7) * (int )tab_i_26[27];
#line 752
  b3___4 = (((int )*((src + 48) + 1) * (int )tab_i_26[28] + (int )*((src + 48) + 3) * (int )tab_i_26[29]) + (int )*((src + 48) + 5) * (int )tab_i_26[30]) + (int )*((src + 48) + 7) * (int )tab_i_26[31];
#line 752
  *((src + 48) + 0) = (short )(((a0___4 + b0___4) + (int )RND_INV_ROW) >> 12);
#line 752
  *((src + 48) + 1) = (short )(((a1___4 + b1___4) + (int )RND_INV_ROW) >> 12);
#line 752
  *((src + 48) + 2) = (short )(((a2___4 + b2___4) + (int )RND_INV_ROW) >> 12);
#line 752
  *((src + 48) + 3) = (short )(((a3___4 + b3___4) + (int )RND_INV_ROW) >> 12);
#line 752
  *((src + 48) + 4) = (short )(((a3___4 - b3___4) + (int )RND_INV_ROW) >> 12);
#line 752
  *((src + 48) + 5) = (short )(((a2___4 - b2___4) + (int )RND_INV_ROW) >> 12);
#line 752
  *((src + 48) + 6) = (short )(((a1___4 - b1___4) + (int )RND_INV_ROW) >> 12);
#line 752
  *((src + 48) + 7) = (short )(((a0___4 - b0___4) + (int )RND_INV_ROW) >> 12);
#line 754
  a0___5 = (((int )*((src + 24) + 0) * (int )tab_i_35[0] + (int )*((src + 24) + 2) * (int )tab_i_35[1]) + (int )*((src + 24) + 4) * (int )tab_i_35[2]) + (int )*((src + 24) + 6) * (int )tab_i_35[3];
#line 754
  a1___5 = (((int )*((src + 24) + 0) * (int )tab_i_35[4] + (int )*((src + 24) + 2) * (int )tab_i_35[5]) + (int )*((src + 24) + 4) * (int )tab_i_35[6]) + (int )*((src + 24) + 6) * (int )tab_i_35[7];
#line 754
  a2___5 = (((int )*((src + 24) + 0) * (int )tab_i_35[8] + (int )*((src + 24) + 2) * (int )tab_i_35[9]) + (int )*((src + 24) + 4) * (int )tab_i_35[10]) + (int )*((src + 24) + 6) * (int )tab_i_35[11];
#line 754
  a3___5 = (((int )*((src + 24) + 0) * (int )tab_i_35[12] + (int )*((src + 24) + 2) * (int )tab_i_35[13]) + (int )*((src + 24) + 4) * (int )tab_i_35[14]) + (int )*((src + 24) + 6) * (int )tab_i_35[15];
#line 754
  b0___5 = (((int )*((src + 24) + 1) * (int )tab_i_35[16] + (int )*((src + 24) + 3) * (int )tab_i_35[17]) + (int )*((src + 24) + 5) * (int )tab_i_35[18]) + (int )*((src + 24) + 7) * (int )tab_i_35[19];
#line 754
  b1___5 = (((int )*((src + 24) + 1) * (int )tab_i_35[20] + (int )*((src + 24) + 3) * (int )tab_i_35[21]) + (int )*((src + 24) + 5) * (int )tab_i_35[22]) + (int )*((src + 24) + 7) * (int )tab_i_35[23];
#line 754
  b2___5 = (((int )*((src + 24) + 1) * (int )tab_i_35[24] + (int )*((src + 24) + 3) * (int )tab_i_35[25]) + (int )*((src + 24) + 5) * (int )tab_i_35[26]) + (int )*((src + 24) + 7) * (int )tab_i_35[27];
#line 754
  b3___5 = (((int )*((src + 24) + 1) * (int )tab_i_35[28] + (int )*((src + 24) + 3) * (int )tab_i_35[29]) + (int )*((src + 24) + 5) * (int )tab_i_35[30]) + (int )*((src + 24) + 7) * (int )tab_i_35[31];
#line 754
  *((src + 24) + 0) = (short )(((a0___5 + b0___5) + (int )RND_INV_ROW) >> 12);
#line 754
  *((src + 24) + 1) = (short )(((a1___5 + b1___5) + (int )RND_INV_ROW) >> 12);
#line 754
  *((src + 24) + 2) = (short )(((a2___5 + b2___5) + (int )RND_INV_ROW) >> 12);
#line 754
  *((src + 24) + 3) = (short )(((a3___5 + b3___5) + (int )RND_INV_ROW) >> 12);
#line 754
  *((src + 24) + 4) = (short )(((a3___5 - b3___5) + (int )RND_INV_ROW) >> 12);
#line 754
  *((src + 24) + 5) = (short )(((a2___5 - b2___5) + (int )RND_INV_ROW) >> 12);
#line 754
  *((src + 24) + 6) = (short )(((a1___5 - b1___5) + (int )RND_INV_ROW) >> 12);
#line 754
  *((src + 24) + 7) = (short )(((a0___5 - b0___5) + (int )RND_INV_ROW) >> 12);
#line 755
  a0___6 = (((int )*((src + 40) + 0) * (int )tab_i_35[0] + (int )*((src + 40) + 2) * (int )tab_i_35[1]) + (int )*((src + 40) + 4) * (int )tab_i_35[2]) + (int )*((src + 40) + 6) * (int )tab_i_35[3];
#line 755
  a1___6 = (((int )*((src + 40) + 0) * (int )tab_i_35[4] + (int )*((src + 40) + 2) * (int )tab_i_35[5]) + (int )*((src + 40) + 4) * (int )tab_i_35[6]) + (int )*((src + 40) + 6) * (int )tab_i_35[7];
#line 755
  a2___6 = (((int )*((src + 40) + 0) * (int )tab_i_35[8] + (int )*((src + 40) + 2) * (int )tab_i_35[9]) + (int )*((src + 40) + 4) * (int )tab_i_35[10]) + (int )*((src + 40) + 6) * (int )tab_i_35[11];
#line 755
  a3___6 = (((int )*((src + 40) + 0) * (int )tab_i_35[12] + (int )*((src + 40) + 2) * (int )tab_i_35[13]) + (int )*((src + 40) + 4) * (int )tab_i_35[14]) + (int )*((src + 40) + 6) * (int )tab_i_35[15];
#line 755
  b0___6 = (((int )*((src + 40) + 1) * (int )tab_i_35[16] + (int )*((src + 40) + 3) * (int )tab_i_35[17]) + (int )*((src + 40) + 5) * (int )tab_i_35[18]) + (int )*((src + 40) + 7) * (int )tab_i_35[19];
#line 755
  b1___6 = (((int )*((src + 40) + 1) * (int )tab_i_35[20] + (int )*((src + 40) + 3) * (int )tab_i_35[21]) + (int )*((src + 40) + 5) * (int )tab_i_35[22]) + (int )*((src + 40) + 7) * (int )tab_i_35[23];
#line 755
  b2___6 = (((int )*((src + 40) + 1) * (int )tab_i_35[24] + (int )*((src + 40) + 3) * (int )tab_i_35[25]) + (int )*((src + 40) + 5) * (int )tab_i_35[26]) + (int )*((src + 40) + 7) * (int )tab_i_35[27];
#line 755
  b3___6 = (((int )*((src + 40) + 1) * (int )tab_i_35[28] + (int )*((src + 40) + 3) * (int )tab_i_35[29]) + (int )*((src + 40) + 5) * (int )tab_i_35[30]) + (int )*((src + 40) + 7) * (int )tab_i_35[31];
#line 755
  *((src + 40) + 0) = (short )(((a0___6 + b0___6) + (int )RND_INV_ROW) >> 12);
#line 755
  *((src + 40) + 1) = (short )(((a1___6 + b1___6) + (int )RND_INV_ROW) >> 12);
#line 755
  *((src + 40) + 2) = (short )(((a2___6 + b2___6) + (int )RND_INV_ROW) >> 12);
#line 755
  *((src + 40) + 3) = (short )(((a3___6 + b3___6) + (int )RND_INV_ROW) >> 12);
#line 755
  *((src + 40) + 4) = (short )(((a3___6 - b3___6) + (int )RND_INV_ROW) >> 12);
#line 755
  *((src + 40) + 5) = (short )(((a2___6 - b2___6) + (int )RND_INV_ROW) >> 12);
#line 755
  *((src + 40) + 6) = (short )(((a1___6 - b1___6) + (int )RND_INV_ROW) >> 12);
#line 755
  *((src + 40) + 7) = (short )(((a0___6 - b0___6) + (int )RND_INV_ROW) >> 12);
#line 757
  tp765 = (int )*(src + 8) + ((int )*(src + 56) * 13036 >> 16);
#line 757
  tp465 = ((int )*(src + 8) * 13036 >> 16) - (int )*(src + 56);
#line 757
  tm765 = (((int )*(src + 40) * -21746 >> 16) + (int )*(src + 40)) + (int )*(src + 24);
#line 757
  tm465 = ((int )*(src + 40) - ((int )*(src + 24) * -21746 >> 16)) - (int )*(src + 24);
#line 757
  t7 = (tp765 + tm765) + 1;
#line 757
  tp65 = tp765 - tm765;
#line 757
  t4 = tp465 + tm465;
#line 757
  tm65 = (tp465 - tm465) + 1;
#line 757
  t6 = ((tp65 + tm65) * -19195 >> 16) | 1;
#line 757
  t6 += tp65 + tm65;
#line 757
  t5 = ((tp65 - tm65) * -19195 >> 16) | 1;
#line 757
  t5 += tp65 - tm65;
#line 757
  tp03 = (int )*(src + 0) + (int )*(src + 32);
#line 757
  tp12 = (int )*(src + 0) - (int )*(src + 32);
#line 757
  tm03 = (int )*(src + 16) + ((int )*(src + 48) * 27146 >> 16);
#line 757
  tm12 = ((int )*(src + 16) * 27146 >> 16) - (int )*(src + 48);
#line 757
  t0 = (tp03 + tm03) + 16;
#line 757
  t3 = (tp03 - tm03) + (int )RND_INV_CORR;
#line 757
  t1 = (tp12 + tm12) + 16;
#line 757
  t2 = (tp12 - tm12) + (int )RND_INV_CORR;
#line 757
  if (t0 + t7 > 32767) {
#line 757
    tmp___0 = 32767;
  } else {
#line 757
    if (t0 + t7 < -32768) {
#line 757
      tmp = -32768;
    } else {
#line 757
      tmp = t0 + t7;
    }
#line 757
    tmp___0 = tmp;
  }
#line 757
  *(src + 0) = (short )(tmp___0 >> 5);
#line 757
  if (t0 - t7 > 32767) {
#line 757
    tmp___2 = 32767;
  } else {
#line 757
    if (t0 - t7 < -32768) {
#line 757
      tmp___1 = -32768;
    } else {
#line 757
      tmp___1 = t0 - t7;
    }
#line 757
    tmp___2 = tmp___1;
  }
#line 757
  *(src + 56) = (short )(tmp___2 >> 5);
#line 757
  if (t1 + t6 > 32767) {
#line 757
    tmp___4 = 32767;
  } else {
#line 757
    if (t1 + t6 < -32768) {
#line 757
      tmp___3 = -32768;
    } else {
#line 757
      tmp___3 = t1 + t6;
    }
#line 757
    tmp___4 = tmp___3;
  }
#line 757
  *(src + 8) = (short )(tmp___4 >> 5);
#line 757
  if (t1 - t6 > 32767) {
#line 757
    tmp___6 = 32767;
  } else {
#line 757
    if (t1 - t6 < -32768) {
#line 757
      tmp___5 = -32768;
    } else {
#line 757
      tmp___5 = t1 - t6;
    }
#line 757
    tmp___6 = tmp___5;
  }
#line 757
  *(src + 48) = (short )(tmp___6 >> 5);
#line 757
  if (t2 + t5 > 32767) {
#line 757
    tmp___8 = 32767;
  } else {
#line 757
    if (t2 + t5 < -32768) {
#line 757
      tmp___7 = -32768;
    } else {
#line 757
      tmp___7 = t2 + t5;
    }
#line 757
    tmp___8 = tmp___7;
  }
#line 757
  *(src + 16) = (short )(tmp___8 >> 5);
#line 757
  if (t2 - t5 > 32767) {
#line 757
    tmp___10 = 32767;
  } else {
#line 757
    if (t2 - t5 < -32768) {
#line 757
      tmp___9 = -32768;
    } else {
#line 757
      tmp___9 = t2 - t5;
    }
#line 757
    tmp___10 = tmp___9;
  }
#line 757
  *(src + 40) = (short )(tmp___10 >> 5);
#line 757
  if (t3 + t4 > 32767) {
#line 757
    tmp___12 = 32767;
  } else {
#line 757
    if (t3 + t4 < -32768) {
#line 757
      tmp___11 = -32768;
    } else {
#line 757
      tmp___11 = t3 + t4;
    }
#line 757
    tmp___12 = tmp___11;
  }
#line 757
  *(src + 24) = (short )(tmp___12 >> 5);
#line 757
  if (t3 - t4 > 32767) {
#line 757
    tmp___14 = 32767;
  } else {
#line 757
    if (t3 - t4 < -32768) {
#line 757
      tmp___13 = -32768;
    } else {
#line 757
      tmp___13 = t3 - t4;
    }
#line 757
    tmp___14 = tmp___13;
  }
#line 757
  *(src + 32) = (short )(tmp___14 >> 5);
#line 758
  tp765___0 = (int )*((src + 1) + 8) + ((int )*((src + 1) + 56) * 13036 >> 16);
#line 758
  tp465___0 = ((int )*((src + 1) + 8) * 13036 >> 16) - (int )*((src + 1) + 56);
#line 758
  tm765___0 = (((int )*((src + 1) + 40) * -21746 >> 16) + (int )*((src + 1) + 40)) + (int )*((src + 1) + 24);
#line 758
  tm465___0 = ((int )*((src + 1) + 40) - ((int )*((src + 1) + 24) * -21746 >> 16)) - (int )*((src + 1) + 24);
#line 758
  t7___0 = (tp765___0 + tm765___0) + 1;
#line 758
  tp65___0 = tp765___0 - tm765___0;
#line 758
  t4___0 = tp465___0 + tm465___0;
#line 758
  tm65___0 = (tp465___0 - tm465___0) + 1;
#line 758
  t6___0 = ((tp65___0 + tm65___0) * -19195 >> 16) | 1;
#line 758
  t6___0 += tp65___0 + tm65___0;
#line 758
  t5___0 = ((tp65___0 - tm65___0) * -19195 >> 16) | 1;
#line 758
  t5___0 += tp65___0 - tm65___0;
#line 758
  tp03___0 = (int )*((src + 1) + 0) + (int )*((src + 1) + 32);
#line 758
  tp12___0 = (int )*((src + 1) + 0) - (int )*((src + 1) + 32);
#line 758
  tm03___0 = (int )*((src + 1) + 16) + ((int )*((src + 1) + 48) * 27146 >> 16);
#line 758
  tm12___0 = ((int )*((src + 1) + 16) * 27146 >> 16) - (int )*((src + 1) + 48);
#line 758
  t0___0 = (tp03___0 + tm03___0) + 16;
#line 758
  t3___0 = (tp03___0 - tm03___0) + (int )RND_INV_CORR;
#line 758
  t1___0 = (tp12___0 + tm12___0) + 16;
#line 758
  t2___0 = (tp12___0 - tm12___0) + (int )RND_INV_CORR;
#line 758
  if (t0___0 + t7___0 > 32767) {
#line 758
    tmp___16 = 32767;
  } else {
#line 758
    if (t0___0 + t7___0 < -32768) {
#line 758
      tmp___15 = -32768;
    } else {
#line 758
      tmp___15 = t0___0 + t7___0;
    }
#line 758
    tmp___16 = tmp___15;
  }
#line 758
  *((src + 1) + 0) = (short )(tmp___16 >> 5);
#line 758
  if (t0___0 - t7___0 > 32767) {
#line 758
    tmp___18 = 32767;
  } else {
#line 758
    if (t0___0 - t7___0 < -32768) {
#line 758
      tmp___17 = -32768;
    } else {
#line 758
      tmp___17 = t0___0 - t7___0;
    }
#line 758
    tmp___18 = tmp___17;
  }
#line 758
  *((src + 1) + 56) = (short )(tmp___18 >> 5);
#line 758
  if (t1___0 + t6___0 > 32767) {
#line 758
    tmp___20 = 32767;
  } else {
#line 758
    if (t1___0 + t6___0 < -32768) {
#line 758
      tmp___19 = -32768;
    } else {
#line 758
      tmp___19 = t1___0 + t6___0;
    }
#line 758
    tmp___20 = tmp___19;
  }
#line 758
  *((src + 1) + 8) = (short )(tmp___20 >> 5);
#line 758
  if (t1___0 - t6___0 > 32767) {
#line 758
    tmp___22 = 32767;
  } else {
#line 758
    if (t1___0 - t6___0 < -32768) {
#line 758
      tmp___21 = -32768;
    } else {
#line 758
      tmp___21 = t1___0 - t6___0;
    }
#line 758
    tmp___22 = tmp___21;
  }
#line 758
  *((src + 1) + 48) = (short )(tmp___22 >> 5);
#line 758
  if (t2___0 + t5___0 > 32767) {
#line 758
    tmp___24 = 32767;
  } else {
#line 758
    if (t2___0 + t5___0 < -32768) {
#line 758
      tmp___23 = -32768;
    } else {
#line 758
      tmp___23 = t2___0 + t5___0;
    }
#line 758
    tmp___24 = tmp___23;
  }
#line 758
  *((src + 1) + 16) = (short )(tmp___24 >> 5);
#line 758
  if (t2___0 - t5___0 > 32767) {
#line 758
    tmp___26 = 32767;
  } else {
#line 758
    if (t2___0 - t5___0 < -32768) {
#line 758
      tmp___25 = -32768;
    } else {
#line 758
      tmp___25 = t2___0 - t5___0;
    }
#line 758
    tmp___26 = tmp___25;
  }
#line 758
  *((src + 1) + 40) = (short )(tmp___26 >> 5);
#line 758
  if (t3___0 + t4___0 > 32767) {
#line 758
    tmp___28 = 32767;
  } else {
#line 758
    if (t3___0 + t4___0 < -32768) {
#line 758
      tmp___27 = -32768;
    } else {
#line 758
      tmp___27 = t3___0 + t4___0;
    }
#line 758
    tmp___28 = tmp___27;
  }
#line 758
  *((src + 1) + 24) = (short )(tmp___28 >> 5);
#line 758
  if (t3___0 - t4___0 > 32767) {
#line 758
    tmp___30 = 32767;
  } else {
#line 758
    if (t3___0 - t4___0 < -32768) {
#line 758
      tmp___29 = -32768;
    } else {
#line 758
      tmp___29 = t3___0 - t4___0;
    }
#line 758
    tmp___30 = tmp___29;
  }
#line 758
  *((src + 1) + 32) = (short )(tmp___30 >> 5);
#line 759
  tp765___1 = (int )*((src + 2) + 8) + ((int )*((src + 2) + 56) * 13036 >> 16);
#line 759
  tp465___1 = ((int )*((src + 2) + 8) * 13036 >> 16) - (int )*((src + 2) + 56);
#line 759
  tm765___1 = (((int )*((src + 2) + 40) * -21746 >> 16) + (int )*((src + 2) + 40)) + (int )*((src + 2) + 24);
#line 759
  tm465___1 = ((int )*((src + 2) + 40) - ((int )*((src + 2) + 24) * -21746 >> 16)) - (int )*((src + 2) + 24);
#line 759
  t7___1 = (tp765___1 + tm765___1) + 1;
#line 759
  tp65___1 = tp765___1 - tm765___1;
#line 759
  t4___1 = tp465___1 + tm465___1;
#line 759
  tm65___1 = (tp465___1 - tm465___1) + 1;
#line 759
  t6___1 = ((tp65___1 + tm65___1) * -19195 >> 16) | 1;
#line 759
  t6___1 += tp65___1 + tm65___1;
#line 759
  t5___1 = ((tp65___1 - tm65___1) * -19195 >> 16) | 1;
#line 759
  t5___1 += tp65___1 - tm65___1;
#line 759
  tp03___1 = (int )*((src + 2) + 0) + (int )*((src + 2) + 32);
#line 759
  tp12___1 = (int )*((src + 2) + 0) - (int )*((src + 2) + 32);
#line 759
  tm03___1 = (int )*((src + 2) + 16) + ((int )*((src + 2) + 48) * 27146 >> 16);
#line 759
  tm12___1 = ((int )*((src + 2) + 16) * 27146 >> 16) - (int )*((src + 2) + 48);
#line 759
  t0___1 = (tp03___1 + tm03___1) + 16;
#line 759
  t3___1 = (tp03___1 - tm03___1) + (int )RND_INV_CORR;
#line 759
  t1___1 = (tp12___1 + tm12___1) + 16;
#line 759
  t2___1 = (tp12___1 - tm12___1) + (int )RND_INV_CORR;
#line 759
  if (t0___1 + t7___1 > 32767) {
#line 759
    tmp___32 = 32767;
  } else {
#line 759
    if (t0___1 + t7___1 < -32768) {
#line 759
      tmp___31 = -32768;
    } else {
#line 759
      tmp___31 = t0___1 + t7___1;
    }
#line 759
    tmp___32 = tmp___31;
  }
#line 759
  *((src + 2) + 0) = (short )(tmp___32 >> 5);
#line 759
  if (t0___1 - t7___1 > 32767) {
#line 759
    tmp___34 = 32767;
  } else {
#line 759
    if (t0___1 - t7___1 < -32768) {
#line 759
      tmp___33 = -32768;
    } else {
#line 759
      tmp___33 = t0___1 - t7___1;
    }
#line 759
    tmp___34 = tmp___33;
  }
#line 759
  *((src + 2) + 56) = (short )(tmp___34 >> 5);
#line 759
  if (t1___1 + t6___1 > 32767) {
#line 759
    tmp___36 = 32767;
  } else {
#line 759
    if (t1___1 + t6___1 < -32768) {
#line 759
      tmp___35 = -32768;
    } else {
#line 759
      tmp___35 = t1___1 + t6___1;
    }
#line 759
    tmp___36 = tmp___35;
  }
#line 759
  *((src + 2) + 8) = (short )(tmp___36 >> 5);
#line 759
  if (t1___1 - t6___1 > 32767) {
#line 759
    tmp___38 = 32767;
  } else {
#line 759
    if (t1___1 - t6___1 < -32768) {
#line 759
      tmp___37 = -32768;
    } else {
#line 759
      tmp___37 = t1___1 - t6___1;
    }
#line 759
    tmp___38 = tmp___37;
  }
#line 759
  *((src + 2) + 48) = (short )(tmp___38 >> 5);
#line 759
  if (t2___1 + t5___1 > 32767) {
#line 759
    tmp___40 = 32767;
  } else {
#line 759
    if (t2___1 + t5___1 < -32768) {
#line 759
      tmp___39 = -32768;
    } else {
#line 759
      tmp___39 = t2___1 + t5___1;
    }
#line 759
    tmp___40 = tmp___39;
  }
#line 759
  *((src + 2) + 16) = (short )(tmp___40 >> 5);
#line 759
  if (t2___1 - t5___1 > 32767) {
#line 759
    tmp___42 = 32767;
  } else {
#line 759
    if (t2___1 - t5___1 < -32768) {
#line 759
      tmp___41 = -32768;
    } else {
#line 759
      tmp___41 = t2___1 - t5___1;
    }
#line 759
    tmp___42 = tmp___41;
  }
#line 759
  *((src + 2) + 40) = (short )(tmp___42 >> 5);
#line 759
  if (t3___1 + t4___1 > 32767) {
#line 759
    tmp___44 = 32767;
  } else {
#line 759
    if (t3___1 + t4___1 < -32768) {
#line 759
      tmp___43 = -32768;
    } else {
#line 759
      tmp___43 = t3___1 + t4___1;
    }
#line 759
    tmp___44 = tmp___43;
  }
#line 759
  *((src + 2) + 24) = (short )(tmp___44 >> 5);
#line 759
  if (t3___1 - t4___1 > 32767) {
#line 759
    tmp___46 = 32767;
  } else {
#line 759
    if (t3___1 - t4___1 < -32768) {
#line 759
      tmp___45 = -32768;
    } else {
#line 759
      tmp___45 = t3___1 - t4___1;
    }
#line 759
    tmp___46 = tmp___45;
  }
#line 759
  *((src + 2) + 32) = (short )(tmp___46 >> 5);
#line 760
  tp765___2 = (int )*((src + 3) + 8) + ((int )*((src + 3) + 56) * 13036 >> 16);
#line 760
  tp465___2 = ((int )*((src + 3) + 8) * 13036 >> 16) - (int )*((src + 3) + 56);
#line 760
  tm765___2 = (((int )*((src + 3) + 40) * -21746 >> 16) + (int )*((src + 3) + 40)) + (int )*((src + 3) + 24);
#line 760
  tm465___2 = ((int )*((src + 3) + 40) - ((int )*((src + 3) + 24) * -21746 >> 16)) - (int )*((src + 3) + 24);
#line 760
  t7___2 = (tp765___2 + tm765___2) + 1;
#line 760
  tp65___2 = tp765___2 - tm765___2;
#line 760
  t4___2 = tp465___2 + tm465___2;
#line 760
  tm65___2 = (tp465___2 - tm465___2) + 1;
#line 760
  t6___2 = ((tp65___2 + tm65___2) * -19195 >> 16) | 1;
#line 760
  t6___2 += tp65___2 + tm65___2;
#line 760
  t5___2 = ((tp65___2 - tm65___2) * -19195 >> 16) | 1;
#line 760
  t5___2 += tp65___2 - tm65___2;
#line 760
  tp03___2 = (int )*((src + 3) + 0) + (int )*((src + 3) + 32);
#line 760
  tp12___2 = (int )*((src + 3) + 0) - (int )*((src + 3) + 32);
#line 760
  tm03___2 = (int )*((src + 3) + 16) + ((int )*((src + 3) + 48) * 27146 >> 16);
#line 760
  tm12___2 = ((int )*((src + 3) + 16) * 27146 >> 16) - (int )*((src + 3) + 48);
#line 760
  t0___2 = (tp03___2 + tm03___2) + 16;
#line 760
  t3___2 = (tp03___2 - tm03___2) + (int )RND_INV_CORR;
#line 760
  t1___2 = (tp12___2 + tm12___2) + 16;
#line 760
  t2___2 = (tp12___2 - tm12___2) + (int )RND_INV_CORR;
#line 760
  if (t0___2 + t7___2 > 32767) {
#line 760
    tmp___48 = 32767;
  } else {
#line 760
    if (t0___2 + t7___2 < -32768) {
#line 760
      tmp___47 = -32768;
    } else {
#line 760
      tmp___47 = t0___2 + t7___2;
    }
#line 760
    tmp___48 = tmp___47;
  }
#line 760
  *((src + 3) + 0) = (short )(tmp___48 >> 5);
#line 760
  if (t0___2 - t7___2 > 32767) {
#line 760
    tmp___50 = 32767;
  } else {
#line 760
    if (t0___2 - t7___2 < -32768) {
#line 760
      tmp___49 = -32768;
    } else {
#line 760
      tmp___49 = t0___2 - t7___2;
    }
#line 760
    tmp___50 = tmp___49;
  }
#line 760
  *((src + 3) + 56) = (short )(tmp___50 >> 5);
#line 760
  if (t1___2 + t6___2 > 32767) {
#line 760
    tmp___52 = 32767;
  } else {
#line 760
    if (t1___2 + t6___2 < -32768) {
#line 760
      tmp___51 = -32768;
    } else {
#line 760
      tmp___51 = t1___2 + t6___2;
    }
#line 760
    tmp___52 = tmp___51;
  }
#line 760
  *((src + 3) + 8) = (short )(tmp___52 >> 5);
#line 760
  if (t1___2 - t6___2 > 32767) {
#line 760
    tmp___54 = 32767;
  } else {
#line 760
    if (t1___2 - t6___2 < -32768) {
#line 760
      tmp___53 = -32768;
    } else {
#line 760
      tmp___53 = t1___2 - t6___2;
    }
#line 760
    tmp___54 = tmp___53;
  }
#line 760
  *((src + 3) + 48) = (short )(tmp___54 >> 5);
#line 760
  if (t2___2 + t5___2 > 32767) {
#line 760
    tmp___56 = 32767;
  } else {
#line 760
    if (t2___2 + t5___2 < -32768) {
#line 760
      tmp___55 = -32768;
    } else {
#line 760
      tmp___55 = t2___2 + t5___2;
    }
#line 760
    tmp___56 = tmp___55;
  }
#line 760
  *((src + 3) + 16) = (short )(tmp___56 >> 5);
#line 760
  if (t2___2 - t5___2 > 32767) {
#line 760
    tmp___58 = 32767;
  } else {
#line 760
    if (t2___2 - t5___2 < -32768) {
#line 760
      tmp___57 = -32768;
    } else {
#line 760
      tmp___57 = t2___2 - t5___2;
    }
#line 760
    tmp___58 = tmp___57;
  }
#line 760
  *((src + 3) + 40) = (short )(tmp___58 >> 5);
#line 760
  if (t3___2 + t4___2 > 32767) {
#line 760
    tmp___60 = 32767;
  } else {
#line 760
    if (t3___2 + t4___2 < -32768) {
#line 760
      tmp___59 = -32768;
    } else {
#line 760
      tmp___59 = t3___2 + t4___2;
    }
#line 760
    tmp___60 = tmp___59;
  }
#line 760
  *((src + 3) + 24) = (short )(tmp___60 >> 5);
#line 760
  if (t3___2 - t4___2 > 32767) {
#line 760
    tmp___62 = 32767;
  } else {
#line 760
    if (t3___2 - t4___2 < -32768) {
#line 760
      tmp___61 = -32768;
    } else {
#line 760
      tmp___61 = t3___2 - t4___2;
    }
#line 760
    tmp___62 = tmp___61;
  }
#line 760
  *((src + 3) + 32) = (short )(tmp___62 >> 5);
#line 761
  tp765___3 = (int )*((src + 4) + 8) + ((int )*((src + 4) + 56) * 13036 >> 16);
#line 761
  tp465___3 = ((int )*((src + 4) + 8) * 13036 >> 16) - (int )*((src + 4) + 56);
#line 761
  tm765___3 = (((int )*((src + 4) + 40) * -21746 >> 16) + (int )*((src + 4) + 40)) + (int )*((src + 4) + 24);
#line 761
  tm465___3 = ((int )*((src + 4) + 40) - ((int )*((src + 4) + 24) * -21746 >> 16)) - (int )*((src + 4) + 24);
#line 761
  t7___3 = (tp765___3 + tm765___3) + 1;
#line 761
  tp65___3 = tp765___3 - tm765___3;
#line 761
  t4___3 = tp465___3 + tm465___3;
#line 761
  tm65___3 = (tp465___3 - tm465___3) + 1;
#line 761
  t6___3 = ((tp65___3 + tm65___3) * -19195 >> 16) | 1;
#line 761
  t6___3 += tp65___3 + tm65___3;
#line 761
  t5___3 = ((tp65___3 - tm65___3) * -19195 >> 16) | 1;
#line 761
  t5___3 += tp65___3 - tm65___3;
#line 761
  tp03___3 = (int )*((src + 4) + 0) + (int )*((src + 4) + 32);
#line 761
  tp12___3 = (int )*((src + 4) + 0) - (int )*((src + 4) + 32);
#line 761
  tm03___3 = (int )*((src + 4) + 16) + ((int )*((src + 4) + 48) * 27146 >> 16);
#line 761
  tm12___3 = ((int )*((src + 4) + 16) * 27146 >> 16) - (int )*((src + 4) + 48);
#line 761
  t0___3 = (tp03___3 + tm03___3) + 16;
#line 761
  t3___3 = (tp03___3 - tm03___3) + (int )RND_INV_CORR;
#line 761
  t1___3 = (tp12___3 + tm12___3) + 16;
#line 761
  t2___3 = (tp12___3 - tm12___3) + (int )RND_INV_CORR;
#line 761
  if (t0___3 + t7___3 > 32767) {
#line 761
    tmp___64 = 32767;
  } else {
#line 761
    if (t0___3 + t7___3 < -32768) {
#line 761
      tmp___63 = -32768;
    } else {
#line 761
      tmp___63 = t0___3 + t7___3;
    }
#line 761
    tmp___64 = tmp___63;
  }
#line 761
  *((src + 4) + 0) = (short )(tmp___64 >> 5);
#line 761
  if (t0___3 - t7___3 > 32767) {
#line 761
    tmp___66 = 32767;
  } else {
#line 761
    if (t0___3 - t7___3 < -32768) {
#line 761
      tmp___65 = -32768;
    } else {
#line 761
      tmp___65 = t0___3 - t7___3;
    }
#line 761
    tmp___66 = tmp___65;
  }
#line 761
  *((src + 4) + 56) = (short )(tmp___66 >> 5);
#line 761
  if (t1___3 + t6___3 > 32767) {
#line 761
    tmp___68 = 32767;
  } else {
#line 761
    if (t1___3 + t6___3 < -32768) {
#line 761
      tmp___67 = -32768;
    } else {
#line 761
      tmp___67 = t1___3 + t6___3;
    }
#line 761
    tmp___68 = tmp___67;
  }
#line 761
  *((src + 4) + 8) = (short )(tmp___68 >> 5);
#line 761
  if (t1___3 - t6___3 > 32767) {
#line 761
    tmp___70 = 32767;
  } else {
#line 761
    if (t1___3 - t6___3 < -32768) {
#line 761
      tmp___69 = -32768;
    } else {
#line 761
      tmp___69 = t1___3 - t6___3;
    }
#line 761
    tmp___70 = tmp___69;
  }
#line 761
  *((src + 4) + 48) = (short )(tmp___70 >> 5);
#line 761
  if (t2___3 + t5___3 > 32767) {
#line 761
    tmp___72 = 32767;
  } else {
#line 761
    if (t2___3 + t5___3 < -32768) {
#line 761
      tmp___71 = -32768;
    } else {
#line 761
      tmp___71 = t2___3 + t5___3;
    }
#line 761
    tmp___72 = tmp___71;
  }
#line 761
  *((src + 4) + 16) = (short )(tmp___72 >> 5);
#line 761
  if (t2___3 - t5___3 > 32767) {
#line 761
    tmp___74 = 32767;
  } else {
#line 761
    if (t2___3 - t5___3 < -32768) {
#line 761
      tmp___73 = -32768;
    } else {
#line 761
      tmp___73 = t2___3 - t5___3;
    }
#line 761
    tmp___74 = tmp___73;
  }
#line 761
  *((src + 4) + 40) = (short )(tmp___74 >> 5);
#line 761
  if (t3___3 + t4___3 > 32767) {
#line 761
    tmp___76 = 32767;
  } else {
#line 761
    if (t3___3 + t4___3 < -32768) {
#line 761
      tmp___75 = -32768;
    } else {
#line 761
      tmp___75 = t3___3 + t4___3;
    }
#line 761
    tmp___76 = tmp___75;
  }
#line 761
  *((src + 4) + 24) = (short )(tmp___76 >> 5);
#line 761
  if (t3___3 - t4___3 > 32767) {
#line 761
    tmp___78 = 32767;
  } else {
#line 761
    if (t3___3 - t4___3 < -32768) {
#line 761
      tmp___77 = -32768;
    } else {
#line 761
      tmp___77 = t3___3 - t4___3;
    }
#line 761
    tmp___78 = tmp___77;
  }
#line 761
  *((src + 4) + 32) = (short )(tmp___78 >> 5);
#line 762
  tp765___4 = (int )*((src + 5) + 8) + ((int )*((src + 5) + 56) * 13036 >> 16);
#line 762
  tp465___4 = ((int )*((src + 5) + 8) * 13036 >> 16) - (int )*((src + 5) + 56);
#line 762
  tm765___4 = (((int )*((src + 5) + 40) * -21746 >> 16) + (int )*((src + 5) + 40)) + (int )*((src + 5) + 24);
#line 762
  tm465___4 = ((int )*((src + 5) + 40) - ((int )*((src + 5) + 24) * -21746 >> 16)) - (int )*((src + 5) + 24);
#line 762
  t7___4 = (tp765___4 + tm765___4) + 1;
#line 762
  tp65___4 = tp765___4 - tm765___4;
#line 762
  t4___4 = tp465___4 + tm465___4;
#line 762
  tm65___4 = (tp465___4 - tm465___4) + 1;
#line 762
  t6___4 = ((tp65___4 + tm65___4) * -19195 >> 16) | 1;
#line 762
  t6___4 += tp65___4 + tm65___4;
#line 762
  t5___4 = ((tp65___4 - tm65___4) * -19195 >> 16) | 1;
#line 762
  t5___4 += tp65___4 - tm65___4;
#line 762
  tp03___4 = (int )*((src + 5) + 0) + (int )*((src + 5) + 32);
#line 762
  tp12___4 = (int )*((src + 5) + 0) - (int )*((src + 5) + 32);
#line 762
  tm03___4 = (int )*((src + 5) + 16) + ((int )*((src + 5) + 48) * 27146 >> 16);
#line 762
  tm12___4 = ((int )*((src + 5) + 16) * 27146 >> 16) - (int )*((src + 5) + 48);
#line 762
  t0___4 = (tp03___4 + tm03___4) + 16;
#line 762
  t3___4 = (tp03___4 - tm03___4) + (int )RND_INV_CORR;
#line 762
  t1___4 = (tp12___4 + tm12___4) + 16;
#line 762
  t2___4 = (tp12___4 - tm12___4) + (int )RND_INV_CORR;
#line 762
  if (t0___4 + t7___4 > 32767) {
#line 762
    tmp___80 = 32767;
  } else {
#line 762
    if (t0___4 + t7___4 < -32768) {
#line 762
      tmp___79 = -32768;
    } else {
#line 762
      tmp___79 = t0___4 + t7___4;
    }
#line 762
    tmp___80 = tmp___79;
  }
#line 762
  *((src + 5) + 0) = (short )(tmp___80 >> 5);
#line 762
  if (t0___4 - t7___4 > 32767) {
#line 762
    tmp___82 = 32767;
  } else {
#line 762
    if (t0___4 - t7___4 < -32768) {
#line 762
      tmp___81 = -32768;
    } else {
#line 762
      tmp___81 = t0___4 - t7___4;
    }
#line 762
    tmp___82 = tmp___81;
  }
#line 762
  *((src + 5) + 56) = (short )(tmp___82 >> 5);
#line 762
  if (t1___4 + t6___4 > 32767) {
#line 762
    tmp___84 = 32767;
  } else {
#line 762
    if (t1___4 + t6___4 < -32768) {
#line 762
      tmp___83 = -32768;
    } else {
#line 762
      tmp___83 = t1___4 + t6___4;
    }
#line 762
    tmp___84 = tmp___83;
  }
#line 762
  *((src + 5) + 8) = (short )(tmp___84 >> 5);
#line 762
  if (t1___4 - t6___4 > 32767) {
#line 762
    tmp___86 = 32767;
  } else {
#line 762
    if (t1___4 - t6___4 < -32768) {
#line 762
      tmp___85 = -32768;
    } else {
#line 762
      tmp___85 = t1___4 - t6___4;
    }
#line 762
    tmp___86 = tmp___85;
  }
#line 762
  *((src + 5) + 48) = (short )(tmp___86 >> 5);
#line 762
  if (t2___4 + t5___4 > 32767) {
#line 762
    tmp___88 = 32767;
  } else {
#line 762
    if (t2___4 + t5___4 < -32768) {
#line 762
      tmp___87 = -32768;
    } else {
#line 762
      tmp___87 = t2___4 + t5___4;
    }
#line 762
    tmp___88 = tmp___87;
  }
#line 762
  *((src + 5) + 16) = (short )(tmp___88 >> 5);
#line 762
  if (t2___4 - t5___4 > 32767) {
#line 762
    tmp___90 = 32767;
  } else {
#line 762
    if (t2___4 - t5___4 < -32768) {
#line 762
      tmp___89 = -32768;
    } else {
#line 762
      tmp___89 = t2___4 - t5___4;
    }
#line 762
    tmp___90 = tmp___89;
  }
#line 762
  *((src + 5) + 40) = (short )(tmp___90 >> 5);
#line 762
  if (t3___4 + t4___4 > 32767) {
#line 762
    tmp___92 = 32767;
  } else {
#line 762
    if (t3___4 + t4___4 < -32768) {
#line 762
      tmp___91 = -32768;
    } else {
#line 762
      tmp___91 = t3___4 + t4___4;
    }
#line 762
    tmp___92 = tmp___91;
  }
#line 762
  *((src + 5) + 24) = (short )(tmp___92 >> 5);
#line 762
  if (t3___4 - t4___4 > 32767) {
#line 762
    tmp___94 = 32767;
  } else {
#line 762
    if (t3___4 - t4___4 < -32768) {
#line 762
      tmp___93 = -32768;
    } else {
#line 762
      tmp___93 = t3___4 - t4___4;
    }
#line 762
    tmp___94 = tmp___93;
  }
#line 762
  *((src + 5) + 32) = (short )(tmp___94 >> 5);
#line 763
  tp765___5 = (int )*((src + 6) + 8) + ((int )*((src + 6) + 56) * 13036 >> 16);
#line 763
  tp465___5 = ((int )*((src + 6) + 8) * 13036 >> 16) - (int )*((src + 6) + 56);
#line 763
  tm765___5 = (((int )*((src + 6) + 40) * -21746 >> 16) + (int )*((src + 6) + 40)) + (int )*((src + 6) + 24);
#line 763
  tm465___5 = ((int )*((src + 6) + 40) - ((int )*((src + 6) + 24) * -21746 >> 16)) - (int )*((src + 6) + 24);
#line 763
  t7___5 = (tp765___5 + tm765___5) + 1;
#line 763
  tp65___5 = tp765___5 - tm765___5;
#line 763
  t4___5 = tp465___5 + tm465___5;
#line 763
  tm65___5 = (tp465___5 - tm465___5) + 1;
#line 763
  t6___5 = ((tp65___5 + tm65___5) * -19195 >> 16) | 1;
#line 763
  t6___5 += tp65___5 + tm65___5;
#line 763
  t5___5 = ((tp65___5 - tm65___5) * -19195 >> 16) | 1;
#line 763
  t5___5 += tp65___5 - tm65___5;
#line 763
  tp03___5 = (int )*((src + 6) + 0) + (int )*((src + 6) + 32);
#line 763
  tp12___5 = (int )*((src + 6) + 0) - (int )*((src + 6) + 32);
#line 763
  tm03___5 = (int )*((src + 6) + 16) + ((int )*((src + 6) + 48) * 27146 >> 16);
#line 763
  tm12___5 = ((int )*((src + 6) + 16) * 27146 >> 16) - (int )*((src + 6) + 48);
#line 763
  t0___5 = (tp03___5 + tm03___5) + 16;
#line 763
  t3___5 = (tp03___5 - tm03___5) + (int )RND_INV_CORR;
#line 763
  t1___5 = (tp12___5 + tm12___5) + 16;
#line 763
  t2___5 = (tp12___5 - tm12___5) + (int )RND_INV_CORR;
#line 763
  if (t0___5 + t7___5 > 32767) {
#line 763
    tmp___96 = 32767;
  } else {
#line 763
    if (t0___5 + t7___5 < -32768) {
#line 763
      tmp___95 = -32768;
    } else {
#line 763
      tmp___95 = t0___5 + t7___5;
    }
#line 763
    tmp___96 = tmp___95;
  }
#line 763
  *((src + 6) + 0) = (short )(tmp___96 >> 5);
#line 763
  if (t0___5 - t7___5 > 32767) {
#line 763
    tmp___98 = 32767;
  } else {
#line 763
    if (t0___5 - t7___5 < -32768) {
#line 763
      tmp___97 = -32768;
    } else {
#line 763
      tmp___97 = t0___5 - t7___5;
    }
#line 763
    tmp___98 = tmp___97;
  }
#line 763
  *((src + 6) + 56) = (short )(tmp___98 >> 5);
#line 763
  if (t1___5 + t6___5 > 32767) {
#line 763
    tmp___100 = 32767;
  } else {
#line 763
    if (t1___5 + t6___5 < -32768) {
#line 763
      tmp___99 = -32768;
    } else {
#line 763
      tmp___99 = t1___5 + t6___5;
    }
#line 763
    tmp___100 = tmp___99;
  }
#line 763
  *((src + 6) + 8) = (short )(tmp___100 >> 5);
#line 763
  if (t1___5 - t6___5 > 32767) {
#line 763
    tmp___102 = 32767;
  } else {
#line 763
    if (t1___5 - t6___5 < -32768) {
#line 763
      tmp___101 = -32768;
    } else {
#line 763
      tmp___101 = t1___5 - t6___5;
    }
#line 763
    tmp___102 = tmp___101;
  }
#line 763
  *((src + 6) + 48) = (short )(tmp___102 >> 5);
#line 763
  if (t2___5 + t5___5 > 32767) {
#line 763
    tmp___104 = 32767;
  } else {
#line 763
    if (t2___5 + t5___5 < -32768) {
#line 763
      tmp___103 = -32768;
    } else {
#line 763
      tmp___103 = t2___5 + t5___5;
    }
#line 763
    tmp___104 = tmp___103;
  }
#line 763
  *((src + 6) + 16) = (short )(tmp___104 >> 5);
#line 763
  if (t2___5 - t5___5 > 32767) {
#line 763
    tmp___106 = 32767;
  } else {
#line 763
    if (t2___5 - t5___5 < -32768) {
#line 763
      tmp___105 = -32768;
    } else {
#line 763
      tmp___105 = t2___5 - t5___5;
    }
#line 763
    tmp___106 = tmp___105;
  }
#line 763
  *((src + 6) + 40) = (short )(tmp___106 >> 5);
#line 763
  if (t3___5 + t4___5 > 32767) {
#line 763
    tmp___108 = 32767;
  } else {
#line 763
    if (t3___5 + t4___5 < -32768) {
#line 763
      tmp___107 = -32768;
    } else {
#line 763
      tmp___107 = t3___5 + t4___5;
    }
#line 763
    tmp___108 = tmp___107;
  }
#line 763
  *((src + 6) + 24) = (short )(tmp___108 >> 5);
#line 763
  if (t3___5 - t4___5 > 32767) {
#line 763
    tmp___110 = 32767;
  } else {
#line 763
    if (t3___5 - t4___5 < -32768) {
#line 763
      tmp___109 = -32768;
    } else {
#line 763
      tmp___109 = t3___5 - t4___5;
    }
#line 763
    tmp___110 = tmp___109;
  }
#line 763
  *((src + 6) + 32) = (short )(tmp___110 >> 5);
#line 764
  tp765___6 = (int )*((src + 7) + 8) + ((int )*((src + 7) + 56) * 13036 >> 16);
#line 764
  tp465___6 = ((int )*((src + 7) + 8) * 13036 >> 16) - (int )*((src + 7) + 56);
#line 764
  tm765___6 = (((int )*((src + 7) + 40) * -21746 >> 16) + (int )*((src + 7) + 40)) + (int )*((src + 7) + 24);
#line 764
  tm465___6 = ((int )*((src + 7) + 40) - ((int )*((src + 7) + 24) * -21746 >> 16)) - (int )*((src + 7) + 24);
#line 764
  t7___6 = (tp765___6 + tm765___6) + 1;
#line 764
  tp65___6 = tp765___6 - tm765___6;
#line 764
  t4___6 = tp465___6 + tm465___6;
#line 764
  tm65___6 = (tp465___6 - tm465___6) + 1;
#line 764
  t6___6 = ((tp65___6 + tm65___6) * -19195 >> 16) | 1;
#line 764
  t6___6 += tp65___6 + tm65___6;
#line 764
  t5___6 = ((tp65___6 - tm65___6) * -19195 >> 16) | 1;
#line 764
  t5___6 += tp65___6 - tm65___6;
#line 764
  tp03___6 = (int )*((src + 7) + 0) + (int )*((src + 7) + 32);
#line 764
  tp12___6 = (int )*((src + 7) + 0) - (int )*((src + 7) + 32);
#line 764
  tm03___6 = (int )*((src + 7) + 16) + ((int )*((src + 7) + 48) * 27146 >> 16);
#line 764
  tm12___6 = ((int )*((src + 7) + 16) * 27146 >> 16) - (int )*((src + 7) + 48);
#line 764
  t0___6 = (tp03___6 + tm03___6) + 16;
#line 764
  t3___6 = (tp03___6 - tm03___6) + (int )RND_INV_CORR;
#line 764
  t1___6 = (tp12___6 + tm12___6) + 16;
#line 764
  t2___6 = (tp12___6 - tm12___6) + (int )RND_INV_CORR;
#line 764
  if (t0___6 + t7___6 > 32767) {
#line 764
    tmp___112 = 32767;
  } else {
#line 764
    if (t0___6 + t7___6 < -32768) {
#line 764
      tmp___111 = -32768;
    } else {
#line 764
      tmp___111 = t0___6 + t7___6;
    }
#line 764
    tmp___112 = tmp___111;
  }
#line 764
  *((src + 7) + 0) = (short )(tmp___112 >> 5);
#line 764
  if (t0___6 - t7___6 > 32767) {
#line 764
    tmp___114 = 32767;
  } else {
#line 764
    if (t0___6 - t7___6 < -32768) {
#line 764
      tmp___113 = -32768;
    } else {
#line 764
      tmp___113 = t0___6 - t7___6;
    }
#line 764
    tmp___114 = tmp___113;
  }
#line 764
  *((src + 7) + 56) = (short )(tmp___114 >> 5);
#line 764
  if (t1___6 + t6___6 > 32767) {
#line 764
    tmp___116 = 32767;
  } else {
#line 764
    if (t1___6 + t6___6 < -32768) {
#line 764
      tmp___115 = -32768;
    } else {
#line 764
      tmp___115 = t1___6 + t6___6;
    }
#line 764
    tmp___116 = tmp___115;
  }
#line 764
  *((src + 7) + 8) = (short )(tmp___116 >> 5);
#line 764
  if (t1___6 - t6___6 > 32767) {
#line 764
    tmp___118 = 32767;
  } else {
#line 764
    if (t1___6 - t6___6 < -32768) {
#line 764
      tmp___117 = -32768;
    } else {
#line 764
      tmp___117 = t1___6 - t6___6;
    }
#line 764
    tmp___118 = tmp___117;
  }
#line 764
  *((src + 7) + 48) = (short )(tmp___118 >> 5);
#line 764
  if (t2___6 + t5___6 > 32767) {
#line 764
    tmp___120 = 32767;
  } else {
#line 764
    if (t2___6 + t5___6 < -32768) {
#line 764
      tmp___119 = -32768;
    } else {
#line 764
      tmp___119 = t2___6 + t5___6;
    }
#line 764
    tmp___120 = tmp___119;
  }
#line 764
  *((src + 7) + 16) = (short )(tmp___120 >> 5);
#line 764
  if (t2___6 - t5___6 > 32767) {
#line 764
    tmp___122 = 32767;
  } else {
#line 764
    if (t2___6 - t5___6 < -32768) {
#line 764
      tmp___121 = -32768;
    } else {
#line 764
      tmp___121 = t2___6 - t5___6;
    }
#line 764
    tmp___122 = tmp___121;
  }
#line 764
  *((src + 7) + 40) = (short )(tmp___122 >> 5);
#line 764
  if (t3___6 + t4___6 > 32767) {
#line 764
    tmp___124 = 32767;
  } else {
#line 764
    if (t3___6 + t4___6 < -32768) {
#line 764
      tmp___123 = -32768;
    } else {
#line 764
      tmp___123 = t3___6 + t4___6;
    }
#line 764
    tmp___124 = tmp___123;
  }
#line 764
  *((src + 7) + 24) = (short )(tmp___124 >> 5);
#line 764
  if (t3___6 - t4___6 > 32767) {
#line 764
    tmp___126 = 32767;
  } else {
#line 764
    if (t3___6 - t4___6 < -32768) {
#line 764
      tmp___125 = -32768;
    } else {
#line 764
      tmp___125 = t3___6 - t4___6;
    }
#line 764
    tmp___126 = tmp___125;
  }
#line 764
  *((src + 7) + 32) = (short )(tmp___126 >> 5);
#line 765
  return;
}
}
#line 778 "src/idct.c"
void idct(short *block ) 
{ 


  {
#line 1006
  idct_M128ASM_scalar(block);
#line 1009
  return;
}
}
#line 1011 "src/idct.c"
void init_idct(void) 
{ 


  {
#line 1020
  return;
}
}
#line 1 "putpic.o"
#pragma merger("0","/tmp/cil-y_eWMDP5.i","-O4")
#line 140 "src/global.h"
void align_bits(int id ) ;
#line 164
void putpict(unsigned char *frame ) ;
#line 166
void ptputpict(unsigned char *frame , int start_mbh , int end_mbh , int pmq , int id ) ;
#line 179
void putaddrinc(int addrinc ) ;
#line 180
void putmbtype(int pict_type___0 , int mb_type ) ;
#line 182
void putdmv(int dmv ) ;
#line 183
void putcbp(int cbp ) ;
#line 189
void put_addrinc(int addrinc , int id ) ;
#line 190
void put_mbtype(int pict_type___0 , int mb_type , int id ) ;
#line 192
void put_dmv(int dmv , int id ) ;
#line 193
void put_cbp(int cbp , int id ) ;
#line 197
int quant_intra(short *src , short *dst , int dc_prec___0 , unsigned char *quant_mat ,
                int mquant ) ;
#line 199
int quant_non_intra(short *src , short *dst , unsigned char *quant_mat , int mquant ) ;
#line 214
void rc_init_pict(unsigned char *frame ) ;
#line 215
void rc_update_pict(void) ;
#line 216
int rc_start_mb(void) ;
#line 217
int rc_calc_mquant(int j ) ;
#line 218
void vbv_end_of_picture(void) ;
#line 323
unsigned char map_non_linear_mquant[113] ;
#line 345
short (*blocks)[64] ;
#line 87 "src/putpic.c"
static void put_mvs(int (*MV)[2][2] , int (*PMV)[2][2] , int (*mv_field_sel)[2] ,
                    int *dmvector , int s , int motion_type , int hor_f_code , int vert_f_code ,
                    int id ) ;
#line 94
static void putmvs(int (*MV)[2][2] , int (*PMV)[2][2] , int (*mv_field_sel)[2] , int *dmvector ,
                   int s , int motion_type , int hor_f_code , int vert_f_code ) ;
#line 100 "src/putpic.c"
void putpict(unsigned char *frame ) 
{ 
  int i ;
  int j ;
  int k ;
  int comp ;
  int cc ;
  int mb_type ;
  int PMV[2][2][2] ;
  int prev_mquant___0 ;
  int cbp ;
  int MBAinc ;
  int tmp ;
  int ind ;
  int ind___0 ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 109
  rc_init_pict(frame);
#line 112
  putpicthdr();
#line 114
  if (! mpeg1) {
#line 115
    putpictcodext();
  }
#line 117
  prev_mquant___0 = rc_start_mb();
#line 119
  k = 0;
#line 121
  j = 0;
#line 121
  while (j < mb_height2) {
#line 125
    i = 0;
#line 125
    while (i < mb_width) {
#line 128
      if (i == 0) {
#line 131
        alignbits();
#line 133
        if (mpeg1) {
#line 134
          putbits((int )(257L + (long )j), 32);
        } else
#line 133
        if (vertical_size <= 2800) {
#line 134
          putbits((int )(257L + (long )j), 32);
        } else {
#line 137
          putbits((int )(257L + (long )(j & 127)), 32);
#line 138
          putbits(j >> 7, 3);
        }
#line 142
        if (q_scale_type) {
#line 142
          tmp = (int )map_non_linear_mquant[prev_mquant___0];
        } else {
#line 142
          tmp = prev_mquant___0 >> 1;
        }
#line 142
        putbits(tmp, 5);
#line 145
        putbits(0, 1);
#line 149
        cc = 0;
#line 149
        while (cc < 3) {
#line 150
          dc_dct_pred[cc] = 0;
#line 149
          cc ++;
        }
#line 152
        PMV[1][0][1] = 0;
#line 152
        PMV[1][0][0] = PMV[1][0][1];
#line 152
        PMV[0][0][1] = PMV[1][0][0];
#line 152
        PMV[0][0][0] = PMV[0][0][1];
#line 153
        PMV[1][1][1] = 0;
#line 153
        PMV[1][1][0] = PMV[1][1][1];
#line 153
        PMV[0][1][1] = PMV[1][1][0];
#line 153
        PMV[0][1][0] = PMV[0][1][1];
#line 155
        MBAinc = i + 1;
      }
#line 158
      mb_type = (mbinfo + k)->mb_type;
#line 161
      (mbinfo + k)->mquant = rc_calc_mquant(k);
#line 164
      if (mb_type & 1) {
#line 166
        comp = 0;
#line 166
        while (comp < block_count) {
#line 167
          ind = k * block_count + comp;
#line 169
          quant_intra(*(blocks + ind), *(blocks + ind), dc_prec, intra_q, (mbinfo + k)->mquant);
#line 166
          comp ++;
        }
#line 172
        cbp = (1 << block_count) - 1;
#line 172
        (mbinfo + k)->cbp = cbp;
      } else {
#line 176
        cbp = 0;
#line 177
        comp = 0;
#line 177
        while (comp < block_count) {
#line 179
          ind___0 = k * block_count + comp;
#line 182
          tmp___0 = quant_non_intra(*(blocks + ind___0), *(blocks + ind___0), inter_q,
                                    (mbinfo + k)->mquant);
#line 182
          cbp = (cbp << 1) | tmp___0;
#line 177
          comp ++;
        }
#line 186
        (mbinfo + k)->cbp = cbp;
#line 188
        if (cbp) {
#line 189
          mb_type |= 2;
        }
      }
#line 193
      if (cbp) {
#line 193
        if (prev_mquant___0 != (mbinfo + k)->mquant) {
#line 194
          mb_type |= 16;
        }
      }
#line 197
      if (i != 0) {
#line 197
        if (i != mb_width - 1) {
#line 197
          if (! cbp) {
#line 201
            if (pict_type == 2) {
#line 201
              if (! (mb_type & 8)) {
#line 207
                cc = 0;
#line 207
                while (cc < 3) {
#line 208
                  dc_dct_pred[cc] = 0;
#line 207
                  cc ++;
                }
#line 210
                PMV[1][0][1] = 0;
#line 210
                PMV[1][0][0] = PMV[1][0][1];
#line 210
                PMV[0][0][1] = PMV[1][0][0];
#line 210
                PMV[0][0][0] = PMV[0][0][1];
#line 211
                PMV[1][1][1] = 0;
#line 211
                PMV[1][1][0] = PMV[1][1][1];
#line 211
                PMV[0][1][1] = PMV[1][1][0];
#line 211
                PMV[0][1][0] = PMV[0][1][1];
#line 213
                (mbinfo + k)->mb_type = mb_type;
#line 214
                (mbinfo + k)->skipped = 1;
#line 215
                MBAinc ++;
#line 216
                k ++;
#line 217
                goto __Cont;
              }
            }
#line 220
            if (pict_type == 3) {
#line 220
              if (pict_struct == 3) {
#line 220
                if ((mbinfo + k)->motion_type == 2) {
#line 220
                  if ((((mbinfo + (k - 1))->mb_type ^ mb_type) & 12) == 0) {
#line 220
                    if (! (mb_type & 8)) {
#line 220
                      goto _L;
                    } else
#line 220
                    if (PMV[0][0][0] == (mbinfo + k)->MV[0][0][0]) {
#line 220
                      if (PMV[0][0][1] == (mbinfo + k)->MV[0][0][1]) {
                        _L: /* CIL Label */ 
#line 220
                        if (! (mb_type & 4)) {
#line 238
                          (mbinfo + k)->mb_type = mb_type;
#line 239
                          (mbinfo + k)->skipped = 1;
#line 240
                          MBAinc ++;
#line 241
                          k ++;
#line 242
                          goto __Cont;
                        } else
#line 220
                        if (PMV[0][1][0] == (mbinfo + k)->MV[0][1][0]) {
#line 220
                          if (PMV[0][1][1] == (mbinfo + k)->MV[0][1][1]) {
#line 238
                            (mbinfo + k)->mb_type = mb_type;
#line 239
                            (mbinfo + k)->skipped = 1;
#line 240
                            MBAinc ++;
#line 241
                            k ++;
#line 242
                            goto __Cont;
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
#line 245
            if (pict_type == 3) {
#line 245
              if (pict_struct != 3) {
#line 245
                if ((mbinfo + k)->motion_type == 1) {
#line 245
                  if ((((mbinfo + (k - 1))->mb_type ^ mb_type) & 12) == 0) {
#line 245
                    if (! (mb_type & 8)) {
#line 245
                      goto _L___0;
                    } else
#line 245
                    if (PMV[0][0][0] == (mbinfo + k)->MV[0][0][0]) {
#line 245
                      if (PMV[0][0][1] == (mbinfo + k)->MV[0][0][1]) {
#line 245
                        if ((mbinfo + k)->mv_field_sel[0][0] == (pict_struct == 2)) {
                          _L___0: /* CIL Label */ 
#line 245
                          if (! (mb_type & 4)) {
#line 267
                            (mbinfo + k)->mb_type = mb_type;
#line 268
                            (mbinfo + k)->skipped = 1;
#line 269
                            MBAinc ++;
#line 270
                            k ++;
#line 271
                            goto __Cont;
                          } else
#line 245
                          if (PMV[0][1][0] == (mbinfo + k)->MV[0][1][0]) {
#line 245
                            if (PMV[0][1][1] == (mbinfo + k)->MV[0][1][1]) {
#line 245
                              if ((mbinfo + k)->mv_field_sel[0][1] == (pict_struct == 2)) {
#line 267
                                (mbinfo + k)->mb_type = mb_type;
#line 268
                                (mbinfo + k)->skipped = 1;
#line 269
                                MBAinc ++;
#line 270
                                k ++;
#line 271
                                goto __Cont;
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
#line 276
      (mbinfo + k)->skipped = 0;
#line 281
      if (pict_type == 2) {
#line 281
        if (! cbp) {
#line 281
          if (! (mb_type & 8)) {
#line 282
            mb_type |= 8;
          }
        }
      }
#line 284
      putaddrinc(MBAinc);
#line 285
      MBAinc = 1;
#line 287
      putmbtype(pict_type, mb_type);
#line 289
      if (mb_type & 12) {
#line 289
        if (! frame_pred_dct) {
#line 290
          putbits((mbinfo + k)->motion_type, 2);
        }
      }
#line 292
      if (pict_struct == 3) {
#line 292
        if (cbp) {
#line 292
          if (! frame_pred_dct) {
#line 293
            putbits((mbinfo + k)->dct_type, 1);
          }
        }
      }
#line 295
      if (mb_type & 16) {
#line 297
        if (q_scale_type) {
#line 297
          tmp___1 = (int )map_non_linear_mquant[(mbinfo + k)->mquant];
        } else {
#line 297
          tmp___1 = (mbinfo + k)->mquant >> 1;
        }
#line 297
        putbits(tmp___1, 5);
#line 299
        prev_mquant___0 = (mbinfo + k)->mquant;
      }
#line 302
      if (mb_type & 8) {
#line 305
        putmvs((int (*)[2][2])((mbinfo + k)->MV), (int (*)[2][2])(PMV), (int (*)[2])((mbinfo + k)->mv_field_sel),
               (int *)((mbinfo + k)->dmvector), 0, (mbinfo + k)->motion_type, forw_hor_f_code,
               forw_vert_f_code);
      }
#line 309
      if (mb_type & 4) {
#line 312
        putmvs((int (*)[2][2])((mbinfo + k)->MV), (int (*)[2][2])(PMV), (int (*)[2])((mbinfo + k)->mv_field_sel),
               (int *)((mbinfo + k)->dmvector), 1, (mbinfo + k)->motion_type, back_hor_f_code,
               back_vert_f_code);
      }
#line 316
      if (mb_type & 2) {
#line 318
        putcbp((cbp >> (block_count - 6)) & 63);
#line 319
        if (chroma_format != 1) {
#line 320
          putbits(cbp, block_count - 6);
        }
      }
#line 323
      comp = 0;
#line 323
      while (comp < block_count) {
#line 326
        if (cbp & (1 << ((block_count - 1) - comp))) {
#line 328
          if (mb_type & 1) {
#line 330
            if (comp < 4) {
#line 330
              cc = 0;
            } else {
#line 330
              cc = (comp & 1) + 1;
            }
#line 331
            putintrablk(*(blocks + (k * block_count + comp)), cc);
          } else {
#line 334
            putnonintrablk(*(blocks + (k * block_count + comp)));
          }
        }
#line 323
        comp ++;
      }
#line 339
      if (! (mb_type & 1)) {
#line 340
        cc = 0;
#line 340
        while (cc < 3) {
#line 341
          dc_dct_pred[cc] = 0;
#line 340
          cc ++;
        }
      }
#line 343
      if (mb_type & 1) {
#line 343
        goto _L___1;
      } else
#line 343
      if (pict_type == 2) {
#line 343
        if (! (mb_type & 8)) {
          _L___1: /* CIL Label */ 
#line 345
          PMV[1][0][1] = 0;
#line 345
          PMV[1][0][0] = PMV[1][0][1];
#line 345
          PMV[0][0][1] = PMV[1][0][0];
#line 345
          PMV[0][0][0] = PMV[0][0][1];
#line 346
          PMV[1][1][1] = 0;
#line 346
          PMV[1][1][0] = PMV[1][1][1];
#line 346
          PMV[0][1][1] = PMV[1][1][0];
#line 346
          PMV[0][1][0] = PMV[0][1][1];
        }
      }
#line 349
      (mbinfo + k)->mb_type = mb_type;
#line 350
      k ++;
      __Cont: /* CIL Label */ 
#line 125
      i ++;
    }
#line 121
    j ++;
  }
#line 354
  rc_update_pict();
#line 355
  vbv_end_of_picture();
#line 356
  return;
}
}
#line 363 "src/putpic.c"
void ptputpict(unsigned char *frame , int start_mbh , int end_mbh , int pmq , int id ) 
{ 
  int i ;
  int j ;
  int k ;
  int comp ;
  int cc ;
  int mb_type ;
  int PMV[2][2][2] ;
  int prev_mquant___0 ;
  int cbp ;
  int MBAinc ;
  int tmp ;
  int tmp___0 ;

  {
#line 373
  k = start_mbh * mb_width;
#line 374
  prev_mquant___0 = pmq;
#line 376
  j = start_mbh;
#line 376
  while (j < end_mbh) {
#line 380
    i = 0;
#line 380
    while (i < mb_width) {
#line 383
      if (i == 0) {
#line 386
        align_bits(id);
#line 388
        if (mpeg1) {
#line 389
          put_bits((int )(257L + (long )j), 32, id);
        } else
#line 388
        if (vertical_size <= 2800) {
#line 389
          put_bits((int )(257L + (long )j), 32, id);
        } else {
#line 392
          put_bits((int )(257L + (long )(j & 127)), 32, id);
#line 393
          put_bits(j >> 7, 3, id);
        }
#line 397
        if (q_scale_type) {
#line 397
          tmp = (int )map_non_linear_mquant[prev_mquant___0];
        } else {
#line 397
          tmp = prev_mquant___0 >> 1;
        }
#line 397
        put_bits(tmp, 5, id);
#line 400
        put_bits(0, 1, id);
#line 404
        cc = 0;
#line 404
        while (cc < 3) {
#line 405
          pt_dc_dct_pred[id][cc] = 0;
#line 404
          cc ++;
        }
#line 407
        PMV[1][0][1] = 0;
#line 407
        PMV[1][0][0] = PMV[1][0][1];
#line 407
        PMV[0][0][1] = PMV[1][0][0];
#line 407
        PMV[0][0][0] = PMV[0][0][1];
#line 408
        PMV[1][1][1] = 0;
#line 408
        PMV[1][1][0] = PMV[1][1][1];
#line 408
        PMV[0][1][1] = PMV[1][1][0];
#line 408
        PMV[0][1][0] = PMV[0][1][1];
#line 410
        MBAinc = i + 1;
      }
#line 413
      mb_type = (mbinfo + k)->mb_type;
#line 417
      (mbinfo + k)->mquant = 20;
#line 419
      cbp = (mbinfo + k)->cbp;
#line 420
      if (! (mb_type & 1)) {
#line 420
        if (cbp) {
#line 421
          mb_type |= 2;
        }
      }
#line 455
      if (cbp) {
#line 455
        if (prev_mquant___0 != (mbinfo + k)->mquant) {
#line 456
          mb_type |= 16;
        }
      }
#line 459
      if (i != 0) {
#line 459
        if (i != mb_width - 1) {
#line 459
          if (! cbp) {
#line 463
            if (pict_type == 2) {
#line 463
              if (! (mb_type & 8)) {
#line 469
                cc = 0;
#line 469
                while (cc < 3) {
#line 470
                  pt_dc_dct_pred[id][cc] = 0;
#line 469
                  cc ++;
                }
#line 472
                PMV[1][0][1] = 0;
#line 472
                PMV[1][0][0] = PMV[1][0][1];
#line 472
                PMV[0][0][1] = PMV[1][0][0];
#line 472
                PMV[0][0][0] = PMV[0][0][1];
#line 473
                PMV[1][1][1] = 0;
#line 473
                PMV[1][1][0] = PMV[1][1][1];
#line 473
                PMV[0][1][1] = PMV[1][1][0];
#line 473
                PMV[0][1][0] = PMV[0][1][1];
#line 475
                (mbinfo + k)->mb_type = mb_type;
#line 476
                (mbinfo + k)->skipped = 1;
#line 477
                MBAinc ++;
#line 478
                k ++;
#line 479
                goto __Cont;
              }
            }
#line 482
            if (pict_type == 3) {
#line 482
              if (pict_struct == 3) {
#line 482
                if ((mbinfo + k)->motion_type == 2) {
#line 482
                  if ((((mbinfo + (k - 1))->mb_type ^ mb_type) & 12) == 0) {
#line 482
                    if (! (mb_type & 8)) {
#line 482
                      goto _L;
                    } else
#line 482
                    if (PMV[0][0][0] == (mbinfo + k)->MV[0][0][0]) {
#line 482
                      if (PMV[0][0][1] == (mbinfo + k)->MV[0][0][1]) {
                        _L: /* CIL Label */ 
#line 482
                        if (! (mb_type & 4)) {
#line 500
                          (mbinfo + k)->mb_type = mb_type;
#line 501
                          (mbinfo + k)->skipped = 1;
#line 502
                          MBAinc ++;
#line 503
                          k ++;
#line 504
                          goto __Cont;
                        } else
#line 482
                        if (PMV[0][1][0] == (mbinfo + k)->MV[0][1][0]) {
#line 482
                          if (PMV[0][1][1] == (mbinfo + k)->MV[0][1][1]) {
#line 500
                            (mbinfo + k)->mb_type = mb_type;
#line 501
                            (mbinfo + k)->skipped = 1;
#line 502
                            MBAinc ++;
#line 503
                            k ++;
#line 504
                            goto __Cont;
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
#line 507
            if (pict_type == 3) {
#line 507
              if (pict_struct != 3) {
#line 507
                if ((mbinfo + k)->motion_type == 1) {
#line 507
                  if ((((mbinfo + (k - 1))->mb_type ^ mb_type) & 12) == 0) {
#line 507
                    if (! (mb_type & 8)) {
#line 507
                      goto _L___0;
                    } else
#line 507
                    if (PMV[0][0][0] == (mbinfo + k)->MV[0][0][0]) {
#line 507
                      if (PMV[0][0][1] == (mbinfo + k)->MV[0][0][1]) {
#line 507
                        if ((mbinfo + k)->mv_field_sel[0][0] == (pict_struct == 2)) {
                          _L___0: /* CIL Label */ 
#line 507
                          if (! (mb_type & 4)) {
#line 529
                            (mbinfo + k)->mb_type = mb_type;
#line 530
                            (mbinfo + k)->skipped = 1;
#line 531
                            MBAinc ++;
#line 532
                            k ++;
#line 533
                            goto __Cont;
                          } else
#line 507
                          if (PMV[0][1][0] == (mbinfo + k)->MV[0][1][0]) {
#line 507
                            if (PMV[0][1][1] == (mbinfo + k)->MV[0][1][1]) {
#line 507
                              if ((mbinfo + k)->mv_field_sel[0][1] == (pict_struct == 2)) {
#line 529
                                (mbinfo + k)->mb_type = mb_type;
#line 530
                                (mbinfo + k)->skipped = 1;
#line 531
                                MBAinc ++;
#line 532
                                k ++;
#line 533
                                goto __Cont;
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
#line 538
      (mbinfo + k)->skipped = 0;
#line 543
      if (pict_type == 2) {
#line 543
        if (! cbp) {
#line 543
          if (! (mb_type & 8)) {
#line 544
            mb_type |= 8;
          }
        }
      }
#line 546
      put_addrinc(MBAinc, id);
#line 547
      MBAinc = 1;
#line 549
      put_mbtype(pict_type, mb_type, id);
#line 551
      if (mb_type & 12) {
#line 551
        if (! frame_pred_dct) {
#line 552
          put_bits((mbinfo + k)->motion_type, 2, id);
        }
      }
#line 554
      if (pict_struct == 3) {
#line 554
        if (cbp) {
#line 554
          if (! frame_pred_dct) {
#line 555
            put_bits((mbinfo + k)->dct_type, 1, id);
          }
        }
      }
#line 557
      if (mb_type & 16) {
#line 559
        if (q_scale_type) {
#line 559
          tmp___0 = (int )map_non_linear_mquant[(mbinfo + k)->mquant];
        } else {
#line 559
          tmp___0 = (mbinfo + k)->mquant >> 1;
        }
#line 559
        put_bits(tmp___0, 5, id);
#line 561
        prev_mquant___0 = (mbinfo + k)->mquant;
      }
#line 564
      if (mb_type & 8) {
#line 567
        put_mvs((int (*)[2][2])((mbinfo + k)->MV), (int (*)[2][2])(PMV), (int (*)[2])((mbinfo + k)->mv_field_sel),
                (int *)((mbinfo + k)->dmvector), 0, (mbinfo + k)->motion_type, forw_hor_f_code,
                forw_vert_f_code, id);
      }
#line 571
      if (mb_type & 4) {
#line 574
        put_mvs((int (*)[2][2])((mbinfo + k)->MV), (int (*)[2][2])(PMV), (int (*)[2])((mbinfo + k)->mv_field_sel),
                (int *)((mbinfo + k)->dmvector), 1, (mbinfo + k)->motion_type, back_hor_f_code,
                back_vert_f_code, id);
      }
#line 578
      if (mb_type & 2) {
#line 580
        put_cbp((cbp >> (block_count - 6)) & 63, id);
#line 581
        if (chroma_format != 1) {
#line 582
          put_bits(cbp, block_count - 6, id);
        }
      }
#line 585
      comp = 0;
#line 585
      while (comp < block_count) {
#line 588
        if (cbp & (1 << ((block_count - 1) - comp))) {
#line 590
          if (mb_type & 1) {
#line 592
            if (comp < 4) {
#line 592
              cc = 0;
            } else {
#line 592
              cc = (comp & 1) + 1;
            }
#line 593
            put_intrablk(*(blocks + (k * block_count + comp)), cc, id);
          } else {
#line 596
            put_nonintrablk(*(blocks + (k * block_count + comp)), id);
          }
        }
#line 585
        comp ++;
      }
#line 601
      if (! (mb_type & 1)) {
#line 602
        cc = 0;
#line 602
        while (cc < 3) {
#line 603
          pt_dc_dct_pred[id][cc] = 0;
#line 602
          cc ++;
        }
      }
#line 605
      if (mb_type & 1) {
#line 605
        goto _L___1;
      } else
#line 605
      if (pict_type == 2) {
#line 605
        if (! (mb_type & 8)) {
          _L___1: /* CIL Label */ 
#line 607
          PMV[1][0][1] = 0;
#line 607
          PMV[1][0][0] = PMV[1][0][1];
#line 607
          PMV[0][0][1] = PMV[1][0][0];
#line 607
          PMV[0][0][0] = PMV[0][0][1];
#line 608
          PMV[1][1][1] = 0;
#line 608
          PMV[1][1][0] = PMV[1][1][1];
#line 608
          PMV[0][1][1] = PMV[1][1][0];
#line 608
          PMV[0][1][0] = PMV[0][1][1];
        }
      }
#line 611
      (mbinfo + k)->mb_type = mb_type;
#line 612
      k ++;
      __Cont: /* CIL Label */ 
#line 380
      i ++;
    }
#line 376
    j ++;
  }
#line 616
  return;
}
}
#line 623 "src/putpic.c"
static void put_mvs(int (*MV)[2][2] , int (*PMV)[2][2] , int (*mv_field_sel)[2] ,
                    int *dmvector , int s , int motion_type , int hor_f_code , int vert_f_code ,
                    int id ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
#line 630
  if (pict_struct == 3) {
#line 632
    if (motion_type == 2) {
#line 635
      put_mv((*(MV + 0))[s][0] - (*(PMV + 0))[s][0], hor_f_code, id);
#line 636
      put_mv((*(MV + 0))[s][1] - (*(PMV + 0))[s][1], vert_f_code, id);
#line 637
      tmp = (*(MV + 0))[s][0];
#line 637
      (*(PMV + 1))[s][0] = tmp;
#line 637
      (*(PMV + 0))[s][0] = tmp;
#line 638
      tmp___0 = (*(MV + 0))[s][1];
#line 638
      (*(PMV + 1))[s][1] = tmp___0;
#line 638
      (*(PMV + 0))[s][1] = tmp___0;
    } else
#line 640
    if (motion_type == 1) {
#line 643
      put_bits((*(mv_field_sel + 0))[s], 1, id);
#line 644
      put_mv((*(MV + 0))[s][0] - (*(PMV + 0))[s][0], hor_f_code, id);
#line 645
      put_mv(((*(MV + 0))[s][1] >> 1) - ((*(PMV + 0))[s][1] >> 1), vert_f_code, id);
#line 646
      put_bits((*(mv_field_sel + 1))[s], 1, id);
#line 647
      put_mv((*(MV + 1))[s][0] - (*(PMV + 1))[s][0], hor_f_code, id);
#line 648
      put_mv(((*(MV + 1))[s][1] >> 1) - ((*(PMV + 1))[s][1] >> 1), vert_f_code, id);
#line 649
      (*(PMV + 0))[s][0] = (*(MV + 0))[s][0];
#line 650
      (*(PMV + 0))[s][1] = (*(MV + 0))[s][1];
#line 651
      (*(PMV + 1))[s][0] = (*(MV + 1))[s][0];
#line 652
      (*(PMV + 1))[s][1] = (*(MV + 1))[s][1];
    } else {
#line 657
      put_mv((*(MV + 0))[s][0] - (*(PMV + 0))[s][0], hor_f_code, id);
#line 658
      put_dmv(*(dmvector + 0), id);
#line 659
      put_mv(((*(MV + 0))[s][1] >> 1) - ((*(PMV + 0))[s][1] >> 1), vert_f_code, id);
#line 660
      put_dmv(*(dmvector + 1), id);
#line 661
      tmp___1 = (*(MV + 0))[s][0];
#line 661
      (*(PMV + 1))[s][0] = tmp___1;
#line 661
      (*(PMV + 0))[s][0] = tmp___1;
#line 662
      tmp___2 = (*(MV + 0))[s][1];
#line 662
      (*(PMV + 1))[s][1] = tmp___2;
#line 662
      (*(PMV + 0))[s][1] = tmp___2;
    }
  } else
#line 668
  if (motion_type == 1) {
#line 671
    put_bits((*(mv_field_sel + 0))[s], 1, id);
#line 672
    put_mv((*(MV + 0))[s][0] - (*(PMV + 0))[s][0], hor_f_code, id);
#line 673
    put_mv((*(MV + 0))[s][1] - (*(PMV + 0))[s][1], vert_f_code, id);
#line 674
    tmp___3 = (*(MV + 0))[s][0];
#line 674
    (*(PMV + 1))[s][0] = tmp___3;
#line 674
    (*(PMV + 0))[s][0] = tmp___3;
#line 675
    tmp___4 = (*(MV + 0))[s][1];
#line 675
    (*(PMV + 1))[s][1] = tmp___4;
#line 675
    (*(PMV + 0))[s][1] = tmp___4;
  } else
#line 677
  if (motion_type == 2) {
#line 680
    put_bits((*(mv_field_sel + 0))[s], 1, id);
#line 681
    put_mv((*(MV + 0))[s][0] - (*(PMV + 0))[s][0], hor_f_code, id);
#line 682
    put_mv((*(MV + 0))[s][1] - (*(PMV + 0))[s][1], vert_f_code, id);
#line 683
    put_bits((*(mv_field_sel + 1))[s], 1, id);
#line 684
    put_mv((*(MV + 1))[s][0] - (*(PMV + 1))[s][0], hor_f_code, id);
#line 685
    put_mv((*(MV + 1))[s][1] - (*(PMV + 1))[s][1], vert_f_code, id);
#line 686
    (*(PMV + 0))[s][0] = (*(MV + 0))[s][0];
#line 687
    (*(PMV + 0))[s][1] = (*(MV + 0))[s][1];
#line 688
    (*(PMV + 1))[s][0] = (*(MV + 1))[s][0];
#line 689
    (*(PMV + 1))[s][1] = (*(MV + 1))[s][1];
  } else {
#line 694
    put_mv((*(MV + 0))[s][0] - (*(PMV + 0))[s][0], hor_f_code, id);
#line 695
    put_dmv(*(dmvector + 0), id);
#line 696
    put_mv((*(MV + 0))[s][1] - (*(PMV + 0))[s][1], vert_f_code, id);
#line 697
    put_dmv(*(dmvector + 1), id);
#line 698
    tmp___5 = (*(MV + 0))[s][0];
#line 698
    (*(PMV + 1))[s][0] = tmp___5;
#line 698
    (*(PMV + 0))[s][0] = tmp___5;
#line 699
    tmp___6 = (*(MV + 0))[s][1];
#line 699
    (*(PMV + 1))[s][1] = tmp___6;
#line 699
    (*(PMV + 0))[s][1] = tmp___6;
  }
#line 702
  return;
}
}
#line 705 "src/putpic.c"
static void putmvs(int (*MV)[2][2] , int (*PMV)[2][2] , int (*mv_field_sel)[2] , int *dmvector ,
                   int s , int motion_type , int hor_f_code , int vert_f_code ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
#line 712
  if (pict_struct == 3) {
#line 714
    if (motion_type == 2) {
#line 717
      putmv((*(MV + 0))[s][0] - (*(PMV + 0))[s][0], hor_f_code);
#line 718
      putmv((*(MV + 0))[s][1] - (*(PMV + 0))[s][1], vert_f_code);
#line 719
      tmp = (*(MV + 0))[s][0];
#line 719
      (*(PMV + 1))[s][0] = tmp;
#line 719
      (*(PMV + 0))[s][0] = tmp;
#line 720
      tmp___0 = (*(MV + 0))[s][1];
#line 720
      (*(PMV + 1))[s][1] = tmp___0;
#line 720
      (*(PMV + 0))[s][1] = tmp___0;
    } else
#line 722
    if (motion_type == 1) {
#line 725
      putbits((*(mv_field_sel + 0))[s], 1);
#line 726
      putmv((*(MV + 0))[s][0] - (*(PMV + 0))[s][0], hor_f_code);
#line 727
      putmv(((*(MV + 0))[s][1] >> 1) - ((*(PMV + 0))[s][1] >> 1), vert_f_code);
#line 728
      putbits((*(mv_field_sel + 1))[s], 1);
#line 729
      putmv((*(MV + 1))[s][0] - (*(PMV + 1))[s][0], hor_f_code);
#line 730
      putmv(((*(MV + 1))[s][1] >> 1) - ((*(PMV + 1))[s][1] >> 1), vert_f_code);
#line 731
      (*(PMV + 0))[s][0] = (*(MV + 0))[s][0];
#line 732
      (*(PMV + 0))[s][1] = (*(MV + 0))[s][1];
#line 733
      (*(PMV + 1))[s][0] = (*(MV + 1))[s][0];
#line 734
      (*(PMV + 1))[s][1] = (*(MV + 1))[s][1];
    } else {
#line 739
      putmv((*(MV + 0))[s][0] - (*(PMV + 0))[s][0], hor_f_code);
#line 740
      putdmv(*(dmvector + 0));
#line 741
      putmv(((*(MV + 0))[s][1] >> 1) - ((*(PMV + 0))[s][1] >> 1), vert_f_code);
#line 742
      putdmv(*(dmvector + 1));
#line 743
      tmp___1 = (*(MV + 0))[s][0];
#line 743
      (*(PMV + 1))[s][0] = tmp___1;
#line 743
      (*(PMV + 0))[s][0] = tmp___1;
#line 744
      tmp___2 = (*(MV + 0))[s][1];
#line 744
      (*(PMV + 1))[s][1] = tmp___2;
#line 744
      (*(PMV + 0))[s][1] = tmp___2;
    }
  } else
#line 750
  if (motion_type == 1) {
#line 753
    putbits((*(mv_field_sel + 0))[s], 1);
#line 754
    putmv((*(MV + 0))[s][0] - (*(PMV + 0))[s][0], hor_f_code);
#line 755
    putmv((*(MV + 0))[s][1] - (*(PMV + 0))[s][1], vert_f_code);
#line 756
    tmp___3 = (*(MV + 0))[s][0];
#line 756
    (*(PMV + 1))[s][0] = tmp___3;
#line 756
    (*(PMV + 0))[s][0] = tmp___3;
#line 757
    tmp___4 = (*(MV + 0))[s][1];
#line 757
    (*(PMV + 1))[s][1] = tmp___4;
#line 757
    (*(PMV + 0))[s][1] = tmp___4;
  } else
#line 759
  if (motion_type == 2) {
#line 762
    putbits((*(mv_field_sel + 0))[s], 1);
#line 763
    putmv((*(MV + 0))[s][0] - (*(PMV + 0))[s][0], hor_f_code);
#line 764
    putmv((*(MV + 0))[s][1] - (*(PMV + 0))[s][1], vert_f_code);
#line 765
    putbits((*(mv_field_sel + 1))[s], 1);
#line 766
    putmv((*(MV + 1))[s][0] - (*(PMV + 1))[s][0], hor_f_code);
#line 767
    putmv((*(MV + 1))[s][1] - (*(PMV + 1))[s][1], vert_f_code);
#line 768
    (*(PMV + 0))[s][0] = (*(MV + 0))[s][0];
#line 769
    (*(PMV + 0))[s][1] = (*(MV + 0))[s][1];
#line 770
    (*(PMV + 1))[s][0] = (*(MV + 1))[s][0];
#line 771
    (*(PMV + 1))[s][1] = (*(MV + 1))[s][1];
  } else {
#line 776
    putmv((*(MV + 0))[s][0] - (*(PMV + 0))[s][0], hor_f_code);
#line 777
    putdmv(*(dmvector + 0));
#line 778
    putmv((*(MV + 0))[s][1] - (*(PMV + 0))[s][1], vert_f_code);
#line 779
    putdmv(*(dmvector + 1));
#line 780
    tmp___5 = (*(MV + 0))[s][0];
#line 780
    (*(PMV + 1))[s][0] = tmp___5;
#line 780
    (*(PMV + 0))[s][0] = tmp___5;
#line 781
    tmp___6 = (*(MV + 0))[s][1];
#line 781
    (*(PMV + 1))[s][1] = tmp___6;
#line 781
    (*(PMV + 0))[s][1] = tmp___6;
  }
#line 784
  return;
}
}
#line 1 "transfrm.o"
#pragma merger("0","/tmp/cil-peR52ySB.i","-O4")
#line 157 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h"
extern  __attribute__((__nothrow__)) double ( __attribute__((__leaf__)) sqrt)(double __x ) ;
#line 150 "/usr/include/x86_64-linux-gnu/bits/mathinline.h"
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__, __always_inline__)) __signbitl)(long double __x )  __attribute__((__const__)) ;
#line 150 "/usr/include/x86_64-linux-gnu/bits/mathinline.h"
__inline extern int ( __attribute__((__leaf__, __always_inline__)) __signbitl)(long double __x ) 
{ 
  union __anonunion___u_8___1 __u ;

  {
#line 153
  __u.__l = __x;
#line 154
  return ((__u.__i[2] & 32768) != 0);
}
}
#line 229 "src/global.h"
void transform(unsigned char **pred___0 , unsigned char **cur , struct mbinfo *mbi ,
               short (*blocks___0)[64] ) ;
#line 231
void itransform(unsigned char **pred___0 , unsigned char **cur , struct mbinfo *mbi ,
                short (*blocks___0)[64] ) ;
#line 233
void dct_type_estimation(unsigned char *pred___0 , unsigned char *cur , struct mbinfo *mbi ) ;
#line 236
void ptdct_type_estimation(unsigned char *pred___0 , unsigned char *cur , struct mbinfo *mbi ,
                           int start_height , int end_height ) ;
#line 238
void pttransform(unsigned char **pred___0 , unsigned char **cur , struct mbinfo *mbi ,
                 short (*blocks___0)[64] , int start_height , int end_height ) ;
#line 240
void ptitransform(unsigned char **pred___0 , unsigned char **cur , struct mbinfo *mbi ,
                  short (*blocks___0)[64] , int start_height , int end_height ) ;
#line 388
int height2 ;
#line 87 "src/transfrm.c"
static void add_pred(unsigned char *pred___0 , unsigned char *cur , int lx , short *blk ) ;
#line 89
static void sub_pred(unsigned char *pred___0 , unsigned char *cur , int lx , short *blk ) ;
#line 93 "src/transfrm.c"
void transform(unsigned char **pred___0 , unsigned char **cur , struct mbinfo *mbi ,
               short (*blocks___0)[64] ) 
{ 
  int i ;
  int j ;
  int i1 ;
  int j1___0 ;
  int k ;
  int n ;
  int cc ;
  int offs ;
  int lx ;

  {
#line 100
  k = 0;
#line 102
  j = 0;
#line 102
  while (j < height2) {
#line 103
    i = 0;
#line 103
    while (i < width) {
#line 105
      n = 0;
#line 105
      while (n < block_count) {
#line 107
        if (n < 4) {
#line 107
          cc = 0;
        } else {
#line 107
          cc = (n & 1) + 1;
        }
#line 108
        if (cc == 0) {
#line 111
          if (pict_struct == 3) {
#line 111
            if ((mbi + k)->dct_type) {
#line 114
              offs = (i + ((n & 1) << 3)) + width * (j + ((n & 2) >> 1));
#line 115
              lx = width << 1;
            } else {
#line 120
              offs = (i + ((n & 1) << 3)) + width2 * (j + ((n & 2) << 2));
#line 121
              lx = width2;
            }
          } else {
#line 120
            offs = (i + ((n & 1) << 3)) + width2 * (j + ((n & 2) << 2));
#line 121
            lx = width2;
          }
#line 124
          if (pict_struct == 2) {
#line 125
            offs += width;
          }
        } else {
#line 132
          if (chroma_format == 3) {
#line 132
            i1 = i;
          } else {
#line 132
            i1 = i >> 1;
          }
#line 133
          if (chroma_format != 1) {
#line 133
            j1___0 = j;
          } else {
#line 133
            j1___0 = j >> 1;
          }
#line 135
          if (pict_struct == 3) {
#line 135
            if ((mbi + k)->dct_type) {
#line 135
              if (chroma_format != 1) {
#line 139
                offs = (i1 + (n & 8)) + chrom_width * (j1___0 + ((n & 2) >> 1));
#line 140
                lx = chrom_width << 1;
              } else {
#line 145
                offs = (i1 + (n & 8)) + chrom_width2 * (j1___0 + ((n & 2) << 2));
#line 146
                lx = chrom_width2;
              }
            } else {
#line 145
              offs = (i1 + (n & 8)) + chrom_width2 * (j1___0 + ((n & 2) << 2));
#line 146
              lx = chrom_width2;
            }
          } else {
#line 145
            offs = (i1 + (n & 8)) + chrom_width2 * (j1___0 + ((n & 2) << 2));
#line 146
            lx = chrom_width2;
          }
#line 149
          if (pict_struct == 2) {
#line 150
            offs += chrom_width;
          }
        }
#line 155
        sub_pred(*(pred___0 + cc) + offs, *(cur + cc) + offs, lx, *(blocks___0 + (k * block_count + n)));
#line 156
        fdct(*(blocks___0 + (k * block_count + n)));
#line 105
        n ++;
      }
#line 159
      k ++;
#line 103
      i += 16;
    }
#line 102
    j += 16;
  }
#line 162
  return;
}
}
#line 166 "src/transfrm.c"
void pttransform(unsigned char **pred___0 , unsigned char **cur , struct mbinfo *mbi ,
                 short (*blocks___0)[64] , int start_height , int end_height ) 
{ 
  int i ;
  int j ;
  int i1 ;
  int j1___0 ;
  int k ;
  int n ;
  int cc ;
  int offs ;
  int lx ;

  {
#line 174
  k = (start_height >> 4) * (width >> 4);
#line 176
  j = start_height;
#line 176
  while (j < end_height) {
#line 177
    i = 0;
#line 177
    while (i < width) {
#line 179
      n = 0;
#line 179
      while (n < block_count) {
#line 181
        if (n < 4) {
#line 181
          cc = 0;
        } else {
#line 181
          cc = (n & 1) + 1;
        }
#line 182
        if (cc == 0) {
#line 185
          if (pict_struct == 3) {
#line 185
            if ((mbi + k)->dct_type) {
#line 188
              offs = (i + ((n & 1) << 3)) + width * (j + ((n & 2) >> 1));
#line 189
              lx = width << 1;
            } else {
#line 194
              offs = (i + ((n & 1) << 3)) + width2 * (j + ((n & 2) << 2));
#line 195
              lx = width2;
            }
          } else {
#line 194
            offs = (i + ((n & 1) << 3)) + width2 * (j + ((n & 2) << 2));
#line 195
            lx = width2;
          }
#line 198
          if (pict_struct == 2) {
#line 199
            offs += width;
          }
        } else {
#line 206
          if (chroma_format == 3) {
#line 206
            i1 = i;
          } else {
#line 206
            i1 = i >> 1;
          }
#line 207
          if (chroma_format != 1) {
#line 207
            j1___0 = j;
          } else {
#line 207
            j1___0 = j >> 1;
          }
#line 209
          if (pict_struct == 3) {
#line 209
            if ((mbi + k)->dct_type) {
#line 209
              if (chroma_format != 1) {
#line 213
                offs = (i1 + (n & 8)) + chrom_width * (j1___0 + ((n & 2) >> 1));
#line 214
                lx = chrom_width << 1;
              } else {
#line 219
                offs = (i1 + (n & 8)) + chrom_width2 * (j1___0 + ((n & 2) << 2));
#line 220
                lx = chrom_width2;
              }
            } else {
#line 219
              offs = (i1 + (n & 8)) + chrom_width2 * (j1___0 + ((n & 2) << 2));
#line 220
              lx = chrom_width2;
            }
          } else {
#line 219
            offs = (i1 + (n & 8)) + chrom_width2 * (j1___0 + ((n & 2) << 2));
#line 220
            lx = chrom_width2;
          }
#line 223
          if (pict_struct == 2) {
#line 224
            offs += chrom_width;
          }
        }
#line 229
        sub_pred(*(pred___0 + cc) + offs, *(cur + cc) + offs, lx, *(blocks___0 + (k * block_count + n)));
#line 230
        fdct(*(blocks___0 + (k * block_count + n)));
#line 179
        n ++;
      }
#line 233
      k ++;
#line 177
      i += 16;
    }
#line 176
    j += 16;
  }
#line 236
  return;
}
}
#line 238 "src/transfrm.c"
void ptitransform(unsigned char **pred___0 , unsigned char **cur , struct mbinfo *mbi ,
                  short (*blocks___0)[64] , int start_height , int end_height ) 
{ 
  int i ;
  int j ;
  int i1 ;
  int j1___0 ;
  int k ;
  int n ;
  int cc ;
  int offs ;
  int lx ;

  {
#line 247
  k = (start_height >> 4) * (width >> 4);
#line 249
  j = start_height;
#line 249
  while (j < end_height) {
#line 250
    i = 0;
#line 250
    while (i < width) {
#line 252
      n = 0;
#line 252
      while (n < block_count) {
#line 254
        if (n < 4) {
#line 254
          cc = 0;
        } else {
#line 254
          cc = (n & 1) + 1;
        }
#line 256
        if (cc == 0) {
#line 259
          if (pict_struct == 3) {
#line 259
            if ((mbi + k)->dct_type) {
#line 262
              offs = (i + ((n & 1) << 3)) + width * (j + ((n & 2) >> 1));
#line 263
              lx = width << 1;
            } else {
#line 268
              offs = (i + ((n & 1) << 3)) + width2 * (j + ((n & 2) << 2));
#line 269
              lx = width2;
            }
          } else {
#line 268
            offs = (i + ((n & 1) << 3)) + width2 * (j + ((n & 2) << 2));
#line 269
            lx = width2;
          }
#line 272
          if (pict_struct == 2) {
#line 273
            offs += width;
          }
        } else {
#line 280
          if (chroma_format == 3) {
#line 280
            i1 = i;
          } else {
#line 280
            i1 = i >> 1;
          }
#line 281
          if (chroma_format != 1) {
#line 281
            j1___0 = j;
          } else {
#line 281
            j1___0 = j >> 1;
          }
#line 283
          if (pict_struct == 3) {
#line 283
            if ((mbi + k)->dct_type) {
#line 283
              if (chroma_format != 1) {
#line 287
                offs = (i1 + (n & 8)) + chrom_width * (j1___0 + ((n & 2) >> 1));
#line 288
                lx = chrom_width << 1;
              } else {
#line 293
                offs = (i1 + (n & 8)) + chrom_width2 * (j1___0 + ((n & 2) << 2));
#line 294
                lx = chrom_width2;
              }
            } else {
#line 293
              offs = (i1 + (n & 8)) + chrom_width2 * (j1___0 + ((n & 2) << 2));
#line 294
              lx = chrom_width2;
            }
          } else {
#line 293
            offs = (i1 + (n & 8)) + chrom_width2 * (j1___0 + ((n & 2) << 2));
#line 294
            lx = chrom_width2;
          }
#line 297
          if (pict_struct == 2) {
#line 298
            offs += chrom_width;
          }
        }
#line 301
        idct(*(blocks___0 + (k * block_count + n)));
#line 302
        add_pred(*(pred___0 + cc) + offs, *(cur + cc) + offs, lx, *(blocks___0 + (k * block_count + n)));
#line 252
        n ++;
      }
#line 305
      k ++;
#line 250
      i += 16;
    }
#line 249
    j += 16;
  }
#line 308
  return;
}
}
#line 313 "src/transfrm.c"
void itransform(unsigned char **pred___0 , unsigned char **cur , struct mbinfo *mbi ,
                short (*blocks___0)[64] ) 
{ 
  int i ;
  int j ;
  int i1 ;
  int j1___0 ;
  int k ;
  int n ;
  int cc ;
  int offs ;
  int lx ;

  {
#line 320
  k = 0;
#line 322
  j = 0;
#line 322
  while (j < height2) {
#line 323
    i = 0;
#line 323
    while (i < width) {
#line 325
      n = 0;
#line 325
      while (n < block_count) {
#line 327
        if (n < 4) {
#line 327
          cc = 0;
        } else {
#line 327
          cc = (n & 1) + 1;
        }
#line 329
        if (cc == 0) {
#line 332
          if (pict_struct == 3) {
#line 332
            if ((mbi + k)->dct_type) {
#line 335
              offs = (i + ((n & 1) << 3)) + width * (j + ((n & 2) >> 1));
#line 336
              lx = width << 1;
            } else {
#line 341
              offs = (i + ((n & 1) << 3)) + width2 * (j + ((n & 2) << 2));
#line 342
              lx = width2;
            }
          } else {
#line 341
            offs = (i + ((n & 1) << 3)) + width2 * (j + ((n & 2) << 2));
#line 342
            lx = width2;
          }
#line 345
          if (pict_struct == 2) {
#line 346
            offs += width;
          }
        } else {
#line 353
          if (chroma_format == 3) {
#line 353
            i1 = i;
          } else {
#line 353
            i1 = i >> 1;
          }
#line 354
          if (chroma_format != 1) {
#line 354
            j1___0 = j;
          } else {
#line 354
            j1___0 = j >> 1;
          }
#line 356
          if (pict_struct == 3) {
#line 356
            if ((mbi + k)->dct_type) {
#line 356
              if (chroma_format != 1) {
#line 360
                offs = (i1 + (n & 8)) + chrom_width * (j1___0 + ((n & 2) >> 1));
#line 361
                lx = chrom_width << 1;
              } else {
#line 366
                offs = (i1 + (n & 8)) + chrom_width2 * (j1___0 + ((n & 2) << 2));
#line 367
                lx = chrom_width2;
              }
            } else {
#line 366
              offs = (i1 + (n & 8)) + chrom_width2 * (j1___0 + ((n & 2) << 2));
#line 367
              lx = chrom_width2;
            }
          } else {
#line 366
            offs = (i1 + (n & 8)) + chrom_width2 * (j1___0 + ((n & 2) << 2));
#line 367
            lx = chrom_width2;
          }
#line 370
          if (pict_struct == 2) {
#line 371
            offs += chrom_width;
          }
        }
#line 374
        idct(*(blocks___0 + (k * block_count + n)));
#line 375
        add_pred(*(pred___0 + cc) + offs, *(cur + cc) + offs, lx, *(blocks___0 + (k * block_count + n)));
#line 325
        n ++;
      }
#line 378
      k ++;
#line 323
      i += 16;
    }
#line 322
    j += 16;
  }
#line 381
  return;
}
}
#line 384 "src/transfrm.c"
static void add_pred(unsigned char *pred___0 , unsigned char *cur , int lx , short *blk ) 
{ 
  int i ;
  int j ;

  {
#line 436
  j = 0;
#line 436
  while (j < 8) {
#line 439
    i = 0;
#line 439
    while (i < 8) {
#line 440
      *(cur + i) = *(clp + ((int )*(blk + i) + (int )*(pred___0 + i)));
#line 439
      i ++;
    }
#line 441
    blk += 8;
#line 442
    cur += lx;
#line 443
    pred___0 += lx;
#line 436
    j ++;
  }
#line 448
  return;
}
}
#line 451 "src/transfrm.c"
static void sub_pred(unsigned char *pred___0 , unsigned char *cur , int lx , short *blk ) 
{ 
  int i ;
  int j ;

  {
#line 494
  j = 0;
#line 494
  while (j < 4) {
#line 498
    i = 0;
#line 498
    while (i < 8) {
#line 499
      *(blk + i) = (short )((int )*(cur + i) - (int )*(pred___0 + i));
#line 498
      i ++;
    }
#line 500
    blk += 8;
#line 501
    cur += lx;
#line 502
    pred___0 += lx;
#line 505
    i = 0;
#line 505
    while (i < 8) {
#line 506
      *(blk + i) = (short )((int )*(cur + i) - (int )*(pred___0 + i));
#line 505
      i ++;
    }
#line 507
    blk += 8;
#line 508
    cur += lx;
#line 509
    pred___0 += lx;
#line 494
    j ++;
  }
#line 513
  return;
}
}
#line 520 "src/transfrm.c"
void dct_type_estimation(unsigned char *pred___0 , unsigned char *cur , struct mbinfo *mbi ) 
{ 
  short blk0[128] ;
  short blk1[128] ;
  int i ;
  int j ;
  int i0 ;
  int j0___0 ;
  int k ;
  int offs ;
  int s0 ;
  int s1 ;
  int sq0 ;
  int sq1 ;
  int s01 ;
  double d___0 ;
  double r___0 ;
  double tmp ;

  {
#line 528
  k = 0;
#line 530
  j0___0 = 0;
#line 530
  while (j0___0 < height2) {
#line 531
    i0 = 0;
#line 531
    while (i0 < width) {
#line 533
      if (frame_pred_dct) {
#line 534
        (mbi + k)->dct_type = 0;
      } else
#line 533
      if (pict_struct != 3) {
#line 534
        (mbi + k)->dct_type = 0;
      } else {
#line 542
        j = 0;
#line 542
        while (j < 8) {
#line 544
          offs = width * ((j << 1) + j0___0) + i0;
#line 545
          i = 0;
#line 545
          while (i < 16) {
#line 547
            blk0[16 * j + i] = (short )((int )*(cur + offs) - (int )*(pred___0 + offs));
#line 548
            blk1[16 * j + i] = (short )((int )*(cur + (offs + width)) - (int )*(pred___0 + (offs + width)));
#line 549
            offs ++;
#line 545
            i ++;
          }
#line 542
          j ++;
        }
#line 553
        s01 = 0;
#line 553
        sq1 = s01;
#line 553
        sq0 = sq1;
#line 553
        s1 = sq0;
#line 553
        s0 = s1;
#line 555
        i = 0;
#line 555
        while (i < 128) {
#line 557
          s0 += (int )blk0[i];
#line 558
          sq0 += (int )blk0[i] * (int )blk0[i];
#line 559
          s1 += (int )blk1[i];
#line 560
          sq1 += (int )blk1[i] * (int )blk1[i];
#line 561
          s01 += (int )blk0[i] * (int )blk1[i];
#line 555
          i ++;
        }
#line 564
        d___0 = ((double )sq0 - (double )(s0 * s0) / 128.0) * ((double )sq1 - (double )(s1 * s1) / 128.0);
#line 566
        if (d___0 > 0.0) {
#line 568
          tmp = sqrt(d___0);
#line 568
          r___0 = ((double )s01 - (double )(s0 * s1) / 128.0) / tmp;
#line 569
          if (r___0 > 0.5) {
#line 570
            (mbi + k)->dct_type = 0;
          } else {
#line 572
            (mbi + k)->dct_type = 1;
          }
        } else {
#line 575
          (mbi + k)->dct_type = 1;
        }
      }
#line 577
      k ++;
#line 531
      i0 += 16;
    }
#line 530
    j0___0 += 16;
  }
#line 579
  return;
}
}
#line 582 "src/transfrm.c"
void ptdct_type_estimation(unsigned char *pred___0 , unsigned char *cur , struct mbinfo *mbi ,
                           int start_height , int end_height ) 
{ 
  short blk0[128] ;
  short blk1[128] ;
  int i ;
  int j ;
  int i0 ;
  int j0___0 ;
  int k ;
  int offs ;
  int s0 ;
  int s1 ;
  int sq0 ;
  int sq1 ;
  int s01 ;
  double d___0 ;
  double r___0 ;
  double tmp ;

  {
#line 591
  k = (start_height >> 4) * (width >> 4);
#line 593
  j0___0 = start_height;
#line 593
  while (j0___0 < end_height) {
#line 594
    i0 = 0;
#line 594
    while (i0 < width) {
#line 596
      if (frame_pred_dct) {
#line 597
        (mbi + k)->dct_type = 0;
      } else
#line 596
      if (pict_struct != 3) {
#line 597
        (mbi + k)->dct_type = 0;
      } else {
#line 605
        j = 0;
#line 605
        while (j < 8) {
#line 607
          offs = width * ((j << 1) + j0___0) + i0;
#line 608
          i = 0;
#line 608
          while (i < 16) {
#line 610
            blk0[16 * j + i] = (short )((int )*(cur + offs) - (int )*(pred___0 + offs));
#line 611
            blk1[16 * j + i] = (short )((int )*(cur + (offs + width)) - (int )*(pred___0 + (offs + width)));
#line 612
            offs ++;
#line 608
            i ++;
          }
#line 605
          j ++;
        }
#line 616
        s01 = 0;
#line 616
        sq1 = s01;
#line 616
        sq0 = sq1;
#line 616
        s1 = sq0;
#line 616
        s0 = s1;
#line 618
        i = 0;
#line 618
        while (i < 128) {
#line 620
          s0 += (int )blk0[i];
#line 621
          sq0 += (int )blk0[i] * (int )blk0[i];
#line 622
          s1 += (int )blk1[i];
#line 623
          sq1 += (int )blk1[i] * (int )blk1[i];
#line 624
          s01 += (int )blk0[i] * (int )blk1[i];
#line 618
          i ++;
        }
#line 627
        d___0 = ((double )sq0 - (double )(s0 * s0) / 128.0) * ((double )sq1 - (double )(s1 * s1) / 128.0);
#line 629
        if (d___0 > 0.0) {
#line 631
          tmp = sqrt(d___0);
#line 631
          r___0 = ((double )s01 - (double )(s0 * s1) / 128.0) / tmp;
#line 632
          if (r___0 > 0.5) {
#line 633
            (mbi + k)->dct_type = 0;
          } else {
#line 635
            (mbi + k)->dct_type = 1;
          }
        } else {
#line 638
          (mbi + k)->dct_type = 1;
        }
      }
#line 640
      k ++;
#line 594
      i0 += 16;
    }
#line 593
    j0___0 += 16;
  }
#line 642
  return;
}
}
/* compiler builtin: 
   void *__builtin___memmove_chk(void * , void const   * , unsigned long  , unsigned long  ) ;  */
/* compiler builtin: 
   char *__builtin_strchr(char * , int  ) ;  */
/* compiler builtin: 
   void *__builtin___memcpy_chk(void * , void const   * , unsigned long  , unsigned long  ) ;  */
/* compiler builtin: 
   char *__builtin___strncpy_chk(char * , char const   * , unsigned long  , unsigned long  ) ;  */
/* compiler builtin: 
   char *__builtin___strcat_chk(char * , char const   * , unsigned long  ) ;  */
/* compiler builtin: 
   char *__builtin___strcpy_chk(char * , char const   * , unsigned long  ) ;  */
/* compiler builtin: 
   void *__builtin___memset_chk(void * , int  , unsigned long  , unsigned long  ) ;  */
/* compiler builtin: 
   char *__builtin___strncat_chk(char * , char const   * , unsigned long  , unsigned long  ) ;  */
#line 1 "putseq.o"
#pragma merger("0","/tmp/cil-7dgxAroH.i","-O4")
#line 542 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 242 "/usr/include/stdio.h"
extern int fflush(FILE *__stream ) ;
#line 42 "/usr/include/string.h"
__inline extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2),
__leaf__, __artificial__, __always_inline__)) memcpy)(void * __restrict  __dest ,
                                                      void const   * __restrict  __src ,
                                                      size_t __len ) ;
#line 46
__inline extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2),
__leaf__, __artificial__, __always_inline__)) memmove)(void *__dest , void const   *__src ,
                                                       size_t __len ) ;
#line 62
__inline extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1),
__leaf__, __artificial__, __always_inline__)) memset)(void *__dest , int __ch , size_t __len ) ;
#line 125
__inline extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2),
__leaf__, __artificial__, __always_inline__)) strcpy)(char * __restrict  __dest ,
                                                      char const   * __restrict  __src ) ;
#line 128
__inline extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2),
__leaf__, __artificial__, __always_inline__)) strncpy)(char * __restrict  __dest ,
                                                       char const   * __restrict  __src ,
                                                       size_t __len ) ;
#line 133
__inline extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2),
__leaf__, __artificial__, __always_inline__)) strcat)(char * __restrict  __dest ,
                                                      char const   * __restrict  __src ) ;
#line 136
__inline extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2),
__leaf__, __artificial__, __always_inline__)) strncat)(char * __restrict  __dest ,
                                                       char const   * __restrict  __src ,
                                                       size_t __len ) ;
#line 395
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 451
__inline extern  __attribute__((__nothrow__)) void ( __attribute__((__nonnull__(1,2),
__leaf__, __artificial__, __always_inline__)) bcopy)(void const   *__src , void *__dest ,
                                                     size_t __len ) ;
#line 455
__inline extern  __attribute__((__nothrow__)) void ( __attribute__((__nonnull__(1),
__leaf__, __artificial__, __always_inline__)) bzero)(void *__dest , size_t __len ) ;
#line 575
__inline extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2),
__leaf__, __artificial__, __always_inline__)) stpncpy)(char * __restrict  __dest ,
                                                       char const   * __restrict  __src ,
                                                       size_t __n ) ;
#line 968 "/usr/include/x86_64-linux-gnu/bits/string2.h"
__inline extern size_t __strcspn_c1(char const   *__s , int __reject ) ;
#line 969 "/usr/include/x86_64-linux-gnu/bits/string2.h"
__inline extern size_t __strcspn_c1(char const   *__s , int __reject ) 
{ 
  register size_t __result ;

  {
#line 972
  __result = (size_t )0;
#line 973
  while (1) {
#line 973
    if ((int const   )*(__s + __result) != 0) {
#line 973
      if (! ((int const   )*(__s + __result) != (int const   )__reject)) {
#line 973
        break;
      }
    } else {
#line 973
      break;
    }
#line 974
    __result ++;
  }
#line 975
  return (__result);
}
}
#line 978
__inline extern size_t __strcspn_c2(char const   *__s , int __reject1 , int __reject2 ) ;
#line 980 "/usr/include/x86_64-linux-gnu/bits/string2.h"
__inline extern size_t __strcspn_c2(char const   *__s , int __reject1 , int __reject2 ) 
{ 
  register size_t __result ;

  {
#line 983
  __result = (size_t )0;
#line 984
  while (1) {
#line 984
    if ((int const   )*(__s + __result) != 0) {
#line 984
      if ((int const   )*(__s + __result) != (int const   )__reject1) {
#line 984
        if (! ((int const   )*(__s + __result) != (int const   )__reject2)) {
#line 984
          break;
        }
      } else {
#line 984
        break;
      }
    } else {
#line 984
      break;
    }
#line 986
    __result ++;
  }
#line 987
  return (__result);
}
}
#line 990
__inline extern size_t __strcspn_c3(char const   *__s , int __reject1 , int __reject2 ,
                                    int __reject3 ) ;
#line 992 "/usr/include/x86_64-linux-gnu/bits/string2.h"
__inline extern size_t __strcspn_c3(char const   *__s , int __reject1 , int __reject2 ,
                                    int __reject3 ) 
{ 
  register size_t __result ;

  {
#line 996
  __result = (size_t )0;
#line 997
  while (1) {
#line 997
    if ((int const   )*(__s + __result) != 0) {
#line 997
      if ((int const   )*(__s + __result) != (int const   )__reject1) {
#line 997
        if ((int const   )*(__s + __result) != (int const   )__reject2) {
#line 997
          if (! ((int const   )*(__s + __result) != (int const   )__reject3)) {
#line 997
            break;
          }
        } else {
#line 997
          break;
        }
      } else {
#line 997
        break;
      }
    } else {
#line 997
      break;
    }
#line 999
    __result ++;
  }
#line 1000
  return (__result);
}
}
#line 1044
__inline extern size_t __strspn_c1(char const   *__s , int __accept ) ;
#line 1045 "/usr/include/x86_64-linux-gnu/bits/string2.h"
__inline extern size_t __strspn_c1(char const   *__s , int __accept ) 
{ 
  register size_t __result ;

  {
#line 1048
  __result = (size_t )0;
#line 1050
  while ((int const   )*(__s + __result) == (int const   )__accept) {
#line 1051
    __result ++;
  }
#line 1052
  return (__result);
}
}
#line 1055
__inline extern size_t __strspn_c2(char const   *__s , int __accept1 , int __accept2 ) ;
#line 1057 "/usr/include/x86_64-linux-gnu/bits/string2.h"
__inline extern size_t __strspn_c2(char const   *__s , int __accept1 , int __accept2 ) 
{ 
  register size_t __result ;

  {
#line 1060
  __result = (size_t )0;
#line 1062
  while (1) {
#line 1062
    if (! ((int const   )*(__s + __result) == (int const   )__accept1)) {
#line 1062
      if (! ((int const   )*(__s + __result) == (int const   )__accept2)) {
#line 1062
        break;
      }
    }
#line 1063
    __result ++;
  }
#line 1064
  return (__result);
}
}
#line 1067
__inline extern size_t __strspn_c3(char const   *__s , int __accept1 , int __accept2 ,
                                   int __accept3 ) ;
#line 1069 "/usr/include/x86_64-linux-gnu/bits/string2.h"
__inline extern size_t __strspn_c3(char const   *__s , int __accept1 , int __accept2 ,
                                   int __accept3 ) 
{ 
  register size_t __result ;

  {
#line 1072
  __result = (size_t )0;
#line 1074
  while (1) {
#line 1074
    if (! ((int const   )*(__s + __result) == (int const   )__accept1)) {
#line 1074
      if (! ((int const   )*(__s + __result) == (int const   )__accept2)) {
#line 1074
        if (! ((int const   )*(__s + __result) == (int const   )__accept3)) {
#line 1074
          break;
        }
      }
    }
#line 1076
    __result ++;
  }
#line 1077
  return (__result);
}
}
#line 1120
__inline extern char *__strpbrk_c2(char const   *__s , int __accept1 , int __accept2 ) ;
#line 1122 "/usr/include/x86_64-linux-gnu/bits/string2.h"
__inline extern char *__strpbrk_c2(char const   *__s , int __accept1 , int __accept2 ) 
{ 
  char *tmp ;

  {
#line 1126
  while (1) {
#line 1126
    if ((int const   )*__s != 0) {
#line 1126
      if ((int const   )*__s != (int const   )__accept1) {
#line 1126
        if (! ((int const   )*__s != (int const   )__accept2)) {
#line 1126
          break;
        }
      } else {
#line 1126
        break;
      }
    } else {
#line 1126
      break;
    }
#line 1127
    __s ++;
  }
#line 1128
  if ((int const   )*__s == 0) {
#line 1128
    tmp = (char *)((void *)0);
  } else {
#line 1128
    tmp = (char *)((size_t )__s);
  }
#line 1128
  return (tmp);
}
}
#line 1131
__inline extern char *__strpbrk_c3(char const   *__s , int __accept1 , int __accept2 ,
                                   int __accept3 ) ;
#line 1133 "/usr/include/x86_64-linux-gnu/bits/string2.h"
__inline extern char *__strpbrk_c3(char const   *__s , int __accept1 , int __accept2 ,
                                   int __accept3 ) 
{ 
  char *tmp ;

  {
#line 1137
  while (1) {
#line 1137
    if ((int const   )*__s != 0) {
#line 1137
      if ((int const   )*__s != (int const   )__accept1) {
#line 1137
        if ((int const   )*__s != (int const   )__accept2) {
#line 1137
          if (! ((int const   )*__s != (int const   )__accept3)) {
#line 1137
            break;
          }
        } else {
#line 1137
          break;
        }
      } else {
#line 1137
        break;
      }
    } else {
#line 1137
      break;
    }
#line 1139
    __s ++;
  }
#line 1140
  if ((int const   )*__s == 0) {
#line 1140
    tmp = (char *)((void *)0);
  } else {
#line 1140
    tmp = (char *)((size_t )__s);
  }
#line 1140
  return (tmp);
}
}
#line 1170
__inline extern char *__strtok_r_1c(char *__s , char __sep , char **__nextp ) ;
#line 1171 "/usr/include/x86_64-linux-gnu/bits/string2.h"
__inline extern char *__strtok_r_1c(char *__s , char __sep , char **__nextp ) 
{ 
  char *__result ;
  char *tmp ;
  char *tmp___0 ;

  {
#line 1175
  if ((unsigned long )__s == (unsigned long )((void *)0)) {
#line 1176
    __s = *__nextp;
  }
#line 1177
  while ((int )*__s == (int )__sep) {
#line 1178
    __s ++;
  }
#line 1179
  __result = (char *)((void *)0);
#line 1180
  if ((int )*__s != 0) {
#line 1182
    tmp = __s;
#line 1182
    __s ++;
#line 1182
    __result = tmp;
#line 1183
    while ((int )*__s != 0) {
#line 1184
      tmp___0 = __s;
#line 1184
      __s ++;
#line 1184
      if ((int )*tmp___0 == (int )__sep) {
#line 1186
        *(__s + -1) = (char )'\000';
#line 1187
        break;
      }
    }
  }
#line 1190
  *__nextp = __s;
#line 1191
  return (__result);
}
}
#line 1220
__inline extern char *__strsep_1c(char **__s , char __reject ) ;
#line 1221 "/usr/include/x86_64-linux-gnu/bits/string2.h"
__inline extern char *__strsep_1c(char **__s , char __reject ) 
{ 
  register char *__retval ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___2 ;

  {
#line 1224
  __retval = *__s;
#line 1225
  if ((unsigned long )__retval != (unsigned long )((void *)0)) {
#line 1225
    tmp___2 = __builtin_strchr(__retval, (int )__reject);
#line 1225
    tmp___0 = tmp___2;
#line 1225
    *__s = tmp___0;
#line 1225
    if ((unsigned long )tmp___0 != (unsigned long )((void *)0)) {
#line 1226
      tmp = *__s;
#line 1226
      (*__s) ++;
#line 1226
      *tmp = (char )'\000';
    }
  }
#line 1227
  return (__retval);
}
}
#line 1230
__inline extern char *__strsep_2c(char **__s , char __reject1 , char __reject2 ) ;
#line 1231 "/usr/include/x86_64-linux-gnu/bits/string2.h"
__inline extern char *__strsep_2c(char **__s , char __reject1 , char __reject2 ) 
{ 
  register char *__retval ;
  register char *__cp ;
  char *tmp ;

  {
#line 1234
  __retval = *__s;
#line 1235
  if ((unsigned long )__retval != (unsigned long )((void *)0)) {
#line 1237
    __cp = __retval;
#line 1238
    while (1) {
#line 1240
      if ((int )*__cp == 0) {
#line 1242
        __cp = (char *)((void *)0);
#line 1243
        break;
      }
#line 1245
      if ((int )*__cp == (int )__reject1) {
#line 1247
        tmp = __cp;
#line 1247
        __cp ++;
#line 1247
        *tmp = (char )'\000';
#line 1248
        break;
      } else
#line 1245
      if ((int )*__cp == (int )__reject2) {
#line 1247
        tmp = __cp;
#line 1247
        __cp ++;
#line 1247
        *tmp = (char )'\000';
#line 1248
        break;
      }
#line 1250
      __cp ++;
    }
#line 1252
    *__s = __cp;
  }
#line 1254
  return (__retval);
}
}
#line 1257
__inline extern char *__strsep_3c(char **__s , char __reject1 , char __reject2 , char __reject3 ) ;
#line 1259 "/usr/include/x86_64-linux-gnu/bits/string2.h"
__inline extern char *__strsep_3c(char **__s , char __reject1 , char __reject2 , char __reject3 ) 
{ 
  register char *__retval ;
  register char *__cp ;
  char *tmp ;

  {
#line 1262
  __retval = *__s;
#line 1263
  if ((unsigned long )__retval != (unsigned long )((void *)0)) {
#line 1265
    __cp = __retval;
#line 1266
    while (1) {
#line 1268
      if ((int )*__cp == 0) {
#line 1270
        __cp = (char *)((void *)0);
#line 1271
        break;
      }
#line 1273
      if ((int )*__cp == (int )__reject1) {
#line 1275
        tmp = __cp;
#line 1275
        __cp ++;
#line 1275
        *tmp = (char )'\000';
#line 1276
        break;
      } else
#line 1273
      if ((int )*__cp == (int )__reject2) {
#line 1275
        tmp = __cp;
#line 1275
        __cp ++;
#line 1275
        *tmp = (char )'\000';
#line 1276
        break;
      } else
#line 1273
      if ((int )*__cp == (int )__reject3) {
#line 1275
        tmp = __cp;
#line 1275
        __cp ++;
#line 1275
        *tmp = (char )'\000';
#line 1276
        break;
      }
#line 1278
      __cp ++;
    }
#line 1280
    *__s = __cp;
  }
#line 1282
  return (__retval);
}
}
#line 47 "/usr/include/x86_64-linux-gnu/bits/string3.h"
__inline extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2),
__leaf__, __artificial__, __always_inline__)) memcpy)(void * __restrict  __dest ,
                                                      void const   * __restrict  __src ,
                                                      size_t __len ) ;
#line 47 "/usr/include/x86_64-linux-gnu/bits/string3.h"
__inline extern void *( __attribute__((__nonnull__(1,2), __leaf__, __artificial__,
__always_inline__)) memcpy)(void * __restrict  __dest , void const   * __restrict  __src ,
                            size_t __len ) 
{ 
  unsigned long tmp ;
  void *tmp___0 ;

  {
#line 51
  tmp = __builtin_object_size((void *)__dest, 0);
#line 51
  tmp___0 = __builtin___memcpy_chk((void *)__dest, (void const   *)__src, __len, tmp);
#line 51
  return (tmp___0);
}
}
#line 54
__inline extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2),
__leaf__, __artificial__, __always_inline__)) memmove)(void *__dest , void const   *__src ,
                                                       size_t __len ) ;
#line 54 "/usr/include/x86_64-linux-gnu/bits/string3.h"
__inline extern void *( __attribute__((__nonnull__(1,2), __leaf__, __artificial__,
__always_inline__)) memmove)(void *__dest , void const   *__src , size_t __len ) 
{ 
  unsigned long tmp ;
  void *tmp___0 ;

  {
#line 57
  tmp = __builtin_object_size(__dest, 0);
#line 57
  tmp___0 = __builtin___memmove_chk(__dest, __src, __len, tmp);
#line 57
  return (tmp___0);
}
}
#line 75
__inline extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1),
__leaf__, __artificial__, __always_inline__)) memset)(void *__dest , int __ch , size_t __len ) ;
#line 75 "/usr/include/x86_64-linux-gnu/bits/string3.h"
__inline extern void *( __attribute__((__nonnull__(1), __leaf__, __artificial__, __always_inline__)) memset)(void *__dest ,
                                                                                                             int __ch ,
                                                                                                             size_t __len ) 
{ 
  unsigned long tmp ;
  void *tmp___0 ;

  {
#line 84
  tmp = __builtin_object_size(__dest, 0);
#line 84
  tmp___0 = __builtin___memset_chk(__dest, __ch, __len, tmp);
#line 84
  return (tmp___0);
}
}
#line 88
__inline extern  __attribute__((__nothrow__)) void ( __attribute__((__nonnull__(1,2),
__leaf__, __artificial__, __always_inline__)) bcopy)(void const   *__src , void *__dest ,
                                                     size_t __len ) ;
#line 88 "/usr/include/x86_64-linux-gnu/bits/string3.h"
__inline extern void ( __attribute__((__nonnull__(1,2), __leaf__, __artificial__,
__always_inline__)) bcopy)(void const   *__src , void *__dest , size_t __len ) 
{ 
  unsigned long tmp ;

  {
#line 91
  tmp = __builtin_object_size(__dest, 0);
#line 91
  __builtin___memmove_chk(__dest, __src, __len, tmp);
#line 92
  return;
}
}
#line 94
__inline extern  __attribute__((__nothrow__)) void ( __attribute__((__nonnull__(1),
__leaf__, __artificial__, __always_inline__)) bzero)(void *__dest , size_t __len ) ;
#line 94 "/usr/include/x86_64-linux-gnu/bits/string3.h"
__inline extern void ( __attribute__((__nonnull__(1), __leaf__, __artificial__, __always_inline__)) bzero)(void *__dest ,
                                                                                                           size_t __len ) 
{ 
  unsigned long tmp ;

  {
#line 97
  tmp = __builtin_object_size(__dest, 0);
#line 97
  __builtin___memset_chk(__dest, '\000', __len, tmp);
#line 98
  return;
}
}
#line 101
__inline extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2),
__leaf__, __artificial__, __always_inline__)) strcpy)(char * __restrict  __dest ,
                                                      char const   * __restrict  __src ) ;
#line 101 "/usr/include/x86_64-linux-gnu/bits/string3.h"
__inline extern char *( __attribute__((__nonnull__(1,2), __leaf__, __artificial__,
__always_inline__)) strcpy)(char * __restrict  __dest , char const   * __restrict  __src ) 
{ 
  unsigned long tmp ;
  char *tmp___0 ;

  {
#line 104
  tmp = __builtin_object_size((void *)__dest, 1);
#line 104
  tmp___0 = __builtin___strcpy_chk((char *)__dest, (char const   *)__src, tmp);
#line 104
  return (tmp___0);
}
}
#line 116
__inline extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2),
__leaf__, __artificial__, __always_inline__)) strncpy)(char * __restrict  __dest ,
                                                       char const   * __restrict  __src ,
                                                       size_t __len ) ;
#line 116 "/usr/include/x86_64-linux-gnu/bits/string3.h"
__inline extern char *( __attribute__((__nonnull__(1,2), __leaf__, __artificial__,
__always_inline__)) strncpy)(char * __restrict  __dest , char const   * __restrict  __src ,
                             size_t __len ) 
{ 
  unsigned long tmp ;
  char *tmp___0 ;

  {
#line 120
  tmp = __builtin_object_size((void *)__dest, 1);
#line 120
  tmp___0 = __builtin___strncpy_chk((char *)__dest, (char const   *)__src, __len,
                                    tmp);
#line 120
  return (tmp___0);
}
}
#line 124
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) __stpncpy_chk)(char *__dest ,
                                                                                      char const   *__src ,
                                                                                      size_t __n ,
                                                                                      size_t __destlen ) ;
#line 126
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) __stpncpy_alias)(char *__dest ,
                                                                                        char const   *__src ,
                                                                                        size_t __n )  __asm__("stpncpy")  ;
#line 129
__inline extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2),
__leaf__, __artificial__, __always_inline__)) stpncpy)(char * __restrict  __dest ,
                                                       char const   * __restrict  __src ,
                                                       size_t __n ) ;
#line 129 "/usr/include/x86_64-linux-gnu/bits/string3.h"
__inline extern char *( __attribute__((__nonnull__(1,2), __leaf__, __artificial__,
__always_inline__)) stpncpy)(char * __restrict  __dest , char const   * __restrict  __src ,
                             size_t __n ) 
{ 
  unsigned long tmp ;
  char *tmp___0 ;
  unsigned long tmp___1 ;
  char *tmp___3 ;

  {
#line 132
  tmp___1 = __builtin_object_size((void *)__dest, 1);
#line 132
  if (tmp___1 != 0xffffffffffffffffUL) {
#line 134
    tmp = __builtin_object_size((void *)__dest, 1);
#line 134
    tmp___0 = __stpncpy_chk((char *)__dest, (char const   *)__src, __n, tmp);
#line 134
    return (tmp___0);
  }
#line 135
  tmp___3 = __stpncpy_alias((char *)__dest, (char const   *)__src, __n);
#line 135
  return (tmp___3);
}
}
#line 139
__inline extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2),
__leaf__, __artificial__, __always_inline__)) strcat)(char * __restrict  __dest ,
                                                      char const   * __restrict  __src ) ;
#line 139 "/usr/include/x86_64-linux-gnu/bits/string3.h"
__inline extern char *( __attribute__((__nonnull__(1,2), __leaf__, __artificial__,
__always_inline__)) strcat)(char * __restrict  __dest , char const   * __restrict  __src ) 
{ 
  unsigned long tmp ;
  char *tmp___0 ;

  {
#line 142
  tmp = __builtin_object_size((void *)__dest, 1);
#line 142
  tmp___0 = __builtin___strcat_chk((char *)__dest, (char const   *)__src, tmp);
#line 142
  return (tmp___0);
}
}
#line 146
__inline extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2),
__leaf__, __artificial__, __always_inline__)) strncat)(char * __restrict  __dest ,
                                                       char const   * __restrict  __src ,
                                                       size_t __len ) ;
#line 146 "/usr/include/x86_64-linux-gnu/bits/string3.h"
__inline extern char *( __attribute__((__nonnull__(1,2), __leaf__, __artificial__,
__always_inline__)) strncat)(char * __restrict  __dest , char const   * __restrict  __src ,
                             size_t __len ) 
{ 
  unsigned long tmp ;
  char *tmp___0 ;

  {
#line 150
  tmp = __builtin_object_size((void *)__dest, 1);
#line 150
  tmp___0 = __builtin___strncat_chk((char *)__dest, (char const   *)__src, __len,
                                    tmp);
#line 150
  return (tmp___0);
}
}
#line 110 "src/global.h"
void motion_estimation(unsigned char *oldorg , unsigned char *neworg , unsigned char *oldref ,
                       unsigned char *newref , unsigned char *cur , unsigned char *curref ,
                       int sxf , int syf , int sxb , int syb , struct mbinfo *mbi ,
                       int secondfield , int ipflag ) ;
#line 115
void ptmotion_estimation(unsigned char *oldorg , unsigned char *neworg , unsigned char *oldref ,
                         unsigned char *newref , unsigned char *cur , unsigned char *curref ,
                         int sxf , int syf , int sxb , int syb , struct mbinfo *mbi ,
                         int secondfield , int ipflag , int start_height , int end_height ) ;
#line 125
void predict(unsigned char **reff , unsigned char **refb , unsigned char **cur , int secondfield ,
             struct mbinfo *mbi ) ;
#line 128
void ptpredict(unsigned char **reff , unsigned char **refb , unsigned char **cur ,
               int secondfield , struct mbinfo *mbi , int start_height , int end_height ) ;
#line 137
void flushbits(int id ) ;
#line 172
void putseq(void) ;
#line 201
void iquant_intra(short *src , short *dst , int dc_prec___0 , unsigned char *quant_mat ,
                  int mquant ) ;
#line 203
void iquant_non_intra(short *src , short *dst , unsigned char *quant_mat , int mquant ) ;
#line 206
void ptiquant(int start_k , int end_k ) ;
#line 207
void ptquant(int start_mbh , int end_mbh ) ;
#line 212
void rc_init_seq(void) ;
#line 213
void rc_init_GOP(int np , int nb ) ;
#line 245
void writeframe(char *fname , unsigned char **frame ) ;
#line 339
unsigned char *newrefframe[3] ;
#line 339
unsigned char *oldrefframe[3] ;
#line 339
unsigned char *auxframe[3] ;
#line 341
unsigned char *neworgframe[3] ;
#line 341
unsigned char *oldorgframe[3] ;
#line 341
unsigned char *auxorgframe[3] ;
#line 343
unsigned char *predframe[3] ;
#line 362
char id_string[256] ;
#line 362
char tplorg[256] ;
#line 362
char tplref[256] ;
#line 374
int N ;
#line 377
int nframes ;
#line 378
int frame0 ;
#line 431
int frame_pred_dct_tab[3] ;
#line 433
int qscale_tab[3] ;
#line 434
int intravlc_tab[3] ;
#line 435
int altscan_tab[3] ;
#line 232 "/usr/include/pthread.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,3))) pthread_create)(pthread_t * __restrict  __newthread ,
                                                                                             pthread_attr_t const   * __restrict  __attr ,
                                                                                             void *(*__start_routine)(void * ) ,
                                                                                             void * __restrict  __arg ) ;
#line 249
extern int pthread_join(pthread_t __th , void **__thread_return ) ;
#line 277
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) pthread_equal)(pthread_t __thread1 ,
                                                                                             pthread_t __thread2 )  __attribute__((__const__)) ;
#line 286
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) pthread_attr_init)(pthread_attr_t *__attr ) ;
#line 289
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) pthread_attr_destroy)(pthread_attr_t *__attr ) ;
#line 298
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) pthread_attr_setdetachstate)(pthread_attr_t *__attr ,
                                                                                                                  int __detachstate ) ;
#line 1143
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) pthread_equal)(pthread_t __thread1 ,
                                                                                             pthread_t __thread2 )  __attribute__((__const__)) ;
#line 1143 "/usr/include/pthread.h"
__inline extern int ( __attribute__((__leaf__)) pthread_equal)(pthread_t __thread1 ,
                                                               pthread_t __thread2 ) 
{ 


  {
#line 1146
  return (__thread1 == __thread2);
}
}
#line 93 "src/putseq.c"
void *thread_work(void *threadargs ) 
{ 
  struct thread_data *my_data ;
  struct Data_Args *mda ;
  int start_height ;
  int end_height ;
  struct mbinfo *mbi ;

  {
#line 94
  my_data = (struct thread_data *)threadargs;
#line 97
  mda = my_data->data_ptr;
#line 98
  start_height = my_data->s_height;
#line 99
  end_height = my_data->e_height;
#line 100
  mbi = mda->mbi;
#line 103
  ptmotion_estimation(mda->oldorg, mda->neworg, mda->oldref, mda->newref, mda->cur,
                      mda->curref, mda->sxf, mda->syf, mda->sxb, mda->syb, mbi, mda->secondfield,
                      mda->ipflag, start_height, end_height);
#line 108
  ptpredict(mda->reff, mda->refb, (unsigned char **)mda->pd_cur, mda->secondfield,
            mbi, start_height, end_height);
#line 111
  ptdct_type_estimation(mda->pred, mda->dte_cur, mbi, start_height, end_height);
#line 113
  pttransform(mda->pd_cur, mda->trfm_cur, mbi, (short (*)[64])mda->blocks, start_height,
              end_height);
#line 116
  ptquant(my_data->s_mbh, my_data->e_mbh);
#line 118
  ptputpict(mda->dte_cur, my_data->pp_smbh, my_data->pp_embh, mda->prev_mquant, my_data->id);
#line 121
  ptiquant(my_data->s_mbh, my_data->e_mbh);
#line 122
  ptitransform(mda->pd_cur, mda->itrfm_cur, mbi, (short (*)[64])mda->blocks, start_height,
               end_height);
#line 125
  return ((void *)0);
}
}
#line 128 "src/putseq.c"
struct thread_data thread_data_array[2]  ;
#line 129 "src/putseq.c"
struct Data_Args data_args  ;
#line 131 "src/putseq.c"
void thread_work_dist(void) 
{ 
  int tmp ;
  int tmp1 ;
  int rc ;
  int t ;
  int status ;
  int excess ;
  int chunk ;
  pthread_attr_t attr ;
  pthread_t thread[1] ;

  {
#line 142
  pthread_attr_init(& attr);
#line 143
  pthread_attr_setdetachstate(& attr, 0);
#line 146
  chunk = height2 / 2;
#line 147
  excess = (height2 / 16) % 2;
#line 149
  t = 0;
#line 149
  while (t < 2) {
#line 151
    if (t == 0) {
#line 152
      thread_data_array[t].s_height = 0;
#line 153
      thread_data_array[t].s_mbh = 0;
#line 154
      thread_data_array[t].pp_smbh = 0;
#line 155
      tmp = chunk;
    } else {
#line 157
      thread_data_array[t].s_height = thread_data_array[t - 1].e_height;
#line 158
      thread_data_array[t].s_mbh = thread_data_array[t - 1].e_mbh;
#line 159
      thread_data_array[t].pp_smbh = thread_data_array[t - 1].pp_embh;
#line 160
      tmp = thread_data_array[t - 1].e_height + chunk;
    }
#line 163
    if (excess) {
#line 164
      tmp = (tmp + 16) - tmp % 16;
#line 165
      excess --;
    } else {
#line 167
      tmp -= tmp % 16;
    }
#line 169
    tmp1 = tmp / 16;
#line 171
    thread_data_array[t].e_height = tmp;
#line 172
    thread_data_array[t].pp_embh = tmp1;
#line 173
    thread_data_array[t].e_mbh = tmp1 * mb_width;
#line 175
    thread_data_array[t].id = t;
#line 177
    thread_data_array[t].data_ptr = & data_args;
#line 181
    if (t < 1) {
#line 182
      rc = pthread_create((pthread_t * __restrict  )(& thread[t]), (pthread_attr_t const   * __restrict  )(& attr),
                          & thread_work, (void * __restrict  )((void *)(& thread_data_array[t])));
#line 184
      if (rc) {
#line 186
        printf((char const   * __restrict  )"ERROR; return code from pthread_create() is %d\n",
               rc);
#line 187
        exit(-1);
      }
    }
#line 149
    t ++;
  }
#line 195
  pthread_attr_destroy(& attr);
#line 200
  putpicthdr();
#line 202
  if (! mpeg1) {
#line 203
    putpictcodext();
  }
#line 205
  alignbits();
#line 207
  thread_work((void *)(& thread_data_array[1]));
#line 210
  t = 0;
#line 210
  while (t < 1) {
#line 212
    rc = pthread_join(thread[t], (void **)(& status));
#line 213
    if (rc) {
#line 215
      printf((char const   * __restrict  )"ERROR; return code from pthread_join() is %d\n",
             rc);
#line 216
      exit(-1);
    }
#line 218
    flushbits(t);
#line 210
    t ++;
  }
#line 223
  flushbits(1);
#line 225
  return;
}
}
#line 229 "src/putseq.c"
void putseq(void) 
{ 
  int i ;
  int j ;
  int k ;
  int f ;
  int f0 ;
  int n ;
  int np ;
  int nb ;
  int sxf ;
  int syf ;
  int sxb ;
  int syb ;
  int ipflag ;
  char name[256] ;
  unsigned char *neworg[3] ;
  unsigned char *newref[3] ;
  size_t tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;

  {
#line 241
  rc_init_seq();
#line 243
  putseqhdr();
#line 244
  if (! mpeg1) {
#line 246
    putseqext();
#line 247
    putseqdispext();
  }
#line 251
  tmp = strlen((char const   *)(id_string));
#line 251
  if (tmp > 1UL) {
#line 252
    putuserdata(id_string);
  }
#line 255
  i = 0;
#line 255
  while (i < nframes) {
#line 258
    if (! quiet) {
#line 260
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Encoding frame %d ",
              i);
#line 261
      fflush(stderr);
    }
#line 269
    f0 = N * ((i + (M - 1)) / N) - (M - 1);
#line 271
    if (f0 < 0) {
#line 272
      f0 = 0;
    }
#line 274
    if (i == 0) {
#line 274
      goto _L;
    } else
#line 274
    if ((i - 1) % M == 0) {
      _L: /* CIL Label */ 
#line 277
      j = 0;
#line 277
      while (j < 3) {
#line 280
        neworg[j] = oldorgframe[j];
#line 281
        newref[j] = oldrefframe[j];
#line 282
        oldorgframe[j] = neworgframe[j];
#line 283
        oldrefframe[j] = newrefframe[j];
#line 284
        neworgframe[j] = neworg[j];
#line 285
        newrefframe[j] = newref[j];
#line 277
        j ++;
      }
#line 289
      if (i == 0) {
#line 289
        f = 0;
      } else {
#line 289
        f = (i + M) - 1;
      }
#line 290
      if (f >= nframes) {
#line 291
        f = nframes - 1;
      }
#line 293
      if (i == f0) {
#line 296
        pict_type = 1;
#line 297
        forw_vert_f_code = 15;
#line 297
        forw_hor_f_code = forw_vert_f_code;
#line 298
        back_vert_f_code = 15;
#line 298
        back_hor_f_code = back_vert_f_code;
#line 304
        if (i == 0) {
#line 304
          n = N - (M - 1);
        } else {
#line 304
          n = N;
        }
#line 307
        if (n > nframes - f0) {
#line 308
          n = nframes - f0;
        }
#line 311
        if (i == 0) {
#line 312
          np = (n + 2 * (M - 1)) / M - 1;
        } else {
#line 314
          np = (n + (M - 1)) / M - 1;
        }
#line 317
        nb = (n - np) - 1;
#line 319
        rc_init_GOP(np, nb);
#line 321
        putgophdr(f0, i == 0);
      } else {
#line 326
        pict_type = 2;
#line 327
        forw_hor_f_code = (motion_data + 0)->forw_hor_f_code;
#line 328
        forw_vert_f_code = (motion_data + 0)->forw_vert_f_code;
#line 329
        back_vert_f_code = 15;
#line 329
        back_hor_f_code = back_vert_f_code;
#line 330
        sxf = (motion_data + 0)->sxf;
#line 331
        syf = (motion_data + 0)->syf;
      }
    } else {
#line 337
      j = 0;
#line 337
      while (j < 3) {
#line 339
        neworg[j] = auxorgframe[j];
#line 340
        newref[j] = auxframe[j];
#line 337
        j ++;
      }
#line 344
      f = i - 1;
#line 345
      pict_type = 3;
#line 346
      n = (i - 2) % M + 1;
#line 347
      forw_hor_f_code = (motion_data + n)->forw_hor_f_code;
#line 348
      forw_vert_f_code = (motion_data + n)->forw_vert_f_code;
#line 349
      back_hor_f_code = (motion_data + n)->back_hor_f_code;
#line 350
      back_vert_f_code = (motion_data + n)->back_vert_f_code;
#line 351
      sxf = (motion_data + n)->sxf;
#line 352
      syf = (motion_data + n)->syf;
#line 353
      sxb = (motion_data + n)->sxb;
#line 354
      syb = (motion_data + n)->syb;
    }
#line 357
    temp_ref = f - f0;
#line 358
    frame_pred_dct = frame_pred_dct_tab[pict_type - 1];
#line 359
    q_scale_type = qscale_tab[pict_type - 1];
#line 360
    intravlc = intravlc_tab[pict_type - 1];
#line 361
    altscan = altscan_tab[pict_type - 1];
#line 390
    sprintf((char * __restrict  )(name), (char const   * __restrict  )(tplorg), f + frame0);
#line 391
    readframe(name, neworg);
#line 394
    if (fieldpic) {
#line 396
      if (! quiet) {
#line 398
        if (topfirst) {
#line 398
          tmp___0 = "top";
        } else {
#line 398
          tmp___0 = "bot";
        }
#line 398
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"\nfirst field  (%s) ",
                tmp___0);
#line 399
        fflush(stderr);
      }
#line 402
      if (topfirst) {
#line 402
        pict_struct = 1;
      } else {
#line 402
        pict_struct = 2;
      }
#line 404
      motion_estimation(oldorgframe[0], neworgframe[0], oldrefframe[0], newrefframe[0],
                        neworg[0], newref[0], sxf, syf, sxb, syb, mbinfo, 0, 0);
#line 409
      predict(oldrefframe, newrefframe, (unsigned char **)(predframe), 0, mbinfo);
#line 410
      dct_type_estimation(predframe[0], neworg[0], mbinfo);
#line 411
      transform(predframe, neworg, mbinfo, blocks);
#line 413
      putpict(neworg[0]);
#line 415
      k = 0;
#line 415
      while (k < mb_height2 * mb_width) {
#line 417
        if ((mbinfo + k)->mb_type & 1) {
#line 418
          j = 0;
#line 418
          while (j < block_count) {
#line 419
            iquant_intra(*(blocks + (k * block_count + j)), *(blocks + (k * block_count + j)),
                         dc_prec, intra_q, (mbinfo + k)->mquant);
#line 418
            j ++;
          }
        } else {
#line 422
          j = 0;
#line 422
          while (j < block_count) {
#line 423
            iquant_non_intra(*(blocks + (k * block_count + j)), *(blocks + (k * block_count + j)),
                             inter_q, (mbinfo + k)->mquant);
#line 422
            j ++;
          }
        }
#line 415
        k ++;
      }
#line 427
      itransform(predframe, newref, mbinfo, blocks);
#line 428
      calcSNR((unsigned char **)(neworg), (unsigned char **)(newref));
#line 429
      stats();
#line 431
      if (! quiet) {
#line 433
        if (topfirst) {
#line 433
          tmp___1 = "bot";
        } else {
#line 433
          tmp___1 = "top";
        }
#line 433
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"second field (%s) ",
                tmp___1);
#line 434
        fflush(stderr);
      }
#line 437
      if (topfirst) {
#line 437
        pict_struct = 2;
      } else {
#line 437
        pict_struct = 1;
      }
#line 439
      ipflag = pict_type == 1;
#line 440
      if (ipflag) {
#line 443
        pict_type = 2;
#line 444
        forw_hor_f_code = (motion_data + 0)->forw_hor_f_code;
#line 445
        forw_vert_f_code = (motion_data + 0)->forw_vert_f_code;
#line 446
        back_vert_f_code = 15;
#line 446
        back_hor_f_code = back_vert_f_code;
#line 447
        sxf = (motion_data + 0)->sxf;
#line 448
        syf = (motion_data + 0)->syf;
      }
#line 451
      motion_estimation(oldorgframe[0], neworgframe[0], oldrefframe[0], newrefframe[0],
                        neworg[0], newref[0], sxf, syf, sxb, syb, mbinfo, 1, ipflag);
#line 456
      predict(oldrefframe, newrefframe, (unsigned char **)(predframe), 1, mbinfo);
#line 457
      dct_type_estimation(predframe[0], neworg[0], mbinfo);
#line 458
      transform(predframe, neworg, mbinfo, blocks);
#line 460
      putpict(neworg[0]);
#line 462
      k = 0;
#line 462
      while (k < mb_height2 * mb_width) {
#line 464
        if ((mbinfo + k)->mb_type & 1) {
#line 465
          j = 0;
#line 465
          while (j < block_count) {
#line 466
            iquant_intra(*(blocks + (k * block_count + j)), *(blocks + (k * block_count + j)),
                         dc_prec, intra_q, (mbinfo + k)->mquant);
#line 465
            j ++;
          }
        } else {
#line 469
          j = 0;
#line 469
          while (j < block_count) {
#line 470
            iquant_non_intra(*(blocks + (k * block_count + j)), *(blocks + (k * block_count + j)),
                             inter_q, (mbinfo + k)->mquant);
#line 469
            j ++;
          }
        }
#line 462
        k ++;
      }
#line 474
      itransform(predframe, newref, mbinfo, blocks);
#line 475
      calcSNR((unsigned char **)(neworg), (unsigned char **)(newref));
#line 476
      stats();
    } else {
#line 480
      pict_struct = 3;
#line 489
      data_args.oldorg = oldorgframe[0];
#line 490
      data_args.neworg = neworgframe[0];
#line 491
      data_args.oldref = oldrefframe[0];
#line 492
      data_args.newref = newrefframe[0];
#line 493
      data_args.cur = neworg[0];
#line 494
      data_args.curref = newref[0];
#line 495
      data_args.sxf = sxf;
#line 496
      data_args.syf = syf;
#line 497
      data_args.sxb = sxb;
#line 498
      data_args.syb = syb;
#line 499
      data_args.mbi = mbinfo;
#line 500
      data_args.secondfield = 0;
#line 501
      data_args.ipflag = 0;
#line 503
      data_args.reff = oldrefframe;
#line 504
      data_args.refb = newrefframe;
#line 505
      data_args.pd_cur = predframe;
#line 507
      data_args.pred = predframe[0];
#line 508
      data_args.dte_cur = neworg[0];
#line 510
      data_args.trfm_cur = neworg;
#line 511
      data_args.blocks = (short **)blocks;
#line 513
      data_args.prev_mquant = 20;
#line 514
      data_args.itrfm_cur = newref;
#line 516
      thread_work_dist();
    }
#line 557
    sprintf((char * __restrict  )(name), (char const   * __restrict  )(tplref), f + frame0);
#line 558
    writeframe(name, newref);
#line 255
    i ++;
  }
#line 561
  putseqend();
#line 563
  return;
}
}
#line 1 "motion.o"
#pragma merger("0","/tmp/cil-YCEJjmXG.i","-O4")
#line 89 "src/motion.c"
static void frame_ME(unsigned char *oldorg , unsigned char *neworg , unsigned char *oldref ,
                     unsigned char *newref , unsigned char *cur , int i , int j ,
                     int sxf , int syf , int sxb , int syb , struct mbinfo *mbi ) ;
#line 93
static void field_ME(unsigned char *oldorg , unsigned char *neworg , unsigned char *oldref ,
                     unsigned char *newref , unsigned char *cur , unsigned char *curref ,
                     int i , int j , int sxf , int syf , int sxb , int syb , struct mbinfo *mbi ,
                     int secondfield , int ipflag ) ;
#line 98
static void frame_estimate(unsigned char *org , unsigned char *ref , unsigned char *mb ,
                           int i , int j , int sx , int sy , int *iminp , int *jminp ,
                           int *imintp , int *jmintp , int *iminbp , int *jminbp ,
                           int *dframep , int *dfieldp , int *tselp , int *bselp ,
                           int (*imins)[2] , int (*jmins)[2] ) ;
#line 105
static void field_estimate(unsigned char *toporg , unsigned char *topref , unsigned char *botorg ,
                           unsigned char *botref , unsigned char *mb , int i , int j ,
                           int sx , int sy , int ipflag , int *iminp , int *jminp ,
                           int *imin8up , int *jmin8up , int *imin8lp , int *jmin8lp ,
                           int *dfieldp , int *d8p , int *selp , int *sel8up , int *sel8lp ,
                           int *iminsp , int *jminsp , int *dsp ) ;
#line 112
static void dpframe_estimate(unsigned char *ref , unsigned char *mb , int i , int j ,
                             int (*iminf)[2] , int (*jminf)[2] , int *iminp , int *jminp ,
                             int *imindmvp , int *jmindmvp , int *dmcp , int *vmcp ) ;
#line 117
static void dpfield_estimate(unsigned char *topref , unsigned char *botref , unsigned char *mb ,
                             int i , int j , int imins , int jmins , int *imindmvp ,
                             int *jmindmvp , int *dmcp , int *vmcp ) ;
#line 122
static int fullsearch(unsigned char *org , unsigned char *ref , unsigned char *blk ,
                      int lx , int i0 , int j0 , int sx , int sy , int h , int xmax ,
                      int ymax , int *iminp , int *jminp ) ;
#line 127
static int dist1(unsigned char *blk1 , unsigned char *blk2 , int lx , int hx , int hy ,
                 int h , int distlim ) ;
#line 130
static int dist2(unsigned char *blk1 , unsigned char *blk2 , int lx , int hx , int hy ,
                 int h ) ;
#line 133
static int bdist1(unsigned char *pf , unsigned char *pb , unsigned char *p2 , int lx ,
                  int hxf , int hyf , int hxb , int hyb , int h ) ;
#line 136
static int bdist2(unsigned char *pf , unsigned char *pb , unsigned char *p2 , int lx ,
                  int hxf , int hyf , int hxb , int hyb , int h ) ;
#line 139
static int variance(unsigned char *p , int lx ) ;
#line 164 "src/motion.c"
void motion_estimation(unsigned char *oldorg , unsigned char *neworg , unsigned char *oldref ,
                       unsigned char *newref , unsigned char *cur , unsigned char *curref ,
                       int sxf , int syf , int sxb , int syb , struct mbinfo *mbi ,
                       int secondfield , int ipflag ) 
{ 
  int i ;
  int j ;

  {
#line 174
  j = 0;
#line 174
  while (j < height2) {
#line 176
    i = 0;
#line 176
    while (i < width) {
#line 179
      if (pict_struct == 3) {
#line 180
        frame_ME(oldorg, neworg, oldref, newref, cur, i, j, sxf, syf, sxb, syb, mbi);
      } else {
#line 182
        field_ME(oldorg, neworg, oldref, newref, cur, curref, i, j, sxf, syf, sxb,
                 syb, mbi, secondfield, ipflag);
      }
#line 184
      mbi ++;
#line 176
      i += 16;
    }
#line 174
    j += 16;
  }
#line 190
  return;
}
}
#line 194 "src/motion.c"
void ptmotion_estimation(unsigned char *oldorg , unsigned char *neworg , unsigned char *oldref ,
                         unsigned char *newref , unsigned char *cur , unsigned char *curref ,
                         int sxf , int syf , int sxb , int syb , struct mbinfo *mbi ,
                         int secondfield , int ipflag , int start_height , int end_height ) 
{ 
  int i ;
  int j ;
  struct mbinfo *local_mbi ;

  {
#line 205
  local_mbi = mbi + (start_height >> 4) * (width >> 4);
#line 208
  j = start_height;
#line 208
  while (j < end_height) {
#line 210
    i = 0;
#line 210
    while (i < width) {
#line 213
      if (pict_struct == 3) {
#line 214
        frame_ME(oldorg, neworg, oldref, newref, cur, i, j, sxf, syf, sxb, syb, local_mbi);
      } else {
#line 216
        field_ME(oldorg, neworg, oldref, newref, cur, curref, i, j, sxf, syf, sxb,
                 syb, local_mbi, secondfield, ipflag);
      }
#line 219
      local_mbi ++;
#line 210
      i += 16;
    }
#line 208
    j += 16;
  }
#line 223
  if (! quiet) {
#line 224
    fputc('\n', stderr);
  }
#line 227
  return;
}
}
#line 232 "src/motion.c"
static void frame_ME(unsigned char *oldorg , unsigned char *neworg , unsigned char *oldref ,
                     unsigned char *newref , unsigned char *cur , int i , int j ,
                     int sxf , int syf , int sxb , int syb , struct mbinfo *mbi ) 
{ 
  int imin ;
  int jmin ;
  int iminf ;
  int jminf ;
  int iminr ;
  int jminr ;
  int imint ;
  int jmint ;
  int iminb ;
  int jminb ;
  int imintf ;
  int jmintf ;
  int iminbf ;
  int jminbf ;
  int imintr ;
  int jmintr ;
  int iminbr ;
  int jminbr ;
  int var ;
  int v0 ;
  int dmc ;
  int dmcf ;
  int dmcr ;
  int dmci ;
  int vmc ;
  int vmcf ;
  int vmcr ;
  int vmci ;
  int dmcfield ;
  int dmcfieldf ;
  int dmcfieldr ;
  int dmcfieldi ;
  int tsel ;
  int bsel ;
  int tself ;
  int bself ;
  int tselr ;
  int bselr ;
  unsigned char *mb ;
  int imins[2][2] ;
  int jmins[2][2] ;
  int imindp ;
  int jmindp ;
  int imindmv ;
  int jmindmv ;
  int dmc_dp ;
  int vmc_dp ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;

  {
#line 249
  mb = (cur + i) + width * j;
#line 251
  var = variance(mb, width);
#line 253
  if (pict_type == 1) {
#line 254
    mbi->mb_type = 1;
  } else
#line 255
  if (pict_type == 2) {
#line 257
    if (frame_pred_dct) {
#line 259
      dmc = fullsearch(oldorg, oldref, mb, width, i, j, sxf, syf, 16, width, height,
                       & imin, & jmin);
#line 261
      vmc = dist2((oldref + (imin >> 1)) + width * (jmin >> 1), mb, width, imin & 1,
                  jmin & 1, 16);
#line 263
      mbi->motion_type = 2;
    } else {
#line 267
      frame_estimate(oldorg, oldref, mb, i, j, sxf, syf, & imin, & jmin, & imint,
                     & jmint, & iminb, & jminb, & dmc, & dmcfield, & tsel, & bsel,
                     (int (*)[2])(imins), (int (*)[2])(jmins));
#line 271
      if (M == 1) {
#line 272
        dpframe_estimate(oldref, mb, i, j >> 1, (int (*)[2])(imins), (int (*)[2])(jmins),
                         & imindp, & jmindp, & imindmv, & jmindmv, & dmc_dp, & vmc_dp);
      }
#line 276
      if (M == 1) {
#line 276
        if (dmc_dp < dmc) {
#line 276
          if (dmc_dp < dmcfield) {
#line 278
            mbi->motion_type = 3;
#line 279
            dmc = dmc_dp;
#line 280
            vmc = vmc_dp;
          } else {
#line 276
            goto _L___0;
          }
        } else {
#line 276
          goto _L___0;
        }
      } else
      _L___0: /* CIL Label */ 
#line 282
      if (dmc <= dmcfield) {
#line 284
        mbi->motion_type = 2;
#line 285
        vmc = dist2((oldref + (imin >> 1)) + width * (jmin >> 1), mb, width, imin & 1,
                    jmin & 1, 16);
      } else {
#line 290
        mbi->motion_type = 1;
#line 291
        dmc = dmcfield;
#line 292
        if (tsel) {
#line 292
          tmp = width;
        } else {
#line 292
          tmp = 0;
        }
#line 292
        vmc = dist2(((oldref + tmp) + (imint >> 1)) + (width << 1) * (jmint >> 1),
                    mb, width << 1, imint & 1, jmint & 1, 8);
#line 294
        if (bsel) {
#line 294
          tmp___0 = width;
        } else {
#line 294
          tmp___0 = 0;
        }
#line 294
        tmp___1 = dist2(((oldref + tmp___0) + (iminb >> 1)) + (width << 1) * (jminb >> 1),
                        mb + width, width << 1, iminb & 1, jminb & 1, 8);
#line 294
        vmc += tmp___1;
      }
    }
#line 307
    if (vmc > var) {
#line 307
      if (vmc >= 2304) {
#line 308
        mbi->mb_type = 1;
      } else {
#line 307
        goto _L___1;
      }
    } else {
      _L___1: /* CIL Label */ 
#line 319
      v0 = dist2((oldref + i) + width * j, mb, width, 0, 0, 16);
#line 320
      if (4 * v0 > 5 * vmc) {
#line 320
        if (v0 >= 2304) {
#line 323
          var = vmc;
#line 324
          mbi->mb_type = 8;
#line 325
          if (mbi->motion_type == 2) {
#line 327
            mbi->MV[0][0][0] = imin - (i << 1);
#line 328
            mbi->MV[0][0][1] = jmin - (j << 1);
          } else
#line 330
          if (mbi->motion_type == 3) {
#line 334
            mbi->MV[0][0][0] = imindp - (i << 1);
#line 335
            mbi->MV[0][0][1] = (jmindp << 1) - (j << 1);
#line 338
            mbi->dmvector[0] = imindmv;
#line 339
            mbi->dmvector[1] = jmindmv;
          } else {
#line 344
            mbi->MV[0][0][0] = imint - (i << 1);
#line 345
            mbi->MV[0][0][1] = (jmint << 1) - (j << 1);
#line 346
            mbi->MV[1][0][0] = iminb - (i << 1);
#line 347
            mbi->MV[1][0][1] = (jminb << 1) - (j << 1);
#line 348
            mbi->mv_field_sel[0][0] = tsel;
#line 349
            mbi->mv_field_sel[1][0] = bsel;
          }
        } else {
#line 355
          var = v0;
#line 356
          mbi->mb_type = 0;
#line 357
          mbi->motion_type = 2;
#line 358
          mbi->MV[0][0][0] = 0;
#line 359
          mbi->MV[0][0][1] = 0;
        }
      } else {
#line 355
        var = v0;
#line 356
        mbi->mb_type = 0;
#line 357
        mbi->motion_type = 2;
#line 358
        mbi->MV[0][0][0] = 0;
#line 359
        mbi->MV[0][0][1] = 0;
      }
    }
  } else {
#line 365
    if (frame_pred_dct) {
#line 368
      dmcf = fullsearch(oldorg, oldref, mb, width, i, j, sxf, syf, 16, width, height,
                        & iminf, & jminf);
#line 370
      vmcf = dist2((oldref + (iminf >> 1)) + width * (jminf >> 1), mb, width, iminf & 1,
                   jminf & 1, 16);
#line 374
      dmcr = fullsearch(neworg, newref, mb, width, i, j, sxb, syb, 16, width, height,
                        & iminr, & jminr);
#line 376
      vmcr = dist2((newref + (iminr >> 1)) + width * (jminr >> 1), mb, width, iminr & 1,
                   jminr & 1, 16);
#line 380
      vmci = bdist2((oldref + (iminf >> 1)) + width * (jminf >> 1), (newref + (iminr >> 1)) + width * (jminr >> 1),
                    mb, width, iminf & 1, jminf & 1, iminr & 1, jminr & 1, 16);
#line 389
      if (vmcf <= vmcr) {
#line 389
        if (vmcf <= vmci) {
#line 391
          vmc = vmcf;
#line 392
          mbi->mb_type = 8;
        } else {
#line 389
          goto _L___2;
        }
      } else
      _L___2: /* CIL Label */ 
#line 394
      if (vmcr <= vmci) {
#line 396
        vmc = vmcr;
#line 397
        mbi->mb_type = 4;
      } else {
#line 401
        vmc = vmci;
#line 402
        mbi->mb_type = 12;
      }
#line 405
      mbi->motion_type = 2;
    } else {
#line 410
      frame_estimate(oldorg, oldref, mb, i, j, sxf, syf, & iminf, & jminf, & imintf,
                     & jmintf, & iminbf, & jminbf, & dmcf, & dmcfieldf, & tself, & bself,
                     (int (*)[2])(imins), (int (*)[2])(jmins));
#line 415
      frame_estimate(neworg, newref, mb, i, j, sxb, syb, & iminr, & jminr, & imintr,
                     & jmintr, & iminbr, & jminbr, & dmcr, & dmcfieldr, & tselr, & bselr,
                     (int (*)[2])(imins), (int (*)[2])(jmins));
#line 421
      dmci = bdist1((oldref + (iminf >> 1)) + width * (jminf >> 1), (newref + (iminr >> 1)) + width * (jminr >> 1),
                    mb, width, iminf & 1, jminf & 1, iminr & 1, jminr & 1, 16);
#line 426
      if (tselr) {
#line 426
        tmp___2 = width;
      } else {
#line 426
        tmp___2 = 0;
      }
#line 426
      if (tself) {
#line 426
        tmp___3 = width;
      } else {
#line 426
        tmp___3 = 0;
      }
#line 426
      dmcfieldi = bdist1(((oldref + (imintf >> 1)) + tmp___3) + (width << 1) * (jmintf >> 1),
                         ((newref + (imintr >> 1)) + tmp___2) + (width << 1) * (jmintr >> 1),
                         mb, width << 1, imintf & 1, jmintf & 1, imintr & 1, jmintr & 1,
                         8);
#line 432
      if (bselr) {
#line 432
        tmp___4 = width;
      } else {
#line 432
        tmp___4 = 0;
      }
#line 432
      if (bself) {
#line 432
        tmp___5 = width;
      } else {
#line 432
        tmp___5 = 0;
      }
#line 432
      tmp___6 = bdist1(((oldref + (iminbf >> 1)) + tmp___5) + (width << 1) * (jminbf >> 1),
                       ((newref + (iminbr >> 1)) + tmp___4) + (width << 1) * (jminbr >> 1),
                       mb + width, width << 1, iminbf & 1, jminbf & 1, iminbr & 1,
                       jminbr & 1, 8);
#line 432
      dmcfieldi += tmp___6;
#line 440
      if (dmci < dmcfieldi) {
#line 440
        if (dmci < dmcf) {
#line 440
          if (dmci < dmcfieldf) {
#line 440
            if (dmci < dmcr) {
#line 440
              if (dmci < dmcfieldr) {
#line 444
                mbi->mb_type = 12;
#line 445
                mbi->motion_type = 2;
#line 446
                vmc = bdist2((oldref + (iminf >> 1)) + width * (jminf >> 1), (newref + (iminr >> 1)) + width * (jminr >> 1),
                             mb, width, iminf & 1, jminf & 1, iminr & 1, jminr & 1,
                             16);
              } else {
#line 440
                goto _L___12;
              }
            } else {
#line 440
              goto _L___12;
            }
          } else {
#line 440
            goto _L___12;
          }
        } else {
#line 440
          goto _L___12;
        }
      } else
      _L___12: /* CIL Label */ 
#line 450
      if (dmcfieldi < dmcf) {
#line 450
        if (dmcfieldi < dmcfieldf) {
#line 450
          if (dmcfieldi < dmcr) {
#line 450
            if (dmcfieldi < dmcfieldr) {
#line 454
              mbi->mb_type = 12;
#line 455
              mbi->motion_type = 1;
#line 456
              if (tselr) {
#line 456
                tmp___7 = width;
              } else {
#line 456
                tmp___7 = 0;
              }
#line 456
              if (tself) {
#line 456
                tmp___8 = width;
              } else {
#line 456
                tmp___8 = 0;
              }
#line 456
              vmc = bdist2(((oldref + (imintf >> 1)) + tmp___8) + (width << 1) * (jmintf >> 1),
                           ((newref + (imintr >> 1)) + tmp___7) + (width << 1) * (jmintr >> 1),
                           mb, width << 1, imintf & 1, jmintf & 1, imintr & 1, jmintr & 1,
                           8);
#line 459
              if (bselr) {
#line 459
                tmp___9 = width;
              } else {
#line 459
                tmp___9 = 0;
              }
#line 459
              if (bself) {
#line 459
                tmp___10 = width;
              } else {
#line 459
                tmp___10 = 0;
              }
#line 459
              tmp___11 = bdist2(((oldref + (iminbf >> 1)) + tmp___10) + (width << 1) * (jminbf >> 1),
                                ((newref + (iminbr >> 1)) + tmp___9) + (width << 1) * (jminbr >> 1),
                                mb + width, width << 1, iminbf & 1, jminbf & 1, iminbr & 1,
                                jminbr & 1, 8);
#line 459
              vmc += tmp___11;
            } else {
#line 450
              goto _L___8;
            }
          } else {
#line 450
            goto _L___8;
          }
        } else {
#line 450
          goto _L___8;
        }
      } else
      _L___8: /* CIL Label */ 
#line 463
      if (dmcf < dmcfieldf) {
#line 463
        if (dmcf < dmcr) {
#line 463
          if (dmcf < dmcfieldr) {
#line 466
            mbi->mb_type = 8;
#line 467
            mbi->motion_type = 2;
#line 468
            vmc = dist2((oldref + (iminf >> 1)) + width * (jminf >> 1), mb, width,
                        iminf & 1, jminf & 1, 16);
          } else {
#line 463
            goto _L___5;
          }
        } else {
#line 463
          goto _L___5;
        }
      } else
      _L___5: /* CIL Label */ 
#line 471
      if (dmcfieldf < dmcr) {
#line 471
        if (dmcfieldf < dmcfieldr) {
#line 474
          mbi->mb_type = 8;
#line 475
          mbi->motion_type = 1;
#line 476
          if (tself) {
#line 476
            tmp___12 = width;
          } else {
#line 476
            tmp___12 = 0;
          }
#line 476
          vmc = dist2(((oldref + tmp___12) + (imintf >> 1)) + (width << 1) * (jmintf >> 1),
                      mb, width << 1, imintf & 1, jmintf & 1, 8);
#line 478
          if (bself) {
#line 478
            tmp___13 = width;
          } else {
#line 478
            tmp___13 = 0;
          }
#line 478
          tmp___14 = dist2(((oldref + tmp___13) + (iminbf >> 1)) + (width << 1) * (jminbf >> 1),
                           mb + width, width << 1, iminbf & 1, jminbf & 1, 8);
#line 478
          vmc += tmp___14;
        } else {
#line 471
          goto _L___3;
        }
      } else
      _L___3: /* CIL Label */ 
#line 481
      if (dmcr < dmcfieldr) {
#line 484
        mbi->mb_type = 4;
#line 485
        mbi->motion_type = 2;
#line 486
        vmc = dist2((newref + (iminr >> 1)) + width * (jminr >> 1), mb, width, iminr & 1,
                    jminr & 1, 16);
      } else {
#line 492
        mbi->mb_type = 4;
#line 493
        mbi->motion_type = 1;
#line 494
        if (tselr) {
#line 494
          tmp___15 = width;
        } else {
#line 494
          tmp___15 = 0;
        }
#line 494
        vmc = dist2(((newref + tmp___15) + (imintr >> 1)) + (width << 1) * (jmintr >> 1),
                    mb, width << 1, imintr & 1, jmintr & 1, 8);
#line 496
        if (bselr) {
#line 496
          tmp___16 = width;
        } else {
#line 496
          tmp___16 = 0;
        }
#line 496
        tmp___17 = dist2(((newref + tmp___16) + (iminbr >> 1)) + (width << 1) * (jminbr >> 1),
                         mb + width, width << 1, iminbr & 1, jminbr & 1, 8);
#line 496
        vmc += tmp___17;
      }
    }
#line 509
    if (vmc > var) {
#line 509
      if (vmc >= 2304) {
#line 510
        mbi->mb_type = 1;
      } else {
#line 509
        goto _L___13;
      }
    } else {
      _L___13: /* CIL Label */ 
#line 513
      var = vmc;
#line 514
      if (mbi->motion_type == 2) {
#line 517
        mbi->MV[0][0][0] = iminf - (i << 1);
#line 518
        mbi->MV[0][0][1] = jminf - (j << 1);
#line 520
        mbi->MV[0][1][0] = iminr - (i << 1);
#line 521
        mbi->MV[0][1][1] = jminr - (j << 1);
      } else {
#line 527
        mbi->MV[0][0][0] = imintf - (i << 1);
#line 528
        mbi->MV[0][0][1] = (jmintf << 1) - (j << 1);
#line 529
        mbi->MV[1][0][0] = iminbf - (i << 1);
#line 530
        mbi->MV[1][0][1] = (jminbf << 1) - (j << 1);
#line 531
        mbi->mv_field_sel[0][0] = tself;
#line 532
        mbi->mv_field_sel[1][0] = bself;
#line 534
        mbi->MV[0][1][0] = imintr - (i << 1);
#line 535
        mbi->MV[0][1][1] = (jmintr << 1) - (j << 1);
#line 536
        mbi->MV[1][1][0] = iminbr - (i << 1);
#line 537
        mbi->MV[1][1][1] = (jminbr << 1) - (j << 1);
#line 538
        mbi->mv_field_sel[0][1] = tselr;
#line 539
        mbi->mv_field_sel[1][1] = bselr;
      }
    }
  }
#line 544
  mbi->var = var;
#line 545
  return;
}
}
#line 575 "src/motion.c"
static void field_ME(unsigned char *oldorg , unsigned char *neworg , unsigned char *oldref ,
                     unsigned char *newref , unsigned char *cur , unsigned char *curref ,
                     int i , int j , int sxf , int syf , int sxb , int syb , struct mbinfo *mbi ,
                     int secondfield , int ipflag ) 
{ 
  int w2 ;
  unsigned char *mb ;
  unsigned char *toporg ;
  unsigned char *topref ;
  unsigned char *botorg ;
  unsigned char *botref ;
  int var ;
  int vmc ;
  int v0 ;
  int dmc ;
  int dmcfieldi ;
  int dmc8i ;
  int imin ;
  int jmin ;
  int imin8u ;
  int jmin8u ;
  int imin8l ;
  int jmin8l ;
  int dmcfield ;
  int dmc8 ;
  int sel ;
  int sel8u ;
  int sel8l ;
  int iminf ;
  int jminf ;
  int imin8uf ;
  int jmin8uf ;
  int imin8lf ;
  int jmin8lf ;
  int dmcfieldf ;
  int dmc8f ;
  int self ;
  int sel8uf ;
  int sel8lf ;
  int iminr ;
  int jminr ;
  int imin8ur ;
  int jmin8ur ;
  int imin8lr ;
  int jmin8lr ;
  int dmcfieldr ;
  int dmc8r ;
  int selr ;
  int sel8ur ;
  int sel8lr ;
  int imins ;
  int jmins ;
  int ds ;
  int imindmv ;
  int jmindmv ;
  int vmc_dp ;
  int dmc_dp ;
  unsigned char *tmp ;
  unsigned char *tmp___0 ;
  int tmp___1 ;
  unsigned char *tmp___2 ;
  unsigned char *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;
  int tmp___25 ;

  {
#line 590
  w2 = width << 1;
#line 592
  mb = (cur + i) + w2 * j;
#line 593
  if (pict_struct == 2) {
#line 594
    mb += width;
  }
#line 596
  var = variance(mb, w2);
#line 598
  if (pict_type == 1) {
#line 599
    mbi->mb_type = 1;
  } else
#line 600
  if (pict_type == 2) {
#line 602
    toporg = oldorg;
#line 603
    topref = oldref;
#line 604
    botorg = oldorg + width;
#line 605
    botref = oldref + width;
#line 607
    if (secondfield) {
#line 610
      if (pict_struct == 1) {
#line 613
        botorg = cur + width;
#line 614
        botref = curref + width;
      } else {
#line 619
        toporg = cur;
#line 620
        topref = curref;
      }
    }
#line 624
    field_estimate(toporg, topref, botorg, botref, mb, i, j, sxf, syf, ipflag, & imin,
                   & jmin, & imin8u, & jmin8u, & imin8l, & jmin8l, & dmcfield, & dmc8,
                   & sel, & sel8u, & sel8l, & imins, & jmins, & ds);
#line 628
    if (M == 1) {
#line 628
      if (! ipflag) {
#line 629
        dpfield_estimate(topref, botref, mb, i, j, imins, jmins, & imindmv, & jmindmv,
                         & dmc_dp, & vmc_dp);
      }
    }
#line 633
    if (M == 1) {
#line 633
      if (! ipflag) {
#line 633
        if (dmc_dp < dmc8) {
#line 633
          if (dmc_dp < dmcfield) {
#line 636
            mbi->motion_type = 3;
#line 637
            dmc = dmc_dp;
#line 638
            vmc = vmc_dp;
          } else {
#line 633
            goto _L___1;
          }
        } else {
#line 633
          goto _L___1;
        }
      } else {
#line 633
        goto _L___1;
      }
    } else
    _L___1: /* CIL Label */ 
#line 641
    if (dmc8 < dmcfield) {
#line 644
      mbi->motion_type = 2;
#line 646
      if (sel8u) {
#line 646
        tmp = botref;
      } else {
#line 646
        tmp = topref;
      }
#line 646
      vmc = dist2((tmp + (imin8u >> 1)) + w2 * (jmin8u >> 1), mb, w2, imin8u & 1,
                  jmin8u & 1, 8);
#line 649
      if (sel8l) {
#line 649
        tmp___0 = botref;
      } else {
#line 649
        tmp___0 = topref;
      }
#line 649
      tmp___1 = dist2((tmp___0 + (imin8l >> 1)) + w2 * (jmin8l >> 1), mb + 8 * w2,
                      w2, imin8l & 1, jmin8l & 1, 8);
#line 649
      vmc += tmp___1;
    } else {
#line 655
      mbi->motion_type = 1;
#line 656
      if (sel) {
#line 656
        tmp___2 = botref;
      } else {
#line 656
        tmp___2 = topref;
      }
#line 656
      vmc = dist2((tmp___2 + (imin >> 1)) + w2 * (jmin >> 1), mb, w2, imin & 1, jmin & 1,
                  16);
    }
#line 661
    if (vmc > var) {
#line 661
      if (vmc >= 2304) {
#line 662
        mbi->mb_type = 1;
      } else {
#line 661
        goto _L___4;
      }
    } else {
      _L___4: /* CIL Label */ 
#line 668
      if (! ipflag) {
#line 669
        if (pict_struct == 2) {
#line 669
          tmp___3 = botref;
        } else {
#line 669
          tmp___3 = topref;
        }
#line 669
        v0 = dist2((tmp___3 + i) + w2 * j, mb, w2, 0, 0, 16);
      }
#line 671
      if (ipflag) {
#line 671
        goto _L___2;
      } else
#line 671
      if (4 * v0 > 5 * vmc) {
#line 671
        if (v0 >= 2304) {
          _L___2: /* CIL Label */ 
#line 673
          var = vmc;
#line 674
          mbi->mb_type = 8;
#line 675
          if (mbi->motion_type == 1) {
#line 677
            mbi->MV[0][0][0] = imin - (i << 1);
#line 678
            mbi->MV[0][0][1] = jmin - (j << 1);
#line 679
            mbi->mv_field_sel[0][0] = sel;
          } else
#line 681
          if (mbi->motion_type == 3) {
#line 684
            mbi->MV[0][0][0] = imins - (i << 1);
#line 685
            mbi->MV[0][0][1] = jmins - (j << 1);
#line 688
            mbi->dmvector[0] = imindmv;
#line 689
            mbi->dmvector[1] = jmindmv;
          } else {
#line 693
            mbi->MV[0][0][0] = imin8u - (i << 1);
#line 694
            mbi->MV[0][0][1] = jmin8u - (j << 1);
#line 695
            mbi->MV[1][0][0] = imin8l - (i << 1);
#line 696
            mbi->MV[1][0][1] = jmin8l - ((j + 8) << 1);
#line 697
            mbi->mv_field_sel[0][0] = sel8u;
#line 698
            mbi->mv_field_sel[1][0] = sel8l;
          }
        } else {
#line 671
          goto _L___3;
        }
      } else {
        _L___3: /* CIL Label */ 
#line 704
        var = v0;
#line 705
        mbi->mb_type = 0;
#line 706
        mbi->motion_type = 1;
#line 707
        mbi->MV[0][0][0] = 0;
#line 708
        mbi->MV[0][0][1] = 0;
#line 709
        mbi->mv_field_sel[0][0] = pict_struct == 2;
      }
    }
  } else {
#line 716
    field_estimate(oldorg, oldref, oldorg + width, oldref + width, mb, i, j, sxf,
                   syf, 0, & iminf, & jminf, & imin8uf, & jmin8uf, & imin8lf, & jmin8lf,
                   & dmcfieldf, & dmc8f, & self, & sel8uf, & sel8lf, & imins, & jmins,
                   & ds);
#line 722
    field_estimate(neworg, newref, neworg + width, newref + width, mb, i, j, sxb,
                   syb, 0, & iminr, & jminr, & imin8ur, & jmin8ur, & imin8lr, & jmin8lr,
                   & dmcfieldr, & dmc8r, & selr, & sel8ur, & sel8lr, & imins, & jmins,
                   & ds);
#line 729
    if (selr) {
#line 729
      tmp___4 = width;
    } else {
#line 729
      tmp___4 = 0;
    }
#line 729
    if (self) {
#line 729
      tmp___5 = width;
    } else {
#line 729
      tmp___5 = 0;
    }
#line 729
    dmcfieldi = bdist1(((oldref + tmp___5) + (iminf >> 1)) + w2 * (jminf >> 1), ((newref + tmp___4) + (iminr >> 1)) + w2 * (jminr >> 1),
                       mb, w2, iminf & 1, jminf & 1, iminr & 1, jminr & 1, 16);
#line 734
    if (sel8ur) {
#line 734
      tmp___6 = width;
    } else {
#line 734
      tmp___6 = 0;
    }
#line 734
    if (sel8uf) {
#line 734
      tmp___7 = width;
    } else {
#line 734
      tmp___7 = 0;
    }
#line 734
    dmc8i = bdist1(((oldref + tmp___7) + (imin8uf >> 1)) + w2 * (jmin8uf >> 1), ((newref + tmp___6) + (imin8ur >> 1)) + w2 * (jmin8ur >> 1),
                   mb, w2, imin8uf & 1, jmin8uf & 1, imin8ur & 1, jmin8ur & 1, 8);
#line 739
    if (sel8lr) {
#line 739
      tmp___8 = width;
    } else {
#line 739
      tmp___8 = 0;
    }
#line 739
    if (sel8lf) {
#line 739
      tmp___9 = width;
    } else {
#line 739
      tmp___9 = 0;
    }
#line 739
    tmp___10 = bdist1(((oldref + tmp___9) + (imin8lf >> 1)) + w2 * (jmin8lf >> 1),
                      ((newref + tmp___8) + (imin8lr >> 1)) + w2 * (jmin8lr >> 1),
                      mb + 8 * w2, w2, imin8lf & 1, jmin8lf & 1, imin8lr & 1, jmin8lr & 1,
                      8);
#line 739
    dmc8i += tmp___10;
#line 744
    if (dmcfieldi < dmc8i) {
#line 744
      if (dmcfieldi < dmcfieldf) {
#line 744
        if (dmcfieldi < dmc8f) {
#line 744
          if (dmcfieldi < dmcfieldr) {
#line 744
            if (dmcfieldi < dmc8r) {
#line 748
              mbi->mb_type = 12;
#line 749
              mbi->motion_type = 1;
#line 750
              if (selr) {
#line 750
                tmp___11 = width;
              } else {
#line 750
                tmp___11 = 0;
              }
#line 750
              if (self) {
#line 750
                tmp___12 = width;
              } else {
#line 750
                tmp___12 = 0;
              }
#line 750
              vmc = bdist2(((oldref + tmp___12) + (iminf >> 1)) + w2 * (jminf >> 1),
                           ((newref + tmp___11) + (iminr >> 1)) + w2 * (jminr >> 1),
                           mb, w2, iminf & 1, jminf & 1, iminr & 1, jminr & 1, 16);
            } else {
#line 744
              goto _L___14;
            }
          } else {
#line 744
            goto _L___14;
          }
        } else {
#line 744
          goto _L___14;
        }
      } else {
#line 744
        goto _L___14;
      }
    } else
    _L___14: /* CIL Label */ 
#line 754
    if (dmc8i < dmcfieldf) {
#line 754
      if (dmc8i < dmc8f) {
#line 754
        if (dmc8i < dmcfieldr) {
#line 754
          if (dmc8i < dmc8r) {
#line 758
            mbi->mb_type = 12;
#line 759
            mbi->motion_type = 2;
#line 762
            if (sel8ur) {
#line 762
              tmp___13 = width;
            } else {
#line 762
              tmp___13 = 0;
            }
#line 762
            if (sel8uf) {
#line 762
              tmp___14 = width;
            } else {
#line 762
              tmp___14 = 0;
            }
#line 762
            vmc = bdist2(((oldref + tmp___14) + (imin8uf >> 1)) + w2 * (jmin8uf >> 1),
                         ((newref + tmp___13) + (imin8ur >> 1)) + w2 * (jmin8ur >> 1),
                         mb, w2, imin8uf & 1, jmin8uf & 1, imin8ur & 1, jmin8ur & 1,
                         8);
#line 767
            if (sel8lr) {
#line 767
              tmp___15 = width;
            } else {
#line 767
              tmp___15 = 0;
            }
#line 767
            if (sel8lf) {
#line 767
              tmp___16 = width;
            } else {
#line 767
              tmp___16 = 0;
            }
#line 767
            tmp___17 = bdist2(((oldref + tmp___16) + (imin8lf >> 1)) + w2 * (jmin8lf >> 1),
                              ((newref + tmp___15) + (imin8lr >> 1)) + w2 * (jmin8lr >> 1),
                              mb + 8 * w2, w2, imin8lf & 1, jmin8lf & 1, imin8lr & 1,
                              jmin8lr & 1, 8);
#line 767
            vmc += tmp___17;
          } else {
#line 754
            goto _L___10;
          }
        } else {
#line 754
          goto _L___10;
        }
      } else {
#line 754
        goto _L___10;
      }
    } else
    _L___10: /* CIL Label */ 
#line 771
    if (dmcfieldf < dmc8f) {
#line 771
      if (dmcfieldf < dmcfieldr) {
#line 771
        if (dmcfieldf < dmc8r) {
#line 774
          mbi->mb_type = 8;
#line 775
          mbi->motion_type = 1;
#line 776
          if (self) {
#line 776
            tmp___18 = width;
          } else {
#line 776
            tmp___18 = 0;
          }
#line 776
          vmc = dist2(((oldref + tmp___18) + (iminf >> 1)) + w2 * (jminf >> 1), mb,
                      w2, iminf & 1, jminf & 1, 16);
        } else {
#line 771
          goto _L___7;
        }
      } else {
#line 771
        goto _L___7;
      }
    } else
    _L___7: /* CIL Label */ 
#line 779
    if (dmc8f < dmcfieldr) {
#line 779
      if (dmc8f < dmc8r) {
#line 782
        mbi->mb_type = 8;
#line 783
        mbi->motion_type = 2;
#line 786
        if (sel8uf) {
#line 786
          tmp___19 = width;
        } else {
#line 786
          tmp___19 = 0;
        }
#line 786
        vmc = dist2(((oldref + tmp___19) + (imin8uf >> 1)) + w2 * (jmin8uf >> 1),
                    mb, w2, imin8uf & 1, jmin8uf & 1, 8);
#line 790
        if (sel8lf) {
#line 790
          tmp___20 = width;
        } else {
#line 790
          tmp___20 = 0;
        }
#line 790
        tmp___21 = dist2(((oldref + tmp___20) + (imin8lf >> 1)) + w2 * (jmin8lf >> 1),
                         mb + 8 * w2, w2, imin8lf & 1, jmin8lf & 1, 8);
#line 790
        vmc += tmp___21;
      } else {
#line 779
        goto _L___5;
      }
    } else
    _L___5: /* CIL Label */ 
#line 793
    if (dmcfieldr < dmc8r) {
#line 796
      mbi->mb_type = 4;
#line 797
      mbi->motion_type = 1;
#line 798
      if (selr) {
#line 798
        tmp___22 = width;
      } else {
#line 798
        tmp___22 = 0;
      }
#line 798
      vmc = dist2(((newref + tmp___22) + (iminr >> 1)) + w2 * (jminr >> 1), mb, w2,
                  iminr & 1, jminr & 1, 16);
    } else {
#line 804
      mbi->mb_type = 4;
#line 805
      mbi->motion_type = 2;
#line 808
      if (sel8ur) {
#line 808
        tmp___23 = width;
      } else {
#line 808
        tmp___23 = 0;
      }
#line 808
      vmc = dist2(((newref + tmp___23) + (imin8ur >> 1)) + w2 * (jmin8ur >> 1), mb,
                  w2, imin8ur & 1, jmin8ur & 1, 8);
#line 812
      if (sel8lr) {
#line 812
        tmp___24 = width;
      } else {
#line 812
        tmp___24 = 0;
      }
#line 812
      tmp___25 = dist2(((newref + tmp___24) + (imin8lr >> 1)) + w2 * (jmin8lr >> 1),
                       mb + 8 * w2, w2, imin8lr & 1, jmin8lr & 1, 8);
#line 812
      vmc += tmp___25;
    }
#line 817
    if (vmc > var) {
#line 817
      if (vmc >= 2304) {
#line 818
        mbi->mb_type = 1;
      } else {
#line 817
        goto _L___15;
      }
    } else {
      _L___15: /* CIL Label */ 
#line 821
      var = vmc;
#line 822
      if (mbi->motion_type == 1) {
#line 825
        mbi->MV[0][0][0] = iminf - (i << 1);
#line 826
        mbi->MV[0][0][1] = jminf - (j << 1);
#line 827
        mbi->mv_field_sel[0][0] = self;
#line 829
        mbi->MV[0][1][0] = iminr - (i << 1);
#line 830
        mbi->MV[0][1][1] = jminr - (j << 1);
#line 831
        mbi->mv_field_sel[0][1] = selr;
      } else {
#line 836
        mbi->MV[0][0][0] = imin8uf - (i << 1);
#line 837
        mbi->MV[0][0][1] = jmin8uf - (j << 1);
#line 838
        mbi->mv_field_sel[0][0] = sel8uf;
#line 839
        mbi->MV[1][0][0] = imin8lf - (i << 1);
#line 840
        mbi->MV[1][0][1] = jmin8lf - ((j + 8) << 1);
#line 841
        mbi->mv_field_sel[1][0] = sel8lf;
#line 843
        mbi->MV[0][1][0] = imin8ur - (i << 1);
#line 844
        mbi->MV[0][1][1] = jmin8ur - (j << 1);
#line 845
        mbi->mv_field_sel[0][1] = sel8ur;
#line 846
        mbi->MV[1][1][0] = imin8lr - (i << 1);
#line 847
        mbi->MV[1][1][1] = jmin8lr - ((j + 8) << 1);
#line 848
        mbi->mv_field_sel[1][1] = sel8lr;
      }
    }
  }
#line 853
  mbi->var = var;
#line 854
  return;
}
}
#line 869 "src/motion.c"
static void frame_estimate(unsigned char *org , unsigned char *ref , unsigned char *mb ,
                           int i , int j , int sx , int sy , int *iminp , int *jminp ,
                           int *imintp , int *jmintp , int *iminbp , int *jminbp ,
                           int *dframep , int *dfieldp , int *tselp , int *bselp ,
                           int (*imins)[2] , int (*jmins)[2] ) 
{ 
  int dt ;
  int db ;
  int dmint ;
  int dminb ;
  int imint ;
  int iminb ;
  int jmint ;
  int jminb ;

  {
#line 884
  *dframep = fullsearch(org, ref, mb, width, i, j, sx, sy, 16, width, height, iminp,
                        jminp);
#line 888
  dt = fullsearch(org, ref, mb, width << 1, i, j >> 1, sx, sy >> 1, 8, width, height >> 1,
                  & imint, & jmint);
#line 892
  db = fullsearch(org + width, ref + width, mb, width << 1, i, j >> 1, sx, sy >> 1,
                  8, width, height >> 1, & iminb, & jminb);
#line 895
  (*(imins + 0))[0] = imint;
#line 896
  (*(jmins + 0))[0] = jmint;
#line 897
  (*(imins + 1))[0] = iminb;
#line 898
  (*(jmins + 1))[0] = jminb;
#line 901
  if (dt <= db) {
#line 903
    dmint = dt;
#line 903
    *imintp = imint;
#line 903
    *jmintp = jmint;
#line 903
    *tselp = 0;
  } else {
#line 907
    dmint = db;
#line 907
    *imintp = iminb;
#line 907
    *jmintp = jminb;
#line 907
    *tselp = 1;
  }
#line 911
  dt = fullsearch(org, ref, mb + width, width << 1, i, j >> 1, sx, sy >> 1, 8, width,
                  height >> 1, & imint, & jmint);
#line 915
  db = fullsearch(org + width, ref + width, mb + width, width << 1, i, j >> 1, sx,
                  sy >> 1, 8, width, height >> 1, & iminb, & jminb);
#line 918
  (*(imins + 0))[1] = imint;
#line 919
  (*(jmins + 0))[1] = jmint;
#line 920
  (*(imins + 1))[1] = iminb;
#line 921
  (*(jmins + 1))[1] = jminb;
#line 924
  if (db <= dt) {
#line 926
    dminb = db;
#line 926
    *iminbp = iminb;
#line 926
    *jminbp = jminb;
#line 926
    *bselp = 1;
  } else {
#line 930
    dminb = dt;
#line 930
    *iminbp = imint;
#line 930
    *jminbp = jmint;
#line 930
    *bselp = 0;
  }
#line 933
  *dfieldp = dmint + dminb;
#line 934
  return;
}
}
#line 955 "src/motion.c"
static void field_estimate(unsigned char *toporg , unsigned char *topref , unsigned char *botorg ,
                           unsigned char *botref , unsigned char *mb , int i , int j ,
                           int sx , int sy , int ipflag , int *iminp , int *jminp ,
                           int *imin8up , int *jmin8up , int *imin8lp , int *jmin8lp ,
                           int *dfieldp , int *d8p , int *selp , int *sel8up , int *sel8lp ,
                           int *iminsp , int *jminsp , int *dsp ) 
{ 
  int dt ;
  int db ;
  int imint ;
  int jmint ;
  int iminb ;
  int jminb ;
  int notop ;
  int nobot ;
  int tmp ;
  int tmp___0 ;

  {
#line 970
  if (ipflag) {
#line 970
    if (pict_struct == 1) {
#line 970
      tmp = 1;
    } else {
#line 970
      tmp = 0;
    }
  } else {
#line 970
    tmp = 0;
  }
#line 970
  notop = tmp;
#line 971
  if (ipflag) {
#line 971
    if (pict_struct == 2) {
#line 971
      tmp___0 = 1;
    } else {
#line 971
      tmp___0 = 0;
    }
  } else {
#line 971
    tmp___0 = 0;
  }
#line 971
  nobot = tmp___0;
#line 976
  if (notop) {
#line 977
    dt = 65536;
  } else {
#line 979
    dt = fullsearch(toporg, topref, mb, width << 1, i, j, sx, sy >> 1, 16, width,
                    height >> 1, & imint, & jmint);
  }
#line 984
  if (nobot) {
#line 985
    db = 65536;
  } else {
#line 987
    db = fullsearch(botorg, botref, mb, width << 1, i, j, sx, sy >> 1, 16, width,
                    height >> 1, & iminb, & jminb);
  }
#line 992
  if (pict_struct == 1) {
#line 994
    *iminsp = imint;
#line 994
    *jminsp = jmint;
#line 994
    *dsp = dt;
  } else {
#line 998
    *iminsp = iminb;
#line 998
    *jminsp = jminb;
#line 998
    *dsp = db;
  }
#line 1002
  if (dt <= db) {
#line 1004
    *dfieldp = dt;
#line 1004
    *iminp = imint;
#line 1004
    *jminp = jmint;
#line 1004
    *selp = 0;
  } else {
#line 1008
    *dfieldp = db;
#line 1008
    *iminp = iminb;
#line 1008
    *jminp = jminb;
#line 1008
    *selp = 1;
  }
#line 1015
  if (notop) {
#line 1016
    dt = 65536;
  } else {
#line 1018
    dt = fullsearch(toporg, topref, mb, width << 1, i, j, sx, sy >> 1, 8, width, height >> 1,
                    & imint, & jmint);
  }
#line 1023
  if (nobot) {
#line 1024
    db = 65536;
  } else {
#line 1026
    db = fullsearch(botorg, botref, mb, width << 1, i, j, sx, sy >> 1, 8, width, height >> 1,
                    & iminb, & jminb);
  }
#line 1031
  if (dt <= db) {
#line 1033
    *d8p = dt;
#line 1033
    *imin8up = imint;
#line 1033
    *jmin8up = jmint;
#line 1033
    *sel8up = 0;
  } else {
#line 1037
    *d8p = db;
#line 1037
    *imin8up = iminb;
#line 1037
    *jmin8up = jminb;
#line 1037
    *sel8up = 1;
  }
#line 1041
  if (notop) {
#line 1042
    dt = 65536;
  } else {
#line 1044
    dt = fullsearch(toporg, topref, mb + (width << 4), width << 1, i, j + 8, sx, sy >> 1,
                    8, width, height >> 1, & imint, & jmint);
  }
#line 1049
  if (nobot) {
#line 1050
    db = 65536;
  } else {
#line 1052
    db = fullsearch(botorg, botref, mb + (width << 4), width << 1, i, j + 8, sx, sy >> 1,
                    8, width, height >> 1, & iminb, & jminb);
  }
#line 1057
  if (dt <= db) {
#line 1059
    *d8p += dt;
#line 1059
    *imin8lp = imint;
#line 1059
    *jmin8lp = jmint;
#line 1059
    *sel8lp = 0;
  } else {
#line 1063
    *d8p += db;
#line 1063
    *imin8lp = iminb;
#line 1063
    *jmin8lp = jminb;
#line 1063
    *sel8lp = 1;
  }
#line 1065
  return;
}
}
#line 1067 "src/motion.c"
static void dpframe_estimate(unsigned char *ref , unsigned char *mb , int i , int j ,
                             int (*iminf)[2] , int (*jminf)[2] , int *iminp , int *jminp ,
                             int *imindmvp , int *jmindmvp , int *dmcp , int *vmcp ) 
{ 
  int pref ;
  int ppred ;
  int delta_x ;
  int delta_y ;
  int is ;
  int js ;
  int it ;
  int jt ;
  int ib ;
  int jb ;
  int it0 ;
  int jt0 ;
  int ib0 ;
  int jb0 ;
  int imins ;
  int jmins ;
  int imint ;
  int jmint ;
  int iminb ;
  int jminb ;
  int imindmv ;
  int jmindmv ;
  int vmc ;
  int local_dist ;
  int tmp ;
  int tmp___0 ;

  {
#line 1087
  vmc = 1 << 30;
#line 1089
  pref = 0;
#line 1089
  while (pref < 2) {
#line 1091
    ppred = 0;
#line 1091
    while (ppred < 2) {
#line 1096
      is = (*(iminf + pref))[ppred] - (i << 1);
#line 1097
      js = (*(jminf + pref))[ppred] - (j << 1);
#line 1099
      if (pref != ppred) {
#line 1102
        if (ppred == 0) {
#line 1103
          js ++;
        } else {
#line 1105
          js --;
        }
#line 1108
        is <<= 1;
#line 1109
        js <<= 1;
#line 1110
        if (topfirst == ppred) {
#line 1113
          if (is >= 0) {
#line 1113
            is = (is + 1) / 3;
          } else {
#line 1113
            is = - ((- is + 1) / 3);
          }
#line 1114
          if (js >= 0) {
#line 1114
            js = (js + 1) / 3;
          } else {
#line 1114
            js = - ((- js + 1) / 3);
          }
        } else {
#line 1117
          goto __Cont;
        }
      }
#line 1121
      if (topfirst) {
#line 1124
        it0 = (is + (is > 0)) >> 1;
#line 1125
        jt0 = ((js + (js > 0)) >> 1) - 1;
#line 1128
        ib0 = (3 * is + (is > 0)) >> 1;
#line 1129
        jb0 = ((3 * js + (js > 0)) >> 1) + 1;
      } else {
#line 1134
        it0 = (3 * is + (is > 0)) >> 1;
#line 1135
        jt0 = ((3 * js + (js > 0)) >> 1) - 1;
#line 1138
        ib0 = (is + (is > 0)) >> 1;
#line 1139
        jb0 = ((js + (js > 0)) >> 1) + 1;
      }
#line 1143
      is += i << 1;
#line 1144
      js += j << 1;
#line 1145
      it0 += i << 1;
#line 1146
      jt0 += j << 1;
#line 1147
      ib0 += i << 1;
#line 1148
      jb0 += j << 1;
#line 1150
      if (is >= 0) {
#line 1150
        if (is <= (width - 16) << 1) {
#line 1150
          if (js >= 0) {
#line 1150
            if (js <= height - 16) {
#line 1153
              delta_y = -1;
#line 1153
              while (delta_y <= 1) {
#line 1155
                delta_x = -1;
#line 1155
                while (delta_x <= 1) {
#line 1158
                  it = it0 + delta_x;
#line 1159
                  jt = jt0 + delta_y;
#line 1160
                  ib = ib0 + delta_x;
#line 1161
                  jb = jb0 + delta_y;
#line 1163
                  if (it >= 0) {
#line 1163
                    if (it <= (width - 16) << 1) {
#line 1163
                      if (jt >= 0) {
#line 1163
                        if (jt <= height - 16) {
#line 1163
                          if (ib >= 0) {
#line 1163
                            if (ib <= (width - 16) << 1) {
#line 1163
                              if (jb >= 0) {
#line 1163
                                if (jb <= height - 16) {
#line 1169
                                  local_dist = bdist2((ref + (is >> 1)) + (width << 1) * (js >> 1),
                                                      ((ref + width) + (it >> 1)) + (width << 1) * (jt >> 1),
                                                      mb, width << 1, is & 1, js & 1,
                                                      it & 1, jt & 1, 8);
#line 1176
                                  tmp = bdist2(((ref + width) + (is >> 1)) + (width << 1) * (js >> 1),
                                               (ref + (ib >> 1)) + (width << 1) * (jb >> 1),
                                               mb + width, width << 1, is & 1, js & 1,
                                               ib & 1, jb & 1, 8);
#line 1176
                                  local_dist += tmp;
#line 1185
                                  if (local_dist < vmc) {
#line 1187
                                    imins = is;
#line 1188
                                    jmins = js;
#line 1189
                                    imint = it;
#line 1190
                                    jmint = jt;
#line 1191
                                    iminb = ib;
#line 1192
                                    jminb = jb;
#line 1193
                                    imindmv = delta_x;
#line 1194
                                    jmindmv = delta_y;
#line 1195
                                    vmc = local_dist;
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
#line 1155
                  delta_x ++;
                }
#line 1153
                delta_y ++;
              }
            }
          }
        }
      }
      __Cont: /* CIL Label */ 
#line 1091
      ppred ++;
    }
#line 1089
    pref ++;
  }
#line 1205
  local_dist = bdist1((ref + (imins >> 1)) + (width << 1) * (jmins >> 1), ((ref + width) + (imint >> 1)) + (width << 1) * (jmint >> 1),
                      mb, width << 1, imins & 1, jmins & 1, imint & 1, jmint & 1,
                      8);
#line 1212
  tmp___0 = bdist1(((ref + width) + (imins >> 1)) + (width << 1) * (jmins >> 1), (ref + (iminb >> 1)) + (width << 1) * (jminb >> 1),
                   mb + width, width << 1, imins & 1, jmins & 1, iminb & 1, jminb & 1,
                   8);
#line 1212
  local_dist += tmp___0;
#line 1220
  *dmcp = local_dist;
#line 1221
  *iminp = imins;
#line 1222
  *jminp = jmins;
#line 1223
  *imindmvp = imindmv;
#line 1224
  *jmindmvp = jmindmv;
#line 1225
  *vmcp = vmc;
#line 1226
  return;
}
}
#line 1228 "src/motion.c"
static void dpfield_estimate(unsigned char *topref , unsigned char *botref , unsigned char *mb ,
                             int i , int j , int imins , int jmins , int *imindmvp ,
                             int *jmindmvp , int *dmcp , int *vmcp ) 
{ 
  unsigned char *sameref ;
  unsigned char *oppref ;
  int io0 ;
  int jo0 ;
  int io ;
  int jo ;
  int delta_x ;
  int delta_y ;
  int mvxs ;
  int mvys ;
  int mvxo0 ;
  int mvyo0 ;
  int imino ;
  int jmino ;
  int imindmv ;
  int jmindmv ;
  int vmc_dp ;
  int local_dist ;

  {
#line 1244
  if (pict_struct == 1) {
#line 1246
    sameref = topref;
#line 1247
    oppref = botref;
  } else {
#line 1251
    sameref = botref;
#line 1252
    oppref = topref;
  }
#line 1258
  mvxs = imins - (i << 1);
#line 1259
  mvys = jmins - (j << 1);
#line 1262
  mvxo0 = (mvxs + (mvxs > 0)) >> 1;
#line 1263
  mvyo0 = (mvys + (mvys > 0)) >> 1;
#line 1266
  if (pict_struct == 1) {
#line 1267
    mvyo0 --;
  } else {
#line 1269
    mvyo0 ++;
  }
#line 1272
  io0 = mvxo0 + (i << 1);
#line 1273
  jo0 = mvyo0 + (j << 1);
#line 1276
  vmc_dp = 1 << 30;
#line 1278
  delta_y = -1;
#line 1278
  while (delta_y <= 1) {
#line 1280
    delta_x = -1;
#line 1280
    while (delta_x <= 1) {
#line 1283
      io = io0 + delta_x;
#line 1284
      jo = jo0 + delta_y;
#line 1286
      if (io >= 0) {
#line 1286
        if (io <= (width - 16) << 1) {
#line 1286
          if (jo >= 0) {
#line 1286
            if (jo <= (height2 - 16) << 1) {
#line 1290
              local_dist = bdist2((sameref + (imins >> 1)) + width2 * (jmins >> 1),
                                  (oppref + (io >> 1)) + width2 * (jo >> 1), mb, width2,
                                  imins & 1, jmins & 1, io & 1, jo & 1, 16);
#line 1299
              if (local_dist < vmc_dp) {
#line 1301
                imino = io;
#line 1302
                jmino = jo;
#line 1303
                imindmv = delta_x;
#line 1304
                jmindmv = delta_y;
#line 1305
                vmc_dp = local_dist;
              }
            }
          }
        }
      }
#line 1280
      delta_x ++;
    }
#line 1278
    delta_y ++;
  }
#line 1312
  *dmcp = bdist1((sameref + (imins >> 1)) + width2 * (jmins >> 1), (oppref + (imino >> 1)) + width2 * (jmino >> 1),
                 mb, width2, imins & 1, jmins & 1, imino & 1, jmino & 1, 16);
#line 1320
  *imindmvp = imindmv;
#line 1321
  *jmindmvp = jmindmv;
#line 1322
  *vmcp = vmc_dp;
#line 1323
  return;
}
}
#line 1375 "src/motion.c"
static int fullsearch(unsigned char *org , unsigned char *ref , unsigned char *blk ,
                      int lx , int i0 , int j0 , int sx , int sy , int h , int xmax ,
                      int ymax , int *iminp , int *jminp ) 
{ 
  int i ;
  int j ;
  int imin ;
  int jmin ;
  int ilow ;
  int ihigh ;
  int jlow ;
  int jhigh ;
  int d___0 ;
  int dmin ;
  int p ;
  int w ;
  int z ;
  int limitx ;
  int limity ;

  {
#line 1388
  imin = i0;
#line 1389
  jmin = j0;
#line 1390
  dmin = dist1((org + imin) + lx * jmin, blk, lx, 0, 0, h, 65536);
#line 1415
  if (dmin > 64) {
#line 1424
    ilow = i0 - sx;
#line 1425
    ihigh = i0 + sx;
#line 1427
    if (ilow < 0) {
#line 1428
      ilow = 0;
    }
#line 1430
    if (ihigh > xmax - 16) {
#line 1431
      ihigh = xmax - 16;
    }
#line 1433
    jlow = j0 - sy;
#line 1434
    jhigh = j0 + sy;
#line 1436
    if (jlow < 0) {
#line 1437
      jlow = 0;
    }
#line 1439
    if (jhigh > ymax - h) {
#line 1440
      jhigh = ymax - h;
    }
#line 1443
    limitx = sx / 4;
#line 1444
    limity = sy / 4;
#line 1450
    w = - limitx;
#line 1450
    while (w <= limitx) {
#line 1452
      z = - limity;
#line 1452
      while (z <= limity) {
#line 1455
        i = i0 + 4 * w;
#line 1456
        j = j0 + 4 * z;
#line 1458
        if (i >= ilow) {
#line 1458
          if (i <= ihigh) {
#line 1458
            if (j >= jlow) {
#line 1458
              if (j <= jhigh) {
#line 1460
                d___0 = dist1((org + i) + lx * j, blk, lx, 0, 0, h, dmin);
#line 1461
                if (d___0 < dmin) {
#line 1463
                  imin = i;
#line 1464
                  jmin = j;
#line 1465
                  dmin = d___0;
                }
              }
            }
          }
        }
#line 1452
        z ++;
      }
#line 1450
      w ++;
    }
#line 1482
    p = 2;
#line 1483
    i0 = imin;
#line 1484
    j0 = jmin;
#line 1486
    while (p > 0) {
#line 1488
      i = i0 - p;
#line 1489
      j = j0 - p;
#line 1490
      if (i >= ilow) {
#line 1490
        if (i <= ihigh) {
#line 1490
          if (j >= jlow) {
#line 1490
            if (j <= jhigh) {
#line 1492
              d___0 = dist1((org + i) + lx * j, blk, lx, 0, 0, h, dmin);
#line 1493
              if (d___0 < dmin) {
#line 1495
                imin = i;
#line 1496
                jmin = j;
#line 1497
                dmin = d___0;
              }
            }
          }
        }
      }
#line 1500
      i = i0 - p;
#line 1501
      j = j0 + p;
#line 1502
      if (i >= ilow) {
#line 1502
        if (i <= ihigh) {
#line 1502
          if (j >= jlow) {
#line 1502
            if (j <= jhigh) {
#line 1504
              d___0 = dist1((org + i) + lx * j, blk, lx, 0, 0, h, dmin);
#line 1505
              if (d___0 < dmin) {
#line 1507
                imin = i;
#line 1508
                jmin = j;
#line 1509
                dmin = d___0;
              }
            }
          }
        }
      }
#line 1512
      i = i0 + p;
#line 1513
      j = j0 - p;
#line 1514
      if (i >= ilow) {
#line 1514
        if (i <= ihigh) {
#line 1514
          if (j >= jlow) {
#line 1514
            if (j <= jhigh) {
#line 1516
              d___0 = dist1((org + i) + lx * j, blk, lx, 0, 0, h, dmin);
#line 1517
              if (d___0 < dmin) {
#line 1519
                imin = i;
#line 1520
                jmin = j;
#line 1521
                dmin = d___0;
              }
            }
          }
        }
      }
#line 1524
      i = i0 + p;
#line 1525
      j = j0 + p;
#line 1526
      if (i >= ilow) {
#line 1526
        if (i <= ihigh) {
#line 1526
          if (j >= jlow) {
#line 1526
            if (j <= jhigh) {
#line 1528
              d___0 = dist1((org + i) + lx * j, blk, lx, 0, 0, h, dmin);
#line 1529
              if (d___0 < dmin) {
#line 1531
                imin = i;
#line 1532
                jmin = j;
#line 1533
                dmin = d___0;
              }
            }
          }
        }
      }
#line 1536
      i = i0 + p;
#line 1537
      j = j0;
#line 1538
      if (i >= ilow) {
#line 1538
        if (i <= ihigh) {
#line 1538
          if (j >= jlow) {
#line 1538
            if (j <= jhigh) {
#line 1540
              d___0 = dist1((org + i) + lx * j, blk, lx, 0, 0, h, dmin);
#line 1541
              if (d___0 < dmin) {
#line 1543
                imin = i;
#line 1544
                jmin = j;
#line 1545
                dmin = d___0;
              }
            }
          }
        }
      }
#line 1548
      i = i0;
#line 1549
      j = j0 - p;
#line 1550
      if (i >= ilow) {
#line 1550
        if (i <= ihigh) {
#line 1550
          if (j >= jlow) {
#line 1550
            if (j <= jhigh) {
#line 1552
              d___0 = dist1((org + i) + lx * j, blk, lx, 0, 0, h, dmin);
#line 1553
              if (d___0 < dmin) {
#line 1555
                imin = i;
#line 1556
                jmin = j;
#line 1557
                dmin = d___0;
              }
            }
          }
        }
      }
#line 1560
      i = i0 - p;
#line 1561
      j = j0;
#line 1562
      if (i >= ilow) {
#line 1562
        if (i <= ihigh) {
#line 1562
          if (j >= jlow) {
#line 1562
            if (j <= jhigh) {
#line 1564
              d___0 = dist1((org + i) + lx * j, blk, lx, 0, 0, h, dmin);
#line 1565
              if (d___0 < dmin) {
#line 1567
                imin = i;
#line 1568
                jmin = j;
#line 1569
                dmin = d___0;
              }
            }
          }
        }
      }
#line 1572
      i = i0;
#line 1573
      j = j0 + p;
#line 1574
      if (i >= ilow) {
#line 1574
        if (i <= ihigh) {
#line 1574
          if (j >= jlow) {
#line 1574
            if (j <= jhigh) {
#line 1576
              d___0 = dist1((org + i) + lx * j, blk, lx, 0, 0, h, dmin);
#line 1577
              if (d___0 < dmin) {
#line 1579
                imin = i;
#line 1580
                jmin = j;
#line 1581
                dmin = d___0;
              }
            }
          }
        }
      }
#line 1586
      i0 = imin;
#line 1587
      j0 = jmin;
#line 1588
      p /= 2;
    }
  }
#line 1602
  dmin = 65536;
#line 1603
  imin <<= 1;
#line 1604
  jmin <<= 1;
#line 1605
  ilow = imin - (imin > 0);
#line 1606
  ihigh = imin + (imin < (xmax - 16) << 1);
#line 1607
  jlow = jmin - (jmin > 0);
#line 1608
  jhigh = jmin + (jmin < (ymax - h) << 1);
#line 1610
  j = jlow;
#line 1610
  while (j <= jhigh) {
#line 1611
    i = ilow;
#line 1611
    while (i <= ihigh) {
#line 1613
      d___0 = dist1((ref + (i >> 1)) + lx * (j >> 1), blk, lx, i & 1, j & 1, h, dmin);
#line 1615
      if (d___0 < dmin) {
#line 1617
        dmin = d___0;
#line 1618
        imin = i;
#line 1619
        jmin = j;
      }
#line 1611
      i ++;
    }
#line 1610
    j ++;
  }
#line 1628
  *iminp = imin;
#line 1629
  *jminp = jmin;
#line 1631
  return (dmin);
}
}
#line 1672 "src/motion.c"
static int dist1(unsigned char *blk1 , unsigned char *blk2 , int lx , int hx , int hy ,
                 int h , int distlim ) 
{ 
  unsigned char *p1 ;
  unsigned char *p1a ;
  unsigned char *p2 ;
  int i ;
  int j ;
  int s ;
  int v ;
  int sa ;
  int tmp ;

  {
#line 1682
  sa = 0;
#line 1684
  if (! hx) {
#line 1684
    if (! hy) {
#line 1687
      s = 0;
#line 1688
      p1 = blk1;
#line 1689
      p2 = blk2;
#line 1728
      j = 0;
#line 1728
      while (j < h) {
#line 1729
        i = 0;
#line 1729
        while (i < 16) {
#line 1730
          v = (int )*(p1 + i) - (int )*(p2 + i);
#line 1731
          if (v >= 0) {
#line 1731
            tmp = v;
          } else {
#line 1731
            tmp = - v;
          }
#line 1731
          s += tmp;
#line 1729
          i ++;
        }
#line 1736
        p1 += lx;
#line 1737
        p2 += lx;
#line 1728
        j ++;
      }
    } else {
#line 1684
      goto _L___1;
    }
  } else
  _L___1: /* CIL Label */ 
#line 1746
  if (hx) {
#line 1746
    if (! hy) {
#line 1750
      s = 0;
#line 1751
      p1 = blk1;
#line 1752
      p2 = blk2;
#line 1781
      j = 0;
#line 1781
      while (j < h) {
#line 1783
        i = 0;
#line 1783
        while (i < 16) {
#line 1785
          v = (int )(((unsigned int )(((int )*(p1 + i) + (int )*(p1 + (i + 1))) + 1) >> 1) - (unsigned int )*(p2 + i));
#line 1786
          if (v >= 0) {
#line 1787
            s += v;
          } else {
#line 1789
            s -= v;
          }
#line 1783
          i ++;
        }
#line 1792
        p1 += lx;
#line 1793
        p2 += lx;
#line 1781
        j ++;
      }
    } else {
#line 1746
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
#line 1805
  if (! hx) {
#line 1805
    if (hy) {
#line 1807
      s = 0;
#line 1808
      p1 = blk1;
#line 1809
      p2 = blk2;
#line 1810
      p1a = p1 + lx;
#line 1842
      j = 0;
#line 1842
      while (j < h) {
#line 1844
        i = 0;
#line 1844
        while (i < 16) {
#line 1846
          v = (int )(((unsigned int )(((int )*(p1 + i) + (int )*(p1a + i)) + 1) >> 1) - (unsigned int )*(p2 + i));
#line 1847
          if (v >= 0) {
#line 1848
            s += v;
          } else {
#line 1850
            s -= v;
          }
#line 1844
          i ++;
        }
#line 1854
        p1 = p1a;
#line 1855
        p1a += lx;
#line 1856
        p2 += lx;
#line 1842
        j ++;
      }
    } else {
#line 1805
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
#line 1870
    s = 0;
#line 1871
    p1 = blk1;
#line 1872
    p2 = blk2;
#line 1873
    p1a = p1 + lx;
#line 1909
    j = 0;
#line 1909
    while (j < h) {
#line 1910
      i = 0;
#line 1910
      while (i < 16) {
#line 1911
        v = (int )(((unsigned int )(((((int )*(p1 + i) + (int )*(p1 + (i + 1))) + (int )*(p1a + i)) + (int )*(p1a + (i + 1))) + 2) >> 2) - (unsigned int )*(p2 + i));
#line 1912
        if (v >= 0) {
#line 1913
          s += v;
        } else {
#line 1915
          s -= v;
        }
#line 1910
        i ++;
      }
#line 1917
      p1 = p1a;
#line 1918
      p1a += lx;
#line 1919
      p2 += lx;
#line 1909
      j ++;
    }
  }
#line 1925
  return (s);
}
}
#line 1944 "src/motion.c"
static int dist2(unsigned char *blk1 , unsigned char *blk2 , int lx , int hx , int hy ,
                 int h ) 
{ 
  unsigned char *p1 ;
  unsigned char *p1a ;
  unsigned char *p2 ;
  int i ;
  int j ;
  int s ;
  int v ;
  int sa ;

  {
#line 1953
  sa = 0;
#line 1956
  if (! hx) {
#line 1956
    if (! hy) {
#line 1958
      s = 0;
#line 1959
      p1 = blk1;
#line 1960
      p2 = blk2;
#line 2000
      j = 0;
#line 2000
      while (j < h) {
#line 2001
        i = 0;
#line 2001
        while (i < 16) {
#line 2002
          v = (int )*(p1 + i) - (int )*(p2 + i);
#line 2003
          s += v * v;
#line 2001
          i ++;
        }
#line 2006
        p1 += lx;
#line 2007
        p2 += lx;
#line 2000
        j ++;
      }
    } else {
#line 1956
      goto _L___1;
    }
  } else
  _L___1: /* CIL Label */ 
#line 2014
  if (hx) {
#line 2014
    if (! hy) {
#line 2016
      s = 0;
#line 2017
      p1 = blk1;
#line 2018
      p2 = blk2;
#line 2060
      j = 0;
#line 2060
      while (j < h) {
#line 2062
        i = 0;
#line 2062
        while (i < 16) {
#line 2064
          v = (int )(((unsigned int )(((int )*(p1 + i) + (int )*(p1 + (i + 1))) + 1) >> 1) - (unsigned int )*(p2 + i));
#line 2065
          s += v * v;
#line 2062
          i ++;
        }
#line 2069
        p1 += lx;
#line 2070
        p2 += lx;
#line 2060
        j ++;
      }
    } else {
#line 2014
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
#line 2077
  if (! hx) {
#line 2077
    if (hy) {
#line 2080
      s = 0;
#line 2081
      p1 = blk1;
#line 2082
      p2 = blk2;
#line 2083
      p1a = p1 + lx;
#line 2126
      j = 0;
#line 2126
      while (j < h) {
#line 2128
        i = 0;
#line 2128
        while (i < 16) {
#line 2130
          v = (int )(((unsigned int )(((int )*(p1 + i) + (int )*(p1a + i)) + 1) >> 1) - (unsigned int )*(p2 + i));
#line 2131
          s += v * v;
#line 2128
          i ++;
        }
#line 2137
        p1 = p1a;
#line 2138
        p1a += lx;
#line 2139
        p2 += lx;
#line 2126
        j ++;
      }
    } else {
#line 2077
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
#line 2153
    s = 0;
#line 2154
    p1 = blk1;
#line 2155
    p2 = blk2;
#line 2156
    p1a = p1 + lx;
#line 2203
    j = 0;
#line 2203
    while (j < h) {
#line 2205
      i = 0;
#line 2205
      while (i < 16) {
#line 2206
        v = (int )(((unsigned int )(((((int )*(p1 + i) + (int )*(p1 + (i + 1))) + (int )*(p1a + i)) + (int )*(p1a + (i + 1))) + 2) >> 2) - (unsigned int )*(p2 + i));
#line 2207
        s += v * v;
#line 2205
        i ++;
      }
#line 2212
      p1 = p1a;
#line 2213
      p1a += lx;
#line 2214
      p2 += lx;
#line 2203
      j ++;
    }
  }
#line 2222
  return (s);
}
}
#line 2237 "src/motion.c"
static int bdist1(unsigned char *pf , unsigned char *pb , unsigned char *p2 , int lx ,
                  int hxf , int hyf , int hxb , int hyb , int h ) 
{ 
  unsigned char *pfa ;
  unsigned char *pfb ;
  unsigned char *pfc ;
  unsigned char *pba ;
  unsigned char *pbb ;
  unsigned char *pbc ;
  int i ;
  int j ;
  int s ;
  int v ;
  int sa ;
  unsigned char *tmp ;
  unsigned char *tmp___0 ;
  unsigned char *tmp___1 ;
  unsigned char *tmp___2 ;
  unsigned char *tmp___3 ;
  unsigned char *tmp___4 ;
  unsigned char *tmp___5 ;
  unsigned char *tmp___6 ;
  unsigned char *tmp___7 ;

  {
#line 2244
  sa = 0;
#line 2246
  pfa = pf + hxf;
#line 2247
  pfb = pf + lx * hyf;
#line 2248
  pfc = pfb + hxf;
#line 2250
  pba = pb + hxb;
#line 2251
  pbb = pb + lx * hyb;
#line 2252
  pbc = pbb + hxb;
#line 2254
  s = 0;
#line 2314
  j = 0;
#line 2314
  while (j < h) {
#line 2317
    i = 0;
#line 2317
    while (i < 16) {
#line 2319
      tmp = pf;
#line 2319
      pf ++;
#line 2319
      tmp___0 = pfa;
#line 2319
      pfa ++;
#line 2319
      tmp___1 = pfb;
#line 2319
      pfb ++;
#line 2319
      tmp___2 = pfc;
#line 2319
      pfc ++;
#line 2319
      tmp___3 = pb;
#line 2319
      pb ++;
#line 2319
      tmp___4 = pba;
#line 2319
      pba ++;
#line 2319
      tmp___5 = pbb;
#line 2319
      pbb ++;
#line 2319
      tmp___6 = pbc;
#line 2319
      pbc ++;
#line 2319
      tmp___7 = p2;
#line 2319
      p2 ++;
#line 2319
      v = (int )((((((unsigned int )(((((int )*tmp + (int )*tmp___0) + (int )*tmp___1) + (int )*tmp___2) + 2) >> 2) + ((unsigned int )(((((int )*tmp___3 + (int )*tmp___4) + (int )*tmp___5) + (int )*tmp___6) + 2) >> 2)) + 1U) >> 1) - (unsigned int )*tmp___7);
#line 2322
      if (v >= 0) {
#line 2323
        s += v;
      } else {
#line 2325
        s -= v;
      }
#line 2317
      i ++;
    }
#line 2327
    p2 += lx - 16;
#line 2328
    pf += lx - 16;
#line 2329
    pfa += lx - 16;
#line 2330
    pfb += lx - 16;
#line 2331
    pfc += lx - 16;
#line 2332
    pb += lx - 16;
#line 2333
    pba += lx - 16;
#line 2334
    pbb += lx - 16;
#line 2335
    pbc += lx - 16;
#line 2314
    j ++;
  }
#line 2339
  return (s);
}
}
#line 2358 "src/motion.c"
static int bdist2(unsigned char *pf , unsigned char *pb , unsigned char *p2 , int lx ,
                  int hxf , int hyf , int hxb , int hyb , int h ) 
{ 
  unsigned char *pfa ;
  unsigned char *pfb ;
  unsigned char *pfc ;
  unsigned char *pba ;
  unsigned char *pbb ;
  unsigned char *pbc ;
  int i ;
  int j ;
  int s ;
  int v ;
  int sa ;
  unsigned char *tmp ;
  unsigned char *tmp___0 ;
  unsigned char *tmp___1 ;
  unsigned char *tmp___2 ;
  unsigned char *tmp___3 ;
  unsigned char *tmp___4 ;
  unsigned char *tmp___5 ;
  unsigned char *tmp___6 ;
  unsigned char *tmp___7 ;

  {
#line 2365
  sa = 0;
#line 2367
  pfa = pf + hxf;
#line 2368
  pfb = pf + lx * hyf;
#line 2369
  pfc = pfb + hxf;
#line 2371
  pba = pb + hxb;
#line 2372
  pbb = pb + lx * hyb;
#line 2373
  pbc = pbb + hxb;
#line 2445
  s = 0;
#line 2447
  j = 0;
#line 2447
  while (j < h) {
#line 2449
    i = 0;
#line 2449
    while (i < 16) {
#line 2451
      tmp = pf;
#line 2451
      pf ++;
#line 2451
      tmp___0 = pfa;
#line 2451
      pfa ++;
#line 2451
      tmp___1 = pfb;
#line 2451
      pfb ++;
#line 2451
      tmp___2 = pfc;
#line 2451
      pfc ++;
#line 2451
      tmp___3 = pb;
#line 2451
      pb ++;
#line 2451
      tmp___4 = pba;
#line 2451
      pba ++;
#line 2451
      tmp___5 = pbb;
#line 2451
      pbb ++;
#line 2451
      tmp___6 = pbc;
#line 2451
      pbc ++;
#line 2451
      tmp___7 = p2;
#line 2451
      p2 ++;
#line 2451
      v = (int )((((((unsigned int )(((((int )*tmp + (int )*tmp___0) + (int )*tmp___1) + (int )*tmp___2) + 2) >> 2) + ((unsigned int )(((((int )*tmp___3 + (int )*tmp___4) + (int )*tmp___5) + (int )*tmp___6) + 2) >> 2)) + 1U) >> 1) - (unsigned int )*tmp___7);
#line 2454
      s += v * v;
#line 2449
      i ++;
    }
#line 2456
    p2 += lx - 16;
#line 2457
    pf += lx - 16;
#line 2458
    pfa += lx - 16;
#line 2459
    pfb += lx - 16;
#line 2460
    pfc += lx - 16;
#line 2461
    pb += lx - 16;
#line 2462
    pba += lx - 16;
#line 2463
    pbb += lx - 16;
#line 2464
    pbc += lx - 16;
#line 2447
    j ++;
  }
#line 2470
  return (s);
}
}
#line 2480 "src/motion.c"
static int variance(unsigned char *p , int lx ) 
{ 
  int i ;
  int j ;
  unsigned int v ;
  unsigned int s ;
  unsigned int s2 ;
  unsigned int sa ;
  unsigned int s2a ;
  unsigned char *tmp ;

  {
#line 2488
  s2a = 0U;
#line 2488
  sa = s2a;
#line 2489
  s2 = 0U;
#line 2489
  s = s2;
#line 2530
  j = 0;
#line 2530
  while (j < 16) {
#line 2532
    i = 0;
#line 2532
    while (i < 16) {
#line 2533
      tmp = p;
#line 2533
      p ++;
#line 2533
      v = (unsigned int )*tmp;
#line 2534
      s += v;
#line 2535
      s2 += v * v;
#line 2532
      i ++;
    }
#line 2538
    p += lx - 16;
#line 2530
    j ++;
  }
#line 2541
  return ((int )(s2 - (s * s) / 256U));
}
}
#line 1 "mpeg2enc.o"
#pragma merger("0","/tmp/cil-zkEbXUl1.i","-O4")
#line 425 "/usr/include/stdio.h"
extern int ( __attribute__((__warn_unused_result__)) fscanf)(FILE * __restrict  __stream ,
                                                             char const   * __restrict  __format 
                                                             , ...)  __asm__("__isoc99_fscanf")  ;
#line 433
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) sscanf)(char const   * __restrict  __s ,
                                                                             char const   * __restrict  __format 
                                                                             , ...)  __asm__("__isoc99_sscanf")  ;
#line 133 "src/global.h"
void initbits(void) ;
#line 250 "src/global.h"
char version[27]  = 
#line 250
  {      (char )'m',      (char )'p',      (char )'e',      (char )'g', 
        (char )'2',      (char )'e',      (char )'n',      (char )'c', 
        (char )'o',      (char )'d',      (char )'e',      (char )' ', 
        (char )'V',      (char )'1',      (char )'.',      (char )'2', 
        (char )',',      (char )' ',      (char )'9',      (char )'6', 
        (char )'/',      (char )'0',      (char )'7',      (char )'/', 
        (char )'1',      (char )'9',      (char )'\000'};
#line 256 "src/global.h"
char author[41]  = 
#line 256
  {      (char )'(',      (char )'C',      (char )')',      (char )' ', 
        (char )'1',      (char )'9',      (char )'9',      (char )'6', 
        (char )',',      (char )' ',      (char )'M',      (char )'P', 
        (char )'E',      (char )'G',      (char )' ',      (char )'S', 
        (char )'o',      (char )'f',      (char )'t',      (char )'w', 
        (char )'a',      (char )'r',      (char )'e',      (char )' ', 
        (char )'S',      (char )'i',      (char )'m',      (char )'u', 
        (char )'l',      (char )'a',      (char )'t',      (char )'i', 
        (char )'o',      (char )'n',      (char )' ',      (char )'G', 
        (char )'r',      (char )'o',      (char )'u',      (char )'p', 
        (char )'\000'};
#line 263 "src/global.h"
unsigned char zig_zag_scan[64]  = 
#line 263
  {      (unsigned char)0,      (unsigned char)1,      (unsigned char)8,      (unsigned char)16, 
        (unsigned char)9,      (unsigned char)2,      (unsigned char)3,      (unsigned char)10, 
        (unsigned char)17,      (unsigned char)24,      (unsigned char)32,      (unsigned char)25, 
        (unsigned char)18,      (unsigned char)11,      (unsigned char)4,      (unsigned char)5, 
        (unsigned char)12,      (unsigned char)19,      (unsigned char)26,      (unsigned char)33, 
        (unsigned char)40,      (unsigned char)48,      (unsigned char)41,      (unsigned char)34, 
        (unsigned char)27,      (unsigned char)20,      (unsigned char)13,      (unsigned char)6, 
        (unsigned char)7,      (unsigned char)14,      (unsigned char)21,      (unsigned char)28, 
        (unsigned char)35,      (unsigned char)42,      (unsigned char)49,      (unsigned char)56, 
        (unsigned char)57,      (unsigned char)50,      (unsigned char)43,      (unsigned char)36, 
        (unsigned char)29,      (unsigned char)22,      (unsigned char)15,      (unsigned char)23, 
        (unsigned char)30,      (unsigned char)37,      (unsigned char)44,      (unsigned char)51, 
        (unsigned char)58,      (unsigned char)59,      (unsigned char)52,      (unsigned char)45, 
        (unsigned char)38,      (unsigned char)31,      (unsigned char)39,      (unsigned char)46, 
        (unsigned char)53,      (unsigned char)60,      (unsigned char)61,      (unsigned char)54, 
        (unsigned char)47,      (unsigned char)55,      (unsigned char)62,      (unsigned char)63};
#line 276 "src/global.h"
unsigned char alternate_scan[64]  = 
#line 276
  {      (unsigned char)0,      (unsigned char)8,      (unsigned char)16,      (unsigned char)24, 
        (unsigned char)1,      (unsigned char)9,      (unsigned char)2,      (unsigned char)10, 
        (unsigned char)17,      (unsigned char)25,      (unsigned char)32,      (unsigned char)40, 
        (unsigned char)48,      (unsigned char)56,      (unsigned char)57,      (unsigned char)49, 
        (unsigned char)41,      (unsigned char)33,      (unsigned char)26,      (unsigned char)18, 
        (unsigned char)3,      (unsigned char)11,      (unsigned char)4,      (unsigned char)12, 
        (unsigned char)19,      (unsigned char)27,      (unsigned char)34,      (unsigned char)42, 
        (unsigned char)50,      (unsigned char)58,      (unsigned char)35,      (unsigned char)43, 
        (unsigned char)51,      (unsigned char)59,      (unsigned char)20,      (unsigned char)28, 
        (unsigned char)5,      (unsigned char)13,      (unsigned char)6,      (unsigned char)14, 
        (unsigned char)21,      (unsigned char)29,      (unsigned char)36,      (unsigned char)44, 
        (unsigned char)52,      (unsigned char)60,      (unsigned char)37,      (unsigned char)45, 
        (unsigned char)53,      (unsigned char)61,      (unsigned char)22,      (unsigned char)30, 
        (unsigned char)7,      (unsigned char)15,      (unsigned char)23,      (unsigned char)31, 
        (unsigned char)38,      (unsigned char)46,      (unsigned char)54,      (unsigned char)62, 
        (unsigned char)39,      (unsigned char)47,      (unsigned char)55,      (unsigned char)63};
#line 289 "src/global.h"
unsigned char default_intra_quantizer_matrix[64]  = 
#line 289
  {      (unsigned char)8,      (unsigned char)16,      (unsigned char)19,      (unsigned char)22, 
        (unsigned char)26,      (unsigned char)27,      (unsigned char)29,      (unsigned char)34, 
        (unsigned char)16,      (unsigned char)16,      (unsigned char)22,      (unsigned char)24, 
        (unsigned char)27,      (unsigned char)29,      (unsigned char)34,      (unsigned char)37, 
        (unsigned char)19,      (unsigned char)22,      (unsigned char)26,      (unsigned char)27, 
        (unsigned char)29,      (unsigned char)34,      (unsigned char)34,      (unsigned char)38, 
        (unsigned char)22,      (unsigned char)22,      (unsigned char)26,      (unsigned char)27, 
        (unsigned char)29,      (unsigned char)34,      (unsigned char)37,      (unsigned char)40, 
        (unsigned char)22,      (unsigned char)26,      (unsigned char)27,      (unsigned char)29, 
        (unsigned char)32,      (unsigned char)35,      (unsigned char)40,      (unsigned char)48, 
        (unsigned char)26,      (unsigned char)27,      (unsigned char)29,      (unsigned char)32, 
        (unsigned char)35,      (unsigned char)40,      (unsigned char)48,      (unsigned char)58, 
        (unsigned char)26,      (unsigned char)27,      (unsigned char)29,      (unsigned char)34, 
        (unsigned char)38,      (unsigned char)46,      (unsigned char)56,      (unsigned char)69, 
        (unsigned char)27,      (unsigned char)29,      (unsigned char)35,      (unsigned char)38, 
        (unsigned char)46,      (unsigned char)56,      (unsigned char)69,      (unsigned char)83};
#line 306 "src/global.h"
unsigned char non_linear_mquant_table[32]  = 
#line 306
  {      (unsigned char)0,      (unsigned char)1,      (unsigned char)2,      (unsigned char)3, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)6,      (unsigned char)7, 
        (unsigned char)8,      (unsigned char)10,      (unsigned char)12,      (unsigned char)14, 
        (unsigned char)16,      (unsigned char)18,      (unsigned char)20,      (unsigned char)22, 
        (unsigned char)24,      (unsigned char)28,      (unsigned char)32,      (unsigned char)36, 
        (unsigned char)40,      (unsigned char)44,      (unsigned char)48,      (unsigned char)52, 
        (unsigned char)56,      (unsigned char)64,      (unsigned char)72,      (unsigned char)80, 
        (unsigned char)88,      (unsigned char)96,      (unsigned char)104,      (unsigned char)112};
#line 323 "src/global.h"
unsigned char map_non_linear_mquant[113]  = 
#line 323
  {      (unsigned char)0,      (unsigned char)1,      (unsigned char)2,      (unsigned char)3, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)6,      (unsigned char)7, 
        (unsigned char)8,      (unsigned char)8,      (unsigned char)9,      (unsigned char)9, 
        (unsigned char)10,      (unsigned char)10,      (unsigned char)11,      (unsigned char)11, 
        (unsigned char)12,      (unsigned char)12,      (unsigned char)13,      (unsigned char)13, 
        (unsigned char)14,      (unsigned char)14,      (unsigned char)15,      (unsigned char)15, 
        (unsigned char)16,      (unsigned char)16,      (unsigned char)16,      (unsigned char)17, 
        (unsigned char)17,      (unsigned char)17,      (unsigned char)18,      (unsigned char)18, 
        (unsigned char)18,      (unsigned char)18,      (unsigned char)19,      (unsigned char)19, 
        (unsigned char)19,      (unsigned char)19,      (unsigned char)20,      (unsigned char)20, 
        (unsigned char)20,      (unsigned char)20,      (unsigned char)21,      (unsigned char)21, 
        (unsigned char)21,      (unsigned char)21,      (unsigned char)22,      (unsigned char)22, 
        (unsigned char)22,      (unsigned char)22,      (unsigned char)23,      (unsigned char)23, 
        (unsigned char)23,      (unsigned char)23,      (unsigned char)24,      (unsigned char)24, 
        (unsigned char)24,      (unsigned char)24,      (unsigned char)24,      (unsigned char)24, 
        (unsigned char)24,      (unsigned char)25,      (unsigned char)25,      (unsigned char)25, 
        (unsigned char)25,      (unsigned char)25,      (unsigned char)25,      (unsigned char)25, 
        (unsigned char)26,      (unsigned char)26,      (unsigned char)26,      (unsigned char)26, 
        (unsigned char)26,      (unsigned char)26,      (unsigned char)26,      (unsigned char)26, 
        (unsigned char)27,      (unsigned char)27,      (unsigned char)27,      (unsigned char)27, 
        (unsigned char)27,      (unsigned char)27,      (unsigned char)27,      (unsigned char)27, 
        (unsigned char)28,      (unsigned char)28,      (unsigned char)28,      (unsigned char)28, 
        (unsigned char)28,      (unsigned char)28,      (unsigned char)28,      (unsigned char)29, 
        (unsigned char)29,      (unsigned char)29,      (unsigned char)29,      (unsigned char)29, 
        (unsigned char)29,      (unsigned char)29,      (unsigned char)29,      (unsigned char)29, 
        (unsigned char)29,      (unsigned char)30,      (unsigned char)30,      (unsigned char)30, 
        (unsigned char)30,      (unsigned char)30,      (unsigned char)30,      (unsigned char)30, 
        (unsigned char)31,      (unsigned char)31,      (unsigned char)31,      (unsigned char)31, 
        (unsigned char)31};
#line 339 "src/global.h"
unsigned char *newrefframe[3]  ;
#line 339 "src/global.h"
unsigned char *oldrefframe[3]  ;
#line 339 "src/global.h"
unsigned char *auxframe[3]  ;
#line 341 "src/global.h"
unsigned char *neworgframe[3]  ;
#line 341 "src/global.h"
unsigned char *oldorgframe[3]  ;
#line 341 "src/global.h"
unsigned char *auxorgframe[3]  ;
#line 343 "src/global.h"
unsigned char *predframe[3]  ;
#line 345 "src/global.h"
short (*blocks)[64]  ;
#line 347 "src/global.h"
unsigned char intra_q[64]  ;
#line 347 "src/global.h"
unsigned char inter_q[64]  ;
#line 348 "src/global.h"
unsigned char chrom_intra_q[64]  ;
#line 348 "src/global.h"
unsigned char chrom_inter_q[64]  ;
#line 350 "src/global.h"
int dc_dct_pred[3]  ;
#line 352 "src/global.h"
int pt_dc_dct_pred[2][3]  ;
#line 355 "src/global.h"
struct mbinfo *mbinfo  ;
#line 357 "src/global.h"
struct motion_data *motion_data  ;
#line 359 "src/global.h"
unsigned char *clp  ;
#line 362 "src/global.h"
char id_string[256]  ;
#line 362 "src/global.h"
char tplorg[256]  ;
#line 362 "src/global.h"
char tplref[256]  ;
#line 363 "src/global.h"
char iqname[256]  ;
#line 363 "src/global.h"
char niqname[256]  ;
#line 364 "src/global.h"
char statname[256]  ;
#line 365 "src/global.h"
char errortext[256]  ;
#line 367 "src/global.h"
FILE *outfile  ;
#line 367 "src/global.h"
FILE *statfile  ;
#line 368 "src/global.h"
int inputtype  ;
#line 370 "src/global.h"
int quiet  ;
#line 374 "src/global.h"
int N  ;
#line 375 "src/global.h"
int M  ;
#line 376 "src/global.h"
int P  ;
#line 377 "src/global.h"
int nframes  ;
#line 378 "src/global.h"
int frame0  ;
#line 378 "src/global.h"
int tc0  ;
#line 379 "src/global.h"
int mpeg1  ;
#line 380 "src/global.h"
int fieldpic  ;
#line 384 "src/global.h"
int horizontal_size  ;
#line 384 "src/global.h"
int vertical_size  ;
#line 385 "src/global.h"
int width  ;
#line 385 "src/global.h"
int height  ;
#line 386 "src/global.h"
int chrom_width  ;
#line 386 "src/global.h"
int chrom_height  ;
#line 386 "src/global.h"
int block_count  ;
#line 387 "src/global.h"
int mb_width  ;
#line 387 "src/global.h"
int mb_height  ;
#line 388 "src/global.h"
int width2  ;
#line 388 "src/global.h"
int height2  ;
#line 388 "src/global.h"
int mb_height2  ;
#line 388 "src/global.h"
int chrom_width2  ;
#line 389 "src/global.h"
int aspectratio  ;
#line 390 "src/global.h"
int frame_rate_code  ;
#line 391 "src/global.h"
double frame_rate  ;
#line 392 "src/global.h"
double bit_rate  ;
#line 393 "src/global.h"
int vbv_buffer_size  ;
#line 394 "src/global.h"
int constrparms  ;
#line 395 "src/global.h"
int load_iquant  ;
#line 395 "src/global.h"
int load_niquant  ;
#line 396 "src/global.h"
int load_ciquant  ;
#line 396 "src/global.h"
int load_cniquant  ;
#line 401 "src/global.h"
int profile  ;
#line 401 "src/global.h"
int level  ;
#line 402 "src/global.h"
int prog_seq  ;
#line 403 "src/global.h"
int chroma_format  ;
#line 404 "src/global.h"
int low_delay  ;
#line 409 "src/global.h"
int video_format  ;
#line 410 "src/global.h"
int color_primaries  ;
#line 411 "src/global.h"
int transfer_characteristics  ;
#line 412 "src/global.h"
int matrix_coefficients  ;
#line 413 "src/global.h"
int display_horizontal_size  ;
#line 413 "src/global.h"
int display_vertical_size  ;
#line 418 "src/global.h"
int temp_ref  ;
#line 419 "src/global.h"
int pict_type  ;
#line 420 "src/global.h"
int vbv_delay  ;
#line 425 "src/global.h"
int forw_hor_f_code  ;
#line 425 "src/global.h"
int forw_vert_f_code  ;
#line 426 "src/global.h"
int back_hor_f_code  ;
#line 426 "src/global.h"
int back_vert_f_code  ;
#line 427 "src/global.h"
int dc_prec  ;
#line 428 "src/global.h"
int pict_struct  ;
#line 429 "src/global.h"
int topfirst  ;
#line 431 "src/global.h"
int frame_pred_dct_tab[3]  ;
#line 431 "src/global.h"
int frame_pred_dct  ;
#line 432 "src/global.h"
int conceal_tab[3]  ;
#line 433 "src/global.h"
int qscale_tab[3]  ;
#line 433 "src/global.h"
int q_scale_type  ;
#line 434 "src/global.h"
int intravlc_tab[3]  ;
#line 434 "src/global.h"
int intravlc  ;
#line 435 "src/global.h"
int altscan_tab[3]  ;
#line 435 "src/global.h"
int altscan  ;
#line 436 "src/global.h"
int repeatfirst  ;
#line 437 "src/global.h"
int prog_frame  ;
#line 439 "src/global.h"
int QUANT_THRESHOLD  ;
#line 449 "src/global.h"
short c[8][8]  ;
#line 450 "src/global.h"
short ic[8][8]  ;
#line 89 "src/mpeg2enc.c"
static void init(void) ;
#line 90
static void readparmfile(char *fname ) ;
#line 91
static void readquantmat(void) ;
#line 94 "src/mpeg2enc.c"
int main(int argc , char **argv ) 
{ 


  {
#line 100
  quiet = 1;
#line 108
  if (argc != 3) {
#line 110
    printf((char const   * __restrict  )"\n%s, %s\n", version, author);
#line 111
    printf((char const   * __restrict  )"Usage: mpeg2encode in.par out.m2v\n");
#line 112
    exit(0);
  }
#line 116
  readparmfile(*(argv + 1));
#line 119
  readquantmat();
#line 122
  outfile = fopen((char const   * __restrict  )*(argv + 2), (char const   * __restrict  )"wb");
#line 122
  if (! outfile) {
#line 124
    sprintf((char * __restrict  )(errortext), (char const   * __restrict  )"Couldn\'t create output file %s",
            *(argv + 2));
#line 125
    error(errortext);
  }
#line 128
  init();
#line 129
  if (mpeg1) {
#line 129
    QUANT_THRESHOLD = 255;
  } else {
#line 129
    QUANT_THRESHOLD = 2047;
  }
#line 131
  putseq();
#line 133
  fclose(outfile);
#line 134
  fclose(statfile);
#line 136
  return (0);
}
}
#line 142 "src/mpeg2enc.c"
static int block_count_tab[3]  = {      6,      8,      12};
#line 139 "src/mpeg2enc.c"
static void init(void) 
{ 
  int i ;
  int size ;
  void *tmp ;
  int tmp___0 ;
  unsigned char *tmp___1 ;
  void *tmp___2 ;
  unsigned char *tmp___3 ;
  void *tmp___4 ;
  unsigned char *tmp___5 ;
  void *tmp___6 ;
  unsigned char *tmp___7 ;
  void *tmp___8 ;
  unsigned char *tmp___9 ;
  void *tmp___10 ;
  unsigned char *tmp___11 ;
  void *tmp___12 ;
  unsigned char *tmp___13 ;
  void *tmp___14 ;
  void *tmp___15 ;
  void *tmp___16 ;

  {
#line 144
  initbits();
#line 145
  init_fdct();
#line 146
  init_idct();
#line 149
  mb_width = (horizontal_size + 15) / 16;
#line 150
  if (prog_seq) {
#line 150
    mb_height = (vertical_size + 15) / 16;
  } else {
#line 150
    mb_height = 2 * ((vertical_size + 31) / 32);
  }
#line 151
  if (fieldpic) {
#line 151
    mb_height2 = mb_height >> 1;
  } else {
#line 151
    mb_height2 = mb_height;
  }
#line 152
  width = 16 * mb_width;
#line 153
  height = 16 * mb_height;
#line 155
  if (chroma_format == 3) {
#line 155
    chrom_width = width;
  } else {
#line 155
    chrom_width = width >> 1;
  }
#line 156
  if (chroma_format != 1) {
#line 156
    chrom_height = height;
  } else {
#line 156
    chrom_height = height >> 1;
  }
#line 158
  if (fieldpic) {
#line 158
    height2 = height >> 1;
  } else {
#line 158
    height2 = height;
  }
#line 159
  if (fieldpic) {
#line 159
    width2 = width << 1;
  } else {
#line 159
    width2 = width;
  }
#line 160
  if (fieldpic) {
#line 160
    chrom_width2 = chrom_width << 1;
  } else {
#line 160
    chrom_width2 = chrom_width;
  }
#line 162
  block_count = block_count_tab[chroma_format - 1];
#line 165
  tmp = malloc((size_t )1024);
#line 165
  clp = (unsigned char *)tmp;
#line 165
  if (! clp) {
#line 166
    error((char *)"malloc failed\n");
  }
#line 167
  clp += 384;
#line 168
  i = -384;
#line 168
  while (i < 640) {
#line 169
    if (i < 0) {
#line 169
      *(clp + i) = (unsigned char)0;
    } else {
#line 169
      if (i > 255) {
#line 169
        tmp___0 = 255;
      } else {
#line 169
        tmp___0 = i;
      }
#line 169
      *(clp + i) = (unsigned char )tmp___0;
    }
#line 168
    i ++;
  }
#line 171
  i = 0;
#line 171
  while (i < 3) {
#line 173
    if (i == 0) {
#line 173
      size = width * height;
    } else {
#line 173
      size = chrom_width * chrom_height;
    }
#line 175
    tmp___2 = malloc((size_t )size);
#line 175
    tmp___1 = (unsigned char *)tmp___2;
#line 175
    newrefframe[i] = tmp___1;
#line 175
    if (! tmp___1) {
#line 176
      error((char *)"malloc failed\n");
    }
#line 177
    tmp___4 = malloc((size_t )size);
#line 177
    tmp___3 = (unsigned char *)tmp___4;
#line 177
    oldrefframe[i] = tmp___3;
#line 177
    if (! tmp___3) {
#line 178
      error((char *)"malloc failed\n");
    }
#line 179
    tmp___6 = malloc((size_t )size);
#line 179
    tmp___5 = (unsigned char *)tmp___6;
#line 179
    auxframe[i] = tmp___5;
#line 179
    if (! tmp___5) {
#line 180
      error((char *)"malloc failed\n");
    }
#line 181
    tmp___8 = malloc((size_t )size);
#line 181
    tmp___7 = (unsigned char *)tmp___8;
#line 181
    neworgframe[i] = tmp___7;
#line 181
    if (! tmp___7) {
#line 182
      error((char *)"malloc failed\n");
    }
#line 183
    tmp___10 = malloc((size_t )size);
#line 183
    tmp___9 = (unsigned char *)tmp___10;
#line 183
    oldorgframe[i] = tmp___9;
#line 183
    if (! tmp___9) {
#line 184
      error((char *)"malloc failed\n");
    }
#line 185
    tmp___12 = malloc((size_t )size);
#line 185
    tmp___11 = (unsigned char *)tmp___12;
#line 185
    auxorgframe[i] = tmp___11;
#line 185
    if (! tmp___11) {
#line 186
      error((char *)"malloc failed\n");
    }
#line 187
    tmp___14 = malloc((size_t )size);
#line 187
    tmp___13 = (unsigned char *)tmp___14;
#line 187
    predframe[i] = tmp___13;
#line 187
    if (! tmp___13) {
#line 188
      error((char *)"malloc failed\n");
    }
#line 171
    i ++;
  }
#line 191
  tmp___15 = malloc((unsigned long )(mb_width * mb_height2) * sizeof(struct mbinfo ));
#line 191
  mbinfo = (struct mbinfo *)tmp___15;
#line 193
  if (! mbinfo) {
#line 194
    error((char *)"malloc failed\n");
  }
#line 197
  tmp___16 = malloc((unsigned long )((mb_width * mb_height2) * block_count) * sizeof(short [64]));
#line 197
  blocks = (short (*)[64])tmp___16;
#line 204
  if (! blocks) {
#line 205
    error((char *)"malloc failed\n");
  }
#line 207
  if ((int )statname[0] == 45) {
#line 208
    statfile = stdout;
  } else {
#line 209
    statfile = fopen((char const   * __restrict  )(statname), (char const   * __restrict  )"w");
#line 209
    if (! statfile) {
#line 211
      sprintf((char * __restrict  )(errortext), (char const   * __restrict  )"Couldn\'t create statistics output file %s",
              statname);
#line 212
      error(errortext);
    }
  }
#line 214
  return;
}
}
#line 216 "src/mpeg2enc.c"
void error(char *text ) 
{ 


  {
#line 219
  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )text);
#line 220
  fputc('\n', stderr);
#line 221
  exit(1);
}
}
#line 231 "src/mpeg2enc.c"
static double ratetab[8]  = 
#line 231
  {      24000.0 / 1001.0,      24.0,      25.0,      30000.0 / 1001.0, 
        30.0,      50.0,      60000.0 / 1001.0,      60.0};
#line 233
int r ;
#line 233
int Xi ;
#line 233
int Xb ;
#line 233
int Xp ;
#line 233
int d0i ;
#line 233
int d0p ;
#line 233
int d0b ;
#line 234
double avg_act ;
#line 224 "src/mpeg2enc.c"
static void readparmfile(char *fname ) 
{ 
  int i ;
  int h ;
  int m ;
  int s ;
  int f ;
  FILE *fd ;
  char line[256] ;
  void *tmp ;

  {
#line 236
  fd = fopen((char const   * __restrict  )fname, (char const   * __restrict  )"r");
#line 236
  if (! fd) {
#line 238
    sprintf((char * __restrict  )(errortext), (char const   * __restrict  )"Couldn\'t open parameter file %s",
            fname);
#line 239
    error(errortext);
  }
#line 242
  fgets((char * __restrict  )(id_string), 254, (FILE * __restrict  )fd);
#line 243
  fgets((char * __restrict  )(line), 254, (FILE * __restrict  )fd);
#line 243
  sscanf((char const   * __restrict  )(line), (char const   * __restrict  )"%s", tplorg);
#line 244
  fgets((char * __restrict  )(line), 254, (FILE * __restrict  )fd);
#line 244
  sscanf((char const   * __restrict  )(line), (char const   * __restrict  )"%s", tplref);
#line 245
  fgets((char * __restrict  )(line), 254, (FILE * __restrict  )fd);
#line 245
  sscanf((char const   * __restrict  )(line), (char const   * __restrict  )"%s", iqname);
#line 246
  fgets((char * __restrict  )(line), 254, (FILE * __restrict  )fd);
#line 246
  sscanf((char const   * __restrict  )(line), (char const   * __restrict  )"%s", niqname);
#line 247
  fgets((char * __restrict  )(line), 254, (FILE * __restrict  )fd);
#line 247
  sscanf((char const   * __restrict  )(line), (char const   * __restrict  )"%s", statname);
#line 248
  fgets((char * __restrict  )(line), 254, (FILE * __restrict  )fd);
#line 248
  sscanf((char const   * __restrict  )(line), (char const   * __restrict  )"%d", & inputtype);
#line 249
  fgets((char * __restrict  )(line), 254, (FILE * __restrict  )fd);
#line 249
  sscanf((char const   * __restrict  )(line), (char const   * __restrict  )"%d", & nframes);
#line 250
  fgets((char * __restrict  )(line), 254, (FILE * __restrict  )fd);
#line 250
  sscanf((char const   * __restrict  )(line), (char const   * __restrict  )"%d", & frame0);
#line 251
  fgets((char * __restrict  )(line), 254, (FILE * __restrict  )fd);
#line 251
  sscanf((char const   * __restrict  )(line), (char const   * __restrict  )"%d:%d:%d:%d",
         & h, & m, & s, & f);
#line 252
  fgets((char * __restrict  )(line), 254, (FILE * __restrict  )fd);
#line 252
  sscanf((char const   * __restrict  )(line), (char const   * __restrict  )"%d", & N);
#line 253
  fgets((char * __restrict  )(line), 254, (FILE * __restrict  )fd);
#line 253
  sscanf((char const   * __restrict  )(line), (char const   * __restrict  )"%d", & M);
#line 254
  fgets((char * __restrict  )(line), 254, (FILE * __restrict  )fd);
#line 254
  sscanf((char const   * __restrict  )(line), (char const   * __restrict  )"%d", & mpeg1);
#line 255
  fgets((char * __restrict  )(line), 254, (FILE * __restrict  )fd);
#line 255
  sscanf((char const   * __restrict  )(line), (char const   * __restrict  )"%d", & fieldpic);
#line 256
  fgets((char * __restrict  )(line), 254, (FILE * __restrict  )fd);
#line 256
  sscanf((char const   * __restrict  )(line), (char const   * __restrict  )"%d", & horizontal_size);
#line 257
  fgets((char * __restrict  )(line), 254, (FILE * __restrict  )fd);
#line 257
  sscanf((char const   * __restrict  )(line), (char const   * __restrict  )"%d", & vertical_size);
#line 258
  fgets((char * __restrict  )(line), 254, (FILE * __restrict  )fd);
#line 258
  sscanf((char const   * __restrict  )(line), (char const   * __restrict  )"%d", & aspectratio);
#line 259
  fgets((char * __restrict  )(line), 254, (FILE * __restrict  )fd);
#line 259
  sscanf((char const   * __restrict  )(line), (char const   * __restrict  )"%d", & frame_rate_code);
#line 260
  fgets((char * __restrict  )(line), 254, (FILE * __restrict  )fd);
#line 260
  sscanf((char const   * __restrict  )(line), (char const   * __restrict  )"%lf",
         & bit_rate);
#line 261
  fgets((char * __restrict  )(line), 254, (FILE * __restrict  )fd);
#line 261
  sscanf((char const   * __restrict  )(line), (char const   * __restrict  )"%d", & vbv_buffer_size);
#line 262
  fgets((char * __restrict  )(line), 254, (FILE * __restrict  )fd);
#line 262
  sscanf((char const   * __restrict  )(line), (char const   * __restrict  )"%d", & low_delay);
#line 263
  fgets((char * __restrict  )(line), 254, (FILE * __restrict  )fd);
#line 263
  sscanf((char const   * __restrict  )(line), (char const   * __restrict  )"%d", & constrparms);
#line 264
  fgets((char * __restrict  )(line), 254, (FILE * __restrict  )fd);
#line 264
  sscanf((char const   * __restrict  )(line), (char const   * __restrict  )"%d", & profile);
#line 265
  fgets((char * __restrict  )(line), 254, (FILE * __restrict  )fd);
#line 265
  sscanf((char const   * __restrict  )(line), (char const   * __restrict  )"%d", & level);
#line 266
  fgets((char * __restrict  )(line), 254, (FILE * __restrict  )fd);
#line 266
  sscanf((char const   * __restrict  )(line), (char const   * __restrict  )"%d", & prog_seq);
#line 267
  fgets((char * __restrict  )(line), 254, (FILE * __restrict  )fd);
#line 267
  sscanf((char const   * __restrict  )(line), (char const   * __restrict  )"%d", & chroma_format);
#line 268
  fgets((char * __restrict  )(line), 254, (FILE * __restrict  )fd);
#line 268
  sscanf((char const   * __restrict  )(line), (char const   * __restrict  )"%d", & video_format);
#line 269
  fgets((char * __restrict  )(line), 254, (FILE * __restrict  )fd);
#line 269
  sscanf((char const   * __restrict  )(line), (char const   * __restrict  )"%d", & color_primaries);
#line 270
  fgets((char * __restrict  )(line), 254, (FILE * __restrict  )fd);
#line 270
  sscanf((char const   * __restrict  )(line), (char const   * __restrict  )"%d", & transfer_characteristics);
#line 271
  fgets((char * __restrict  )(line), 254, (FILE * __restrict  )fd);
#line 271
  sscanf((char const   * __restrict  )(line), (char const   * __restrict  )"%d", & matrix_coefficients);
#line 272
  fgets((char * __restrict  )(line), 254, (FILE * __restrict  )fd);
#line 272
  sscanf((char const   * __restrict  )(line), (char const   * __restrict  )"%d", & display_horizontal_size);
#line 273
  fgets((char * __restrict  )(line), 254, (FILE * __restrict  )fd);
#line 273
  sscanf((char const   * __restrict  )(line), (char const   * __restrict  )"%d", & display_vertical_size);
#line 274
  fgets((char * __restrict  )(line), 254, (FILE * __restrict  )fd);
#line 274
  sscanf((char const   * __restrict  )(line), (char const   * __restrict  )"%d", & dc_prec);
#line 275
  fgets((char * __restrict  )(line), 254, (FILE * __restrict  )fd);
#line 275
  sscanf((char const   * __restrict  )(line), (char const   * __restrict  )"%d", & topfirst);
#line 276
  fgets((char * __restrict  )(line), 254, (FILE * __restrict  )fd);
#line 276
  sscanf((char const   * __restrict  )(line), (char const   * __restrict  )"%d %d %d",
         frame_pred_dct_tab, frame_pred_dct_tab + 1, frame_pred_dct_tab + 2);
#line 279
  fgets((char * __restrict  )(line), 254, (FILE * __restrict  )fd);
#line 279
  sscanf((char const   * __restrict  )(line), (char const   * __restrict  )"%d %d %d",
         conceal_tab, conceal_tab + 1, conceal_tab + 2);
#line 282
  fgets((char * __restrict  )(line), 254, (FILE * __restrict  )fd);
#line 282
  sscanf((char const   * __restrict  )(line), (char const   * __restrict  )"%d %d %d",
         qscale_tab, qscale_tab + 1, qscale_tab + 2);
#line 285
  fgets((char * __restrict  )(line), 254, (FILE * __restrict  )fd);
#line 285
  sscanf((char const   * __restrict  )(line), (char const   * __restrict  )"%d %d %d",
         intravlc_tab, intravlc_tab + 1, intravlc_tab + 2);
#line 287
  fgets((char * __restrict  )(line), 254, (FILE * __restrict  )fd);
#line 287
  sscanf((char const   * __restrict  )(line), (char const   * __restrict  )"%d %d %d",
         altscan_tab, altscan_tab + 1, altscan_tab + 2);
#line 289
  fgets((char * __restrict  )(line), 254, (FILE * __restrict  )fd);
#line 289
  sscanf((char const   * __restrict  )(line), (char const   * __restrict  )"%d", & repeatfirst);
#line 290
  fgets((char * __restrict  )(line), 254, (FILE * __restrict  )fd);
#line 290
  sscanf((char const   * __restrict  )(line), (char const   * __restrict  )"%d", & prog_frame);
#line 292
  fgets((char * __restrict  )(line), 254, (FILE * __restrict  )fd);
#line 292
  sscanf((char const   * __restrict  )(line), (char const   * __restrict  )"%d", & P);
#line 293
  fgets((char * __restrict  )(line), 254, (FILE * __restrict  )fd);
#line 293
  sscanf((char const   * __restrict  )(line), (char const   * __restrict  )"%d", & r);
#line 294
  fgets((char * __restrict  )(line), 254, (FILE * __restrict  )fd);
#line 294
  sscanf((char const   * __restrict  )(line), (char const   * __restrict  )"%lf",
         & avg_act);
#line 295
  fgets((char * __restrict  )(line), 254, (FILE * __restrict  )fd);
#line 295
  sscanf((char const   * __restrict  )(line), (char const   * __restrict  )"%d", & Xi);
#line 296
  fgets((char * __restrict  )(line), 254, (FILE * __restrict  )fd);
#line 296
  sscanf((char const   * __restrict  )(line), (char const   * __restrict  )"%d", & Xp);
#line 297
  fgets((char * __restrict  )(line), 254, (FILE * __restrict  )fd);
#line 297
  sscanf((char const   * __restrict  )(line), (char const   * __restrict  )"%d", & Xb);
#line 298
  fgets((char * __restrict  )(line), 254, (FILE * __restrict  )fd);
#line 298
  sscanf((char const   * __restrict  )(line), (char const   * __restrict  )"%d", & d0i);
#line 299
  fgets((char * __restrict  )(line), 254, (FILE * __restrict  )fd);
#line 299
  sscanf((char const   * __restrict  )(line), (char const   * __restrict  )"%d", & d0p);
#line 300
  fgets((char * __restrict  )(line), 254, (FILE * __restrict  )fd);
#line 300
  sscanf((char const   * __restrict  )(line), (char const   * __restrict  )"%d", & d0b);
#line 302
  if (N < 1) {
#line 303
    error((char *)"N must be positive");
  }
#line 304
  if (M < 1) {
#line 305
    error((char *)"M must be positive");
  }
#line 306
  if (N % M != 0) {
#line 307
    error((char *)"N must be an integer multiple of M");
  }
#line 309
  tmp = malloc((unsigned long )M * sizeof(struct motion_data ));
#line 309
  motion_data = (struct motion_data *)tmp;
#line 310
  if (! motion_data) {
#line 311
    error((char *)"malloc failed\n");
  }
#line 313
  i = 0;
#line 313
  while (i < M) {
#line 315
    fgets((char * __restrict  )(line), 254, (FILE * __restrict  )fd);
#line 316
    sscanf((char const   * __restrict  )(line), (char const   * __restrict  )"%d %d %d %d",
           & (motion_data + i)->forw_hor_f_code, & (motion_data + i)->forw_vert_f_code,
           & (motion_data + i)->sxf, & (motion_data + i)->syf);
#line 320
    if (i != 0) {
#line 322
      fgets((char * __restrict  )(line), 254, (FILE * __restrict  )fd);
#line 323
      sscanf((char const   * __restrict  )(line), (char const   * __restrict  )"%d %d %d %d",
             & (motion_data + i)->back_hor_f_code, & (motion_data + i)->back_vert_f_code,
             & (motion_data + i)->sxb, & (motion_data + i)->syb);
    }
#line 313
    i ++;
  }
#line 329
  fclose(fd);
#line 332
  mpeg1 = ! (! mpeg1);
#line 333
  fieldpic = ! (! fieldpic);
#line 334
  low_delay = ! (! low_delay);
#line 335
  constrparms = ! (! constrparms);
#line 336
  prog_seq = ! (! prog_seq);
#line 337
  topfirst = ! (! topfirst);
#line 339
  i = 0;
#line 339
  while (i < 3) {
#line 341
    frame_pred_dct_tab[i] = ! (! frame_pred_dct_tab[i]);
#line 342
    conceal_tab[i] = ! (! conceal_tab[i]);
#line 343
    qscale_tab[i] = ! (! qscale_tab[i]);
#line 344
    intravlc_tab[i] = ! (! intravlc_tab[i]);
#line 345
    altscan_tab[i] = ! (! altscan_tab[i]);
#line 339
    i ++;
  }
#line 347
  repeatfirst = ! (! repeatfirst);
#line 348
  prog_frame = ! (! prog_frame);
#line 351
  range_checks();
#line 353
  frame_rate = ratetab[frame_rate_code - 1];
#line 356
  tc0 = h;
#line 357
  tc0 = 60 * tc0 + m;
#line 358
  tc0 = 60 * tc0 + s;
#line 359
  tc0 = (int )(frame_rate + 0.5) * tc0 + f;
#line 361
  if (! mpeg1) {
#line 363
    profile_and_level_checks();
  } else {
#line 368
    if (constrparms) {
#line 370
      if (horizontal_size > 768) {
#line 370
        goto _L;
      } else
#line 370
      if (vertical_size > 576) {
#line 370
        goto _L;
      } else
#line 370
      if (((horizontal_size + 15) / 16) * ((vertical_size + 15) / 16) > 396) {
#line 370
        goto _L;
      } else
#line 370
      if ((double )(((horizontal_size + 15) / 16) * ((vertical_size + 15) / 16)) * frame_rate > (double )396 * 25.0) {
#line 370
        goto _L;
      } else
#line 370
      if (frame_rate > 30.0) {
        _L: /* CIL Label */ 
#line 376
        if (! quiet) {
#line 377
          fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Warning: setting constrained_parameters_flag = 0\n");
        }
#line 378
        constrparms = 0;
      }
    }
#line 382
    if (constrparms) {
#line 384
      i = 0;
#line 384
      while (i < M) {
#line 386
        if ((motion_data + i)->forw_hor_f_code > 4) {
#line 388
          if (! quiet) {
#line 389
            fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Warning: setting constrained_parameters_flag = 0\n");
          }
#line 390
          constrparms = 0;
#line 391
          break;
        }
#line 394
        if ((motion_data + i)->forw_vert_f_code > 4) {
#line 396
          if (! quiet) {
#line 397
            fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Warning: setting constrained_parameters_flag = 0\n");
          }
#line 398
          constrparms = 0;
#line 399
          break;
        }
#line 402
        if (i != 0) {
#line 404
          if ((motion_data + i)->back_hor_f_code > 4) {
#line 406
            if (! quiet) {
#line 407
              fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Warning: setting constrained_parameters_flag = 0\n");
            }
#line 408
            constrparms = 0;
#line 409
            break;
          }
#line 412
          if ((motion_data + i)->back_vert_f_code > 4) {
#line 414
            if (! quiet) {
#line 415
              fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Warning: setting constrained_parameters_flag = 0\n");
            }
#line 416
            constrparms = 0;
#line 417
            break;
          }
        }
#line 384
        i ++;
      }
    }
  }
#line 426
  if (mpeg1) {
#line 428
    if (! prog_seq) {
#line 430
      if (! quiet) {
#line 431
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Warning: setting progressive_sequence = 1\n");
      }
#line 432
      prog_seq = 1;
    }
#line 435
    if (chroma_format != 1) {
#line 437
      if (! quiet) {
#line 438
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Warning: setting chroma_format = 1 (4:2:0)\n");
      }
#line 439
      chroma_format = 1;
    }
#line 442
    if (dc_prec != 0) {
#line 444
      if (! quiet) {
#line 445
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Warning: setting intra_dc_precision = 0\n");
      }
#line 446
      dc_prec = 0;
    }
#line 449
    i = 0;
#line 449
    while (i < 3) {
#line 450
      if (qscale_tab[i]) {
#line 452
        if (! quiet) {
#line 453
          fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Warning: setting qscale_tab[%d] = 0\n",
                  i);
        }
#line 454
        qscale_tab[i] = 0;
      }
#line 449
      i ++;
    }
#line 457
    i = 0;
#line 457
    while (i < 3) {
#line 458
      if (intravlc_tab[i]) {
#line 460
        if (! quiet) {
#line 461
          fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Warning: setting intravlc_tab[%d] = 0\n",
                  i);
        }
#line 462
        intravlc_tab[i] = 0;
      }
#line 457
      i ++;
    }
#line 465
    i = 0;
#line 465
    while (i < 3) {
#line 466
      if (altscan_tab[i]) {
#line 468
        if (! quiet) {
#line 469
          fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Warning: setting altscan_tab[%d] = 0\n",
                  i);
        }
#line 470
        altscan_tab[i] = 0;
      }
#line 465
      i ++;
    }
  }
#line 474
  if (! mpeg1) {
#line 474
    if (constrparms) {
#line 476
      if (! quiet) {
#line 477
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Warning: setting constrained_parameters_flag = 0\n");
      }
#line 478
      constrparms = 0;
    }
  }
#line 481
  if (prog_seq) {
#line 481
    if (! prog_frame) {
#line 483
      if (! quiet) {
#line 484
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Warning: setting progressive_frame = 1\n");
      }
#line 485
      prog_frame = 1;
    }
  }
#line 488
  if (prog_frame) {
#line 488
    if (fieldpic) {
#line 490
      if (! quiet) {
#line 491
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Warning: setting field_pictures = 0\n");
      }
#line 492
      fieldpic = 0;
    }
  }
#line 495
  if (! prog_frame) {
#line 495
    if (repeatfirst) {
#line 497
      if (! quiet) {
#line 498
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Warning: setting repeat_first_field = 0\n");
      }
#line 499
      repeatfirst = 0;
    }
  }
#line 502
  if (prog_frame) {
#line 504
    i = 0;
#line 504
    while (i < 3) {
#line 505
      if (! frame_pred_dct_tab[i]) {
#line 507
        if (! quiet) {
#line 508
          fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Warning: setting frame_pred_frame_dct[%d] = 1\n",
                  i);
        }
#line 509
        frame_pred_dct_tab[i] = 1;
      }
#line 504
      i ++;
    }
  }
#line 513
  if (prog_seq) {
#line 513
    if (! repeatfirst) {
#line 513
      if (topfirst) {
#line 515
        if (! quiet) {
#line 516
          fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Warning: setting top_field_first = 0\n");
        }
#line 517
        topfirst = 0;
      }
    }
  }
#line 521
  i = 0;
#line 521
  while (i < M) {
#line 523
    if ((motion_data + i)->sxf > (4 << (motion_data + i)->forw_hor_f_code) - 1) {
#line 525
      if (! quiet) {
#line 526
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Warning: reducing forward horizontal search width to %d\n",
                (4 << (motion_data + i)->forw_hor_f_code) - 1);
      }
#line 529
      (motion_data + i)->sxf = (4 << (motion_data + i)->forw_hor_f_code) - 1;
    }
#line 532
    if ((motion_data + i)->syf > (4 << (motion_data + i)->forw_vert_f_code) - 1) {
#line 534
      if (! quiet) {
#line 535
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Warning: reducing forward vertical search width to %d\n",
                (4 << (motion_data + i)->forw_vert_f_code) - 1);
      }
#line 538
      (motion_data + i)->syf = (4 << (motion_data + i)->forw_vert_f_code) - 1;
    }
#line 541
    if (i != 0) {
#line 543
      if ((motion_data + i)->sxb > (4 << (motion_data + i)->back_hor_f_code) - 1) {
#line 545
        if (! quiet) {
#line 546
          fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Warning: reducing backward horizontal search width to %d\n",
                  (4 << (motion_data + i)->back_hor_f_code) - 1);
        }
#line 549
        (motion_data + i)->sxb = (4 << (motion_data + i)->back_hor_f_code) - 1;
      }
#line 552
      if ((motion_data + i)->syb > (4 << (motion_data + i)->back_vert_f_code) - 1) {
#line 554
        if (! quiet) {
#line 555
          fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Warning: reducing backward vertical search width to %d\n",
                  (4 << (motion_data + i)->back_vert_f_code) - 1);
        }
#line 558
        (motion_data + i)->syb = (4 << (motion_data + i)->back_vert_f_code) - 1;
      }
    }
#line 521
    i ++;
  }
#line 563
  return;
}
}
#line 565 "src/mpeg2enc.c"
static void readquantmat(void) 
{ 
  int i ;
  int v ;
  FILE *fd ;

  {
#line 570
  if ((int )iqname[0] == 45) {
#line 573
    load_iquant = 0;
#line 574
    i = 0;
#line 574
    while (i < 64) {
#line 575
      intra_q[i] = default_intra_quantizer_matrix[i];
#line 574
      i ++;
    }
  } else {
#line 580
    load_iquant = 1;
#line 581
    fd = fopen((char const   * __restrict  )(iqname), (char const   * __restrict  )"r");
#line 581
    if (! fd) {
#line 583
      sprintf((char * __restrict  )(errortext), (char const   * __restrict  )"Couldn\'t open quant matrix file %s",
              iqname);
#line 584
      error(errortext);
    }
#line 587
    i = 0;
#line 587
    while (i < 64) {
#line 589
      fscanf((FILE * __restrict  )fd, (char const   * __restrict  )"%d", & v);
#line 590
      if (v < 1) {
#line 591
        error((char *)"invalid value in quant matrix");
      } else
#line 590
      if (v > 255) {
#line 591
        error((char *)"invalid value in quant matrix");
      }
#line 592
      intra_q[i] = (unsigned char )v;
#line 587
      i ++;
    }
#line 595
    fclose(fd);
  }
#line 598
  if ((int )niqname[0] == 45) {
#line 601
    load_niquant = 0;
#line 602
    i = 0;
#line 602
    while (i < 64) {
#line 603
      inter_q[i] = (unsigned char)16;
#line 602
      i ++;
    }
  } else {
#line 608
    load_niquant = 1;
#line 609
    fd = fopen((char const   * __restrict  )(niqname), (char const   * __restrict  )"r");
#line 609
    if (! fd) {
#line 611
      sprintf((char * __restrict  )(errortext), (char const   * __restrict  )"Couldn\'t open quant matrix file %s",
              niqname);
#line 612
      error(errortext);
    }
#line 615
    i = 0;
#line 615
    while (i < 64) {
#line 617
      fscanf((FILE * __restrict  )fd, (char const   * __restrict  )"%d", & v);
#line 618
      if (v < 1) {
#line 619
        error((char *)"invalid value in quant matrix");
      } else
#line 618
      if (v > 255) {
#line 619
        error((char *)"invalid value in quant matrix");
      }
#line 620
      inter_q[i] = (unsigned char )v;
#line 615
      i ++;
    }
#line 623
    fclose(fd);
  }
#line 625
  return;
}
}
#line 1 "putvlc.o"
#pragma merger("0","/tmp/cil-fwZv6Ifp.i","-O4")
#line 105 "src/vlc.h"
static VLCtable addrinctab[33]  = 
#line 105 "src/vlc.h"
  {      {(unsigned char)1, (char)1}, 
        {(unsigned char)3, (char)3}, 
        {(unsigned char)2, (char)3}, 
        {(unsigned char)3, (char)4}, 
        {(unsigned char)2, (char)4}, 
        {(unsigned char)3, (char)5}, 
        {(unsigned char)2, (char)5}, 
        {(unsigned char)7, (char)7}, 
        {(unsigned char)6, (char)7}, 
        {(unsigned char)11, (char)8}, 
        {(unsigned char)10, (char)8}, 
        {(unsigned char)9, (char)8}, 
        {(unsigned char)8, (char)8}, 
        {(unsigned char)7, (char)8}, 
        {(unsigned char)6, (char)8}, 
        {(unsigned char)23, (char)10}, 
        {(unsigned char)22, (char)10}, 
        {(unsigned char)21, (char)10}, 
        {(unsigned char)20, (char)10}, 
        {(unsigned char)19, (char)10}, 
        {(unsigned char)18, (char)10}, 
        {(unsigned char)35, (char)11}, 
        {(unsigned char)34, (char)11}, 
        {(unsigned char)33, (char)11}, 
        {(unsigned char)32, (char)11}, 
        {(unsigned char)31, (char)11}, 
        {(unsigned char)30, (char)11}, 
        {(unsigned char)29, (char)11}, 
        {(unsigned char)28, (char)11}, 
        {(unsigned char)27, (char)11}, 
        {(unsigned char)26, (char)11}, 
        {(unsigned char)25, (char)11}, 
        {(unsigned char)24, (char)11}};
#line 124 "src/vlc.h"
static VLCtable mbtypetab[3][32]  = { {        {(unsigned char)0, (char)0}, 
            {(unsigned char)1, (char)1}, 
            {(unsigned char)0, (char)0}, 
            {(unsigned char)0, (char)0}, 
            {(unsigned char)0, (char)0}, 
            {(unsigned char)0, (char)0}, 
            {(unsigned char)0, (char)0}, 
            {(unsigned char)0, (char)0}, 
            {(unsigned char)0, (char)0}, 
            {(unsigned char)0, (char)0}, 
            {(unsigned char)0, (char)0}, 
            {(unsigned char)0, (char)0}, 
            {(unsigned char)0, (char)0}, 
            {(unsigned char)0, (char)0}, 
            {(unsigned char)0, (char)0}, 
            {(unsigned char)0, (char)0}, 
            {(unsigned char)0, (char)0}, 
            {(unsigned char)1, (char)2}, 
            {(unsigned char)0, (char)0}, 
            {(unsigned char)0, (char)0}, 
            {(unsigned char)0, (char)0}, 
            {(unsigned char)0, (char)0}, 
            {(unsigned char)0, (char)0}, 
            {(unsigned char)0, (char)0}, 
            {(unsigned char)0, (char)0}, 
            {(unsigned char)0, (char)0}, 
            {(unsigned char)0, (char)0}, 
            {(unsigned char)0, (char)0}, 
            {(unsigned char)0, (char)0}, 
            {(unsigned char)0, (char)0}, 
            {(unsigned char)0, (char)0}, 
            {(unsigned char)0, (char)0}}, 
   {        {(unsigned char)0, (char)0}, 
            {(unsigned char)3, (char)5}, 
            {(unsigned char)1, (char)2}, 
            {(unsigned char)0, (char)0}, 
            {(unsigned char)0, (char)0}, 
            {(unsigned char)0, (char)0}, 
            {(unsigned char)0, (char)0}, 
            {(unsigned char)0, (char)0}, 
            {(unsigned char)1, (char)3}, 
            {(unsigned char)0, (char)0}, 
            {(unsigned char)1, (char)1}, 
            {(unsigned char)0, (char)0}, 
            {(unsigned char)0, (char)0}, 
            {(unsigned char)0, (char)0}, 
            {(unsigned char)0, (char)0}, 
            {(unsigned char)0, (char)0}, 
            {(unsigned char)0, (char)0}, 
            {(unsigned char)1, (char)6}, 
            {(unsigned char)1, (char)5}, 
            {(unsigned char)0, (char)0}, 
            {(unsigned char)0, (char)0}, 
            {(unsigned char)0, (char)0}, 
            {(unsigned char)0, (char)0}, 
            {(unsigned char)0, (char)0}, 
            {(unsigned char)0, (char)0}, 
            {(unsigned char)0, (char)0}, 
            {(unsigned char)2, (char)5}, 
            {(unsigned char)0, (char)0}, 
            {(unsigned char)0, (char)0}, 
            {(unsigned char)0, (char)0}, 
            {(unsigned char)0, (char)0}, 
            {(unsigned char)0, (char)0}}, 
   {        {(unsigned char)0, (char)0}, 
            {(unsigned char)3, (char)5}, 
            {(unsigned char)0, (char)0}, 
            {(unsigned char)0, (char)0}, 
            {(unsigned char)2, (char)3}, 
            {(unsigned char)0, (char)0}, 
            {(unsigned char)3, (char)3}, 
            {(unsigned char)0, (char)0}, 
            {(unsigned char)2, (char)4}, 
            {(unsigned char)0, (char)0}, 
            {(unsigned char)3, (char)4}, 
            {(unsigned char)0, (char)0}, 
            {(unsigned char)2, (char)2}, 
            {(unsigned char)0, (char)0}, 
            {(unsigned char)3, (char)2}, 
            {(unsigned char)0, (char)0}, 
            {(unsigned char)0, (char)0}, 
            {(unsigned char)1, (char)6}, 
            {(unsigned char)0, (char)0}, 
            {(unsigned char)0, (char)0}, 
            {(unsigned char)0, (char)0}, 
            {(unsigned char)0, (char)0}, 
            {(unsigned char)2, (char)6}, 
            {(unsigned char)0, (char)0}, 
            {(unsigned char)0, (char)0}, 
            {(unsigned char)0, (char)0}, 
            {(unsigned char)3, (char)6}, 
            {(unsigned char)0, (char)0}, 
            {(unsigned char)0, (char)0}, 
            {(unsigned char)0, (char)0}, 
            {(unsigned char)2, (char)5}, 
            {(unsigned char)0, (char)0}}};
#line 161 "src/vlc.h"
static VLCtable cbptable[64]  = 
#line 161
  {      {(unsigned char)1, (char)9}, 
        {(unsigned char)11, (char)5}, 
        {(unsigned char)9, (char)5}, 
        {(unsigned char)13, (char)6}, 
        {(unsigned char)13, (char)4}, 
        {(unsigned char)23, (char)7}, 
        {(unsigned char)19, (char)7}, 
        {(unsigned char)31, (char)8}, 
        {(unsigned char)12, (char)4}, 
        {(unsigned char)22, (char)7}, 
        {(unsigned char)18, (char)7}, 
        {(unsigned char)30, (char)8}, 
        {(unsigned char)19, (char)5}, 
        {(unsigned char)27, (char)8}, 
        {(unsigned char)23, (char)8}, 
        {(unsigned char)19, (char)8}, 
        {(unsigned char)11, (char)4}, 
        {(unsigned char)21, (char)7}, 
        {(unsigned char)17, (char)7}, 
        {(unsigned char)29, (char)8}, 
        {(unsigned char)17, (char)5}, 
        {(unsigned char)25, (char)8}, 
        {(unsigned char)21, (char)8}, 
        {(unsigned char)17, (char)8}, 
        {(unsigned char)15, (char)6}, 
        {(unsigned char)15, (char)8}, 
        {(unsigned char)13, (char)8}, 
        {(unsigned char)3, (char)9}, 
        {(unsigned char)15, (char)5}, 
        {(unsigned char)11, (char)8}, 
        {(unsigned char)7, (char)8}, 
        {(unsigned char)7, (char)9}, 
        {(unsigned char)10, (char)4}, 
        {(unsigned char)20, (char)7}, 
        {(unsigned char)16, (char)7}, 
        {(unsigned char)28, (char)8}, 
        {(unsigned char)14, (char)6}, 
        {(unsigned char)14, (char)8}, 
        {(unsigned char)12, (char)8}, 
        {(unsigned char)2, (char)9}, 
        {(unsigned char)16, (char)5}, 
        {(unsigned char)24, (char)8}, 
        {(unsigned char)20, (char)8}, 
        {(unsigned char)16, (char)8}, 
        {(unsigned char)14, (char)5}, 
        {(unsigned char)10, (char)8}, 
        {(unsigned char)6, (char)8}, 
        {(unsigned char)6, (char)9}, 
        {(unsigned char)18, (char)5}, 
        {(unsigned char)26, (char)8}, 
        {(unsigned char)22, (char)8}, 
        {(unsigned char)18, (char)8}, 
        {(unsigned char)13, (char)5}, 
        {(unsigned char)9, (char)8}, 
        {(unsigned char)5, (char)8}, 
        {(unsigned char)5, (char)9}, 
        {(unsigned char)12, (char)5}, 
        {(unsigned char)8, (char)8}, 
        {(unsigned char)4, (char)8}, 
        {(unsigned char)4, (char)9}, 
        {(unsigned char)7, (char)3}, 
        {(unsigned char)10, (char)5}, 
        {(unsigned char)8, (char)5}, 
        {(unsigned char)12, (char)6}};
#line 188 "src/vlc.h"
static VLCtable motionvectab[17]  = 
#line 188
  {      {(unsigned char)1, (char)1}, 
        {(unsigned char)1, (char)2}, 
        {(unsigned char)1, (char)3}, 
        {(unsigned char)1, (char)4}, 
        {(unsigned char)3, (char)6}, 
        {(unsigned char)5, (char)7}, 
        {(unsigned char)4, (char)7}, 
        {(unsigned char)3, (char)7}, 
        {(unsigned char)11, (char)9}, 
        {(unsigned char)10, (char)9}, 
        {(unsigned char)9, (char)9}, 
        {(unsigned char)17, (char)10}, 
        {(unsigned char)16, (char)10}, 
        {(unsigned char)15, (char)10}, 
        {(unsigned char)14, (char)10}, 
        {(unsigned char)13, (char)10}, 
        {(unsigned char)12, (char)10}};
#line 208 "src/vlc.h"
static sVLCtable DClumtab[12]  = 
#line 208
  {      {(unsigned short)4, (char)3}, 
        {(unsigned short)0, (char)2}, 
        {(unsigned short)1, (char)2}, 
        {(unsigned short)5, (char)3}, 
        {(unsigned short)6, (char)3}, 
        {(unsigned short)14, (char)4}, 
        {(unsigned short)30, (char)5}, 
        {(unsigned short)62, (char)6}, 
        {(unsigned short)126, (char)7}, 
        {(unsigned short)254, (char)8}, 
        {(unsigned short)510, (char)9}, 
        {(unsigned short)511, (char)9}};
#line 220 "src/vlc.h"
static sVLCtable DCchromtab[12]  = 
#line 220
  {      {(unsigned short)0, (char)2}, 
        {(unsigned short)1, (char)2}, 
        {(unsigned short)2, (char)2}, 
        {(unsigned short)6, (char)3}, 
        {(unsigned short)14, (char)4}, 
        {(unsigned short)30, (char)5}, 
        {(unsigned short)62, (char)6}, 
        {(unsigned short)126, (char)7}, 
        {(unsigned short)254, (char)8}, 
        {(unsigned short)510, (char)9}, 
        {(unsigned short)1022, (char)10}, 
        {(unsigned short)1023, (char)10}};
#line 235 "src/vlc.h"
static VLCtable dct_code_tab1[2][40]  = { {        {(unsigned char)3, (char)2}, 
            {(unsigned char)4, (char)4}, 
            {(unsigned char)5, (char)5}, 
            {(unsigned char)6, (char)7}, 
            {(unsigned char)38, (char)8}, 
            {(unsigned char)33, (char)8}, 
            {(unsigned char)10, (char)10}, 
            {(unsigned char)29, (char)12}, 
            {(unsigned char)24, (char)12}, 
            {(unsigned char)19, (char)12}, 
            {(unsigned char)16, (char)12}, 
            {(unsigned char)26, (char)13}, 
            {(unsigned char)25, (char)13}, 
            {(unsigned char)24, (char)13}, 
            {(unsigned char)23, (char)13}, 
            {(unsigned char)31, (char)14}, 
            {(unsigned char)30, (char)14}, 
            {(unsigned char)29, (char)14}, 
            {(unsigned char)28, (char)14}, 
            {(unsigned char)27, (char)14}, 
            {(unsigned char)26, (char)14}, 
            {(unsigned char)25, (char)14}, 
            {(unsigned char)24, (char)14}, 
            {(unsigned char)23, (char)14}, 
            {(unsigned char)22, (char)14}, 
            {(unsigned char)21, (char)14}, 
            {(unsigned char)20, (char)14}, 
            {(unsigned char)19, (char)14}, 
            {(unsigned char)18, (char)14}, 
            {(unsigned char)17, (char)14}, 
            {(unsigned char)16, (char)14}, 
            {(unsigned char)24, (char)15}, 
            {(unsigned char)23, (char)15}, 
            {(unsigned char)22, (char)15}, 
            {(unsigned char)21, (char)15}, 
            {(unsigned char)20, (char)15}, 
            {(unsigned char)19, (char)15}, 
            {(unsigned char)18, (char)15}, 
            {(unsigned char)17, (char)15}, 
            {(unsigned char)16, (char)15}}, 
   {        {(unsigned char)3, (char)3}, 
            {(unsigned char)6, (char)6}, 
            {(unsigned char)37, (char)8}, 
            {(unsigned char)12, (char)10}, 
            {(unsigned char)27, (char)12}, 
            {(unsigned char)22, (char)13}, 
            {(unsigned char)21, (char)13}, 
            {(unsigned char)31, (char)15}, 
            {(unsigned char)30, (char)15}, 
            {(unsigned char)29, (char)15}, 
            {(unsigned char)28, (char)15}, 
            {(unsigned char)27, (char)15}, 
            {(unsigned char)26, (char)15}, 
            {(unsigned char)25, (char)15}, 
            {(unsigned char)19, (char)16}, 
            {(unsigned char)18, (char)16}, 
            {(unsigned char)17, (char)16}, 
            {(unsigned char)16, (char)16}, 
            {(unsigned char)0, (char)0}, 
            {(unsigned char)0, (char)0}, 
            {(unsigned char)0, (char)0}, 
            {(unsigned char)0, (char)0}, 
            {(unsigned char)0, (char)0}, 
            {(unsigned char)0, (char)0}, 
            {(unsigned char)0, (char)0}, 
            {(unsigned char)0, (char)0}, 
            {(unsigned char)0, (char)0}, 
            {(unsigned char)0, (char)0}, 
            {(unsigned char)0, (char)0}, 
            {(unsigned char)0, (char)0}, 
            {(unsigned char)0, (char)0}, 
            {(unsigned char)0, (char)0}, 
            {(unsigned char)0, (char)0}, 
            {(unsigned char)0, (char)0}, 
            {(unsigned char)0, (char)0}, 
            {(unsigned char)0, (char)0}, 
            {(unsigned char)0, (char)0}, 
            {(unsigned char)0, (char)0}, 
            {(unsigned char)0, (char)0}, 
            {(unsigned char)0, (char)0}}};
#line 265 "src/vlc.h"
static VLCtable dct_code_tab2[30][5]  = 
#line 265
  { {        {(unsigned char)5, (char)4}, 
            {(unsigned char)4, (char)7}, 
            {(unsigned char)11, (char)10}, 
            {(unsigned char)20, (char)12}, 
            {(unsigned char)20, (char)13}}, 
   {        {(unsigned char)7, (char)5}, 
            {(unsigned char)36, (char)8}, 
            {(unsigned char)28, (char)12}, 
            {(unsigned char)19, (char)13}, 
            {(unsigned char)0, (char)0}}, 
   {        {(unsigned char)6, (char)5}, 
            {(unsigned char)15, (char)10}, 
            {(unsigned char)18, (char)12}, 
            {(unsigned char)0, (char)0}, 
            {(unsigned char)0, (char)0}}, 
   {        {(unsigned char)7, (char)6}, 
            {(unsigned char)9, (char)10}, 
            {(unsigned char)18, (char)13}, 
            {(unsigned char)0, (char)0}, 
            {(unsigned char)0, (char)0}}, 
   {        {(unsigned char)5, (char)6}, 
            {(unsigned char)30, (char)12}, 
            {(unsigned char)20, (char)16}, 
            {(unsigned char)0, (char)0}, 
            {(unsigned char)0, (char)0}}, 
   {        {(unsigned char)4, (char)6}, 
            {(unsigned char)21, (char)12}, 
            {(unsigned char)0, (char)0}, 
            {(unsigned char)0, (char)0}, 
            {(unsigned char)0, (char)0}}, 
   {        {(unsigned char)7, (char)7}, 
            {(unsigned char)17, (char)12}, 
            {(unsigned char)0, (char)0}, 
            {(unsigned char)0, (char)0}, 
            {(unsigned char)0, (char)0}}, 
   {        {(unsigned char)5, (char)7}, 
            {(unsigned char)17, (char)13}, 
            {(unsigned char)0, (char)0}, 
            {(unsigned char)0, (char)0}, 
            {(unsigned char)0, (char)0}}, 
   {        {(unsigned char)39, (char)8}, 
            {(unsigned char)16, (char)13}, 
            {(unsigned char)0, (char)0}, 
            {(unsigned char)0, (char)0}, 
            {(unsigned char)0, (char)0}}, 
   {        {(unsigned char)35, (char)8}, 
            {(unsigned char)26, (char)16}, 
            {(unsigned char)0, (char)0}, 
            {(unsigned char)0, (char)0}, 
            {(unsigned char)0, (char)0}}, 
   {        {(unsigned char)34, (char)8}, 
            {(unsigned char)25, (char)16}, 
            {(unsigned char)0, (char)0}, 
            {(unsigned char)0, (char)0}, 
            {(unsigned char)0, (char)0}}, 
   {        {(unsigned char)32, (char)8}, 
            {(unsigned char)24, (char)16}, 
            {(unsigned char)0, (char)0}, 
            {(unsigned char)0, (char)0}, 
            {(unsigned char)0, (char)0}}, 
   {        {(unsigned char)14, (char)10}, 
            {(unsigned char)23, (char)16}, 
            {(unsigned char)0, (char)0}, 
            {(unsigned char)0, (char)0}, 
            {(unsigned char)0, (char)0}}, 
   {        {(unsigned char)13, (char)10}, 
            {(unsigned char)22, (char)16}, 
            {(unsigned char)0, (char)0}, 
            {(unsigned char)0, (char)0}, 
            {(unsigned char)0, (char)0}}, 
   {        {(unsigned char)8, (char)10}, 
            {(unsigned char)21, (char)16}, 
            {(unsigned char)0, (char)0}, 
            {(unsigned char)0, (char)0}, 
            {(unsigned char)0, (char)0}}, 
   {        {(unsigned char)31, (char)12}, 
            {(unsigned char)0, (char)0}, 
            {(unsigned char)0, (char)0}, 
            {(unsigned char)0, (char)0}, 
            {(unsigned char)0, (char)0}}, 
   {        {(unsigned char)26, (char)12}, 
            {(unsigned char)0, (char)0}, 
            {(unsigned char)0, (char)0}, 
            {(unsigned char)0, (char)0}, 
            {(unsigned char)0, (char)0}}, 
   {        {(unsigned char)25, (char)12}, 
            {(unsigned char)0, (char)0}, 
            {(unsigned char)0, (char)0}, 
            {(unsigned char)0, (char)0}, 
            {(unsigned char)0, (char)0}}, 
   {        {(unsigned char)23, (char)12}, 
            {(unsigned char)0, (char)0}, 
            {(unsigned char)0, (char)0}, 
            {(unsigned char)0, (char)0}, 
            {(unsigned char)0, (char)0}}, 
   {        {(unsigned char)22, (char)12}, 
            {(unsigned char)0, (char)0}, 
            {(unsigned char)0, (char)0}, 
            {(unsigned char)0, (char)0}, 
            {(unsigned char)0, (char)0}}, 
   {        {(unsigned char)31, (char)13}, 
            {(unsigned char)0, (char)0}, 
            {(unsigned char)0, (char)0}, 
            {(unsigned char)0, (char)0}, 
            {(unsigned char)0, (char)0}}, 
   {        {(unsigned char)30, (char)13}, 
            {(unsigned char)0, (char)0}, 
            {(unsigned char)0, (char)0}, 
            {(unsigned char)0, (char)0}, 
            {(unsigned char)0, (char)0}}, 
   {        {(unsigned char)29, (char)13}, 
            {(unsigned char)0, (char)0}, 
            {(unsigned char)0, (char)0}, 
            {(unsigned char)0, (char)0}, 
            {(unsigned char)0, (char)0}}, 
   {        {(unsigned char)28, (char)13}, 
            {(unsigned char)0, (char)0}, 
            {(unsigned char)0, (char)0}, 
            {(unsigned char)0, (char)0}, 
            {(unsigned char)0, (char)0}}, 
   {        {(unsigned char)27, (char)13}, 
            {(unsigned char)0, (char)0}, 
            {(unsigned char)0, (char)0}, 
            {(unsigned char)0, (char)0}, 
            {(unsigned char)0, (char)0}}, 
   {        {(unsigned char)31, (char)16}, 
            {(unsigned char)0, (char)0}, 
            {(unsigned char)0, (char)0}, 
            {(unsigned char)0, (char)0}, 
            {(unsigned char)0, (char)0}}, 
   {        {(unsigned char)30, (char)16}, 
            {(unsigned char)0, (char)0}, 
            {(unsigned char)0, (char)0}, 
            {(unsigned char)0, (char)0}, 
            {(unsigned char)0, (char)0}}, 
   {        {(unsigned char)29, (char)16}, 
            {(unsigned char)0, (char)0}, 
            {(unsigned char)0, (char)0}, 
            {(unsigned char)0, (char)0}, 
            {(unsigned char)0, (char)0}}, 
   {        {(unsigned char)28, (char)16}, 
            {(unsigned char)0, (char)0}, 
            {(unsigned char)0, (char)0}, 
            {(unsigned char)0, (char)0}, 
            {(unsigned char)0, (char)0}}, 
   {        {(unsigned char)27, (char)16}, 
            {(unsigned char)0, (char)0}, 
            {(unsigned char)0, (char)0}, 
            {(unsigned char)0, (char)0}, 
            {(unsigned char)0, (char)0}}};
#line 309 "src/vlc.h"
static VLCtable dct_code_tab1a[2][40]  = { {        {(unsigned char)2, (char)2}, 
            {(unsigned char)6, (char)3}, 
            {(unsigned char)7, (char)4}, 
            {(unsigned char)28, (char)5}, 
            {(unsigned char)29, (char)5}, 
            {(unsigned char)5, (char)6}, 
            {(unsigned char)4, (char)6}, 
            {(unsigned char)123, (char)7}, 
            {(unsigned char)124, (char)7}, 
            {(unsigned char)35, (char)8}, 
            {(unsigned char)34, (char)8}, 
            {(unsigned char)250, (char)8}, 
            {(unsigned char)251, (char)8}, 
            {(unsigned char)254, (char)8}, 
            {(unsigned char)255, (char)8}, 
            {(unsigned char)31, (char)14}, 
            {(unsigned char)30, (char)14}, 
            {(unsigned char)29, (char)14}, 
            {(unsigned char)28, (char)14}, 
            {(unsigned char)27, (char)14}, 
            {(unsigned char)26, (char)14}, 
            {(unsigned char)25, (char)14}, 
            {(unsigned char)24, (char)14}, 
            {(unsigned char)23, (char)14}, 
            {(unsigned char)22, (char)14}, 
            {(unsigned char)21, (char)14}, 
            {(unsigned char)20, (char)14}, 
            {(unsigned char)19, (char)14}, 
            {(unsigned char)18, (char)14}, 
            {(unsigned char)17, (char)14}, 
            {(unsigned char)16, (char)14}, 
            {(unsigned char)24, (char)15}, 
            {(unsigned char)23, (char)15}, 
            {(unsigned char)22, (char)15}, 
            {(unsigned char)21, (char)15}, 
            {(unsigned char)20, (char)15}, 
            {(unsigned char)19, (char)15}, 
            {(unsigned char)18, (char)15}, 
            {(unsigned char)17, (char)15}, 
            {(unsigned char)16, (char)15}}, 
   {        {(unsigned char)2, (char)3}, 
            {(unsigned char)6, (char)5}, 
            {(unsigned char)121, (char)7}, 
            {(unsigned char)39, (char)8}, 
            {(unsigned char)32, (char)8}, 
            {(unsigned char)22, (char)13}, 
            {(unsigned char)21, (char)13}, 
            {(unsigned char)31, (char)15}, 
            {(unsigned char)30, (char)15}, 
            {(unsigned char)29, (char)15}, 
            {(unsigned char)28, (char)15}, 
            {(unsigned char)27, (char)15}, 
            {(unsigned char)26, (char)15}, 
            {(unsigned char)25, (char)15}, 
            {(unsigned char)19, (char)16}, 
            {(unsigned char)18, (char)16}, 
            {(unsigned char)17, (char)16}, 
            {(unsigned char)16, (char)16}, 
            {(unsigned char)0, (char)0}, 
            {(unsigned char)0, (char)0}, 
            {(unsigned char)0, (char)0}, 
            {(unsigned char)0, (char)0}, 
            {(unsigned char)0, (char)0}, 
            {(unsigned char)0, (char)0}, 
            {(unsigned char)0, (char)0}, 
            {(unsigned char)0, (char)0}, 
            {(unsigned char)0, (char)0}, 
            {(unsigned char)0, (char)0}, 
            {(unsigned char)0, (char)0}, 
            {(unsigned char)0, (char)0}, 
            {(unsigned char)0, (char)0}, 
            {(unsigned char)0, (char)0}, 
            {(unsigned char)0, (char)0}, 
            {(unsigned char)0, (char)0}, 
            {(unsigned char)0, (char)0}, 
            {(unsigned char)0, (char)0}, 
            {(unsigned char)0, (char)0}, 
            {(unsigned char)0, (char)0}, 
            {(unsigned char)0, (char)0}, 
            {(unsigned char)0, (char)0}}};
#line 339 "src/vlc.h"
static VLCtable dct_code_tab2a[30][5]  = 
#line 339
  { {        {(unsigned char)5, (char)5}, 
            {(unsigned char)7, (char)7}, 
            {(unsigned char)252, (char)8}, 
            {(unsigned char)12, (char)10}, 
            {(unsigned char)20, (char)13}}, 
   {        {(unsigned char)7, (char)5}, 
            {(unsigned char)38, (char)8}, 
            {(unsigned char)28, (char)12}, 
            {(unsigned char)19, (char)13}, 
            {(unsigned char)0, (char)0}}, 
   {        {(unsigned char)6, (char)6}, 
            {(unsigned char)253, (char)8}, 
            {(unsigned char)18, (char)12}, 
            {(unsigned char)0, (char)0}, 
            {(unsigned char)0, (char)0}}, 
   {        {(unsigned char)7, (char)6}, 
            {(unsigned char)4, (char)9}, 
            {(unsigned char)18, (char)13}, 
            {(unsigned char)0, (char)0}, 
            {(unsigned char)0, (char)0}}, 
   {        {(unsigned char)6, (char)7}, 
            {(unsigned char)30, (char)12}, 
            {(unsigned char)20, (char)16}, 
            {(unsigned char)0, (char)0}, 
            {(unsigned char)0, (char)0}}, 
   {        {(unsigned char)4, (char)7}, 
            {(unsigned char)21, (char)12}, 
            {(unsigned char)0, (char)0}, 
            {(unsigned char)0, (char)0}, 
            {(unsigned char)0, (char)0}}, 
   {        {(unsigned char)5, (char)7}, 
            {(unsigned char)17, (char)12}, 
            {(unsigned char)0, (char)0}, 
            {(unsigned char)0, (char)0}, 
            {(unsigned char)0, (char)0}}, 
   {        {(unsigned char)120, (char)7}, 
            {(unsigned char)17, (char)13}, 
            {(unsigned char)0, (char)0}, 
            {(unsigned char)0, (char)0}, 
            {(unsigned char)0, (char)0}}, 
   {        {(unsigned char)122, (char)7}, 
            {(unsigned char)16, (char)13}, 
            {(unsigned char)0, (char)0}, 
            {(unsigned char)0, (char)0}, 
            {(unsigned char)0, (char)0}}, 
   {        {(unsigned char)33, (char)8}, 
            {(unsigned char)26, (char)16}, 
            {(unsigned char)0, (char)0}, 
            {(unsigned char)0, (char)0}, 
            {(unsigned char)0, (char)0}}, 
   {        {(unsigned char)37, (char)8}, 
            {(unsigned char)25, (char)16}, 
            {(unsigned char)0, (char)0}, 
            {(unsigned char)0, (char)0}, 
            {(unsigned char)0, (char)0}}, 
   {        {(unsigned char)36, (char)8}, 
            {(unsigned char)24, (char)16}, 
            {(unsigned char)0, (char)0}, 
            {(unsigned char)0, (char)0}, 
            {(unsigned char)0, (char)0}}, 
   {        {(unsigned char)5, (char)9}, 
            {(unsigned char)23, (char)16}, 
            {(unsigned char)0, (char)0}, 
            {(unsigned char)0, (char)0}, 
            {(unsigned char)0, (char)0}}, 
   {        {(unsigned char)7, (char)9}, 
            {(unsigned char)22, (char)16}, 
            {(unsigned char)0, (char)0}, 
            {(unsigned char)0, (char)0}, 
            {(unsigned char)0, (char)0}}, 
   {        {(unsigned char)13, (char)10}, 
            {(unsigned char)21, (char)16}, 
            {(unsigned char)0, (char)0}, 
            {(unsigned char)0, (char)0}, 
            {(unsigned char)0, (char)0}}, 
   {        {(unsigned char)31, (char)12}, 
            {(unsigned char)0, (char)0}, 
            {(unsigned char)0, (char)0}, 
            {(unsigned char)0, (char)0}, 
            {(unsigned char)0, (char)0}}, 
   {        {(unsigned char)26, (char)12}, 
            {(unsigned char)0, (char)0}, 
            {(unsigned char)0, (char)0}, 
            {(unsigned char)0, (char)0}, 
            {(unsigned char)0, (char)0}}, 
   {        {(unsigned char)25, (char)12}, 
            {(unsigned char)0, (char)0}, 
            {(unsigned char)0, (char)0}, 
            {(unsigned char)0, (char)0}, 
            {(unsigned char)0, (char)0}}, 
   {        {(unsigned char)23, (char)12}, 
            {(unsigned char)0, (char)0}, 
            {(unsigned char)0, (char)0}, 
            {(unsigned char)0, (char)0}, 
            {(unsigned char)0, (char)0}}, 
   {        {(unsigned char)22, (char)12}, 
            {(unsigned char)0, (char)0}, 
            {(unsigned char)0, (char)0}, 
            {(unsigned char)0, (char)0}, 
            {(unsigned char)0, (char)0}}, 
   {        {(unsigned char)31, (char)13}, 
            {(unsigned char)0, (char)0}, 
            {(unsigned char)0, (char)0}, 
            {(unsigned char)0, (char)0}, 
            {(unsigned char)0, (char)0}}, 
   {        {(unsigned char)30, (char)13}, 
            {(unsigned char)0, (char)0}, 
            {(unsigned char)0, (char)0}, 
            {(unsigned char)0, (char)0}, 
            {(unsigned char)0, (char)0}}, 
   {        {(unsigned char)29, (char)13}, 
            {(unsigned char)0, (char)0}, 
            {(unsigned char)0, (char)0}, 
            {(unsigned char)0, (char)0}, 
            {(unsigned char)0, (char)0}}, 
   {        {(unsigned char)28, (char)13}, 
            {(unsigned char)0, (char)0}, 
            {(unsigned char)0, (char)0}, 
            {(unsigned char)0, (char)0}, 
            {(unsigned char)0, (char)0}}, 
   {        {(unsigned char)27, (char)13}, 
            {(unsigned char)0, (char)0}, 
            {(unsigned char)0, (char)0}, 
            {(unsigned char)0, (char)0}, 
            {(unsigned char)0, (char)0}}, 
   {        {(unsigned char)31, (char)16}, 
            {(unsigned char)0, (char)0}, 
            {(unsigned char)0, (char)0}, 
            {(unsigned char)0, (char)0}, 
            {(unsigned char)0, (char)0}}, 
   {        {(unsigned char)30, (char)16}, 
            {(unsigned char)0, (char)0}, 
            {(unsigned char)0, (char)0}, 
            {(unsigned char)0, (char)0}, 
            {(unsigned char)0, (char)0}}, 
   {        {(unsigned char)29, (char)16}, 
            {(unsigned char)0, (char)0}, 
            {(unsigned char)0, (char)0}, 
            {(unsigned char)0, (char)0}, 
            {(unsigned char)0, (char)0}}, 
   {        {(unsigned char)28, (char)16}, 
            {(unsigned char)0, (char)0}, 
            {(unsigned char)0, (char)0}, 
            {(unsigned char)0, (char)0}, 
            {(unsigned char)0, (char)0}}, 
   {        {(unsigned char)27, (char)16}, 
            {(unsigned char)0, (char)0}, 
            {(unsigned char)0, (char)0}, 
            {(unsigned char)0, (char)0}, 
            {(unsigned char)0, (char)0}}};
#line 88 "src/putvlc.c"
static void putDC(sVLCtable *tab , int val ) ;
#line 91
static void put_DC(sVLCtable *tab , int val , int id ) ;
#line 95 "src/putvlc.c"
void put_DClum(int val , int id ) 
{ 


  {
#line 98
  put_DC(DClumtab, val, id);
#line 99
  return;
}
}
#line 102 "src/putvlc.c"
void put_DCchrom(int val , int id ) 
{ 


  {
#line 105
  put_DC(DCchromtab, val, id);
#line 106
  return;
}
}
#line 109 "src/putvlc.c"
static void put_DC(sVLCtable *tab , int val , int id ) 
{ 
  int absval ;
  int size ;

  {
#line 115
  if (val < 0) {
#line 115
    absval = - val;
  } else {
#line 115
    absval = val;
  }
#line 117
  if (absval > 2047) {
#line 120
    sprintf((char * __restrict  )(errortext), (char const   * __restrict  )"DC value out of range (%d)\n",
            val);
#line 121
    error(errortext);
  } else
#line 117
  if (mpeg1) {
#line 117
    if (absval > 255) {
#line 120
      sprintf((char * __restrict  )(errortext), (char const   * __restrict  )"DC value out of range (%d)\n",
              val);
#line 121
      error(errortext);
    }
  }
#line 125
  size = 0;
#line 127
  while (absval) {
#line 129
    absval >>= 1;
#line 130
    size ++;
  }
#line 134
  put_bits((int )(tab + size)->code, (int )(tab + size)->len, id);
#line 137
  if (size != 0) {
#line 139
    if (val >= 0) {
#line 140
      absval = val;
    } else {
#line 142
      absval = (val + (1 << size)) - 1;
    }
#line 143
    put_bits(absval, size, id);
  }
#line 145
  return;
}
}
#line 149 "src/putvlc.c"
void put_ACfirst(int run , int val , int id ) 
{ 


  {
#line 152
  if (run == 0) {
#line 152
    if (val == 1) {
#line 153
      put_bits(2 | (val < 0), 2, id);
    } else
#line 152
    if (val == -1) {
#line 153
      put_bits(2 | (val < 0), 2, id);
    } else {
#line 155
      put_AC(run, val, 0, id);
    }
  } else {
#line 155
    put_AC(run, val, 0, id);
  }
#line 156
  return;
}
}
#line 159 "src/putvlc.c"
void put_AC(int run , int signed_level , int vlcformat , int id ) 
{ 
  int level___0 ;
  int len ;
  VLCtable *ptab ;

  {
#line 165
  if (signed_level < 0) {
#line 165
    level___0 = - signed_level;
  } else {
#line 165
    level___0 = signed_level;
  }
#line 168
  if (run < 0) {
#line 170
    sprintf((char * __restrict  )(errortext), (char const   * __restrict  )"AC value out of range (run=%d, signed_level=%d)\n",
            run, signed_level);
#line 172
    error(errortext);
  } else
#line 168
  if (run > 63) {
#line 170
    sprintf((char * __restrict  )(errortext), (char const   * __restrict  )"AC value out of range (run=%d, signed_level=%d)\n",
            run, signed_level);
#line 172
    error(errortext);
  } else
#line 168
  if (level___0 == 0) {
#line 170
    sprintf((char * __restrict  )(errortext), (char const   * __restrict  )"AC value out of range (run=%d, signed_level=%d)\n",
            run, signed_level);
#line 172
    error(errortext);
  } else
#line 168
  if (level___0 > 2047) {
#line 170
    sprintf((char * __restrict  )(errortext), (char const   * __restrict  )"AC value out of range (run=%d, signed_level=%d)\n",
            run, signed_level);
#line 172
    error(errortext);
  } else
#line 168
  if (mpeg1) {
#line 168
    if (level___0 > 255) {
#line 170
      sprintf((char * __restrict  )(errortext), (char const   * __restrict  )"AC value out of range (run=%d, signed_level=%d)\n",
              run, signed_level);
#line 172
      error(errortext);
    }
  }
#line 175
  len = 0;
#line 177
  if (run < 2) {
#line 177
    if (level___0 < 41) {
#line 180
      if (vlcformat) {
#line 181
        ptab = & dct_code_tab1a[run][level___0 - 1];
      } else {
#line 183
        ptab = & dct_code_tab1[run][level___0 - 1];
      }
#line 185
      len = (int )ptab->len;
    } else {
#line 177
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 187
  if (run < 32) {
#line 187
    if (level___0 < 6) {
#line 190
      if (vlcformat) {
#line 191
        ptab = & dct_code_tab2a[run - 2][level___0 - 1];
      } else {
#line 193
        ptab = & dct_code_tab2[run - 2][level___0 - 1];
      }
#line 195
      len = (int )ptab->len;
    }
  }
#line 198
  if (len != 0) {
#line 200
    put_bits((int )ptab->code, len, id);
#line 201
    put_bits(signed_level < 0, 1, id);
  } else {
#line 206
    put_bits(1, 6, id);
#line 207
    put_bits(run, 6, id);
#line 208
    if (mpeg1) {
#line 211
      if (signed_level > 127) {
#line 212
        put_bits(0, 8, id);
      }
#line 213
      if (signed_level < -127) {
#line 214
        put_bits(128, 8, id);
      }
#line 215
      put_bits(signed_level, 8, id);
    } else {
#line 220
      put_bits(signed_level, 12, id);
    }
  }
#line 223
  return;
}
}
#line 226 "src/putvlc.c"
void put_addrinc(int addrinc , int id ) 
{ 


  {
#line 229
  while (addrinc > 33) {
#line 231
    put_bits(8, 11, id);
#line 232
    addrinc -= 33;
  }
#line 235
  put_bits((int )addrinctab[addrinc - 1].code, (int )addrinctab[addrinc - 1].len,
           id);
#line 236
  return;
}
}
#line 239 "src/putvlc.c"
void put_mbtype(int pict_type___0 , int mb_type , int id ) 
{ 


  {
#line 242
  put_bits((int )mbtypetab[pict_type___0 - 1][mb_type].code, (int )mbtypetab[pict_type___0 - 1][mb_type].len,
           id);
#line 244
  return;
}
}
#line 247 "src/putvlc.c"
void put_motioncode(int motion_code , int id ) 
{ 
  int abscode ;

  {
#line 252
  if (motion_code >= 0) {
#line 252
    abscode = motion_code;
  } else {
#line 252
    abscode = - motion_code;
  }
#line 254
  put_bits((int )motionvectab[abscode].code, (int )motionvectab[abscode].len, id);
#line 255
  if (motion_code != 0) {
#line 256
    put_bits(motion_code < 0, 1, id);
  }
#line 257
  return;
}
}
#line 260 "src/putvlc.c"
void put_dmv(int dmv , int id ) 
{ 


  {
#line 263
  if (dmv == 0) {
#line 264
    put_bits(0, 1, id);
  } else
#line 265
  if (dmv > 0) {
#line 266
    put_bits(2, 2, id);
  } else {
#line 268
    put_bits(3, 2, id);
  }
#line 269
  return;
}
}
#line 275 "src/putvlc.c"
void put_cbp(int cbp , int id ) 
{ 


  {
#line 278
  put_bits((int )cbptable[cbp].code, (int )cbptable[cbp].len, id);
#line 279
  return;
}
}
#line 284 "src/putvlc.c"
void putDClum(int val ) 
{ 


  {
#line 287
  putDC(DClumtab, val);
#line 288
  return;
}
}
#line 291 "src/putvlc.c"
void putDCchrom(int val ) 
{ 


  {
#line 294
  putDC(DCchromtab, val);
#line 295
  return;
}
}
#line 298 "src/putvlc.c"
static void putDC(sVLCtable *tab , int val ) 
{ 
  int absval ;
  int size ;

  {
#line 304
  if (val < 0) {
#line 304
    absval = - val;
  } else {
#line 304
    absval = val;
  }
#line 306
  if (absval > 2047) {
#line 309
    sprintf((char * __restrict  )(errortext), (char const   * __restrict  )"DC value out of range (%d)\n",
            val);
#line 310
    error(errortext);
  } else
#line 306
  if (mpeg1) {
#line 306
    if (absval > 255) {
#line 309
      sprintf((char * __restrict  )(errortext), (char const   * __restrict  )"DC value out of range (%d)\n",
              val);
#line 310
      error(errortext);
    }
  }
#line 314
  size = 0;
#line 316
  while (absval) {
#line 318
    absval >>= 1;
#line 319
    size ++;
  }
#line 323
  putbits((int )(tab + size)->code, (int )(tab + size)->len);
#line 326
  if (size != 0) {
#line 328
    if (val >= 0) {
#line 329
      absval = val;
    } else {
#line 331
      absval = (val + (1 << size)) - 1;
    }
#line 332
    putbits(absval, size);
  }
#line 334
  return;
}
}
#line 338 "src/putvlc.c"
void putACfirst(int run , int val ) 
{ 


  {
#line 341
  if (run == 0) {
#line 341
    if (val == 1) {
#line 342
      putbits(2 | (val < 0), 2);
    } else
#line 341
    if (val == -1) {
#line 342
      putbits(2 | (val < 0), 2);
    } else {
#line 344
      putAC(run, val, 0);
    }
  } else {
#line 344
    putAC(run, val, 0);
  }
#line 345
  return;
}
}
#line 348 "src/putvlc.c"
void putAC(int run , int signed_level , int vlcformat ) 
{ 
  int level___0 ;
  int len ;
  VLCtable *ptab ;

  {
#line 354
  if (signed_level < 0) {
#line 354
    level___0 = - signed_level;
  } else {
#line 354
    level___0 = signed_level;
  }
#line 357
  if (run < 0) {
#line 359
    sprintf((char * __restrict  )(errortext), (char const   * __restrict  )"AC value out of range (run=%d, signed_level=%d)\n",
            run, signed_level);
#line 361
    error(errortext);
  } else
#line 357
  if (run > 63) {
#line 359
    sprintf((char * __restrict  )(errortext), (char const   * __restrict  )"AC value out of range (run=%d, signed_level=%d)\n",
            run, signed_level);
#line 361
    error(errortext);
  } else
#line 357
  if (level___0 == 0) {
#line 359
    sprintf((char * __restrict  )(errortext), (char const   * __restrict  )"AC value out of range (run=%d, signed_level=%d)\n",
            run, signed_level);
#line 361
    error(errortext);
  } else
#line 357
  if (level___0 > 2047) {
#line 359
    sprintf((char * __restrict  )(errortext), (char const   * __restrict  )"AC value out of range (run=%d, signed_level=%d)\n",
            run, signed_level);
#line 361
    error(errortext);
  } else
#line 357
  if (mpeg1) {
#line 357
    if (level___0 > 255) {
#line 359
      sprintf((char * __restrict  )(errortext), (char const   * __restrict  )"AC value out of range (run=%d, signed_level=%d)\n",
              run, signed_level);
#line 361
      error(errortext);
    }
  }
#line 364
  len = 0;
#line 366
  if (run < 2) {
#line 366
    if (level___0 < 41) {
#line 369
      if (vlcformat) {
#line 370
        ptab = & dct_code_tab1a[run][level___0 - 1];
      } else {
#line 372
        ptab = & dct_code_tab1[run][level___0 - 1];
      }
#line 374
      len = (int )ptab->len;
    } else {
#line 366
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 376
  if (run < 32) {
#line 376
    if (level___0 < 6) {
#line 379
      if (vlcformat) {
#line 380
        ptab = & dct_code_tab2a[run - 2][level___0 - 1];
      } else {
#line 382
        ptab = & dct_code_tab2[run - 2][level___0 - 1];
      }
#line 384
      len = (int )ptab->len;
    }
  }
#line 387
  if (len != 0) {
#line 389
    putbits((int )ptab->code, len);
#line 390
    putbits(signed_level < 0, 1);
  } else {
#line 395
    putbits(1, 6);
#line 396
    putbits(run, 6);
#line 397
    if (mpeg1) {
#line 400
      if (signed_level > 127) {
#line 401
        putbits(0, 8);
      }
#line 402
      if (signed_level < -127) {
#line 403
        putbits(128, 8);
      }
#line 404
      putbits(signed_level, 8);
    } else {
#line 409
      putbits(signed_level, 12);
    }
  }
#line 412
  return;
}
}
#line 415 "src/putvlc.c"
void putaddrinc(int addrinc ) 
{ 


  {
#line 418
  while (addrinc > 33) {
#line 420
    putbits(8, 11);
#line 421
    addrinc -= 33;
  }
#line 424
  putbits((int )addrinctab[addrinc - 1].code, (int )addrinctab[addrinc - 1].len);
#line 425
  return;
}
}
#line 428 "src/putvlc.c"
void putmbtype(int pict_type___0 , int mb_type ) 
{ 


  {
#line 431
  putbits((int )mbtypetab[pict_type___0 - 1][mb_type].code, (int )mbtypetab[pict_type___0 - 1][mb_type].len);
#line 433
  return;
}
}
#line 436 "src/putvlc.c"
void putmotioncode(int motion_code ) 
{ 
  int abscode ;

  {
#line 441
  if (motion_code >= 0) {
#line 441
    abscode = motion_code;
  } else {
#line 441
    abscode = - motion_code;
  }
#line 443
  putbits((int )motionvectab[abscode].code, (int )motionvectab[abscode].len);
#line 444
  if (motion_code != 0) {
#line 445
    putbits(motion_code < 0, 1);
  }
#line 446
  return;
}
}
#line 449 "src/putvlc.c"
void putdmv(int dmv ) 
{ 


  {
#line 452
  if (dmv == 0) {
#line 453
    putbits(0, 1);
  } else
#line 454
  if (dmv > 0) {
#line 455
    putbits(2, 2);
  } else {
#line 457
    putbits(3, 2);
  }
#line 458
  return;
}
}
#line 464 "src/putvlc.c"
void putcbp(int cbp ) 
{ 


  {
#line 467
  putbits((int )cbptable[cbp].code, (int )cbptable[cbp].len);
#line 468
  return;
}
}
#line 1 "writepic.o"
#pragma merger("0","/tmp/cil-PsNCaNFK.i","-O4")
#line 715 "/usr/include/stdio.h"
extern size_t fwrite(void const   * __restrict  __ptr , size_t __size , size_t __n ,
                     FILE * __restrict  __s ) ;
#line 86 "src/writepic.c"
void writeframe(char *fname , unsigned char **frame ) 
{ 
  int chrom_hsize ;
  int chrom_vsize ;
  char name[128] ;
  FILE *fd ;

  {
#line 94
  if (chroma_format == 3) {
#line 94
    chrom_hsize = horizontal_size;
  } else {
#line 94
    chrom_hsize = horizontal_size >> 1;
  }
#line 97
  if (chroma_format != 1) {
#line 97
    chrom_vsize = vertical_size;
  } else {
#line 97
    chrom_vsize = vertical_size >> 1;
  }
#line 100
  if ((int )*(fname + 0) == 45) {
#line 101
    return;
  }
#line 104
  sprintf((char * __restrict  )(name), (char const   * __restrict  )"%s.Y", fname);
#line 106
  fd = fopen((char const   * __restrict  )(name), (char const   * __restrict  )"wb");
#line 106
  if (! fd) {
#line 108
    sprintf((char * __restrict  )(errortext), (char const   * __restrict  )"Couldn\'t create %s\n",
            name);
#line 109
    error(errortext);
  }
#line 111
  fwrite((void const   * __restrict  )*(frame + 0), (size_t )1, (size_t )(horizontal_size * vertical_size),
         (FILE * __restrict  )fd);
#line 112
  fclose(fd);
#line 115
  sprintf((char * __restrict  )(name), (char const   * __restrict  )"%s.U", fname);
#line 116
  fd = fopen((char const   * __restrict  )(name), (char const   * __restrict  )"wb");
#line 116
  if (! fd) {
#line 118
    sprintf((char * __restrict  )(errortext), (char const   * __restrict  )"Couldn\'t create %s\n",
            name);
#line 119
    error(errortext);
  }
#line 121
  fwrite((void const   * __restrict  )*(frame + 1), (size_t )1, (size_t )(chrom_hsize * chrom_vsize),
         (FILE * __restrict  )fd);
#line 122
  fclose(fd);
#line 125
  sprintf((char * __restrict  )(name), (char const   * __restrict  )"%s.V", fname);
#line 126
  fd = fopen((char const   * __restrict  )(name), (char const   * __restrict  )"wb");
#line 126
  if (! fd) {
#line 128
    sprintf((char * __restrict  )(errortext), (char const   * __restrict  )"Couldn\'t create %s\n",
            name);
#line 129
    error(errortext);
  }
#line 131
  fwrite((void const   * __restrict  )*(frame + 2), (size_t )1, (size_t )(chrom_hsize * chrom_vsize),
         (FILE * __restrict  )fd);
#line 132
  fclose(fd);
#line 133
  return;
}
}
#line 1 "predict.o"
#pragma merger("0","/tmp/cil-v6yDPdbK.i","-O4")
#line 86 "src/predict.c"
static void predict_mb(unsigned char **oldref , unsigned char **newref , unsigned char **cur ,
                       int lx , int bx , int by , int pict_type___0 , int pict_struct___0 ,
                       int mb_type , int motion_type , int secondfield , int (*PMV)[2][2] ,
                       int (*mv_field_sel)[2] , int *dmvector ) ;
#line 92
static void pred(unsigned char **src , int sfield , unsigned char **dst , int dfield ,
                 int lx , int w , int h , int x , int y , int dx , int dy , int addflag ) ;
#line 96
static void pred_comp(unsigned char *src , unsigned char *dst , int lx , int w , int h ,
                      int x , int y , int dx , int dy , int addflag ) ;
#line 99
static void calc_DMV(int (*DMV)[2] , int *dmvector , int mvx , int mvy ) ;
#line 102
static void clearblock(unsigned char **cur , int i0 , int j0 ) ;
#line 117 "src/predict.c"
void predict(unsigned char **reff , unsigned char **refb , unsigned char **cur , int secondfield ,
             struct mbinfo *mbi ) 
{ 
  int i ;
  int j ;
  int k ;

  {
#line 124
  k = 0;
#line 127
  j = 0;
#line 127
  while (j < height2) {
#line 128
    i = 0;
#line 128
    while (i < width) {
#line 130
      predict_mb(reff, refb, (unsigned char **)cur, width, i, j, pict_type, pict_struct,
                 (mbi + k)->mb_type, (mbi + k)->motion_type, secondfield, (int (*)[2][2])((mbi + k)->MV),
                 (int (*)[2])((mbi + k)->mv_field_sel), (int *)((mbi + k)->dmvector));
#line 134
      k ++;
#line 128
      i += 16;
    }
#line 127
    j += 16;
  }
#line 136
  return;
}
}
#line 139 "src/predict.c"
void ptpredict(unsigned char **reff , unsigned char **refb , unsigned char **cur ,
               int secondfield , struct mbinfo *mbi , int start_height , int end_height ) 
{ 
  int i ;
  int j ;
  int k ;

  {
#line 147
  k = (start_height >> 4) * (width >> 4);
#line 149
  j = start_height;
#line 149
  while (j < end_height) {
#line 150
    i = 0;
#line 150
    while (i < width) {
#line 152
      predict_mb(reff, refb, (unsigned char **)cur, width, i, j, pict_type, pict_struct,
                 (mbi + k)->mb_type, (mbi + k)->motion_type, secondfield, (int (*)[2][2])((mbi + k)->MV),
                 (int (*)[2])((mbi + k)->mv_field_sel), (int *)((mbi + k)->dmvector));
#line 156
      k ++;
#line 150
      i += 16;
    }
#line 149
    j += 16;
  }
#line 158
  return;
}
}
#line 190 "src/predict.c"
static void predict_mb(unsigned char **oldref , unsigned char **newref , unsigned char **cur ,
                       int lx , int bx , int by , int pict_type___0 , int pict_struct___0 ,
                       int mb_type , int motion_type , int secondfield , int (*PMV)[2][2] ,
                       int (*mv_field_sel)[2] , int *dmvector ) 
{ 
  int addflag ;
  int currentfield ;
  unsigned char **predframe___0 ;
  int DMV[2][2] ;

  {
#line 206
  if (mb_type & 1) {
#line 208
    clearblock(cur, bx, by);
#line 209
    return;
  }
#line 212
  addflag = 0;
#line 214
  if (mb_type & 8) {
#line 214
    goto _L;
  } else
#line 214
  if (pict_type___0 == 2) {
    _L: /* CIL Label */ 
#line 218
    if (pict_struct___0 == 3) {
#line 222
      if (motion_type == 2) {
#line 225
        pred(oldref, 0, cur, 0, lx, 16, 16, bx, by, (*(PMV + 0))[0][0], (*(PMV + 0))[0][1],
             0);
      } else
#line 222
      if (! (mb_type & 8)) {
#line 225
        pred(oldref, 0, cur, 0, lx, 16, 16, bx, by, (*(PMV + 0))[0][0], (*(PMV + 0))[0][1],
             0);
      } else
#line 228
      if (motion_type == 1) {
#line 237
        pred(oldref, (*(mv_field_sel + 0))[0], cur, 0, lx << 1, 16, 8, bx, by >> 1,
             (*(PMV + 0))[0][0], (*(PMV + 0))[0][1] >> 1, 0);
#line 241
        pred(oldref, (*(mv_field_sel + 1))[0], cur, 1, lx << 1, 16, 8, bx, by >> 1,
             (*(PMV + 1))[0][0], (*(PMV + 1))[0][1] >> 1, 0);
      } else
#line 244
      if (motion_type == 3) {
#line 249
        calc_DMV(DMV, (int *)dmvector, (*(PMV + 0))[0][0], (*(PMV + 0))[0][1] >> 1);
#line 252
        pred(oldref, 0, cur, 0, lx << 1, 16, 8, bx, by >> 1, (*(PMV + 0))[0][0], (*(PMV + 0))[0][1] >> 1,
             0);
#line 256
        pred(oldref, 1, cur, 1, lx << 1, 16, 8, bx, by >> 1, (*(PMV + 0))[0][0], (*(PMV + 0))[0][1] >> 1,
             0);
#line 260
        pred(oldref, 1, cur, 0, lx << 1, 16, 8, bx, by >> 1, DMV[0][0], DMV[0][1],
             1);
#line 264
        pred(oldref, 0, cur, 1, lx << 1, 16, 8, bx, by >> 1, DMV[1][0], DMV[1][1],
             1);
      } else
#line 270
      if (! quiet) {
#line 271
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"invalid motion_type\n");
      }
    } else {
#line 278
      currentfield = pict_struct___0 == 2;
#line 281
      if (pict_type___0 == 2) {
#line 281
        if (secondfield) {
#line 281
          if (currentfield != (*(mv_field_sel + 0))[0]) {
#line 283
            predframe___0 = newref;
          } else {
#line 285
            predframe___0 = oldref;
          }
        } else {
#line 285
          predframe___0 = oldref;
        }
      } else {
#line 285
        predframe___0 = oldref;
      }
#line 287
      if (motion_type == 1) {
#line 290
        pred(predframe___0, (*(mv_field_sel + 0))[0], cur, currentfield, lx << 1,
             16, 16, bx, by, (*(PMV + 0))[0][0], (*(PMV + 0))[0][1], 0);
      } else
#line 287
      if (! (mb_type & 8)) {
#line 290
        pred(predframe___0, (*(mv_field_sel + 0))[0], cur, currentfield, lx << 1,
             16, 16, bx, by, (*(PMV + 0))[0][0], (*(PMV + 0))[0][1], 0);
      } else
#line 293
      if (motion_type == 2) {
#line 298
        pred(predframe___0, (*(mv_field_sel + 0))[0], cur, currentfield, lx << 1,
             16, 8, bx, by, (*(PMV + 0))[0][0], (*(PMV + 0))[0][1], 0);
#line 302
        if (pict_type___0 == 2) {
#line 302
          if (secondfield) {
#line 302
            if (currentfield != (*(mv_field_sel + 1))[0]) {
#line 304
              predframe___0 = newref;
            } else {
#line 306
              predframe___0 = oldref;
            }
          } else {
#line 306
            predframe___0 = oldref;
          }
        } else {
#line 306
          predframe___0 = oldref;
        }
#line 309
        pred(predframe___0, (*(mv_field_sel + 1))[0], cur, currentfield, lx << 1,
             16, 8, bx, by + 8, (*(PMV + 1))[0][0], (*(PMV + 1))[0][1], 0);
      } else
#line 312
      if (motion_type == 3) {
#line 317
        if (secondfield) {
#line 318
          predframe___0 = newref;
        } else {
#line 320
          predframe___0 = oldref;
        }
#line 323
        calc_DMV(DMV, (int *)dmvector, (*(PMV + 0))[0][0], (*(PMV + 0))[0][1]);
#line 326
        pred(oldref, currentfield, cur, currentfield, lx << 1, 16, 16, bx, by, (*(PMV + 0))[0][0],
             (*(PMV + 0))[0][1], 0);
#line 330
        pred(predframe___0, ! currentfield, cur, currentfield, lx << 1, 16, 16, bx,
             by, DMV[0][0], DMV[0][1], 1);
      } else
#line 336
      if (! quiet) {
#line 337
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"invalid motion_type\n");
      }
    }
#line 340
    addflag = 1;
  }
#line 343
  if (mb_type & 4) {
#line 347
    if (pict_struct___0 == 3) {
#line 351
      if (motion_type == 2) {
#line 354
        pred(newref, 0, cur, 0, lx, 16, 16, bx, by, (*(PMV + 0))[1][0], (*(PMV + 0))[1][1],
             addflag);
      } else {
#line 366
        pred(newref, (*(mv_field_sel + 0))[1], cur, 0, lx << 1, 16, 8, bx, by >> 1,
             (*(PMV + 0))[1][0], (*(PMV + 0))[1][1] >> 1, addflag);
#line 370
        pred(newref, (*(mv_field_sel + 1))[1], cur, 1, lx << 1, 16, 8, bx, by >> 1,
             (*(PMV + 1))[1][0], (*(PMV + 1))[1][1] >> 1, addflag);
      }
    } else {
#line 378
      currentfield = pict_struct___0 == 2;
#line 380
      if (motion_type == 1) {
#line 383
        pred(newref, (*(mv_field_sel + 0))[1], cur, currentfield, lx << 1, 16, 16,
             bx, by, (*(PMV + 0))[1][0], (*(PMV + 0))[1][1], addflag);
      } else
#line 386
      if (motion_type == 2) {
#line 391
        pred(newref, (*(mv_field_sel + 0))[1], cur, currentfield, lx << 1, 16, 8,
             bx, by, (*(PMV + 0))[1][0], (*(PMV + 0))[1][1], addflag);
#line 395
        pred(newref, (*(mv_field_sel + 1))[1], cur, currentfield, lx << 1, 16, 8,
             bx, by + 8, (*(PMV + 1))[1][0], (*(PMV + 1))[1][1], addflag);
      } else
#line 401
      if (! quiet) {
#line 402
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"invalid motion_type\n");
      }
    }
  }
#line 406
  return;
}
}
#line 422 "src/predict.c"
static void pred(unsigned char **src , int sfield , unsigned char **dst , int dfield ,
                 int lx , int w , int h , int x , int y , int dx , int dy , int addflag ) 
{ 
  int cc ;
  int tmp ;
  int tmp___0 ;

  {
#line 435
  cc = 0;
#line 435
  while (cc < 3) {
#line 437
    if (cc == 1) {
#line 440
      if (chroma_format == 1) {
#line 443
        h >>= 1;
#line 443
        y >>= 1;
#line 443
        dy /= 2;
      }
#line 445
      if (chroma_format != 3) {
#line 448
        w >>= 1;
#line 448
        x >>= 1;
#line 448
        dx /= 2;
#line 449
        lx >>= 1;
      }
    }
#line 453
    if (dfield) {
#line 453
      tmp = lx >> 1;
    } else {
#line 453
      tmp = 0;
    }
#line 453
    if (sfield) {
#line 453
      tmp___0 = lx >> 1;
    } else {
#line 453
      tmp___0 = 0;
    }
#line 453
    pred_comp(*(src + cc) + tmp___0, *(dst + cc) + tmp, lx, w, h, x, y, dx, dy, addflag);
#line 435
    cc ++;
  }
#line 456
  return;
}
}
#line 469 "src/predict.c"
static void pred_comp(unsigned char *src , unsigned char *dst , int lx , int w , int h ,
                      int x , int y , int dx , int dy , int addflag ) 
{ 
  int xint ;
  int xh ;
  int yint ;
  int yh ;
  int i ;
  int j ;
  unsigned char *s ;
  unsigned char *d___0 ;

  {
#line 483
  xint = dx >> 1;
#line 484
  xh = dx & 1;
#line 485
  yint = dy >> 1;
#line 486
  yh = dy & 1;
#line 489
  s = (src + lx * (y + yint)) + (x + xint);
#line 490
  d___0 = (dst + lx * y) + x;
#line 492
  if (! xh) {
#line 492
    if (! yh) {
#line 493
      if (addflag) {
#line 494
        j = 0;
#line 494
        while (j < h) {
#line 496
          i = 0;
#line 496
          while (i < w) {
#line 497
            *(d___0 + i) = (unsigned char )((unsigned int )(((int )*(d___0 + i) + (int )*(s + i)) + 1) >> 1);
#line 496
            i ++;
          }
#line 498
          s += lx;
#line 499
          d___0 += lx;
#line 494
          j ++;
        }
      } else {
#line 502
        j = 0;
#line 502
        while (j < h) {
#line 504
          i = 0;
#line 504
          while (i < w) {
#line 505
            *(d___0 + i) = *(s + i);
#line 504
            i ++;
          }
#line 506
          s += lx;
#line 507
          d___0 += lx;
#line 502
          j ++;
        }
      }
    } else {
#line 492
      goto _L___1;
    }
  } else
  _L___1: /* CIL Label */ 
#line 509
  if (! xh) {
#line 509
    if (yh) {
#line 510
      if (addflag) {
#line 511
        j = 0;
#line 511
        while (j < h) {
#line 513
          i = 0;
#line 513
          while (i < w) {
#line 514
            *(d___0 + i) = (unsigned char )((((unsigned int )*(d___0 + i) + ((unsigned int )(((int )*(s + i) + (int )*(s + (i + lx))) + 1) >> 1)) + 1U) >> 1);
#line 513
            i ++;
          }
#line 515
          s += lx;
#line 516
          d___0 += lx;
#line 511
          j ++;
        }
      } else {
#line 519
        j = 0;
#line 519
        while (j < h) {
#line 521
          i = 0;
#line 521
          while (i < w) {
#line 522
            *(d___0 + i) = (unsigned char )((unsigned int )(((int )*(s + i) + (int )*(s + (i + lx))) + 1) >> 1);
#line 521
            i ++;
          }
#line 523
          s += lx;
#line 524
          d___0 += lx;
#line 519
          j ++;
        }
      }
    } else {
#line 509
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
#line 526
  if (xh) {
#line 526
    if (! yh) {
#line 527
      if (addflag) {
#line 528
        j = 0;
#line 528
        while (j < h) {
#line 530
          i = 0;
#line 530
          while (i < w) {
#line 531
            *(d___0 + i) = (unsigned char )((((unsigned int )*(d___0 + i) + ((unsigned int )(((int )*(s + i) + (int )*(s + (i + 1))) + 1) >> 1)) + 1U) >> 1);
#line 530
            i ++;
          }
#line 532
          s += lx;
#line 533
          d___0 += lx;
#line 528
          j ++;
        }
      } else {
#line 536
        j = 0;
#line 536
        while (j < h) {
#line 538
          i = 0;
#line 538
          while (i < w) {
#line 539
            *(d___0 + i) = (unsigned char )((unsigned int )(((int )*(s + i) + (int )*(s + (i + 1))) + 1) >> 1);
#line 538
            i ++;
          }
#line 540
          s += lx;
#line 541
          d___0 += lx;
#line 536
          j ++;
        }
      }
    } else {
#line 526
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 544
  if (addflag) {
#line 545
    j = 0;
#line 545
    while (j < h) {
#line 547
      i = 0;
#line 547
      while (i < w) {
#line 548
        *(d___0 + i) = (unsigned char )((((unsigned int )*(d___0 + i) + ((unsigned int )(((((int )*(s + i) + (int )*(s + (i + 1))) + (int )*(s + (i + lx))) + (int )*(s + ((i + lx) + 1))) + 2) >> 2)) + 1U) >> 1);
#line 547
        i ++;
      }
#line 549
      s += lx;
#line 550
      d___0 += lx;
#line 545
      j ++;
    }
  } else {
#line 553
    j = 0;
#line 553
    while (j < h) {
#line 555
      i = 0;
#line 555
      while (i < w) {
#line 556
        *(d___0 + i) = (unsigned char )((unsigned int )(((((int )*(s + i) + (int )*(s + (i + 1))) + (int )*(s + (i + lx))) + (int )*(s + ((i + lx) + 1))) + 2) >> 2);
#line 555
        i ++;
      }
#line 557
      s += lx;
#line 558
      d___0 += lx;
#line 553
      j ++;
    }
  }
#line 560
  return;
}
}
#line 575 "src/predict.c"
static void calc_DMV(int (*DMV)[2] , int *dmvector , int mvx , int mvy ) 
{ 


  {
#line 580
  if (pict_struct == 3) {
#line 582
    if (topfirst) {
#line 585
      (*(DMV + 0))[0] = ((mvx + (mvx > 0)) >> 1) + *(dmvector + 0);
#line 586
      (*(DMV + 0))[1] = (((mvy + (mvy > 0)) >> 1) + *(dmvector + 1)) - 1;
#line 589
      (*(DMV + 1))[0] = ((3 * mvx + (mvx > 0)) >> 1) + *(dmvector + 0);
#line 590
      (*(DMV + 1))[1] = (((3 * mvy + (mvy > 0)) >> 1) + *(dmvector + 1)) + 1;
    } else {
#line 595
      (*(DMV + 0))[0] = ((3 * mvx + (mvx > 0)) >> 1) + *(dmvector + 0);
#line 596
      (*(DMV + 0))[1] = (((3 * mvy + (mvy > 0)) >> 1) + *(dmvector + 1)) - 1;
#line 599
      (*(DMV + 1))[0] = ((mvx + (mvx > 0)) >> 1) + *(dmvector + 0);
#line 600
      (*(DMV + 1))[1] = (((mvy + (mvy > 0)) >> 1) + *(dmvector + 1)) + 1;
    }
  } else {
#line 606
    (*(DMV + 0))[0] = ((mvx + (mvx > 0)) >> 1) + *(dmvector + 0);
#line 607
    (*(DMV + 0))[1] = ((mvy + (mvy > 0)) >> 1) + *(dmvector + 1);
#line 610
    if (pict_struct == 1) {
#line 611
      ((*(DMV + 0))[1]) --;
    } else {
#line 613
      ((*(DMV + 0))[1]) ++;
    }
  }
#line 615
  return;
}
}
#line 617 "src/predict.c"
static void clearblock(unsigned char **cur , int i0 , int j0 ) 
{ 
  int i ;
  int j ;
  int w ;
  int h ;
  unsigned char *p ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 624
  if (pict_struct == 2) {
#line 624
    tmp = width;
  } else {
#line 624
    tmp = 0;
  }
#line 624
  p = ((*(cur + 0) + tmp) + i0) + width2 * j0;
#line 626
  j = 0;
#line 626
  while (j < 16) {
#line 628
    i = 0;
#line 628
    while (i < 16) {
#line 629
      *(p + i) = (unsigned char)128;
#line 628
      i ++;
    }
#line 630
    p += width2;
#line 626
    j ++;
  }
#line 633
  h = 16;
#line 633
  w = h;
#line 635
  if (chroma_format != 3) {
#line 637
    i0 >>= 1;
#line 637
    w >>= 1;
  }
#line 640
  if (chroma_format == 1) {
#line 642
    j0 >>= 1;
#line 642
    h >>= 1;
  }
#line 645
  if (pict_struct == 2) {
#line 645
    tmp___0 = chrom_width;
  } else {
#line 645
    tmp___0 = 0;
  }
#line 645
  p = ((*(cur + 1) + tmp___0) + i0) + chrom_width2 * j0;
#line 648
  j = 0;
#line 648
  while (j < h) {
#line 650
    i = 0;
#line 650
    while (i < w) {
#line 651
      *(p + i) = (unsigned char)128;
#line 650
      i ++;
    }
#line 652
    p += chrom_width2;
#line 648
    j ++;
  }
#line 655
  if (pict_struct == 2) {
#line 655
    tmp___1 = chrom_width;
  } else {
#line 655
    tmp___1 = 0;
  }
#line 655
  p = ((*(cur + 2) + tmp___1) + i0) + chrom_width2 * j0;
#line 658
  j = 0;
#line 658
  while (j < h) {
#line 660
    i = 0;
#line 660
    while (i < w) {
#line 661
      *(p + i) = (unsigned char)128;
#line 660
      i ++;
    }
#line 662
    p += chrom_width2;
#line 658
    j ++;
  }
#line 664
  return;
}
}
#line 1 "quantize.o"
#pragma merger("0","/tmp/cil-hTBvWg_q.i","-O4")
#line 88 "src/quantize.c"
static void iquant1_intra(short *src , short *dst , int dc_prec___0 , unsigned char *quant_mat ,
                          int mquant ) ;
#line 90
static void iquant1_non_intra(short *src , short *dst , unsigned char *quant_mat ,
                              int mquant ) ;
#line 95 "src/quantize.c"
void ptquant(int start_mbh , int end_mbh ) 
{ 
  int k ;
  int mb_type ;
  int comp ;
  int cbp ;
  int ind ;
  int ind___0 ;
  int tmp ;

  {
#line 105
  k = start_mbh;
#line 105
  while (k < end_mbh) {
#line 107
    mb_type = (mbinfo + k)->mb_type;
#line 111
    (mbinfo + k)->mquant = 20;
#line 114
    if (mb_type & 1) {
#line 116
      comp = 0;
#line 116
      while (comp < block_count) {
#line 117
        ind = k * block_count + comp;
#line 119
        quant_intra(*(blocks + ind), *(blocks + ind), dc_prec, intra_q, (mbinfo + k)->mquant);
#line 116
        comp ++;
      }
#line 122
      cbp = (1 << block_count) - 1;
#line 122
      (mbinfo + k)->cbp = cbp;
    } else {
#line 127
      cbp = 0;
#line 129
      comp = 0;
#line 129
      while (comp < block_count) {
#line 131
        ind___0 = k * block_count + comp;
#line 133
        tmp = quant_non_intra(*(blocks + ind___0), *(blocks + ind___0), inter_q, (mbinfo + k)->mquant);
#line 133
        cbp = (cbp << 1) | tmp;
#line 129
        comp ++;
      }
#line 137
      (mbinfo + k)->cbp = cbp;
    }
#line 105
    k ++;
  }
#line 143
  return;
}
}
#line 146 "src/quantize.c"
void ptiquant(int start_k , int end_k ) 
{ 
  int k ;
  int j ;
  int ind ;
  int ind___0 ;

  {
#line 152
  k = start_k;
#line 152
  while (k < end_k) {
#line 154
    if ((mbinfo + k)->mb_type & 1) {
#line 155
      j = 0;
#line 155
      while (j < block_count) {
#line 157
        ind = k * block_count + j;
#line 159
        iquant_intra(*(blocks + ind), *(blocks + ind), dc_prec, intra_q, (mbinfo + k)->mquant);
#line 155
        j ++;
      }
    } else {
#line 163
      j = 0;
#line 163
      while (j < block_count) {
#line 165
        ind___0 = k * block_count + j;
#line 167
        iquant_non_intra(*(blocks + ind___0), *(blocks + ind___0), inter_q, (mbinfo + k)->mquant);
#line 163
        j ++;
      }
    }
#line 152
    k ++;
  }
#line 173
  return;
}
}
#line 185 "src/quantize.c"
int quant_intra(short *src , short *dst , int dc_prec___0 , unsigned char *quant_mat ,
                int mquant ) 
{ 
  int i ;
  int x ;
  int y ;
  int d___0 ;
  short dst0 ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 195
  x = (int )*(src + 0);
#line 196
  d___0 = 8 >> dc_prec___0;
#line 197
  if (x >= 0) {
#line 197
    dst0 = (short )((x + (d___0 >> 1)) / d___0);
  } else {
#line 197
    dst0 = (short )(- ((- x + (d___0 >> 1)) / d___0));
  }
#line 287
  i = 0;
#line 287
  while (i < 64) {
#line 289
    x = (int )*(src + i);
#line 290
    d___0 = (int )*(quant_mat + i);
#line 291
    if (x >= 0) {
#line 291
      tmp = x;
    } else {
#line 291
      tmp = - x;
    }
#line 291
    y = (32 * tmp + (d___0 >> 1)) / d___0;
#line 292
    d___0 = (3 * mquant + 2) >> 2;
#line 293
    y = (y + d___0) / (2 * mquant);
#line 295
    if (y > QUANT_THRESHOLD) {
#line 295
      y = QUANT_THRESHOLD;
    } else {
#line 295
      y = y;
    }
#line 296
    if (x >= 0) {
#line 296
      *(dst + i) = (short )y;
    } else {
#line 296
      *(dst + i) = (short )(- y);
    }
#line 297
    i ++;
#line 299
    x = (int )*(src + i);
#line 300
    d___0 = (int )*(quant_mat + i);
#line 301
    if (x >= 0) {
#line 301
      tmp___0 = x;
    } else {
#line 301
      tmp___0 = - x;
    }
#line 301
    y = (32 * tmp___0 + (d___0 >> 1)) / d___0;
#line 302
    d___0 = (3 * mquant + 2) >> 2;
#line 303
    y = (y + d___0) / (2 * mquant);
#line 305
    if (y > QUANT_THRESHOLD) {
#line 305
      y = QUANT_THRESHOLD;
    } else {
#line 305
      y = y;
    }
#line 306
    if (x >= 0) {
#line 306
      *(dst + i) = (short )y;
    } else {
#line 306
      *(dst + i) = (short )(- y);
    }
#line 307
    i ++;
#line 309
    x = (int )*(src + i);
#line 310
    d___0 = (int )*(quant_mat + i);
#line 311
    if (x >= 0) {
#line 311
      tmp___1 = x;
    } else {
#line 311
      tmp___1 = - x;
    }
#line 311
    y = (32 * tmp___1 + (d___0 >> 1)) / d___0;
#line 312
    d___0 = (3 * mquant + 2) >> 2;
#line 313
    y = (y + d___0) / (2 * mquant);
#line 314
    if (y > QUANT_THRESHOLD) {
#line 314
      y = QUANT_THRESHOLD;
    } else {
#line 314
      y = y;
    }
#line 316
    if (x >= 0) {
#line 316
      *(dst + i) = (short )y;
    } else {
#line 316
      *(dst + i) = (short )(- y);
    }
#line 317
    i ++;
#line 319
    x = (int )*(src + i);
#line 320
    d___0 = (int )*(quant_mat + i);
#line 321
    if (x >= 0) {
#line 321
      tmp___2 = x;
    } else {
#line 321
      tmp___2 = - x;
    }
#line 321
    y = (32 * tmp___2 + (d___0 >> 1)) / d___0;
#line 322
    d___0 = (3 * mquant + 2) >> 2;
#line 323
    y = (y + d___0) / (2 * mquant);
#line 324
    if (y > QUANT_THRESHOLD) {
#line 324
      y = QUANT_THRESHOLD;
    } else {
#line 324
      y = y;
    }
#line 326
    if (x >= 0) {
#line 326
      *(dst + i) = (short )y;
    } else {
#line 326
      *(dst + i) = (short )(- y);
    }
#line 327
    i ++;
  }
#line 331
  *(dst + 0) = dst0;
#line 333
  return (1);
}
}
#line 337 "src/quantize.c"
int quant_non_intra(short *src , short *dst , unsigned char *quant_mat , int mquant ) 
{ 
  int i ;
  int x ;
  int y ;
  int d___0 ;
  int nzflag ;
  int tmp ;
  short tmp___0 ;
  int tmp___1 ;
  short tmp___2 ;
  int tmp___3 ;
  short tmp___4 ;
  int tmp___5 ;
  short tmp___6 ;

  {
#line 439
  nzflag = 0;
#line 441
  i = 0;
#line 441
  while (i < 64) {
#line 443
    x = (int )*(src + i);
#line 444
    d___0 = (int )*(quant_mat + i);
#line 445
    if (x >= 0) {
#line 445
      tmp = x;
    } else {
#line 445
      tmp = - x;
    }
#line 445
    y = (32 * tmp + (d___0 >> 1)) / d___0;
#line 446
    y /= 2 * mquant;
#line 447
    if (y > QUANT_THRESHOLD) {
#line 447
      y = QUANT_THRESHOLD;
    }
#line 448
    if (x >= 0) {
#line 448
      tmp___0 = (short )y;
    } else {
#line 448
      tmp___0 = (short )(- y);
    }
#line 448
    *(dst + i) = tmp___0;
#line 448
    if ((int )tmp___0 != 0) {
#line 448
      nzflag = 1;
    }
#line 449
    i ++;
#line 451
    x = (int )*(src + i);
#line 452
    d___0 = (int )*(quant_mat + i);
#line 453
    if (x >= 0) {
#line 453
      tmp___1 = x;
    } else {
#line 453
      tmp___1 = - x;
    }
#line 453
    y = (32 * tmp___1 + (d___0 >> 1)) / d___0;
#line 454
    y /= 2 * mquant;
#line 455
    if (y > QUANT_THRESHOLD) {
#line 455
      y = QUANT_THRESHOLD;
    }
#line 456
    if (x >= 0) {
#line 456
      tmp___2 = (short )y;
    } else {
#line 456
      tmp___2 = (short )(- y);
    }
#line 456
    *(dst + i) = tmp___2;
#line 456
    if ((int )tmp___2 != 0) {
#line 456
      nzflag = 1;
    }
#line 457
    i ++;
#line 459
    x = (int )*(src + i);
#line 460
    d___0 = (int )*(quant_mat + i);
#line 461
    if (x >= 0) {
#line 461
      tmp___3 = x;
    } else {
#line 461
      tmp___3 = - x;
    }
#line 461
    y = (32 * tmp___3 + (d___0 >> 1)) / d___0;
#line 462
    y /= 2 * mquant;
#line 463
    if (y > QUANT_THRESHOLD) {
#line 463
      y = QUANT_THRESHOLD;
    }
#line 464
    if (x >= 0) {
#line 464
      tmp___4 = (short )y;
    } else {
#line 464
      tmp___4 = (short )(- y);
    }
#line 464
    *(dst + i) = tmp___4;
#line 464
    if ((int )tmp___4 != 0) {
#line 464
      nzflag = 1;
    }
#line 465
    i ++;
#line 467
    x = (int )*(src + i);
#line 468
    d___0 = (int )*(quant_mat + i);
#line 469
    if (x >= 0) {
#line 469
      tmp___5 = x;
    } else {
#line 469
      tmp___5 = - x;
    }
#line 469
    y = (32 * tmp___5 + (d___0 >> 1)) / d___0;
#line 470
    y /= 2 * mquant;
#line 471
    if (y > QUANT_THRESHOLD) {
#line 471
      y = QUANT_THRESHOLD;
    }
#line 472
    if (x >= 0) {
#line 472
      tmp___6 = (short )y;
    } else {
#line 472
      tmp___6 = (short )(- y);
    }
#line 472
    *(dst + i) = tmp___6;
#line 472
    if ((int )tmp___6 != 0) {
#line 472
      nzflag = 1;
    }
#line 473
    i ++;
  }
#line 478
  return (nzflag);
}
}
#line 483 "src/quantize.c"
void iquant_intra(short *src , short *dst , int dc_prec___0 , unsigned char *quant_mat ,
                  int mquant ) 
{ 
  int i ;
  int val ;
  int sum ;
  int tmp ;
  short tmp___0 ;
  int tmp___1 ;
  short tmp___2 ;
  int tmp___3 ;
  short tmp___4 ;
  int tmp___5 ;
  short tmp___6 ;
  int tmp___7 ;

  {
#line 491
  if (mpeg1) {
#line 492
    iquant1_intra(src, dst, dc_prec___0, quant_mat, mquant);
  } else {
#line 499
    sum = (int )*(src + 0) << (3 - dc_prec___0);
#line 499
    tmp = sum;
#line 563
    i = 0;
#line 563
    while (i < 64) {
#line 565
      val = (((int )*(src + i) * (int )*(quant_mat + i)) * mquant) / 16;
#line 566
      if (val > 2047) {
#line 566
        tmp___0 = (short)2047;
      } else {
#line 566
        if (val < -2048) {
#line 566
          tmp___1 = -2048;
        } else {
#line 566
          tmp___1 = val;
        }
#line 566
        tmp___0 = (short )tmp___1;
      }
#line 566
      *(dst + i) = tmp___0;
#line 566
      sum ^= (int )tmp___0;
#line 567
      i ++;
#line 569
      val = (((int )*(src + i) * (int )*(quant_mat + i)) * mquant) / 16;
#line 570
      if (val > 2047) {
#line 570
        tmp___2 = (short)2047;
      } else {
#line 570
        if (val < -2048) {
#line 570
          tmp___3 = -2048;
        } else {
#line 570
          tmp___3 = val;
        }
#line 570
        tmp___2 = (short )tmp___3;
      }
#line 570
      *(dst + i) = tmp___2;
#line 570
      sum ^= (int )tmp___2;
#line 571
      i ++;
#line 573
      val = (((int )*(src + i) * (int )*(quant_mat + i)) * mquant) / 16;
#line 574
      if (val > 2047) {
#line 574
        tmp___4 = (short)2047;
      } else {
#line 574
        if (val < -2048) {
#line 574
          tmp___5 = -2048;
        } else {
#line 574
          tmp___5 = val;
        }
#line 574
        tmp___4 = (short )tmp___5;
      }
#line 574
      *(dst + i) = tmp___4;
#line 574
      sum ^= (int )tmp___4;
#line 575
      i ++;
#line 577
      val = (((int )*(src + i) * (int )*(quant_mat + i)) * mquant) / 16;
#line 578
      if (val > 2047) {
#line 578
        tmp___6 = (short)2047;
      } else {
#line 578
        if (val < -2048) {
#line 578
          tmp___7 = -2048;
        } else {
#line 578
          tmp___7 = val;
        }
#line 578
        tmp___6 = (short )tmp___7;
      }
#line 578
      *(dst + i) = tmp___6;
#line 578
      sum ^= (int )tmp___6;
#line 579
      i ++;
    }
#line 583
    sum ^= (int )*(dst + 0);
#line 585
    *(dst + 0) = (short )tmp;
#line 588
    if ((sum & 1) == 0) {
#line 589
      *(dst + 63) = (short )((int )*(dst + 63) ^ 1);
    }
  }
#line 629
  return;
}
}
#line 632 "src/quantize.c"
void iquant_non_intra(short *src , short *dst , unsigned char *quant_mat , int mquant ) 
{ 
  int i ;
  int val ;
  int sum ;
  int tmp ;
  short tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  short tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  short tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  short tmp___9 ;
  int tmp___10 ;

  {
#line 639
  if (mpeg1) {
#line 640
    iquant1_non_intra(src, dst, quant_mat, mquant);
  } else {
#line 720
    sum = 0;
#line 722
    i = 0;
#line 722
    while (i < 64) {
#line 724
      val = (int )*(src + i);
#line 725
      if (val != 0) {
#line 726
        if (val > 0) {
#line 726
          tmp = 1;
        } else {
#line 726
          tmp = -1;
        }
#line 726
        val = (((2 * val + tmp) * (int )*(quant_mat + i)) * mquant) / 32;
      }
#line 727
      if (val > 2047) {
#line 727
        tmp___0 = (short)2047;
      } else {
#line 727
        if (val < -2048) {
#line 727
          tmp___1 = -2048;
        } else {
#line 727
          tmp___1 = val;
        }
#line 727
        tmp___0 = (short )tmp___1;
      }
#line 727
      *(dst + i) = tmp___0;
#line 727
      sum += (int )tmp___0;
#line 728
      i ++;
#line 730
      val = (int )*(src + i);
#line 731
      if (val != 0) {
#line 732
        if (val > 0) {
#line 732
          tmp___2 = 1;
        } else {
#line 732
          tmp___2 = -1;
        }
#line 732
        val = (((2 * val + tmp___2) * (int )*(quant_mat + i)) * mquant) / 32;
      }
#line 733
      if (val > 2047) {
#line 733
        tmp___3 = (short)2047;
      } else {
#line 733
        if (val < -2048) {
#line 733
          tmp___4 = -2048;
        } else {
#line 733
          tmp___4 = val;
        }
#line 733
        tmp___3 = (short )tmp___4;
      }
#line 733
      *(dst + i) = tmp___3;
#line 733
      sum += (int )tmp___3;
#line 734
      i ++;
#line 736
      val = (int )*(src + i);
#line 737
      if (val != 0) {
#line 738
        if (val > 0) {
#line 738
          tmp___5 = 1;
        } else {
#line 738
          tmp___5 = -1;
        }
#line 738
        val = (((2 * val + tmp___5) * (int )*(quant_mat + i)) * mquant) / 32;
      }
#line 739
      if (val > 2047) {
#line 739
        tmp___6 = (short)2047;
      } else {
#line 739
        if (val < -2048) {
#line 739
          tmp___7 = -2048;
        } else {
#line 739
          tmp___7 = val;
        }
#line 739
        tmp___6 = (short )tmp___7;
      }
#line 739
      *(dst + i) = tmp___6;
#line 739
      sum += (int )tmp___6;
#line 740
      i ++;
#line 742
      val = (int )*(src + i);
#line 743
      if (val != 0) {
#line 744
        if (val > 0) {
#line 744
          tmp___8 = 1;
        } else {
#line 744
          tmp___8 = -1;
        }
#line 744
        val = (((2 * val + tmp___8) * (int )*(quant_mat + i)) * mquant) / 32;
      }
#line 745
      if (val > 2047) {
#line 745
        tmp___9 = (short)2047;
      } else {
#line 745
        if (val < -2048) {
#line 745
          tmp___10 = -2048;
        } else {
#line 745
          tmp___10 = val;
        }
#line 745
        tmp___9 = (short )tmp___10;
      }
#line 745
      *(dst + i) = tmp___9;
#line 745
      sum += (int )tmp___9;
#line 746
      i ++;
    }
#line 751
    if ((sum & 1) == 0) {
#line 752
      *(dst + 63) = (short )((int )*(dst + 63) ^ 1);
    }
  }
#line 754
  return;
}
}
#line 763 "src/quantize.c"
static void iquant1_intra(short *src , short *dst , int dc_prec___0 , unsigned char *quant_mat ,
                          int mquant ) 
{ 
  int i ;
  int val ;
  int tmp ;
  int tmp___0 ;

  {
#line 771
  *(dst + 0) = (short )((int )*(src + 0) << (3 - dc_prec___0));
#line 772
  i = 1;
#line 772
  while (i < 64) {
#line 774
    val = (((int )*(src + i) * (int )*(quant_mat + i)) * mquant) / 16;
#line 777
    if ((val & 1) == 0) {
#line 777
      if (val != 0) {
#line 778
        if (val > 0) {
#line 778
          tmp = -1;
        } else {
#line 778
          tmp = 1;
        }
#line 778
        val += tmp;
      }
    }
#line 781
    if (val > 2047) {
#line 781
      *(dst + i) = (short)2047;
    } else {
#line 781
      if (val < -2048) {
#line 781
        tmp___0 = -2048;
      } else {
#line 781
        tmp___0 = val;
      }
#line 781
      *(dst + i) = (short )tmp___0;
    }
#line 772
    i ++;
  }
#line 783
  return;
}
}
#line 785 "src/quantize.c"
static void iquant1_non_intra(short *src , short *dst , unsigned char *quant_mat ,
                              int mquant ) 
{ 
  int i ;
  int val ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 792
  i = 0;
#line 792
  while (i < 64) {
#line 794
    val = (int )*(src + i);
#line 795
    if (val != 0) {
#line 797
      if (val > 0) {
#line 797
        tmp = 1;
      } else {
#line 797
        tmp = -1;
      }
#line 797
      val = (((2 * val + tmp) * (int )*(quant_mat + i)) * mquant) / 32;
#line 800
      if ((val & 1) == 0) {
#line 800
        if (val != 0) {
#line 801
          if (val > 0) {
#line 801
            tmp___0 = -1;
          } else {
#line 801
            tmp___0 = 1;
          }
#line 801
          val += tmp___0;
        }
      }
    }
#line 805
    if (val > 2047) {
#line 805
      *(dst + i) = (short)2047;
    } else {
#line 805
      if (val < -2048) {
#line 805
        tmp___1 = -2048;
      } else {
#line 805
        tmp___1 = val;
      }
#line 805
      *(dst + i) = (short )tmp___1;
    }
#line 792
    i ++;
  }
#line 807
  return;
}
}
#line 1 "putbits.o"
#pragma merger("0","/tmp/cil-sZD0JDWa.i","-O4")
#line 75 "/usr/include/malloc.h"
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 91 "src/putbits.c"
static unsigned char outbfr  ;
#line 92 "src/putbits.c"
static int outcnt  ;
#line 93 "src/putbits.c"
static int bytecnt  ;
#line 97 "src/putbits.c"
int buf_ptr[2]  ;
#line 98 "src/putbits.c"
int cur_size[2]  ;
#line 99 "src/putbits.c"
unsigned char *outfrmbuf[2]  ;
#line 101 "src/putbits.c"
static unsigned char out_bfr[2]  ;
#line 102 "src/putbits.c"
static int out_cnt[2]  ;
#line 103 "src/putbits.c"
int byte_cnt[2]  ;
#line 105 "src/putbits.c"
void write_buf(unsigned char val , int id ) 
{ 
  unsigned char *tmp ;
  void *tmp___0 ;
  int tmp___1 ;

  {
#line 107
  if (buf_ptr[id] == cur_size[id] - 1) {
#line 110
    cur_size[id] <<= 1;
#line 111
    tmp___0 = malloc((unsigned long )cur_size[id] * sizeof(unsigned char ));
#line 111
    tmp = (unsigned char *)tmp___0;
#line 112
    memcpy((void * __restrict  )tmp, (void const   * __restrict  )outfrmbuf[id], (size_t )(cur_size[id] >> 1));
#line 113
    free((void *)outfrmbuf[id]);
#line 114
    outfrmbuf[id] = tmp;
  }
#line 118
  tmp___1 = buf_ptr[id];
#line 118
  (buf_ptr[id]) ++;
#line 118
  *(outfrmbuf[id] + tmp___1) = val;
#line 119
  return;
}
}
#line 122 "src/putbits.c"
void put_bits(int val , int n , int id ) 
{ 
  int i ;
  unsigned int mask ;

  {
#line 130
  mask = (unsigned int )(1 << (n - 1));
#line 132
  i = 0;
#line 132
  while (i < n) {
#line 134
    out_bfr[id] = (unsigned char )((int )out_bfr[id] << 1);
#line 136
    if ((unsigned int )val & mask) {
#line 137
      out_bfr[id] = (unsigned char )((int )out_bfr[id] | 1);
    }
#line 139
    mask >>= 1;
#line 140
    (out_cnt[id]) --;
#line 142
    if (out_cnt[id] == 0) {
#line 144
      write_buf(out_bfr[id], id);
#line 145
      out_cnt[id] = 8;
#line 146
      (byte_cnt[id]) ++;
    }
#line 132
    i ++;
  }
#line 150
  return;
}
}
#line 153 "src/putbits.c"
void align_bits(int id ) 
{ 


  {
#line 155
  if (out_cnt[id] != 8) {
#line 156
    put_bits(0, out_cnt[id], id);
  }
#line 157
  return;
}
}
#line 159 "src/putbits.c"
void flushbits(int id ) 
{ 


  {
#line 162
  align_bits(id);
#line 166
  fwrite((void const   * __restrict  )outfrmbuf[id], sizeof(unsigned char ), (size_t )buf_ptr[id],
         (FILE * __restrict  )outfile);
#line 168
  buf_ptr[id] = 0;
#line 170
  return;
}
}
#line 175 "src/putbits.c"
void initbits(void) 
{ 
  int id ;
  void *tmp ;

  {
#line 181
  outcnt = 8;
#line 182
  bytecnt = 0;
#line 184
  id = 0;
#line 184
  while (id < 2) {
#line 185
    out_cnt[id] = 8;
#line 186
    byte_cnt[id] = 0;
#line 187
    buf_ptr[id] = 0;
#line 188
    tmp = malloc(128UL * sizeof(unsigned char ));
#line 188
    outfrmbuf[id] = (unsigned char *)tmp;
#line 189
    cur_size[id] = 128;
#line 184
    id ++;
  }
#line 192
  return;
}
}
#line 196 "src/putbits.c"
void putbits(int val , int n ) 
{ 
  int i ;
  unsigned int mask ;

  {
#line 203
  mask = (unsigned int )(1 << (n - 1));
#line 205
  i = 0;
#line 205
  while (i < n) {
#line 207
    outbfr = (unsigned char )((int )outbfr << 1);
#line 209
    if ((unsigned int )val & mask) {
#line 210
      outbfr = (unsigned char )((int )outbfr | 1);
    }
#line 212
    mask >>= 1;
#line 213
    outcnt --;
#line 215
    if (outcnt == 0) {
#line 217
      fputc((int )outbfr, outfile);
#line 218
      outcnt = 8;
#line 219
      bytecnt ++;
    }
#line 205
    i ++;
  }
#line 222
  return;
}
}
#line 225 "src/putbits.c"
void alignbits(void) 
{ 


  {
#line 228
  if (outcnt != 8) {
#line 229
    putbits(0, outcnt);
  }
#line 230
  return;
}
}
#line 233 "src/putbits.c"
int bitcount(void) 
{ 


  {
#line 235
  return (8 * bytecnt + (8 - outcnt));
}
}
#line 1 "ratectl.o"
#pragma merger("0","/tmp/cil-zktwyx8E.i","-O4")
#line 185 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h"
extern  __attribute__((__nothrow__)) double ( __attribute__((__leaf__)) floor)(double __x )  __attribute__((__const__)) ;
#line 150 "/usr/include/x86_64-linux-gnu/bits/mathinline.h"
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__, __always_inline__)) __signbitl)(long double __x )  __attribute__((__const__)) ;
#line 150 "/usr/include/x86_64-linux-gnu/bits/mathinline.h"
__inline extern int ( __attribute__((__leaf__, __always_inline__)) __signbitl)(long double __x ) 
{ 
  union __anonunion___u_8___2 __u ;

  {
#line 153
  __u.__l = __x;
#line 154
  return ((__u.__i[2] & 32768) != 0);
}
}
#line 88 "src/ratectl.c"
static void calc_actj(unsigned char *frame ) ;
#line 89
static double var_sblk(unsigned char *p , int lx ) ;
#line 92 "src/ratectl.c"
int Xi  ;
#line 92 "src/ratectl.c"
int Xp  ;
#line 92 "src/ratectl.c"
int Xb  ;
#line 92 "src/ratectl.c"
int r  ;
#line 92 "src/ratectl.c"
int d0i  ;
#line 92 "src/ratectl.c"
int d0p  ;
#line 92 "src/ratectl.c"
int d0b  ;
#line 93 "src/ratectl.c"
double avg_act  ;
#line 94 "src/ratectl.c"
static int R  ;
#line 94 "src/ratectl.c"
static int T  ;
#line 94 "src/ratectl.c"
static int d  ;
#line 95 "src/ratectl.c"
static double actsum  ;
#line 96 "src/ratectl.c"
static int Np  ;
#line 96 "src/ratectl.c"
static int Nb  ;
#line 96 "src/ratectl.c"
static int S  ;
#line 96 "src/ratectl.c"
static int Q  ;
#line 97 "src/ratectl.c"
static int prev_mquant  ;
#line 99 "src/ratectl.c"
void rc_init_seq(void) 
{ 
  double tmp ;
  double tmp___0 ;
  double tmp___1 ;
  double tmp___2 ;
  double tmp___3 ;
  double tmp___4 ;
  double tmp___5 ;

  {
#line 102
  if (r == 0) {
#line 102
    tmp = floor((2.0 * bit_rate) / frame_rate + 0.5);
#line 102
    r = (int )tmp;
  }
#line 105
  if (avg_act == 0.0) {
#line 105
    avg_act = 400.0;
  }
#line 108
  R = 0;
#line 111
  if (Xi == 0) {
#line 111
    tmp___0 = floor((160.0 * bit_rate) / 115.0 + 0.5);
#line 111
    Xi = (int )tmp___0;
  }
#line 112
  if (Xp == 0) {
#line 112
    tmp___1 = floor((60.0 * bit_rate) / 115.0 + 0.5);
#line 112
    Xp = (int )tmp___1;
  }
#line 113
  if (Xb == 0) {
#line 113
    tmp___2 = floor((42.0 * bit_rate) / 115.0 + 0.5);
#line 113
    Xb = (int )tmp___2;
  }
#line 116
  if (d0i == 0) {
#line 116
    tmp___3 = floor((10.0 * (double )r) / 31.0 + 0.5);
#line 116
    d0i = (int )tmp___3;
  }
#line 117
  if (d0p == 0) {
#line 117
    tmp___4 = floor((10.0 * (double )r) / 31.0 + 0.5);
#line 117
    d0p = (int )tmp___4;
  }
#line 118
  if (d0b == 0) {
#line 118
    tmp___5 = floor(((1.4 * 10.0) * (double )r) / 31.0 + 0.5);
#line 118
    d0b = (int )tmp___5;
  }
#line 135
  return;
}
}
#line 137 "src/ratectl.c"
void rc_init_GOP(int np , int nb ) 
{ 
  double tmp ;

  {
#line 140
  tmp = floor(((double )((1 + np) + nb) * bit_rate) / frame_rate + 0.5);
#line 140
  R += (int )tmp;
#line 141
  if (fieldpic) {
#line 141
    Np = 2 * np + 1;
  } else {
#line 141
    Np = np;
  }
#line 142
  if (fieldpic) {
#line 142
    Nb = 2 * nb;
  } else {
#line 142
    Nb = nb;
  }
#line 149
  return;
}
}
#line 155 "src/ratectl.c"
void rc_init_pict(unsigned char *frame ) 
{ 
  double Tmin ;
  double tmp ;
  double tmp___0 ;
  double tmp___1 ;
  double tmp___2 ;

  {
#line 160
  switch (pict_type) {
  case 1: 
#line 163
  tmp = floor((double )R / ((1.0 + (double )(Np * Xp) / ((double )Xi * 1.0)) + (double )(Nb * Xb) / ((double )Xi * 1.4)) + 0.5);
#line 163
  T = (int )tmp;
#line 164
  d = d0i;
#line 165
  break;
  case 2: 
#line 167
  tmp___0 = floor((double )R / ((double )Np + (((double )Nb * 1.0) * (double )Xb) / (1.4 * (double )Xp)) + 0.5);
#line 167
  T = (int )tmp___0;
#line 168
  d = d0p;
#line 169
  break;
  case 3: 
#line 171
  tmp___1 = floor((double )R / ((double )Nb + (((double )Np * 1.4) * (double )Xp) / (1.0 * (double )Xb)) + 0.5);
#line 171
  T = (int )tmp___1;
#line 172
  d = d0b;
#line 173
  break;
  }
#line 176
  tmp___2 = floor(bit_rate / (8.0 * frame_rate) + 0.5);
#line 176
  Tmin = (double )((int )tmp___2);
#line 178
  if ((double )T < Tmin) {
#line 179
    T = (int )Tmin;
  }
#line 181
  S = bitcount();
#line 182
  Q = 0;
#line 184
  calc_actj(frame);
#line 185
  actsum = 0.0;
#line 190
  return;
}
}
#line 192 "src/ratectl.c"
static void calc_actj(unsigned char *frame ) 
{ 
  int i ;
  int j ;
  int k ;
  unsigned char *p ;
  double actj ;
  double var ;
  int tmp ;
  int tmp___0 ;

  {
#line 199
  k = 0;
#line 201
  j = 0;
#line 201
  while (j < height2) {
#line 202
    i = 0;
#line 202
    while (i < width) {
#line 204
      if (pict_struct == 2) {
#line 204
        tmp = width;
      } else {
#line 204
        tmp = 0;
      }
#line 204
      p = ((frame + tmp) + i) + width2 * j;
#line 208
      actj = var_sblk(p, width2);
#line 209
      var = var_sblk(p + 8, width2);
#line 210
      if (var < actj) {
#line 210
        actj = var;
      }
#line 211
      var = var_sblk(p + 8 * width2, width2);
#line 212
      if (var < actj) {
#line 212
        actj = var;
      }
#line 213
      var = var_sblk((p + 8 * width2) + 8, width2);
#line 214
      if (var < actj) {
#line 214
        actj = var;
      }
#line 216
      if (! fieldpic) {
#line 216
        if (! prog_seq) {
#line 219
          var = var_sblk(p, width << 1);
#line 220
          if (var < actj) {
#line 220
            actj = var;
          }
#line 221
          var = var_sblk(p + 8, width << 1);
#line 222
          if (var < actj) {
#line 222
            actj = var;
          }
#line 223
          var = var_sblk(p + width, width << 1);
#line 224
          if (var < actj) {
#line 224
            actj = var;
          }
#line 225
          var = var_sblk((p + width) + 8, width << 1);
#line 226
          if (var < actj) {
#line 226
            actj = var;
          }
        }
      }
#line 229
      actj += 1.0;
#line 231
      tmp___0 = k;
#line 231
      k ++;
#line 231
      (mbinfo + tmp___0)->act = actj;
#line 202
      i += 16;
    }
#line 201
    j += 16;
  }
#line 233
  return;
}
}
#line 235 "src/ratectl.c"
void rc_update_pict(void) 
{ 
  double X ;
  int tmp ;
  double tmp___0 ;

  {
#line 239
  tmp = bitcount();
#line 239
  S = tmp - S;
#line 240
  R -= S;
#line 241
  tmp___0 = floor((double )S * ((0.5 * (double )Q) / (double )(mb_width * mb_height2)) + 0.5);
#line 241
  X = (double )((int )tmp___0);
#line 242
  d += S - T;
#line 243
  avg_act = actsum / (double )(mb_width * mb_height2);
#line 245
  switch (pict_type) {
  case 1: 
#line 248
  Xi = (int )X;
#line 249
  d0i = d;
#line 250
  break;
  case 2: 
#line 252
  Xp = (int )X;
#line 253
  d0p = d;
#line 254
  Np --;
#line 255
  break;
  case 3: 
#line 257
  Xb = (int )X;
#line 258
  d0b = d;
#line 259
  Nb --;
#line 260
  break;
  }
#line 278
  return;
}
}
#line 281 "src/ratectl.c"
int rc_start_mb(void) 
{ 
  int mquant ;
  double tmp ;
  double tmp___0 ;

  {
#line 285
  if (q_scale_type) {
#line 287
    tmp = floor(((2.0 * (double )d) * 31.0) / (double )r + 0.5);
#line 287
    mquant = (int )tmp;
#line 290
    if (mquant < 1) {
#line 291
      mquant = 1;
    }
#line 292
    if (mquant > 112) {
#line 293
      mquant = 112;
    }
#line 296
    mquant = (int )non_linear_mquant_table[map_non_linear_mquant[mquant]];
  } else {
#line 300
    tmp___0 = floor(((double )d * 31.0) / (double )r + 0.5);
#line 300
    mquant = (int )tmp___0;
#line 301
    mquant <<= 1;
#line 304
    if (mquant < 2) {
#line 305
      mquant = 2;
    }
#line 306
    if (mquant > 62) {
#line 307
      mquant = 62;
    }
#line 309
    prev_mquant = mquant;
  }
#line 317
  return (mquant);
}
}
#line 321 "src/ratectl.c"
int rc_calc_mquant(int j ) 
{ 
  int mquant ;
  double dj ;
  double Qj ;
  double actj ;
  double N_actj ;
  int tmp ;
  double tmp___0 ;
  double tmp___1 ;

  {
#line 328
  tmp = bitcount();
#line 328
  dj = (double )((d + (tmp - S)) - j * (T / (mb_width * mb_height2)));
#line 331
  Qj = (dj * 31.0) / (double )r;
#line 334
  actj = (mbinfo + j)->act;
#line 335
  actsum += actj;
#line 338
  N_actj = (2.0 * actj + avg_act) / (actj + 2.0 * avg_act);
#line 340
  if (q_scale_type) {
#line 343
    tmp___0 = floor((2.0 * Qj) * N_actj + 0.5);
#line 343
    mquant = (int )tmp___0;
#line 346
    if (mquant < 1) {
#line 347
      mquant = 1;
    }
#line 348
    if (mquant > 112) {
#line 349
      mquant = 112;
    }
#line 352
    mquant = (int )non_linear_mquant_table[map_non_linear_mquant[mquant]];
  } else {
#line 357
    tmp___1 = floor(Qj * N_actj + 0.5);
#line 357
    mquant = (int )tmp___1;
#line 358
    mquant <<= 1;
#line 361
    if (mquant < 2) {
#line 362
      mquant = 2;
    }
#line 363
    if (mquant > 62) {
#line 364
      mquant = 62;
    }
#line 367
    if (mquant >= 8) {
#line 367
      if (mquant - prev_mquant >= -4) {
#line 367
        if (mquant - prev_mquant <= 4) {
#line 368
          mquant = prev_mquant;
        }
      }
    }
#line 370
    prev_mquant = mquant;
  }
#line 373
  Q += mquant;
#line 381
  return (mquant);
}
}
#line 385 "src/ratectl.c"
static double var_sblk(unsigned char *p , int lx ) 
{ 
  int i ;
  int j ;
  unsigned int v ;
  unsigned int s ;
  unsigned int s2 ;
  unsigned char *tmp ;

  {
#line 392
  s2 = 0U;
#line 392
  s = s2;
#line 394
  j = 0;
#line 394
  while (j < 8) {
#line 396
    i = 0;
#line 396
    while (i < 8) {
#line 398
      tmp = p;
#line 398
      p ++;
#line 398
      v = (unsigned int )*tmp;
#line 399
      s += v;
#line 400
      s2 += v * v;
#line 396
      i ++;
    }
#line 402
    p += lx - 8;
#line 394
    j ++;
  }
#line 405
  return ((double )s2 / 64.0 - ((double )s / 64.0) * ((double )s / 64.0));
}
}
#line 420 "src/ratectl.c"
static int bitcnt_EOP  ;
#line 422 "src/ratectl.c"
void vbv_end_of_picture(void) 
{ 


  {
#line 424
  bitcnt_EOP = bitcount();
#line 425
  bitcnt_EOP = (bitcnt_EOP + 7) & -8;
#line 426
  return;
}
}
#line 437 "src/ratectl.c"
static double next_ip_delay  ;
#line 438 "src/ratectl.c"
static double decoding_time  ;
#line 434 "src/ratectl.c"
void calc_vbv_delay(void) 
{ 
  double picture_delay ;
  int tmp ;

  {
#line 441
  if (pict_type == 3) {
#line 443
    if (prog_seq) {
#line 445
      if (! repeatfirst) {
#line 446
        picture_delay = 90000.0 / frame_rate;
      } else
#line 449
      if (! topfirst) {
#line 450
        picture_delay = (90000.0 * 2.0) / frame_rate;
      } else {
#line 452
        picture_delay = (90000.0 * 3.0) / frame_rate;
      }
    } else
#line 458
    if (fieldpic) {
#line 459
      picture_delay = 90000.0 / (2.0 * frame_rate);
    } else
#line 462
    if (! repeatfirst) {
#line 463
      picture_delay = (90000.0 * 2.0) / (2.0 * frame_rate);
    } else {
#line 465
      picture_delay = (90000.0 * 3.0) / (2.0 * frame_rate);
    }
  } else {
#line 472
    if (fieldpic) {
#line 474
      if (topfirst == (pict_struct == 1)) {
#line 477
        picture_delay = 90000.0 / (2.0 * frame_rate);
      } else {
#line 483
        picture_delay = next_ip_delay - 90000.0 / (2.0 * frame_rate);
      }
    } else {
#line 490
      picture_delay = next_ip_delay;
    }
#line 493
    if (! fieldpic) {
#line 493
      goto _L;
    } else
#line 493
    if (topfirst != (pict_struct == 1)) {
      _L: /* CIL Label */ 
#line 496
      if (prog_seq) {
#line 498
        if (! repeatfirst) {
#line 499
          next_ip_delay = 90000.0 / frame_rate;
        } else
#line 502
        if (! topfirst) {
#line 503
          next_ip_delay = (90000.0 * 2.0) / frame_rate;
        } else {
#line 505
          next_ip_delay = (90000.0 * 3.0) / frame_rate;
        }
      } else
#line 510
      if (fieldpic) {
#line 511
        next_ip_delay = 90000.0 / (2.0 * frame_rate);
      } else
#line 514
      if (! repeatfirst) {
#line 515
        next_ip_delay = (90000.0 * 2.0) / (2.0 * frame_rate);
      } else {
#line 517
        next_ip_delay = (90000.0 * 3.0) / (2.0 * frame_rate);
      }
    }
  }
#line 523
  if (decoding_time == 0.0) {
#line 527
    picture_delay = ((double )(((vbv_buffer_size * 16384) * 7) / 8) * 90000.0) / bit_rate;
#line 528
    if (fieldpic) {
#line 529
      next_ip_delay = (double )((int )(90000.0 / frame_rate + 0.5));
    }
  }
#line 535
  if (! low_delay) {
#line 535
    if (decoding_time < ((double )bitcnt_EOP * 90000.0) / bit_rate) {
#line 538
      if (! quiet) {
#line 539
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"vbv_delay underflow! (decoding_time=%.1f, t_EOP=%.1f\n)",
                decoding_time, ((double )bitcnt_EOP * 90000.0) / bit_rate);
      }
    }
  }
#line 544
  decoding_time += picture_delay;
#line 547
  tmp = bitcount();
#line 547
  vbv_delay = (int )(decoding_time - ((double )tmp * 90000.0) / bit_rate);
#line 550
  if (decoding_time - ((double )bitcnt_EOP * 90000.0) / bit_rate > ((double )(vbv_buffer_size * 16384) * 90000.0) / bit_rate) {
#line 553
    if (! quiet) {
#line 554
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"vbv_delay overflow!\n");
    }
  }
#line 563
  if (vbv_delay < 0) {
#line 565
    if (! quiet) {
#line 566
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"vbv_delay underflow: %d\n",
              vbv_delay);
    }
#line 567
    vbv_delay = 0;
  }
#line 570
  if (vbv_delay > 65535) {
#line 572
    if (! quiet) {
#line 573
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"vbv_delay overflow: %d\n",
              vbv_delay);
    }
#line 574
    vbv_delay = 65535;
  }
#line 576
  return;
}
}
