/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is true */

#line 213 "/usr/lib/gcc/x86_64-linux-gnu/4.7/include/stddef.h"
typedef unsigned long size_t;
#line 325 "/usr/lib/gcc/x86_64-linux-gnu/4.7/include/stddef.h"
typedef int wchar_t;
#line 60 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef unsigned long pthread_t;
#line 75 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
struct __pthread_internal_list {
   struct __pthread_internal_list *__prev ;
   struct __pthread_internal_list *__next ;
};
#line 75 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef struct __pthread_internal_list __pthread_list_t;
#line 90 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
struct __pthread_mutex_s {
   int __lock ;
   unsigned int __count ;
   int __owner ;
   unsigned int __nusers ;
   int __kind ;
   int __spins ;
   __pthread_list_t __list ;
};
#line 90 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
union __anonunion_pthread_mutex_t_10 {
   struct __pthread_mutex_s __data ;
   char __size[40] ;
   long __align ;
};
#line 90 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef union __anonunion_pthread_mutex_t_10 pthread_mutex_t;
#line 120 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
union __anonunion_pthread_mutexattr_t_11 {
   char __size[4] ;
   int __align ;
};
#line 120 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef union __anonunion_pthread_mutexattr_t_11 pthread_mutexattr_t;
#line 129 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
struct __anonstruct___data_13 {
   int __lock ;
   unsigned int __futex ;
   unsigned long long __total_seq ;
   unsigned long long __wakeup_seq ;
   unsigned long long __woken_seq ;
   void *__mutex ;
   unsigned int __nwaiters ;
   unsigned int __broadcast_seq ;
};
#line 129 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
union __anonunion_pthread_cond_t_12 {
   struct __anonstruct___data_13 __data ;
   char __size[48] ;
   long long __align ;
};
#line 129 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef union __anonunion_pthread_cond_t_12 pthread_cond_t;
#line 146 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
union __anonunion_pthread_condattr_t_14 {
   char __size[4] ;
   int __align ;
};
#line 146 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef union __anonunion_pthread_condattr_t_14 pthread_condattr_t;
#line 54 "src/barrier.h"
struct barrier_struct {
   int padding1[8] ;
   pthread_mutex_t lock ;
   int n_clients ;
   int n_waiting ;
   int phase ;
   pthread_cond_t wait_cv ;
   int padding2[8] ;
};
#line 54 "src/barrier.h"
typedef struct barrier_struct barrier_t;
#line 114 "src/prim_type.h"
typedef int int32;
#line 117 "src/prim_type.h"
typedef unsigned int uint32;
#line 118 "src/bitvec.h"
typedef uint32 *bitvec_t;
#line 140 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 141 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 40 "/usr/lib/gcc/x86_64-linux-gnu/4.7/include/stdarg.h"
typedef __builtin_va_list __gnuc_va_list;
#line 155 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 161 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 246 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 316 "/usr/include/libio.h"
typedef struct _IO_FILE _IO_FILE;
#line 281 "src/ckd_alloc.c"
struct mylist_s {
   char **freelist ;
   struct mylist_s *next ;
   int32 elemsize ;
   int32 blocksize ;
   int32 blk_alloc ;
};
#line 281 "src/ckd_alloc.c"
typedef struct mylist_s mylist_t;
#line 119 "src/prim_type.h"
typedef unsigned char uint8;
#line 120 "src/prim_type.h"
typedef float float32;
#line 121 "src/prim_type.h"
typedef double float64;
#line 123 "src/prim_type.h"
union anytype_s {
   void *ptr ;
   int32 int32 ;
   uint32 uint32 ;
   float32 float32 ;
   float64 float64 ;
};
#line 123 "src/prim_type.h"
typedef union anytype_s anytype_t;
#line 127 "src/cmd_ln.h"
typedef int32 argtype_t;
#line 130 "src/cmd_ln.h"
struct __anonstruct_arg_t_24 {
   char *name ;
   argtype_t type ;
   char *deflt ;
   char *doc ;
};
#line 130 "src/cmd_ln.h"
typedef struct __anonstruct_arg_t_24 arg_t;
#line 139 "src/hash.h"
struct hash_entry_s {
   char const   *key ;
   int32 len ;
   int32 val ;
   struct hash_entry_s *next ;
};
#line 139 "src/hash.h"
typedef struct hash_entry_s hash_entry_t;
#line 149 "src/hash.h"
struct __anonstruct_hash_table_t_25 {
   hash_entry_t *table ;
   int32 size ;
   uint8 nocase ;
};
#line 149 "src/hash.h"
typedef struct __anonstruct_hash_table_t_25 hash_table_t;
#line 124 "src/cmd_ln.c"
struct argval_s {
   anytype_t val ;
   void const   *ptr ;
};
#line 124 "src/cmd_ln.c"
typedef struct argval_s argval_t;
#line 79 "/usr/include/stdio.h"
typedef __gnuc_va_list va_list;
#line 127 "src/glist.h"
struct gnode_s {
   anytype_t data ;
   struct gnode_s *next ;
};
#line 127 "src/glist.h"
typedef struct gnode_s gnode_t;
#line 131 "src/glist.h"
typedef gnode_t *glist_t;
#line 133 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __dev_t;
#line 134 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __uid_t;
#line 135 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __gid_t;
#line 136 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __ino_t;
#line 138 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __mode_t;
#line 139 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __nlink_t;
#line 148 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 162 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blksize_t;
#line 167 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blkcnt_t;
#line 181 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __ssize_t;
#line 184 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __syscall_slong_t;
#line 102 "/usr/include/stdio.h"
typedef __ssize_t ssize_t;
#line 120 "/usr/include/time.h"
struct timespec {
   __time_t tv_sec ;
   __syscall_slong_t tv_nsec ;
};
#line 153 "/usr/include/x86_64-linux-gnu/bits/mathinline.h"
union __anonunion___u_29 {
   long double __l ;
   int __i[3] ;
};
#line 118 "src/prim_type.h"
typedef unsigned short uint16;
#line 46 "/usr/include/x86_64-linux-gnu/bits/stat.h"
struct stat {
   __dev_t st_dev ;
   __ino_t st_ino ;
   __nlink_t st_nlink ;
   __mode_t st_mode ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   int __pad0 ;
   __dev_t st_rdev ;
   __off_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   __syscall_slong_t __unused[3] ;
};
#line 153 "/usr/include/x86_64-linux-gnu/bits/mathinline.h"
union __anonunion___u_29___0 {
   long double __l ;
   int __i[3] ;
};
#line 134 "src/profile.h"
struct __anonstruct_ptmr_t_33 {
   char const   *name ;
   float64 t_cpu ;
   float64 t_elapsed ;
   float64 t_tot_cpu ;
   float64 t_tot_elapsed ;
   float64 start_cpu ;
   float64 start_elapsed ;
};
#line 134 "src/profile.h"
typedef struct __anonstruct_ptmr_t_33 ptmr_t;
#line 117 "src/vector.h"
typedef float32 *vector_t;
#line 290 "src/vector.h"
struct __anonstruct_vector_gautbl_t_37 {
   int32 n_gau ;
   int32 veclen ;
   float32 **mean ;
   float32 **var ;
   float32 *lrd ;
   float64 distfloor ;
};
#line 290 "src/vector.h"
typedef struct __anonstruct_vector_gautbl_t_37 vector_gautbl_t;
#line 153 "/usr/include/x86_64-linux-gnu/bits/mathinline.h"
union __anonunion___u_29___1 {
   long double __l ;
   int __i[3] ;
};
#line 112 "src/heap.h"
typedef void *heap_t;
#line 117 "src/heap.c"
struct heap_s {
   void *data ;
   int32 val ;
   int32 nl ;
   int32 nr ;
   struct heap_s *l ;
   struct heap_s *r ;
};
#line 117 "src/heap.c"
typedef struct heap_s heapnode_t;
#line 150 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __suseconds_t;
#line 30 "/usr/include/x86_64-linux-gnu/bits/time.h"
struct timeval {
   __time_t tv_sec ;
   __suseconds_t tv_usec ;
};
#line 56 "/usr/include/x86_64-linux-gnu/sys/time.h"
struct timezone {
   int tz_minuteswest ;
   int tz_dsttime ;
};
#line 62 "/usr/include/x86_64-linux-gnu/sys/time.h"
typedef struct timezone * __restrict  __timezone_ptr_t;
#line 187 "/usr/include/x86_64-linux-gnu/bits/resource.h"
union __anonunion____missing_field_name_27 {
   long ru_maxrss ;
   __syscall_slong_t __ru_maxrss_word ;
};
#line 187 "/usr/include/x86_64-linux-gnu/bits/resource.h"
union __anonunion____missing_field_name_28 {
   long ru_ixrss ;
   __syscall_slong_t __ru_ixrss_word ;
};
#line 187 "/usr/include/x86_64-linux-gnu/bits/resource.h"
union __anonunion____missing_field_name_29 {
   long ru_idrss ;
   __syscall_slong_t __ru_idrss_word ;
};
#line 187 "/usr/include/x86_64-linux-gnu/bits/resource.h"
union __anonunion____missing_field_name_30 {
   long ru_isrss ;
   __syscall_slong_t __ru_isrss_word ;
};
#line 187 "/usr/include/x86_64-linux-gnu/bits/resource.h"
union __anonunion____missing_field_name_31 {
   long ru_minflt ;
   __syscall_slong_t __ru_minflt_word ;
};
#line 187 "/usr/include/x86_64-linux-gnu/bits/resource.h"
union __anonunion____missing_field_name_32 {
   long ru_majflt ;
   __syscall_slong_t __ru_majflt_word ;
};
#line 187 "/usr/include/x86_64-linux-gnu/bits/resource.h"
union __anonunion____missing_field_name_33 {
   long ru_nswap ;
   __syscall_slong_t __ru_nswap_word ;
};
#line 187 "/usr/include/x86_64-linux-gnu/bits/resource.h"
union __anonunion____missing_field_name_34 {
   long ru_inblock ;
   __syscall_slong_t __ru_inblock_word ;
};
#line 187 "/usr/include/x86_64-linux-gnu/bits/resource.h"
union __anonunion____missing_field_name_35 {
   long ru_oublock ;
   __syscall_slong_t __ru_oublock_word ;
};
#line 187 "/usr/include/x86_64-linux-gnu/bits/resource.h"
union __anonunion____missing_field_name_36 {
   long ru_msgsnd ;
   __syscall_slong_t __ru_msgsnd_word ;
};
#line 187 "/usr/include/x86_64-linux-gnu/bits/resource.h"
union __anonunion____missing_field_name_37 {
   long ru_msgrcv ;
   __syscall_slong_t __ru_msgrcv_word ;
};
#line 187 "/usr/include/x86_64-linux-gnu/bits/resource.h"
union __anonunion____missing_field_name_38 {
   long ru_nsignals ;
   __syscall_slong_t __ru_nsignals_word ;
};
#line 187 "/usr/include/x86_64-linux-gnu/bits/resource.h"
union __anonunion____missing_field_name_39 {
   long ru_nvcsw ;
   __syscall_slong_t __ru_nvcsw_word ;
};
#line 187 "/usr/include/x86_64-linux-gnu/bits/resource.h"
union __anonunion____missing_field_name_40 {
   long ru_nivcsw ;
   __syscall_slong_t __ru_nivcsw_word ;
};
#line 187 "/usr/include/x86_64-linux-gnu/bits/resource.h"
struct rusage {
   struct timeval ru_utime ;
   struct timeval ru_stime ;
   union __anonunion____missing_field_name_27 __annonCompField1 ;
   union __anonunion____missing_field_name_28 __annonCompField2 ;
   union __anonunion____missing_field_name_29 __annonCompField3 ;
   union __anonunion____missing_field_name_30 __annonCompField4 ;
   union __anonunion____missing_field_name_31 __annonCompField5 ;
   union __anonunion____missing_field_name_32 __annonCompField6 ;
   union __anonunion____missing_field_name_33 __annonCompField7 ;
   union __anonunion____missing_field_name_34 __annonCompField8 ;
   union __anonunion____missing_field_name_35 __annonCompField9 ;
   union __anonunion____missing_field_name_36 __annonCompField10 ;
   union __anonunion____missing_field_name_37 __annonCompField11 ;
   union __anonunion____missing_field_name_38 __annonCompField12 ;
   union __anonunion____missing_field_name_39 __annonCompField13 ;
   union __anonunion____missing_field_name_40 __annonCompField14 ;
};
#line 44 "/usr/include/x86_64-linux-gnu/sys/resource.h"
typedef int __rusage_who_t;
#line 118 "src/profile.h"
struct __anonstruct_pctr_t_41 {
   char const   *name ;
   int32 count ;
};
#line 118 "src/profile.h"
typedef struct __anonstruct_pctr_t_41 pctr_t;
#line 40 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __int32_t;
#line 145 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __rlim_t;
#line 131 "/usr/include/x86_64-linux-gnu/bits/resource.h"
typedef __rlim_t rlim_t;
#line 139 "/usr/include/x86_64-linux-gnu/bits/resource.h"
struct rlimit {
   rlim_t rlim_cur ;
   rlim_t rlim_max ;
};
#line 43 "/usr/include/x86_64-linux-gnu/sys/resource.h"
typedef int __rlimit_resource_t;
#line 153 "/usr/include/x86_64-linux-gnu/bits/mathinline.h"
union __anonunion___u_29___2 {
   long double __l ;
   int __i[3] ;
};
#line 153 "/usr/include/x86_64-linux-gnu/bits/mathinline.h"
union __anonunion___u_29___3 {
   long double __l ;
   int __i[3] ;
};
#line 146 "src/cont_mgau.h"
struct __anonstruct_mgau_t_38 {
   int32 n_comp ;
   float32 **mean ;
   float32 **var ;
   int32 *mixw ;
   float32 *lrd ;
};
#line 146 "src/cont_mgau.h"
typedef struct __anonstruct_mgau_t_38 mgau_t;
#line 162 "src/cont_mgau.h"
struct __anonstruct_mgau_model_t_39 {
   int32 n_mgau ;
   int32 max_comp ;
   int32 veclen ;
   mgau_t *mgau ;
   float64 distfloor ;
   int32 frm_sen_eval ;
   int32 frm_gau_eval ;
};
#line 162 "src/cont_mgau.h"
typedef struct __anonstruct_mgau_model_t_39 mgau_model_t;
#line 153 "/usr/include/x86_64-linux-gnu/bits/mathinline.h"
union __anonunion___u_29___4 {
   long double __l ;
   int __i[3] ;
};
#line 121 "src/vector.h"
struct __anonstruct_arraysize_t_36 {
   int32 r ;
   int32 c ;
};
#line 121 "src/vector.h"
typedef struct __anonstruct_arraysize_t_36 arraysize_t;
#line 131 "src/subvq.h"
struct __anonstruct_subvq_t_40 {
   arraysize_t origsize ;
   int32 n_sv ;
   int32 vqsize ;
   int32 **featdim ;
   vector_gautbl_t *gautbl ;
   int32 ***map ;
   float32 *subvec ;
   int32 **vqdist ;
   int32 *gauscore ;
   int32 *mgau_sl ;
   float32 *thrd_subvec[1] ;
   int32 *thrd_gauscore[1] ;
   int32 *thrd_mgau_sl[1] ;
};
#line 131 "src/subvq.h"
typedef struct __anonstruct_subvq_t_40 subvq_t;
#line 153 "/usr/include/x86_64-linux-gnu/bits/mathinline.h"
union __anonunion___u_42 {
   long double __l ;
   int __i[3] ;
};
#line 115 "src/prim_type.h"
typedef short int16;
#line 116 "src/prim_type.h"
typedef char int8;
#line 126 "src/s3types.h"
typedef int8 s3cipid_t;
#line 132 "src/s3types.h"
typedef int32 s3pid_t;
#line 138 "src/s3types.h"
typedef s3pid_t s3ssid_t;
#line 144 "src/s3types.h"
typedef int32 s3tmatid_t;
#line 150 "src/s3types.h"
typedef int32 s3wid_t;
#line 156 "src/s3types.h"
typedef uint16 s3lmwid_t;
#line 168 "src/s3types.h"
typedef int16 s3frmid_t;
#line 174 "src/s3types.h"
typedef int16 s3senid_t;
#line 123 "src/mdef.h"
enum __anonenum_word_posn_t_54 {
    WORD_POSN_BEGIN = 0,
    WORD_POSN_END = 1,
    WORD_POSN_SINGLE = 2,
    WORD_POSN_INTERNAL = 3,
    WORD_POSN_UNDEFINED = 4
} ;
#line 123 "src/mdef.h"
typedef enum __anonenum_word_posn_t_54 word_posn_t;
#line 135 "src/mdef.h"
struct __anonstruct_ciphone_t_55 {
   char *name ;
   int32 filler ;
};
#line 135 "src/mdef.h"
typedef struct __anonstruct_ciphone_t_55 ciphone_t;
#line 145 "src/mdef.h"
struct __anonstruct_phone_t_56 {
   s3ssid_t ssid ;
   s3tmatid_t tmat ;
   s3cipid_t ci ;
   s3cipid_t lc ;
   s3cipid_t rc ;
   word_posn_t wpos ;
};
#line 145 "src/mdef.h"
typedef struct __anonstruct_phone_t_56 phone_t;
#line 159 "src/mdef.h"
struct ph_rc_s {
   s3cipid_t rc ;
   s3pid_t pid ;
   struct ph_rc_s *next ;
};
#line 159 "src/mdef.h"
typedef struct ph_rc_s ph_rc_t;
#line 165 "src/mdef.h"
struct ph_lc_s {
   s3cipid_t lc ;
   ph_rc_t *rclist ;
   struct ph_lc_s *next ;
};
#line 165 "src/mdef.h"
typedef struct ph_lc_s ph_lc_t;
#line 173 "src/mdef.h"
struct __anonstruct_mdef_t_57 {
   int32 n_ciphone ;
   int32 n_phone ;
   int32 n_emit_state ;
   int32 n_ci_sen ;
   int32 n_sen ;
   int32 n_tmat ;
   hash_table_t *ciphone_ht ;
   ciphone_t *ciphone ;
   phone_t *phone ;
   s3senid_t **sseq ;
   int32 n_sseq ;
   s3senid_t *cd2cisen ;
   s3cipid_t *sen2cimap ;
   int32 *ciphone2n_cd_sen ;
   s3cipid_t sil ;
   ph_lc_t ***wpos_ci_lclist ;
};
#line 173 "src/mdef.h"
typedef struct __anonstruct_mdef_t_57 mdef_t;
#line 122 "src/dict.h"
struct __anonstruct_dictword_t_58 {
   char *word ;
   s3cipid_t *ciphone ;
   int32 pronlen ;
   s3wid_t alt ;
   s3wid_t basewid ;
   int32 n_comp ;
   s3wid_t *comp ;
};
#line 122 "src/dict.h"
typedef struct __anonstruct_dictword_t_58 dictword_t;
#line 135 "src/dict.h"
struct __anonstruct_dict_t_59 {
   mdef_t *mdef ;
   hash_table_t *pht ;
   char **ciphone_str ;
   int32 n_ciphone ;
   dictword_t *word ;
   hash_table_t *ht ;
   int32 max_words ;
   int32 n_word ;
   int32 filler_start ;
   int32 filler_end ;
   s3wid_t *comp_head ;
   s3wid_t startwid ;
   s3wid_t finishwid ;
   s3wid_t silwid ;
};
#line 135 "src/dict.h"
typedef struct __anonstruct_dict_t_59 dict_t;
#line 150 "src/dict2pid.h"
struct __anonstruct_dict2pid_t_60 {
   s3ssid_t **internal ;
   s3ssid_t ***ldiph_lc ;
   s3ssid_t **single_lc ;
   s3senid_t **comstate ;
   s3senid_t **comsseq ;
   int32 *comwt ;
   int32 n_comstate ;
   int32 n_comsseq ;
};
#line 150 "src/dict2pid.h"
typedef struct __anonstruct_dict2pid_t_60 dict2pid_t;
#line 123 "src/feat.h"
struct feat_s {
   char *name ;
   int32 cepsize ;
   int32 cepsize_used ;
   int32 n_stream ;
   int32 *stream_len ;
   int32 window_size ;
   int32 cmn ;
   int32 varnorm ;
   int32 agc ;
   void (*compute_feat)(struct feat_s *fcb , float32 **input , float32 **feat ) ;
};
#line 123 "src/feat.h"
typedef struct feat_s feat_t;
#line 113 "src/fillpen.h"
struct __anonstruct_fillpen_t_61 {
   dict_t *dict ;
   int32 *prob ;
   float64 lw ;
   float64 wip ;
};
#line 113 "src/fillpen.h"
typedef struct __anonstruct_fillpen_t_61 fillpen_t;
#line 122 "src/lm.h"
union __anonunion_lmlog_t_62 {
   float32 f ;
   int32 l ;
};
#line 122 "src/lm.h"
typedef union __anonunion_lmlog_t_62 lmlog_t;
#line 127 "src/lm.h"
struct __anonstruct_ug_t_63 {
   s3wid_t dictwid ;
   lmlog_t prob ;
   lmlog_t bowt ;
   int32 firstbg ;
};
#line 127 "src/lm.h"
typedef struct __anonstruct_ug_t_63 ug_t;
#line 137 "src/lm.h"
struct __anonstruct_bg_t_64 {
   s3lmwid_t wid ;
   uint16 probid ;
   uint16 bowtid ;
   uint16 firsttg ;
};
#line 137 "src/lm.h"
typedef struct __anonstruct_bg_t_64 bg_t;
#line 144 "src/lm.h"
struct __anonstruct_tg_t_65 {
   s3lmwid_t wid ;
   uint16 probid ;
};
#line 144 "src/lm.h"
typedef struct __anonstruct_tg_t_65 tg_t;
#line 153 "src/lm.h"
struct __anonstruct_membg_t_66 {
   bg_t *bg ;
   int32 used ;
};
#line 153 "src/lm.h"
typedef struct __anonstruct_membg_t_66 membg_t;
#line 167 "src/lm.h"
struct tginfo_s {
   s3lmwid_t w1 ;
   int32 n_tg ;
   tg_t *tg ;
   int32 bowt ;
   int32 used ;
   struct tginfo_s *next ;
};
#line 167 "src/lm.h"
typedef struct tginfo_s tginfo_t;
#line 181 "src/lm.h"
struct __anonstruct_lm_tgcache_entry_t_67 {
   s3lmwid_t lwid[3] ;
   int32 lscr ;
};
#line 181 "src/lm.h"
typedef struct __anonstruct_lm_tgcache_entry_t_67 lm_tgcache_entry_t;
#line 212 "src/lm.h"
struct lm_s {
   int32 n_ug ;
   int32 n_bg ;
   int32 n_tg ;
   int32 max_ug ;
   char **wordstr ;
   s3lmwid_t startlwid ;
   s3lmwid_t finishlwid ;
   int32 log_bg_seg_sz ;
   int32 bg_seg_sz ;
   ug_t *ug ;
   bg_t *bg ;
   tg_t *tg ;
   membg_t *membg ;
   tginfo_t **tginfo ;
   lmlog_t *bgprob ;
   lmlog_t *tgprob ;
   lmlog_t *tgbowt ;
   int32 *tg_segbase ;
   int32 n_bgprob ;
   int32 n_tgprob ;
   int32 n_tgbowt ;
   FILE *fp ;
   int32 byteswap ;
   int32 bgoff ;
   int32 tgoff ;
   float32 lw ;
   int32 wip ;
   lm_tgcache_entry_t *tgcache ;
   int32 n_bg_fill ;
   int32 n_bg_inmem ;
   int32 n_bg_score ;
   int32 n_bg_bo ;
   int32 n_tg_fill ;
   int32 n_tg_inmem ;
   int32 n_tg_score ;
   int32 n_tg_bo ;
   int32 n_tgcache_hit ;
   int32 access_type ;
};
#line 212 "src/lm.h"
typedef struct lm_s lm_t;
#line 125 "src/tmat.h"
struct __anonstruct_tmat_t_69 {
   int32 ***tp ;
   int32 n_tmat ;
   int32 n_state ;
};
#line 125 "src/tmat.h"
typedef struct __anonstruct_tmat_t_69 tmat_t;
#line 131 "src/kbcore.h"
struct __anonstruct_kbcore_t_70 {
   feat_t *fcb ;
   mdef_t *mdef ;
   dict_t *dict ;
   dict2pid_t *dict2pid ;
   lm_t *lm ;
   fillpen_t *fillpen ;
   s3lmwid_t *dict2lmwid ;
   mgau_model_t *mgau ;
   subvq_t *svq ;
   tmat_t *tmat ;
};
#line 131 "src/kbcore.h"
typedef struct __anonstruct_kbcore_t_70 kbcore_t;
#line 156 "src/hmm.h"
struct __anonstruct_hmm_state_t_71 {
   int32 score ;
   int32 history ;
};
#line 156 "src/hmm.h"
typedef struct __anonstruct_hmm_state_t_71 hmm_state_t;
#line 161 "src/hmm.h"
struct __anonstruct_hmm_t_72 {
   hmm_state_t *state ;
   hmm_state_t in ;
   hmm_state_t out ;
   int32 **tp ;
   int32 bestscore ;
};
#line 161 "src/hmm.h"
typedef struct __anonstruct_hmm_t_72 hmm_t;
#line 128 "src/vithist.h"
struct __anonstruct_lm3g_75 {
   s3lmwid_t lwid[2] ;
};
#line 128 "src/vithist.h"
union __anonunion_vh_lmstate_t_74 {
   struct __anonstruct_lm3g_75 lm3g ;
};
#line 128 "src/vithist.h"
typedef union __anonunion_vh_lmstate_t_74 vh_lmstate_t;
#line 138 "src/vithist.h"
struct __anonstruct_vithist_entry_t_76 {
   s3wid_t wid ;
   s3frmid_t sf ;
   s3frmid_t ef ;
   int32 ascr ;
   int32 lscr ;
   int32 score ;
   int32 pred ;
   int32 type ;
   int32 valid ;
   vh_lmstate_t lmstate ;
};
#line 138 "src/vithist.h"
typedef struct __anonstruct_vithist_entry_t_76 vithist_entry_t;
#line 170 "src/vithist.h"
struct __anonstruct_vh_lms2vh_t_77 {
   int32 state ;
   int32 vhid ;
   vithist_entry_t *ve ;
   glist_t children ;
};
#line 170 "src/vithist.h"
typedef struct __anonstruct_vh_lms2vh_t_77 vh_lms2vh_t;
#line 185 "src/vithist.h"
struct __anonstruct_vithist_t_78 {
   vithist_entry_t **entry ;
   int32 *frame_start ;
   int32 n_entry ;
   int32 n_frm ;
   int32 bghist ;
   int32 wbeam ;
   int32 *bestscore ;
   int32 *bestvh ;
   vh_lms2vh_t **lms2vh_root ;
   glist_t lwidlist ;
};
#line 185 "src/vithist.h"
typedef struct __anonstruct_vithist_t_78 vithist_t;
#line 115 "src/ascr.h"
struct __anonstruct_ascr_t_79 {
   int32 *sen ;
   int32 *comsen ;
};
#line 115 "src/ascr.h"
typedef struct __anonstruct_ascr_t_79 ascr_t;
#line 145 "src/lextree.h"
struct __anonstruct_lextree_node_t_80 {
   hmm_t hmm ;
   glist_t children ;
   int32 wid ;
   int32 prob ;
   int32 ssid ;
   s3ssid_t *ssid_lc ;
   s3cipid_t ci ;
   int8 composite ;
   s3frmid_t frame ;
   int8 synch ;
};
#line 145 "src/lextree.h"
typedef struct __anonstruct_lextree_node_t_80 lextree_node_t;
#line 170 "src/lextree.h"
struct __anonstruct_lextree_lcroot_t_81 {
   s3cipid_t lc ;
   glist_t root ;
};
#line 170 "src/lextree.h"
typedef struct __anonstruct_lextree_lcroot_t_81 lextree_lcroot_t;
#line 179 "src/lextree.h"
struct __anonstruct_lextree_t_82 {
   int32 type ;
   glist_t root ;
   lextree_lcroot_t *lcroot ;
   int32 n_lc ;
   int32 n_node ;
   lextree_node_t **active ;
   lextree_node_t **next_active ;
   int32 n_active ;
   int32 n_next_active ;
   int32 best ;
   int32 wbest ;
};
#line 179 "src/lextree.h"
typedef struct __anonstruct_lextree_t_82 lextree_t;
#line 115 "src/beam.h"
struct __anonstruct_beam_t_83 {
   int32 subvq ;
   int32 hmm ;
   int32 ptrans ;
   int32 word ;
};
#line 115 "src/beam.h"
typedef struct __anonstruct_beam_t_83 beam_t;
#line 125 "src/kb.h"
struct __anonstruct_kb_t_84 {
   kbcore_t *kbcore ;
   int32 n_lextree ;
   lextree_t **ugtree ;
   lextree_t **fillertree ;
   int32 n_lextrans ;
   vithist_t *vithist ;
   float32 ***feat ;
   int32 nfr ;
   int32 *ssid_active ;
   int32 *comssid_active ;
   int32 *sen_active ;
   int32 bestscore ;
   int32 bestwordscore ;
   ascr_t *ascr ;
   beam_t *beam ;
   char *uttid ;
   int32 utt_hmm_eval ;
   int32 utt_sen_eval ;
   int32 utt_gau_eval ;
   int32 *hmm_hist ;
   int32 hmm_hist_bins ;
   int32 hmm_hist_binsize ;
   ptmr_t tm_sen ;
   ptmr_t tm_srch ;
   int32 tot_fr ;
   float64 tot_sen_eval ;
   float64 tot_gau_eval ;
   float64 tot_hmm_eval ;
   float64 tot_wd_exit ;
   FILE *matchsegfp ;
};
#line 125 "src/kb.h"
typedef struct __anonstruct_kb_t_84 kb_t;
#line 60 "src/threading.h"
struct __anonstruct_sen_active_args_t_85 {
   kb_t *kb ;
   mdef_t *mdef ;
   dict2pid_t *d2p ;
};
#line 60 "src/threading.h"
typedef struct __anonstruct_sen_active_args_t_85 sen_active_args_t;
#line 66 "src/threading.h"
struct __anonstruct_scoring_args_t_86 {
   subvq_t *vq ;
   mgau_model_t *g ;
   int32 beam ;
   float32 *feat ;
   int32 *sen_active ;
   int32 *senscr ;
   dict2pid_t *d2p ;
   int32 *comsenscr ;
};
#line 66 "src/threading.h"
typedef struct __anonstruct_scoring_args_t_86 scoring_args_t;
#line 78 "src/threading.h"
struct __anonstruct_searching_args_t_87 {
   kb_t *kb ;
   lextree_t *lextree ;
   kbcore_t *kbc ;
   ascr_t *ascr ;
   int32 frm ;
   FILE *fp ;
   int32 ptranskip ;
   vithist_t *vithist ;
   int32 th ;
   int32 pth ;
   int32 wth ;
};
#line 78 "src/threading.h"
typedef struct __anonstruct_searching_args_t_87 searching_args_t;
#line 92 "src/threading.h"
struct __anonstruct_thread_args_t_88 {
   int id ;
   int32 feval_start ;
   int32 feval_end ;
   int32 com_start ;
   int32 com_end ;
   int32 hmmeval_start ;
   int32 hmmeval_end ;
   int32 hmmppg_start ;
   int32 hmmppg_end ;
   int32 best ;
   int32 wbest ;
   int32 lextree_num ;
   lextree_t *lextree ;
   sen_active_args_t *sa_args ;
   scoring_args_t *score_args ;
   searching_args_t *search_args ;
};
#line 92 "src/threading.h"
typedef struct __anonstruct_thread_args_t_88 thread_args_t;
#line 153 "/usr/include/x86_64-linux-gnu/bits/mathinline.h"
union __anonunion___u_29___5 {
   long double __l ;
   int __i[3] ;
};
#line 153 "/usr/include/x86_64-linux-gnu/bits/mathinline.h"
union __anonunion___u_29___6 {
   long double __l ;
   int __i[3] ;
};
#line 153 "/usr/include/x86_64-linux-gnu/bits/mathinline.h"
union __anonunion___u_29___7 {
   long double __l ;
   int __i[3] ;
};
#line 153 "/usr/include/x86_64-linux-gnu/bits/mathinline.h"
union __anonunion___u_29___8 {
   long double __l ;
   int __i[3] ;
};
#line 153 "/usr/include/x86_64-linux-gnu/bits/mathinline.h"
union __anonunion___u_29___9 {
   long double __l ;
   int __i[3] ;
};
#line 282 "src/lm.h"
struct __anonstruct_wordprob_t_40 {
   s3wid_t wid ;
   int32 prob ;
};
#line 282 "src/lm.h"
typedef struct __anonstruct_wordprob_t_40 wordprob_t;
#line 153 "/usr/include/x86_64-linux-gnu/bits/mathinline.h"
union __anonunion___u_29___10 {
   long double __l ;
   int __i[3] ;
};
#line 153 "/usr/include/x86_64-linux-gnu/bits/mathinline.h"
union __anonunion___u_29___11 {
   long double __l ;
   int __i[3] ;
};
#line 153 "/usr/include/x86_64-linux-gnu/bits/mathinline.h"
union __anonunion___u_29___12 {
   long double __l ;
   int __i[3] ;
};
#line 153 "/usr/include/x86_64-linux-gnu/bits/mathinline.h"
union __anonunion___u_29___13 {
   long double __l ;
   int __i[3] ;
};
#line 153 "/usr/include/x86_64-linux-gnu/bits/mathinline.h"
union __anonunion___u_29___14 {
   long double __l ;
   int __i[3] ;
};
#line 153 "/usr/include/x86_64-linux-gnu/bits/mathinline.h"
union __anonunion___u_29___15 {
   long double __l ;
   int __i[3] ;
};
#line 111 "src/hyp.h"
struct __anonstruct_hyp_t_58 {
   int32 id ;
   int32 vhid ;
   int32 sf ;
   int32 ef ;
   int32 ascr ;
   int32 lscr ;
   int32 type ;
};
#line 111 "src/hyp.h"
typedef struct __anonstruct_hyp_t_58 hyp_t;
#line 811 "src/vithist.c"
struct __anonstruct_dagnode_t_77 {
   s3wid_t wid ;
   int32 fef ;
   int32 lef ;
   int32 seqid ;
   glist_t velist ;
};
#line 811 "src/vithist.c"
typedef struct __anonstruct_dagnode_t_77 dagnode_t;
#line 153 "/usr/include/x86_64-linux-gnu/bits/mathinline.h"
union __anonunion___u_29___16 {
   long double __l ;
   int __i[3] ;
};
#line 153 "/usr/include/x86_64-linux-gnu/bits/mathinline.h"
union __anonunion___u_29___17 {
   long double __l ;
   int __i[3] ;
};
#line 153 "/usr/include/x86_64-linux-gnu/bits/mathinline.h"
union __anonunion___u_29___18 {
   long double __l ;
   int __i[3] ;
};
#line 153 "/usr/include/x86_64-linux-gnu/bits/mathinline.h"
union __anonunion___u_29___19 {
   long double __l ;
   int __i[3] ;
};
#line 132 "src/corpus.h"
struct __anonstruct_corpus_t_34 {
   hash_table_t *ht ;
   int32 n ;
   char **str ;
};
#line 132 "src/corpus.h"
typedef struct __anonstruct_corpus_t_34 corpus_t;
#line 153 "/usr/include/x86_64-linux-gnu/bits/mathinline.h"
union __anonunion___u_29___20 {
   long double __l ;
   int __i[3] ;
};
#line 153 "/usr/include/x86_64-linux-gnu/bits/mathinline.h"
union __anonunion___u_8 {
   long double __l ;
   int __i[3] ;
};
#line 92 "src/new_fe.h"
struct __anonstruct_param_t_34 {
   float SAMPLING_RATE ;
   int32 FRAME_RATE ;
   float WINDOW_LENGTH ;
   int32 FB_TYPE ;
   int32 NUM_CEPSTRA ;
   int32 NUM_FILTERS ;
   int32 FFT_SIZE ;
   float LOWER_FILT_FREQ ;
   float UPPER_FILT_FREQ ;
   float PRE_EMPHASIS_ALPHA ;
   char *wavfile ;
   char *cepfile ;
   char *ctlfile ;
   char *wavdir ;
   char *cepdir ;
   char *wavext ;
   char *cepext ;
   int32 input_format ;
   int32 is_batch ;
   int32 is_single ;
   int32 blocksize ;
   int32 verbose ;
};
#line 92 "src/new_fe.h"
typedef struct __anonstruct_param_t_34 param_t;
#line 121 "src/new_fe.h"
struct __anonstruct_melfb_t_35 {
   float sampling_rate ;
   int32 num_cepstra ;
   int32 num_filters ;
   int32 fft_size ;
   float lower_filt_freq ;
   float upper_filt_freq ;
   float **filter_coeffs ;
   float **mel_cosine ;
   float *left_apex ;
   int32 *width ;
};
#line 121 "src/new_fe.h"
typedef struct __anonstruct_melfb_t_35 melfb_t;
#line 135 "src/new_fe.h"
struct __anonstruct_fe_t_36 {
   float SAMPLING_RATE ;
   int32 FRAME_RATE ;
   int32 FRAME_SHIFT ;
   float WINDOW_LENGTH ;
   int32 FRAME_SIZE ;
   int32 FFT_SIZE ;
   int32 FB_TYPE ;
   int32 NUM_CEPSTRA ;
   float PRE_EMPHASIS_ALPHA ;
   int16 *OVERFLOW_SAMPS ;
   int32 NUM_OVERFLOW_SAMPS ;
   melfb_t *MEL_FB ;
   int32 START_FLAG ;
   int16 PRIOR ;
   double *HAMMING_WINDOW ;
};
#line 135 "src/new_fe.h"
typedef struct __anonstruct_fe_t_36 fe_t;
#line 96 "src/new_fe_sp.h"
struct __anonstruct_complex_37 {
   double r ;
   double i ;
};
#line 96 "src/new_fe_sp.h"
typedef struct __anonstruct_complex_37 complex;
#line 153 "/usr/include/x86_64-linux-gnu/bits/mathinline.h"
union __anonunion___u_8___0 {
   long double __l ;
   int __i[3] ;
};
#line 153 "/usr/include/x86_64-linux-gnu/bits/mathinline.h"
union __anonunion___u_29___21 {
   long double __l ;
   int __i[3] ;
};
#line 153 "/usr/include/x86_64-linux-gnu/bits/mathinline.h"
union __anonunion___u_29___22 {
   long double __l ;
   int __i[3] ;
};
#line 153 "/usr/include/x86_64-linux-gnu/bits/mathinline.h"
union __anonunion___u_29___23 {
   long double __l ;
   int __i[3] ;
};
#line 28 "/usr/include/x86_64-linux-gnu/bits/sigset.h"
struct __anonstruct___sigset_t_12 {
   unsigned long __val[1024UL / (8UL * sizeof(unsigned long ))] ;
};
#line 28 "/usr/include/x86_64-linux-gnu/bits/sigset.h"
typedef struct __anonstruct___sigset_t_12 __sigset_t;
#line 153 "/usr/include/x86_64-linux-gnu/bits/mathinline.h"
union __anonunion___u_29___24 {
   long double __l ;
   int __i[3] ;
};
#line 153 "/usr/include/x86_64-linux-gnu/bits/mathinline.h"
union __anonunion___u_29___25 {
   long double __l ;
   int __i[3] ;
};
#line 97 "src/live.h"
struct __anonstruct_partialhyp_t_88 {
   int32 ascr ;
   int32 lscr ;
   char *word ;
   int32 sf ;
   int32 ef ;
};
#line 97 "src/live.h"
typedef struct __anonstruct_partialhyp_t_88 partialhyp_t;
#line 153 "/usr/include/x86_64-linux-gnu/bits/mathinline.h"
union __anonunion___u_29___26 {
   long double __l ;
   int __i[3] ;
};
/* compiler builtin: 
   unsigned long __builtin_object_size(void * , int  ) ;  */
#line 1 "barrier.o"
#pragma merger("0","/tmp/cil-zFcfST7S.i","-g,-O4")
#line 144 "/usr/include/stdlib.h"
__inline extern  __attribute__((__nothrow__)) double ( __attribute__((__warn_unused_result__,
__nonnull__(1), __leaf__)) atof)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 147
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__warn_unused_result__,
__nonnull__(1), __leaf__)) atoi)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 150
__inline extern  __attribute__((__nothrow__)) long ( __attribute__((__warn_unused_result__,
__nonnull__(1), __leaf__)) atol)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 157
__inline extern  __attribute__((__nothrow__)) long long ( __attribute__((__warn_unused_result__,
__nonnull__(1), __leaf__)) atoll)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 164
extern  __attribute__((__nothrow__)) double ( __attribute__((__nonnull__(1), __leaf__)) strtod)(char const   * __restrict  __nptr ,
                                                                                                char ** __restrict  __endptr ) ;
#line 183
extern  __attribute__((__nothrow__)) long ( __attribute__((__nonnull__(1), __leaf__)) strtol)(char const   * __restrict  __nptr ,
                                                                                              char ** __restrict  __endptr ,
                                                                                              int __base ) ;
#line 209
extern  __attribute__((__nothrow__)) long long ( __attribute__((__nonnull__(1), __leaf__)) strtoll)(char const   * __restrict  __nptr ,
                                                                                                    char ** __restrict  __endptr ,
                                                                                                    int __base ) ;
#line 277
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__warn_unused_result__,
__nonnull__(1), __leaf__)) atoi)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 277 "/usr/include/stdlib.h"
__inline extern int ( __attribute__((__warn_unused_result__, __nonnull__(1), __leaf__)) atoi)(char const   *__nptr ) 
{ 
  long tmp ;

  {
#line 280
  tmp = strtol((char const   * __restrict  )__nptr, (char ** __restrict  )((char **)((void *)0)),
               10);
#line 280
  return ((int )tmp);
}
}
#line 282
__inline extern  __attribute__((__nothrow__)) long ( __attribute__((__warn_unused_result__,
__nonnull__(1), __leaf__)) atol)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 282 "/usr/include/stdlib.h"
__inline extern long ( __attribute__((__warn_unused_result__, __nonnull__(1), __leaf__)) atol)(char const   *__nptr ) 
{ 
  long tmp ;

  {
#line 285
  tmp = strtol((char const   * __restrict  )__nptr, (char ** __restrict  )((char **)((void *)0)),
               10);
#line 285
  return (tmp);
}
}
#line 291
__inline extern  __attribute__((__nothrow__)) long long ( __attribute__((__warn_unused_result__,
__nonnull__(1), __leaf__)) atoll)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 291 "/usr/include/stdlib.h"
__inline extern long long ( __attribute__((__warn_unused_result__, __nonnull__(1),
__leaf__)) atoll)(char const   *__nptr ) 
{ 
  long long tmp ;

  {
#line 294
  tmp = strtoll((char const   * __restrict  )__nptr, (char ** __restrict  )((char **)((void *)0)),
                10);
#line 294
  return (tmp);
}
}
#line 32 "/usr/include/x86_64-linux-gnu/sys/sysmacros.h"
__inline extern  __attribute__((__nothrow__)) unsigned int ( __attribute__((__leaf__)) gnu_dev_major)(unsigned long long __dev )  __attribute__((__const__)) ;
#line 35
__inline extern  __attribute__((__nothrow__)) unsigned int ( __attribute__((__leaf__)) gnu_dev_minor)(unsigned long long __dev )  __attribute__((__const__)) ;
#line 38
__inline extern  __attribute__((__nothrow__)) unsigned long long ( __attribute__((__leaf__)) gnu_dev_makedev)(unsigned int __major ,
                                                                                                              unsigned int __minor )  __attribute__((__const__)) ;
#line 43
__inline extern  __attribute__((__nothrow__)) unsigned int ( __attribute__((__leaf__)) gnu_dev_major)(unsigned long long __dev )  __attribute__((__const__)) ;
#line 43 "/usr/include/x86_64-linux-gnu/sys/sysmacros.h"
__inline extern unsigned int ( __attribute__((__leaf__)) gnu_dev_major)(unsigned long long __dev ) 
{ 


  {
#line 46
  return ((unsigned int )(((__dev >> 8) & 4095ULL) | (unsigned long long )((unsigned int )(__dev >> 32) & 4294963200U)));
}
}
#line 49
__inline extern  __attribute__((__nothrow__)) unsigned int ( __attribute__((__leaf__)) gnu_dev_minor)(unsigned long long __dev )  __attribute__((__const__)) ;
#line 49 "/usr/include/x86_64-linux-gnu/sys/sysmacros.h"
__inline extern unsigned int ( __attribute__((__leaf__)) gnu_dev_minor)(unsigned long long __dev ) 
{ 


  {
#line 52
  return ((unsigned int )((__dev & 255ULL) | (unsigned long long )((unsigned int )(__dev >> 12) & 4294967040U)));
}
}
#line 55
__inline extern  __attribute__((__nothrow__)) unsigned long long ( __attribute__((__leaf__)) gnu_dev_makedev)(unsigned int __major ,
                                                                                                              unsigned int __minor )  __attribute__((__const__)) ;
#line 55 "/usr/include/x86_64-linux-gnu/sys/sysmacros.h"
__inline extern unsigned long long ( __attribute__((__leaf__)) gnu_dev_makedev)(unsigned int __major ,
                                                                                unsigned int __minor ) 
{ 


  {
#line 58
  return (((unsigned long long )((__minor & 255U) | ((__major & 4095U) << 8)) | ((unsigned long long )(__minor & 4294967040U) << 12)) | ((unsigned long long )(__major & 4294963200U) << 32));
}
}
#line 465 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__warn_unused_result__,
__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 482
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 733
__inline extern  __attribute__((__nothrow__)) char *( __attribute__((__warn_unused_result__,
__leaf__, __artificial__, __always_inline__)) realpath)(char const   * __restrict  __name ,
                                                        char * __restrict  __resolved ) ;
#line 866
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__warn_unused_result__,
__leaf__, __artificial__, __always_inline__)) wctomb)(char *__s , wchar_t __wchar ) ;
#line 870
__inline extern  __attribute__((__nothrow__)) size_t ( __attribute__((__leaf__, __artificial__,
__always_inline__)) mbstowcs)(wchar_t * __restrict  __dst , char const   * __restrict  __src ,
                              size_t __len ) ;
#line 873
__inline extern  __attribute__((__nothrow__)) size_t ( __attribute__((__leaf__, __artificial__,
__always_inline__)) wcstombs)(char * __restrict  __dst , wchar_t const   * __restrict  __src ,
                              size_t __len ) ;
#line 25 "/usr/include/x86_64-linux-gnu/bits/stdlib-float.h"
__inline extern  __attribute__((__nothrow__)) double ( __attribute__((__warn_unused_result__,
__nonnull__(1), __leaf__)) atof)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 25 "/usr/include/x86_64-linux-gnu/bits/stdlib-float.h"
__inline extern double ( __attribute__((__warn_unused_result__, __nonnull__(1), __leaf__)) atof)(char const   *__nptr ) 
{ 
  double tmp ;

  {
#line 28
  tmp = strtod((char const   * __restrict  )__nptr, (char ** __restrict  )((char **)((void *)0)));
#line 28
  return (tmp);
}
}
#line 23 "/usr/include/x86_64-linux-gnu/bits/stdlib.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__warn_unused_result__,
__leaf__)) __realpath_chk)(char const   * __restrict  __name , char * __restrict  __resolved ,
                           size_t __resolvedlen ) ;
#line 26
extern  __attribute__((__nothrow__)) char *( __attribute__((__warn_unused_result__,
__leaf__)) __realpath_alias)(char const   * __restrict  __name , char * __restrict  __resolved )  __asm__("realpath")  ;
#line 36
__inline extern  __attribute__((__nothrow__)) char *( __attribute__((__warn_unused_result__,
__leaf__, __artificial__, __always_inline__)) realpath)(char const   * __restrict  __name ,
                                                        char * __restrict  __resolved ) ;
#line 36 "/usr/include/x86_64-linux-gnu/bits/stdlib.h"
__inline extern char *( __attribute__((__warn_unused_result__, __leaf__, __artificial__,
__always_inline__)) realpath)(char const   * __restrict  __name , char * __restrict  __resolved ) 
{ 
  unsigned long tmp ;
  char *tmp___0 ;
  unsigned long tmp___1 ;
  char *tmp___2 ;

  {
#line 39
  tmp___1 = __builtin_object_size((void *)__resolved, 1);
#line 39
  if (tmp___1 != 0xffffffffffffffffUL) {
#line 45
    tmp = __builtin_object_size((void *)__resolved, 1);
#line 45
    tmp___0 = __realpath_chk(__name, __resolved, tmp);
#line 45
    return (tmp___0);
  }
#line 48
  tmp___2 = __realpath_alias(__name, __resolved);
#line 48
  return (tmp___2);
}
}
#line 52
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2), __leaf__)) __ptsname_r_chk)(int __fd ,
                                                                                                      char *__buf ,
                                                                                                      size_t __buflen ,
                                                                                                      size_t __nreal ) ;
#line 54
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2), __leaf__)) __ptsname_r_alias)(int __fd ,
                                                                                                        char *__buf ,
                                                                                                        size_t __buflen )  __asm__("ptsname_r")  ;
#line 57
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2), __leaf__)) __ptsname_r_chk_warn)(int __fd ,
                                                                                                           char *__buf ,
                                                                                                           size_t __buflen ,
                                                                                                           size_t __nreal )  __asm__("__ptsname_r_chk") __attribute__((__warning__("ptsname_r called with buflen bigger than size of buf"))) ;
#line 63
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__, __artificial__,
__always_inline__)) ptsname_r)(int __fd , char *__buf , size_t __buflen ) ;
#line 63 "/usr/include/x86_64-linux-gnu/bits/stdlib.h"
__inline extern int ( __attribute__((__leaf__, __artificial__, __always_inline__)) ptsname_r)(int __fd ,
                                                                                              char *__buf ,
                                                                                              size_t __buflen ) 
{ 
  unsigned long tmp ;
  int tmp___0 ;
  unsigned long tmp___1 ;
  int tmp___2 ;
  unsigned long tmp___3 ;
  unsigned long tmp___4 ;
  int tmp___5 ;

  {
#line 66
  tmp___4 = __builtin_object_size((void *)__buf, 1);
#line 66
  if (tmp___4 != 0xffffffffffffffffUL) {
#line 69
    tmp = __builtin_object_size((void *)__buf, 1);
#line 69
    tmp___0 = __ptsname_r_chk(__fd, __buf, __buflen, tmp);
#line 69
    return (tmp___0);
#line 70
    tmp___3 = __builtin_object_size((void *)__buf, 1);
#line 70
    if (__buflen > tmp___3) {
#line 71
      tmp___1 = __builtin_object_size((void *)__buf, 1);
#line 71
      tmp___2 = __ptsname_r_chk_warn(__fd, __buf, __buflen, tmp___1);
#line 71
      return (tmp___2);
    }
  }
#line 73
  tmp___5 = __ptsname_r_alias(__fd, __buf, __buflen);
#line 73
  return (tmp___5);
}
}
#line 77
extern  __attribute__((__nothrow__)) int ( __attribute__((__warn_unused_result__,
__leaf__)) __wctomb_chk)(char *__s , wchar_t __wchar , size_t __buflen ) ;
#line 79
extern  __attribute__((__nothrow__)) int ( __attribute__((__warn_unused_result__,
__leaf__)) __wctomb_alias)(char *__s , wchar_t __wchar )  __asm__("wctomb")  ;
#line 82
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__warn_unused_result__,
__leaf__, __artificial__, __always_inline__)) wctomb)(char *__s , wchar_t __wchar ) ;
#line 82 "/usr/include/x86_64-linux-gnu/bits/stdlib.h"
__inline extern int ( __attribute__((__warn_unused_result__, __leaf__, __artificial__,
__always_inline__)) wctomb)(char *__s , wchar_t __wchar ) 
{ 
  unsigned long tmp ;
  int tmp___0 ;
  unsigned long tmp___1 ;
  unsigned long tmp___2 ;
  int tmp___3 ;

  {
#line 92
  tmp___1 = __builtin_object_size((void *)__s, 1);
#line 92
  if (tmp___1 != 0xffffffffffffffffUL) {
#line 92
    tmp___2 = __builtin_object_size((void *)__s, 1);
#line 92
    if (16UL > tmp___2) {
#line 93
      tmp = __builtin_object_size((void *)__s, 1);
#line 93
      tmp___0 = __wctomb_chk(__s, __wchar, tmp);
#line 93
      return (tmp___0);
    }
  }
#line 94
  tmp___3 = __wctomb_alias(__s, __wchar);
#line 94
  return (tmp___3);
}
}
#line 98
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__leaf__)) __mbstowcs_chk)(wchar_t * __restrict  __dst ,
                                                                                        char const   * __restrict  __src ,
                                                                                        size_t __len ,
                                                                                        size_t __dstlen ) ;
#line 101
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__leaf__)) __mbstowcs_alias)(wchar_t * __restrict  __dst ,
                                                                                          char const   * __restrict  __src ,
                                                                                          size_t __len )  __asm__("mbstowcs")  ;
#line 105
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__leaf__)) __mbstowcs_chk_warn)(wchar_t * __restrict  __dst ,
                                                                                             char const   * __restrict  __src ,
                                                                                             size_t __len ,
                                                                                             size_t __dstlen )  __asm__("__mbstowcs_chk") __attribute__((__warning__("mbstowcs called with dst buffer smaller than len * sizeof (wchar_t)"))) ;
#line 112
__inline extern  __attribute__((__nothrow__)) size_t ( __attribute__((__leaf__, __artificial__,
__always_inline__)) mbstowcs)(wchar_t * __restrict  __dst , char const   * __restrict  __src ,
                              size_t __len ) ;
#line 112 "/usr/include/x86_64-linux-gnu/bits/stdlib.h"
__inline extern size_t ( __attribute__((__leaf__, __artificial__, __always_inline__)) mbstowcs)(wchar_t * __restrict  __dst ,
                                                                                                char const   * __restrict  __src ,
                                                                                                size_t __len ) 
{ 
  unsigned long tmp ;
  size_t tmp___0 ;
  unsigned long tmp___1 ;
  size_t tmp___2 ;
  unsigned long tmp___3 ;
  unsigned long tmp___4 ;
  size_t tmp___5 ;

  {
#line 116
  tmp___4 = __builtin_object_size((void *)__dst, 1);
#line 116
  if (tmp___4 != 0xffffffffffffffffUL) {
#line 119
    tmp = __builtin_object_size((void *)__dst, 1);
#line 119
    tmp___0 = __mbstowcs_chk(__dst, __src, __len, tmp / sizeof(wchar_t ));
#line 119
    return (tmp___0);
#line 122
    tmp___3 = __builtin_object_size((void *)__dst, 1);
#line 122
    if (__len > tmp___3 / sizeof(wchar_t )) {
#line 123
      tmp___1 = __builtin_object_size((void *)__dst, 1);
#line 123
      tmp___2 = __mbstowcs_chk_warn(__dst, __src, __len, tmp___1 / sizeof(wchar_t ));
#line 123
      return (tmp___2);
    }
  }
#line 126
  tmp___5 = __mbstowcs_alias(__dst, __src, __len);
#line 126
  return (tmp___5);
}
}
#line 130
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__leaf__)) __wcstombs_chk)(char * __restrict  __dst ,
                                                                                        wchar_t const   * __restrict  __src ,
                                                                                        size_t __len ,
                                                                                        size_t __dstlen ) ;
#line 133
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__leaf__)) __wcstombs_alias)(char * __restrict  __dst ,
                                                                                          wchar_t const   * __restrict  __src ,
                                                                                          size_t __len )  __asm__("wcstombs")  ;
#line 137
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__leaf__)) __wcstombs_chk_warn)(char * __restrict  __dst ,
                                                                                             wchar_t const   * __restrict  __src ,
                                                                                             size_t __len ,
                                                                                             size_t __dstlen )  __asm__("__wcstombs_chk") __attribute__((__warning__("wcstombs called with dst buffer smaller than len"))) ;
#line 143
__inline extern  __attribute__((__nothrow__)) size_t ( __attribute__((__leaf__, __artificial__,
__always_inline__)) wcstombs)(char * __restrict  __dst , wchar_t const   * __restrict  __src ,
                              size_t __len ) ;
#line 143 "/usr/include/x86_64-linux-gnu/bits/stdlib.h"
__inline extern size_t ( __attribute__((__leaf__, __artificial__, __always_inline__)) wcstombs)(char * __restrict  __dst ,
                                                                                                wchar_t const   * __restrict  __src ,
                                                                                                size_t __len ) 
{ 
  unsigned long tmp ;
  size_t tmp___0 ;
  unsigned long tmp___1 ;
  size_t tmp___2 ;
  unsigned long tmp___3 ;
  unsigned long tmp___4 ;
  size_t tmp___5 ;

  {
#line 147
  tmp___4 = __builtin_object_size((void *)__dst, 1);
#line 147
  if (tmp___4 != 0xffffffffffffffffUL) {
#line 150
    tmp = __builtin_object_size((void *)__dst, 1);
#line 150
    tmp___0 = __wcstombs_chk(__dst, __src, __len, tmp);
#line 150
    return (tmp___0);
#line 151
    tmp___3 = __builtin_object_size((void *)__dst, 1);
#line 151
    if (__len > tmp___3) {
#line 152
      tmp___1 = __builtin_object_size((void *)__dst, 1);
#line 152
      tmp___2 = __wcstombs_chk_warn(__dst, __src, __len, tmp___1);
#line 152
      return (tmp___2);
    }
  }
#line 154
  tmp___5 = __wcstombs_alias(__dst, __src, __len);
#line 154
  return (tmp___5);
}
}
#line 277 "/usr/include/pthread.h"
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) pthread_equal)(pthread_t __thread1 ,
                                                                                             pthread_t __thread2 )  __attribute__((__const__)) ;
#line 740
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) pthread_mutex_init)(pthread_mutex_t *__mutex ,
                                                                                                         pthread_mutexattr_t const   *__mutexattr ) ;
#line 745
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) pthread_mutex_destroy)(pthread_mutex_t *__mutex ) ;
#line 959
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) pthread_cond_init)(pthread_cond_t * __restrict  __cond ,
                                                                                                        pthread_condattr_t const   * __restrict  __cond_attr ) ;
#line 964
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) pthread_cond_destroy)(pthread_cond_t *__cond ) ;
#line 1143
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) pthread_equal)(pthread_t __thread1 ,
                                                                                             pthread_t __thread2 )  __attribute__((__const__)) ;
#line 1143 "/usr/include/pthread.h"
__inline extern int ( __attribute__((__leaf__)) pthread_equal)(pthread_t __thread1 ,
                                                               pthread_t __thread2 ) 
{ 


  {
#line 1146
  return (__thread1 == __thread2);
}
}
#line 64 "src/barrier.h"
barrier_t *thread_barrier_init(int n_clients ) ;
#line 65
void thread_barrier_destroy(barrier_t *barrier ) ;
#line 66
void thread_barrier(int t , barrier_t *barrier ) ;
#line 55 "src/barrier.c"
barrier_t *thread_barrier_init(int n_clients ) 
{ 
  barrier_t *barrier ;
  void *tmp ;

  {
#line 56
  tmp = malloc(sizeof(barrier_t ));
#line 56
  barrier = (barrier_t *)tmp;
#line 58
  if ((unsigned long )barrier != (unsigned long )((void *)0)) {
#line 59
    barrier->n_clients = n_clients;
#line 60
    barrier->n_waiting = 0;
#line 61
    barrier->phase = 0;
#line 62
    pthread_mutex_init(& barrier->lock, (pthread_mutexattr_t const   *)((void *)0));
#line 63
    pthread_cond_init((pthread_cond_t * __restrict  )(& barrier->wait_cv), (pthread_condattr_t const   * __restrict  )((void *)0));
  }
#line 66
  return (barrier);
}
}
#line 69 "src/barrier.c"
void thread_barrier_destroy(barrier_t *barrier ) 
{ 


  {
#line 70
  pthread_mutex_destroy(& barrier->lock);
#line 71
  pthread_cond_destroy(& barrier->wait_cv);
#line 72
  free((void *)barrier);
#line 73
  return;
}
}
#line 75 "src/barrier.c"
void thread_barrier(int t , barrier_t *barrier ) 
{ 


  {
#line 97
  return;
}
}
#line 1 "bitvec.o"
#pragma merger("0","/tmp/cil-JiVg35jD.i","-g,-O4")
#line 145 "src/bitvec.h"
int32 bitvec_count_set(bitvec_t vec , int32 len ) ;
#line 107 "src/bitvec.c"
int32 bitvec_count_set(bitvec_t vec , int32 len ) 
{ 
  int32 n ;
  int32 i ;

  {
#line 111
  i = 0;
#line 111
  n = 0;
#line 111
  while (i < len) {
#line 112
    if (*(vec + (i >> 5)) & (unsigned int )(1 << (i & 31))) {
#line 113
      n ++;
    }
#line 111
    i ++;
  }
#line 115
  return (n);
}
}
#line 1 "case.o"
#pragma merger("0","/tmp/cil-aWgA1LUv.i","-g,-O4")
#line 122 "src/case.h"
void ucase(char *cp ) ;
#line 125
void lcase(char *cp ) ;
#line 131
int32 strcmp_nocase(char const   *str1 , char const   *str2 ) ;
#line 110 "src/case.c"
void lcase(char *cp ) 
{ 


  {
#line 112
  while (*cp) {
#line 113
    if ((int )*cp >= 65) {
#line 113
      if ((int )*cp <= 90) {
#line 113
        *cp = (char )((int )*cp + 32);
      } else {
#line 113
        *cp = *cp;
      }
    } else {
#line 113
      *cp = *cp;
    }
#line 112
    cp ++;
  }
#line 114
  return;
}
}
#line 117 "src/case.c"
void ucase(char *cp ) 
{ 


  {
#line 119
  while (*cp) {
#line 120
    if ((int )*cp >= 97) {
#line 120
      if ((int )*cp <= 122) {
#line 120
        *cp = (char )((int )*cp - 32);
      } else {
#line 120
        *cp = *cp;
      }
    } else {
#line 120
      *cp = *cp;
    }
#line 119
    cp ++;
  }
#line 121
  return;
}
}
#line 124 "src/case.c"
int32 strcmp_nocase(char const   *str1 , char const   *str2 ) 
{ 
  char c1 ;
  char c2 ;
  char const   *tmp ;
  char const   *tmp___0 ;

  {
#line 128
  while (1) {
#line 129
    tmp = str1;
#line 129
    str1 ++;
#line 129
    c1 = (char )*tmp;
#line 130
    if ((int )c1 >= 97) {
#line 130
      if ((int )c1 <= 122) {
#line 130
        c1 = (char )((int )c1 - 32);
      } else {
#line 130
        c1 = c1;
      }
    } else {
#line 130
      c1 = c1;
    }
#line 131
    tmp___0 = str2;
#line 131
    str2 ++;
#line 131
    c2 = (char )*tmp___0;
#line 132
    if ((int )c2 >= 97) {
#line 132
      if ((int )c2 <= 122) {
#line 132
        c2 = (char )((int )c2 - 32);
      } else {
#line 132
        c2 = c2;
      }
    } else {
#line 132
      c2 = c2;
    }
#line 133
    if ((int )c1 != (int )c2) {
#line 134
      return ((int )c1 - (int )c2);
    }
#line 135
    if ((int )c1 == 0) {
#line 136
      return (0);
    }
  }
}
}
/* compiler builtin: 
   void *__builtin___memmove_chk(void * , void const   * , unsigned long  , unsigned long  ) ;  */
/* compiler builtin: 
   char *__builtin_strchr(char * , int  ) ;  */
/* compiler builtin: 
   void *__builtin___memcpy_chk(void * , void const   * , unsigned long  , unsigned long  ) ;  */
/* compiler builtin: 
   int __builtin___vsprintf_chk(char * , int  , unsigned long  , char const   * ,
                                __builtin_va_list  ) ;  */
/* compiler builtin: 
   char *__builtin___strncpy_chk(char * , char const   * , unsigned long  , unsigned long  ) ;  */
/* compiler builtin: 
   char *__builtin___strcat_chk(char * , char const   * , unsigned long  ) ;  */
/* compiler builtin: 
   int __builtin___sprintf_chk(char * , int  , unsigned long  , char const   *  , ...) ;  */
/* compiler builtin: 
   int __builtin___snprintf_chk(char * , unsigned long  , int  , unsigned long  ,
                                char const   *  , ...) ;  */
/* compiler builtin: 
   int __builtin___vsnprintf_chk(char * , unsigned long  , int  , unsigned long  ,
                                 char const   * , __builtin_va_list  ) ;  */
/* compiler builtin: 
   char *__builtin___strcpy_chk(char * , char const   * , unsigned long  ) ;  */
/* compiler builtin: 
   void *__builtin___memset_chk(void * , int  , unsigned long  , unsigned long  ) ;  */
/* compiler builtin: 
   char *__builtin___strncat_chk(char * , char const   * , unsigned long  , unsigned long  ) ;  */
/* compiler builtin: 
   long __builtin_expect(long  , long  ) ;  */
/* compiler builtin: 
   int __builtin_va_arg_pack(void) ;  */
#line 1 "ckd_alloc.o"
#pragma merger("0","/tmp/cil-XXjmUYqn.i","-g,-O4")
#line 392 "/usr/include/libio.h"
extern int __uflow(_IO_FILE * ) ;
#line 393
extern int __overflow(_IO_FILE * , int  ) ;
#line 435
extern int _IO_getc(_IO_FILE *__fp ) ;
#line 436
extern int _IO_putc(int __c , _IO_FILE *__fp ) ;
#line 168 "/usr/include/stdio.h"
extern struct _IO_FILE *stdin ;
#line 169
extern struct _IO_FILE *stdout ;
#line 356
__inline extern int ( __attribute__((__artificial__, __always_inline__)) fprintf)(FILE * __restrict  __stream ,
                                                                                  char const   * __restrict  __fmt 
                                                                                  , ...) ;
#line 362
__inline extern int ( __attribute__((__artificial__, __always_inline__)) printf)(char const   * __restrict  __fmt 
                                                                                 , ...) ;
#line 364
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__, __artificial__,
__always_inline__)) sprintf)(char * __restrict  __s , char const   * __restrict  __fmt 
                             , ...) ;
#line 371
__inline extern int ( __attribute__((__artificial__, __always_inline__)) vfprintf)(FILE * __restrict  __stream ,
                                                                                   char const   * __restrict  __fmt ,
                                                                                   __gnuc_va_list __ap ) ;
#line 377
__inline extern int ( __attribute__((__artificial__, __always_inline__)) vprintf)(char const   * __restrict  __fmt ,
                                                                                  __gnuc_va_list __ap ) ;
#line 379
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__, __artificial__,
__always_inline__)) vsprintf)(char * __restrict  __s , char const   * __restrict  __fmt ,
                              __gnuc_va_list __ap ) ;
#line 386
__inline extern  __attribute__((__nothrow__)) int ( /* format attribute */ __attribute__((__leaf__,
__artificial__, __always_inline__)) snprintf)(char * __restrict  __s , size_t __n ,
                                              char const   * __restrict  __fmt  , ...) ;
#line 390
__inline extern  __attribute__((__nothrow__)) int ( /* format attribute */ __attribute__((__leaf__,
__artificial__, __always_inline__)) vsnprintf)(char * __restrict  __s , size_t __n ,
                                               char const   * __restrict  __fmt ,
                                               __gnuc_va_list __ap ) ;
#line 412
__inline extern int ( /* format attribute */ __attribute__((__artificial__, __always_inline__)) vdprintf)(int __fd ,
                                                                                                          char const   * __restrict  __fmt ,
                                                                                                          __gnuc_va_list __ap ) ;
#line 415
__inline extern int ( /* format attribute */ __attribute__((__artificial__, __always_inline__)) dprintf)(int __fd ,
                                                                                                         char const   * __restrict  __fmt 
                                                                                                         , ...) ;
#line 538
__inline extern int getchar(void) ;
#line 550
__inline extern int getc_unlocked(FILE *__fp ) ;
#line 551
__inline extern int getchar_unlocked(void) ;
#line 561
__inline extern int fgetc_unlocked(FILE *__fp ) ;
#line 580
__inline extern int putchar(int __c ) ;
#line 594
__inline extern int fputc_unlocked(int __c , FILE *__stream ) ;
#line 602
__inline extern int putc_unlocked(int __c , FILE *__stream ) ;
#line 603
__inline extern int putchar_unlocked(int __c ) ;
#line 622
__inline extern char *( __attribute__((__warn_unused_result__, __artificial__, __always_inline__)) fgets)(char * __restrict  __s ,
                                                                                                          int __n ,
                                                                                                          FILE * __restrict  __stream ) ;
#line 638
__inline extern char *( __attribute__((__warn_unused_result__, __artificial__, __always_inline__)) gets)(char *__str )  __attribute__((__deprecated__)) ;
#line 709
__inline extern size_t ( __attribute__((__warn_unused_result__, __artificial__, __always_inline__)) fread)(void * __restrict  __ptr ,
                                                                                                           size_t __size ,
                                                                                                           size_t __n ,
                                                                                                           FILE * __restrict  __stream ) ;
#line 737
__inline extern size_t ( __attribute__((__warn_unused_result__, __artificial__, __always_inline__)) fread_unlocked)(void * __restrict  __ptr ,
                                                                                                                    size_t __size ,
                                                                                                                    size_t __n ,
                                                                                                                    FILE * __restrict  __stream ) ;
#line 836
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__warn_unused_result__,
__leaf__)) feof_unlocked)(FILE *__stream ) ;
#line 837
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__warn_unused_result__,
__leaf__)) ferror_unlocked)(FILE *__stream ) ;
#line 43 "/usr/include/x86_64-linux-gnu/bits/stdio.h"
__inline extern int getchar(void) 
{ 
  int tmp ;

  {
#line 46
  tmp = _IO_getc(stdin);
#line 46
  return (tmp);
}
}
#line 52 "/usr/include/x86_64-linux-gnu/bits/stdio.h"
__inline extern int fgetc_unlocked(FILE *__fp ) 
{ 
  int tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  long tmp___3 ;

  {
#line 55
  tmp___3 = __builtin_expect((long )((unsigned long )__fp->_IO_read_ptr >= (unsigned long )__fp->_IO_read_end),
                             0L);
#line 55
  if (tmp___3) {
#line 55
    tmp___0 = __uflow(__fp);
#line 55
    tmp___2 = tmp___0;
  } else {
#line 55
    tmp___1 = __fp->_IO_read_ptr;
#line 55
    (__fp->_IO_read_ptr) ++;
#line 55
    tmp___2 = (int )*((unsigned char *)tmp___1);
  }
#line 55
  return (tmp___2);
}
}
#line 69 "/usr/include/x86_64-linux-gnu/bits/stdio.h"
__inline extern int getchar_unlocked(void) 
{ 
  int tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  long tmp___3 ;

  {
#line 72
  tmp___3 = __builtin_expect((long )((unsigned long )stdin->_IO_read_ptr >= (unsigned long )stdin->_IO_read_end),
                             0L);
#line 72
  if (tmp___3) {
#line 72
    tmp___0 = __uflow(stdin);
#line 72
    tmp___2 = tmp___0;
  } else {
#line 72
    tmp___1 = stdin->_IO_read_ptr;
#line 72
    (stdin->_IO_read_ptr) ++;
#line 72
    tmp___2 = (int )*((unsigned char *)tmp___1);
  }
#line 72
  return (tmp___2);
}
}
#line 78 "/usr/include/x86_64-linux-gnu/bits/stdio.h"
__inline extern int putchar(int __c ) 
{ 
  int tmp ;

  {
#line 81
  tmp = _IO_putc(__c, stdout);
#line 81
  return (tmp);
}
}
#line 87 "/usr/include/x86_64-linux-gnu/bits/stdio.h"
__inline extern int fputc_unlocked(int __c , FILE *__stream ) 
{ 
  int tmp___0 ;
  char *tmp___1 ;
  char tmp___2 ;
  int tmp___3 ;
  long tmp___4 ;

  {
#line 90
  tmp___4 = __builtin_expect((long )((unsigned long )__stream->_IO_write_ptr >= (unsigned long )__stream->_IO_write_end),
                             0L);
#line 90
  if (tmp___4) {
#line 90
    tmp___0 = __overflow(__stream, (int )((unsigned char )__c));
#line 90
    tmp___3 = tmp___0;
  } else {
#line 90
    tmp___1 = __stream->_IO_write_ptr;
#line 90
    (__stream->_IO_write_ptr) ++;
#line 90
    tmp___2 = (char )__c;
#line 90
    *tmp___1 = tmp___2;
#line 90
    tmp___3 = (int )((unsigned char )tmp___2);
  }
#line 90
  return (tmp___3);
}
}
#line 104 "/usr/include/x86_64-linux-gnu/bits/stdio.h"
__inline extern int putchar_unlocked(int __c ) 
{ 
  int tmp___0 ;
  char *tmp___1 ;
  char tmp___2 ;
  int tmp___3 ;
  long tmp___4 ;

  {
#line 107
  tmp___4 = __builtin_expect((long )((unsigned long )stdout->_IO_write_ptr >= (unsigned long )stdout->_IO_write_end),
                             0L);
#line 107
  if (tmp___4) {
#line 107
    tmp___0 = __overflow(stdout, (int )((unsigned char )__c));
#line 107
    tmp___3 = tmp___0;
  } else {
#line 107
    tmp___1 = stdout->_IO_write_ptr;
#line 107
    (stdout->_IO_write_ptr) ++;
#line 107
    tmp___2 = (char )__c;
#line 107
    *tmp___1 = tmp___2;
#line 107
    tmp___3 = (int )((unsigned char )tmp___2);
  }
#line 107
  return (tmp___3);
}
}
#line 124
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__warn_unused_result__,
__leaf__)) feof_unlocked)(FILE *__stream ) ;
#line 124 "/usr/include/x86_64-linux-gnu/bits/stdio.h"
__inline extern int ( __attribute__((__warn_unused_result__, __leaf__)) feof_unlocked)(FILE *__stream ) 
{ 


  {
#line 127
  return ((__stream->_flags & 16) != 0);
}
}
#line 131
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__warn_unused_result__,
__leaf__)) ferror_unlocked)(FILE *__stream ) ;
#line 131 "/usr/include/x86_64-linux-gnu/bits/stdio.h"
__inline extern int ( __attribute__((__warn_unused_result__, __leaf__)) ferror_unlocked)(FILE *__stream ) 
{ 


  {
#line 134
  return ((__stream->_flags & 32) != 0);
}
}
#line 30 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__, __artificial__,
__always_inline__)) sprintf)(char * __restrict  __s , char const   * __restrict  __fmt 
                             , ...) ;
#line 30 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern int ( __attribute__((__leaf__, __artificial__, __always_inline__)) sprintf)(char * __restrict  __s ,
                                                                                            char const   * __restrict  __fmt 
                                                                                            , ...) 
{ 
  unsigned long tmp ;
  int tmp___0 ;

  {
#line 33
  tmp = __builtin_object_size((void *)__s, 1);
#line 33
  tmp___0 = __builtin___sprintf_chk((char *)__s, 1, tmp, (char const   *)__fmt, __builtin_va_arg_pack());
#line 33
  return (tmp___0);
}
}
#line 42
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__, __artificial__,
__always_inline__)) vsprintf)(char * __restrict  __s , char const   * __restrict  __fmt ,
                              __gnuc_va_list __ap ) ;
#line 42 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern int ( __attribute__((__leaf__, __artificial__, __always_inline__)) vsprintf)(char * __restrict  __s ,
                                                                                             char const   * __restrict  __fmt ,
                                                                                             __gnuc_va_list __ap ) 
{ 
  unsigned long tmp ;
  int tmp___0 ;

  {
#line 46
  tmp = __builtin_object_size((void *)__s, 1);
#line 46
  tmp___0 = __builtin___vsprintf_chk((char *)__s, 1, tmp, (char const   *)__fmt, __ap);
#line 46
  return (tmp___0);
}
}
#line 60
__inline extern  __attribute__((__nothrow__)) int ( /* format attribute */ __attribute__((__leaf__,
__artificial__, __always_inline__)) snprintf)(char * __restrict  __s , size_t __n ,
                                              char const   * __restrict  __fmt  , ...) ;
#line 60 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern int ( /* format attribute */ __attribute__((__leaf__, __artificial__,
__always_inline__)) snprintf)(char * __restrict  __s , size_t __n , char const   * __restrict  __fmt 
                              , ...) 
{ 
  unsigned long tmp ;
  int tmp___0 ;

  {
#line 64
  tmp = __builtin_object_size((void *)__s, 1);
#line 64
  tmp___0 = __builtin___snprintf_chk((char *)__s, __n, 1, tmp, (char const   *)__fmt,
                                     __builtin_va_arg_pack());
#line 64
  return (tmp___0);
}
}
#line 73
__inline extern  __attribute__((__nothrow__)) int ( /* format attribute */ __attribute__((__leaf__,
__artificial__, __always_inline__)) vsnprintf)(char * __restrict  __s , size_t __n ,
                                               char const   * __restrict  __fmt ,
                                               __gnuc_va_list __ap ) ;
#line 73 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern int ( /* format attribute */ __attribute__((__leaf__, __artificial__,
__always_inline__)) vsnprintf)(char * __restrict  __s , size_t __n , char const   * __restrict  __fmt ,
                               __gnuc_va_list __ap ) 
{ 
  unsigned long tmp ;
  int tmp___0 ;

  {
#line 77
  tmp = __builtin_object_size((void *)__s, 1);
#line 77
  tmp___0 = __builtin___vsnprintf_chk((char *)__s, __n, 1, tmp, (char const   *)__fmt,
                                      __ap);
#line 77
  return (tmp___0);
}
}
#line 85
extern int __fprintf_chk(FILE * __restrict  __stream , int __flag , char const   * __restrict  __format 
                         , ...) ;
#line 87
extern int __printf_chk(int __flag , char const   * __restrict  __format  , ...) ;
#line 88
extern int __vfprintf_chk(FILE * __restrict  __stream , int __flag , char const   * __restrict  __format ,
                          __gnuc_va_list __ap ) ;
#line 94 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern int ( __attribute__((__artificial__, __always_inline__)) fprintf)(FILE * __restrict  __stream ,
                                                                                  char const   * __restrict  __fmt 
                                                                                  , ...) 
{ 
  int tmp ;

  {
#line 97
  tmp = __fprintf_chk(__stream, 1, __fmt, __builtin_va_arg_pack());
#line 97
  return (tmp);
}
}
#line 101 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern int ( __attribute__((__artificial__, __always_inline__)) printf)(char const   * __restrict  __fmt 
                                                                                 , ...) 
{ 
  int tmp ;

  {
#line 104
  tmp = __printf_chk(1, __fmt, __builtin_va_arg_pack());
#line 104
  return (tmp);
}
}
#line 113 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern int ( __attribute__((__artificial__, __always_inline__)) vprintf)(char const   * __restrict  __fmt ,
                                                                                  __gnuc_va_list __ap ) 
{ 
  int tmp ;

  {
#line 117
  tmp = __vfprintf_chk((FILE * __restrict  )stdout, 1, __fmt, __ap);
#line 117
  return (tmp);
}
}
#line 123 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern int ( __attribute__((__artificial__, __always_inline__)) vfprintf)(FILE * __restrict  __stream ,
                                                                                   char const   * __restrict  __fmt ,
                                                                                   __gnuc_va_list __ap ) 
{ 
  int tmp ;

  {
#line 127
  tmp = __vfprintf_chk(__stream, 1, __fmt, __ap);
#line 127
  return (tmp);
}
}
#line 131
extern int ( /* format attribute */  __dprintf_chk)(int __fd , int __flag , char const   * __restrict  __fmt 
                                                    , ...) ;
#line 133
extern int ( /* format attribute */  __vdprintf_chk)(int __fd , int __flag , char const   * __restrict  __fmt ,
                                                     __gnuc_va_list __arg ) ;
#line 138 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern int ( /* format attribute */ __attribute__((__artificial__, __always_inline__)) dprintf)(int __fd ,
                                                                                                         char const   * __restrict  __fmt 
                                                                                                         , ...) 
{ 
  int tmp ;

  {
#line 141
  tmp = __dprintf_chk(__fd, 1, __fmt, __builtin_va_arg_pack());
#line 141
  return (tmp);
}
}
#line 149 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern int ( /* format attribute */ __attribute__((__artificial__, __always_inline__)) vdprintf)(int __fd ,
                                                                                                          char const   * __restrict  __fmt ,
                                                                                                          __gnuc_va_list __ap ) 
{ 
  int tmp ;

  {
#line 152
  tmp = __vdprintf_chk(__fd, 1, __fmt, __ap);
#line 152
  return (tmp);
}
}
#line 227
extern char *( __attribute__((__warn_unused_result__)) __gets_chk)(char *__str , size_t  ) ;
#line 228
extern char *( __attribute__((__warn_unused_result__)) __gets_warn)(char *__str )  __asm__("gets") __attribute__((__warning__("please use fgets or getline instead, gets can\'t specify buffer size"))) ;
#line 232
__inline extern char *( __attribute__((__warn_unused_result__, __artificial__, __always_inline__)) gets)(char *__str )  __attribute__((__deprecated__)) ;
#line 232 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern char *( __attribute__((__warn_unused_result__, __artificial__, __always_inline__)) gets)(char *__str ) 
{ 
  unsigned long tmp ;
  char *tmp___0 ;
  unsigned long tmp___1 ;
  char *tmp___2 ;

  {
#line 235
  tmp___1 = __builtin_object_size((void *)__str, 1);
#line 235
  if (tmp___1 != 0xffffffffffffffffUL) {
#line 236
    tmp = __builtin_object_size((void *)__str, 1);
#line 236
    tmp___0 = __gets_chk(__str, tmp);
#line 236
    return (tmp___0);
  }
#line 237
  tmp___2 = __gets_warn(__str);
#line 237
  return (tmp___2);
}
}
#line 241
extern char *( __attribute__((__warn_unused_result__)) __fgets_chk)(char * __restrict  __s ,
                                                                    size_t __size ,
                                                                    int __n , FILE * __restrict  __stream ) ;
#line 243
extern char *( __attribute__((__warn_unused_result__)) __fgets_alias)(char * __restrict  __s ,
                                                                      int __n , FILE * __restrict  __stream )  __asm__("fgets")  ;
#line 246
extern char *( __attribute__((__warn_unused_result__)) __fgets_chk_warn)(char * __restrict  __s ,
                                                                         size_t __size ,
                                                                         int __n ,
                                                                         FILE * __restrict  __stream )  __asm__("__fgets_chk") __attribute__((__warning__("fgets called with bigger size than length of destination buffer"))) ;
#line 252 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern char *( __attribute__((__warn_unused_result__, __artificial__, __always_inline__)) fgets)(char * __restrict  __s ,
                                                                                                          int __n ,
                                                                                                          FILE * __restrict  __stream ) 
{ 
  unsigned long tmp ;
  char *tmp___0 ;
  unsigned long tmp___1 ;
  char *tmp___2 ;
  unsigned long tmp___3 ;
  unsigned long tmp___4 ;
  char *tmp___5 ;

  {
#line 255
  tmp___4 = __builtin_object_size((void *)__s, 1);
#line 255
  if (tmp___4 != 0xffffffffffffffffUL) {
#line 258
    tmp = __builtin_object_size((void *)__s, 1);
#line 258
    tmp___0 = __fgets_chk(__s, tmp, __n, __stream);
#line 258
    return (tmp___0);
#line 260
    tmp___3 = __builtin_object_size((void *)__s, 1);
#line 260
    if ((size_t )__n > tmp___3) {
#line 261
      tmp___1 = __builtin_object_size((void *)__s, 1);
#line 261
      tmp___2 = __fgets_chk_warn(__s, tmp___1, __n, __stream);
#line 261
      return (tmp___2);
    }
  }
#line 263
  tmp___5 = __fgets_alias(__s, __n, __stream);
#line 263
  return (tmp___5);
}
}
#line 266
extern size_t ( __attribute__((__warn_unused_result__)) __fread_chk)(void * __restrict  __ptr ,
                                                                     size_t __ptrlen ,
                                                                     size_t __size ,
                                                                     size_t __n ,
                                                                     FILE * __restrict  __stream ) ;
#line 269
extern size_t ( __attribute__((__warn_unused_result__)) __fread_alias)(void * __restrict  __ptr ,
                                                                       size_t __size ,
                                                                       size_t __n ,
                                                                       FILE * __restrict  __stream )  __asm__("fread")  ;
#line 273
extern size_t ( __attribute__((__warn_unused_result__)) __fread_chk_warn)(void * __restrict  __ptr ,
                                                                          size_t __ptrlen ,
                                                                          size_t __size ,
                                                                          size_t __n ,
                                                                          FILE * __restrict  __stream )  __asm__("__fread_chk") __attribute__((__warning__("fread called with bigger size * nmemb than length of destination buffer"))) ;
#line 281 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern size_t ( __attribute__((__warn_unused_result__, __artificial__, __always_inline__)) fread)(void * __restrict  __ptr ,
                                                                                                           size_t __size ,
                                                                                                           size_t __n ,
                                                                                                           FILE * __restrict  __stream ) 
{ 
  unsigned long tmp ;
  size_t tmp___0 ;
  unsigned long tmp___1 ;
  size_t tmp___2 ;
  unsigned long tmp___3 ;
  unsigned long tmp___4 ;
  size_t tmp___5 ;

  {
#line 285
  tmp___4 = __builtin_object_size((void *)__ptr, 0);
#line 285
  if (tmp___4 != 0xffffffffffffffffUL) {
#line 290
    tmp = __builtin_object_size((void *)__ptr, 0);
#line 290
    tmp___0 = __fread_chk(__ptr, tmp, __size, __n, __stream);
#line 290
    return (tmp___0);
#line 292
    tmp___3 = __builtin_object_size((void *)__ptr, 0);
#line 292
    if (__size * __n > tmp___3) {
#line 293
      tmp___1 = __builtin_object_size((void *)__ptr, 0);
#line 293
      tmp___2 = __fread_chk_warn(__ptr, tmp___1, __size, __n, __stream);
#line 293
      return (tmp___2);
    }
  }
#line 295
  tmp___5 = __fread_alias(__ptr, __size, __n, __stream);
#line 295
  return (tmp___5);
}
}
#line 327
extern size_t ( __attribute__((__warn_unused_result__)) __fread_unlocked_chk)(void * __restrict  __ptr ,
                                                                              size_t __ptrlen ,
                                                                              size_t __size ,
                                                                              size_t __n ,
                                                                              FILE * __restrict  __stream ) ;
#line 330
extern size_t ( __attribute__((__warn_unused_result__)) __fread_unlocked_alias)(void * __restrict  __ptr ,
                                                                                size_t __size ,
                                                                                size_t __n ,
                                                                                FILE * __restrict  __stream )  __asm__("fread_unlocked")  ;
#line 334
extern size_t ( __attribute__((__warn_unused_result__)) __fread_unlocked_chk_warn)(void * __restrict  __ptr ,
                                                                                   size_t __ptrlen ,
                                                                                   size_t __size ,
                                                                                   size_t __n ,
                                                                                   FILE * __restrict  __stream )  __asm__("__fread_unlocked_chk") __attribute__((__warning__("fread_unlocked called with bigger size * nmemb than length of destination buffer"))) ;
#line 342 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern size_t ( __attribute__((__warn_unused_result__, __artificial__, __always_inline__)) fread_unlocked)(void * __restrict  __ptr ,
                                                                                                                    size_t __size ,
                                                                                                                    size_t __n ,
                                                                                                                    FILE * __restrict  __stream ) 
{ 
  unsigned long tmp ;
  size_t tmp___0 ;
  unsigned long tmp___1 ;
  size_t tmp___2 ;
  unsigned long tmp___3 ;
  unsigned long tmp___4 ;
  size_t tmp___11 ;

  {
#line 346
  tmp___4 = __builtin_object_size((void *)__ptr, 0);
#line 346
  if (tmp___4 != 0xffffffffffffffffUL) {
#line 351
    tmp = __builtin_object_size((void *)__ptr, 0);
#line 351
    tmp___0 = __fread_unlocked_chk(__ptr, tmp, __size, __n, __stream);
#line 351
    return (tmp___0);
#line 354
    tmp___3 = __builtin_object_size((void *)__ptr, 0);
#line 354
    if (__size * __n > tmp___3) {
#line 355
      tmp___1 = __builtin_object_size((void *)__ptr, 0);
#line 355
      tmp___2 = __fread_unlocked_chk_warn(__ptr, tmp___1, __size, __n, __stream);
#line 355
      return (tmp___2);
    }
  }
#line 380
  tmp___11 = __fread_unlocked_alias(__ptr, __size, __n, __stream);
#line 380
  return (tmp___11);
}
}
#line 467 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__warn_unused_result__,
__leaf__)) calloc)(size_t __nmemb , size_t __size )  __attribute__((__malloc__)) ;
#line 479
extern  __attribute__((__nothrow__)) void *( __attribute__((__warn_unused_result__,
__leaf__)) realloc)(void *__ptr , size_t __size ) ;
#line 42 "/usr/include/string.h"
__inline extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2),
__leaf__, __artificial__, __always_inline__)) memcpy)(void * __restrict  __dest ,
                                                      void const   * __restrict  __src ,
                                                      size_t __len ) ;
#line 46
__inline extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2),
__leaf__, __artificial__, __always_inline__)) memmove)(void *__dest , void const   *__src ,
                                                       size_t __len ) ;
#line 62
__inline extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1),
__leaf__, __artificial__, __always_inline__)) memset)(void *__dest , int __ch , size_t __len ) ;
#line 125
__inline extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2),
__leaf__, __artificial__, __always_inline__)) strcpy)(char * __restrict  __dest ,
                                                      char const   * __restrict  __src ) ;
#line 128
__inline extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2),
__leaf__, __artificial__, __always_inline__)) strncpy)(char * __restrict  __dest ,
                                                       char const   * __restrict  __src ,
                                                       size_t __len ) ;
#line 133
__inline extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2),
__leaf__, __artificial__, __always_inline__)) strcat)(char * __restrict  __dest ,
                                                      char const   * __restrict  __src ) ;
#line 136
__inline extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2),
__leaf__, __artificial__, __always_inline__)) strncat)(char * __restrict  __dest ,
                                                       char const   * __restrict  __src ,
                                                       size_t __len ) ;
#line 395
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 451
__inline extern  __attribute__((__nothrow__)) void ( __attribute__((__nonnull__(1,2),
__leaf__, __artificial__, __always_inline__)) bcopy)(void const   *__src , void *__dest ,
                                                     size_t __len ) ;
#line 455
__inline extern  __attribute__((__nothrow__)) void ( __attribute__((__nonnull__(1),
__leaf__, __artificial__, __always_inline__)) bzero)(void *__dest , size_t __len ) ;
#line 575
__inline extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2),
__leaf__, __artificial__, __always_inline__)) stpncpy)(char * __restrict  __dest ,
                                                       char const   * __restrict  __src ,
                                                       size_t __n ) ;
#line 968 "/usr/include/x86_64-linux-gnu/bits/string2.h"
__inline extern size_t __strcspn_c1(char const   *__s , int __reject ) ;
#line 969 "/usr/include/x86_64-linux-gnu/bits/string2.h"
__inline extern size_t __strcspn_c1(char const   *__s , int __reject ) 
{ 
  register size_t __result ;

  {
#line 972
  __result = (size_t )0;
#line 973
  while (1) {
#line 973
    if ((int const   )*(__s + __result) != 0) {
#line 973
      if (! ((int const   )*(__s + __result) != (int const   )__reject)) {
#line 973
        break;
      }
    } else {
#line 973
      break;
    }
#line 974
    __result ++;
  }
#line 975
  return (__result);
}
}
#line 978
__inline extern size_t __strcspn_c2(char const   *__s , int __reject1 , int __reject2 ) ;
#line 980 "/usr/include/x86_64-linux-gnu/bits/string2.h"
__inline extern size_t __strcspn_c2(char const   *__s , int __reject1 , int __reject2 ) 
{ 
  register size_t __result ;

  {
#line 983
  __result = (size_t )0;
#line 984
  while (1) {
#line 984
    if ((int const   )*(__s + __result) != 0) {
#line 984
      if ((int const   )*(__s + __result) != (int const   )__reject1) {
#line 984
        if (! ((int const   )*(__s + __result) != (int const   )__reject2)) {
#line 984
          break;
        }
      } else {
#line 984
        break;
      }
    } else {
#line 984
      break;
    }
#line 986
    __result ++;
  }
#line 987
  return (__result);
}
}
#line 990
__inline extern size_t __strcspn_c3(char const   *__s , int __reject1 , int __reject2 ,
                                    int __reject3 ) ;
#line 992 "/usr/include/x86_64-linux-gnu/bits/string2.h"
__inline extern size_t __strcspn_c3(char const   *__s , int __reject1 , int __reject2 ,
                                    int __reject3 ) 
{ 
  register size_t __result ;

  {
#line 996
  __result = (size_t )0;
#line 997
  while (1) {
#line 997
    if ((int const   )*(__s + __result) != 0) {
#line 997
      if ((int const   )*(__s + __result) != (int const   )__reject1) {
#line 997
        if ((int const   )*(__s + __result) != (int const   )__reject2) {
#line 997
          if (! ((int const   )*(__s + __result) != (int const   )__reject3)) {
#line 997
            break;
          }
        } else {
#line 997
          break;
        }
      } else {
#line 997
        break;
      }
    } else {
#line 997
      break;
    }
#line 999
    __result ++;
  }
#line 1000
  return (__result);
}
}
#line 1044
__inline extern size_t __strspn_c1(char const   *__s , int __accept ) ;
#line 1045 "/usr/include/x86_64-linux-gnu/bits/string2.h"
__inline extern size_t __strspn_c1(char const   *__s , int __accept ) 
{ 
  register size_t __result ;

  {
#line 1048
  __result = (size_t )0;
#line 1050
  while ((int const   )*(__s + __result) == (int const   )__accept) {
#line 1051
    __result ++;
  }
#line 1052
  return (__result);
}
}
#line 1055
__inline extern size_t __strspn_c2(char const   *__s , int __accept1 , int __accept2 ) ;
#line 1057 "/usr/include/x86_64-linux-gnu/bits/string2.h"
__inline extern size_t __strspn_c2(char const   *__s , int __accept1 , int __accept2 ) 
{ 
  register size_t __result ;

  {
#line 1060
  __result = (size_t )0;
#line 1062
  while (1) {
#line 1062
    if (! ((int const   )*(__s + __result) == (int const   )__accept1)) {
#line 1062
      if (! ((int const   )*(__s + __result) == (int const   )__accept2)) {
#line 1062
        break;
      }
    }
#line 1063
    __result ++;
  }
#line 1064
  return (__result);
}
}
#line 1067
__inline extern size_t __strspn_c3(char const   *__s , int __accept1 , int __accept2 ,
                                   int __accept3 ) ;
#line 1069 "/usr/include/x86_64-linux-gnu/bits/string2.h"
__inline extern size_t __strspn_c3(char const   *__s , int __accept1 , int __accept2 ,
                                   int __accept3 ) 
{ 
  register size_t __result ;

  {
#line 1072
  __result = (size_t )0;
#line 1074
  while (1) {
#line 1074
    if (! ((int const   )*(__s + __result) == (int const   )__accept1)) {
#line 1074
      if (! ((int const   )*(__s + __result) == (int const   )__accept2)) {
#line 1074
        if (! ((int const   )*(__s + __result) == (int const   )__accept3)) {
#line 1074
          break;
        }
      }
    }
#line 1076
    __result ++;
  }
#line 1077
  return (__result);
}
}
#line 1120
__inline extern char *__strpbrk_c2(char const   *__s , int __accept1 , int __accept2 ) ;
#line 1122 "/usr/include/x86_64-linux-gnu/bits/string2.h"
__inline extern char *__strpbrk_c2(char const   *__s , int __accept1 , int __accept2 ) 
{ 
  char *tmp ;

  {
#line 1126
  while (1) {
#line 1126
    if ((int const   )*__s != 0) {
#line 1126
      if ((int const   )*__s != (int const   )__accept1) {
#line 1126
        if (! ((int const   )*__s != (int const   )__accept2)) {
#line 1126
          break;
        }
      } else {
#line 1126
        break;
      }
    } else {
#line 1126
      break;
    }
#line 1127
    __s ++;
  }
#line 1128
  if ((int const   )*__s == 0) {
#line 1128
    tmp = (char *)((void *)0);
  } else {
#line 1128
    tmp = (char *)((size_t )__s);
  }
#line 1128
  return (tmp);
}
}
#line 1131
__inline extern char *__strpbrk_c3(char const   *__s , int __accept1 , int __accept2 ,
                                   int __accept3 ) ;
#line 1133 "/usr/include/x86_64-linux-gnu/bits/string2.h"
__inline extern char *__strpbrk_c3(char const   *__s , int __accept1 , int __accept2 ,
                                   int __accept3 ) 
{ 
  char *tmp ;

  {
#line 1137
  while (1) {
#line 1137
    if ((int const   )*__s != 0) {
#line 1137
      if ((int const   )*__s != (int const   )__accept1) {
#line 1137
        if ((int const   )*__s != (int const   )__accept2) {
#line 1137
          if (! ((int const   )*__s != (int const   )__accept3)) {
#line 1137
            break;
          }
        } else {
#line 1137
          break;
        }
      } else {
#line 1137
        break;
      }
    } else {
#line 1137
      break;
    }
#line 1139
    __s ++;
  }
#line 1140
  if ((int const   )*__s == 0) {
#line 1140
    tmp = (char *)((void *)0);
  } else {
#line 1140
    tmp = (char *)((size_t )__s);
  }
#line 1140
  return (tmp);
}
}
#line 1170
__inline extern char *__strtok_r_1c(char *__s , char __sep , char **__nextp ) ;
#line 1171 "/usr/include/x86_64-linux-gnu/bits/string2.h"
__inline extern char *__strtok_r_1c(char *__s , char __sep , char **__nextp ) 
{ 
  char *__result ;
  char *tmp ;
  char *tmp___0 ;

  {
#line 1175
  if ((unsigned long )__s == (unsigned long )((void *)0)) {
#line 1176
    __s = *__nextp;
  }
#line 1177
  while ((int )*__s == (int )__sep) {
#line 1178
    __s ++;
  }
#line 1179
  __result = (char *)((void *)0);
#line 1180
  if ((int )*__s != 0) {
#line 1182
    tmp = __s;
#line 1182
    __s ++;
#line 1182
    __result = tmp;
#line 1183
    while ((int )*__s != 0) {
#line 1184
      tmp___0 = __s;
#line 1184
      __s ++;
#line 1184
      if ((int )*tmp___0 == (int )__sep) {
#line 1186
        *(__s + -1) = (char )'\000';
#line 1187
        break;
      }
    }
  }
#line 1190
  *__nextp = __s;
#line 1191
  return (__result);
}
}
#line 1220
__inline extern char *__strsep_1c(char **__s , char __reject ) ;
#line 1221 "/usr/include/x86_64-linux-gnu/bits/string2.h"
__inline extern char *__strsep_1c(char **__s , char __reject ) 
{ 
  register char *__retval ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___2 ;

  {
#line 1224
  __retval = *__s;
#line 1225
  if ((unsigned long )__retval != (unsigned long )((void *)0)) {
#line 1225
    tmp___2 = __builtin_strchr(__retval, (int )__reject);
#line 1225
    tmp___0 = tmp___2;
#line 1225
    *__s = tmp___0;
#line 1225
    if ((unsigned long )tmp___0 != (unsigned long )((void *)0)) {
#line 1226
      tmp = *__s;
#line 1226
      (*__s) ++;
#line 1226
      *tmp = (char )'\000';
    }
  }
#line 1227
  return (__retval);
}
}
#line 1230
__inline extern char *__strsep_2c(char **__s , char __reject1 , char __reject2 ) ;
#line 1231 "/usr/include/x86_64-linux-gnu/bits/string2.h"
__inline extern char *__strsep_2c(char **__s , char __reject1 , char __reject2 ) 
{ 
  register char *__retval ;
  register char *__cp ;
  char *tmp ;

  {
#line 1234
  __retval = *__s;
#line 1235
  if ((unsigned long )__retval != (unsigned long )((void *)0)) {
#line 1237
    __cp = __retval;
#line 1238
    while (1) {
#line 1240
      if ((int )*__cp == 0) {
#line 1242
        __cp = (char *)((void *)0);
#line 1243
        break;
      }
#line 1245
      if ((int )*__cp == (int )__reject1) {
#line 1247
        tmp = __cp;
#line 1247
        __cp ++;
#line 1247
        *tmp = (char )'\000';
#line 1248
        break;
      } else
#line 1245
      if ((int )*__cp == (int )__reject2) {
#line 1247
        tmp = __cp;
#line 1247
        __cp ++;
#line 1247
        *tmp = (char )'\000';
#line 1248
        break;
      }
#line 1250
      __cp ++;
    }
#line 1252
    *__s = __cp;
  }
#line 1254
  return (__retval);
}
}
#line 1257
__inline extern char *__strsep_3c(char **__s , char __reject1 , char __reject2 , char __reject3 ) ;
#line 1259 "/usr/include/x86_64-linux-gnu/bits/string2.h"
__inline extern char *__strsep_3c(char **__s , char __reject1 , char __reject2 , char __reject3 ) 
{ 
  register char *__retval ;
  register char *__cp ;
  char *tmp ;

  {
#line 1262
  __retval = *__s;
#line 1263
  if ((unsigned long )__retval != (unsigned long )((void *)0)) {
#line 1265
    __cp = __retval;
#line 1266
    while (1) {
#line 1268
      if ((int )*__cp == 0) {
#line 1270
        __cp = (char *)((void *)0);
#line 1271
        break;
      }
#line 1273
      if ((int )*__cp == (int )__reject1) {
#line 1275
        tmp = __cp;
#line 1275
        __cp ++;
#line 1275
        *tmp = (char )'\000';
#line 1276
        break;
      } else
#line 1273
      if ((int )*__cp == (int )__reject2) {
#line 1275
        tmp = __cp;
#line 1275
        __cp ++;
#line 1275
        *tmp = (char )'\000';
#line 1276
        break;
      } else
#line 1273
      if ((int )*__cp == (int )__reject3) {
#line 1275
        tmp = __cp;
#line 1275
        __cp ++;
#line 1275
        *tmp = (char )'\000';
#line 1276
        break;
      }
#line 1278
      __cp ++;
    }
#line 1280
    *__s = __cp;
  }
#line 1282
  return (__retval);
}
}
#line 47 "/usr/include/x86_64-linux-gnu/bits/string3.h"
__inline extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2),
__leaf__, __artificial__, __always_inline__)) memcpy)(void * __restrict  __dest ,
                                                      void const   * __restrict  __src ,
                                                      size_t __len ) ;
#line 47 "/usr/include/x86_64-linux-gnu/bits/string3.h"
__inline extern void *( __attribute__((__nonnull__(1,2), __leaf__, __artificial__,
__always_inline__)) memcpy)(void * __restrict  __dest , void const   * __restrict  __src ,
                            size_t __len ) 
{ 
  unsigned long tmp ;
  void *tmp___0 ;

  {
#line 51
  tmp = __builtin_object_size((void *)__dest, 0);
#line 51
  tmp___0 = __builtin___memcpy_chk((void *)__dest, (void const   *)__src, __len, tmp);
#line 51
  return (tmp___0);
}
}
#line 54
__inline extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2),
__leaf__, __artificial__, __always_inline__)) memmove)(void *__dest , void const   *__src ,
                                                       size_t __len ) ;
#line 54 "/usr/include/x86_64-linux-gnu/bits/string3.h"
__inline extern void *( __attribute__((__nonnull__(1,2), __leaf__, __artificial__,
__always_inline__)) memmove)(void *__dest , void const   *__src , size_t __len ) 
{ 
  unsigned long tmp ;
  void *tmp___0 ;

  {
#line 57
  tmp = __builtin_object_size(__dest, 0);
#line 57
  tmp___0 = __builtin___memmove_chk(__dest, __src, __len, tmp);
#line 57
  return (tmp___0);
}
}
#line 75
__inline extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1),
__leaf__, __artificial__, __always_inline__)) memset)(void *__dest , int __ch , size_t __len ) ;
#line 75 "/usr/include/x86_64-linux-gnu/bits/string3.h"
__inline extern void *( __attribute__((__nonnull__(1), __leaf__, __artificial__, __always_inline__)) memset)(void *__dest ,
                                                                                                             int __ch ,
                                                                                                             size_t __len ) 
{ 
  unsigned long tmp ;
  void *tmp___0 ;

  {
#line 84
  tmp = __builtin_object_size(__dest, 0);
#line 84
  tmp___0 = __builtin___memset_chk(__dest, __ch, __len, tmp);
#line 84
  return (tmp___0);
}
}
#line 88
__inline extern  __attribute__((__nothrow__)) void ( __attribute__((__nonnull__(1,2),
__leaf__, __artificial__, __always_inline__)) bcopy)(void const   *__src , void *__dest ,
                                                     size_t __len ) ;
#line 88 "/usr/include/x86_64-linux-gnu/bits/string3.h"
__inline extern void ( __attribute__((__nonnull__(1,2), __leaf__, __artificial__,
__always_inline__)) bcopy)(void const   *__src , void *__dest , size_t __len ) 
{ 
  unsigned long tmp ;

  {
#line 91
  tmp = __builtin_object_size(__dest, 0);
#line 91
  __builtin___memmove_chk(__dest, __src, __len, tmp);
#line 92
  return;
}
}
#line 94
__inline extern  __attribute__((__nothrow__)) void ( __attribute__((__nonnull__(1),
__leaf__, __artificial__, __always_inline__)) bzero)(void *__dest , size_t __len ) ;
#line 94 "/usr/include/x86_64-linux-gnu/bits/string3.h"
__inline extern void ( __attribute__((__nonnull__(1), __leaf__, __artificial__, __always_inline__)) bzero)(void *__dest ,
                                                                                                           size_t __len ) 
{ 
  unsigned long tmp ;

  {
#line 97
  tmp = __builtin_object_size(__dest, 0);
#line 97
  __builtin___memset_chk(__dest, '\000', __len, tmp);
#line 98
  return;
}
}
#line 101
__inline extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2),
__leaf__, __artificial__, __always_inline__)) strcpy)(char * __restrict  __dest ,
                                                      char const   * __restrict  __src ) ;
#line 101 "/usr/include/x86_64-linux-gnu/bits/string3.h"
__inline extern char *( __attribute__((__nonnull__(1,2), __leaf__, __artificial__,
__always_inline__)) strcpy)(char * __restrict  __dest , char const   * __restrict  __src ) 
{ 
  unsigned long tmp ;
  char *tmp___0 ;

  {
#line 104
  tmp = __builtin_object_size((void *)__dest, 1);
#line 104
  tmp___0 = __builtin___strcpy_chk((char *)__dest, (char const   *)__src, tmp);
#line 104
  return (tmp___0);
}
}
#line 116
__inline extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2),
__leaf__, __artificial__, __always_inline__)) strncpy)(char * __restrict  __dest ,
                                                       char const   * __restrict  __src ,
                                                       size_t __len ) ;
#line 116 "/usr/include/x86_64-linux-gnu/bits/string3.h"
__inline extern char *( __attribute__((__nonnull__(1,2), __leaf__, __artificial__,
__always_inline__)) strncpy)(char * __restrict  __dest , char const   * __restrict  __src ,
                             size_t __len ) 
{ 
  unsigned long tmp ;
  char *tmp___0 ;

  {
#line 120
  tmp = __builtin_object_size((void *)__dest, 1);
#line 120
  tmp___0 = __builtin___strncpy_chk((char *)__dest, (char const   *)__src, __len,
                                    tmp);
#line 120
  return (tmp___0);
}
}
#line 124
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) __stpncpy_chk)(char *__dest ,
                                                                                      char const   *__src ,
                                                                                      size_t __n ,
                                                                                      size_t __destlen ) ;
#line 126
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) __stpncpy_alias)(char *__dest ,
                                                                                        char const   *__src ,
                                                                                        size_t __n )  __asm__("stpncpy")  ;
#line 129
__inline extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2),
__leaf__, __artificial__, __always_inline__)) stpncpy)(char * __restrict  __dest ,
                                                       char const   * __restrict  __src ,
                                                       size_t __n ) ;
#line 129 "/usr/include/x86_64-linux-gnu/bits/string3.h"
__inline extern char *( __attribute__((__nonnull__(1,2), __leaf__, __artificial__,
__always_inline__)) stpncpy)(char * __restrict  __dest , char const   * __restrict  __src ,
                             size_t __n ) 
{ 
  unsigned long tmp ;
  char *tmp___0 ;
  unsigned long tmp___1 ;
  char *tmp___3 ;

  {
#line 132
  tmp___1 = __builtin_object_size((void *)__dest, 1);
#line 132
  if (tmp___1 != 0xffffffffffffffffUL) {
#line 134
    tmp = __builtin_object_size((void *)__dest, 1);
#line 134
    tmp___0 = __stpncpy_chk((char *)__dest, (char const   *)__src, __n, tmp);
#line 134
    return (tmp___0);
  }
#line 135
  tmp___3 = __stpncpy_alias((char *)__dest, (char const   *)__src, __n);
#line 135
  return (tmp___3);
}
}
#line 139
__inline extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2),
__leaf__, __artificial__, __always_inline__)) strcat)(char * __restrict  __dest ,
                                                      char const   * __restrict  __src ) ;
#line 139 "/usr/include/x86_64-linux-gnu/bits/string3.h"
__inline extern char *( __attribute__((__nonnull__(1,2), __leaf__, __artificial__,
__always_inline__)) strcat)(char * __restrict  __dest , char const   * __restrict  __src ) 
{ 
  unsigned long tmp ;
  char *tmp___0 ;

  {
#line 142
  tmp = __builtin_object_size((void *)__dest, 1);
#line 142
  tmp___0 = __builtin___strcat_chk((char *)__dest, (char const   *)__src, tmp);
#line 142
  return (tmp___0);
}
}
#line 146
__inline extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2),
__leaf__, __artificial__, __always_inline__)) strncat)(char * __restrict  __dest ,
                                                       char const   * __restrict  __src ,
                                                       size_t __len ) ;
#line 146 "/usr/include/x86_64-linux-gnu/bits/string3.h"
__inline extern char *( __attribute__((__nonnull__(1,2), __leaf__, __artificial__,
__always_inline__)) strncat)(char * __restrict  __dest , char const   * __restrict  __src ,
                             size_t __len ) 
{ 
  unsigned long tmp ;
  char *tmp___0 ;

  {
#line 150
  tmp = __builtin_object_size((void *)__dest, 1);
#line 150
  tmp___0 = __builtin___strncat_chk((char *)__dest, (char const   *)__src, __len,
                                    tmp);
#line 150
  return (tmp___0);
}
}
#line 143 "src/ckd_alloc.h"
void *__ckd_calloc__(size_t n_elem , size_t elem_size , char const   *caller_file ,
                     int caller_line ) ;
#line 146
void *__ckd_malloc__(size_t size , char const   *caller_file , int caller_line ) ;
#line 149
void *__ckd_realloc__(void *ptr , size_t new_size , char const   *caller_file , int caller_line ) ;
#line 156
char *__ckd_salloc__(char const   *orig , char const   *caller_file , int32 caller_line ) ;
#line 163
void **__ckd_calloc_2d__(int32 d1 , int32 d2 , int32 elemsize , char const   *caller_file ,
                         int32 caller_line ) ;
#line 167
void **__ckd_calloc_2d__a(int32 d1 , int32 d2 , int32 elemsize , char const   *caller_file ,
                          int32 caller_line ) ;
#line 175
void ***__ckd_calloc_3d__(int32 d1 , int32 d2 , int32 d3 , int32 elemsize , char const   *caller_file ,
                          int32 caller_line ) ;
#line 180
void ckd_free_2d(void **ptr ) ;
#line 183
void ckd_free_2da(void **ptr ) ;
#line 187
void ckd_free_3d(void ***ptr ) ;
#line 212
char *__mymalloc__(int32 elemsize , char *caller_file , int32 caller_line ) ;
#line 219
void __myfree__(char *elem , int32 elemsize , char *caller_file , int32 caller_line ) ;
#line 115 "src/err.h"
void _E__pr_header(char const   *f , long ln , char const   *msg ) ;
#line 119
void _E__die_error(char const   *fmt  , ...) ;
#line 140 "src/ckd_alloc.c"
void *__ckd_calloc__(size_t n_elem , size_t elem_size , char const   *caller_file ,
                     int caller_line ) 
{ 
  void *mem ;

  {
#line 145
  mem = calloc(n_elem, elem_size);
#line 145
  if ((unsigned long )mem == (unsigned long )((void *)0)) {
#line 146
    _E__pr_header("src/ckd_alloc.c", 146L, "FATAL_ERROR");
#line 146
    _E__die_error("calloc(%d,%d) failed from %s(%d)\n", n_elem, elem_size, caller_file,
                  caller_line);
  }
#line 150
  return (mem);
}
}
#line 154 "src/ckd_alloc.c"
void *__ckd_malloc__(size_t size , char const   *caller_file , int caller_line ) 
{ 
  void *mem ;

  {
#line 159
  mem = malloc(size);
#line 159
  if ((unsigned long )mem == (unsigned long )((void *)0)) {
#line 160
    _E__pr_header("src/ckd_alloc.c", 160L, "FATAL_ERROR");
#line 160
    _E__die_error("malloc(%d) failed from %s(%d)\n", size, caller_file, caller_line);
  }
#line 162
  return (mem);
}
}
#line 166 "src/ckd_alloc.c"
void *__ckd_realloc__(void *ptr , size_t new_size , char const   *caller_file , int caller_line ) 
{ 
  void *mem ;

  {
#line 171
  mem = realloc(ptr, new_size);
#line 171
  if ((unsigned long )mem == (unsigned long )((void *)0)) {
#line 172
    _E__pr_header("src/ckd_alloc.c", 172L, "FATAL_ERROR");
#line 172
    _E__die_error("realloc(%d) failed from %s(%d)\n", new_size, caller_file, caller_line);
  }
#line 176
  return (mem);
}
}
#line 180 "src/ckd_alloc.c"
char *__ckd_salloc__(char const   *orig , char const   *caller_file , int32 caller_line ) 
{ 
  int32 len ;
  char *buf ;
  size_t tmp ;
  void *tmp___0 ;

  {
#line 185
  tmp = strlen(orig);
#line 185
  len = (int32 )(tmp + 1UL);
#line 186
  tmp___0 = __ckd_malloc__((size_t )len, caller_file, caller_line);
#line 186
  buf = (char *)tmp___0;
#line 188
  strcpy((char * __restrict  )buf, (char const   * __restrict  )orig);
#line 189
  return (buf);
}
}
#line 192 "src/ckd_alloc.c"
void **__ckd_calloc_2d__(int32 d1 , int32 d2 , int32 elemsize , char const   *caller_file ,
                         int32 caller_line ) 
{ 
  char **ref ;
  char *mem ;
  int32 i ;
  int32 offset ;
  void *tmp ;
  void *tmp___0 ;

  {
#line 198
  tmp = __ckd_calloc__((size_t )(d1 * d2), (size_t )elemsize, caller_file, caller_line);
#line 198
  mem = (char *)tmp;
#line 199
  tmp___0 = __ckd_malloc__((unsigned long )d1 * sizeof(void *), caller_file, caller_line);
#line 199
  ref = (char **)tmp___0;
#line 201
  i = 0;
#line 201
  offset = 0;
#line 201
  while (i < d1) {
#line 202
    *(ref + i) = mem + offset;
#line 201
    i ++;
#line 201
    offset += d2 * elemsize;
  }
#line 204
  return ((void **)ref);
}
}
#line 207 "src/ckd_alloc.c"
void **__ckd_calloc_2d__a(int32 d1 , int32 d2 , int32 elemsize , char const   *caller_file ,
                          int32 caller_line ) 
{ 
  char **ref ;
  char *mem ;
  int32 i ;
  int32 offset ;
  void *tmp ;
  void *tmp___0 ;

  {
#line 215
  tmp = __ckd_calloc__((size_t )(d1 * d2), (size_t )elemsize, caller_file, caller_line);
#line 215
  mem = (char *)tmp;
#line 217
  tmp___0 = __ckd_malloc__((unsigned long )d1 * sizeof(void *), caller_file, caller_line);
#line 217
  ref = (char **)tmp___0;
#line 219
  i = 0;
#line 219
  offset = 0;
#line 219
  while (i < d1) {
#line 220
    *(ref + i) = mem + offset;
#line 219
    i ++;
#line 219
    offset += d2 * elemsize;
  }
#line 222
  return ((void **)ref);
}
}
#line 226 "src/ckd_alloc.c"
void ckd_free_2da(void **ptr ) 
{ 


  {
#line 231
  free(*(ptr + 0));
#line 233
  free((void *)ptr);
#line 234
  return;
}
}
#line 236 "src/ckd_alloc.c"
void ckd_free_2d(void **ptr ) 
{ 


  {
#line 238
  free(*(ptr + 0));
#line 239
  free((void *)ptr);
#line 240
  return;
}
}
#line 243 "src/ckd_alloc.c"
void ***__ckd_calloc_3d__(int32 d1 , int32 d2 , int32 d3 , int32 elemsize , char const   *caller_file ,
                          int32 caller_line ) 
{ 
  char ***ref1 ;
  char **ref2 ;
  char *mem ;
  int32 i ;
  int32 j ;
  int32 offset ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
#line 249
  tmp = __ckd_calloc__((size_t )((d1 * d2) * d3), (size_t )elemsize, caller_file,
                       caller_line);
#line 249
  mem = (char *)tmp;
#line 250
  tmp___0 = __ckd_malloc__((unsigned long )d1 * sizeof(void **), caller_file, caller_line);
#line 250
  ref1 = (char ***)tmp___0;
#line 251
  tmp___1 = __ckd_malloc__((unsigned long )(d1 * d2) * sizeof(void *), caller_file,
                           caller_line);
#line 251
  ref2 = (char **)tmp___1;
#line 253
  i = 0;
#line 253
  offset = 0;
#line 253
  while (i < d1) {
#line 254
    *(ref1 + i) = ref2 + offset;
#line 253
    i ++;
#line 253
    offset += d2;
  }
#line 256
  offset = 0;
#line 257
  i = 0;
#line 257
  while (i < d1) {
#line 258
    j = 0;
#line 258
    while (j < d2) {
#line 259
      *(*(ref1 + i) + j) = mem + offset;
#line 260
      offset += d3 * elemsize;
#line 258
      j ++;
    }
#line 257
    i ++;
  }
#line 264
  return ((void ***)ref1);
}
}
#line 268 "src/ckd_alloc.c"
void ckd_free_3d(void ***ptr ) 
{ 


  {
#line 270
  free(*(*(ptr + 0) + 0));
#line 271
  free((void *)*(ptr + 0));
#line 272
  free((void *)ptr);
#line 273
  return;
}
}
#line 288 "src/ckd_alloc.c"
static mylist_t *head  =    (mylist_t *)((void *)0);
#line 293 "src/ckd_alloc.c"
char *__mymalloc__(int32 elemsize , char *caller_file , int32 caller_line ) 
{ 
  char *cp ;
  int32 j ;
  char **cpp ;
  mylist_t *prev ;
  mylist_t *list ;
  void *tmp ;
  char **tmp___0 ;
  void *tmp___1 ;

  {
#line 302
  prev = (mylist_t *)((void *)0);
#line 303
  list = head;
#line 303
  while (1) {
#line 303
    if (list) {
#line 303
      if (! (list->elemsize != elemsize)) {
#line 303
        break;
      }
    } else {
#line 303
      break;
    }
#line 304
    prev = list;
#line 303
    list = list->next;
  }
#line 306
  if (! list) {
#line 308
    if ((unsigned long )elemsize % sizeof(void *) != 0UL) {
#line 309
      _E__pr_header("src/ckd_alloc.c", 309L, "FATAL_ERROR");
#line 309
      _E__die_error("List item size (%d) not multiple of sizeof(void *)\n", elemsize);
    }
#line 311
    tmp = __ckd_calloc__((size_t )1, sizeof(mylist_t ), "src/ckd_alloc.c", 311);
#line 311
    list = (mylist_t *)tmp;
#line 312
    list->freelist = (char **)((void *)0);
#line 313
    list->elemsize = elemsize;
#line 314
    list->blocksize = 50;
#line 315
    list->blk_alloc = (1 << 18) / (list->blocksize * elemsize);
#line 318
    list->next = head;
#line 319
    head = list;
  } else
#line 320
  if (prev) {
#line 322
    prev->next = list->next;
#line 323
    list->next = head;
#line 324
    head = list;
  }
#line 328
  if ((unsigned long )list->freelist == (unsigned long )((void *)0)) {
#line 330
    if (list->blk_alloc == 0) {
#line 331
      list->blocksize <<= 1;
#line 332
      list->blk_alloc = (1 << 18) / (list->blocksize * elemsize);
#line 333
      if (list->blk_alloc <= 0) {
#line 334
        list->blk_alloc = 1879048192;
      }
    }
#line 338
    tmp___1 = __ckd_calloc__((size_t )list->blocksize, (size_t )elemsize, (char const   *)caller_file,
                             caller_line);
#line 338
    tmp___0 = (char **)tmp___1;
#line 338
    list->freelist = tmp___0;
#line 338
    cpp = tmp___0;
#line 340
    cp = (char *)cpp;
#line 341
    j = list->blocksize - 1;
#line 341
    while (j > 0) {
#line 342
      cp += elemsize;
#line 343
      *cpp = cp;
#line 344
      cpp = (char **)cp;
#line 341
      j --;
    }
#line 346
    *cpp = (char *)((void *)0);
#line 347
    (list->blk_alloc) --;
  }
#line 351
  cp = (char *)list->freelist;
#line 352
  list->freelist = (char **)*(list->freelist);
#line 359
  return (cp);
}
}
#line 363 "src/ckd_alloc.c"
void __myfree__(char *elem , int32 elemsize , char *caller_file , int32 caller_line ) 
{ 
  char **cpp ;
  mylist_t *prev ;
  mylist_t *list ;

  {
#line 370
  prev = (mylist_t *)((void *)0);
#line 371
  list = head;
#line 371
  while (1) {
#line 371
    if (list) {
#line 371
      if (! (list->elemsize != elemsize)) {
#line 371
        break;
      }
    } else {
#line 371
      break;
    }
#line 372
    prev = list;
#line 371
    list = list->next;
  }
#line 374
  if (! list) {
#line 375
    _E__pr_header("src/ckd_alloc.c", 375L, "FATAL_ERROR");
#line 375
    _E__die_error("Unknown list item size: %d; called from %s(%d)\n", elemsize, caller_file,
                  caller_line);
  } else
#line 377
  if (prev) {
#line 379
    prev->next = list->next;
#line 380
    list->next = head;
#line 381
    head = list;
  }
#line 388
  cpp = (char **)elem;
#line 389
  *cpp = (char *)list->freelist;
#line 390
  list->freelist = cpp;
#line 394
  return;
}
}
#line 1 "cmd_ln.o"
#pragma merger("0","/tmp/cil-LxiGdx7c.i","-g,-O4")
#line 170 "/usr/include/stdio.h"
extern struct _IO_FILE *stderr ;
#line 242
extern int fflush(FILE *__stream ) ;
#line 433
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) sscanf)(char const   * __restrict  __s ,
                                                                             char const   * __restrict  __format 
                                                                             , ...)  __asm__("__isoc99_sscanf")  ;
#line 542 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 760
extern void ( __attribute__((__nonnull__(1,4))) qsort)(void *__base , size_t __nmemb ,
                                                       size_t __size , int (*__compar)(void const   * ,
                                                                                       void const   * ) ) ;
#line 70 "/usr/include/assert.h"
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) __assert_fail)(char const   *__assertion ,
                                                                                                   char const   *__file ,
                                                                                                   unsigned int __line ,
                                                                                                   char const   *__function ) ;
#line 145 "src/cmd_ln.h"
int32 cmd_ln_parse(arg_t *defn , int32 argc , char **argv ) ;
#line 156
void const   *cmd_ln_access(char *name ) ;
#line 167
void cmd_ln_print_help(FILE *fp , arg_t *defn ) ;
#line 171
void cmd_ln_free(void) ;
#line 116 "src/err.h"
void _E__pr_info_header(char const   *f , long ln , char const   *msg ) ;
#line 117
void _E__pr_warn(char const   *fmt  , ...) ;
#line 118
void _E__pr_info(char const   *fmt  , ...) ;
#line 169 "src/hash.h"
hash_table_t *hash_new(int32 size , int32 casearg ) ;
#line 181
void hash_free(hash_table_t *h ) ;
#line 190
int32 hash_enter(hash_table_t *h , char const   *key , int32 val ) ;
#line 211
int32 hash_lookup(hash_table_t *h , char const   *key , int32 *val ) ;
#line 128 "src/cmd_ln.c"
static argval_t *argval  =    (argval_t *)((void *)0);
#line 129 "src/cmd_ln.c"
static hash_table_t *ht  ;
#line 162 "src/cmd_ln.c"
static int32 arg_strlen(arg_t *defn , int32 *namelen , int32 *deflen ) 
{ 
  int32 i ;
  int32 l ;
  int32 tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;

  {
#line 166
  tmp = 0;
#line 166
  *deflen = tmp;
#line 166
  *namelen = tmp;
#line 167
  i = 0;
#line 167
  while ((defn + i)->name) {
#line 168
    tmp___0 = strlen((char const   *)(defn + i)->name);
#line 168
    l = (int32 )tmp___0;
#line 169
    if (*namelen < l) {
#line 170
      *namelen = l;
    }
#line 172
    if ((defn + i)->deflt) {
#line 173
      tmp___1 = strlen((char const   *)(defn + i)->deflt);
#line 173
      l = (int32 )tmp___1;
#line 174
      if (*deflen < l) {
#line 175
        *deflen = l;
      }
    }
#line 167
    i ++;
  }
#line 179
  return (i);
}
}
#line 184 "src/cmd_ln.c"
static arg_t *tmp_defn  ;
#line 186 "src/cmd_ln.c"
static int32 cmp_name(void const   *a , void const   *b ) 
{ 
  int32 tmp ;

  {
#line 188
  tmp = strcmp_nocase((char const   *)(tmp_defn + *((int32 *)a))->name, (char const   *)(tmp_defn + *((int32 *)b))->name);
#line 188
  return (tmp);
}
}
#line 191 "src/cmd_ln.c"
static int32 *arg_sort(arg_t *defn , int32 n ) 
{ 
  int32 *pos ;
  int32 i ;
  void *tmp ;

  {
#line 196
  tmp = __ckd_calloc__((size_t )n, sizeof(int32 ), "src/cmd_ln.c", 196);
#line 196
  pos = (int32 *)tmp;
#line 197
  i = 0;
#line 197
  while (i < n) {
#line 198
    *(pos + i) = i;
#line 197
    i ++;
  }
#line 199
  tmp_defn = defn;
#line 200
  qsort((void *)pos, (size_t )n, sizeof(int32 ), & cmp_name);
#line 201
  tmp_defn = (arg_t *)((void *)0);
#line 203
  return (pos);
}
}
#line 207 "src/cmd_ln.c"
static int32 arg_str2val(argval_t *v , argtype_t t , char *str ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 209
  if (! str) {
#line 210
    v->ptr = (void const   *)((void *)0);
  } else {
#line 212
    switch (t) {
    case 3: 
    case 2: 
#line 215
    tmp = sscanf((char const   * __restrict  )str, (char const   * __restrict  )"%d",
                 & v->val.int32);
#line 215
    if (tmp != 1) {
#line 216
      return (-1);
    }
#line 217
    v->ptr = (void const   *)((void *)(& v->val.int32));
#line 218
    break;
    case 5: 
    case 4: 
#line 221
    tmp___0 = sscanf((char const   * __restrict  )str, (char const   * __restrict  )"%f",
                     & v->val.float32);
#line 221
    if (tmp___0 != 1) {
#line 222
      return (-1);
    }
#line 223
    v->ptr = (void const   *)((void *)(& v->val.float32));
#line 224
    break;
    case 7: 
    case 6: 
#line 227
    tmp___1 = sscanf((char const   * __restrict  )str, (char const   * __restrict  )"%lf",
                     & v->val.float64);
#line 227
    if (tmp___1 != 1) {
#line 228
      return (-1);
    }
#line 229
    v->ptr = (void const   *)((void *)(& v->val.float64));
#line 230
    break;
    case 9: 
    case 8: 
#line 233
    v->ptr = (void const   *)((void *)str);
#line 234
    break;
    default: 
#line 235
    _E__pr_header("src/cmd_ln.c", 235L, "FATAL_ERROR");
#line 235
    _E__die_error("Unknown argument type: %d\n", t);
    }
  }
#line 239
  return (0);
}
}
#line 243 "src/cmd_ln.c"
static void arg_dump(FILE *fp , arg_t *defn , int32 doc ) 
{ 
  int32 *pos ;
  int32 i ;
  int32 j ;
  int32 l ;
  int32 n ;
  int32 namelen ;
  int32 deflen ;
  void const   *vp ;
  size_t tmp ;
  size_t tmp___0 ;

  {
#line 251
  n = arg_strlen(defn, & namelen, & deflen);
#line 252
  namelen = (int32 )((unsigned int )namelen & 4294967288U);
#line 253
  deflen = (int32 )((unsigned int )deflen & 4294967288U);
#line 255
  fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"[NAME]");
#line 256
  l = 6;
#line 256
  while (l < namelen) {
#line 257
    fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"\t");
#line 256
    l += 8;
  }
#line 258
  fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"\t[DEFLT]");
#line 259
  l = 6;
#line 259
  while (l < deflen) {
#line 260
    fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"\t");
#line 259
    l += 8;
  }
#line 261
  fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"\t[VALUE]\n");
#line 264
  pos = arg_sort(defn, n);
#line 265
  i = 0;
#line 265
  while (i < n) {
#line 266
    j = *(pos + i);
#line 268
    fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"%s", (defn + j)->name);
#line 269
    tmp = strlen((char const   *)(defn + j)->name);
#line 269
    l = (int32 )tmp;
#line 269
    while (l < namelen) {
#line 270
      fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"\t");
#line 269
      l += 8;
    }
#line 272
    fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"\t");
#line 273
    if ((defn + j)->deflt) {
#line 274
      fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"%s", (defn + j)->deflt);
#line 275
      tmp___0 = strlen((char const   *)(defn + j)->deflt);
#line 275
      l = (int32 )tmp___0;
    } else {
#line 277
      l = 0;
    }
#line 278
    while (l < deflen) {
#line 279
      fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"\t");
#line 278
      l += 8;
    }
#line 281
    fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"\t");
#line 282
    if (doc) {
#line 283
      if ((defn + j)->doc) {
#line 284
        fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"%s", (defn + j)->doc);
      }
    } else {
#line 286
      vp = cmd_ln_access((defn + j)->name);
#line 287
      if (vp) {
#line 288
        switch ((defn + j)->type) {
        case 3: 
        case 2: 
#line 291
        fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"%d", *((int32 *)vp));
#line 292
        break;
        case 5: 
        case 4: 
#line 295
        fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"%e", (double )*((float32 *)vp));
#line 296
        break;
        case 7: 
        case 6: 
#line 299
        fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"%e", *((float64 *)vp));
#line 300
        break;
        case 9: 
        case 8: 
#line 303
        fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"%s", (char *)vp);
#line 304
        break;
        default: 
#line 305
        _E__pr_header("src/cmd_ln.c", 305L, "FATAL_ERROR");
#line 305
        _E__die_error("Unknown argument type: %d\n", (defn + j)->type);
        }
      }
    }
#line 310
    fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"\n");
#line 265
    i ++;
  }
#line 312
  free((void *)pos);
#line 314
  fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"\n");
#line 315
  fflush(fp);
#line 316
  return;
}
}
#line 319 "src/cmd_ln.c"
int32 cmd_ln_parse(arg_t *defn , int32 argc , char **argv ) 
{ 
  int32 i ;
  int32 j ;
  int32 n ;
  void *tmp ;
  int32 tmp___0 ;
  int32 tmp___1 ;
  int32 tmp___2 ;
  int32 tmp___3 ;

  {
#line 323
  if (argval) {
#line 324
    _E__pr_header("src/cmd_ln.c", 324L, "FATAL_ERROR");
#line 324
    _E__die_error("Multiple sets of argument definitions not supported\n");
  }
#line 327
  _E__pr_info_header("src/cmd_ln.c", 327L, "INFO");
#line 327
  _E__pr_info("Parsing command line:\n");
#line 328
  i = 0;
#line 328
  while (i < argc) {
#line 329
    if ((int )*(*(argv + i) + 0) == 45) {
#line 330
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"\\\n\t");
    }
#line 331
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s ", *(argv + i));
#line 328
    i ++;
  }
#line 333
  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"\n\n");
#line 334
  fflush(stderr);
#line 337
  n = 0;
#line 337
  while ((defn + n)->name) {
#line 337
    n ++;
  }
#line 340
  ht = hash_new(n, 0);
#line 341
  tmp = __ckd_calloc__((size_t )n, sizeof(argval_t ), "src/cmd_ln.c", 341);
#line 341
  argval = (argval_t *)tmp;
#line 344
  i = 0;
#line 344
  while (i < n) {
#line 346
    tmp___0 = hash_enter(ht, (char const   *)(defn + i)->name, i);
#line 346
    if (tmp___0 != i) {
#line 347
      _E__pr_header("src/cmd_ln.c", 347L, "FATAL_ERROR");
#line 347
      _E__die_error("Duplicate argument name: %s\n", (defn + i)->name);
    }
#line 344
    i ++;
  }
#line 351
  j = 1;
#line 351
  while (j < argc) {
#line 352
    tmp___1 = hash_lookup(ht, (char const   *)*(argv + j), & i);
#line 352
    if (tmp___1 < 0) {
#line 353
      _E__pr_header("src/cmd_ln.c", 353L, "ERROR");
#line 353
      _E__pr_warn("Unknown argument: %s\n", *(argv + j));
#line 354
      cmd_ln_print_help(stderr, defn);
#line 355
      exit(-1);
    }
#line 359
    if ((argval + i)->ptr) {
#line 360
      _E__pr_header("src/cmd_ln.c", 360L, "FATAL_ERROR");
#line 360
      _E__die_error("Multiple occurrences of argument %s\n", *(argv + j));
    }
#line 362
    if (j + 1 >= argc) {
#line 363
      _E__pr_header("src/cmd_ln.c", 363L, "ERROR");
#line 363
      _E__pr_warn("Argument value for \'%s\' missing\n", *(argv + j));
#line 364
      cmd_ln_print_help(stderr, defn);
#line 365
      exit(-1);
    }
#line 369
    tmp___2 = arg_str2val(argval + i, (defn + i)->type, *(argv + (j + 1)));
#line 369
    if (tmp___2 < 0) {
#line 370
      _E__pr_header("src/cmd_ln.c", 370L, "ERROR");
#line 370
      _E__pr_warn("Bad argument value for %s: %s\n", *(argv + j), *(argv + (j + 1)));
#line 371
      cmd_ln_print_help(stderr, defn);
#line 372
      exit(-1);
    }
#line 375
    if (! (argval + i)->ptr) {
#line 375
      __assert_fail("argval[i].ptr", "src/cmd_ln.c", 375U, "cmd_ln_parse");
    }
#line 351
    j += 2;
  }
#line 379
  i = 0;
#line 379
  while (i < n) {
#line 380
    if (! (argval + i)->ptr) {
#line 381
      tmp___3 = arg_str2val(argval + i, (defn + i)->type, (defn + i)->deflt);
#line 381
      if (tmp___3 < 0) {
#line 382
        _E__pr_header("src/cmd_ln.c", 382L, "FATAL_ERROR");
#line 382
        _E__die_error("Bad default argument value for %s: %s\n", (defn + i)->name,
                      (defn + i)->deflt);
      }
    }
#line 379
    i ++;
  }
#line 388
  j = 0;
#line 389
  i = 0;
#line 389
  while (i < n) {
#line 390
    if ((defn + i)->type & 1) {
#line 390
      if (! (argval + i)->ptr) {
#line 391
        _E__pr_header("src/cmd_ln.c", 391L, "ERROR");
#line 391
        _E__pr_warn("Missing required argument %s\n", (defn + i)->name);
#line 392
        j ++;
      }
    }
#line 389
    i ++;
  }
#line 395
  if (j > 0) {
#line 396
    cmd_ln_print_help(stderr, defn);
#line 397
    exit(-1);
  }
#line 401
  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Configuration in effect:\n");
#line 403
  arg_dump(stderr, defn, 0);
#line 405
  return (0);
}
}
#line 409 "src/cmd_ln.c"
void cmd_ln_print_help(FILE *fp , arg_t *defn ) 
{ 


  {
#line 411
  fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"Arguments list definition:\n");
#line 412
  arg_dump(fp, defn, 1);
#line 413
  return;
}
}
#line 416 "src/cmd_ln.c"
void const   *cmd_ln_access(char *name ) 
{ 
  int32 i ;
  int32 tmp ;

  {
#line 420
  if (! argval) {
#line 421
    _E__pr_header("src/cmd_ln.c", 421L, "FATAL_ERROR");
#line 421
    _E__die_error("cmd_ln_access invoked before cmd_ln_parse\n");
  }
#line 423
  tmp = hash_lookup(ht, (char const   *)name, & i);
#line 423
  if (tmp < 0) {
#line 424
    _E__pr_header("src/cmd_ln.c", 424L, "FATAL_ERROR");
#line 424
    _E__die_error("Unknown argument: %s\n", name);
  }
#line 426
  return ((argval + i)->ptr);
}
}
#line 430 "src/cmd_ln.c"
void cmd_ln_free(void) 
{ 


  {
#line 432
  hash_free(ht);
#line 433
  free((void *)argval);
#line 435
  return;
}
}
/* compiler builtin: 
   void __builtin_va_end(__builtin_va_list  ) ;  */
/* compiler builtin: 
   void __builtin_va_start(__builtin_va_list  ) ;  */
#line 1 "err.o"
#pragma merger("0","/tmp/cil-ckpG9tRc.i","-g,-O4")
#line 573 "/usr/include/stdio.h"
extern int fputc(int __c , FILE *__stream ) ;
#line 846
extern void perror(char const   *__s ) ;
#line 514 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) abort)(void) ;
#line 50 "/usr/include/x86_64-linux-gnu/bits/errno.h"
extern  __attribute__((__nothrow__)) int *( __attribute__((__leaf__)) __errno_location)(void)  __attribute__((__const__)) ;
#line 120 "src/err.h"
void _E__abort_error(char const   *fmt  , ...) ;
#line 121
void _E__sys_error(char const   *fmt  , ...) ;
#line 122
void _E__fatal_sys_error(char const   *fmt  , ...) ;
#line 122 "src/err.c"
void _E__pr_header(char const   *f , long ln , char const   *msg ) 
{ 


  {
#line 125
  fflush(stderr);
#line 126
  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s: \"%s\", line %ld: ",
          msg, f, ln);
#line 127
  return;
}
}
#line 129 "src/err.c"
void _E__pr_info_header(char const   *f , long ln , char const   *msg ) 
{ 


  {
#line 132
  fflush(stderr);
#line 135
  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s: %s(%ld): ",
          msg, f, ln);
#line 136
  return;
}
}
#line 138 "src/err.c"
void _E__pr_warn(char const   *fmt  , ...) 
{ 
  va_list pvar ;

  {
#line 143
  __builtin_va_start(pvar, fmt);
#line 144
  vfprintf((FILE * __restrict  )stderr, (char const   * __restrict  )fmt, pvar);
#line 145
  __builtin_va_end(pvar);
#line 147
  fflush(stderr);
#line 148
  return;
}
}
#line 150 "src/err.c"
void _E__pr_info(char const   *fmt  , ...) 
{ 
  va_list pvar ;

  {
#line 155
  __builtin_va_start(pvar, fmt);
#line 156
  vfprintf((FILE * __restrict  )stderr, (char const   * __restrict  )fmt, pvar);
#line 157
  __builtin_va_end(pvar);
#line 159
  fflush(stderr);
#line 160
  return;
}
}
#line 162 "src/err.c"
void _E__die_error(char const   *fmt  , ...) 
{ 
  va_list pvar ;

  {
#line 166
  __builtin_va_start(pvar, fmt);
#line 168
  vfprintf((FILE * __restrict  )stderr, (char const   * __restrict  )fmt, pvar);
#line 169
  fflush(stderr);
#line 171
  __builtin_va_end(pvar);
#line 173
  fflush(stderr);
#line 175
  exit(-1);
}
}
#line 178 "src/err.c"
void _E__fatal_sys_error(char const   *fmt  , ...) 
{ 
  va_list pvar ;
  int *tmp ;

  {
#line 182
  __builtin_va_start(pvar, fmt);
#line 183
  vfprintf((FILE * __restrict  )stderr, (char const   * __restrict  )fmt, pvar);
#line 184
  __builtin_va_end(pvar);
#line 186
  fputc(';', stderr);
#line 187
  fputc(' ', stderr);
#line 189
  perror("");
#line 191
  fflush(stderr);
#line 193
  tmp = __errno_location();
#line 193
  exit(*tmp);
}
}
#line 196 "src/err.c"
void _E__sys_error(char const   *fmt  , ...) 
{ 
  va_list pvar ;

  {
#line 200
  __builtin_va_start(pvar, fmt);
#line 201
  vfprintf((FILE * __restrict  )stderr, (char const   * __restrict  )fmt, pvar);
#line 202
  __builtin_va_end(pvar);
#line 204
  fputc(';', stderr);
#line 205
  fputc(' ', stderr);
#line 207
  perror("");
#line 209
  fflush(stderr);
#line 210
  return;
}
}
#line 212 "src/err.c"
void _E__abort_error(char const   *fmt  , ...) 
{ 
  va_list pvar ;

  {
#line 216
  __builtin_va_start(pvar, fmt);
#line 217
  vfprintf((FILE * __restrict  )stderr, (char const   * __restrict  )fmt, pvar);
#line 218
  __builtin_va_end(pvar);
#line 220
  fflush(stderr);
#line 222
  abort();
}
}
#line 1 "filename.o"
#pragma merger("0","/tmp/cil-MzsFO7_3.i","-g,-O4")
#line 115 "src/filename.h"
void path2basename(char *path , char *base ) ;
#line 122
void strip_fileext(char *path , char *root ) ;
#line 113 "src/filename.c"
void path2basename(char *path , char *base ) 
{ 
  int32 i ;
  int32 l ;
  size_t tmp ;

  {
#line 117
  tmp = strlen((char const   *)path);
#line 117
  l = (int32 )tmp;
#line 118
  i = l - 1;
#line 118
  while (1) {
#line 118
    if (i >= 0) {
#line 118
      if (! ((int )*(path + i) != 47)) {
#line 118
        break;
      }
    } else {
#line 118
      break;
    }
#line 118
    i --;
  }
#line 119
  strcpy((char * __restrict  )base, (char const   * __restrict  )((path + i) + 1));
#line 120
  return;
}
}
#line 124 "src/filename.c"
void strip_fileext(char *path , char *root ) 
{ 
  int32 i ;
  int32 l ;
  size_t tmp ;

  {
#line 128
  tmp = strlen((char const   *)path);
#line 128
  l = (int32 )tmp;
#line 129
  i = l - 1;
#line 129
  while (1) {
#line 129
    if (i >= 0) {
#line 129
      if (! ((int )*(path + i) != 46)) {
#line 129
        break;
      }
    } else {
#line 129
      break;
    }
#line 129
    i --;
  }
#line 130
  if (i < 0) {
#line 131
    strcpy((char * __restrict  )root, (char const   * __restrict  )path);
  } else {
#line 133
    *(path + i) = (char )'\000';
#line 134
    strcpy((char * __restrict  )root, (char const   * __restrict  )path);
#line 135
    *(path + i) = (char )'.';
  }
#line 137
  return;
}
}
#line 1 "glist.o"
#pragma merger("0","/tmp/cil-ROPpW4L7.i","-g,-O4")
#line 149 "src/glist.h"
glist_t glist_add_ptr(glist_t g , void *ptr ) ;
#line 150
glist_t glist_add_int32(glist_t g , int32 val ) ;
#line 151
glist_t glist_add_uint32(glist_t g , uint32 val ) ;
#line 152
glist_t glist_add_float32(glist_t g , float32 val ) ;
#line 153
glist_t glist_add_float64(glist_t g , float64 val ) ;
#line 161
int32 glist_chkdup_ptr(glist_t g , void *val ) ;
#line 162
int32 glist_chkdup_int32(glist_t g , int32 val ) ;
#line 163
int32 glist_chkdup_uint32(glist_t g , uint32 val ) ;
#line 164
int32 glist_chkdup_float32(glist_t g , float32 val ) ;
#line 165
int32 glist_chkdup_float64(glist_t g , float64 val ) ;
#line 174
glist_t glist_reverse(glist_t g ) ;
#line 178
int32 glist_count(glist_t g ) ;
#line 185
void glist_apply_ptr(glist_t g , void (*func)(void * ) ) ;
#line 186
void glist_apply_int32(glist_t g , void (*func)(int32  ) ) ;
#line 187
void glist_apply_uint32(glist_t g , void (*func)(uint32  ) ) ;
#line 188
void glist_apply_float32(glist_t g , void (*func)(float32  ) ) ;
#line 189
void glist_apply_float64(glist_t g , void (*func)(float64  ) ) ;
#line 196
void glist_free(glist_t g ) ;
#line 204
void glist_myfree(glist_t g , int32 datasize ) ;
#line 210
gnode_t *glist_tail(glist_t g ) ;
#line 116 "src/glist.c"
glist_t glist_add_ptr(glist_t g , void *ptr ) 
{ 
  gnode_t *gn ;
  char *tmp ;

  {
#line 120
  tmp = __mymalloc__((int32 )sizeof(gnode_t ), (char *)"src/glist.c", 120);
#line 120
  gn = (gnode_t *)tmp;
#line 121
  gn->data.ptr = ptr;
#line 122
  gn->next = g;
#line 123
  return (gn);
}
}
#line 127 "src/glist.c"
glist_t glist_add_int32(glist_t g , int32 val ) 
{ 
  gnode_t *gn ;
  char *tmp ;

  {
#line 131
  tmp = __mymalloc__((int32 )sizeof(gnode_t ), (char *)"src/glist.c", 131);
#line 131
  gn = (gnode_t *)tmp;
#line 132
  gn->data.int32 = val;
#line 133
  gn->next = g;
#line 134
  return (gn);
}
}
#line 138 "src/glist.c"
glist_t glist_add_uint32(glist_t g , uint32 val ) 
{ 
  gnode_t *gn ;
  char *tmp ;

  {
#line 142
  tmp = __mymalloc__((int32 )sizeof(gnode_t ), (char *)"src/glist.c", 142);
#line 142
  gn = (gnode_t *)tmp;
#line 143
  gn->data.uint32 = val;
#line 144
  gn->next = g;
#line 145
  return (gn);
}
}
#line 149 "src/glist.c"
glist_t glist_add_float32(glist_t g , float32 val ) 
{ 
  gnode_t *gn ;
  char *tmp ;

  {
#line 153
  tmp = __mymalloc__((int32 )sizeof(gnode_t ), (char *)"src/glist.c", 153);
#line 153
  gn = (gnode_t *)tmp;
#line 154
  gn->data.float32 = val;
#line 155
  gn->next = g;
#line 156
  return (gn);
}
}
#line 160 "src/glist.c"
glist_t glist_add_float64(glist_t g , float64 val ) 
{ 
  gnode_t *gn ;
  char *tmp ;

  {
#line 164
  tmp = __mymalloc__((int32 )sizeof(gnode_t ), (char *)"src/glist.c", 164);
#line 164
  gn = (gnode_t *)tmp;
#line 165
  gn->data.float64 = val;
#line 166
  gn->next = g;
#line 167
  return (gn);
}
}
#line 171 "src/glist.c"
int32 glist_chkdup_ptr(glist_t g , void *val ) 
{ 
  gnode_t *gn ;

  {
#line 175
  gn = g;
#line 175
  while (gn) {
#line 176
    if ((unsigned long )gn->data.ptr == (unsigned long )val) {
#line 177
      return (1);
    }
#line 175
    gn = gn->next;
  }
#line 179
  return (0);
}
}
#line 183 "src/glist.c"
int32 glist_chkdup_int32(glist_t g , int32 val ) 
{ 
  gnode_t *gn ;

  {
#line 187
  gn = g;
#line 187
  while (gn) {
#line 188
    if (gn->data.int32 == val) {
#line 189
      return (1);
    }
#line 187
    gn = gn->next;
  }
#line 191
  return (0);
}
}
#line 195 "src/glist.c"
int32 glist_chkdup_uint32(glist_t g , uint32 val ) 
{ 
  gnode_t *gn ;

  {
#line 199
  gn = g;
#line 199
  while (gn) {
#line 200
    if (gn->data.uint32 == val) {
#line 201
      return (1);
    }
#line 199
    gn = gn->next;
  }
#line 203
  return (0);
}
}
#line 207 "src/glist.c"
int32 glist_chkdup_float32(glist_t g , float32 val ) 
{ 
  gnode_t *gn ;

  {
#line 211
  gn = g;
#line 211
  while (gn) {
#line 212
    if (gn->data.float32 == val) {
#line 213
      return (1);
    }
#line 211
    gn = gn->next;
  }
#line 215
  return (0);
}
}
#line 219 "src/glist.c"
int32 glist_chkdup_float64(glist_t g , float64 val ) 
{ 
  gnode_t *gn ;

  {
#line 223
  gn = g;
#line 223
  while (gn) {
#line 224
    if (gn->data.float64 == val) {
#line 225
      return (1);
    }
#line 223
    gn = gn->next;
  }
#line 227
  return (0);
}
}
#line 231 "src/glist.c"
void glist_apply_ptr(glist_t g , void (*func)(void * ) ) 
{ 
  gnode_t *gn ;

  {
#line 235
  gn = g;
#line 235
  while (gn) {
#line 236
    (*func)(gn->data.ptr);
#line 235
    gn = gn->next;
  }
#line 237
  return;
}
}
#line 240 "src/glist.c"
void glist_apply_int32(glist_t g , void (*func)(int32  ) ) 
{ 
  gnode_t *gn ;

  {
#line 244
  gn = g;
#line 244
  while (gn) {
#line 245
    (*func)(gn->data.int32);
#line 244
    gn = gn->next;
  }
#line 246
  return;
}
}
#line 249 "src/glist.c"
void glist_apply_uint32(glist_t g , void (*func)(uint32  ) ) 
{ 
  gnode_t *gn ;

  {
#line 253
  gn = g;
#line 253
  while (gn) {
#line 254
    (*func)(gn->data.uint32);
#line 253
    gn = gn->next;
  }
#line 255
  return;
}
}
#line 258 "src/glist.c"
void glist_apply_float32(glist_t g , void (*func)(float32  ) ) 
{ 
  gnode_t *gn ;

  {
#line 262
  gn = g;
#line 262
  while (gn) {
#line 263
    (*func)(gn->data.float32);
#line 262
    gn = gn->next;
  }
#line 264
  return;
}
}
#line 267 "src/glist.c"
void glist_apply_float64(glist_t g , void (*func)(float64  ) ) 
{ 
  gnode_t *gn ;

  {
#line 271
  gn = g;
#line 271
  while (gn) {
#line 272
    (*func)(gn->data.float64);
#line 271
    gn = gn->next;
  }
#line 273
  return;
}
}
#line 276 "src/glist.c"
void glist_free(glist_t g ) 
{ 
  gnode_t *gn ;

  {
#line 280
  while (g) {
#line 281
    gn = g;
#line 282
    g = gn->next;
#line 283
    __myfree__((char *)gn, (int32 )sizeof(gnode_t ), (char *)"src/glist.c", 283);
  }
#line 285
  return;
}
}
#line 288 "src/glist.c"
void glist_myfree(glist_t g , int32 datasize ) 
{ 
  gnode_t *gn ;

  {
#line 292
  while (g) {
#line 293
    gn = g;
#line 294
    g = gn->next;
#line 295
    __myfree__((char *)gn->data.ptr, datasize, (char *)"src/glist.c", 295);
#line 296
    __myfree__((char *)gn, (int32 )sizeof(gnode_t ), (char *)"src/glist.c", 296);
  }
#line 298
  return;
}
}
#line 301 "src/glist.c"
int32 glist_count(glist_t g ) 
{ 
  gnode_t *gn ;
  int32 n ;

  {
#line 306
  gn = g;
#line 306
  n = 0;
#line 306
  while (gn) {
#line 306
    gn = gn->next;
#line 306
    n ++;
  }
#line 307
  return (n);
}
}
#line 311 "src/glist.c"
gnode_t *glist_tail(glist_t g ) 
{ 
  gnode_t *gn ;

  {
#line 315
  if (! g) {
#line 316
    return ((gnode_t *)((void *)0));
  }
#line 318
  gn = g;
#line 318
  while (gn->next) {
#line 318
    gn = gn->next;
  }
#line 319
  return (gn);
}
}
#line 323 "src/glist.c"
glist_t glist_reverse(glist_t g ) 
{ 
  gnode_t *gn ;
  gnode_t *nextgn ;
  gnode_t *rev ;

  {
#line 328
  rev = (gnode_t *)((void *)0);
#line 329
  gn = g;
#line 329
  while (gn) {
#line 330
    nextgn = gn->next;
#line 332
    gn->next = rev;
#line 333
    rev = gn;
#line 329
    gn = nextgn;
  }
#line 336
  return (rev);
}
}
/* compiler builtin: 
   int __builtin_strcmp(char const   * , char const   * ) ;  */
/* compiler builtin: 
   unsigned long __builtin_strlen(char const   * ) ;  */
#line 1 "bio.o"
#pragma merger("0","/tmp/cil-Axl2Aiff.i","-g,-O4")
#line 715 "/usr/include/stdio.h"
extern size_t fwrite(void const   * __restrict  __ptr , size_t __size , size_t __n ,
                     FILE * __restrict  __s ) ;
#line 360 "/usr/include/unistd.h"
__inline extern ssize_t ( __attribute__((__warn_unused_result__, __artificial__, __always_inline__)) read)(int __fd ,
                                                                                                           void *__buf ,
                                                                                                           size_t __nbytes ) ;
#line 511
__inline extern  __attribute__((__nothrow__)) char *( __attribute__((__warn_unused_result__,
__leaf__, __artificial__, __always_inline__)) getcwd)(char *__buf , size_t __size ) ;
#line 525
__inline extern  __attribute__((__nothrow__)) char __attribute__((__deprecated__))  *( __attribute__((__warn_unused_result__,
__nonnull__(1), __leaf__, __artificial__, __always_inline__)) getwd)(char *__buf )  __attribute__((__deprecated__)) ;
#line 623
__inline extern  __attribute__((__nothrow__)) size_t ( __attribute__((__leaf__, __artificial__,
__always_inline__)) confstr)(int __name , char *__buf , size_t __len ) ;
#line 711
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__warn_unused_result__,
__leaf__, __artificial__, __always_inline__)) getgroups)(int __size , __gid_t *__list ) ;
#line 796
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__warn_unused_result__,
__nonnull__(2), __leaf__, __artificial__, __always_inline__)) ttyname_r)(int __fd ,
                                                                         char *__buf ,
                                                                         size_t __buflen ) ;
#line 831
__inline extern  __attribute__((__nothrow__)) ssize_t ( __attribute__((__warn_unused_result__,
__nonnull__(1,2), __leaf__, __artificial__, __always_inline__)) readlink)(char const   * __restrict  __path ,
                                                                          char * __restrict  __buf ,
                                                                          size_t __len ) ;
#line 842
__inline extern  __attribute__((__nothrow__)) ssize_t ( __attribute__((__warn_unused_result__,
__nonnull__(2,3), __leaf__, __artificial__, __always_inline__)) readlinkat)(int __fd ,
                                                                            char const   * __restrict  __path ,
                                                                            char * __restrict  __buf ,
                                                                            size_t __len ) ;
#line 879
__inline extern int ( __attribute__((__nonnull__(1), __artificial__, __always_inline__)) getlogin_r)(char *__buf ,
                                                                                                     size_t __buflen ) ;
#line 901
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1),
__leaf__, __artificial__, __always_inline__)) gethostname)(char *__buf , size_t __buflen ) ;
#line 919
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__warn_unused_result__,
__nonnull__(1), __leaf__, __artificial__, __always_inline__)) getdomainname)(char *__buf ,
                                                                             size_t __buflen ) ;
#line 23 "/usr/include/x86_64-linux-gnu/bits/unistd.h"
extern ssize_t ( __attribute__((__warn_unused_result__)) __read_chk)(int __fd , void *__buf ,
                                                                     size_t __nbytes ,
                                                                     size_t __buflen ) ;
#line 25
extern ssize_t ( __attribute__((__warn_unused_result__)) __read_alias)(int __fd ,
                                                                       void *__buf ,
                                                                       size_t __nbytes )  __asm__("read")  ;
#line 27
extern ssize_t ( __attribute__((__warn_unused_result__)) __read_chk_warn)(int __fd ,
                                                                          void *__buf ,
                                                                          size_t __nbytes ,
                                                                          size_t __buflen )  __asm__("__read_chk") __attribute__((__warning__("read called with bigger length than size of the destination buffer"))) ;
#line 33 "/usr/include/x86_64-linux-gnu/bits/unistd.h"
__inline extern ssize_t ( __attribute__((__warn_unused_result__, __artificial__, __always_inline__)) read)(int __fd ,
                                                                                                           void *__buf ,
                                                                                                           size_t __nbytes ) 
{ 
  unsigned long tmp ;
  ssize_t tmp___0 ;
  unsigned long tmp___1 ;
  ssize_t tmp___2 ;
  unsigned long tmp___3 ;
  unsigned long tmp___4 ;
  ssize_t tmp___5 ;

  {
#line 36
  tmp___4 = __builtin_object_size(__buf, 0);
#line 36
  if (tmp___4 != 0xffffffffffffffffUL) {
#line 39
    tmp = __builtin_object_size(__buf, 0);
#line 39
    tmp___0 = __read_chk(__fd, __buf, __nbytes, tmp);
#line 39
    return (tmp___0);
#line 41
    tmp___3 = __builtin_object_size(__buf, 0);
#line 41
    if (__nbytes > tmp___3) {
#line 42
      tmp___1 = __builtin_object_size(__buf, 0);
#line 42
      tmp___2 = __read_chk_warn(__fd, __buf, __nbytes, tmp___1);
#line 42
      return (tmp___2);
    }
  }
#line 44
  tmp___5 = __read_alias(__fd, __buf, __nbytes);
#line 44
  return (tmp___5);
}
}
#line 123
extern  __attribute__((__nothrow__)) ssize_t ( __attribute__((__warn_unused_result__,
__nonnull__(1,2), __leaf__)) __readlink_chk)(char const   * __restrict  __path , char * __restrict  __buf ,
                                             size_t __len , size_t __buflen ) ;
#line 127
extern  __attribute__((__nothrow__)) ssize_t ( __attribute__((__warn_unused_result__,
__nonnull__(1,2), __leaf__)) __readlink_alias)(char const   * __restrict  __path ,
                                               char * __restrict  __buf , size_t __len )  __asm__("readlink")  ;
#line 131
extern  __attribute__((__nothrow__)) ssize_t ( __attribute__((__warn_unused_result__,
__nonnull__(1,2), __leaf__)) __readlink_chk_warn)(char const   * __restrict  __path ,
                                                  char * __restrict  __buf , size_t __len ,
                                                  size_t __buflen )  __asm__("__readlink_chk") __attribute__((__warning__("readlink called with bigger length than size of destination buffer"))) ;
#line 138
__inline extern  __attribute__((__nothrow__)) ssize_t ( __attribute__((__warn_unused_result__,
__nonnull__(1,2), __leaf__, __artificial__, __always_inline__)) readlink)(char const   * __restrict  __path ,
                                                                          char * __restrict  __buf ,
                                                                          size_t __len ) ;
#line 138 "/usr/include/x86_64-linux-gnu/bits/unistd.h"
__inline extern ssize_t ( __attribute__((__warn_unused_result__, __nonnull__(1,2),
__leaf__, __artificial__, __always_inline__)) readlink)(char const   * __restrict  __path ,
                                                        char * __restrict  __buf ,
                                                        size_t __len ) 
{ 
  unsigned long tmp ;
  ssize_t tmp___0 ;
  unsigned long tmp___1 ;
  ssize_t tmp___2 ;
  unsigned long tmp___3 ;
  unsigned long tmp___4 ;
  ssize_t tmp___5 ;

  {
#line 142
  tmp___4 = __builtin_object_size((void *)__buf, 1);
#line 142
  if (tmp___4 != 0xffffffffffffffffUL) {
#line 145
    tmp = __builtin_object_size((void *)__buf, 1);
#line 145
    tmp___0 = __readlink_chk(__path, __buf, __len, tmp);
#line 145
    return (tmp___0);
#line 147
    tmp___3 = __builtin_object_size((void *)__buf, 1);
#line 147
    if (__len > tmp___3) {
#line 148
      tmp___1 = __builtin_object_size((void *)__buf, 1);
#line 148
      tmp___2 = __readlink_chk_warn(__path, __buf, __len, tmp___1);
#line 148
      return (tmp___2);
    }
  }
#line 150
  tmp___5 = __readlink_alias(__path, __buf, __len);
#line 150
  return (tmp___5);
}
}
#line 155
extern  __attribute__((__nothrow__)) ssize_t ( __attribute__((__warn_unused_result__,
__nonnull__(2,3), __leaf__)) __readlinkat_chk)(int __fd , char const   * __restrict  __path ,
                                               char * __restrict  __buf , size_t __len ,
                                               size_t __buflen ) ;
#line 159
extern  __attribute__((__nothrow__)) ssize_t ( __attribute__((__warn_unused_result__,
__nonnull__(2,3), __leaf__)) __readlinkat_alias)(int __fd , char const   * __restrict  __path ,
                                                 char * __restrict  __buf , size_t __len )  __asm__("readlinkat")  ;
#line 164
extern  __attribute__((__nothrow__)) ssize_t ( __attribute__((__warn_unused_result__,
__nonnull__(2,3), __leaf__)) __readlinkat_chk_warn)(int __fd , char const   * __restrict  __path ,
                                                    char * __restrict  __buf , size_t __len ,
                                                    size_t __buflen )  __asm__("__readlinkat_chk") __attribute__((__warning__("readlinkat called with bigger length than size of destination buffer"))) ;
#line 172
__inline extern  __attribute__((__nothrow__)) ssize_t ( __attribute__((__warn_unused_result__,
__nonnull__(2,3), __leaf__, __artificial__, __always_inline__)) readlinkat)(int __fd ,
                                                                            char const   * __restrict  __path ,
                                                                            char * __restrict  __buf ,
                                                                            size_t __len ) ;
#line 172 "/usr/include/x86_64-linux-gnu/bits/unistd.h"
__inline extern ssize_t ( __attribute__((__warn_unused_result__, __nonnull__(2,3),
__leaf__, __artificial__, __always_inline__)) readlinkat)(int __fd , char const   * __restrict  __path ,
                                                          char * __restrict  __buf ,
                                                          size_t __len ) 
{ 
  unsigned long tmp ;
  ssize_t tmp___0 ;
  unsigned long tmp___1 ;
  ssize_t tmp___2 ;
  unsigned long tmp___3 ;
  unsigned long tmp___4 ;
  ssize_t tmp___5 ;

  {
#line 176
  tmp___4 = __builtin_object_size((void *)__buf, 1);
#line 176
  if (tmp___4 != 0xffffffffffffffffUL) {
#line 179
    tmp = __builtin_object_size((void *)__buf, 1);
#line 179
    tmp___0 = __readlinkat_chk(__fd, __path, __buf, __len, tmp);
#line 179
    return (tmp___0);
#line 181
    tmp___3 = __builtin_object_size((void *)__buf, 1);
#line 181
    if (__len > tmp___3) {
#line 182
      tmp___1 = __builtin_object_size((void *)__buf, 1);
#line 182
      tmp___2 = __readlinkat_chk_warn(__fd, __path, __buf, __len, tmp___1);
#line 182
      return (tmp___2);
    }
  }
#line 185
  tmp___5 = __readlinkat_alias(__fd, __path, __buf, __len);
#line 185
  return (tmp___5);
}
}
#line 189
extern  __attribute__((__nothrow__)) char *( __attribute__((__warn_unused_result__,
__leaf__)) __getcwd_chk)(char *__buf , size_t __size , size_t __buflen ) ;
#line 191
extern  __attribute__((__nothrow__)) char *( __attribute__((__warn_unused_result__,
__leaf__)) __getcwd_alias)(char *__buf , size_t __size )  __asm__("getcwd")  ;
#line 193
extern  __attribute__((__nothrow__)) char *( __attribute__((__warn_unused_result__,
__leaf__)) __getcwd_chk_warn)(char *__buf , size_t __size , size_t __buflen )  __asm__("__getcwd_chk") __attribute__((__warning__("getcwd caller with bigger length than size of destination buffer"))) ;
#line 199
__inline extern  __attribute__((__nothrow__)) char *( __attribute__((__warn_unused_result__,
__leaf__, __artificial__, __always_inline__)) getcwd)(char *__buf , size_t __size ) ;
#line 199 "/usr/include/x86_64-linux-gnu/bits/unistd.h"
__inline extern char *( __attribute__((__warn_unused_result__, __leaf__, __artificial__,
__always_inline__)) getcwd)(char *__buf , size_t __size ) 
{ 
  unsigned long tmp ;
  char *tmp___0 ;
  unsigned long tmp___1 ;
  char *tmp___2 ;
  unsigned long tmp___3 ;
  unsigned long tmp___4 ;
  char *tmp___5 ;

  {
#line 202
  tmp___4 = __builtin_object_size((void *)__buf, 1);
#line 202
  if (tmp___4 != 0xffffffffffffffffUL) {
#line 205
    tmp = __builtin_object_size((void *)__buf, 1);
#line 205
    tmp___0 = __getcwd_chk(__buf, __size, tmp);
#line 205
    return (tmp___0);
#line 207
    tmp___3 = __builtin_object_size((void *)__buf, 1);
#line 207
    if (__size > tmp___3) {
#line 208
      tmp___1 = __builtin_object_size((void *)__buf, 1);
#line 208
      tmp___2 = __getcwd_chk_warn(__buf, __size, tmp___1);
#line 208
      return (tmp___2);
    }
  }
#line 210
  tmp___5 = __getcwd_alias(__buf, __size);
#line 210
  return (tmp___5);
}
}
#line 214
extern  __attribute__((__nothrow__)) char *( __attribute__((__warn_unused_result__,
__nonnull__(1), __leaf__)) __getwd_chk)(char *__buf , size_t buflen ) ;
#line 216
extern  __attribute__((__nothrow__)) char *( __attribute__((__warn_unused_result__,
__nonnull__(1), __leaf__)) __getwd_warn)(char *__buf )  __asm__("getwd") __attribute__((__warning__("please use getcwd instead, as getwd doesn\'t specify buffer size"))) ;
#line 220
__inline extern  __attribute__((__nothrow__)) char __attribute__((__deprecated__))  *( __attribute__((__warn_unused_result__,
__nonnull__(1), __leaf__, __artificial__, __always_inline__)) getwd)(char *__buf )  __attribute__((__deprecated__)) ;
#line 220 "/usr/include/x86_64-linux-gnu/bits/unistd.h"
__inline extern char __attribute__((__deprecated__))  *( __attribute__((__warn_unused_result__,
__nonnull__(1), __leaf__, __artificial__, __always_inline__)) getwd)(char *__buf ) 
{ 
  unsigned long tmp ;
  char *tmp___0 ;
  unsigned long tmp___1 ;
  char *tmp___2 ;

  {
#line 223
  tmp___1 = __builtin_object_size((void *)__buf, 1);
#line 223
  if (tmp___1 != 0xffffffffffffffffUL) {
#line 224
    tmp = __builtin_object_size((void *)__buf, 1);
#line 224
    tmp___0 = __getwd_chk(__buf, tmp);
#line 224
    return ((char __attribute__((__deprecated__))  *)tmp___0);
  }
#line 225
  tmp___2 = __getwd_warn(__buf);
#line 225
  return ((char __attribute__((__deprecated__))  *)tmp___2);
}
}
#line 229
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__leaf__)) __confstr_chk)(int __name ,
                                                                                       char *__buf ,
                                                                                       size_t __len ,
                                                                                       size_t __buflen ) ;
#line 231
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__leaf__)) __confstr_alias)(int __name ,
                                                                                         char *__buf ,
                                                                                         size_t __len )  __asm__("confstr")  ;
#line 233
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__leaf__)) __confstr_chk_warn)(int __name ,
                                                                                            char *__buf ,
                                                                                            size_t __len ,
                                                                                            size_t __buflen )  __asm__("__confstr_chk") __attribute__((__warning__("confstr called with bigger length than size of destination buffer"))) ;
#line 239
__inline extern  __attribute__((__nothrow__)) size_t ( __attribute__((__leaf__, __artificial__,
__always_inline__)) confstr)(int __name , char *__buf , size_t __len ) ;
#line 239 "/usr/include/x86_64-linux-gnu/bits/unistd.h"
__inline extern size_t ( __attribute__((__leaf__, __artificial__, __always_inline__)) confstr)(int __name ,
                                                                                               char *__buf ,
                                                                                               size_t __len ) 
{ 
  unsigned long tmp ;
  size_t tmp___0 ;
  unsigned long tmp___1 ;
  size_t tmp___2 ;
  unsigned long tmp___3 ;
  unsigned long tmp___4 ;
  size_t tmp___5 ;

  {
#line 242
  tmp___4 = __builtin_object_size((void *)__buf, 1);
#line 242
  if (tmp___4 != 0xffffffffffffffffUL) {
#line 245
    tmp = __builtin_object_size((void *)__buf, 1);
#line 245
    tmp___0 = __confstr_chk(__name, __buf, __len, tmp);
#line 245
    return (tmp___0);
#line 247
    tmp___3 = __builtin_object_size((void *)__buf, 1);
#line 247
    if (tmp___3 < __len) {
#line 248
      tmp___1 = __builtin_object_size((void *)__buf, 1);
#line 248
      tmp___2 = __confstr_chk_warn(__name, __buf, __len, tmp___1);
#line 248
      return (tmp___2);
    }
  }
#line 250
  tmp___5 = __confstr_alias(__name, __buf, __len);
#line 250
  return (tmp___5);
}
}
#line 254
extern  __attribute__((__nothrow__)) int ( __attribute__((__warn_unused_result__,
__leaf__)) __getgroups_chk)(int __size , __gid_t *__list , size_t __listlen ) ;
#line 256
extern  __attribute__((__nothrow__)) int ( __attribute__((__warn_unused_result__,
__leaf__)) __getgroups_alias)(int __size , __gid_t *__list )  __asm__("getgroups")  ;
#line 258
extern  __attribute__((__nothrow__)) int ( __attribute__((__warn_unused_result__,
__leaf__)) __getgroups_chk_warn)(int __size , __gid_t *__list , size_t __listlen )  __asm__("__getgroups_chk") __attribute__((__warning__("getgroups called with bigger group count than what can fit into destination buffer"))) ;
#line 264
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__warn_unused_result__,
__leaf__, __artificial__, __always_inline__)) getgroups)(int __size , __gid_t *__list ) ;
#line 264 "/usr/include/x86_64-linux-gnu/bits/unistd.h"
__inline extern int ( __attribute__((__warn_unused_result__, __leaf__, __artificial__,
__always_inline__)) getgroups)(int __size , __gid_t *__list ) 
{ 
  unsigned long tmp ;
  int tmp___0 ;
  unsigned long tmp___1 ;
  int tmp___2 ;
  unsigned long tmp___3 ;
  unsigned long tmp___4 ;
  int tmp___5 ;

  {
#line 267
  tmp___4 = __builtin_object_size((void *)__list, 1);
#line 267
  if (tmp___4 != 0xffffffffffffffffUL) {
#line 270
    tmp = __builtin_object_size((void *)__list, 1);
#line 270
    tmp___0 = __getgroups_chk(__size, __list, tmp);
#line 270
    return (tmp___0);
#line 272
    tmp___3 = __builtin_object_size((void *)__list, 1);
#line 272
    if ((unsigned long )__size * sizeof(__gid_t ) > tmp___3) {
#line 273
      tmp___1 = __builtin_object_size((void *)__list, 1);
#line 273
      tmp___2 = __getgroups_chk_warn(__size, __list, tmp___1);
#line 273
      return (tmp___2);
    }
  }
#line 275
  tmp___5 = __getgroups_alias(__size, __list);
#line 275
  return (tmp___5);
}
}
#line 279
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2), __leaf__)) __ttyname_r_chk)(int __fd ,
                                                                                                      char *__buf ,
                                                                                                      size_t __buflen ,
                                                                                                      size_t __nreal ) ;
#line 281
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2), __leaf__)) __ttyname_r_alias)(int __fd ,
                                                                                                        char *__buf ,
                                                                                                        size_t __buflen )  __asm__("ttyname_r")  ;
#line 284
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2), __leaf__)) __ttyname_r_chk_warn)(int __fd ,
                                                                                                           char *__buf ,
                                                                                                           size_t __buflen ,
                                                                                                           size_t __nreal )  __asm__("__ttyname_r_chk") __attribute__((__warning__("ttyname_r called with bigger buflen than size of destination buffer"))) ;
#line 290
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__warn_unused_result__,
__nonnull__(2), __leaf__, __artificial__, __always_inline__)) ttyname_r)(int __fd ,
                                                                         char *__buf ,
                                                                         size_t __buflen ) ;
#line 290 "/usr/include/x86_64-linux-gnu/bits/unistd.h"
__inline extern int ( __attribute__((__warn_unused_result__, __nonnull__(2), __leaf__,
__artificial__, __always_inline__)) ttyname_r)(int __fd , char *__buf , size_t __buflen ) 
{ 
  unsigned long tmp ;
  int tmp___0 ;
  unsigned long tmp___1 ;
  int tmp___2 ;
  unsigned long tmp___3 ;
  unsigned long tmp___4 ;
  int tmp___5 ;

  {
#line 293
  tmp___4 = __builtin_object_size((void *)__buf, 1);
#line 293
  if (tmp___4 != 0xffffffffffffffffUL) {
#line 296
    tmp = __builtin_object_size((void *)__buf, 1);
#line 296
    tmp___0 = __ttyname_r_chk(__fd, __buf, __buflen, tmp);
#line 296
    return (tmp___0);
#line 298
    tmp___3 = __builtin_object_size((void *)__buf, 1);
#line 298
    if (__buflen > tmp___3) {
#line 299
      tmp___1 = __builtin_object_size((void *)__buf, 1);
#line 299
      tmp___2 = __ttyname_r_chk_warn(__fd, __buf, __buflen, tmp___1);
#line 299
      return (tmp___2);
    }
  }
#line 301
  tmp___5 = __ttyname_r_alias(__fd, __buf, __buflen);
#line 301
  return (tmp___5);
}
}
#line 306
extern int ( __attribute__((__nonnull__(1))) __getlogin_r_chk)(char *__buf , size_t __buflen ,
                                                               size_t __nreal ) ;
#line 308
extern int ( __attribute__((__nonnull__(1))) __getlogin_r_alias)(char *__buf , size_t __buflen )  __asm__("getlogin_r")  ;
#line 310
extern int ( __attribute__((__nonnull__(1))) __getlogin_r_chk_warn)(char *__buf ,
                                                                    size_t __buflen ,
                                                                    size_t __nreal )  __asm__("__getlogin_r_chk") __attribute__((__warning__("getlogin_r called with bigger buflen than size of destination buffer"))) ;
#line 316 "/usr/include/x86_64-linux-gnu/bits/unistd.h"
__inline extern int ( __attribute__((__nonnull__(1), __artificial__, __always_inline__)) getlogin_r)(char *__buf ,
                                                                                                     size_t __buflen ) 
{ 
  unsigned long tmp ;
  int tmp___0 ;
  unsigned long tmp___1 ;
  int tmp___2 ;
  unsigned long tmp___3 ;
  unsigned long tmp___4 ;
  int tmp___5 ;

  {
#line 319
  tmp___4 = __builtin_object_size((void *)__buf, 1);
#line 319
  if (tmp___4 != 0xffffffffffffffffUL) {
#line 322
    tmp = __builtin_object_size((void *)__buf, 1);
#line 322
    tmp___0 = __getlogin_r_chk(__buf, __buflen, tmp);
#line 322
    return (tmp___0);
#line 324
    tmp___3 = __builtin_object_size((void *)__buf, 1);
#line 324
    if (__buflen > tmp___3) {
#line 325
      tmp___1 = __builtin_object_size((void *)__buf, 1);
#line 325
      tmp___2 = __getlogin_r_chk_warn(__buf, __buflen, tmp___1);
#line 325
      return (tmp___2);
    }
  }
#line 327
  tmp___5 = __getlogin_r_alias(__buf, __buflen);
#line 327
  return (tmp___5);
}
}
#line 333
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) __gethostname_chk)(char *__buf ,
                                                                                                        size_t __buflen ,
                                                                                                        size_t __nreal ) ;
#line 335
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) __gethostname_alias)(char *__buf ,
                                                                                                          size_t __buflen )  __asm__("gethostname")  ;
#line 337
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) __gethostname_chk_warn)(char *__buf ,
                                                                                                             size_t __buflen ,
                                                                                                             size_t __nreal )  __asm__("__gethostname_chk") __attribute__((__warning__("gethostname called with bigger buflen than size of destination buffer"))) ;
#line 343
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1),
__leaf__, __artificial__, __always_inline__)) gethostname)(char *__buf , size_t __buflen ) ;
#line 343 "/usr/include/x86_64-linux-gnu/bits/unistd.h"
__inline extern int ( __attribute__((__nonnull__(1), __leaf__, __artificial__, __always_inline__)) gethostname)(char *__buf ,
                                                                                                                size_t __buflen ) 
{ 
  unsigned long tmp ;
  int tmp___0 ;
  unsigned long tmp___1 ;
  int tmp___2 ;
  unsigned long tmp___3 ;
  unsigned long tmp___4 ;
  int tmp___5 ;

  {
#line 346
  tmp___4 = __builtin_object_size((void *)__buf, 1);
#line 346
  if (tmp___4 != 0xffffffffffffffffUL) {
#line 349
    tmp = __builtin_object_size((void *)__buf, 1);
#line 349
    tmp___0 = __gethostname_chk(__buf, __buflen, tmp);
#line 349
    return (tmp___0);
#line 351
    tmp___3 = __builtin_object_size((void *)__buf, 1);
#line 351
    if (__buflen > tmp___3) {
#line 352
      tmp___1 = __builtin_object_size((void *)__buf, 1);
#line 352
      tmp___2 = __gethostname_chk_warn(__buf, __buflen, tmp___1);
#line 352
      return (tmp___2);
    }
  }
#line 354
  tmp___5 = __gethostname_alias(__buf, __buflen);
#line 354
  return (tmp___5);
}
}
#line 360
extern  __attribute__((__nothrow__)) int ( __attribute__((__warn_unused_result__,
__nonnull__(1), __leaf__)) __getdomainname_chk)(char *__buf , size_t __buflen , size_t __nreal ) ;
#line 362
extern  __attribute__((__nothrow__)) int ( __attribute__((__warn_unused_result__,
__nonnull__(1), __leaf__)) __getdomainname_alias)(char *__buf , size_t __buflen )  __asm__("getdomainname")  ;
#line 365
extern  __attribute__((__nothrow__)) int ( __attribute__((__warn_unused_result__,
__nonnull__(1), __leaf__)) __getdomainname_chk_warn)(char *__buf , size_t __buflen ,
                                                     size_t __nreal )  __asm__("__getdomainname_chk") __attribute__((__warning__("getdomainname called with bigger buflen than size of destination buffer"))) ;
#line 372
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__warn_unused_result__,
__nonnull__(1), __leaf__, __artificial__, __always_inline__)) getdomainname)(char *__buf ,
                                                                             size_t __buflen ) ;
#line 372 "/usr/include/x86_64-linux-gnu/bits/unistd.h"
__inline extern int ( __attribute__((__warn_unused_result__, __nonnull__(1), __leaf__,
__artificial__, __always_inline__)) getdomainname)(char *__buf , size_t __buflen ) 
{ 
  unsigned long tmp ;
  int tmp___0 ;
  unsigned long tmp___1 ;
  int tmp___2 ;
  unsigned long tmp___3 ;
  unsigned long tmp___4 ;
  int tmp___5 ;

  {
#line 375
  tmp___4 = __builtin_object_size((void *)__buf, 1);
#line 375
  if (tmp___4 != 0xffffffffffffffffUL) {
#line 378
    tmp = __builtin_object_size((void *)__buf, 1);
#line 378
    tmp___0 = __getdomainname_chk(__buf, __buflen, tmp);
#line 378
    return (tmp___0);
#line 380
    tmp___3 = __builtin_object_size((void *)__buf, 1);
#line 380
    if (__buflen > tmp___3) {
#line 381
      tmp___1 = __builtin_object_size((void *)__buf, 1);
#line 381
      tmp___2 = __getdomainname_chk_warn(__buf, __buflen, tmp___1);
#line 381
      return (tmp___2);
    }
  }
#line 383
  tmp___5 = __getdomainname_alias(__buf, __buflen);
#line 383
  return (tmp___5);
}
}
#line 350 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h"
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__, __always_inline__)) __signbit)(double __x )  __attribute__((__const__)) ;
#line 350
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__, __always_inline__)) __signbitf)(float __x )  __attribute__((__const__)) ;
#line 350
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__, __always_inline__)) __signbitl)(long double __x )  __attribute__((__const__)) ;
#line 126 "/usr/include/x86_64-linux-gnu/bits/mathinline.h"
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__, __always_inline__)) __signbitf)(float __x )  __attribute__((__const__)) ;
#line 126 "/usr/include/x86_64-linux-gnu/bits/mathinline.h"
__inline extern int ( __attribute__((__leaf__, __always_inline__)) __signbitf)(float __x ) 
{ 
  int __m ;

  {
#line 131
  __asm__  ("pmovmskb %1, %0": "=r" (__m): "x" (__x));
#line 132
  return ((__m & 8) != 0);
}
}
#line 138
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__, __always_inline__)) __signbit)(double __x )  __attribute__((__const__)) ;
#line 138 "/usr/include/x86_64-linux-gnu/bits/mathinline.h"
__inline extern int ( __attribute__((__leaf__, __always_inline__)) __signbit)(double __x ) 
{ 
  int __m ;

  {
#line 143
  __asm__  ("pmovmskb %1, %0": "=r" (__m): "x" (__x));
#line 144
  return ((__m & 128) != 0);
}
}
#line 150
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__, __always_inline__)) __signbitl)(long double __x )  __attribute__((__const__)) ;
#line 150 "/usr/include/x86_64-linux-gnu/bits/mathinline.h"
__inline extern int ( __attribute__((__leaf__, __always_inline__)) __signbitl)(long double __x ) 
{ 
  union __anonunion___u_29 __u ;

  {
#line 153
  __u.__l = __x;
#line 154
  return ((__u.__i[2] & 32768) != 0);
}
}
#line 210 "/usr/include/x86_64-linux-gnu/sys/stat.h"
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2),
__leaf__)) stat)(char const   * __restrict  __path , struct stat * __restrict  __statbuf ) ;
#line 215
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2),
__leaf__)) fstat)(int __fd , struct stat *__statbuf ) ;
#line 239
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2,3),
__leaf__)) fstatat)(int __fd , char const   * __restrict  __filename , struct stat * __restrict  __statbuf ,
                    int __flag ) ;
#line 264
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2),
__leaf__)) lstat)(char const   * __restrict  __path , struct stat * __restrict  __statbuf ) ;
#line 337
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1),
__leaf__)) mknod)(char const   *__path , __mode_t __mode , __dev_t __dev ) ;
#line 344
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2),
__leaf__)) mknodat)(int __fd , char const   *__path , __mode_t __mode , __dev_t __dev ) ;
#line 400
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(3), __leaf__)) __fxstat)(int __ver ,
                                                                                               int __fildes ,
                                                                                               struct stat *__stat_buf ) ;
#line 402
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2,3), __leaf__)) __xstat)(int __ver ,
                                                                                                char const   *__filename ,
                                                                                                struct stat *__stat_buf ) ;
#line 404
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2,3), __leaf__)) __lxstat)(int __ver ,
                                                                                                 char const   *__filename ,
                                                                                                 struct stat *__stat_buf ) ;
#line 406
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(3,4), __leaf__)) __fxstatat)(int __ver ,
                                                                                                   int __fildes ,
                                                                                                   char const   *__filename ,
                                                                                                   struct stat *__stat_buf ,
                                                                                                   int __flag ) ;
#line 443
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2,4), __leaf__)) __xmknod)(int __ver ,
                                                                                                 char const   *__path ,
                                                                                                 __mode_t __mode ,
                                                                                                 __dev_t *__dev ) ;
#line 446
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(3,5), __leaf__)) __xmknodat)(int __ver ,
                                                                                                   int __fd ,
                                                                                                   char const   *__path ,
                                                                                                   __mode_t __mode ,
                                                                                                   __dev_t *__dev ) ;
#line 453
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2),
__leaf__)) stat)(char const   * __restrict  __path , struct stat * __restrict  __statbuf ) ;
#line 453 "/usr/include/x86_64-linux-gnu/sys/stat.h"
__inline extern int ( __attribute__((__nonnull__(1,2), __leaf__)) stat)(char const   * __restrict  __path ,
                                                                        struct stat * __restrict  __statbuf ) 
{ 
  int tmp ;

  {
#line 456
  tmp = __xstat(1, (char const   *)__path, (struct stat *)__statbuf);
#line 456
  return (tmp);
}
}
#line 460
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2),
__leaf__)) lstat)(char const   * __restrict  __path , struct stat * __restrict  __statbuf ) ;
#line 460 "/usr/include/x86_64-linux-gnu/sys/stat.h"
__inline extern int ( __attribute__((__nonnull__(1,2), __leaf__)) lstat)(char const   * __restrict  __path ,
                                                                         struct stat * __restrict  __statbuf ) 
{ 
  int tmp ;

  {
#line 463
  tmp = __lxstat(1, (char const   *)__path, (struct stat *)__statbuf);
#line 463
  return (tmp);
}
}
#line 467
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2),
__leaf__)) fstat)(int __fd , struct stat *__statbuf ) ;
#line 467 "/usr/include/x86_64-linux-gnu/sys/stat.h"
__inline extern int ( __attribute__((__nonnull__(2), __leaf__)) fstat)(int __fd ,
                                                                       struct stat *__statbuf ) 
{ 
  int tmp ;

  {
#line 470
  tmp = __fxstat(1, __fd, __statbuf);
#line 470
  return (tmp);
}
}
#line 474
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2,3),
__leaf__)) fstatat)(int __fd , char const   * __restrict  __filename , struct stat * __restrict  __statbuf ,
                    int __flag ) ;
#line 474 "/usr/include/x86_64-linux-gnu/sys/stat.h"
__inline extern int ( __attribute__((__nonnull__(2,3), __leaf__)) fstatat)(int __fd ,
                                                                           char const   * __restrict  __filename ,
                                                                           struct stat * __restrict  __statbuf ,
                                                                           int __flag ) 
{ 
  int tmp ;

  {
#line 478
  tmp = __fxstatat(1, __fd, (char const   *)__filename, (struct stat *)__statbuf,
                   __flag);
#line 478
  return (tmp);
}
}
#line 483
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1),
__leaf__)) mknod)(char const   *__path , __mode_t __mode , __dev_t __dev ) ;
#line 483 "/usr/include/x86_64-linux-gnu/sys/stat.h"
__inline extern int ( __attribute__((__nonnull__(1), __leaf__)) mknod)(char const   *__path ,
                                                                       __mode_t __mode ,
                                                                       __dev_t __dev ) 
{ 
  int tmp ;

  {
#line 486
  tmp = __xmknod(0, __path, __mode, & __dev);
#line 486
  return (tmp);
}
}
#line 491
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2),
__leaf__)) mknodat)(int __fd , char const   *__path , __mode_t __mode , __dev_t __dev ) ;
#line 491 "/usr/include/x86_64-linux-gnu/sys/stat.h"
__inline extern int ( __attribute__((__nonnull__(2), __leaf__)) mknodat)(int __fd ,
                                                                         char const   *__path ,
                                                                         __mode_t __mode ,
                                                                         __dev_t __dev ) 
{ 
  int tmp ;

  {
#line 495
  tmp = __xmknodat(0, __fd, __path, __mode, & __dev);
#line 495
  return (tmp);
}
}
#line 138 "src/bio.h"
int32 bio_readhdr(FILE *fp , char ***argname , char ***argval___0 , int32 *swap ) ;
#line 148
int32 bio_writehdr_version(FILE *fp , char *version ) ;
#line 154
void bio_hdrarg_free(char **argname , char **argval___0 ) ;
#line 162
int32 bio_fread(void *buf , int32 el_sz , int32 n_el , FILE *fp , int32 swap , uint32 *chksum ) ;
#line 177
int32 bio_fread_1d(void **buf , int32 el_sz , int32 *n_el , FILE *fp , int32 sw ,
                   uint32 *ck ) ;
#line 189
void bio_verify_chksum(FILE *fp , int32 byteswap , uint32 chksum ) ;
#line 114 "src/bio.c"
static void bcomment_read(FILE *fp ) 
{ 
  char iline[16384] ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___0 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  char *tmp___6 ;

  {
#line 118
  while (1) {
#line 118
    tmp___6 = fgets((char * __restrict  )(iline), (int )sizeof(iline), (FILE * __restrict  )fp);
#line 118
    if (! ((unsigned long )tmp___6 != (unsigned long )((void *)0))) {
#line 118
      break;
    }
#line 119
    if (0) {
#line 119
      __s1_len = __builtin_strlen((char const   *)(iline));
#line 119
      __s2_len = __builtin_strlen("*end_comment*\n");
#line 119
      if (! ((size_t )((void const   *)(iline + 1)) - (size_t )((void const   *)(iline)) == 1UL)) {
#line 119
        goto _L___0;
      } else
#line 119
      if (__s1_len >= 4UL) {
        _L___0: /* CIL Label */ 
#line 119
        if (! ((size_t )((void const   *)("*end_comment*\n" + 1)) - (size_t )((void const   *)"*end_comment*\n") == 1UL)) {
#line 119
          tmp___5 = 1;
        } else
#line 119
        if (__s2_len >= 4UL) {
#line 119
          tmp___5 = 1;
        } else {
#line 119
          tmp___5 = 0;
        }
      } else {
#line 119
        tmp___5 = 0;
      }
#line 119
      if (tmp___5) {
#line 119
        tmp___0 = __builtin_strcmp((char const   *)(iline), "*end_comment*\n");
#line 119
        tmp___4 = tmp___0;
      } else {
#line 119
        tmp___3 = __builtin_strcmp((char const   *)(iline), "*end_comment*\n");
#line 119
        tmp___4 = tmp___3;
      }
    } else {
#line 119
      tmp___3 = __builtin_strcmp((char const   *)(iline), "*end_comment*\n");
#line 119
      tmp___4 = tmp___3;
    }
#line 119
    if (tmp___4 == 0) {
#line 120
      return;
    }
  }
#line 122
  _E__pr_header("src/bio.c", 122L, "FATAL_ERROR");
#line 122
  _E__die_error("Missing %s marker\n", "*end_comment*\n");
#line 123
  return;
}
}
#line 126 "src/bio.c"
static int32 swap_check(FILE *fp ) 
{ 
  uint32 magic ;
  size_t tmp ;

  {
#line 130
  tmp = fread((void * __restrict  )(& magic), sizeof(uint32 ), (size_t )1, (FILE * __restrict  )fp);
#line 130
  if (tmp != 1UL) {
#line 131
    _E__pr_header("src/bio.c", 131L, "ERROR");
#line 131
    _E__pr_warn("Cannot read BYTEORDER MAGIC NO.\n");
#line 132
    return (-1);
  }
#line 135
  if (magic != 287454020U) {
#line 137
    magic = (((255U & (magic >> 24)) | (65280U & (magic >> 8))) | (16711680U & (magic << 8))) | (4278190080U & (magic << 24));
#line 139
    if (magic == 287454020U) {
#line 140
      return (1);
    }
#line 142
    magic = (((255U & (magic >> 24)) | (65280U & (magic >> 8))) | (16711680U & (magic << 8))) | (4278190080U & (magic << 24));
#line 143
    _E__pr_header("src/bio.c", 143L, "ERROR");
#line 143
    _E__pr_warn("Bad BYTEORDER MAGIC NO: %08x, expecting %08x\n", magic, 287454020);
#line 145
    return (-1);
  }
#line 148
  return (0);
}
}
#line 152 "src/bio.c"
void bio_hdrarg_free(char **argname , char **argval___0 ) 
{ 
  int32 i ;

  {
#line 156
  i = 0;
#line 156
  while (*(argname + i)) {
#line 157
    free((void *)*(argname + i));
#line 158
    free((void *)*(argval___0 + i));
#line 156
    i ++;
  }
#line 160
  free((void *)argname);
#line 161
  free((void *)argval___0);
#line 162
  return;
}
}
#line 165 "src/bio.c"
int32 bio_writehdr_version(FILE *fp , char *version ) 
{ 
  uint32 b ;

  {
#line 169
  fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"s3\n");
#line 170
  fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"version %s\n", version);
#line 171
  fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"endhdr\n");
#line 172
  fflush(fp);
#line 174
  b = (uint32 )287454020;
#line 175
  fwrite((void const   * __restrict  )(& b), sizeof(uint32 ), (size_t )1, (FILE * __restrict  )fp);
#line 176
  fflush(fp);
#line 178
  return (0);
}
}
#line 182 "src/bio.c"
int32 bio_readhdr(FILE *fp , char ***argname , char ***argval___0 , int32 *swap ) 
{ 
  char line[16384] ;
  char word[4096] ;
  int32 i ;
  int32 l ;
  int32 lineno ;
  void *tmp ;
  void *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___5 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int32 tmp___13 ;

  {
#line 188
  tmp = __ckd_calloc__((size_t )33, sizeof(char *), "src/bio.c", 188);
#line 188
  *argname = (char **)tmp;
#line 189
  tmp___0 = __ckd_calloc__((size_t )32, sizeof(char *), "src/bio.c", 189);
#line 189
  *argval___0 = (char **)tmp___0;
#line 191
  lineno = 0;
#line 192
  tmp___1 = fgets((char * __restrict  )(line), (int )sizeof(line), (FILE * __restrict  )fp);
#line 192
  if ((unsigned long )tmp___1 == (unsigned long )((void *)0)) {
#line 193
    _E__pr_header("src/bio.c", 193L, "FATAL_ERROR");
#line 193
    _E__die_error("Premature EOF, line %d\n", lineno);
  }
#line 194
  lineno ++;
#line 196
  if ((int )line[0] == 115) {
#line 196
    if ((int )line[1] == 51) {
#line 196
      if ((int )line[2] == 10) {
#line 198
        i = 0;
#line 198
        while (1) {
#line 199
          tmp___2 = fgets((char * __restrict  )(line), (int )sizeof(line), (FILE * __restrict  )fp);
#line 199
          if ((unsigned long )tmp___2 == (unsigned long )((void *)0)) {
#line 200
            _E__pr_header("src/bio.c", 200L, "FATAL_ERROR");
#line 200
            _E__die_error("Premature EOF, line %d\n", lineno);
          }
#line 201
          lineno ++;
#line 203
          tmp___3 = sscanf((char const   * __restrict  )(line), (char const   * __restrict  )"%s%n",
                           word, & l);
#line 203
          if (tmp___3 != 1) {
#line 204
            _E__pr_header("src/bio.c", 204L, "FATAL_ERROR");
#line 204
            _E__die_error("Header format error, line %d\n", lineno);
          }
#line 205
          if (0) {
#line 205
            __s1_len = __builtin_strlen((char const   *)(word));
#line 205
            __s2_len = __builtin_strlen("endhdr");
#line 205
            if (! ((size_t )((void const   *)(word + 1)) - (size_t )((void const   *)(word)) == 1UL)) {
#line 205
              goto _L___0;
            } else
#line 205
            if (__s1_len >= 4UL) {
              _L___0: /* CIL Label */ 
#line 205
              if (! ((size_t )((void const   *)("endhdr" + 1)) - (size_t )((void const   *)"endhdr") == 1UL)) {
#line 205
                tmp___10 = 1;
              } else
#line 205
              if (__s2_len >= 4UL) {
#line 205
                tmp___10 = 1;
              } else {
#line 205
                tmp___10 = 0;
              }
            } else {
#line 205
              tmp___10 = 0;
            }
#line 205
            if (tmp___10) {
#line 205
              tmp___5 = __builtin_strcmp((char const   *)(word), "endhdr");
#line 205
              tmp___9 = tmp___5;
            } else {
#line 205
              tmp___8 = __builtin_strcmp((char const   *)(word), "endhdr");
#line 205
              tmp___9 = tmp___8;
            }
          } else {
#line 205
            tmp___8 = __builtin_strcmp((char const   *)(word), "endhdr");
#line 205
            tmp___9 = tmp___8;
          }
#line 205
          if (tmp___9 == 0) {
#line 206
            break;
          }
#line 207
          if ((int )word[0] == 35) {
#line 208
            goto __Cont;
          }
#line 210
          if (i >= 32) {
#line 211
            _E__pr_header("src/bio.c", 211L, "FATAL_ERROR");
#line 211
            _E__die_error("Max arg-value limit(%d) exceeded; increase BIO_HDRARG_MAX\n",
                          32);
          }
#line 214
          *(*argname + i) = __ckd_salloc__((char const   *)(word), "src/bio.c", 214);
#line 215
          tmp___11 = sscanf((char const   * __restrict  )(line + l), (char const   * __restrict  )"%s",
                            word);
#line 215
          if (tmp___11 != 1) {
#line 216
            _E__pr_header("src/bio.c", 216L, "FATAL_ERROR");
#line 216
            _E__die_error("Header format error, line %d\n", lineno);
          }
#line 217
          *(*argval___0 + i) = __ckd_salloc__((char const   *)(word), "src/bio.c",
                                              217);
#line 218
          i ++;
          __Cont: /* CIL Label */ ;
        }
      } else {
#line 196
        goto _L___2;
      }
    } else {
#line 196
      goto _L___2;
    }
  } else {
    _L___2: /* CIL Label */ 
#line 222
    tmp___12 = sscanf((char const   * __restrict  )(line), (char const   * __restrict  )"%s",
                      word);
#line 222
    if (tmp___12 != 1) {
#line 223
      _E__pr_header("src/bio.c", 223L, "FATAL_ERROR");
#line 223
      _E__die_error("Header format error, line %d\n", lineno);
    }
#line 225
    *(*argname + 0) = __ckd_salloc__("version", "src/bio.c", 225);
#line 226
    *(*argval___0 + 0) = __ckd_salloc__((char const   *)(word), "src/bio.c", 226);
#line 227
    i = 1;
#line 229
    bcomment_read(fp);
  }
#line 231
  *(*argname + i) = (char *)((void *)0);
#line 233
  tmp___13 = swap_check(fp);
#line 233
  *swap = tmp___13;
#line 233
  if (tmp___13 < 0) {
#line 234
    _E__pr_header("src/bio.c", 234L, "FATAL_ERROR");
#line 234
    _E__die_error("swap_check failed\n");
  }
#line 236
  return (0);
}
}
#line 240 "src/bio.c"
static uint32 chksum_accum(void *buf , int32 el_sz , int32 n_el , uint32 sum___0 ) 
{ 
  int32 i ;
  uint8 *i8 ;
  uint16 *i16 ;
  uint32 *i32 ;

  {
#line 247
  switch (el_sz) {
  case 1: 
#line 249
  i8 = (uint8 *)buf;
#line 250
  i = 0;
#line 250
  while (i < n_el) {
#line 251
    sum___0 = ((sum___0 << 5) | (sum___0 >> 27)) + (unsigned int )*(i8 + i);
#line 250
    i ++;
  }
#line 252
  break;
  case 2: 
#line 254
  i16 = (uint16 *)buf;
#line 255
  i = 0;
#line 255
  while (i < n_el) {
#line 256
    sum___0 = ((sum___0 << 10) | (sum___0 >> 22)) + (unsigned int )*(i16 + i);
#line 255
    i ++;
  }
#line 257
  break;
  case 4: 
#line 259
  i32 = (uint32 *)buf;
#line 260
  i = 0;
#line 260
  while (i < n_el) {
#line 261
    sum___0 = ((sum___0 << 20) | (sum___0 >> 12)) + *(i32 + i);
#line 260
    i ++;
  }
#line 262
  break;
  default: 
#line 264
  _E__pr_header("src/bio.c", 264L, "FATAL_ERROR");
#line 264
  _E__die_error("Unsupported elemsize for checksum: %d\n", el_sz);
#line 265
  break;
  }
#line 268
  return (sum___0);
}
}
#line 272 "src/bio.c"
static void swap_buf(void *buf , int32 el_sz , int32 n_el ) 
{ 
  int32 i ;
  uint16 *buf16 ;
  uint32 *buf32 ;

  {
#line 278
  switch (el_sz) {
  case 1: 
#line 280
  break;
  case 2: 
#line 282
  buf16 = (uint16 *)buf;
#line 283
  i = 0;
#line 283
  while (i < n_el) {
#line 284
    *(buf16 + i) = (uint16 )((255 & ((int )*(buf16 + i) >> 8)) | (65280 & ((int )*(buf16 + i) << 8)));
#line 283
    i ++;
  }
#line 285
  break;
  case 4: 
#line 287
  buf32 = (uint32 *)buf;
#line 288
  i = 0;
#line 288
  while (i < n_el) {
#line 289
    *(buf32 + i) = (((255U & (*(buf32 + i) >> 24)) | (65280U & (*(buf32 + i) >> 8))) | (16711680U & (*(buf32 + i) << 8))) | (4278190080U & (*(buf32 + i) << 24));
#line 288
    i ++;
  }
#line 290
  break;
  default: 
#line 292
  _E__pr_header("src/bio.c", 292L, "FATAL_ERROR");
#line 292
  _E__die_error("Unsupported elemsize for byteswapping: %d\n", el_sz);
#line 293
  break;
  }
#line 295
  return;
}
}
#line 298 "src/bio.c"
int32 bio_fread(void *buf , int32 el_sz , int32 n_el , FILE *fp , int32 swap , uint32 *chksum ) 
{ 
  size_t tmp ;

  {
#line 300
  tmp = fread((void * __restrict  )buf, (size_t )el_sz, (size_t )n_el, (FILE * __restrict  )fp);
#line 300
  if (tmp != (size_t )n_el) {
#line 301
    return (-1);
  }
#line 303
  if (swap) {
#line 304
    swap_buf(buf, el_sz, n_el);
  }
#line 306
  if (chksum) {
#line 307
    *chksum = chksum_accum(buf, el_sz, n_el, *chksum);
  }
#line 309
  return (n_el);
}
}
#line 313 "src/bio.c"
int32 bio_fread_1d(void **buf , int32 el_sz , int32 *n_el , FILE *fp , int32 sw ,
                   uint32 *ck ) 
{ 
  int32 tmp ;
  void *tmp___0 ;
  int32 tmp___1 ;

  {
#line 315
  if (el_sz != 1) {
#line 315
    if (el_sz != 2) {
#line 315
      if (el_sz != 4) {
#line 316
        _E__pr_header("src/bio.c", 316L, "FATAL_ERROR");
#line 316
        _E__die_error("Unsupported elemsize: %d\n", el_sz);
      }
    }
  }
#line 319
  tmp = bio_fread((void *)n_el, (int32 )sizeof(int32 ), 1, fp, sw, ck);
#line 319
  if (tmp != 1) {
#line 320
    _E__pr_header("src/bio.c", 320L, "FATAL_ERROR");
#line 320
    _E__die_error("fread(arraysize) failed\n");
  }
#line 321
  if (*n_el <= 0) {
#line 322
    _E__pr_header("src/bio.c", 322L, "FATAL_ERROR");
#line 322
    _E__die_error("Bad arraysize: %d\n", *n_el);
  }
#line 325
  tmp___0 = __ckd_calloc__((size_t )*n_el, (size_t )el_sz, "src/bio.c", 325);
#line 325
  *buf = tmp___0;
#line 328
  tmp___1 = bio_fread(*buf, el_sz, *n_el, fp, sw, ck);
#line 328
  if (tmp___1 != *n_el) {
#line 329
    _E__pr_header("src/bio.c", 329L, "FATAL_ERROR");
#line 329
    _E__die_error("fread(arraydata) failed\n");
  }
#line 331
  return (*n_el);
}
}
#line 335 "src/bio.c"
void bio_verify_chksum(FILE *fp , int32 byteswap , uint32 chksum ) 
{ 
  uint32 file_chksum ;
  size_t tmp ;

  {
#line 339
  tmp = fread((void * __restrict  )(& file_chksum), sizeof(uint32 ), (size_t )1, (FILE * __restrict  )fp);
#line 339
  if (tmp != 1UL) {
#line 340
    _E__pr_header("src/bio.c", 340L, "FATAL_ERROR");
#line 340
    _E__die_error("fread(chksum) failed\n");
  }
#line 341
  if (byteswap) {
#line 342
    file_chksum = (((255U & (file_chksum >> 24)) | (65280U & (file_chksum >> 8))) | (16711680U & (file_chksum << 8))) | (4278190080U & (file_chksum << 24));
  }
#line 343
  if (file_chksum != chksum) {
#line 344
    _E__pr_header("src/bio.c", 344L, "FATAL_ERROR");
#line 344
    _E__die_error("Checksum error; file-checksum %08x, computed %08x\n", file_chksum,
                  chksum);
  }
#line 346
  return;
}
}
#line 1 "vector.o"
#pragma merger("0","/tmp/cil-5kcJUvDU.i","-g,-O4")
#line 321 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) long ( __attribute__((__leaf__)) random)(void) ;
#line 324
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) srandom)(unsigned int __seed ) ;
#line 109 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h"
extern  __attribute__((__nothrow__)) double ( __attribute__((__leaf__)) log)(double __x ) ;
#line 150 "/usr/include/x86_64-linux-gnu/bits/mathinline.h"
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__, __always_inline__)) __signbitl)(long double __x )  __attribute__((__const__)) ;
#line 150 "/usr/include/x86_64-linux-gnu/bits/mathinline.h"
__inline extern int ( __attribute__((__leaf__, __always_inline__)) __signbitl)(long double __x ) 
{ 
  union __anonunion___u_29___0 __u ;

  {
#line 153
  __u.__l = __x;
#line 154
  return ((__u.__i[2] & 32768) != 0);
}
}
#line 147 "src/profile.h"
void ptmr_start(ptmr_t *tm ) ;
#line 150
void ptmr_stop(ptmr_t *tm ) ;
#line 156
void ptmr_init(ptmr_t *tm ) ;
#line 144 "src/vector.h"
void vector_floor(float32 *vec , int32 len , float64 flr ) ;
#line 148
void vector_nz_floor(float32 *vec , int32 len , float64 flr ) ;
#line 155
float64 vector_sum_norm(float32 *vec , int32 len ) ;
#line 159
void vector_print(FILE *fp , vector_t v , int32 dim ) ;
#line 163
int32 vector_is_zero(float32 *vec , int32 len ) ;
#line 172
int32 vector_maxcomp_int32(int32 *val , int32 len ) ;
#line 173
int32 vector_mincomp_int32(int32 *val , int32 len ) ;
#line 174
int32 vector_maxcomp_float32(float32 *val , int32 len ) ;
#line 175
int32 vector_mincomp_float32(float32 *val , int32 len ) ;
#line 179
void vector_accum(float32 *dst , float32 *src , int32 len ) ;
#line 187
int32 vector_cmp(float32 *v1 , float32 *v2 , int32 len ) ;
#line 194
int32 vector_mean(float32 *mean , float32 **data , int32 n_vec , int32 n_dim ) ;
#line 203
float64 vector_dist_eucl(float32 *v1 , float32 *v2 , int32 len ) ;
#line 220
float64 vector_maha_precomp(float32 *var , int32 len ) ;
#line 230
float64 vector_dist_maha(float32 *vec , float32 *mean , float32 *varinv , float64 loginvdet ,
                         int32 len ) ;
#line 245
float64 vector_vqgen(float32 **data , int32 rows , int32 cols , int32 vqrows , float64 epsilon ,
                     int32 maxiter , float32 **mean , int32 *map ) ;
#line 264
int32 vector_vqlabel(float32 *vec , float32 **mean , int32 rows , int32 cols , float64 *sqerr ) ;
#line 275
float64 vector_pdf_entropy(float32 *p , int32 len ) ;
#line 282
float64 vector_pdf_cross_entropy(float32 *p1 , float32 *p2 , int32 len ) ;
#line 305
void vector_gautbl_alloc(vector_gautbl_t *gautbl , int32 n_gau , int32 veclen ) ;
#line 307
void vector_gautbl_free(vector_gautbl_t *gautbl ) ;
#line 313
void vector_gautbl_var_floor(vector_gautbl_t *gautbl , float64 floor___0 ) ;
#line 320
void vector_gautbl_maha_precomp(vector_gautbl_t *gautbl ) ;
#line 329
void vector_gautbl_eval_logs3(vector_gautbl_t *gautbl , int32 offset , int32 count ,
                              float32 *x___0 , int32 *score ) ;
#line 136 "src/logs3.h"
float64 log_to_logs3_factor(void) ;
#line 139
float64 logs3_to_log(int32 logs3p ) ;
#line 122 "src/vector.c"
float64 vector_sum_norm(float32 *vec , int32 len ) 
{ 
  float64 sum___0 ;
  float64 f ;
  int32 i ;

  {
#line 127
  sum___0 = 0.0;
#line 128
  i = 0;
#line 128
  while (i < len) {
#line 129
    sum___0 += (float64 )*(vec + i);
#line 128
    i ++;
  }
#line 131
  if (sum___0 != 0.0) {
#line 132
    f = 1.0 / sum___0;
#line 133
    i = 0;
#line 133
    while (i < len) {
#line 136
      *(vec + i) = (float32 )((float64 )*(vec + i) * f);
#line 133
      i ++;
    }
  }
#line 139
  return (sum___0);
}
}
#line 143 "src/vector.c"
void vector_floor(float32 *vec , int32 len , float64 flr ) 
{ 
  int32 i ;

  {
#line 147
  i = 0;
#line 147
  while (i < len) {
#line 148
    if ((float64 )*(vec + i) < flr) {
#line 149
      *(vec + i) = (float32 )flr;
    }
#line 147
    i ++;
  }
#line 150
  return;
}
}
#line 153 "src/vector.c"
void vector_nz_floor(float32 *vec , int32 len , float64 flr ) 
{ 
  int32 i ;

  {
#line 157
  i = 0;
#line 157
  while (i < len) {
#line 158
    if ((double )*(vec + i) != 0.0) {
#line 158
      if ((float64 )*(vec + i) < flr) {
#line 159
        *(vec + i) = (float32 )flr;
      }
    }
#line 157
    i ++;
  }
#line 160
  return;
}
}
#line 163 "src/vector.c"
void vector_print(FILE *fp , vector_t v , int32 dim ) 
{ 
  int32 i ;

  {
#line 167
  i = 0;
#line 167
  while (i < dim) {
#line 168
    fprintf((FILE * __restrict  )fp, (char const   * __restrict  )" %11.4e", (double )*(v + i));
#line 167
    i ++;
  }
#line 169
  fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"\n");
#line 170
  fflush(fp);
#line 171
  return;
}
}
#line 174 "src/vector.c"
int32 vector_is_zero(float32 *vec , int32 len ) 
{ 
  int32 i ;

  {
#line 178
  i = 0;
#line 178
  while (1) {
#line 178
    if (i < len) {
#line 178
      if (! ((double )*(vec + i) == 0.0)) {
#line 178
        break;
      }
    } else {
#line 178
      break;
    }
#line 178
    i ++;
  }
#line 179
  return (i == len);
}
}
#line 183 "src/vector.c"
int32 vector_maxcomp_int32(int32 *val , int32 len ) 
{ 
  int32 i ;
  int32 bi ;

  {
#line 187
  bi = 0;
#line 188
  i = 1;
#line 188
  while (i < len) {
#line 189
    if (*(val + i) > *(val + bi)) {
#line 190
      bi = i;
    }
#line 188
    i ++;
  }
#line 192
  return (bi);
}
}
#line 196 "src/vector.c"
int32 vector_mincomp_int32(int32 *val , int32 len ) 
{ 
  int32 i ;
  int32 bi ;

  {
#line 200
  bi = 0;
#line 201
  i = 1;
#line 201
  while (i < len) {
#line 202
    if (*(val + i) < *(val + bi)) {
#line 203
      bi = i;
    }
#line 201
    i ++;
  }
#line 205
  return (bi);
}
}
#line 209 "src/vector.c"
int32 vector_maxcomp_float32(float32 *val , int32 len ) 
{ 
  int32 i ;
  int32 bi ;

  {
#line 213
  bi = 0;
#line 214
  i = 1;
#line 214
  while (i < len) {
#line 215
    if (*(val + i) > *(val + bi)) {
#line 216
      bi = i;
    }
#line 214
    i ++;
  }
#line 218
  return (bi);
}
}
#line 222 "src/vector.c"
int32 vector_mincomp_float32(float32 *val , int32 len ) 
{ 
  int32 i ;
  int32 bi ;

  {
#line 226
  bi = 0;
#line 227
  i = 1;
#line 227
  while (i < len) {
#line 228
    if (*(val + i) < *(val + bi)) {
#line 229
      bi = i;
    }
#line 227
    i ++;
  }
#line 231
  return (bi);
}
}
#line 235 "src/vector.c"
void vector_accum(float32 *dst , float32 *src , int32 len ) 
{ 
  int32 i ;

  {
#line 239
  i = 0;
#line 239
  while (i < len) {
#line 240
    *(dst + i) += *(src + i);
#line 239
    i ++;
  }
#line 241
  return;
}
}
#line 244 "src/vector.c"
int32 vector_cmp(float32 *v1 , float32 *v2 , int32 len ) 
{ 
  int32 i ;

  {
#line 248
  i = 0;
#line 248
  while (i < len) {
#line 249
    if (*(v1 + i) < *(v2 + i)) {
#line 250
      return (-1);
    }
#line 251
    if (*(v1 + i) > *(v2 + i)) {
#line 252
      return (1);
    }
#line 248
    i ++;
  }
#line 255
  return (0);
}
}
#line 259 "src/vector.c"
int32 vector_mean(float32 *mean , float32 **data , int32 n_vec , int32 n_dim ) 
{ 
  int32 i ;
  int32 j ;
  float64 f ;

  {
#line 264
  if (n_vec > 0) {
#line 264
    if (! (n_dim > 0)) {
#line 264
      __assert_fail("(n_vec > 0) && (n_dim > 0)", "src/vector.c", 264U, "vector_mean");
    }
  } else {
#line 264
    __assert_fail("(n_vec > 0) && (n_dim > 0)", "src/vector.c", 264U, "vector_mean");
  }
#line 266
  i = 0;
#line 266
  while (i < n_dim) {
#line 267
    *(mean + i) = (float32 )0.0;
#line 266
    i ++;
  }
#line 269
  i = 0;
#line 269
  while (i < n_vec) {
#line 270
    j = 0;
#line 270
    while (j < n_dim) {
#line 271
      *(mean + j) += *(*(data + i) + j);
#line 270
      j ++;
    }
#line 269
    i ++;
  }
#line 274
  f = 1.0 / (float64 )n_vec;
#line 275
  i = 0;
#line 275
  while (i < n_dim) {
#line 276
    *(mean + i) *= (float32 )f;
#line 275
    i ++;
  }
#line 278
  return (0);
}
}
#line 282 "src/vector.c"
float64 vector_dist_eucl(float32 *v1 , float32 *v2 , int32 len ) 
{ 
  float64 d ;
  int32 i ;

  {
#line 287
  d = 0.0;
#line 288
  i = 0;
#line 288
  while (i < len) {
#line 289
    d += (float64 )((*(v1 + i) - *(v2 + i)) * (*(v1 + i) - *(v2 + i)));
#line 288
    i ++;
  }
#line 291
  return (d);
}
}
#line 295 "src/vector.c"
float64 vector_maha_precomp(float32 *var , int32 len ) 
{ 
  float64 det ;
  int32 i ;
  double tmp ;
  double tmp___0 ;

  {
#line 300
  det = 0.0;
#line 300
  i = 0;
#line 300
  while (i < len) {
#line 301
    tmp = log((double )*(var + i));
#line 301
    det -= tmp;
#line 302
    *(var + i) = (float32 )(1.0 / ((double )*(var + i) * 2.0));
#line 300
    i ++;
  }
#line 304
  tmp___0 = log(2.0 * 3.14159265358979323846);
#line 304
  det -= tmp___0 * (double )len;
#line 306
  return (det * 0.5);
}
}
#line 310 "src/vector.c"
float64 vector_dist_maha(float32 *vec , float32 *mean , float32 *varinv , float64 loginvdet ,
                         int32 len ) 
{ 
  float64 dist ;
  float64 diff ;
  int32 i ;

  {
#line 316
  dist = loginvdet;
#line 317
  i = 0;
#line 317
  while (i < len) {
#line 318
    diff = (float64 )(*(vec + i) - *(mean + i));
#line 319
    dist -= (diff * diff) * (float64 )*(varinv + i);
#line 317
    i ++;
  }
#line 322
  return (dist);
}
}
#line 326 "src/vector.c"
int32 vector_vqlabel(float32 *vec , float32 **mean , int32 rows , int32 cols , float64 *sqerr ) 
{ 
  int32 i ;
  int32 besti ;
  float64 d ;
  float64 bestd ;

  {
#line 331
  if (rows > 0) {
#line 331
    if (! (cols > 0)) {
#line 331
      __assert_fail("(rows > 0) && (cols > 0)", "src/vector.c", 331U, "vector_vqlabel");
    }
  } else {
#line 331
    __assert_fail("(rows > 0) && (cols > 0)", "src/vector.c", 331U, "vector_vqlabel");
  }
#line 333
  bestd = vector_dist_eucl(*(mean + 0), vec, cols);
#line 334
  besti = 0;
#line 336
  i = 1;
#line 336
  while (i < rows) {
#line 337
    d = vector_dist_eucl(*(mean + i), vec, cols);
#line 338
    if (bestd > d) {
#line 339
      bestd = d;
#line 340
      besti = i;
    }
#line 336
    i ++;
  }
#line 344
  if (sqerr) {
#line 345
    *sqerr = bestd;
  }
#line 347
  return (besti);
}
}
#line 356 "src/vector.c"
static uint32 seed  =    (uint32 )1;
#line 351 "src/vector.c"
float64 vector_vqgen(float32 **data , int32 rows , int32 cols , int32 vqrows , float64 epsilon ,
                     int32 maxiter , float32 **mean , int32 *map ) 
{ 
  int32 i ;
  int32 j ;
  int32 r ;
  int32 it ;
  float64 sqerr ;
  float64 prev_sqerr ;
  float64 t ;
  bitvec_t sel ;
  int32 *count ;
  float32 *gmean ;
  ptmr_t tm ;
  void *tmp ;
  long tmp___0 ;
  long tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;

  {
#line 357
  prev_sqerr = (float64 )0;
#line 363
  if (rows >= vqrows) {
#line 363
    if (maxiter >= 0) {
#line 363
      if (! (epsilon > 0.0)) {
#line 363
        __assert_fail("(rows >= vqrows) && (maxiter >= 0) && (epsilon > 0.0)", "src/vector.c",
                      363U, "vector_vqgen");
      }
    } else {
#line 363
      __assert_fail("(rows >= vqrows) && (maxiter >= 0) && (epsilon > 0.0)", "src/vector.c",
                    363U, "vector_vqgen");
    }
  } else {
#line 363
    __assert_fail("(rows >= vqrows) && (maxiter >= 0) && (epsilon > 0.0)", "src/vector.c",
                  363U, "vector_vqgen");
  }
#line 365
  tmp = __ckd_calloc__((size_t )((rows + 31) >> 5), sizeof(uint32 ), "src/vector.c",
                       365);
#line 365
  sel = (bitvec_t )tmp;
#line 367
  ptmr_init(& tm);
#line 368
  ptmr_start(& tm);
#line 372
  srandom(seed);
#line 373
  tmp___0 = random();
#line 373
  seed = (uint32 )((long )seed ^ tmp___0);
#line 377
  i = 0;
#line 377
  while (i < vqrows) {
#line 381
    tmp___1 = random();
#line 381
    r = (int32 )((tmp___1 & 2147483647L) % (long )rows);
#line 385
    while (*(sel + (r >> 5)) & (unsigned int )(1 << (r & 31))) {
#line 386
      r ++;
#line 386
      if (r >= rows) {
#line 387
        r = 0;
      }
    }
#line 389
    *(sel + (r >> 5)) |= (unsigned int )(1 << (r & 31));
#line 391
    memcpy((void * __restrict  )((void *)*(mean + i)), (void const   * __restrict  )((void *)*(data + r)),
           (unsigned long )cols * sizeof(float32 ));
#line 377
    i ++;
  }
#line 394
  free((void *)((char *)sel));
#line 396
  tmp___2 = __ckd_calloc__((size_t )vqrows, sizeof(int32 ), "src/vector.c", 396);
#line 396
  count = (int32 *)tmp___2;
#line 399
  tmp___3 = __ckd_calloc__((size_t )cols, sizeof(float32 ), "src/vector.c", 399);
#line 399
  gmean = (float32 *)tmp___3;
#line 400
  vector_mean(gmean, mean, vqrows, cols);
#line 402
  it = 0;
#line 402
  while (1) {
#line 404
    sqerr = 0.0;
#line 405
    i = 0;
#line 405
    while (i < rows) {
#line 406
      *(map + i) = vector_vqlabel(*(data + i), mean, vqrows, cols, & t);
#line 407
      sqerr += t;
#line 405
      i ++;
    }
#line 409
    ptmr_stop(& tm);
#line 411
    if (it == 0) {
#line 412
      _E__pr_info_header("src/vector.c", 412L, "INFO");
#line 412
      _E__pr_info("Iter %4d: %.1fs CPU; sqerr= %e\n", it, tm.t_cpu, sqerr);
    } else {
#line 414
      _E__pr_info_header("src/vector.c", 414L, "INFO");
#line 414
      _E__pr_info("Iter %4d: %.1fs CPU; sqerr= %e; delta= %e\n", it, tm.t_cpu, sqerr,
                  (prev_sqerr - sqerr) / prev_sqerr);
    }
#line 418
    if (sqerr == 0.0) {
#line 420
      break;
    } else
#line 418
    if (it >= maxiter - 1) {
#line 420
      break;
    } else
#line 418
    if (it > 0) {
#line 418
      if ((prev_sqerr - sqerr) / prev_sqerr < epsilon) {
#line 420
        break;
      }
    }
#line 421
    prev_sqerr = sqerr;
#line 423
    ptmr_start(& tm);
#line 426
    i = 0;
#line 426
    while (i < vqrows) {
#line 427
      j = 0;
#line 427
      while (j < cols) {
#line 428
        *(*(mean + i) + j) = (float32 )0.0;
#line 427
        j ++;
      }
#line 429
      *(count + i) = 0;
#line 426
      i ++;
    }
#line 431
    i = 0;
#line 431
    while (i < rows) {
#line 432
      vector_accum(*(mean + *(map + i)), *(data + i), cols);
#line 433
      (*(count + *(map + i))) ++;
#line 431
      i ++;
    }
#line 435
    i = 0;
#line 435
    while (i < vqrows) {
#line 436
      if (*(count + i) > 1) {
#line 437
        t = 1.0 / (float64 )*(count + i);
#line 438
        j = 0;
#line 438
        while (j < cols) {
#line 440
          *(*(mean + i) + j) = (float32 )((float64 )*(*(mean + i) + j) * t);
#line 438
          j ++;
        }
      } else
#line 441
      if (*(count + i) == 0) {
#line 442
        _E__pr_header("src/vector.c", 442L, "ERROR");
#line 442
        _E__pr_warn("Iter %d: mean[%d] unmapped\n", it, i);
#line 443
        memcpy((void * __restrict  )*(mean + i), (void const   * __restrict  )gmean,
               (unsigned long )cols * sizeof(float32 ));
      }
#line 435
      i ++;
    }
#line 402
    it ++;
  }
#line 448
  free((void *)count);
#line 449
  free((void *)gmean);
#line 451
  return (sqerr);
}
}
#line 455 "src/vector.c"
float64 vector_pdf_entropy(float32 *p , int32 len ) 
{ 
  float64 sum___0 ;
  int32 i ;
  double tmp ;
  double tmp___0 ;

  {
#line 460
  sum___0 = 0.0;
#line 462
  i = 0;
#line 462
  while (i < len) {
#line 463
    if ((double )*(p + i) > 0.0) {
#line 464
      tmp = log((double )*(p + i));
#line 464
      sum___0 -= (double )*(p + i) * tmp;
    }
#line 462
    i ++;
  }
#line 466
  tmp___0 = log(2.0);
#line 466
  sum___0 /= tmp___0;
#line 468
  return (sum___0);
}
}
#line 472 "src/vector.c"
float64 vector_pdf_cross_entropy(float32 *p1 , float32 *p2 , int32 len ) 
{ 
  float64 sum___0 ;
  int32 i ;
  double tmp ;
  double tmp___0 ;

  {
#line 477
  sum___0 = 0.0;
#line 478
  i = 0;
#line 478
  while (i < len) {
#line 479
    if ((double )*(p2 + i) > 0.0) {
#line 480
      tmp = log((double )*(p2 + i));
#line 480
      sum___0 -= (double )*(p1 + i) * tmp;
    }
#line 478
    i ++;
  }
#line 482
  tmp___0 = log(2.0);
#line 482
  sum___0 /= tmp___0;
#line 484
  return (sum___0);
}
}
#line 487 "src/vector.c"
void vector_gautbl_alloc(vector_gautbl_t *gautbl , int32 n_gau , int32 veclen ) 
{ 
  int32 tmp ;
  void **tmp___0 ;
  void **tmp___1 ;
  void *tmp___2 ;

  {
#line 490
  gautbl->n_gau = n_gau;
#line 491
  gautbl->veclen = veclen;
#line 493
  if (veclen % 4) {
#line 493
    tmp = (veclen + 4) - veclen % 4;
  } else {
#line 493
    tmp = veclen;
  }
#line 494
  tmp___0 = __ckd_calloc_2d__a(n_gau, tmp, (int32 )sizeof(float32 ), "src/vector.c",
                               494);
#line 494
  gautbl->mean = (float32 **)tmp___0;
#line 495
  tmp___1 = __ckd_calloc_2d__a(n_gau, tmp, (int32 )sizeof(float32 ), "src/vector.c",
                               495);
#line 495
  gautbl->var = (float32 **)tmp___1;
#line 501
  tmp___2 = __ckd_calloc__((size_t )n_gau, sizeof(float32 ), "src/vector.c", 501);
#line 501
  gautbl->lrd = (float32 *)tmp___2;
#line 502
  gautbl->distfloor = logs3_to_log((int32 )3355443200U);
#line 503
  return;
}
}
#line 506 "src/vector.c"
void vector_gautbl_free(vector_gautbl_t *gautbl ) 
{ 


  {
#line 508
  ckd_free_2da((void **)gautbl->mean);
#line 509
  ckd_free_2da((void **)gautbl->var);
#line 510
  free((void *)gautbl->lrd);
#line 511
  return;
}
}
#line 514 "src/vector.c"
void vector_gautbl_var_floor(vector_gautbl_t *gautbl , float64 floor___0 ) 
{ 
  int32 g ;

  {
#line 518
  g = 0;
#line 518
  while (g < gautbl->n_gau) {
#line 519
    vector_floor(*(gautbl->var + g), gautbl->veclen, floor___0);
#line 518
    g ++;
  }
#line 520
  return;
}
}
#line 523 "src/vector.c"
void vector_gautbl_maha_precomp(vector_gautbl_t *gautbl ) 
{ 
  int32 g ;
  float64 tmp ;

  {
#line 527
  g = 0;
#line 527
  while (g < gautbl->n_gau) {
#line 528
    tmp = vector_maha_precomp(*(gautbl->var + g), gautbl->veclen);
#line 528
    *(gautbl->lrd + g) = (float32 )tmp;
#line 527
    g ++;
  }
#line 529
  return;
}
}
#line 667 "src/vector.c"
float64 vector_gautbl_eval_logs3_inner(vector_gautbl_t *gautbl , int32 const   r ,
                                       float32 const   *x___0 ) 
{ 
  float32 *m1 ;
  float32 *v1 ;
  float64 dval1 ;
  float64 vdiff[4] ;
  float64 vdval[4] ;
  int32 veclen ;
  int32 i ;

  {
#line 674
  m1 = *(gautbl->mean + r);
#line 675
  v1 = *(gautbl->var + r);
#line 676
  dval1 = (float64 )*(gautbl->lrd + r);
#line 677
  veclen = gautbl->veclen;
#line 680
  vdval[3] = 0.0;
#line 680
  vdval[2] = vdval[3];
#line 680
  vdval[1] = vdval[2];
#line 680
  vdval[0] = vdval[1];
#line 683
  if (veclen % 4) {
#line 683
    veclen = (veclen + 4) - veclen % 4;
  } else {
#line 683
    veclen = veclen;
  }
#line 684
  i = 0;
#line 684
  while (i < veclen) {
#line 688
    vdiff[0] = (float64 )(*(x___0 + i) - (float32 const   )*(m1 + i));
#line 689
    vdval[0] += (vdiff[0] * vdiff[0]) * (float64 )*(v1 + i);
#line 691
    vdiff[1] = (float64 )(*(x___0 + (i + 1)) - (float32 const   )*(m1 + (i + 1)));
#line 692
    vdval[1] += (vdiff[1] * vdiff[1]) * (float64 )*(v1 + (i + 1));
#line 694
    vdiff[2] = (float64 )(*(x___0 + (i + 2)) - (float32 const   )*(m1 + (i + 2)));
#line 695
    vdval[2] += (vdiff[2] * vdiff[2]) * (float64 )*(v1 + (i + 2));
#line 697
    vdiff[3] = (float64 )(*(x___0 + (i + 3)) - (float32 const   )*(m1 + (i + 3)));
#line 698
    vdval[3] += (vdiff[3] * vdiff[3]) * (float64 )*(v1 + (i + 3));
#line 684
    i += 4;
  }
#line 736
  dval1 -= ((vdval[0] + vdval[1]) + vdval[2]) + vdval[3];
#line 745
  return (dval1);
}
}
#line 751 "src/vector.c"
void vector_gautbl_eval_logs3(vector_gautbl_t *gautbl , int32 offset , int32 count ,
                              float32 *x___0 , int32 *score ) 
{ 
  int32 r ;
  float64 f ;
  int32 end ;
  float64 dval1 ;

  {
#line 763
  f = log_to_logs3_factor();
#line 766
  end = offset + count;
#line 767
  r = offset;
#line 767
  while (r < end) {
#line 769
    dval1 = vector_gautbl_eval_logs3_inner(gautbl, (int32 const   )r, (float32 const   *)x___0);
#line 771
    if (dval1 < gautbl->distfloor) {
#line 772
      dval1 = gautbl->distfloor;
    }
#line 774
    *(score + r) = (int32 )(f * dval1);
#line 767
    r ++;
  }
#line 777
  return;
}
}
#line 1 "logs3.o"
#pragma merger("0","/tmp/cil-Ao5c96U2.i","-g,-O4")
#line 100 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h"
extern  __attribute__((__nothrow__)) double ( __attribute__((__leaf__)) exp)(double __x ) ;
#line 112
extern  __attribute__((__nothrow__)) double ( __attribute__((__leaf__)) log10)(double __x ) ;
#line 154
extern  __attribute__((__nothrow__)) double ( __attribute__((__leaf__)) pow)(double __x ,
                                                                             double __y ) ;
#line 150 "/usr/include/x86_64-linux-gnu/bits/mathinline.h"
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__, __always_inline__)) __signbitl)(long double __x )  __attribute__((__const__)) ;
#line 150 "/usr/include/x86_64-linux-gnu/bits/mathinline.h"
__inline extern int ( __attribute__((__leaf__, __always_inline__)) __signbitl)(long double __x ) 
{ 
  union __anonunion___u_29___1 __u ;

  {
#line 153
  __u.__l = __x;
#line 154
  return ((__u.__i[2] & 32768) != 0);
}
}
#line 124 "src/logs3.h"
int32 logs3_init(float64 base ) ;
#line 127
int32 logs3_add(int32 logp , int32 logq ) ;
#line 130
int32 logs3(float64 p ) ;
#line 133
int32 log_to_logs3(float64 logp ) ;
#line 142
float64 logs3_to_p(int32 logs3p ) ;
#line 145
int32 log10_to_logs3(float64 log10p ) ;
#line 148
void logs_free(void) ;
#line 115 "src/logs3.c"
static int USE_LOG3_ADD_TABLE  =    1;
#line 116 "src/logs3.c"
static float64 F  =    (float64 )0;
#line 137 "src/logs3.c"
static float64 B  ;
#line 137 "src/logs3.c"
static float64 logB  ;
#line 137 "src/logs3.c"
static float64 invlogB  ;
#line 137 "src/logs3.c"
static float64 invlog10B  ;
#line 138 "src/logs3.c"
static uint16 *add_tbl  =    (uint16 *)((void *)0);
#line 139 "src/logs3.c"
static int32 add_tbl_size  ;
#line 142 "src/logs3.c"
int32 logs3_init(float64 base ) 
{ 
  int32 i ;
  int32 k___0 ;
  float64 d ;
  float64 t ;
  float64 f ;
  void const   *tmp ;
  double tmp___0 ;
  double tmp___1 ;
  double tmp___2 ;
  void *tmp___3 ;
  double tmp___4 ;

  {
#line 148
  tmp = cmd_ln_access((char *)"-log3table");
#line 148
  USE_LOG3_ADD_TABLE = *((int32 *)tmp);
#line 150
  _E__pr_info_header("src/logs3.c", 150L, "INFO");
#line 150
  _E__pr_info("Initializing logbase: %e (add table: %d)\n", base, USE_LOG3_ADD_TABLE);
#line 152
  if (base <= 1.0) {
#line 153
    _E__pr_header("src/logs3.c", 153L, "FATAL_ERROR");
#line 153
    _E__die_error("Illegal logbase: %e; must be > 1.0\n", base);
  }
#line 155
  if (add_tbl) {
#line 156
    if (B == base) {
#line 157
      _E__pr_header("src/logs3.c", 157L, "WARNING");
#line 157
      _E__pr_warn("logs3_init() already done\n");
    } else {
#line 159
      _E__pr_header("src/logs3.c", 159L, "FATAL_ERROR");
#line 159
      _E__die_error("logs3_init() already done with base %e\n", B);
    }
  }
#line 162
  B = base;
#line 163
  logB = log(base);
#line 164
  invlogB = 1.0 / logB;
#line 165
  tmp___0 = log10(base);
#line 165
  invlog10B = 1.0 / tmp___0;
#line 169
  tmp___1 = log(2.0);
#line 169
  k___0 = (int32 )(tmp___1 * invlogB + 0.5);
#line 170
  if (k___0 > 65535) {
#line 171
    _E__pr_header("src/logs3.c", 171L, "ERROR");
#line 171
    _E__pr_warn("Logbase too small: %e; needs int32 addtable[]\n", base);
#line 172
    return (-1);
  }
#line 175
  d = 1.0;
#line 176
  f = 1.0 / B;
#line 177
  F = 1.0 / B;
#line 180
  i = 0;
#line 180
  while (1) {
#line 181
    tmp___2 = log(1.0 + d);
#line 181
    t = tmp___2 * invlogB;
#line 182
    k___0 = (int32 )(t + 0.5);
#line 189
    if (k___0 == 0) {
#line 190
      break;
    }
#line 192
    d *= f;
#line 180
    i ++;
  }
#line 195
  add_tbl_size = i + 1;
#line 196
  tmp___3 = __ckd_calloc__((size_t )(i + 1), sizeof(uint16 ), "src/logs3.c", 196);
#line 196
  add_tbl = (uint16 *)tmp___3;
#line 199
  d = 1.0;
#line 200
  i = 0;
#line 200
  while (1) {
#line 201
    tmp___4 = log(1.0 + d);
#line 201
    t = tmp___4 * invlogB;
#line 202
    k___0 = (int32 )(t + 0.5);
#line 204
    *(add_tbl + i) = (uint16 )k___0;
#line 206
    if (k___0 == 0) {
#line 207
      break;
    }
#line 209
    d *= f;
#line 200
    i ++;
  }
#line 212
  _E__pr_info_header("src/logs3.c", 212L, "INFO");
#line 212
  _E__pr_info("Log-Add table size = %d\n", add_tbl_size);
#line 214
  return (0);
}
}
#line 218 "src/logs3.c"
int32 logs3_add(int32 logp , int32 logq ) 
{ 
  int32 d ;
  int32 r ;
  double tmp ;
  double tmp___0 ;

  {
#line 222
  if (! ((unsigned long )add_tbl != (unsigned long )((void *)0))) {
#line 222
    __assert_fail("add_tbl != ((void *)0)", "src/logs3.c", 222U, "logs3_add");
  }
#line 224
  if (logp > logq) {
#line 225
    d = logp - logq;
#line 226
    r = logp;
  } else {
#line 228
    d = logq - logp;
#line 229
    r = logq;
  }
#line 235
  if (d < add_tbl_size) {
#line 237
    if (USE_LOG3_ADD_TABLE) {
#line 238
      r += (int32 )*(add_tbl + d);
    } else {
#line 241
      tmp = pow(F, (double )d);
#line 241
      tmp___0 = log(1.0 + tmp);
#line 241
      r = (int32 )((double )r + (0.5 + tmp___0 * invlogB));
    }
  }
#line 244
  return (r);
}
}
#line 248 "src/logs3.c"
int32 logs3(float64 p ) 
{ 
  double tmp ;

  {
#line 250
  if (! add_tbl) {
#line 251
    _E__pr_header("src/logs3.c", 251L, "FATAL_ERROR");
#line 251
    _E__die_error("logs3 module not initialized\n");
  }
#line 253
  if (p <= 0.0) {
#line 254
    _E__pr_header("src/logs3.c", 254L, "WARNING");
#line 254
    _E__pr_warn("logs3 argument: %e; using S3_LOGPROB_ZERO\n", p);
#line 255
    return ((int32 )3355443200U);
  }
#line 258
  tmp = log(p);
#line 258
  return ((int32 )(tmp * invlogB));
}
}
#line 262 "src/logs3.c"
int32 log_to_logs3(float64 logp ) 
{ 


  {
#line 264
  if (! add_tbl) {
#line 265
    _E__pr_header("src/logs3.c", 265L, "FATAL_ERROR");
#line 265
    _E__die_error("logs3 module not initialized\n");
  }
#line 267
  return ((int32 )(logp * invlogB));
}
}
#line 271 "src/logs3.c"
float64 log_to_logs3_factor(void) 
{ 


  {
#line 273
  return (invlogB);
}
}
#line 277 "src/logs3.c"
float64 logs3_to_log(int32 logs3p ) 
{ 


  {
#line 279
  if (! add_tbl) {
#line 280
    _E__pr_header("src/logs3.c", 280L, "FATAL_ERROR");
#line 280
    _E__die_error("logs3 module not initialized\n");
  }
#line 282
  return ((float64 )logs3p * logB);
}
}
#line 286 "src/logs3.c"
float64 logs3_to_p(int32 logs3p ) 
{ 
  double tmp ;

  {
#line 288
  tmp = exp((float64 )logs3p * logB);
#line 288
  return (tmp);
}
}
#line 292 "src/logs3.c"
int32 log10_to_logs3(float64 log10p ) 
{ 


  {
#line 294
  if (! add_tbl) {
#line 295
    _E__pr_header("src/logs3.c", 295L, "FATAL_ERROR");
#line 295
    _E__die_error("logs3 module not initialized\n");
  }
#line 297
  return ((int32 )(log10p * invlog10B));
}
}
#line 300 "src/logs3.c"
void logs_free(void) 
{ 


  {
#line 302
  if (add_tbl) {
#line 303
    free((void *)add_tbl);
  }
#line 304
  return;
}
}
#line 1 "hash.o"
#pragma merger("0","/tmp/cil-g0WAp8N9.i","-g,-O4")
#line 201 "src/hash.h"
int32 hash_enter_bkey(hash_table_t *h , char const   *key , int32 len , int32 val ) ;
#line 222
int32 hash_lookup_bkey(hash_table_t *h , char const   *key , int32 len , int32 *val ) ;
#line 231
glist_t hash_tolist(hash_table_t *h , int32 *count ) ;
#line 151 "src/hash.c"
static int32 prime[46]  = 
#line 151 "src/hash.c"
  {      101,      211,      307,      401, 
        503,      601,      701,      809, 
        907,      1009,      1201,      1601, 
        2003,      2411,      3001,      4001, 
        5003,      6007,      7001,      8009, 
        9001,      10007,      12007,      16001, 
        20011,      24001,      30011,      40009, 
        50021,      60013,      70001,      80021, 
        90001,      100003,      120011,      160001, 
        200003,      240007,      300007,      400009, 
        500009,      600011,      700001,      800011, 
        900001,      -1};
#line 160 "src/hash.c"
static int32 prime_size(int32 size ) 
{ 
  int32 i ;

  {
#line 164
  i = 0;
#line 164
  while (1) {
#line 164
    if (prime[i] > 0) {
#line 164
      if (! (prime[i] < size)) {
#line 164
        break;
      }
    } else {
#line 164
      break;
    }
#line 164
    i ++;
  }
#line 165
  if (prime[i] <= 0) {
#line 166
    _E__pr_header("src/hash.c", 166L, "WARNING");
#line 166
    _E__pr_warn("Very large hash table requested (%d entries)\n", size);
#line 167
    i --;
  }
#line 169
  return (prime[i]);
}
}
#line 173 "src/hash.c"
hash_table_t *hash_new(int32 size , int32 casearg ) 
{ 
  hash_table_t *h ;
  void *tmp ;
  void *tmp___0 ;

  {
#line 177
  tmp = __ckd_calloc__((size_t )1, sizeof(hash_table_t ), "src/hash.c", 177);
#line 177
  h = (hash_table_t *)tmp;
#line 178
  h->size = prime_size(size + (size >> 1));
#line 179
  h->nocase = (uint8 )(casearg == 1);
#line 180
  tmp___0 = __ckd_calloc__((size_t )h->size, sizeof(hash_entry_t ), "src/hash.c",
                           180);
#line 180
  h->table = (hash_entry_t *)tmp___0;
#line 183
  return (h);
}
}
#line 191 "src/hash.c"
static uint32 key2hash(hash_table_t *h , char const   *key ) 
{ 
  register char const   *cp ;
  register char c ;
  register int32 s___0 ;
  register uint32 hash ;

  {
#line 198
  hash = (uint32 )0;
#line 199
  s___0 = 0;
#line 201
  if (h->nocase) {
#line 202
    cp = key;
#line 202
    while (*cp) {
#line 203
      c = (char )*cp;
#line 204
      if ((int )c >= 97) {
#line 204
        if ((int )c <= 122) {
#line 204
          c = (char )((int )c - 32);
        } else {
#line 204
          c = c;
        }
      } else {
#line 204
        c = c;
      }
#line 205
      hash += (uint32 )((int )c << s___0);
#line 206
      s___0 += 5;
#line 207
      if (s___0 >= 25) {
#line 208
        s___0 -= 24;
      }
#line 202
      cp ++;
    }
  } else {
#line 211
    cp = key;
#line 211
    while (*cp) {
#line 212
      hash += (uint32 )((int const   )*cp << s___0);
#line 213
      s___0 += 5;
#line 214
      if (s___0 >= 25) {
#line 215
        s___0 -= 24;
      }
#line 211
      cp ++;
    }
  }
#line 219
  return (hash % (unsigned int )h->size);
}
}
#line 223 "src/hash.c"
static char *makekey(uint8 *data , int32 len , char *key ) 
{ 
  int32 i ;
  int32 j ;
  void *tmp ;

  {
#line 227
  if (! key) {
#line 228
    tmp = __ckd_calloc__((size_t )(len * 2 + 1), sizeof(char ), "src/hash.c", 228);
#line 228
    key = (char *)tmp;
  }
#line 230
  i = 0;
#line 230
  j = 0;
#line 230
  while (i < len) {
#line 231
    *(key + j) = (char )(65 + ((int )*(data + i) & 15));
#line 232
    *(key + (j + 1)) = (char )(74 + (((int )*(data + i) >> 4) & 15));
#line 230
    i ++;
#line 230
    j += 2;
  }
#line 234
  *(key + j) = (char )'\000';
#line 236
  return (key);
}
}
#line 240 "src/hash.c"
static int32 keycmp_nocase(hash_entry_t *entry , char const   *key ) 
{ 
  char c1 ;
  char c2 ;
  int32 i ;
  char const   *str ;
  char const   *tmp ;
  char const   *tmp___0 ;

  {
#line 246
  str = entry->key;
#line 247
  i = 0;
#line 247
  while (i < entry->len) {
#line 248
    tmp = str;
#line 248
    str ++;
#line 248
    c1 = (char )*tmp;
#line 249
    if ((int )c1 >= 97) {
#line 249
      if ((int )c1 <= 122) {
#line 249
        c1 = (char )((int )c1 - 32);
      } else {
#line 249
        c1 = c1;
      }
    } else {
#line 249
      c1 = c1;
    }
#line 250
    tmp___0 = key;
#line 250
    key ++;
#line 250
    c2 = (char )*tmp___0;
#line 251
    if ((int )c2 >= 97) {
#line 251
      if ((int )c2 <= 122) {
#line 251
        c2 = (char )((int )c2 - 32);
      } else {
#line 251
        c2 = c2;
      }
    } else {
#line 251
      c2 = c2;
    }
#line 252
    if ((int )c1 != (int )c2) {
#line 253
      return ((int )c1 - (int )c2);
    }
#line 247
    i ++;
  }
#line 256
  return (0);
}
}
#line 260 "src/hash.c"
static int32 keycmp_case(hash_entry_t *entry , char const   *key ) 
{ 
  char c1 ;
  char c2 ;
  int32 i ;
  char const   *str ;
  char const   *tmp ;
  char const   *tmp___0 ;

  {
#line 266
  str = entry->key;
#line 267
  i = 0;
#line 267
  while (i < entry->len) {
#line 268
    tmp = str;
#line 268
    str ++;
#line 268
    c1 = (char )*tmp;
#line 269
    tmp___0 = key;
#line 269
    key ++;
#line 269
    c2 = (char )*tmp___0;
#line 270
    if ((int )c1 != (int )c2) {
#line 271
      return ((int )c1 - (int )c2);
    }
#line 267
    i ++;
  }
#line 274
  return (0);
}
}
#line 283 "src/hash.c"
static int32 lookup(hash_table_t *h , uint32 hash , char const   *key , int32 len ,
                    int32 *val ) 
{ 
  hash_entry_t *entry ;
  int32 tmp ;
  int32 tmp___0 ;

  {
#line 287
  entry = h->table + hash;
#line 288
  if ((unsigned long )entry->key == (unsigned long )((void *)0)) {
#line 289
    return (-1);
  }
#line 291
  if (h->nocase) {
#line 292
    while (1) {
#line 292
      if (entry) {
#line 292
        if (! (entry->len != len)) {
#line 292
          tmp = keycmp_nocase(entry, key);
#line 292
          if (! (tmp != 0)) {
#line 292
            break;
          }
        }
      } else {
#line 292
        break;
      }
#line 293
      entry = entry->next;
    }
  } else {
#line 295
    while (1) {
#line 295
      if (entry) {
#line 295
        if (! (entry->len != len)) {
#line 295
          tmp___0 = keycmp_case(entry, key);
#line 295
          if (! (tmp___0 != 0)) {
#line 295
            break;
          }
        }
      } else {
#line 295
        break;
      }
#line 296
      entry = entry->next;
    }
  }
#line 299
  if (entry) {
#line 300
    *val = entry->val;
#line 301
    return (0);
  } else {
#line 303
    return (-1);
  }
}
}
#line 307 "src/hash.c"
int32 hash_lookup(hash_table_t *h , char const   *key , int32 *val ) 
{ 
  uint32 hash ;
  int32 len ;
  size_t tmp ;
  int32 tmp___0 ;

  {
#line 312
  hash = key2hash(h, key);
#line 313
  tmp = strlen(key);
#line 313
  len = (int32 )tmp;
#line 315
  tmp___0 = lookup(h, hash, key, len, val);
#line 315
  return (tmp___0);
}
}
#line 319 "src/hash.c"
int32 hash_lookup_bkey(hash_table_t *h , char const   *key , int32 len , int32 *val ) 
{ 
  uint32 hash ;
  char *str ;
  int32 tmp ;

  {
#line 324
  str = makekey((uint8 *)key, len, (char *)((void *)0));
#line 325
  hash = key2hash(h, (char const   *)str);
#line 326
  free((void *)str);
#line 328
  tmp = lookup(h, hash, key, len, val);
#line 328
  return (tmp);
}
}
#line 332 "src/hash.c"
static int32 enter(hash_table_t *h , uint32 hash , char const   *key , int32 len ,
                   int32 val ) 
{ 
  int32 old ;
  hash_entry_t *cur ;
  hash_entry_t *new ;
  int32 tmp ;
  void *tmp___0 ;

  {
#line 337
  tmp = lookup(h, hash, key, len, & old);
#line 337
  if (tmp == 0) {
#line 339
    return (old);
  }
#line 342
  cur = h->table + hash;
#line 343
  if ((unsigned long )cur->key == (unsigned long )((void *)0)) {
#line 345
    cur->key = key;
#line 346
    cur->len = len;
#line 347
    cur->val = val;
  } else {
#line 350
    tmp___0 = __ckd_calloc__((size_t )1, sizeof(hash_entry_t ), "src/hash.c", 350);
#line 350
    new = (hash_entry_t *)tmp___0;
#line 351
    new->key = key;
#line 352
    new->len = len;
#line 353
    new->val = val;
#line 354
    new->next = cur->next;
#line 355
    cur->next = new;
  }
#line 358
  return (val);
}
}
#line 362 "src/hash.c"
int32 hash_enter(hash_table_t *h , char const   *key , int32 val ) 
{ 
  uint32 hash ;
  int32 len ;
  size_t tmp ;
  int32 tmp___0 ;

  {
#line 367
  hash = key2hash(h, key);
#line 368
  tmp = strlen(key);
#line 368
  len = (int32 )tmp;
#line 369
  tmp___0 = enter(h, hash, key, len, val);
#line 369
  return (tmp___0);
}
}
#line 373 "src/hash.c"
int32 hash_enter_bkey(hash_table_t *h , char const   *key , int32 len , int32 val ) 
{ 
  uint32 hash ;
  char *str ;
  int32 tmp ;

  {
#line 378
  str = makekey((uint8 *)key, len, (char *)((void *)0));
#line 379
  hash = key2hash(h, (char const   *)str);
#line 380
  free((void *)str);
#line 382
  tmp = enter(h, hash, key, len, val);
#line 382
  return (tmp);
}
}
#line 386 "src/hash.c"
glist_t hash_tolist(hash_table_t *h , int32 *count ) 
{ 
  glist_t g ;
  hash_entry_t *e ;
  int32 i ;
  int32 j ;

  {
#line 392
  g = (glist_t )((void *)0);
#line 394
  j = 0;
#line 395
  i = 0;
#line 395
  while (i < h->size) {
#line 396
    e = h->table + i;
#line 398
    if ((unsigned long )e->key != (unsigned long )((void *)0)) {
#line 399
      g = glist_add_ptr(g, (void *)e);
#line 400
      j ++;
#line 402
      e = e->next;
#line 402
      while (e) {
#line 403
        g = glist_add_ptr(g, (void *)e);
#line 404
        j ++;
#line 402
        e = e->next;
      }
    }
#line 395
    i ++;
  }
#line 409
  *count = j;
#line 411
  return (g);
}
}
#line 415 "src/hash.c"
void hash_free(hash_table_t *h ) 
{ 
  hash_entry_t *e ;
  hash_entry_t *e2 ;
  int32 i ;

  {
#line 421
  i = 0;
#line 421
  while (i < h->size) {
#line 422
    e = (h->table + i)->next;
#line 422
    while (e) {
#line 423
      e2 = e->next;
#line 424
      free((void *)e);
#line 422
      e = e2;
    }
#line 421
    i ++;
  }
#line 428
  free((void *)h->table);
#line 429
  free((void *)h);
#line 430
  return;
}
}
#line 1 "heap.o"
#pragma merger("0","/tmp/cil-Pys1ZIs4.i","-g,-O4")
#line 127 "src/heap.h"
heap_t heap_new(void) ;
#line 134
int32 heap_insert(heap_t heap , void *data , int32 val ) ;
#line 143
int32 heap_top(heap_t heap , void **data , int32 *val ) ;
#line 150
int32 heap_pop(heap_t heap , void **data , int32 *val ) ;
#line 157
int32 heap_destroy(heap_t heap ) ;
#line 144 "src/heap.c"
heap_t heap_new(void) 
{ 
  heapnode_t **h ;
  void *tmp ;

  {
#line 148
  tmp = __ckd_calloc__((size_t )1, sizeof(heapnode_t *), "src/heap.c", 148);
#line 148
  h = (heapnode_t **)tmp;
#line 149
  *h = (heapnode_t *)((void *)0);
#line 151
  return ((heap_t )h);
}
}
#line 155 "src/heap.c"
static heapnode_t *subheap_insert(heapnode_t *root , void *data , int32 val ) 
{ 
  heapnode_t *h ;
  void *tmpdata ;
  int32 tmpval ;
  char *tmp ;
  struct heap_s *tmp___0 ;
  int32 tmp___1 ;

  {
#line 161
  if (! root) {
#line 162
    tmp = __mymalloc__((int32 )sizeof(heapnode_t ), (char *)"src/heap.c", 162);
#line 162
    h = (heapnode_t *)tmp;
#line 163
    h->data = data;
#line 164
    h->val = val;
#line 165
    tmp___0 = (struct heap_s *)((void *)0);
#line 165
    h->r = tmp___0;
#line 165
    h->l = tmp___0;
#line 166
    tmp___1 = 0;
#line 166
    h->nr = tmp___1;
#line 166
    h->nl = tmp___1;
#line 167
    return (h);
  }
#line 171
  if (root->val > val) {
#line 172
    tmpdata = root->data;
#line 173
    tmpval = root->val;
#line 174
    root->data = data;
#line 175
    root->val = val;
#line 176
    data = tmpdata;
#line 177
    val = tmpval;
  }
#line 181
  if (root->nl > root->nr) {
#line 182
    root->r = subheap_insert(root->r, data, val);
#line 183
    (root->nr) ++;
  } else {
#line 185
    root->l = subheap_insert(root->l, data, val);
#line 186
    (root->nl) ++;
  }
#line 189
  return (root);
}
}
#line 193 "src/heap.c"
int32 heap_insert(heap_t heap , void *data , int32 val ) 
{ 
  heapnode_t **hp ;

  {
#line 197
  hp = (heapnode_t **)heap;
#line 199
  *hp = subheap_insert(*hp, data, val);
#line 201
  return (0);
}
}
#line 205 "src/heap.c"
static heapnode_t *subheap_pop(heapnode_t *root ) 
{ 
  heapnode_t *l ;
  heapnode_t *r ;

  {
#line 210
  l = root->l;
#line 211
  r = root->r;
#line 213
  if (! l) {
#line 214
    if (! r) {
#line 215
      __myfree__((char *)root, (int32 )sizeof(heapnode_t ), (char *)"src/heap.c",
                 215);
#line 216
      return ((heapnode_t *)((void *)0));
    } else {
#line 218
      root->data = r->data;
#line 219
      root->val = r->val;
#line 220
      root->r = subheap_pop(r);
#line 221
      (root->nr) --;
    }
  } else
#line 224
  if (! r) {
#line 225
    root->data = l->data;
#line 226
    root->val = l->val;
#line 227
    root->l = subheap_pop(l);
#line 228
    (root->nl) --;
  } else
#line 224
  if (l->val < r->val) {
#line 225
    root->data = l->data;
#line 226
    root->val = l->val;
#line 227
    root->l = subheap_pop(l);
#line 228
    (root->nl) --;
  } else {
#line 230
    root->data = r->data;
#line 231
    root->val = r->val;
#line 232
    root->r = subheap_pop(r);
#line 233
    (root->nr) --;
  }
#line 237
  return (root);
}
}
#line 241 "src/heap.c"
int32 heap_pop(heap_t heap , void **data , int32 *val ) 
{ 
  heapnode_t **hp ;
  heapnode_t *h ;

  {
#line 245
  hp = (heapnode_t **)heap;
#line 246
  h = *hp;
#line 248
  if (! h) {
#line 249
    return (0);
  }
#line 251
  *data = h->data;
#line 252
  *val = h->val;
#line 254
  *hp = subheap_pop(h);
#line 256
  return (1);
}
}
#line 260 "src/heap.c"
int32 heap_top(heap_t heap , void **data , int32 *val ) 
{ 
  heapnode_t **hp ;
  heapnode_t *h ;

  {
#line 264
  hp = (heapnode_t **)heap;
#line 265
  h = *hp;
#line 267
  if (! h) {
#line 268
    return (0);
  }
#line 270
  *data = h->data;
#line 271
  *val = h->val;
#line 273
  return (1);
}
}
#line 277 "src/heap.c"
int32 heap_destroy(heap_t heap ) 
{ 
  void *data ;
  int32 val ;
  int32 tmp ;

  {
#line 283
  while (1) {
#line 283
    tmp = heap_pop(heap, & data, & val);
#line 283
    if (! (tmp > 0)) {
#line 283
      break;
    }
  }
#line 284
  free((void *)((char *)heap));
#line 286
  return (0);
}
}
#line 1 "io.o"
#pragma merger("0","/tmp/cil-RuzD0ie_.i","-g,-O4")
#line 237 "/usr/include/stdio.h"
extern int fclose(FILE *__stream ) ;
#line 272
extern FILE *( __attribute__((__warn_unused_result__)) fopen)(char const   * __restrict  __filename ,
                                                              char const   * __restrict  __modes ) ;
#line 873
extern FILE *( __attribute__((__warn_unused_result__)) popen)(char const   *__command ,
                                                              char const   *__modes ) ;
#line 879
extern int pclose(FILE *__stream ) ;
#line 123 "src/io.h"
FILE *fopen_comp(char *file , char *mode , int32 *ispipe ) ;
#line 131
void fclose_comp(FILE *fp , int32 ispipe ) ;
#line 139
FILE *fopen_compchk(char *file , int32 *ispipe ) ;
#line 146
FILE *_myfopen(char *file , char *mode , char *pgm , int32 line ) ;
#line 158
int32 fread_retry(void *pointer , int32 size , int32 num_items , FILE *stream ) ;
#line 165
int32 stat_retry(char *file , struct stat *statbuf ) ;
#line 170
int32 stat_mtime(char *file ) ;
#line 122 "src/io.c"
FILE *fopen_comp(char *file , char *mode , int32 *ispipe ) 
{ 
  char command[16384] ;
  FILE *fp ;
  int32 k___0 ;
  int32 isgz ;
  size_t tmp ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___1 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___8 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  size_t __s1_len___1 ;
  size_t __s2_len___1 ;
  int tmp___15 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  size_t __s1_len___2 ;
  size_t __s2_len___2 ;
  int tmp___22 ;
  int tmp___25 ;
  int tmp___26 ;
  int tmp___27 ;
  size_t __s1_len___3 ;
  size_t __s2_len___3 ;
  int tmp___29 ;
  int tmp___32 ;
  int tmp___33 ;
  int tmp___34 ;
  size_t __s1_len___4 ;
  size_t __s2_len___4 ;
  int tmp___36 ;
  int tmp___39 ;
  int tmp___40 ;
  int tmp___41 ;

  {
#line 128
  tmp = strlen((char const   *)file);
#line 128
  k___0 = (int32 )tmp;
#line 135
  *ispipe = 0;
#line 136
  isgz = 0;
#line 137
  if (k___0 > 2) {
#line 137
    if (0) {
#line 137
      __s1_len___1 = __builtin_strlen((char const   *)((file + k___0) - 2));
#line 137
      __s2_len___1 = __builtin_strlen(".Z");
#line 137
      if (! ((size_t )((void const   *)(((file + k___0) - 2) + 1)) - (size_t )((void const   *)((file + k___0) - 2)) == 1UL)) {
#line 137
        goto _L___4;
      } else
#line 137
      if (__s1_len___1 >= 4UL) {
        _L___4: /* CIL Label */ 
#line 137
        if (! ((size_t )((void const   *)(".Z" + 1)) - (size_t )((void const   *)".Z") == 1UL)) {
#line 137
          tmp___20 = 1;
        } else
#line 137
        if (__s2_len___1 >= 4UL) {
#line 137
          tmp___20 = 1;
        } else {
#line 137
          tmp___20 = 0;
        }
      } else {
#line 137
        tmp___20 = 0;
      }
#line 137
      if (tmp___20) {
#line 137
        tmp___15 = __builtin_strcmp((char const   *)((file + k___0) - 2), ".Z");
#line 137
        tmp___19 = tmp___15;
      } else {
#line 137
        tmp___18 = __builtin_strcmp((char const   *)((file + k___0) - 2), ".Z");
#line 137
        tmp___19 = tmp___18;
      }
    } else {
#line 137
      tmp___18 = __builtin_strcmp((char const   *)((file + k___0) - 2), ".Z");
#line 137
      tmp___19 = tmp___18;
    }
#line 137
    if (tmp___19 == 0) {
#line 138
      *ispipe = 1;
    } else {
#line 137
      if (0) {
#line 137
        __s1_len___2 = __builtin_strlen((char const   *)((file + k___0) - 2));
#line 137
        __s2_len___2 = __builtin_strlen(".z");
#line 137
        if (! ((size_t )((void const   *)(((file + k___0) - 2) + 1)) - (size_t )((void const   *)((file + k___0) - 2)) == 1UL)) {
#line 137
          goto _L___6;
        } else
#line 137
        if (__s1_len___2 >= 4UL) {
          _L___6: /* CIL Label */ 
#line 137
          if (! ((size_t )((void const   *)(".z" + 1)) - (size_t )((void const   *)".z") == 1UL)) {
#line 137
            tmp___27 = 1;
          } else
#line 137
          if (__s2_len___2 >= 4UL) {
#line 137
            tmp___27 = 1;
          } else {
#line 137
            tmp___27 = 0;
          }
        } else {
#line 137
          tmp___27 = 0;
        }
#line 137
        if (tmp___27) {
#line 137
          tmp___22 = __builtin_strcmp((char const   *)((file + k___0) - 2), ".z");
#line 137
          tmp___26 = tmp___22;
        } else {
#line 137
          tmp___25 = __builtin_strcmp((char const   *)((file + k___0) - 2), ".z");
#line 137
          tmp___26 = tmp___25;
        }
      } else {
#line 137
        tmp___25 = __builtin_strcmp((char const   *)((file + k___0) - 2), ".z");
#line 137
        tmp___26 = tmp___25;
      }
#line 137
      if (tmp___26 == 0) {
#line 138
        *ispipe = 1;
      } else {
#line 137
        goto _L___7;
      }
    }
  } else
  _L___7: /* CIL Label */ 
#line 141
  if (k___0 > 3) {
#line 141
    if (0) {
#line 141
      __s1_len = __builtin_strlen((char const   *)((file + k___0) - 3));
#line 141
      __s2_len = __builtin_strlen(".gz");
#line 141
      if (! ((size_t )((void const   *)(((file + k___0) - 3) + 1)) - (size_t )((void const   *)((file + k___0) - 3)) == 1UL)) {
#line 141
        goto _L___0;
      } else
#line 141
      if (__s1_len >= 4UL) {
        _L___0: /* CIL Label */ 
#line 141
        if (! ((size_t )((void const   *)(".gz" + 1)) - (size_t )((void const   *)".gz") == 1UL)) {
#line 141
          tmp___6 = 1;
        } else
#line 141
        if (__s2_len >= 4UL) {
#line 141
          tmp___6 = 1;
        } else {
#line 141
          tmp___6 = 0;
        }
      } else {
#line 141
        tmp___6 = 0;
      }
#line 141
      if (tmp___6) {
#line 141
        tmp___1 = __builtin_strcmp((char const   *)((file + k___0) - 3), ".gz");
#line 141
        tmp___5 = tmp___1;
      } else {
#line 141
        tmp___4 = __builtin_strcmp((char const   *)((file + k___0) - 3), ".gz");
#line 141
        tmp___5 = tmp___4;
      }
    } else {
#line 141
      tmp___4 = __builtin_strcmp((char const   *)((file + k___0) - 3), ".gz");
#line 141
      tmp___5 = tmp___4;
    }
#line 141
    if (tmp___5 == 0) {
#line 142
      *ispipe = 1;
#line 143
      isgz = 1;
    } else {
#line 141
      if (0) {
#line 141
        __s1_len___0 = __builtin_strlen((char const   *)((file + k___0) - 3));
#line 141
        __s2_len___0 = __builtin_strlen(".GZ");
#line 141
        if (! ((size_t )((void const   *)(((file + k___0) - 3) + 1)) - (size_t )((void const   *)((file + k___0) - 3)) == 1UL)) {
#line 141
          goto _L___2;
        } else
#line 141
        if (__s1_len___0 >= 4UL) {
          _L___2: /* CIL Label */ 
#line 141
          if (! ((size_t )((void const   *)(".GZ" + 1)) - (size_t )((void const   *)".GZ") == 1UL)) {
#line 141
            tmp___13 = 1;
          } else
#line 141
          if (__s2_len___0 >= 4UL) {
#line 141
            tmp___13 = 1;
          } else {
#line 141
            tmp___13 = 0;
          }
        } else {
#line 141
          tmp___13 = 0;
        }
#line 141
        if (tmp___13) {
#line 141
          tmp___8 = __builtin_strcmp((char const   *)((file + k___0) - 3), ".GZ");
#line 141
          tmp___12 = tmp___8;
        } else {
#line 141
          tmp___11 = __builtin_strcmp((char const   *)((file + k___0) - 3), ".GZ");
#line 141
          tmp___12 = tmp___11;
        }
      } else {
#line 141
        tmp___11 = __builtin_strcmp((char const   *)((file + k___0) - 3), ".GZ");
#line 141
        tmp___12 = tmp___11;
      }
#line 141
      if (tmp___12 == 0) {
#line 142
        *ispipe = 1;
#line 143
        isgz = 1;
      }
    }
  }
#line 148
  if (*ispipe) {
#line 161
    if (0) {
#line 161
      __s1_len___4 = __builtin_strlen((char const   *)mode);
#line 161
      __s2_len___4 = __builtin_strlen("r");
#line 161
      if (! ((size_t )((void const   *)(mode + 1)) - (size_t )((void const   *)mode) == 1UL)) {
#line 161
        goto _L___11;
      } else
#line 161
      if (__s1_len___4 >= 4UL) {
        _L___11: /* CIL Label */ 
#line 161
        if (! ((size_t )((void const   *)("r" + 1)) - (size_t )((void const   *)"r") == 1UL)) {
#line 161
          tmp___41 = 1;
        } else
#line 161
        if (__s2_len___4 >= 4UL) {
#line 161
          tmp___41 = 1;
        } else {
#line 161
          tmp___41 = 0;
        }
      } else {
#line 161
        tmp___41 = 0;
      }
#line 161
      if (tmp___41) {
#line 161
        tmp___36 = __builtin_strcmp((char const   *)mode, "r");
#line 161
        tmp___40 = tmp___36;
      } else {
#line 161
        tmp___39 = __builtin_strcmp((char const   *)mode, "r");
#line 161
        tmp___40 = tmp___39;
      }
    } else {
#line 161
      tmp___39 = __builtin_strcmp((char const   *)mode, "r");
#line 161
      tmp___40 = tmp___39;
    }
#line 161
    if (tmp___40 == 0) {
#line 162
      if (isgz) {
#line 163
        sprintf((char * __restrict  )(command), (char const   * __restrict  )"gunzip -c %s",
                file);
      } else {
#line 165
        sprintf((char * __restrict  )(command), (char const   * __restrict  )"zcat %s",
                file);
      }
#line 167
      fp = popen((char const   *)(command), (char const   *)mode);
#line 167
      if ((unsigned long )fp == (unsigned long )((void *)0)) {
#line 168
        _E__pr_header("src/io.c", 168L, "SYSTEM_ERROR");
#line 168
        _E__sys_error("popen (%s,%s) failed\n", command, mode);
#line 169
        return ((FILE *)((void *)0));
      }
    } else {
#line 171
      if (0) {
#line 171
        __s1_len___3 = __builtin_strlen((char const   *)mode);
#line 171
        __s2_len___3 = __builtin_strlen("w");
#line 171
        if (! ((size_t )((void const   *)(mode + 1)) - (size_t )((void const   *)mode) == 1UL)) {
#line 171
          goto _L___9;
        } else
#line 171
        if (__s1_len___3 >= 4UL) {
          _L___9: /* CIL Label */ 
#line 171
          if (! ((size_t )((void const   *)("w" + 1)) - (size_t )((void const   *)"w") == 1UL)) {
#line 171
            tmp___34 = 1;
          } else
#line 171
          if (__s2_len___3 >= 4UL) {
#line 171
            tmp___34 = 1;
          } else {
#line 171
            tmp___34 = 0;
          }
        } else {
#line 171
          tmp___34 = 0;
        }
#line 171
        if (tmp___34) {
#line 171
          tmp___29 = __builtin_strcmp((char const   *)mode, "w");
#line 171
          tmp___33 = tmp___29;
        } else {
#line 171
          tmp___32 = __builtin_strcmp((char const   *)mode, "w");
#line 171
          tmp___33 = tmp___32;
        }
      } else {
#line 171
        tmp___32 = __builtin_strcmp((char const   *)mode, "w");
#line 171
        tmp___33 = tmp___32;
      }
#line 171
      if (tmp___33 == 0) {
#line 172
        if (isgz) {
#line 173
          sprintf((char * __restrict  )(command), (char const   * __restrict  )"gzip > %s",
                  file);
        } else {
#line 175
          sprintf((char * __restrict  )(command), (char const   * __restrict  )"compress -c > %s",
                  file);
        }
#line 177
        fp = popen((char const   *)(command), (char const   *)mode);
#line 177
        if ((unsigned long )fp == (unsigned long )((void *)0)) {
#line 178
          _E__pr_header("src/io.c", 178L, "SYSTEM_ERROR");
#line 178
          _E__sys_error("popen (%s,%s) failed\n", command, mode);
#line 179
          return ((FILE *)((void *)0));
        }
      } else {
#line 182
        _E__pr_header("src/io.c", 182L, "ERROR");
#line 182
        _E__pr_warn("fopen_comp not implemented for mode = %s\n", mode);
#line 183
        return ((FILE *)((void *)0));
      }
    }
  } else {
#line 187
    fp = fopen((char const   * __restrict  )file, (char const   * __restrict  )mode);
  }
#line 190
  return (fp);
}
}
#line 194 "src/io.c"
void fclose_comp(FILE *fp , int32 ispipe ) 
{ 


  {
#line 196
  if (ispipe) {
#line 200
    pclose(fp);
  } else {
#line 203
    fclose(fp);
  }
#line 204
  return;
}
}
#line 207 "src/io.c"
FILE *fopen_compchk(char *file , int32 *ispipe ) 
{ 
  char tmpfile___0[16384] ;
  int32 k___0 ;
  int32 isgz ;
  struct stat statbuf ;
  size_t tmp ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___1 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___8 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  size_t __s1_len___1 ;
  size_t __s2_len___1 ;
  int tmp___15 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  size_t __s1_len___2 ;
  size_t __s2_len___2 ;
  int tmp___22 ;
  int tmp___25 ;
  int tmp___26 ;
  int tmp___27 ;
  int tmp___28 ;
  int tmp___29 ;
  int tmp___30 ;
  int tmp___31 ;
  FILE *tmp___32 ;

  {
#line 213
  tmp = strlen((char const   *)file);
#line 213
  k___0 = (int32 )tmp;
#line 220
  *ispipe = 0;
#line 221
  isgz = 0;
#line 222
  if (k___0 > 2) {
#line 222
    if (0) {
#line 222
      __s1_len___1 = __builtin_strlen((char const   *)((file + k___0) - 2));
#line 222
      __s2_len___1 = __builtin_strlen(".Z");
#line 222
      if (! ((size_t )((void const   *)(((file + k___0) - 2) + 1)) - (size_t )((void const   *)((file + k___0) - 2)) == 1UL)) {
#line 222
        goto _L___4;
      } else
#line 222
      if (__s1_len___1 >= 4UL) {
        _L___4: /* CIL Label */ 
#line 222
        if (! ((size_t )((void const   *)(".Z" + 1)) - (size_t )((void const   *)".Z") == 1UL)) {
#line 222
          tmp___20 = 1;
        } else
#line 222
        if (__s2_len___1 >= 4UL) {
#line 222
          tmp___20 = 1;
        } else {
#line 222
          tmp___20 = 0;
        }
      } else {
#line 222
        tmp___20 = 0;
      }
#line 222
      if (tmp___20) {
#line 222
        tmp___15 = __builtin_strcmp((char const   *)((file + k___0) - 2), ".Z");
#line 222
        tmp___19 = tmp___15;
      } else {
#line 222
        tmp___18 = __builtin_strcmp((char const   *)((file + k___0) - 2), ".Z");
#line 222
        tmp___19 = tmp___18;
      }
    } else {
#line 222
      tmp___18 = __builtin_strcmp((char const   *)((file + k___0) - 2), ".Z");
#line 222
      tmp___19 = tmp___18;
    }
#line 222
    if (tmp___19 == 0) {
#line 223
      *ispipe = 1;
    } else {
#line 222
      if (0) {
#line 222
        __s1_len___2 = __builtin_strlen((char const   *)((file + k___0) - 2));
#line 222
        __s2_len___2 = __builtin_strlen(".z");
#line 222
        if (! ((size_t )((void const   *)(((file + k___0) - 2) + 1)) - (size_t )((void const   *)((file + k___0) - 2)) == 1UL)) {
#line 222
          goto _L___6;
        } else
#line 222
        if (__s1_len___2 >= 4UL) {
          _L___6: /* CIL Label */ 
#line 222
          if (! ((size_t )((void const   *)(".z" + 1)) - (size_t )((void const   *)".z") == 1UL)) {
#line 222
            tmp___27 = 1;
          } else
#line 222
          if (__s2_len___2 >= 4UL) {
#line 222
            tmp___27 = 1;
          } else {
#line 222
            tmp___27 = 0;
          }
        } else {
#line 222
          tmp___27 = 0;
        }
#line 222
        if (tmp___27) {
#line 222
          tmp___22 = __builtin_strcmp((char const   *)((file + k___0) - 2), ".z");
#line 222
          tmp___26 = tmp___22;
        } else {
#line 222
          tmp___25 = __builtin_strcmp((char const   *)((file + k___0) - 2), ".z");
#line 222
          tmp___26 = tmp___25;
        }
      } else {
#line 222
        tmp___25 = __builtin_strcmp((char const   *)((file + k___0) - 2), ".z");
#line 222
        tmp___26 = tmp___25;
      }
#line 222
      if (tmp___26 == 0) {
#line 223
        *ispipe = 1;
      } else {
#line 222
        goto _L___7;
      }
    }
  } else
  _L___7: /* CIL Label */ 
#line 226
  if (k___0 > 3) {
#line 226
    if (0) {
#line 226
      __s1_len = __builtin_strlen((char const   *)((file + k___0) - 3));
#line 226
      __s2_len = __builtin_strlen(".gz");
#line 226
      if (! ((size_t )((void const   *)(((file + k___0) - 3) + 1)) - (size_t )((void const   *)((file + k___0) - 3)) == 1UL)) {
#line 226
        goto _L___0;
      } else
#line 226
      if (__s1_len >= 4UL) {
        _L___0: /* CIL Label */ 
#line 226
        if (! ((size_t )((void const   *)(".gz" + 1)) - (size_t )((void const   *)".gz") == 1UL)) {
#line 226
          tmp___6 = 1;
        } else
#line 226
        if (__s2_len >= 4UL) {
#line 226
          tmp___6 = 1;
        } else {
#line 226
          tmp___6 = 0;
        }
      } else {
#line 226
        tmp___6 = 0;
      }
#line 226
      if (tmp___6) {
#line 226
        tmp___1 = __builtin_strcmp((char const   *)((file + k___0) - 3), ".gz");
#line 226
        tmp___5 = tmp___1;
      } else {
#line 226
        tmp___4 = __builtin_strcmp((char const   *)((file + k___0) - 3), ".gz");
#line 226
        tmp___5 = tmp___4;
      }
    } else {
#line 226
      tmp___4 = __builtin_strcmp((char const   *)((file + k___0) - 3), ".gz");
#line 226
      tmp___5 = tmp___4;
    }
#line 226
    if (tmp___5 == 0) {
#line 227
      *ispipe = 1;
#line 228
      isgz = 1;
    } else {
#line 226
      if (0) {
#line 226
        __s1_len___0 = __builtin_strlen((char const   *)((file + k___0) - 3));
#line 226
        __s2_len___0 = __builtin_strlen(".GZ");
#line 226
        if (! ((size_t )((void const   *)(((file + k___0) - 3) + 1)) - (size_t )((void const   *)((file + k___0) - 3)) == 1UL)) {
#line 226
          goto _L___2;
        } else
#line 226
        if (__s1_len___0 >= 4UL) {
          _L___2: /* CIL Label */ 
#line 226
          if (! ((size_t )((void const   *)(".GZ" + 1)) - (size_t )((void const   *)".GZ") == 1UL)) {
#line 226
            tmp___13 = 1;
          } else
#line 226
          if (__s2_len___0 >= 4UL) {
#line 226
            tmp___13 = 1;
          } else {
#line 226
            tmp___13 = 0;
          }
        } else {
#line 226
          tmp___13 = 0;
        }
#line 226
        if (tmp___13) {
#line 226
          tmp___8 = __builtin_strcmp((char const   *)((file + k___0) - 3), ".GZ");
#line 226
          tmp___12 = tmp___8;
        } else {
#line 226
          tmp___11 = __builtin_strcmp((char const   *)((file + k___0) - 3), ".GZ");
#line 226
          tmp___12 = tmp___11;
        }
      } else {
#line 226
        tmp___11 = __builtin_strcmp((char const   *)((file + k___0) - 3), ".GZ");
#line 226
        tmp___12 = tmp___11;
      }
#line 226
      if (tmp___12 == 0) {
#line 227
        *ispipe = 1;
#line 228
        isgz = 1;
      }
    }
  }
#line 233
  strcpy((char * __restrict  )(tmpfile___0), (char const   * __restrict  )file);
#line 234
  tmp___31 = stat((char const   * __restrict  )(tmpfile___0), (struct stat * __restrict  )(& statbuf));
#line 234
  if (tmp___31 != 0) {
#line 236
    _E__pr_header("src/io.c", 236L, "SYSTEM_ERROR");
#line 236
    _E__sys_error("stat(%s) failed\n", tmpfile___0);
#line 238
    if (*ispipe) {
#line 239
      if (isgz) {
#line 240
        tmpfile___0[k___0 - 3] = (char )'\000';
      } else {
#line 242
        tmpfile___0[k___0 - 2] = (char )'\000';
      }
#line 244
      tmp___28 = stat((char const   * __restrict  )(tmpfile___0), (struct stat * __restrict  )(& statbuf));
#line 244
      if (tmp___28 != 0) {
#line 245
        return ((FILE *)((void *)0));
      }
    } else {
#line 247
      strcpy((char * __restrict  )(tmpfile___0 + k___0), (char const   * __restrict  )".gz");
#line 248
      tmp___30 = stat((char const   * __restrict  )(tmpfile___0), (struct stat * __restrict  )(& statbuf));
#line 248
      if (tmp___30 != 0) {
#line 250
        strcpy((char * __restrict  )(tmpfile___0 + k___0), (char const   * __restrict  )".Z");
#line 251
        tmp___29 = stat((char const   * __restrict  )(tmpfile___0), (struct stat * __restrict  )(& statbuf));
#line 251
        if (tmp___29 != 0) {
#line 252
          return ((FILE *)((void *)0));
        }
      }
    }
#line 259
    _E__pr_header("src/io.c", 259L, "WARNING");
#line 259
    _E__pr_warn("Using %s instead of %s\n", tmpfile___0, file);
  }
#line 262
  tmp___32 = fopen_comp(tmpfile___0, (char *)"r", ispipe);
#line 262
  return (tmp___32);
}
}
#line 268 "src/io.c"
int32 fread_retry(void *pointer , int32 size , int32 num_items , FILE *stream ) 
{ 
  char *data ;
  uint32 n_items_read ;
  uint32 n_items_rem ;
  uint32 n_retry_rem ;
  int32 loc ;
  size_t tmp ;

  {
#line 276
  n_retry_rem = (uint32 )60;
#line 278
  data = (char *)pointer;
#line 279
  loc = 0;
#line 280
  n_items_rem = (uint32 )num_items;
#line 282
  while (1) {
#line 283
    tmp = fread((void * __restrict  )(data + loc), (size_t )size, (size_t )n_items_rem,
                (FILE * __restrict  )stream);
#line 283
    n_items_read = (uint32 )tmp;
#line 285
    n_items_rem -= n_items_read;
#line 287
    if (n_items_rem > 0U) {
#line 290
      if (n_retry_rem == 0U) {
#line 291
        return (-1);
      }
#line 293
      if (n_retry_rem == 60U) {
#line 294
        _E__pr_header("src/io.c", 294L, "SYSTEM_ERROR");
#line 294
        _E__sys_error("fread() failed; retrying...\n");
      }
#line 297
      n_retry_rem --;
#line 299
      loc = (int32 )((uint32 )loc + n_items_read * (uint32 )size);
    }
#line 282
    if (! (n_items_rem > 0U)) {
#line 282
      break;
    }
  }
#line 306
  return (num_items);
}
}
#line 312 "src/io.c"
int32 stat_retry(char *file , struct stat *statbuf ) 
{ 
  int32 i ;
  int tmp ;

  {
#line 316
  i = 0;
#line 316
  while (i < 10) {
#line 317
    tmp = stat((char const   * __restrict  )file, (struct stat * __restrict  )statbuf);
#line 317
    if (tmp == 0) {
#line 318
      return (0);
    }
#line 320
    if (i == 0) {
#line 321
      _E__pr_header("src/io.c", 321L, "SYSTEM_ERROR");
#line 321
      _E__sys_error("stat(%s) failed; retrying...\n", file);
    }
#line 316
    i ++;
  }
#line 328
  return (-1);
}
}
#line 332 "src/io.c"
int32 stat_mtime(char *file ) 
{ 
  struct stat statbuf ;
  int tmp ;

  {
#line 336
  tmp = stat((char const   * __restrict  )file, (struct stat * __restrict  )(& statbuf));
#line 336
  if (tmp != 0) {
#line 337
    return (-1);
  }
#line 339
  return ((int32 )statbuf.st_mtim.tv_sec);
}
}
#line 343 "src/io.c"
FILE *_myfopen(char *file , char *mode , char *pgm , int32 line ) 
{ 
  FILE *fp ;
  int *tmp ;

  {
#line 347
  fp = fopen((char const   * __restrict  )file, (char const   * __restrict  )mode);
#line 347
  if ((unsigned long )fp == (unsigned long )((void *)0)) {
#line 348
    fflush(stdout);
#line 349
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"FATAL_ERROR: \"%s\", line %d: fopen(%s,%s) failed; ",
            pgm, line, file, mode);
#line 351
    perror("");
#line 352
    fflush(stderr);
#line 354
    tmp = __errno_location();
#line 354
    exit(*tmp);
  }
#line 357
  return (fp);
}
}
#line 1 "profile.o"
#pragma merger("0","/tmp/cil-DjLOaiUF.i","-g,-O4")
#line 848 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) unlink)(char const   *__name ) ;
#line 72 "/usr/include/x86_64-linux-gnu/sys/time.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) gettimeofday)(struct timeval * __restrict  __tv ,
                                                                                                   __timezone_ptr_t __tz ) ;
#line 88 "/usr/include/x86_64-linux-gnu/sys/resource.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) getrusage)(__rusage_who_t __who ,
                                                                                struct rusage *__usage ) ;
#line 125 "src/profile.h"
void pctr_reset(pctr_t *ctr ) ;
#line 126
void pctr_reset_all(pctr_t *ctr ) ;
#line 127
void pctr_print_all(FILE *fp , pctr_t *ctr ) ;
#line 153
void ptmr_reset(ptmr_t *tm ) ;
#line 163
void ptmr_reset_all(ptmr_t *tm ) ;
#line 169
void ptmr_print_all(FILE *fp , ptmr_t *tm , float64 norm ) ;
#line 176
int32 host_pclk(int32 dummy ) ;
#line 184
int32 host_endian(void) ;
#line 129 "src/profile.c"
void pctr_reset(pctr_t *ctr ) 
{ 


  {
#line 131
  ctr->count = 0;
#line 132
  return;
}
}
#line 135 "src/profile.c"
void pctr_reset_all(pctr_t *ctr ) 
{ 


  {
#line 137
  while (ctr->name) {
#line 138
    pctr_reset(ctr);
#line 137
    ctr ++;
  }
#line 139
  return;
}
}
#line 142 "src/profile.c"
void pctr_print_all(FILE *fp , pctr_t *ctr ) 
{ 


  {
#line 144
  if (! ctr->name) {
#line 145
    return;
  }
#line 147
  fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"CTR:");
#line 148
  while (ctr->name) {
#line 149
    fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"  %d %s", ctr->count,
            ctr->name);
#line 148
    ctr ++;
  }
#line 150
  fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"\n");
#line 151
  return;
}
}
#line 154 "src/profile.c"
int32 host_pclk(int32 dummy ) 
{ 
  int32 mhz ;

  {
#line 156
  mhz = 0;
#line 198
  return (mhz);
}
}
#line 219 "src/profile.c"
static float64 make_sec(struct timeval *s___0 ) 
{ 


  {
#line 221
  return ((double )s___0->tv_sec + (double )s___0->tv_usec * 0.000001);
}
}
#line 227 "src/profile.c"
void ptmr_start(ptmr_t *tm ) 
{ 
  struct timeval e_start ;
  struct rusage start ;
  float64 tmp ;
  float64 tmp___0 ;

  {
#line 236
  getrusage(0, & start);
#line 237
  tmp = make_sec(& start.ru_utime);
#line 237
  tmp___0 = make_sec(& start.ru_stime);
#line 237
  tm->start_cpu = tmp + tmp___0;
#line 240
  gettimeofday((struct timeval * __restrict  )(& e_start), (__timezone_ptr_t )0);
#line 241
  tm->start_elapsed = make_sec(& e_start);
#line 253
  return;
}
}
#line 256 "src/profile.c"
void ptmr_stop(ptmr_t *tm ) 
{ 
  float64 dt_cpu ;
  float64 dt_elapsed ;
  struct timeval e_stop ;
  struct rusage stop ;
  float64 tmp ;
  float64 tmp___0 ;
  float64 tmp___1 ;

  {
#line 267
  getrusage(0, & stop);
#line 268
  tmp = make_sec(& stop.ru_utime);
#line 268
  tmp___0 = make_sec(& stop.ru_stime);
#line 268
  dt_cpu = (tmp + tmp___0) - tm->start_cpu;
#line 273
  gettimeofday((struct timeval * __restrict  )(& e_stop), (__timezone_ptr_t )0);
#line 274
  tmp___1 = make_sec(& e_stop);
#line 274
  dt_elapsed = tmp___1 - tm->start_elapsed;
#line 286
  tm->t_cpu += dt_cpu;
#line 287
  tm->t_elapsed += dt_elapsed;
#line 289
  tm->t_tot_cpu += dt_cpu;
#line 290
  tm->t_tot_elapsed += dt_elapsed;
#line 291
  return;
}
}
#line 294 "src/profile.c"
void ptmr_reset(ptmr_t *tm ) 
{ 


  {
#line 296
  tm->t_cpu = 0.0;
#line 297
  tm->t_elapsed = 0.0;
#line 298
  return;
}
}
#line 301 "src/profile.c"
void ptmr_init(ptmr_t *tm ) 
{ 


  {
#line 303
  tm->t_cpu = 0.0;
#line 304
  tm->t_elapsed = 0.0;
#line 305
  tm->t_tot_cpu = 0.0;
#line 306
  tm->t_tot_elapsed = 0.0;
#line 307
  return;
}
}
#line 310 "src/profile.c"
void ptmr_reset_all(ptmr_t *tm ) 
{ 


  {
#line 312
  while (tm->name) {
#line 313
    ptmr_reset(tm);
#line 312
    tm ++;
  }
#line 314
  return;
}
}
#line 317 "src/profile.c"
void ptmr_print_all(FILE *fp , ptmr_t *tm , float64 norm ) 
{ 


  {
#line 319
  if (norm != 0.0) {
#line 320
    norm = 1.0 / norm;
#line 321
    while (tm->name) {
#line 322
      fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"  %6.2fx %s",
              tm->t_cpu * norm, tm->name);
#line 321
      tm ++;
    }
  }
#line 324
  return;
}
}
#line 327 "src/profile.c"
int32 host_endian(void) 
{ 
  FILE *fp ;
  int32 BYTE_ORDER_MAGIC ;
  char *file ;
  char buf[8] ;
  int32 k___0 ;
  int32 endian ;
  size_t tmp ;
  size_t tmp___0 ;

  {
#line 335
  file = (char *)"/tmp/__EnDiAn_TeSt__";
#line 337
  fp = fopen((char const   * __restrict  )file, (char const   * __restrict  )"wb");
#line 337
  if ((unsigned long )fp == (unsigned long )((void *)0)) {
#line 338
    _E__pr_header("src/profile.c", 338L, "ERROR");
#line 338
    _E__pr_warn("fopen(%s,wb) failed\n", file);
#line 339
    return (-1);
  }
#line 342
  BYTE_ORDER_MAGIC = 287454020;
#line 344
  k___0 = BYTE_ORDER_MAGIC;
#line 345
  tmp = fwrite((void const   * __restrict  )(& k___0), sizeof(int32 ), (size_t )1,
               (FILE * __restrict  )fp);
#line 345
  if (tmp != 1UL) {
#line 346
    _E__pr_header("src/profile.c", 346L, "ERROR");
#line 346
    _E__pr_warn("fwrite(%s) failed\n", file);
#line 347
    fclose(fp);
#line 348
    unlink((char const   *)file);
#line 349
    return (-1);
  }
#line 352
  fclose(fp);
#line 353
  fp = fopen((char const   * __restrict  )file, (char const   * __restrict  )"rb");
#line 353
  if ((unsigned long )fp == (unsigned long )((void *)0)) {
#line 354
    _E__pr_header("src/profile.c", 354L, "ERROR");
#line 354
    _E__pr_warn("fopen(%s,rb) failed\n", file);
#line 355
    unlink((char const   *)file);
#line 356
    return (-1);
  }
#line 358
  tmp___0 = fread((void * __restrict  )(buf), (size_t )1, sizeof(int32 ), (FILE * __restrict  )fp);
#line 358
  if (tmp___0 != sizeof(int32 )) {
#line 359
    _E__pr_header("src/profile.c", 359L, "ERROR");
#line 359
    _E__pr_warn("fread(%s) failed\n", file);
#line 360
    fclose(fp);
#line 361
    unlink((char const   *)file);
#line 362
    return (-1);
  }
#line 364
  fclose(fp);
#line 365
  unlink((char const   *)file);
#line 368
  if ((int )buf[0] == (BYTE_ORDER_MAGIC & 255)) {
#line 368
    endian = 1;
  } else {
#line 368
    endian = 0;
  }
#line 370
  return (endian);
}
}
#line 1 "str2words.o"
#pragma merger("0","/tmp/cil-SYqYVzdf.i","-g,-O4")
#line 80 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) unsigned short const   **( __attribute__((__leaf__)) __ctype_b_loc)(void)  __attribute__((__const__)) ;
#line 82
extern  __attribute__((__nothrow__)) __int32_t const   **( __attribute__((__leaf__)) __ctype_tolower_loc)(void)  __attribute__((__const__)) ;
#line 84
extern  __attribute__((__nothrow__)) __int32_t const   **( __attribute__((__leaf__)) __ctype_toupper_loc)(void)  __attribute__((__const__)) ;
#line 125
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) tolower)(int __c ) ;
#line 128
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) toupper)(int __c ) ;
#line 215
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) tolower)(int __c ) ;
#line 215 "/usr/include/ctype.h"
__inline extern int ( __attribute__((__leaf__)) tolower)(int __c ) 
{ 
  __int32_t const   **tmp ;
  __int32_t tmp___0 ;

  {
#line 218
  if (__c >= -128) {
#line 218
    if (__c < 256) {
#line 218
      tmp = __ctype_tolower_loc();
#line 218
      tmp___0 = *(*tmp + __c);
    } else {
#line 218
      tmp___0 = (__int32_t const   )__c;
    }
  } else {
#line 218
    tmp___0 = (__int32_t const   )__c;
  }
#line 218
  return ((int )tmp___0);
}
}
#line 221
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) toupper)(int __c ) ;
#line 221 "/usr/include/ctype.h"
__inline extern int ( __attribute__((__leaf__)) toupper)(int __c ) 
{ 
  __int32_t const   **tmp ;
  __int32_t tmp___0 ;

  {
#line 224
  if (__c >= -128) {
#line 224
    if (__c < 256) {
#line 224
      tmp = __ctype_toupper_loc();
#line 224
      tmp___0 = *(*tmp + __c);
    } else {
#line 224
      tmp___0 = (__int32_t const   )__c;
    }
  } else {
#line 224
    tmp___0 = (__int32_t const   )__c;
  }
#line 224
  return ((int )tmp___0);
}
}
#line 118 "src/str2words.h"
int32 str2words(char *line , char **ptr , int32 max_ptr ) ;
#line 113 "src/str2words.c"
int32 str2words(char *line , char **ptr , int32 max_ptr ) 
{ 
  int32 i ;
  int32 n ;
  unsigned short const   **tmp ;
  int32 tmp___0 ;
  unsigned short const   **tmp___1 ;
  int32 tmp___2 ;

  {
#line 117
  n = 0;
#line 118
  i = 0;
#line 119
  while (1) {
#line 121
    while (1) {
#line 121
      if (*(line + i)) {
#line 121
        tmp = __ctype_b_loc();
#line 121
        if (! ((int const   )*(*tmp + (int )*(line + i)) & 8192)) {
#line 121
          break;
        }
      } else {
#line 121
        break;
      }
#line 121
      i ++;
    }
#line 122
    if (! *(line + i)) {
#line 123
      break;
    }
#line 125
    if (n >= max_ptr) {
#line 130
      while (i >= 0) {
#line 131
        if ((int )*(line + i) == 0) {
#line 132
          *(line + i) = (char )' ';
        }
#line 130
        i --;
      }
#line 134
      return (-1);
    }
#line 138
    tmp___0 = n;
#line 138
    n ++;
#line 138
    *(ptr + tmp___0) = line + i;
#line 139
    while (1) {
#line 139
      if (*(line + i)) {
#line 139
        tmp___1 = __ctype_b_loc();
#line 139
        if ((int const   )*(*tmp___1 + (int )*(line + i)) & 8192) {
#line 139
          break;
        }
      } else {
#line 139
        break;
      }
#line 139
      i ++;
    }
#line 140
    if (! *(line + i)) {
#line 141
      break;
    }
#line 142
    tmp___2 = i;
#line 142
    i ++;
#line 142
    *(line + tmp___2) = (char )'\000';
  }
#line 145
  return (n);
}
}
#line 1 "unlimit.o"
#pragma merger("0","/tmp/cil-_ibZWf_2.i","-g,-O4")
#line 51 "/usr/include/x86_64-linux-gnu/sys/resource.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) getrlimit)(__rlimit_resource_t __resource ,
                                                                                struct rlimit *__rlimits ) ;
#line 70
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) setrlimit)(__rlimit_resource_t __resource ,
                                                                                struct rlimit  const  *__rlimits ) ;
#line 109 "src/unlimit.h"
void unlimit(void) ;
#line 115 "src/unlimit.c"
void unlimit(void) 
{ 
  struct rlimit rl ;

  {
#line 120
  getrlimit(2, & rl);
#line 121
  rl.rlim_cur = rl.rlim_max;
#line 122
  setrlimit(2, (struct rlimit  const  *)(& rl));
#line 124
  return;
}
}
#line 1 "parse_args_file.o"
#pragma merger("0","/tmp/cil-Benvo2Fg.i","-g,-O4")
#line 759 "/usr/include/stdio.h"
extern void rewind(FILE *__stream ) ;
#line 344 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(2), __leaf__)) strtok)(char * __restrict  __s ,
                                                                                               char const   * __restrict  __delim ) ;
#line 150 "/usr/include/x86_64-linux-gnu/bits/mathinline.h"
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__, __always_inline__)) __signbitl)(long double __x )  __attribute__((__const__)) ;
#line 150 "/usr/include/x86_64-linux-gnu/bits/mathinline.h"
__inline extern int ( __attribute__((__leaf__, __always_inline__)) __signbitl)(long double __x ) 
{ 
  union __anonunion___u_29___2 __u ;

  {
#line 153
  __u.__l = __x;
#line 154
  return ((__u.__i[2] & 32768) != 0);
}
}
#line 89 "src/cmd_ln_args.h"
void parse_args_file(char *live_args ) ;
#line 90
void parse_args_free(void) ;
#line 105 "src/parse_args_file.c"
static arg_t arg[57]  = 
#line 105 "src/parse_args_file.c"
  {      {(char *)"-logbase", 4, (char *)"1.0003", (char *)"Base in which all log-likelihoods calculated"}, 
        {(char *)"-lminmemory",
      2, (char *)"0", (char *)"Load language model into memory (default: use disk cache for lm"}, 
        {(char *)"-log3table",
      2, (char *)"1", (char *)"Determines whether to use the log3 table or to compute the values at run time."}, 
        {(char *)"-vqeval",
      2, (char *)"3", (char *)"How many vectors should be analyzed by VQ when building the shortlist. It speeds up the decoder, but at a cost."}, 
        {(char *)"-cmn",
      8, (char *)"current", (char *)"Cepstral mean normalization scheme (default: Cep -= mean-over-current-sentence(Cep))"}, 
        {(char *)"-varnorm",
      8, (char *)"no", (char *)"Variance normalize each utterance (yes/no; only applicable if CMN is also performed)"}, 
        {(char *)"-agc",
      8, (char *)"max", (char *)"Automatic gain control for c0 (\'max\' or \'none\'); (max: c0 -= max-over-current-sentence(c0))"}, 
        {(char *)"-mdef",
      9, (char *)((void *)0), (char *)"Model definition input file"}, 
        {(char *)"-dict", 9, (char *)((void *)0), (char *)"Pronunciation dictionary input file"}, 
        {(char *)"-fdict",
      9, (char *)((void *)0), (char *)"Filler word pronunciation dictionary input file"}, 
        {(char *)"-lm",
      9, (char *)((void *)0), (char *)"Word trigram language model input file"}, 
        {(char *)"-fillpen", 8, (char *)((void *)0), (char *)"Filler word probabilities input file"}, 
        {(char *)"-silprob",
      4, (char *)"0.1", (char *)"Default silence word probability"}, 
        {(char *)"-fillprob", 4, (char *)"0.1", (char *)"Default non-silence filler word probability"}, 
        {(char *)"-lw",
      4, (char *)"8.5", (char *)"Language weight"}, 
        {(char *)"-wip", 4, (char *)"0.7", (char *)"Word insertion penalty"}, 
        {(char *)"-uw", 4, (char *)"0.7", (char *)"Unigram weight"}, 
        {(char *)"-mean", 9, (char *)((void *)0), (char *)"Mixture gaussian means input file"}, 
        {(char *)"-var",
      9, (char *)((void *)0), (char *)"Mixture gaussian variances input file"}, 
        {(char *)"-varfloor", 4, (char *)"0.0001", (char *)"Mixture gaussian variance floor (applied to data from -var file)"}, 
        {(char *)"-mixw",
      9, (char *)((void *)0), (char *)"Senone mixture weights input file"}, 
        {(char *)"-mixwfloor", 4, (char *)"0.0000001", (char *)"Senone mixture weights floor (applied to data from -mixw file)"}, 
        {(char *)"-subvq",
      8, (char *)((void *)0), (char *)"Sub-vector quantized form of acoustic model"}, 
        {(char *)"-tmat",
      9, (char *)((void *)0), (char *)"HMM state transition matrix input file"}, 
        {(char *)"-tmatfloor", 4, (char *)"0.0001", (char *)"HMM state transition probability floor (applied to -tmat file)"}, 
        {(char *)"-Nlextree",
      2, (char *)"3", (char *)"No. of lextrees to be instantiated; entries into them staggered in time"}, 
        {(char *)"-epl",
      2, (char *)"3", (char *)"Entries Per Lextree; #successive entries into one lextree before lextree-entries shifted to the next"}, 
        {(char *)"-subvqbeam",
      6, (char *)"3.0e-3", (char *)"Beam selecting best components within each mixture Gaussian [0(widest)..1(narrowest)]"}, 
        {(char *)"-beam",
      6, (char *)"1.0e-55", (char *)"Beam selecting active HMMs (relative to best) in each frame [0(widest)..1(narrowest)]"}, 
        {(char *)"-pbeam",
      6, (char *)"1.0e-50", (char *)"Beam selecting HMMs transitioning to successors in each frame [0(widest)..1(narrowest)]"}, 
        {(char *)"-wbeam",
      6, (char *)"1.0e-35", (char *)"Beam selecting word-final HMMs exiting in each frame [0(widest)..1(narrowest)]"}, 
        {(char *)"-ctl",
      8, (char *)((void *)0), (char *)"Control file listing utterances to be processed"}, 
        {(char *)"-utt",
      8, (char *)((void *)0), (char *)"Utterance file to be processed (-ctlcount argument times)"}, 
        {(char *)"-ctloffset",
      2, (char *)"0", (char *)"No. of utterances at the beginning of -ctl file to be skipped"}, 
        {(char *)"-ctlcount",
      2, (char *)"1000000000", (char *)"No. of utterances to be processed (after skipping -ctloffset entries)"}, 
        {(char *)"-cepdir",
      8, (char *)((void *)0), (char *)"Input cepstrum files directory (prefixed to filespecs in control file)"}, 
        {(char *)"-bptbldir",
      8, (char *)((void *)0), (char *)"Directory in which to dump word Viterbi back pointer table (for debugging)"}, 
        {(char *)"-outlatdir",
      8, (char *)((void *)0), (char *)"Directory in which to dump word lattices"}, 
        {(char *)"-outlatoldfmt",
      2, (char *)"1", (char *)"Whether to dump lattices in old format"}, 
        {(char *)"-latext", 8, (char *)"lat.gz", (char *)"Filename extension for lattice files (gzip compressed, by default)"}, 
        {(char *)"-hmmdump",
      2, (char *)"0", (char *)"Whether to dump active HMM details to stderr (for debugging)"}, 
        {(char *)"-lextreedump",
      2, (char *)"0", (char *)"Whether to dump the lextree structure to stderr (for debugging)"}, 
        {(char *)"-maxwpf",
      2, (char *)"20", (char *)"Max no. of distinct word exits to maintain at each frame"}, 
        {(char *)"-maxhistpf",
      2, (char *)"100", (char *)"Max no. of histories to maintain at each frame"}, 
        {(char *)"-bghist",
      2, (char *)"0", (char *)"Bigram-mode: If TRUE only one BP entry/frame; else one per LM state"}, 
        {(char *)"-maxhmmpf",
      2, (char *)"20000", (char *)"Max no. of active HMMs to maintain at each frame; approx."}, 
        {(char *)"-hmmhistbinsize",
      2, (char *)"5000", (char *)"Performance histogram: #frames vs #HMMs active; #HMMs/bin in this histogram"}, 
        {(char *)"-ptranskip",
      2, (char *)"0", (char *)"Use wbeam for phone transitions every so many frames (if >= 1)"}, 
        {(char *)"-hypseg",
      8, (char *)((void *)0), (char *)"Recognition result file, with word segmentations and scores"}, 
        {(char *)"-treeugprob",
      2, (char *)"1", (char *)"If TRUE (non-0), Use unigram probs in lextree"}, 
        {(char *)"-maxhyplen", 2, (char *)"1000", (char *)"Maximum number of words in a partial hypothesis (for block decoding)"}, 
        {(char *)"-maxcepvecs",
      2, (char *)"256", (char *)"Maximum number of cepstral vectors that can be obtained from a single sample buffer"}, 
        {(char *)"-samprate",
      2, (char *)"8000", (char *)"Sampling rate (only 8K and 16K currently supported)"}, 
        {(char *)"-nfilt",
      2, (char *)"31", (char *)"Number of mel filters"}, 
        {(char *)"-lowerf", 4, (char *)"200", (char *)"Lower edge of filters"}, 
        {(char *)"-upperf", 4, (char *)"3500", (char *)"Upper edge of filters"}, 
        {(char *)((void *)0), 2, (char *)((void *)0), (char *)((void *)0)}};
#line 349 "src/parse_args_file.c"
static char **liveargs  =    (char **)((void *)0);
#line 354 "src/parse_args_file.c"
static int32 nliveargs  ;
#line 351 "src/parse_args_file.c"
void parse_args_file(char *live_args ) 
{ 
  int32 nargs ;
  int32 maxarglen ;
  char *argline ;
  char *targ ;
  FILE *fp ;
  void *tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  char *tmp___4 ;
  void **tmp___5 ;
  int32 tmp___6 ;
  int32 tmp___7 ;
  char *tmp___8 ;

  {
#line 359
  if ((unsigned long )live_args == (unsigned long )((void *)0)) {
#line 360
    cmd_ln_print_help(stderr, arg);
#line 361
    return;
  }
#line 363
  fp = fopen((char const   * __restrict  )live_args, (char const   * __restrict  )"r");
#line 363
  if ((unsigned long )fp == (unsigned long )((void *)0)) {
#line 364
    _E__pr_header("src/parse_args_file.c", 364L, "FATAL_ERROR");
#line 364
    _E__die_error("Unable to open arguments file %s for reading\n", live_args);
  }
#line 366
  tmp = __ckd_calloc__((size_t )10000, sizeof(char ), "src/parse_args_file.c", 366);
#line 366
  argline = (char *)tmp;
#line 367
  nargs = 1;
#line 368
  maxarglen = 0;
#line 369
  while (1) {
#line 369
    tmp___4 = fgets((char * __restrict  )argline, 10000, (FILE * __restrict  )fp);
#line 369
    if (! ((unsigned long )tmp___4 != (unsigned long )((void *)0))) {
#line 369
      break;
    }
#line 370
    targ = strtok((char * __restrict  )argline, (char const   * __restrict  )" \t\n");
#line 370
    if ((unsigned long )targ == (unsigned long )((void *)0)) {
#line 371
      continue;
    }
#line 372
    tmp___1 = strlen((char const   *)targ);
#line 372
    if ((int32 )tmp___1 > maxarglen) {
#line 372
      tmp___0 = strlen((char const   *)targ);
#line 372
      maxarglen = (int32 )tmp___0;
    }
#line 373
    nargs ++;
#line 375
    while (1) {
#line 375
      targ = strtok((char * __restrict  )((void *)0), (char const   * __restrict  )" \t\n");
#line 375
      if (! ((unsigned long )targ != (unsigned long )((void *)0))) {
#line 375
        break;
      }
#line 376
      tmp___3 = strlen((char const   *)targ);
#line 376
      if ((int32 )tmp___3 > maxarglen) {
#line 376
        tmp___2 = strlen((char const   *)targ);
#line 376
        maxarglen = (int32 )tmp___2;
      }
#line 377
      nargs ++;
    }
  }
#line 380
  rewind(fp);
#line 382
  nliveargs = nargs;
#line 383
  tmp___5 = __ckd_calloc_2d__(nargs, maxarglen + 1, (int32 )sizeof(char ), "src/parse_args_file.c",
                              383);
#line 383
  liveargs = (char **)tmp___5;
#line 385
  nargs = 1;
#line 386
  while (1) {
#line 386
    tmp___8 = fgets((char * __restrict  )argline, 10000, (FILE * __restrict  )fp);
#line 386
    if (! ((unsigned long )tmp___8 != (unsigned long )((void *)0))) {
#line 386
      break;
    }
#line 387
    targ = strtok((char * __restrict  )argline, (char const   * __restrict  )" \t\n");
#line 387
    if ((unsigned long )targ == (unsigned long )((void *)0)) {
#line 388
      continue;
    }
#line 390
    tmp___6 = nargs;
#line 390
    nargs ++;
#line 390
    strcpy((char * __restrict  )*(liveargs + tmp___6), (char const   * __restrict  )targ);
#line 391
    while (1) {
#line 391
      targ = strtok((char * __restrict  )((void *)0), (char const   * __restrict  )" \t\n");
#line 391
      if (! ((unsigned long )targ != (unsigned long )((void *)0))) {
#line 391
        break;
      }
#line 392
      tmp___7 = nargs;
#line 392
      nargs ++;
#line 392
      strcpy((char * __restrict  )*(liveargs + tmp___7), (char const   * __restrict  )targ);
    }
  }
#line 395
  fclose(fp);
#line 397
  if (! (nargs == nliveargs)) {
#line 397
    __assert_fail("nargs == nliveargs", "src/parse_args_file.c", 397U, "parse_args_file");
  }
#line 398
  free((void *)argline);
#line 399
  cmd_ln_parse(arg, nliveargs, liveargs);
#line 400
  return;
}
}
#line 404 "src/parse_args_file.c"
void parse_args_free(void) 
{ 


  {
#line 406
  cmd_ln_free();
#line 407
  ckd_free_2d((void **)liveargs);
#line 408
  return;
}
}
#line 1 "cont_mgau.o"
#pragma merger("0","/tmp/cil-F5FSS31J.i","-g,-O4")
#line 150 "/usr/include/x86_64-linux-gnu/bits/mathinline.h"
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__, __always_inline__)) __signbitl)(long double __x )  __attribute__((__const__)) ;
#line 150 "/usr/include/x86_64-linux-gnu/bits/mathinline.h"
__inline extern int ( __attribute__((__leaf__, __always_inline__)) __signbitl)(long double __x ) 
{ 
  union __anonunion___u_29___3 __u ;

  {
#line 153
  __u.__l = __x;
#line 154
  return ((__u.__i[2] & 32768) != 0);
}
}
#line 193 "src/cont_mgau.h"
mgau_model_t *mgau_init(char *meanfile , char *varfile , float64 varfloor , char *mixwfile ,
                        float64 mixwfloor , int32 precomp ) ;
#line 207
int32 mgau_var_nzvec_floor(mgau_model_t *g , float64 floor___0 ) ;
#line 216
int32 mgau_eval(mgau_model_t *g , int32 m , int32 *active , float32 *x___0 ) ;
#line 228
int32 mgau_comp_eval(mgau_model_t *g , int32 s___0 , float32 *x___0 , int32 *score ) ;
#line 237
void mgau_free(mgau_model_t *g ) ;
#line 128 "src/cont_mgau.c"
static int32 mgau_file_read(mgau_model_t *g , char *file_name , int32 type ) 
{ 
  char tmp ;
  FILE *fp ;
  int32 i ;
  int32 k___0 ;
  int32 n ;
  int32 n_mgau ;
  int32 n_feat ;
  int32 n_density ;
  int32 veclen ;
  int32 byteswap ;
  int32 chksum_present ;
  float32 *buf ;
  float32 **pbuf ;
  char **argname ;
  char **argval___0 ;
  uint32 chksum ;
  int32 tmp___0 ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___2 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___9 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  size_t __s1_len___1 ;
  size_t __s2_len___1 ;
  int tmp___16 ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  int32 tmp___22 ;
  int32 tmp___23 ;
  int32 tmp___24 ;
  int32 tmp___25 ;
  int32 tmp___26 ;
  void *tmp___27 ;
  void *tmp___28 ;
  void *tmp___29 ;
  void *tmp___30 ;
  void *tmp___31 ;
  void *tmp___32 ;
  int32 tmp___33 ;
  size_t tmp___34 ;

  {
#line 145
  _E__pr_info_header("src/cont_mgau.c", 145L, "INFO");
#line 145
  _E__pr_info("Reading mixture gaussian file \'%s\'\n", file_name);
#line 147
  fp = _myfopen(file_name, (char *)"rb", (char *)"src/cont_mgau.c", 147);
#line 150
  tmp___0 = bio_readhdr(fp, & argname, & argval___0, & byteswap);
#line 150
  if (tmp___0 < 0) {
#line 151
    _E__pr_header("src/cont_mgau.c", 151L, "FATAL_ERROR");
#line 151
    _E__die_error("bio_readhdr(%s) failed\n", file_name);
  }
#line 154
  chksum_present = 0;
#line 155
  i = 0;
#line 155
  while (*(argname + i)) {
#line 156
    if (0) {
#line 156
      __s1_len___1 = __builtin_strlen((char const   *)*(argname + i));
#line 156
      __s2_len___1 = __builtin_strlen("version");
#line 156
      if (! ((size_t )((void const   *)(*(argname + i) + 1)) - (size_t )((void const   *)*(argname + i)) == 1UL)) {
#line 156
        goto _L___4;
      } else
#line 156
      if (__s1_len___1 >= 4UL) {
        _L___4: /* CIL Label */ 
#line 156
        if (! ((size_t )((void const   *)("version" + 1)) - (size_t )((void const   *)"version") == 1UL)) {
#line 156
          tmp___21 = 1;
        } else
#line 156
        if (__s2_len___1 >= 4UL) {
#line 156
          tmp___21 = 1;
        } else {
#line 156
          tmp___21 = 0;
        }
      } else {
#line 156
        tmp___21 = 0;
      }
#line 156
      if (tmp___21) {
#line 156
        tmp___16 = __builtin_strcmp((char const   *)*(argname + i), "version");
#line 156
        tmp___20 = tmp___16;
      } else {
#line 156
        tmp___19 = __builtin_strcmp((char const   *)*(argname + i), "version");
#line 156
        tmp___20 = tmp___19;
      }
    } else {
#line 156
      tmp___19 = __builtin_strcmp((char const   *)*(argname + i), "version");
#line 156
      tmp___20 = tmp___19;
    }
#line 156
    if (tmp___20 == 0) {
#line 157
      if (0) {
#line 157
        __s1_len = __builtin_strlen((char const   *)*(argval___0 + i));
#line 157
        __s2_len = __builtin_strlen("1.0");
#line 157
        if (! ((size_t )((void const   *)(*(argval___0 + i) + 1)) - (size_t )((void const   *)*(argval___0 + i)) == 1UL)) {
#line 157
          goto _L___0;
        } else
#line 157
        if (__s1_len >= 4UL) {
          _L___0: /* CIL Label */ 
#line 157
          if (! ((size_t )((void const   *)("1.0" + 1)) - (size_t )((void const   *)"1.0") == 1UL)) {
#line 157
            tmp___7 = 1;
          } else
#line 157
          if (__s2_len >= 4UL) {
#line 157
            tmp___7 = 1;
          } else {
#line 157
            tmp___7 = 0;
          }
        } else {
#line 157
          tmp___7 = 0;
        }
#line 157
        if (tmp___7) {
#line 157
          tmp___2 = __builtin_strcmp((char const   *)*(argval___0 + i), "1.0");
#line 157
          tmp___6 = tmp___2;
        } else {
#line 157
          tmp___5 = __builtin_strcmp((char const   *)*(argval___0 + i), "1.0");
#line 157
          tmp___6 = tmp___5;
        }
      } else {
#line 157
        tmp___5 = __builtin_strcmp((char const   *)*(argval___0 + i), "1.0");
#line 157
        tmp___6 = tmp___5;
      }
#line 157
      if (tmp___6 != 0) {
#line 158
        _E__pr_header("src/cont_mgau.c", 158L, "WARNING");
#line 158
        _E__pr_warn("Version mismatch(%s): %s, expecting %s\n", file_name, *(argval___0 + i),
                    "1.0");
      }
    } else {
#line 160
      if (0) {
#line 160
        __s1_len___0 = __builtin_strlen((char const   *)*(argname + i));
#line 160
        __s2_len___0 = __builtin_strlen("chksum0");
#line 160
        if (! ((size_t )((void const   *)(*(argname + i) + 1)) - (size_t )((void const   *)*(argname + i)) == 1UL)) {
#line 160
          goto _L___2;
        } else
#line 160
        if (__s1_len___0 >= 4UL) {
          _L___2: /* CIL Label */ 
#line 160
          if (! ((size_t )((void const   *)("chksum0" + 1)) - (size_t )((void const   *)"chksum0") == 1UL)) {
#line 160
            tmp___14 = 1;
          } else
#line 160
          if (__s2_len___0 >= 4UL) {
#line 160
            tmp___14 = 1;
          } else {
#line 160
            tmp___14 = 0;
          }
        } else {
#line 160
          tmp___14 = 0;
        }
#line 160
        if (tmp___14) {
#line 160
          tmp___9 = __builtin_strcmp((char const   *)*(argname + i), "chksum0");
#line 160
          tmp___13 = tmp___9;
        } else {
#line 160
          tmp___12 = __builtin_strcmp((char const   *)*(argname + i), "chksum0");
#line 160
          tmp___13 = tmp___12;
        }
      } else {
#line 160
        tmp___12 = __builtin_strcmp((char const   *)*(argname + i), "chksum0");
#line 160
        tmp___13 = tmp___12;
      }
#line 160
      if (tmp___13 == 0) {
#line 161
        chksum_present = 1;
      }
    }
#line 155
    i ++;
  }
#line 164
  bio_hdrarg_free(argname, argval___0);
#line 165
  argval___0 = (char **)((void *)0);
#line 165
  argname = argval___0;
#line 167
  chksum = (uint32 )0;
#line 170
  tmp___22 = bio_fread((void *)(& n_mgau), (int32 )sizeof(int32 ), 1, fp, byteswap,
                       & chksum);
#line 170
  if (tmp___22 != 1) {
#line 171
    _E__pr_header("src/cont_mgau.c", 171L, "FATAL_ERROR");
#line 171
    _E__die_error("fread(%s) (#codebooks) failed\n", file_name);
  }
#line 172
  if (n_mgau >= 32766) {
#line 173
    _E__pr_header("src/cont_mgau.c", 173L, "FATAL_ERROR");
#line 173
    _E__die_error("%s: #Mixture Gaussians (%d) exceeds limit(%d) enforced by MGAUID type\n",
                  file_name, n_mgau, 32766);
  }
#line 178
  tmp___23 = bio_fread((void *)(& n_feat), (int32 )sizeof(int32 ), 1, fp, byteswap,
                       & chksum);
#line 178
  if (tmp___23 != 1) {
#line 179
    _E__pr_header("src/cont_mgau.c", 179L, "FATAL_ERROR");
#line 179
    _E__die_error("fread(%s) (#features) failed\n", file_name);
  }
#line 180
  if (n_feat != 1) {
#line 181
    _E__pr_header("src/cont_mgau.c", 181L, "FATAL_ERROR");
#line 181
    _E__die_error("#Features streams(%d) != 1\n", n_feat);
  }
#line 184
  tmp___24 = bio_fread((void *)(& n_density), (int32 )sizeof(int32 ), 1, fp, byteswap,
                       & chksum);
#line 184
  if (tmp___24 != 1) {
#line 185
    _E__pr_header("src/cont_mgau.c", 185L, "FATAL_ERROR");
#line 185
    _E__die_error("fread(%s) (#density/codebook) failed\n", file_name);
  }
#line 188
  tmp___25 = bio_fread((void *)(& veclen), (int32 )sizeof(int32 ), 1, fp, byteswap,
                       & chksum);
#line 188
  if (tmp___25 != 1) {
#line 189
    _E__pr_header("src/cont_mgau.c", 189L, "FATAL_ERROR");
#line 189
    _E__die_error("fread(%s) (feature vector-length) failed\n", file_name);
  }
#line 192
  tmp___26 = bio_fread((void *)(& n), (int32 )sizeof(int32 ), 1, fp, byteswap, & chksum);
#line 192
  if (tmp___26 != 1) {
#line 193
    _E__pr_header("src/cont_mgau.c", 193L, "FATAL_ERROR");
#line 193
    _E__die_error("fread(%s) (total #floats) failed\n", file_name);
  }
#line 194
  if (n != (n_mgau * n_density) * veclen) {
#line 195
    _E__pr_header("src/cont_mgau.c", 195L, "FATAL_ERROR");
#line 195
    _E__die_error("%s: #float32s(%d) doesn\'t match dimensions: %d x %d x %d\n", file_name,
                  n, n_mgau, n_density, veclen);
  }
#line 199
  if (type == 1) {
#line 205
    g->n_mgau = n_mgau;
#line 206
    g->max_comp = n_density;
#line 207
    g->veclen = veclen;
#line 208
    tmp___27 = __ckd_calloc__((size_t )n_mgau, sizeof(mgau_t ), "src/cont_mgau.c",
                              208);
#line 208
    g->mgau = (mgau_t *)tmp___27;
#line 213
    tmp___28 = __ckd_calloc__((size_t )n, sizeof(float ), "src/cont_mgau.c", 213);
#line 213
    buf = (float32 *)tmp___28;
#line 215
    tmp___29 = __ckd_calloc__((size_t )(n_mgau * n_density), sizeof(float32 *), "src/cont_mgau.c",
                              215);
#line 215
    pbuf = (float32 **)tmp___29;
#line 217
    i = 0;
#line 217
    while (i < n_mgau) {
#line 218
      (g->mgau + i)->n_comp = n_density;
#line 219
      (g->mgau + i)->mean = pbuf;
#line 221
      k___0 = 0;
#line 221
      while (k___0 < n_density) {
#line 222
        *((g->mgau + i)->mean + k___0) = buf;
#line 226
        buf += veclen;
#line 221
        k___0 ++;
      }
#line 229
      pbuf += n_density;
#line 217
      i ++;
    }
#line 232
    buf = *((g->mgau + 0)->mean + 0);
  } else {
#line 238
    if (! (type == 2)) {
#line 238
      __assert_fail("type == 2", "src/cont_mgau.c", 238U, "mgau_file_read");
    }
#line 240
    if (g->n_mgau != n_mgau) {
#line 241
      _E__pr_header("src/cont_mgau.c", 241L, "FATAL_ERROR");
#line 241
      _E__die_error("#Mixtures(%d) doesn\'t match that of means(%d)\n", n_mgau, g->n_mgau);
    }
#line 242
    if (g->max_comp != n_density) {
#line 243
      _E__pr_header("src/cont_mgau.c", 243L, "FATAL_ERROR");
#line 243
      _E__die_error("#Components(%d) doesn\'t match that of means(%d)\n", n_density,
                    g->max_comp);
    }
#line 244
    if (g->veclen != veclen) {
#line 245
      _E__pr_header("src/cont_mgau.c", 245L, "FATAL_ERROR");
#line 245
      _E__die_error("#Vector length(%d) doesn\'t match that of means(%d)\n", veclen,
                    g->veclen);
    }
#line 250
    tmp___30 = __ckd_calloc__((size_t )n, sizeof(float32 ), "src/cont_mgau.c", 250);
#line 250
    buf = (float32 *)tmp___30;
#line 252
    tmp___31 = __ckd_calloc__((size_t )(n_mgau * n_density), sizeof(float32 *), "src/cont_mgau.c",
                              252);
#line 252
    pbuf = (float32 **)tmp___31;
#line 254
    i = 0;
#line 254
    while (i < n_mgau) {
#line 255
      if ((g->mgau + i)->n_comp != n_density) {
#line 256
        _E__pr_header("src/cont_mgau.c", 256L, "FATAL_ERROR");
#line 256
        _E__die_error("Mixture %d: #Components(%d) doesn\'t match that of means(%d)\n",
                      i, n_density, (g->mgau + i)->n_comp);
      }
#line 259
      (g->mgau + i)->var = pbuf;
#line 261
      k___0 = 0;
#line 261
      while (k___0 < n_density) {
#line 262
        *((g->mgau + i)->var + k___0) = buf;
#line 266
        buf += veclen;
#line 261
        k___0 ++;
      }
#line 269
      pbuf += n_density;
#line 254
      i ++;
    }
#line 272
    tmp___32 = __ckd_calloc__((size_t )(n_mgau * n_density), sizeof(float32 ), "src/cont_mgau.c",
                              272);
#line 272
    buf = (float32 *)tmp___32;
#line 273
    i = 0;
#line 273
    while (i < n_mgau) {
#line 274
      (g->mgau + i)->lrd = buf;
#line 275
      buf += n_density;
#line 273
      i ++;
    }
#line 278
    buf = *((g->mgau + 0)->var + 0);
  }
#line 299
  tmp___33 = bio_fread((void *)buf, (int32 )sizeof(float32 ), n, fp, byteswap, & chksum);
#line 299
  if (tmp___33 != n) {
#line 300
    _E__pr_header("src/cont_mgau.c", 300L, "FATAL_ERROR");
#line 300
    _E__die_error("fread(%s) (densitydata) failed\n", file_name);
  }
#line 303
  if (chksum_present) {
#line 304
    bio_verify_chksum(fp, byteswap, chksum);
  }
#line 306
  tmp___34 = fread((void * __restrict  )(& tmp), (size_t )1, (size_t )1, (FILE * __restrict  )fp);
#line 306
  if (tmp___34 == 1UL) {
#line 307
    _E__pr_header("src/cont_mgau.c", 307L, "FATAL_ERROR");
#line 307
    _E__die_error("%s: More data than expected\n", file_name);
  }
#line 309
  fclose(fp);
#line 311
  _E__pr_info_header("src/cont_mgau.c", 311L, "INFO");
#line 311
  _E__pr_info("%d mixture Gaussians, %d components, veclen %d\n", n_mgau, n_density,
              veclen);
#line 313
  return (0);
}
}
#line 317 "src/cont_mgau.c"
static int32 mgau_mixw_read(mgau_model_t *g , char *file_name , float64 mixwfloor ) 
{ 
  char **argname ;
  char **argval___0 ;
  char eofchk ;
  FILE *fp ;
  int32 byteswap ;
  int32 chksum_present ;
  uint32 chksum ;
  int32 *buf ;
  float32 *pdf ;
  int32 i ;
  int32 j ;
  int32 n ;
  int32 n_mgau ;
  int32 n_feat ;
  int32 n_comp ;
  int32 n_err ;
  int32 tmp ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___1 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___8 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  size_t __s1_len___1 ;
  size_t __s2_len___1 ;
  int tmp___15 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  int32 tmp___21 ;
  int32 tmp___22 ;
  int32 tmp___23 ;
  int32 tmp___24 ;
  void *tmp___25 ;
  void *tmp___26 ;
  int32 tmp___27 ;
  int32 tmp___28 ;
  int32 tmp___29 ;
  size_t tmp___30 ;

  {
#line 332
  _E__pr_info_header("src/cont_mgau.c", 332L, "INFO");
#line 332
  _E__pr_info("Reading mixture weights file \'%s\'\n", file_name);
#line 334
  fp = _myfopen(file_name, (char *)"rb", (char *)"src/cont_mgau.c", 334);
#line 337
  tmp = bio_readhdr(fp, & argname, & argval___0, & byteswap);
#line 337
  if (tmp < 0) {
#line 338
    _E__pr_header("src/cont_mgau.c", 338L, "FATAL_ERROR");
#line 338
    _E__die_error("bio_readhdr(%s) failed\n", file_name);
  }
#line 341
  chksum_present = 0;
#line 342
  i = 0;
#line 342
  while (*(argname + i)) {
#line 343
    if (0) {
#line 343
      __s1_len___1 = __builtin_strlen((char const   *)*(argname + i));
#line 343
      __s2_len___1 = __builtin_strlen("version");
#line 343
      if (! ((size_t )((void const   *)(*(argname + i) + 1)) - (size_t )((void const   *)*(argname + i)) == 1UL)) {
#line 343
        goto _L___4;
      } else
#line 343
      if (__s1_len___1 >= 4UL) {
        _L___4: /* CIL Label */ 
#line 343
        if (! ((size_t )((void const   *)("version" + 1)) - (size_t )((void const   *)"version") == 1UL)) {
#line 343
          tmp___20 = 1;
        } else
#line 343
        if (__s2_len___1 >= 4UL) {
#line 343
          tmp___20 = 1;
        } else {
#line 343
          tmp___20 = 0;
        }
      } else {
#line 343
        tmp___20 = 0;
      }
#line 343
      if (tmp___20) {
#line 343
        tmp___15 = __builtin_strcmp((char const   *)*(argname + i), "version");
#line 343
        tmp___19 = tmp___15;
      } else {
#line 343
        tmp___18 = __builtin_strcmp((char const   *)*(argname + i), "version");
#line 343
        tmp___19 = tmp___18;
      }
    } else {
#line 343
      tmp___18 = __builtin_strcmp((char const   *)*(argname + i), "version");
#line 343
      tmp___19 = tmp___18;
    }
#line 343
    if (tmp___19 == 0) {
#line 344
      if (0) {
#line 344
        __s1_len = __builtin_strlen((char const   *)*(argval___0 + i));
#line 344
        __s2_len = __builtin_strlen("1.0");
#line 344
        if (! ((size_t )((void const   *)(*(argval___0 + i) + 1)) - (size_t )((void const   *)*(argval___0 + i)) == 1UL)) {
#line 344
          goto _L___0;
        } else
#line 344
        if (__s1_len >= 4UL) {
          _L___0: /* CIL Label */ 
#line 344
          if (! ((size_t )((void const   *)("1.0" + 1)) - (size_t )((void const   *)"1.0") == 1UL)) {
#line 344
            tmp___6 = 1;
          } else
#line 344
          if (__s2_len >= 4UL) {
#line 344
            tmp___6 = 1;
          } else {
#line 344
            tmp___6 = 0;
          }
        } else {
#line 344
          tmp___6 = 0;
        }
#line 344
        if (tmp___6) {
#line 344
          tmp___1 = __builtin_strcmp((char const   *)*(argval___0 + i), "1.0");
#line 344
          tmp___5 = tmp___1;
        } else {
#line 344
          tmp___4 = __builtin_strcmp((char const   *)*(argval___0 + i), "1.0");
#line 344
          tmp___5 = tmp___4;
        }
      } else {
#line 344
        tmp___4 = __builtin_strcmp((char const   *)*(argval___0 + i), "1.0");
#line 344
        tmp___5 = tmp___4;
      }
#line 344
      if (tmp___5 != 0) {
#line 345
        _E__pr_header("src/cont_mgau.c", 345L, "WARNING");
#line 345
        _E__pr_warn("Version mismatch(%s): %s, expecting %s\n", file_name, *(argval___0 + i),
                    "1.0");
      }
    } else {
#line 347
      if (0) {
#line 347
        __s1_len___0 = __builtin_strlen((char const   *)*(argname + i));
#line 347
        __s2_len___0 = __builtin_strlen("chksum0");
#line 347
        if (! ((size_t )((void const   *)(*(argname + i) + 1)) - (size_t )((void const   *)*(argname + i)) == 1UL)) {
#line 347
          goto _L___2;
        } else
#line 347
        if (__s1_len___0 >= 4UL) {
          _L___2: /* CIL Label */ 
#line 347
          if (! ((size_t )((void const   *)("chksum0" + 1)) - (size_t )((void const   *)"chksum0") == 1UL)) {
#line 347
            tmp___13 = 1;
          } else
#line 347
          if (__s2_len___0 >= 4UL) {
#line 347
            tmp___13 = 1;
          } else {
#line 347
            tmp___13 = 0;
          }
        } else {
#line 347
          tmp___13 = 0;
        }
#line 347
        if (tmp___13) {
#line 347
          tmp___8 = __builtin_strcmp((char const   *)*(argname + i), "chksum0");
#line 347
          tmp___12 = tmp___8;
        } else {
#line 347
          tmp___11 = __builtin_strcmp((char const   *)*(argname + i), "chksum0");
#line 347
          tmp___12 = tmp___11;
        }
      } else {
#line 347
        tmp___11 = __builtin_strcmp((char const   *)*(argname + i), "chksum0");
#line 347
        tmp___12 = tmp___11;
      }
#line 347
      if (tmp___12 == 0) {
#line 348
        chksum_present = 1;
      }
    }
#line 342
    i ++;
  }
#line 351
  bio_hdrarg_free(argname, argval___0);
#line 352
  argval___0 = (char **)((void *)0);
#line 352
  argname = argval___0;
#line 354
  chksum = (uint32 )0;
#line 357
  tmp___21 = bio_fread((void *)(& n_mgau), (int32 )sizeof(int32 ), 1, fp, byteswap,
                       & chksum);
#line 357
  if (tmp___21 != 1) {
#line 361
    _E__pr_header("src/cont_mgau.c", 361L, "FATAL_ERROR");
#line 361
    _E__die_error("bio_fread(%s) (arraysize) failed\n", file_name);
  } else {
#line 357
    tmp___22 = bio_fread((void *)(& n_feat), (int32 )sizeof(int32 ), 1, fp, byteswap,
                         & chksum);
#line 357
    if (tmp___22 != 1) {
#line 361
      _E__pr_header("src/cont_mgau.c", 361L, "FATAL_ERROR");
#line 361
      _E__die_error("bio_fread(%s) (arraysize) failed\n", file_name);
    } else {
#line 357
      tmp___23 = bio_fread((void *)(& n_comp), (int32 )sizeof(int32 ), 1, fp, byteswap,
                           & chksum);
#line 357
      if (tmp___23 != 1) {
#line 361
        _E__pr_header("src/cont_mgau.c", 361L, "FATAL_ERROR");
#line 361
        _E__die_error("bio_fread(%s) (arraysize) failed\n", file_name);
      } else {
#line 357
        tmp___24 = bio_fread((void *)(& n), (int32 )sizeof(int32 ), 1, fp, byteswap,
                             & chksum);
#line 357
        if (tmp___24 != 1) {
#line 361
          _E__pr_header("src/cont_mgau.c", 361L, "FATAL_ERROR");
#line 361
          _E__die_error("bio_fread(%s) (arraysize) failed\n", file_name);
        }
      }
    }
  }
#line 363
  if (n_feat != 1) {
#line 364
    _E__pr_header("src/cont_mgau.c", 364L, "FATAL_ERROR");
#line 364
    _E__die_error("#Features streams(%d) != 1\n", n_feat);
  }
#line 365
  if (n != n_mgau * n_comp) {
#line 366
    _E__pr_header("src/cont_mgau.c", 366L, "FATAL_ERROR");
#line 366
    _E__die_error("%s: #float32s(%d) doesn\'t match header dimensions: %d x %d\n",
                  file_name, i, n_mgau, n_comp);
  }
#line 369
  if (n_mgau != g->n_mgau) {
#line 370
    _E__pr_header("src/cont_mgau.c", 370L, "FATAL_ERROR");
#line 370
    _E__die_error("%s: #Mixture Gaussians(%d) doesn\'t match mean/var parameters(%d)\n",
                  n_mgau, g->n_mgau);
  }
#line 373
  tmp___25 = __ckd_calloc__((size_t )(n_mgau * n_comp), sizeof(int32 ), "src/cont_mgau.c",
                            373);
#line 373
  buf = (int32 *)tmp___25;
#line 374
  i = 0;
#line 374
  while (i < n_mgau) {
#line 375
    if (n_comp != (g->mgau + i)->n_comp) {
#line 376
      _E__pr_header("src/cont_mgau.c", 376L, "FATAL_ERROR");
#line 376
      _E__die_error("Mixture %d: #Weights(%d) doesn\'t match #Gaussian components(%d)\n",
                    i, n_comp, (g->mgau + i)->n_comp);
    }
#line 379
    (g->mgau + i)->mixw = buf;
#line 380
    buf += (g->mgau + i)->n_comp;
#line 374
    i ++;
  }
#line 384
  tmp___26 = __ckd_calloc__((size_t )n_comp, sizeof(float32 ), "src/cont_mgau.c",
                            384);
#line 384
  pdf = (float32 *)tmp___26;
#line 387
  n_err = 0;
#line 388
  i = 0;
#line 388
  while (i < n_mgau) {
#line 389
    tmp___27 = bio_fread((void *)pdf, (int32 )sizeof(float32 ), n_comp, fp, byteswap,
                         & chksum);
#line 389
    if (tmp___27 != n_comp) {
#line 390
      _E__pr_header("src/cont_mgau.c", 390L, "FATAL_ERROR");
#line 390
      _E__die_error("bio_fread(%s) (arraydata) failed\n", file_name);
    }
#line 393
    tmp___29 = vector_is_zero(pdf, n_comp);
#line 393
    if (tmp___29) {
#line 394
      n_err ++;
#line 395
      j = 0;
#line 395
      while (j < n_comp) {
#line 396
        *((g->mgau + i)->mixw + j) = (int32 )3355443200U;
#line 395
        j ++;
      }
    } else {
#line 398
      vector_nz_floor(pdf, n_comp, mixwfloor);
#line 399
      vector_sum_norm(pdf, n_comp);
#line 400
      j = 0;
#line 400
      while (j < n_comp) {
#line 401
        if ((double )*(pdf + j) != 0.0) {
#line 401
          tmp___28 = logs3((float64 )*(pdf + j));
#line 401
          *((g->mgau + i)->mixw + j) = tmp___28;
        } else {
#line 401
          *((g->mgau + i)->mixw + j) = (int32 )3355443200U;
        }
#line 400
        j ++;
      }
    }
#line 388
    i ++;
  }
#line 404
  if (n_err > 0) {
#line 405
    _E__pr_header("src/cont_mgau.c", 405L, "ERROR");
#line 405
    _E__pr_warn("Weight normalization failed for %d senones\n", n_err);
  }
#line 407
  free((void *)pdf);
#line 409
  if (chksum_present) {
#line 410
    bio_verify_chksum(fp, byteswap, chksum);
  }
#line 412
  tmp___30 = fread((void * __restrict  )(& eofchk), (size_t )1, (size_t )1, (FILE * __restrict  )fp);
#line 412
  if (tmp___30 == 1UL) {
#line 413
    _E__pr_header("src/cont_mgau.c", 413L, "FATAL_ERROR");
#line 413
    _E__die_error("More data than expected in %s\n", file_name);
  }
#line 415
  fclose(fp);
#line 417
  _E__pr_info_header("src/cont_mgau.c", 417L, "INFO");
#line 417
  _E__pr_info("Read %d x %d mixture weights\n", n_mgau, n_comp);
#line 419
  return (0);
}
}
#line 429 "src/cont_mgau.c"
static void mgau_uninit_compact(mgau_model_t *g ) 
{ 
  int32 m ;
  int32 c ;
  int32 c2 ;
  int32 n ;
  int32 nm ;
  int32 tmp ;

  {
#line 433
  _E__pr_info_header("src/cont_mgau.c", 433L, "INFO");
#line 433
  _E__pr_info("Removing uninitialized Gaussian densities\n");
#line 435
  n = 0;
#line 436
  nm = 0;
#line 437
  m = 0;
#line 437
  while (m < g->n_mgau) {
#line 438
    c = 0;
#line 438
    c2 = 0;
#line 438
    while (c < (g->mgau + m)->n_comp) {
#line 439
      tmp = vector_is_zero(*((g->mgau + m)->var + c), g->veclen);
#line 439
      if (tmp) {
#line 449
        n ++;
      } else {
#line 440
        if (c2 != c) {
#line 441
          memcpy((void * __restrict  )*((g->mgau + m)->mean + c2), (void const   * __restrict  )*((g->mgau + m)->mean + c),
                 (unsigned long )g->veclen * sizeof(float32 ));
#line 443
          memcpy((void * __restrict  )*((g->mgau + m)->var + c2), (void const   * __restrict  )*((g->mgau + m)->var + c),
                 (unsigned long )g->veclen * sizeof(float32 ));
#line 445
          *((g->mgau + m)->mixw + c2) = *((g->mgau + m)->mixw + c);
        }
#line 447
        c2 ++;
      }
#line 438
      c ++;
    }
#line 452
    (g->mgau + m)->n_comp = c2;
#line 453
    if (c2 == 0) {
#line 454
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )" %d", m);
#line 455
      fflush(stderr);
#line 456
      nm ++;
    }
#line 437
    m ++;
  }
#line 459
  if (nm > 0) {
#line 460
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"\n");
  }
#line 462
  if (nm > 0) {
#line 463
    _E__pr_info_header("src/cont_mgau.c", 463L, "INFO");
#line 463
    _E__pr_info("%d densities removed (%d mixtures removed entirely)\n", n, nm);
  } else
#line 462
  if (n > 0) {
#line 463
    _E__pr_info_header("src/cont_mgau.c", 463L, "INFO");
#line 463
    _E__pr_info("%d densities removed (%d mixtures removed entirely)\n", n, nm);
  }
#line 464
  return;
}
}
#line 467 "src/cont_mgau.c"
static void mgau_var_floor(mgau_model_t *g , float64 floor___0 ) 
{ 
  int32 m ;
  int32 c ;
  int32 i ;
  int32 n ;

  {
#line 471
  _E__pr_info_header("src/cont_mgau.c", 471L, "INFO");
#line 471
  _E__pr_info("Applying variance floor\n");
#line 472
  n = 0;
#line 473
  m = 0;
#line 473
  while (m < g->n_mgau) {
#line 474
    c = 0;
#line 474
    while (c < (g->mgau + m)->n_comp) {
#line 475
      i = 0;
#line 475
      while (i < g->veclen) {
#line 476
        if ((float64 )*(*((g->mgau + m)->var + c) + i) < floor___0) {
#line 477
          *(*((g->mgau + m)->var + c) + i) = (float32 )floor___0;
#line 478
          n ++;
        }
#line 475
        i ++;
      }
#line 474
      c ++;
    }
#line 473
    m ++;
  }
#line 483
  _E__pr_info_header("src/cont_mgau.c", 483L, "INFO");
#line 483
  _E__pr_info("%d variance values floored\n", n);
#line 484
  return;
}
}
#line 487 "src/cont_mgau.c"
int32 mgau_var_nzvec_floor(mgau_model_t *g , float64 floor___0 ) 
{ 
  int32 m ;
  int32 c ;
  int32 i ;
  int32 n ;
  int32 l ;
  float32 *var ;
  int32 tmp ;

  {
#line 492
  _E__pr_info_header("src/cont_mgau.c", 492L, "INFO");
#line 492
  _E__pr_info("Applying variance floor to non-zero variance vectors\n");
#line 494
  l = g->veclen;
#line 496
  n = 0;
#line 497
  m = 0;
#line 497
  while (m < g->n_mgau) {
#line 498
    c = 0;
#line 498
    while (c < (g->mgau + m)->n_comp) {
#line 499
      var = *((g->mgau + m)->var + c);
#line 501
      tmp = vector_is_zero(var, l);
#line 501
      if (! tmp) {
#line 502
        i = 0;
#line 502
        while (i < l) {
#line 503
          if ((float64 )*(var + i) < floor___0) {
#line 504
            *(var + i) = (float32 )floor___0;
#line 505
            n ++;
          }
#line 502
          i ++;
        }
      }
#line 498
      c ++;
    }
#line 497
    m ++;
  }
#line 512
  _E__pr_info_header("src/cont_mgau.c", 512L, "INFO");
#line 512
  _E__pr_info("%d variance values floored\n", n);
#line 514
  return (n);
}
}
#line 522 "src/cont_mgau.c"
static int32 mgau_precomp(mgau_model_t *g ) 
{ 
  int32 m ;
  int32 c ;
  int32 i ;
  float64 lrd ;
  double tmp ;
  double tmp___0 ;

  {
#line 527
  _E__pr_info_header("src/cont_mgau.c", 527L, "INFO");
#line 527
  _E__pr_info("Precomputing Mahalanobis distance invariants\n");
#line 529
  m = 0;
#line 529
  while (m < g->n_mgau) {
#line 530
    c = 0;
#line 530
    while (c < (g->mgau + m)->n_comp) {
#line 531
      lrd = 0.0;
#line 532
      i = 0;
#line 532
      while (i < g->veclen) {
#line 533
        tmp = log((double )*(*((g->mgau + m)->var + c) + i));
#line 533
        lrd += tmp;
#line 536
        *(*((g->mgau + m)->var + c) + i) = (float32 )(1.0 / ((double )*(*((g->mgau + m)->var + c) + i) * 2.0));
#line 532
        i ++;
      }
#line 539
      tmp___0 = log(2.0 * 3.14159265358979323846);
#line 539
      lrd += (double )g->veclen * tmp___0;
#line 540
      *((g->mgau + m)->lrd + c) = (float32 )(- 0.5 * lrd);
#line 530
      c ++;
    }
#line 529
    m ++;
  }
#line 544
  return (0);
}
}
#line 549 "src/cont_mgau.c"
mgau_model_t *mgau_init(char *meanfile , char *varfile , float64 varfloor , char *mixwfile ,
                        float64 mixwfloor , int32 precomp ) 
{ 
  mgau_model_t *g ;
  void *tmp ;

  {
#line 555
  if (! ((unsigned long )meanfile != (unsigned long )((void *)0))) {
#line 555
    __assert_fail("meanfile != ((void *)0)", "src/cont_mgau.c", 555U, "mgau_init");
  }
#line 556
  if (! ((unsigned long )varfile != (unsigned long )((void *)0))) {
#line 556
    __assert_fail("varfile != ((void *)0)", "src/cont_mgau.c", 556U, "mgau_init");
  }
#line 557
  if (! (varfloor >= 0.0)) {
#line 557
    __assert_fail("varfloor >= 0.0", "src/cont_mgau.c", 557U, "mgau_init");
  }
#line 558
  if (! ((unsigned long )mixwfile != (unsigned long )((void *)0))) {
#line 558
    __assert_fail("mixwfile != ((void *)0)", "src/cont_mgau.c", 558U, "mgau_init");
  }
#line 559
  if (! (mixwfloor >= 0.0)) {
#line 559
    __assert_fail("mixwfloor >= 0.0", "src/cont_mgau.c", 559U, "mgau_init");
  }
#line 561
  tmp = __ckd_calloc__((size_t )1, sizeof(mgau_model_t ), "src/cont_mgau.c", 561);
#line 561
  g = (mgau_model_t *)tmp;
#line 564
  mgau_file_read(g, meanfile, 1);
#line 565
  mgau_file_read(g, varfile, 2);
#line 566
  mgau_mixw_read(g, mixwfile, mixwfloor);
#line 568
  mgau_uninit_compact(g);
#line 570
  if (varfloor > 0.0) {
#line 571
    mgau_var_floor(g, varfloor);
  }
#line 573
  if (precomp) {
#line 574
    mgau_precomp(g);
  }
#line 576
  g->distfloor = logs3_to_log((int32 )3355443200U);
#line 578
  return (g);
}
}
#line 582 "src/cont_mgau.c"
int32 mgau_comp_eval(mgau_model_t *g , int32 s___0 , float32 *x___0 , int32 *score ) 
{ 
  mgau_t *mgau ;
  int32 veclen ;
  float32 *m ;
  float32 *v ;
  float64 dval ;
  float64 diff ;
  float64 f ;
  int32 bs___0 ;
  int32 i ;
  int32 c ;

  {
#line 594
  veclen = g->veclen;
#line 595
  mgau = g->mgau + s___0;
#line 596
  f = log_to_logs3_factor();
#line 598
  bs___0 = (int32 )2147483648U;
#line 599
  c = 0;
#line 599
  while (c < mgau->n_comp) {
#line 600
    m = *(mgau->mean + c);
#line 601
    v = *(mgau->var + c);
#line 602
    dval = (float64 )*(mgau->lrd + c);
#line 604
    i = 0;
#line 604
    while (i < veclen) {
#line 605
      diff = (float64 )(*(x___0 + i) - *(m + i));
#line 606
      dval -= (diff * diff) * (float64 )*(v + i);
#line 604
      i ++;
    }
#line 609
    if (dval < g->distfloor) {
#line 610
      dval = g->distfloor;
    }
#line 612
    *(score + c) = (int32 )(f * dval);
#line 613
    if (*(score + c) > bs___0) {
#line 614
      bs___0 = *(score + c);
    }
#line 599
    c ++;
  }
#line 617
  return (bs___0);
}
}
#line 844 "src/cont_mgau.c"
float64 mgau_eval_inner(mgau_t const   *mgau , int32 const   veclen , int32 const   c ,
                        float32 const   *x___0 ) 
{ 
  float32 *m1 ;
  float32 *v1 ;
  float64 vdiff[4] ;
  float64 vdval[4] ;
  float64 dval1 ;
  int32 i ;

  {
#line 851
  m1 = *(mgau->mean + c);
#line 852
  v1 = *(mgau->var + c);
#line 853
  dval1 = (float64 )*(mgau->lrd + c);
#line 856
  vdval[3] = 0.0;
#line 856
  vdval[2] = vdval[3];
#line 856
  vdval[1] = vdval[2];
#line 856
  vdval[0] = vdval[1];
#line 860
  i = 0;
#line 860
  while (i < (int32 )(veclen - 3)) {
#line 865
    vdiff[0] = (float64 )(*(x___0 + i) - (float32 const   )*(m1 + i));
#line 866
    vdval[0] += (vdiff[0] * vdiff[0]) * (float64 )*(v1 + i);
#line 868
    vdiff[1] = (float64 )(*(x___0 + (i + 1)) - (float32 const   )*(m1 + (i + 1)));
#line 869
    vdval[1] += (vdiff[1] * vdiff[1]) * (float64 )*(v1 + (i + 1));
#line 871
    vdiff[2] = (float64 )(*(x___0 + (i + 2)) - (float32 const   )*(m1 + (i + 2)));
#line 872
    vdval[2] += (vdiff[2] * vdiff[2]) * (float64 )*(v1 + (i + 2));
#line 874
    vdiff[3] = (float64 )(*(x___0 + (i + 3)) - (float32 const   )*(m1 + (i + 3)));
#line 875
    vdval[3] += (vdiff[3] * vdiff[3]) * (float64 )*(v1 + (i + 3));
#line 860
    i += 4;
  }
#line 886
  vdiff[0] = (float64 )(*(x___0 + i) - (float32 const   )*(m1 + i));
#line 887
  vdval[0] += (vdiff[0] * vdiff[0]) * (float64 )*(v1 + i);
#line 889
  vdiff[1] = (float64 )(*(x___0 + (i + 1)) - (float32 const   )*(m1 + (i + 1)));
#line 890
  vdval[1] += (vdiff[1] * vdiff[1]) * (float64 )*(v1 + (i + 1));
#line 892
  vdiff[2] = (float64 )(*(x___0 + (i + 2)) - (float32 const   )*(m1 + (i + 2)));
#line 893
  vdval[2] += (vdiff[2] * vdiff[2]) * (float64 )*(v1 + (i + 2));
#line 897
  dval1 -= ((vdval[0] + vdval[1]) + vdval[2]) + vdval[3];
#line 899
  return (dval1);
}
}
#line 906 "src/cont_mgau.c"
int32 mgau_eval(mgau_model_t *g , int32 m , int32 *active , float32 *x___0 ) 
{ 
  mgau_t *mgau ;
  int32 veclen ;
  int32 score ;
  float64 dval1 ;
  float64 f ;
  int32 j ;
  int32 c ;

  {
#line 916
  veclen = g->veclen;
#line 917
  mgau = g->mgau + m;
#line 918
  f = log_to_logs3_factor();
#line 919
  score = (int32 )3355443200U;
#line 921
  if (! active) {
#line 925
    c = 0;
#line 925
    while (c < mgau->n_comp) {
#line 927
      dval1 = mgau_eval_inner((mgau_t const   *)mgau, (int32 const   )veclen, (int32 const   )c,
                              (float32 const   *)x___0);
#line 928
      if (dval1 < g->distfloor) {
#line 928
        dval1 = g->distfloor;
      }
#line 930
      score = logs3_add(score, (int32 )(f * dval1) + *(mgau->mixw + c));
#line 925
      c ++;
    }
  } else {
#line 934
    j = 0;
#line 934
    while (*(active + j) >= 0) {
#line 935
      c = *(active + j);
#line 937
      dval1 = mgau_eval_inner((mgau_t const   *)mgau, (int32 const   )veclen, (int32 const   )c,
                              (float32 const   *)x___0);
#line 938
      if (dval1 < g->distfloor) {
#line 938
        dval1 = g->distfloor;
      }
#line 940
      score = logs3_add(score, (int32 )(f * dval1) + *(mgau->mixw + c));
#line 934
      j ++;
    }
  }
#line 944
  return (score);
}
}
#line 961 "src/cont_mgau.c"
void mgau_free(mgau_model_t *g ) 
{ 


  {
#line 963
  if (g) {
#line 964
    if ((g->mgau + 0)->mean) {
#line 965
      free((void *)(g->mgau + 0)->mean);
    }
#line 969
    if ((g->mgau + 0)->var) {
#line 970
      free((void *)(g->mgau + 0)->var);
    }
#line 971
    if ((g->mgau + 0)->lrd) {
#line 972
      free((void *)(g->mgau + 0)->lrd);
    }
#line 976
    if ((g->mgau + 0)->mixw) {
#line 977
      free((void *)(g->mgau + 0)->mixw);
    }
#line 979
    if (g->mgau) {
#line 980
      free((void *)g->mgau);
    }
#line 981
    free((void *)g);
  }
#line 983
  return;
}
}
#line 1 "subvq.o"
#pragma merger("0","/tmp/cil-HG51827L.i","-g,-O4")
#line 425 "/usr/include/stdio.h"
extern int ( __attribute__((__warn_unused_result__)) fscanf)(FILE * __restrict  __stream ,
                                                             char const   * __restrict  __format 
                                                             , ...)  __asm__("__isoc99_fscanf")  ;
#line 150 "/usr/include/x86_64-linux-gnu/bits/mathinline.h"
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__, __always_inline__)) __signbitl)(long double __x )  __attribute__((__const__)) ;
#line 150 "/usr/include/x86_64-linux-gnu/bits/mathinline.h"
__inline extern int ( __attribute__((__leaf__, __always_inline__)) __signbitl)(long double __x ) 
{ 
  union __anonunion___u_29___4 __u ;

  {
#line 153
  __u.__l = __x;
#line 154
  return ((__u.__i[2] & 32768) != 0);
}
}
#line 187 "src/subvq.h"
subvq_t *subvq_init(char *file , float64 varfloor , int32 max_sv , mgau_model_t *g ) ;
#line 194
void subvq_free(subvq_t *s___0 ) ;
#line 204
int32 subvq_frame_eval(subvq_t *vq , mgau_model_t *g , int32 beam , float32 *feat___0 ,
                       int32 *sen_active , int32 *senscr ) ;
#line 217
void subvq_gautbl_eval_logs3(subvq_t *vq , float32 *feat___0 ) ;
#line 231
void thrd_subvq_gautbl_eval_logs3(int subvec_num , subvq_t *vq , float32 *feat___0 ) ;
#line 147 "src/subvq.c"
int VQ_EVAL  =    3;
#line 155 "src/subvq.c"
static void subvq_maha_precomp(subvq_t *svq , float64 floor___0 ) 
{ 
  int32 s___0 ;
  float32 *lrd ;
  vector_gautbl_t *gautbl ;
  void *tmp ;

  {
#line 161
  _E__pr_info_header("src/subvq.c", 161L, "INFO");
#line 161
  _E__pr_info("Precomputing Mahalanobis distance invariants\n");
#line 163
  tmp = __ckd_calloc__((size_t )(svq->n_sv * svq->vqsize), sizeof(float32 ), "src/subvq.c",
                       163);
#line 163
  lrd = (float32 *)tmp;
#line 165
  s___0 = 0;
#line 165
  while (s___0 < svq->n_sv) {
#line 166
    gautbl = svq->gautbl + s___0;
#line 168
    vector_gautbl_var_floor(gautbl, floor___0);
#line 170
    gautbl->lrd = lrd;
#line 171
    lrd += svq->vqsize;
#line 172
    vector_gautbl_maha_precomp(gautbl);
#line 165
    s___0 ++;
  }
#line 174
  return;
}
}
#line 177 "src/subvq.c"
static void subvq_map_compact(subvq_t *vq , mgau_model_t *g ) 
{ 
  int32 r ;
  int32 c ;
  int32 c2 ;
  int32 s___0 ;

  {
#line 181
  if (g) {
#line 182
    if (g->n_mgau != vq->origsize.r) {
#line 183
      _E__pr_header("src/subvq.c", 183L, "FATAL_ERROR");
#line 183
      _E__die_error("Model size conflict: %d x %d (SubVQ) vs %d x %d (Original)\n",
                    vq->origsize.r, vq->origsize.c, g->n_mgau, g->max_comp);
    } else
#line 182
    if (g->max_comp != vq->origsize.c) {
#line 183
      _E__pr_header("src/subvq.c", 183L, "FATAL_ERROR");
#line 183
      _E__die_error("Model size conflict: %d x %d (SubVQ) vs %d x %d (Original)\n",
                    vq->origsize.r, vq->origsize.c, g->n_mgau, g->max_comp);
    }
  }
#line 193
  r = 0;
#line 193
  while (r < vq->origsize.r) {
#line 194
    c = 0;
#line 194
    c2 = 0;
#line 194
    while (c < vq->origsize.c) {
#line 195
      if (*(*(*(vq->map + r) + c) + 0) < 0) {
#line 197
        s___0 = 1;
#line 197
        while (s___0 < vq->n_sv) {
#line 198
          if (*(*(*(vq->map + r) + c) + s___0) >= 0) {
#line 199
            _E__pr_header("src/subvq.c", 199L, "FATAL_ERROR");
#line 199
            _E__die_error("Partially undefined map[%d][%d]\n", r, c);
          }
#line 197
          s___0 ++;
        }
      } else {
#line 202
        if (c2 != c) {
#line 203
          s___0 = 0;
#line 203
          while (s___0 < vq->n_sv) {
#line 204
            if (*(*(*(vq->map + r) + c) + s___0) < 0) {
#line 205
              _E__pr_header("src/subvq.c", 205L, "FATAL_ERROR");
#line 205
              _E__die_error("Partially undefined map[%d][%d]\n", r, c);
            }
#line 206
            *(*(*(vq->map + r) + c2) + s___0) = *(*(*(vq->map + r) + c) + s___0);
#line 203
            s___0 ++;
          }
        }
#line 209
        c2 ++;
      }
#line 194
      c ++;
    }
#line 213
    if (g) {
#line 213
      if (c2 != (g->mgau + r)->n_comp) {
#line 214
        _E__pr_header("src/subvq.c", 214L, "FATAL_ERROR");
#line 214
        _E__die_error("Mixture %d: #Valid components conflict: %d (SubVQ) vs %d (Original)\n",
                      r, c2, (g->mgau + r)->n_comp);
      }
    }
#line 218
    while (c2 < vq->origsize.c) {
#line 219
      s___0 = 0;
#line 219
      while (s___0 < vq->n_sv) {
#line 220
        *(*(*(vq->map + r) + c2) + s___0) = -1;
#line 219
        s___0 ++;
      }
#line 218
      c2 ++;
    }
#line 193
    r ++;
  }
#line 223
  return;
}
}
#line 233 "src/subvq.c"
static void subvq_map_linearize(subvq_t *vq ) 
{ 
  int32 r ;
  int32 c ;
  int32 s___0 ;

  {
#line 237
  r = 0;
#line 237
  while (r < vq->origsize.r) {
#line 238
    c = 0;
#line 238
    while (1) {
#line 238
      if (c < vq->origsize.c) {
#line 238
        if (! (*(*(*(vq->map + r) + c) + 0) >= 0)) {
#line 238
          break;
        }
      } else {
#line 238
        break;
      }
#line 239
      s___0 = 0;
#line 239
      while (s___0 < vq->n_sv) {
#line 240
        *(*(*(vq->map + r) + c) + s___0) = s___0 * vq->vqsize + *(*(*(vq->map + r) + c) + s___0);
#line 239
        s___0 ++;
      }
#line 238
      c ++;
    }
#line 237
    r ++;
  }
#line 243
  return;
}
}
#line 246 "src/subvq.c"
subvq_t *subvq_init(char *file , float64 varfloor , int32 max_sv , mgau_model_t *g ) 
{ 
  FILE *fp ;
  char line[16384] ;
  int32 n_sv ;
  int32 s___0 ;
  int32 k___0 ;
  int32 l ;
  int32 n ;
  int32 r ;
  int32 c ;
  char *strp ;
  subvq_t *vq ;
  void const   *tmp ;
  void *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  void ***tmp___5 ;
  char *tmp___6 ;
  int tmp___7 ;
  void *tmp___8 ;
  int tmp___9 ;
  int32 veclen ;
  int a_veclen ;
  int32 tmp___10 ;
  char const   *tmp___11 ;
  char *tmp___12 ;
  int tmp___13 ;
  char *tmp___14 ;
  int tmp___15 ;
  char *tmp___16 ;
  int tmp___17 ;
  char *tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___22 ;
  int tmp___25 ;
  int tmp___26 ;
  int tmp___27 ;
  void *tmp___28 ;
  void *tmp___29 ;
  void *tmp___30 ;
  void *tmp___31 ;
  void **tmp___32 ;
  void *tmp___33 ;
  void *tmp___34 ;

  {
#line 255
  tmp = cmd_ln_access((char *)"-vqeval");
#line 255
  VQ_EVAL = *((int32 *)tmp);
#line 257
  _E__pr_info_header("src/subvq.c", 257L, "INFO");
#line 257
  _E__pr_info("Loading Mixture Gaussian sub-VQ file \'%s\' (vq_eval: %d)\n", file,
              VQ_EVAL);
#line 259
  tmp___0 = __ckd_calloc__((size_t )1, sizeof(subvq_t ), "src/subvq.c", 259);
#line 259
  vq = (subvq_t *)tmp___0;
#line 261
  fp = _myfopen(file, (char *)"r", (char *)"src/subvq.c", 261);
#line 264
  while (1) {
#line 265
    tmp___1 = fgets((char * __restrict  )(line), (int )sizeof(line), (FILE * __restrict  )fp);
#line 265
    if ((unsigned long )tmp___1 == (unsigned long )((void *)0)) {
#line 266
      _E__pr_header("src/subvq.c", 266L, "FATAL_ERROR");
#line 266
      _E__die_error("Failed to read VQParam header\n");
    }
#line 267
    tmp___2 = sscanf((char const   * __restrict  )(line), (char const   * __restrict  )"VQParam %d %d -> %d %d",
                     & vq->origsize.r, & vq->origsize.c, & vq->n_sv, & vq->vqsize);
#line 267
    if (tmp___2 == 4) {
#line 269
      break;
    }
  }
#line 272
  if (g) {
#line 273
    if (g->n_mgau != vq->origsize.r) {
#line 274
      _E__pr_header("src/subvq.c", 274L, "FATAL_ERROR");
#line 274
      _E__die_error("Model size conflict: %d x %d (SubVQ) vs %d x %d (Original)\n",
                    vq->origsize.r, vq->origsize.c, g->n_mgau, g->max_comp);
    } else
#line 273
    if (g->max_comp != vq->origsize.c) {
#line 274
      _E__pr_header("src/subvq.c", 274L, "FATAL_ERROR");
#line 274
      _E__die_error("Model size conflict: %d x %d (SubVQ) vs %d x %d (Original)\n",
                    vq->origsize.r, vq->origsize.c, g->n_mgau, g->max_comp);
    }
  }
#line 278
  if (max_sv < 0) {
#line 279
    max_sv = vq->n_sv;
  }
#line 280
  if (max_sv < vq->n_sv) {
#line 281
    _E__pr_info_header("src/subvq.c", 281L, "INFO");
#line 281
    _E__pr_info("Using %d subvectors out of %d\n", max_sv, vq->n_sv);
  } else
#line 282
  if (max_sv > vq->n_sv) {
#line 283
    _E__pr_header("src/subvq.c", 283L, "WARNING");
#line 283
    _E__pr_warn("#Subvectors specified(%d) > available(%d); using latter\n", max_sv,
                vq->n_sv);
#line 284
    max_sv = vq->n_sv;
  }
#line 287
  n_sv = vq->n_sv;
#line 288
  vq->n_sv = max_sv;
#line 289
  if (vq->n_sv < VQ_EVAL) {
#line 290
    VQ_EVAL = vq->n_sv;
  }
#line 291
  tmp___3 = __ckd_calloc__((size_t )vq->n_sv, sizeof(int32 *), "src/subvq.c", 291);
#line 291
  vq->featdim = (int32 **)tmp___3;
#line 292
  tmp___4 = __ckd_calloc__((size_t )vq->n_sv, sizeof(vector_gautbl_t ), "src/subvq.c",
                           292);
#line 292
  vq->gautbl = (vector_gautbl_t *)tmp___4;
#line 293
  tmp___5 = __ckd_calloc_3d__(vq->origsize.r, vq->origsize.c, vq->n_sv, (int32 )sizeof(int32 ),
                              "src/subvq.c", 294);
#line 293
  vq->map = (int32 ***)tmp___5;
#line 297
  s___0 = 0;
#line 297
  while (s___0 < n_sv) {
#line 298
    tmp___6 = fgets((char * __restrict  )(line), (int )sizeof(line), (FILE * __restrict  )fp);
#line 298
    if ((unsigned long )tmp___6 == (unsigned long )((void *)0)) {
#line 300
      _E__pr_header("src/subvq.c", 300L, "FATAL_ERROR");
#line 300
      _E__die_error("Error reading length(subvector %d)\n", s___0);
    } else {
#line 298
      tmp___7 = sscanf((char const   * __restrict  )(line), (char const   * __restrict  )"Subvector %d length %d%n",
                       & k___0, & l, & n);
#line 298
      if (tmp___7 != 2) {
#line 300
        _E__pr_header("src/subvq.c", 300L, "FATAL_ERROR");
#line 300
        _E__die_error("Error reading length(subvector %d)\n", s___0);
      } else
#line 298
      if (k___0 != s___0) {
#line 300
        _E__pr_header("src/subvq.c", 300L, "FATAL_ERROR");
#line 300
        _E__die_error("Error reading length(subvector %d)\n", s___0);
      }
    }
#line 302
    if (s___0 < vq->n_sv) {
#line 303
      (vq->gautbl + s___0)->veclen = l;
#line 304
      tmp___8 = __ckd_calloc__((size_t )(vq->gautbl + s___0)->veclen, sizeof(int32 ),
                               "src/subvq.c", 304);
#line 304
      *(vq->featdim + s___0) = (int32 *)tmp___8;
#line 306
      strp = line + n;
#line 306
      c = 0;
#line 306
      while (c < (vq->gautbl + s___0)->veclen) {
#line 307
        tmp___9 = sscanf((char const   * __restrict  )strp, (char const   * __restrict  )"%d%n",
                         *(vq->featdim + s___0) + c, & n);
#line 307
        if (tmp___9 != 1) {
#line 308
          _E__pr_header("src/subvq.c", 308L, "FATAL_ERROR");
#line 308
          _E__die_error("Error reading subvector(%d).featdim(%d)\n", s___0, c);
        }
#line 309
        strp += n;
#line 306
        c ++;
      }
#line 312
      vector_gautbl_alloc(vq->gautbl + s___0, vq->vqsize, (vq->gautbl + s___0)->veclen);
    }
#line 297
    s___0 ++;
  }
#line 317
  _E__pr_info_header("src/subvq.c", 317L, "INFO");
#line 317
  _E__pr_info("Original #codebooks(states)/codewords: %d x %d\n", vq->origsize.r,
              vq->origsize.c);
#line 318
  _E__pr_info_header("src/subvq.c", 318L, "INFO");
#line 318
  _E__pr_info("Subvectors: %d, VQsize: %d\n", vq->n_sv, vq->vqsize);
#line 319
  s___0 = 0;
#line 319
  while (s___0 < vq->n_sv) {
#line 320
    _E__pr_info_header("src/subvq.c", 320L, "INFO");
#line 320
    _E__pr_info("SV %d feature dims(%d): ", s___0, (vq->gautbl + s___0)->veclen);
#line 321
    c = 0;
#line 321
    while (c < (vq->gautbl + s___0)->veclen) {
#line 322
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )" %2d", *(*(vq->featdim + s___0) + c));
#line 321
      c ++;
    }
#line 323
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"\n");
#line 319
    s___0 ++;
  }
#line 325
  fflush(stderr);
#line 328
  s___0 = 0;
#line 328
  while (s___0 < n_sv) {
#line 330
    veclen = (vq->gautbl + s___0)->veclen;
#line 331
    if (veclen % 4) {
#line 331
      tmp___10 = (veclen + 4) - veclen % 4;
    } else {
#line 331
      tmp___10 = veclen;
    }
#line 331
    a_veclen = tmp___10;
#line 333
    _E__pr_info_header("src/subvq.c", 333L, "INFO");
#line 333
    if (s___0 < vq->n_sv) {
#line 333
      tmp___11 = "";
    } else {
#line 333
      tmp___11 = " (not used)";
    }
#line 333
    _E__pr_info("Reading subvq %d%s\n", s___0, tmp___11);
#line 335
    _E__pr_info_header("src/subvq.c", 335L, "INFO");
#line 335
    _E__pr_info("Reading codebook\n");
#line 336
    tmp___12 = fgets((char * __restrict  )(line), (int )sizeof(line), (FILE * __restrict  )fp);
#line 336
    if ((unsigned long )tmp___12 == (unsigned long )((void *)0)) {
#line 338
      _E__pr_header("src/subvq.c", 338L, "FATAL_ERROR");
#line 338
      _E__die_error("Error reading codebook header\n", s___0);
    } else {
#line 336
      tmp___13 = sscanf((char const   * __restrict  )(line), (char const   * __restrict  )"Codebook %d",
                        & k___0);
#line 336
      if (tmp___13 != 1) {
#line 338
        _E__pr_header("src/subvq.c", 338L, "FATAL_ERROR");
#line 338
        _E__die_error("Error reading codebook header\n", s___0);
      } else
#line 336
      if (k___0 != s___0) {
#line 338
        _E__pr_header("src/subvq.c", 338L, "FATAL_ERROR");
#line 338
        _E__die_error("Error reading codebook header\n", s___0);
      }
    }
#line 340
    r = 0;
#line 340
    while (r < vq->vqsize) {
#line 342
      tmp___14 = fgets((char * __restrict  )(line), (int )sizeof(line), (FILE * __restrict  )fp);
#line 342
      if ((unsigned long )tmp___14 == (unsigned long )((void *)0)) {
#line 343
        _E__pr_header("src/subvq.c", 343L, "FATAL_ERROR");
#line 343
        _E__die_error("Error reading row(%d)\n", r);
      }
#line 345
      if (s___0 >= vq->n_sv) {
#line 346
        goto __Cont;
      }
#line 348
      strp = line;
#line 348
      c = 0;
#line 348
      while (c < veclen) {
#line 349
        tmp___15 = sscanf((char const   * __restrict  )strp, (char const   * __restrict  )"%f %f%n",
                          *((vq->gautbl + s___0)->mean + r) + c, *((vq->gautbl + s___0)->var + r) + c,
                          & k___0);
#line 349
        if (tmp___15 != 2) {
#line 351
          _E__pr_header("src/subvq.c", 351L, "FATAL_ERROR");
#line 351
          _E__die_error("Error reading row(%d) col(%d)\n", r, c);
        }
#line 354
        strp += k___0;
#line 348
        c ++;
      }
#line 358
      while (c < a_veclen) {
#line 359
        *(*((vq->gautbl + s___0)->mean + r) + c) = (float32 )0.0;
#line 360
        *(*((vq->gautbl + s___0)->var + r) + c) = (float32 )0.0;
#line 358
        c ++;
      }
      __Cont: /* CIL Label */ 
#line 340
      r ++;
    }
#line 365
    _E__pr_info_header("src/subvq.c", 365L, "INFO");
#line 365
    _E__pr_info("Reading map\n");
#line 366
    tmp___16 = fgets((char * __restrict  )(line), (int )sizeof(line), (FILE * __restrict  )fp);
#line 366
    if ((unsigned long )tmp___16 == (unsigned long )((void *)0)) {
#line 368
      _E__pr_header("src/subvq.c", 368L, "FATAL_ERROR");
#line 368
      _E__die_error("Error reading map header\n", s___0);
    } else {
#line 366
      tmp___17 = sscanf((char const   * __restrict  )(line), (char const   * __restrict  )"Map %d",
                        & k___0);
#line 366
      if (tmp___17 != 1) {
#line 368
        _E__pr_header("src/subvq.c", 368L, "FATAL_ERROR");
#line 368
        _E__die_error("Error reading map header\n", s___0);
      } else
#line 366
      if (k___0 != s___0) {
#line 368
        _E__pr_header("src/subvq.c", 368L, "FATAL_ERROR");
#line 368
        _E__die_error("Error reading map header\n", s___0);
      }
    }
#line 370
    r = 0;
#line 370
    while (r < vq->origsize.r) {
#line 371
      tmp___18 = fgets((char * __restrict  )(line), (int )sizeof(line), (FILE * __restrict  )fp);
#line 371
      if ((unsigned long )tmp___18 == (unsigned long )((void *)0)) {
#line 372
        _E__pr_header("src/subvq.c", 372L, "FATAL_ERROR");
#line 372
        _E__die_error("Error reading row(%d)\n", r);
      }
#line 374
      if (s___0 >= vq->n_sv) {
#line 375
        goto __Cont___0;
      }
#line 377
      strp = line;
#line 377
      c = 0;
#line 377
      while (c < vq->origsize.c) {
#line 378
        tmp___19 = sscanf((char const   * __restrict  )strp, (char const   * __restrict  )"%d%n",
                          *(*(vq->map + r) + c) + s___0, & k___0);
#line 378
        if (tmp___19 != 1) {
#line 379
          _E__pr_header("src/subvq.c", 379L, "FATAL_ERROR");
#line 379
          _E__die_error("Error reading row(%d) col(%d)\n", r, c);
        }
#line 380
        strp += k___0;
#line 377
        c ++;
      }
      __Cont___0: /* CIL Label */ 
#line 370
      r ++;
    }
#line 384
    fflush(stdout);
#line 328
    s___0 ++;
  }
#line 387
  tmp___20 = fscanf((FILE * __restrict  )fp, (char const   * __restrict  )"%s", line);
#line 387
  if (tmp___20 != 1) {
#line 388
    _E__pr_header("src/subvq.c", 388L, "FATAL_ERROR");
#line 388
    _E__die_error("Error reading \'End\' token\n");
  } else {
#line 387
    if (0) {
#line 387
      __s1_len = __builtin_strlen((char const   *)(line));
#line 387
      __s2_len = __builtin_strlen("End");
#line 387
      if (! ((size_t )((void const   *)(line + 1)) - (size_t )((void const   *)(line)) == 1UL)) {
#line 387
        goto _L___0;
      } else
#line 387
      if (__s1_len >= 4UL) {
        _L___0: /* CIL Label */ 
#line 387
        if (! ((size_t )((void const   *)("End" + 1)) - (size_t )((void const   *)"End") == 1UL)) {
#line 387
          tmp___27 = 1;
        } else
#line 387
        if (__s2_len >= 4UL) {
#line 387
          tmp___27 = 1;
        } else {
#line 387
          tmp___27 = 0;
        }
      } else {
#line 387
        tmp___27 = 0;
      }
#line 387
      if (tmp___27) {
#line 387
        tmp___22 = __builtin_strcmp((char const   *)(line), "End");
#line 387
        tmp___26 = tmp___22;
      } else {
#line 387
        tmp___25 = __builtin_strcmp((char const   *)(line), "End");
#line 387
        tmp___26 = tmp___25;
      }
    } else {
#line 387
      tmp___25 = __builtin_strcmp((char const   *)(line), "End");
#line 387
      tmp___26 = tmp___25;
    }
#line 387
    if (tmp___26 != 0) {
#line 388
      _E__pr_header("src/subvq.c", 388L, "FATAL_ERROR");
#line 388
      _E__die_error("Error reading \'End\' token\n");
    }
  }
#line 390
  fclose(fp);
#line 392
  subvq_maha_precomp(vq, varfloor);
#line 393
  subvq_map_compact(vq, g);
#line 394
  subvq_map_linearize(vq);
#line 396
  n = 0;
#line 397
  s___0 = 0;
#line 397
  while (s___0 < n_sv) {
#line 398
    if ((vq->gautbl + s___0)->veclen > n) {
#line 399
      n = (vq->gautbl + s___0)->veclen;
    }
#line 397
    s___0 ++;
  }
#line 401
  if (! (n > 0)) {
#line 401
    __assert_fail("n > 0", "src/subvq.c", 401U, "subvq_init");
  }
#line 403
  s___0 = 0;
#line 403
  while (s___0 < vq->n_sv) {
#line 404
    tmp___28 = __ckd_calloc__((size_t )n, sizeof(float32 ), "src/subvq.c", 404);
#line 404
    vq->thrd_subvec[s___0] = (float32 *)tmp___28;
#line 403
    s___0 ++;
  }
#line 406
  s___0 = 0;
#line 406
  while (s___0 < 1) {
#line 407
    tmp___29 = __ckd_calloc__((size_t )vq->origsize.c, sizeof(int32 ), "src/subvq.c",
                              407);
#line 407
    vq->thrd_gauscore[s___0] = (int32 *)tmp___29;
#line 408
    tmp___30 = __ckd_calloc__((size_t )(vq->origsize.c + 1), sizeof(int32 ), "src/subvq.c",
                              408);
#line 408
    vq->thrd_mgau_sl[s___0] = (int32 *)tmp___30;
#line 406
    s___0 ++;
  }
#line 415
  tmp___31 = __ckd_calloc__((size_t )n, sizeof(float32 ), "src/subvq.c", 415);
#line 415
  vq->subvec = (float32 *)tmp___31;
#line 417
  tmp___32 = __ckd_calloc_2d__(vq->n_sv, vq->vqsize, (int32 )sizeof(int32 ), "src/subvq.c",
                               417);
#line 417
  vq->vqdist = (int32 **)tmp___32;
#line 419
  tmp___33 = __ckd_calloc__((size_t )vq->origsize.c, sizeof(int32 ), "src/subvq.c",
                            419);
#line 419
  vq->gauscore = (int32 *)tmp___33;
#line 420
  tmp___34 = __ckd_calloc__((size_t )(vq->origsize.c + 1), sizeof(int32 ), "src/subvq.c",
                            420);
#line 420
  vq->mgau_sl = (int32 *)tmp___34;
#line 422
  return (vq);
}
}
#line 431 "src/subvq.c"
static int32 subvq_mgau_shortlist(subvq_t *vq , int32 m , int32 n , int32 beam ) 
{ 
  int32 *gauscore ;
  int32 *map ;
  int32 i ;
  int32 v ;
  int32 bv___0 ;
  int32 th ;
  int32 nc ;
  int32 *sl ;
  int32 *vqdist ;
  int32 *tmp ;
  int32 *tmp___0 ;
  int32 *tmp___1 ;
  int32 *tmp___2 ;
  int32 *tmp___3 ;
  int32 *tmp___4 ;
  int32 *tmp___5 ;
  int32 tmp___6 ;

  {
#line 442
  vqdist = *(vq->vqdist + 0);
#line 444
  gauscore = vq->gauscore;
#line 445
  sl = vq->mgau_sl;
#line 448
  map = *(*(vq->map + m) + 0);
#line 449
  bv___0 = (int32 )2147483648U;
#line 451
  switch (vq->n_sv) {
  case 3: 
#line 453
  i = 0;
#line 453
  while (i < n) {
#line 454
    if (VQ_EVAL == 1) {
#line 455
      v = *(vqdist + *map);
#line 456
      map += 3;
    } else
#line 460
    if (VQ_EVAL == 2) {
#line 461
      tmp = map;
#line 461
      map ++;
#line 461
      v = *(vqdist + *tmp);
#line 462
      v += 2 * *(vqdist + *map);
#line 463
      map += 2;
    } else {
#line 465
      tmp___0 = map;
#line 465
      map ++;
#line 465
      v = *(vqdist + *tmp___0);
#line 466
      tmp___1 = map;
#line 466
      map ++;
#line 466
      v += *(vqdist + *tmp___1);
#line 467
      tmp___2 = map;
#line 467
      map ++;
#line 467
      v += *(vqdist + *tmp___2);
    }
#line 471
    *(gauscore + i) = v;
#line 473
    if (bv___0 < v) {
#line 474
      bv___0 = v;
    }
#line 453
    i ++;
  }
#line 476
  break;
  case 2: 
#line 478
  i = 0;
#line 478
  while (i < n) {
#line 479
    tmp___3 = map;
#line 479
    map ++;
#line 479
    v = *(vqdist + *tmp___3);
#line 480
    tmp___4 = map;
#line 480
    map ++;
#line 480
    v += *(vqdist + *tmp___4);
#line 481
    *(gauscore + i) = v;
#line 483
    if (bv___0 < v) {
#line 484
      bv___0 = v;
    }
#line 478
    i ++;
  }
#line 486
  break;
  case 1: 
#line 488
  i = 0;
#line 488
  while (i < n) {
#line 489
    tmp___5 = map;
#line 489
    map ++;
#line 489
    v = *(vqdist + *tmp___5);
#line 490
    *(gauscore + i) = v;
#line 492
    if (bv___0 < v) {
#line 493
      bv___0 = v;
    }
#line 488
    i ++;
  }
#line 495
  break;
  default: 
#line 497
  _E__pr_header("src/subvq.c", 497L, "FATAL_ERROR");
#line 497
  _E__die_error("#Subvectors %d not yet implemented\n", vq->n_sv);
  }
#line 500
  th = bv___0 + beam;
#line 501
  nc = 0;
#line 502
  i = 0;
#line 502
  while (i < n) {
#line 503
    if (*(gauscore + i) >= th) {
#line 504
      tmp___6 = nc;
#line 504
      nc ++;
#line 504
      *(sl + tmp___6) = i;
    }
#line 502
    i ++;
  }
#line 506
  *(sl + nc) = -1;
#line 508
  return (nc);
}
}
#line 527 "src/subvq.c"
void subvq_gautbl_eval_logs3(subvq_t *vq , float32 *feat___0 ) 
{ 
  int32 s___0 ;
  int32 i ;
  int32 *featdim ;

  {
#line 532
  s___0 = 0;
#line 532
  while (s___0 < vq->n_sv) {
#line 534
    featdim = *(vq->featdim + s___0);
#line 535
    i = 0;
#line 535
    while (i < (vq->gautbl + s___0)->veclen) {
#line 536
      *(vq->subvec + i) = *(feat___0 + *(featdim + i));
#line 535
      i ++;
    }
#line 542
    if (s___0 < VQ_EVAL) {
#line 543
      vector_gautbl_eval_logs3(vq->gautbl + s___0, 0, vq->vqsize, vq->subvec, *(vq->vqdist + s___0));
    }
#line 532
    s___0 ++;
  }
#line 549
  return;
}
}
#line 554 "src/subvq.c"
int32 sema  =    0;
#line 559 "src/subvq.c"
void thrd_subvq_gautbl_eval_logs3(int subvec_num , subvq_t *vq , float32 *feat___0 ) 
{ 
  int32 s___0 ;
  int32 i ;
  int32 *featdim ;

  {
#line 566
  s___0 = 0;
#line 566
  while (s___0 < vq->n_sv) {
#line 568
    featdim = *(vq->featdim + s___0);
#line 569
    i = 0;
#line 569
    while (i < (vq->gautbl + s___0)->veclen) {
#line 570
      *(vq->subvec + i) = *(feat___0 + *(featdim + i));
#line 569
      i ++;
    }
#line 573
    if (s___0 < VQ_EVAL) {
#line 577
      vector_gautbl_eval_logs3(vq->gautbl + s___0, 0, vq->vqsize, vq->subvec, *(vq->vqdist + s___0));
    }
#line 566
    s___0 ++;
  }
#line 664
  return;
}
}
#line 694 "src/subvq.c"
int32 subvq_frame_eval(subvq_t *vq , mgau_model_t *g , int32 beam , float32 *feat___0 ,
                       int32 *sen_active , int32 *senscr ) 
{ 
  int32 s___0 ;
  int32 best ;
  int32 ns ;
  int32 ng ;
  int32 tmp ;

  {
#line 700
  best = (int32 )2147483648U;
#line 701
  ns = 0;
#line 702
  ng = 0;
#line 704
  if (! vq) {
#line 706
    s___0 = 0;
#line 706
    while (s___0 < g->n_mgau) {
#line 707
      if (! sen_active) {
#line 707
        goto _L;
      } else
#line 707
      if (*(sen_active + s___0)) {
        _L: /* CIL Label */ 
#line 708
        *(senscr + s___0) = mgau_eval(g, s___0, (int32 *)((void *)0), feat___0);
#line 709
        if (best < *(senscr + s___0)) {
#line 710
          best = *(senscr + s___0);
        }
#line 711
        ns ++;
#line 712
        ng += (g->mgau + s___0)->n_comp;
      } else {
#line 714
        *(senscr + s___0) = (int32 )3355443200U;
      }
#line 706
      s___0 ++;
    }
  } else {
#line 718
    subvq_gautbl_eval_logs3(vq, feat___0);
#line 721
    s___0 = 0;
#line 721
    while (s___0 < g->n_mgau) {
#line 722
      if (! sen_active) {
#line 722
        goto _L___0;
      } else
#line 722
      if (*(sen_active + s___0)) {
        _L___0: /* CIL Label */ 
#line 723
        tmp = subvq_mgau_shortlist(vq, s___0, (g->mgau + s___0)->n_comp, beam);
#line 723
        ng += tmp;
#line 725
        *(senscr + s___0) = mgau_eval(g, s___0, vq->mgau_sl, feat___0);
#line 726
        if (best < *(senscr + s___0)) {
#line 727
          best = *(senscr + s___0);
        }
#line 729
        ns ++;
      } else {
#line 732
        *(senscr + s___0) = (int32 )3355443200U;
      }
#line 721
      s___0 ++;
    }
  }
#line 737
  s___0 = 0;
#line 737
  while (s___0 < g->n_mgau) {
#line 738
    *(senscr + s___0) -= best;
#line 737
    s___0 ++;
  }
#line 740
  g->frm_sen_eval = ns;
#line 741
  g->frm_gau_eval = ng;
#line 743
  return (best);
}
}
#line 747 "src/subvq.c"
void subvq_free(subvq_t *s___0 ) 
{ 
  int i ;

  {
#line 751
  if (s___0) {
#line 753
    i = 0;
#line 753
    while (i < s___0->n_sv) {
#line 755
      if (*(s___0->featdim + i)) {
#line 755
        free((void *)*(s___0->featdim + i));
      }
#line 753
      i ++;
    }
#line 759
    if (s___0->featdim) {
#line 760
      free((void *)s___0->featdim);
    }
#line 763
    if (s___0->gautbl) {
#line 764
      free((void *)s___0->gautbl);
    }
#line 768
    if (s___0->map) {
#line 769
      ckd_free_3d((void ***)s___0->map);
    }
#line 771
    if (s___0->subvec) {
#line 772
      free((void *)s___0->subvec);
    }
#line 774
    if (s___0->vqdist) {
#line 775
      ckd_free_2d((void **)s___0->vqdist);
    }
#line 777
    if (s___0->gauscore) {
#line 778
      free((void *)s___0->gauscore);
    }
#line 780
    if (s___0->mgau_sl) {
#line 781
      free((void *)s___0->mgau_sl);
    }
#line 784
    free((void *)s___0);
  }
#line 788
  return;
}
}
#line 1 "threading.o"
#pragma merger("0","/tmp/cil-1QlDRqWr.i","-g,-O4")
#line 150 "/usr/include/x86_64-linux-gnu/bits/mathinline.h"
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__, __always_inline__)) __signbitl)(long double __x )  __attribute__((__const__)) ;
#line 150 "/usr/include/x86_64-linux-gnu/bits/mathinline.h"
__inline extern int ( __attribute__((__leaf__, __always_inline__)) __signbitl)(long double __x ) 
{ 
  union __anonunion___u_42 __u ;

  {
#line 153
  __u.__l = __x;
#line 154
  return ((__u.__i[2] & 32768) != 0);
}
}
#line 174 "src/hmm.h"
void hmm_clear(hmm_t *h , int32 n_state ) ;
#line 195
int32 hmm_vit_eval_3st(hmm_t *hmm , s3senid_t *senid , int32 *senscr ) ;
#line 267 "src/vithist.h"
void vithist_rescore(vithist_t *vh , kbcore_t *kbc , s3wid_t wid , int32 ef , int32 score ,
                     int32 pred , int32 type ) ;
#line 315
pthread_mutex_t update_lock ;
#line 110 "src/threading.h"
void ThreadJoin(void) ;
#line 111
void threading_support_init(kb_t *kb___0 ) ;
#line 112
void *frame_eval_thrd_work(thread_args_t *thrd_args ) ;
#line 114
void dict2pid_comsenscr_thrd_work(thread_args_t *thrd_args ) ;
#line 115
void lextree_hmm_eval_thrd_work(thread_args_t *thrd_args ) ;
#line 116
void lextree_hmm_ppg_thrd_work(thread_args_t *thrd_args ) ;
#line 117
void thrd_scoring_phase(scoring_args_t *score_args ) ;
#line 118
void new_thrd_lextree_hmm_eval(searching_args_t *search_args , int32 *besthmmscr ,
                               int32 *bestwordscr , int32 *n_hmm_eval , int32 *frm_nhmm ) ;
#line 121
void new_lextree_hmm_eval_thrd_work(thread_args_t *thrd_args ) ;
#line 122
void new_thrd_lextree_hmm_propagate(searching_args_t *search_args ) ;
#line 123
void new_lextree_hmm_ppg_thrd_work(thread_args_t *thrd_args ) ;
#line 58 "src/threading.c"
barrier_t *score_barrier ;
#line 59 "src/threading.c"
pthread_mutex_t update_lock  =    {{0, 0U, 0, 0U, 0, 0, {(struct __pthread_internal_list *)0, (struct __pthread_internal_list *)0}}};
#line 61 "src/threading.c"
int thread_arrived  =    0;
#line 62 "src/threading.c"
int wk_idx  =    0;
#line 64 "src/threading.c"
thread_args_t thread_data_array[1]  ;
#line 70 "src/threading.c"
int32 best_array[1]  ;
#line 71 "src/threading.c"
int32 wbest_array[1]  ;
#line 72 "src/threading.c"
int32 ns_array[1]  ;
#line 73 "src/threading.c"
int32 ng_array[1]  ;
#line 75 "src/threading.c"
int32 *he_best_array[1]  ;
#line 76 "src/threading.c"
int32 *he_wbest_array[1]  ;
#line 78 "src/threading.c"
lextree_node_t ***next_active_array[1]  ;
#line 79 "src/threading.c"
int32 *next_active_size[1]  ;
#line 80 "src/threading.c"
int32 *private_n[1]  ;
#line 84 "src/threading.c"
lextree_node_t **double_next_active(int32 t , int32 ltn , int32 *array_size ) 
{ 
  void *tmp ;

  {
#line 86
  *(next_active_size[t] + ltn) <<= 1;
#line 87
  tmp = realloc((void *)*(next_active_array[t] + ltn), (unsigned long )*(next_active_size[t] + ltn) * sizeof(lextree_node_t *));
#line 87
  *(next_active_array[t] + ltn) = (lextree_node_t **)tmp;
#line 89
  *array_size = *(next_active_size[t] + ltn);
#line 90
  return (*(next_active_array[t] + ltn));
}
}
#line 93 "src/threading.c"
void threading_support_init(kb_t *kb___0 ) 
{ 
  int32 n ;
  int32 i ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;

  {
#line 97
  n = 0;
#line 97
  while (n < 1) {
#line 98
    tmp = __ckd_calloc__((size_t )(kb___0->n_lextree << 1), sizeof(int32 ), "src/threading.c",
                         98);
#line 98
    next_active_size[n] = (int32 *)tmp;
#line 99
    tmp___0 = __ckd_calloc__((size_t )(kb___0->n_lextree << 1), sizeof(lextree_node_t **),
                             "src/threading.c", 100);
#line 99
    next_active_array[n] = (lextree_node_t ***)tmp___0;
#line 101
    tmp___1 = __ckd_calloc__((size_t )(kb___0->n_lextree << 1), sizeof(int32 ), "src/threading.c",
                             101);
#line 101
    private_n[n] = (int32 *)tmp___1;
#line 103
    i = 0;
#line 103
    while (i < kb___0->n_lextree << 1) {
#line 104
      *(next_active_size[n] + i) = 16;
#line 105
      tmp___2 = __ckd_calloc__((size_t )16, sizeof(lextree_node_t *), "src/threading.c",
                               106);
#line 105
      *(next_active_array[n] + i) = (lextree_node_t **)tmp___2;
#line 103
      i ++;
    }
#line 109
    tmp___3 = __ckd_calloc__((size_t )(kb___0->n_lextree << 1), sizeof(int32 ), "src/threading.c",
                             109);
#line 109
    he_best_array[n] = (int32 *)tmp___3;
#line 110
    tmp___4 = __ckd_calloc__((size_t )(kb___0->n_lextree << 1), sizeof(int32 ), "src/threading.c",
                             110);
#line 110
    he_wbest_array[n] = (int32 *)tmp___4;
#line 97
    n ++;
  }
#line 112
  return;
}
}
#line 114 "src/threading.c"
static int32 thrd_subvq_mgau_shortlist(int t , subvq_t *vq , int32 m , int32 n , int32 beam ) 
{ 
  int32 *gauscore ;
  int32 *map ;
  int32 i ;
  int32 v ;
  int32 bv___0 ;
  int32 th ;
  int32 nc ;
  int32 *sl ;
  int32 *vqdist ;
  int32 *tmp ;
  int32 *tmp___0 ;
  int32 *tmp___1 ;
  int32 *tmp___2 ;
  int32 *tmp___3 ;
  int32 *tmp___4 ;
  int32 *tmp___5 ;
  int32 tmp___6 ;

  {
#line 126
  vqdist = *(vq->vqdist + 0);
#line 128
  gauscore = vq->thrd_gauscore[t];
#line 129
  sl = vq->thrd_mgau_sl[t];
#line 132
  map = *(*(vq->map + m) + 0);
#line 133
  bv___0 = (int32 )2147483648U;
#line 135
  switch (vq->n_sv) {
  case 3: 
#line 137
  i = 0;
#line 137
  while (i < n) {
#line 138
    if (VQ_EVAL == 1) {
#line 139
      v = *(vqdist + *map);
#line 140
      map += 3;
    } else
#line 144
    if (VQ_EVAL == 2) {
#line 145
      tmp = map;
#line 145
      map ++;
#line 145
      v = *(vqdist + *tmp);
#line 146
      v += 2 * *(vqdist + *map);
#line 147
      map += 2;
    } else {
#line 149
      tmp___0 = map;
#line 149
      map ++;
#line 149
      v = *(vqdist + *tmp___0);
#line 150
      tmp___1 = map;
#line 150
      map ++;
#line 150
      v += *(vqdist + *tmp___1);
#line 151
      tmp___2 = map;
#line 151
      map ++;
#line 151
      v += *(vqdist + *tmp___2);
    }
#line 155
    *(gauscore + i) = v;
#line 157
    if (bv___0 < v) {
#line 158
      bv___0 = v;
    }
#line 137
    i ++;
  }
#line 160
  break;
  case 2: 
#line 162
  i = 0;
#line 162
  while (i < n) {
#line 163
    tmp___3 = map;
#line 163
    map ++;
#line 163
    v = *(vqdist + *tmp___3);
#line 164
    tmp___4 = map;
#line 164
    map ++;
#line 164
    v += *(vqdist + *tmp___4);
#line 165
    *(gauscore + i) = v;
#line 167
    if (bv___0 < v) {
#line 168
      bv___0 = v;
    }
#line 162
    i ++;
  }
#line 170
  break;
  case 1: 
#line 172
  i = 0;
#line 172
  while (i < n) {
#line 173
    tmp___5 = map;
#line 173
    map ++;
#line 173
    v = *(vqdist + *tmp___5);
#line 174
    *(gauscore + i) = v;
#line 176
    if (bv___0 < v) {
#line 177
      bv___0 = v;
    }
#line 172
    i ++;
  }
#line 179
  break;
  default: 
#line 181
  _E__pr_header("src/threading.c", 181L, "FATAL_ERROR");
#line 181
  _E__die_error("#Subvectors %d not yet implemented\n", vq->n_sv);
  }
#line 184
  th = bv___0 + beam;
#line 185
  nc = 0;
#line 186
  i = 0;
#line 186
  while (i < n) {
#line 187
    if (*(gauscore + i) >= th) {
#line 188
      tmp___6 = nc;
#line 188
      nc ++;
#line 188
      *(sl + tmp___6) = i;
    }
#line 186
    i ++;
  }
#line 190
  *(sl + nc) = -1;
#line 192
  return (nc);
}
}
#line 196 "src/threading.c"
void *frame_eval_thrd_work(thread_args_t *thrd_args ) 
{ 
  int t ;
  int32 start ;
  int32 end ;
  scoring_args_t *my_data ;
  subvq_t *vq ;
  mgau_model_t *g ;
  int32 beam ;
  float32 *feat___0 ;
  int32 *sen_active ;
  int32 *senscr ;
  int32 s___0 ;
  int32 best ;
  int32 ns ;
  int32 ng ;
  int go ;
  int32 tmp ;

  {
#line 198
  t = thrd_args->id;
#line 199
  start = thrd_args->feval_start;
#line 200
  end = thrd_args->feval_end;
#line 201
  my_data = thrd_args->score_args;
#line 202
  vq = my_data->vq;
#line 203
  g = my_data->g;
#line 204
  beam = my_data->beam;
#line 205
  feat___0 = my_data->feat;
#line 206
  sen_active = my_data->sen_active;
#line 207
  senscr = my_data->senscr;
#line 212
  best = (int32 )2147483648U;
#line 213
  ns = 0;
#line 214
  ng = 0;
#line 216
  if (! vq) {
#line 219
    s___0 = start;
#line 219
    while (s___0 < end) {
#line 220
      if (! sen_active) {
#line 220
        goto _L;
      } else
#line 220
      if (*(sen_active + s___0)) {
        _L: /* CIL Label */ 
#line 221
        *(senscr + s___0) = mgau_eval(g, s___0, (int32 *)((void *)0), feat___0);
#line 222
        if (best < *(senscr + s___0)) {
#line 223
          best = *(senscr + s___0);
        }
#line 224
        ns ++;
#line 225
        ng += (g->mgau + s___0)->n_comp;
      } else {
#line 227
        *(senscr + s___0) = (int32 )3355443200U;
      }
#line 219
      s___0 ++;
    }
  } else {
#line 230
    go = -1;
#line 264
    subvq_gautbl_eval_logs3(vq, feat___0);
#line 267
    s___0 = start;
#line 267
    while (s___0 < end) {
#line 268
      if (! sen_active) {
#line 268
        goto _L___0;
      } else
#line 268
      if (*(sen_active + s___0)) {
        _L___0: /* CIL Label */ 
#line 269
        tmp = thrd_subvq_mgau_shortlist(t, vq, s___0, (g->mgau + s___0)->n_comp, beam);
#line 269
        ng += tmp;
#line 271
        *(senscr + s___0) = mgau_eval(g, s___0, vq->thrd_mgau_sl[t], feat___0);
#line 272
        if (best < *(senscr + s___0)) {
#line 273
          best = *(senscr + s___0);
        }
#line 275
        ns ++;
      } else {
#line 278
        *(senscr + s___0) = (int32 )3355443200U;
      }
#line 267
      s___0 ++;
    }
  }
#line 282
  best_array[t] = best;
#line 283
  ns_array[t] = ns;
#line 284
  ng_array[t] = ng;
#line 289
  if (thread_arrived < 0) {
#line 290
    thread_arrived ++;
  } else {
#line 292
    thread_arrived = 0;
#line 293
    best = best_array[0];
#line 294
    s___0 = 0;
#line 294
    while (s___0 < 1) {
#line 295
      if (best < best_array[s___0]) {
#line 296
        best = best_array[s___0];
      }
#line 294
      s___0 ++;
    }
#line 298
    best_array[0] = best;
  }
#line 303
  thread_barrier(thrd_args->id, score_barrier);
#line 307
  best = best_array[0];
#line 308
  s___0 = start;
#line 308
  while (s___0 < end) {
#line 309
    *(senscr + s___0) -= best;
#line 308
    s___0 ++;
  }
#line 311
  return ((void *)0);
}
}
#line 314 "src/threading.c"
void dict2pid_comsenscr_thrd_work(thread_args_t *thrd_args ) 
{ 
  scoring_args_t *my_data ;
  int32 start ;
  int32 end ;
  dict2pid_t *d2p ;
  int32 *comsenscr ;
  int32 *senscr ;
  int32 i ;
  int32 j ;
  int32 best ;
  s3senid_t *comstate ;
  s3senid_t k___0 ;

  {
#line 316
  my_data = thrd_args->score_args;
#line 317
  start = thrd_args->com_start;
#line 318
  end = thrd_args->com_end;
#line 319
  d2p = my_data->d2p;
#line 320
  comsenscr = my_data->comsenscr;
#line 321
  senscr = my_data->senscr;
#line 326
  i = start;
#line 326
  while (i < end) {
#line 328
    comstate = *(d2p->comstate + i);
#line 330
    best = *(senscr + *(comstate + 0));
#line 331
    j = 1;
#line 331
    while (1) {
#line 332
      k___0 = *(comstate + j);
#line 333
      if ((int )k___0 < 0) {
#line 334
        break;
      }
#line 335
      if (best < *(senscr + k___0)) {
#line 336
        best = *(senscr + k___0);
      }
#line 331
      j ++;
    }
#line 339
    *(comsenscr + i) = best + *(d2p->comwt + i);
#line 326
    i ++;
  }
#line 341
  return;
}
}
#line 343 "src/threading.c"
void lextree_hmm_eval_thrd_work(thread_args_t *thrd_args ) 
{ 
  int32 best ;
  int32 wbest ;
  int32 n_st ;
  int32 i ;
  int32 k___0 ;
  int32 start ;
  int32 end ;
  searching_args_t const   *s_args ;
  lextree_t const   *lextree ;
  kbcore_t const   *kbc ;
  ascr_t const   *ascr ;
  int32 frm ;
  FILE *fp ;
  lextree_node_t **list ;
  lextree_node_t *ln ;
  mdef_t *mdef ;
  dict2pid_t *d2p ;

  {
#line 347
  start = thrd_args->hmmeval_start;
#line 348
  end = thrd_args->hmmeval_end;
#line 349
  s_args = (searching_args_t const   *)thrd_args->search_args;
#line 350
  lextree = (lextree_t const   *)thrd_args->lextree;
#line 351
  kbc = (kbcore_t const   *)s_args->kbc;
#line 352
  ascr = (ascr_t const   *)s_args->ascr;
#line 353
  frm = (int32 )s_args->frm;
#line 354
  fp = (FILE *)s_args->fp;
#line 360
  mdef = (mdef_t *)kbc->mdef;
#line 361
  d2p = (dict2pid_t *)kbc->dict2pid;
#line 362
  n_st = mdef->n_emit_state;
#line 364
  list = (lextree_node_t **)lextree->active;
#line 365
  best = (int32 )2147483648U;
#line 366
  wbest = (int32 )2147483648U;
#line 368
  if (! fp) {
#line 368
    if (n_st == 3) {
#line 368
      if (! "not qualified") {
#line 368
        __assert_fail("!fp && n_st==3 && \"not qualified\"", "src/threading.c", 368U,
                      "lextree_hmm_eval_thrd_work");
      }
    } else {
#line 368
      __assert_fail("!fp && n_st==3 && \"not qualified\"", "src/threading.c", 368U,
                    "lextree_hmm_eval_thrd_work");
    }
  } else {
#line 368
    __assert_fail("!fp && n_st==3 && \"not qualified\"", "src/threading.c", 368U,
                  "lextree_hmm_eval_thrd_work");
  }
#line 369
  i = start;
#line 369
  while (i < end) {
#line 371
    ln = *(list + i);
#line 373
    if (! ((int )ln->frame == frm)) {
#line 373
      __assert_fail("ln->frame == frm", "src/threading.c", 373U, "lextree_hmm_eval_thrd_work");
    }
#line 375
    if (! ln->composite) {
#line 376
      k___0 = hmm_vit_eval_3st(& ln->hmm, *(mdef->sseq + ln->ssid), (int32 *)ascr->sen);
    } else {
#line 378
      k___0 = hmm_vit_eval_3st(& ln->hmm, *(d2p->comsseq + ln->ssid), (int32 *)ascr->comsen);
    }
#line 380
    if (best < k___0) {
#line 381
      best = k___0;
    }
#line 383
    if (ln->wid >= 0) {
#line 384
      if (wbest < k___0) {
#line 385
        wbest = k___0;
      }
    }
#line 369
    i ++;
  }
#line 388
  thrd_args->best = best;
#line 389
  thrd_args->wbest = wbest;
#line 391
  return;
}
}
#line 393 "src/threading.c"
int32 ln_lock(int32 t1 , lextree_node_t *ln ) 
{ 
  int32 retry ;
  int32 skip ;

  {
#line 395
  skip = 0;
#line 397
  while (1) {
#line 399
    retry = 0;
#line 403
    if ((int )ln->synch != 0) {
#line 404
      if ((int )ln->synch > t1) {
#line 405
        skip = 1;
      } else {
#line 407
        retry = 1;
      }
    } else {
#line 409
      ln->synch = (int8 )t1;
    }
#line 397
    if (! retry) {
#line 397
      break;
    }
  }
#line 416
  return (skip);
}
}
#line 419 "src/threading.c"
int32 ln_lock_child(int32 t1 , lextree_node_t *ln ) 
{ 
  int32 retry ;
  int32 skip ;

  {
#line 421
  skip = 0;
#line 423
  while (1) {
#line 425
    retry = 0;
#line 429
    if ((int )ln->synch != 0) {
#line 430
      retry = 1;
    } else {
#line 432
      ln->synch = (int8 )t1;
    }
#line 423
    if (! retry) {
#line 423
      break;
    }
  }
#line 440
  return (skip);
}
}
#line 443 "src/threading.c"
void ln_unlock(int32 t , lextree_node_t *ln ) 
{ 


  {
#line 448
  if (t == (int32 )ln->synch) {
#line 449
    ln->synch = (int8 )0;
  }
#line 454
  return;
}
}
#line 457 "src/threading.c"
void lextree_hmm_ppg_thrd_work(thread_args_t *thrd_args ) 
{ 
  mdef_t *mdef ;
  int32 nf ;
  int32 newscore ;
  lextree_t const   *lextree ;
  lextree_node_t **list ;
  lextree_node_t *ln ;
  lextree_node_t *ln2 ;
  hmm_t *hmm ;
  hmm_t *hmm2 ;
  gnode_t *gn ;
  int32 i ;
  int32 n ;
  int32 t ;
  int32 t1 ;
  int32 ltn ;
  int32 start ;
  int32 end ;
  searching_args_t const   *s_args ;
  kbcore_t *kbc ;
  int32 cf ;
  int32 th ;
  int32 wth ;
  int32 pth ;
  vithist_t *vh ;
  lextree_node_t **next_active ;
  int32 next_active_array_size ;
  int32 tmp ;
  int32 tmp___0 ;
  int32 tmp___1 ;
  int32 tmp___2 ;

  {
#line 461
  lextree = (lextree_t const   *)thrd_args->lextree;
#line 462
  list = (lextree_node_t **)lextree->active;
#line 467
  t = thrd_args->id;
#line 468
  t1 = t + 1;
#line 469
  ltn = thrd_args->lextree_num;
#line 471
  start = thrd_args->hmmppg_start;
#line 472
  end = thrd_args->hmmppg_end;
#line 473
  s_args = (searching_args_t const   *)thrd_args->search_args;
#line 475
  kbc = (kbcore_t *)s_args->kbc;
#line 476
  cf = (int32 )s_args->frm;
#line 477
  th = (int32 )s_args->th;
#line 478
  wth = (int32 )s_args->wth;
#line 479
  pth = (int32 )s_args->pth;
#line 480
  vh = (vithist_t *)s_args->vithist;
#line 481
  next_active = *(next_active_array[t] + ltn);
#line 482
  next_active_array_size = *(next_active_size[t] + ltn);
#line 484
  mdef = kbc->mdef;
#line 486
  nf = cf + 1;
#line 490
  if (! (lextree->n_next_active == 0)) {
#line 490
    __assert_fail("lextree->n_next_active==0", "src/threading.c", 490U, "lextree_hmm_ppg_thrd_work");
  }
#line 491
  n = 0;
#line 493
  i = start;
#line 493
  while (i < end) {
#line 494
    ln = *(list + i);
#line 495
    hmm = & ln->hmm;
#line 497
    tmp___0 = ln_lock(t1, ln);
#line 497
    if (! tmp___0) {
#line 497
      if ((int )ln->frame < nf) {
#line 498
        if (hmm->bestscore >= th) {
#line 500
          ln->frame = (s3frmid_t )nf;
#line 502
          if (n == next_active_array_size) {
#line 503
            next_active = double_next_active(t, ltn, & next_active_array_size);
          }
#line 504
          tmp = n;
#line 504
          n ++;
#line 504
          *(next_active + tmp) = ln;
        } else
#line 507
        if ((int )ln->frame != nf) {
#line 508
          ln->frame = (s3frmid_t )-1;
#line 509
          hmm_clear(hmm, mdef->n_emit_state);
        }
      }
    }
#line 514
    ln_unlock(t1, ln);
#line 516
    if (ln->wid < 0) {
#line 518
      if (hmm->out.score < pth) {
#line 519
        goto __Cont;
      }
#line 522
      gn = ln->children;
#line 522
      while (gn) {
#line 523
        ln2 = (lextree_node_t *)gn->data.ptr;
#line 524
        hmm2 = & ln2->hmm;
#line 526
        tmp___2 = ln_lock_child(t1, ln2);
#line 526
        if (! tmp___2) {
#line 527
          newscore = hmm->out.score + (ln2->prob - ln->prob);
#line 529
          if (newscore >= th) {
#line 529
            if (hmm2->in.score < newscore) {
#line 530
              hmm2->in.score = newscore;
#line 531
              hmm2->in.history = hmm->out.history;
#line 533
              if ((int )ln2->frame != nf) {
#line 534
                ln2->frame = (s3frmid_t )nf;
#line 536
                if (n == next_active_array_size) {
#line 537
                  next_active = double_next_active(t, ltn, & next_active_array_size);
                }
#line 539
                tmp___1 = n;
#line 539
                n ++;
#line 539
                *(next_active + tmp___1) = ln2;
              }
            }
          }
        }
#line 543
        ln_unlock(t1, ln2);
#line 522
        gn = gn->next;
      }
    } else {
#line 546
      if (hmm->out.score < wth) {
#line 547
        goto __Cont;
      }
#line 557
      vithist_rescore(vh, kbc, ln->wid, cf, hmm->out.score - ln->prob, hmm->out.history,
                      (int32 )lextree->type);
    }
    __Cont: /* CIL Label */ 
#line 493
    i ++;
  }
#line 565
  *(private_n[t] + ltn) = n;
#line 567
  return;
}
}
#line 569 "src/threading.c"
void ThreadJoin(void) 
{ 


  {
#line 581
  return;
}
}
#line 583 "src/threading.c"
void lextree_ssid_active_thrd_work(thread_args_t *t_args , int32 *ssid , int32 *comssid ) 
{ 
  lextree_t *lextree ;
  lextree_node_t **list ;
  lextree_node_t *ln ;
  int32 i ;
  int start ;
  int end ;

  {
#line 586
  lextree = t_args->lextree;
#line 589
  start = t_args->hmmeval_start;
#line 590
  end = t_args->hmmeval_end;
#line 592
  list = lextree->active;
#line 594
  i = start;
#line 594
  while (i < end) {
#line 595
    ln = *(list + i);
#line 596
    if (ln->composite) {
#line 597
      *(comssid + ln->ssid) = 1;
    } else {
#line 599
      *(ssid + ln->ssid) = 1;
    }
#line 594
    i ++;
  }
#line 601
  return;
}
}
#line 603 "src/threading.c"
void sseq2sen_active_thrd_work(thread_args_t *t_args ) 
{ 
  int32 ss ;
  int32 cs ;
  int32 i ;
  int32 j ;
  s3senid_t *csp ;
  s3senid_t *sp ;
  mdef_t *mdef ;
  dict2pid_t *d2p ;
  kb_t *kb___0 ;
  int32 *sseq ;
  int32 *comssid ;
  int32 *sen ;
  int32 n_sseq ;
  int32 n_comsseq ;
  int32 s_start ;
  int32 s_end ;
  int32 c_start ;
  int32 c_end ;
  int32 mdef_chunk_size ;
  int32 mdef_remainder ;
  int32 d2p_chunk_size ;
  int32 d2p_remainder ;
  int32 t ;
  int32 tmp ;
  int tmp___0 ;
  int32 tmp___1 ;
  int tmp___2 ;

  {
#line 607
  mdef = (t_args->sa_args)->mdef;
#line 608
  d2p = (t_args->sa_args)->d2p;
#line 609
  kb___0 = (t_args->sa_args)->kb;
#line 610
  sseq = kb___0->ssid_active;
#line 611
  comssid = kb___0->comssid_active;
#line 612
  sen = kb___0->sen_active;
#line 613
  n_sseq = mdef->n_sseq;
#line 614
  n_comsseq = d2p->n_comsseq;
#line 616
  mdef_chunk_size = n_sseq;
#line 617
  mdef_remainder = 0;
#line 618
  d2p_chunk_size = n_comsseq;
#line 619
  d2p_remainder = 0;
#line 620
  t = t_args->id;
#line 622
  if (t == 0) {
#line 622
    s_start = 0;
  } else {
#line 622
    if (t <= mdef_remainder) {
#line 622
      tmp = t;
    } else {
#line 622
      tmp = mdef_remainder;
    }
#line 622
    s_start = t * mdef_chunk_size + tmp;
  }
#line 624
  if (t < mdef_remainder) {
#line 624
    tmp___0 = 1;
  } else {
#line 624
    tmp___0 = 0;
  }
#line 624
  s_end = (s_start + mdef_chunk_size) + tmp___0;
#line 627
  if (t == 0) {
#line 627
    c_start = 0;
  } else {
#line 627
    if (t <= d2p_remainder) {
#line 627
      tmp___1 = t;
    } else {
#line 627
      tmp___1 = d2p_remainder;
    }
#line 627
    c_start = t * d2p_chunk_size + tmp___1;
  }
#line 629
  if (t < d2p_remainder) {
#line 629
    tmp___2 = 1;
  } else {
#line 629
    tmp___2 = 0;
  }
#line 629
  c_end = (c_start + d2p_chunk_size) + tmp___2;
#line 632
  ss = s_start;
#line 632
  while (ss < s_end) {
#line 633
    if (*(sseq + ss)) {
#line 634
      sp = *(mdef->sseq + ss);
#line 635
      i = 0;
#line 635
      while (i < mdef->n_emit_state) {
#line 636
        *(sen + *(sp + i)) = 1;
#line 635
        i ++;
      }
    }
#line 632
    ss ++;
  }
#line 640
  ss = c_start;
#line 640
  while (ss < c_end) {
#line 641
    if (*(comssid + ss)) {
#line 642
      csp = *(d2p->comsseq + ss);
#line 644
      i = 0;
#line 644
      while (i < mdef->n_emit_state) {
#line 645
        cs = (int32 )*(csp + i);
#line 646
        sp = *(d2p->comstate + cs);
#line 648
        j = 0;
#line 648
        while ((int )*(sp + j) >= 0) {
#line 649
          *(sen + *(sp + j)) = 1;
#line 648
          j ++;
        }
#line 644
        i ++;
      }
    }
#line 640
    ss ++;
  }
#line 653
  return;
}
}
#line 655 "src/threading.c"
void sen_active_thrd_work(thread_args_t *t_args ) 
{ 
  int32 i ;
  int t ;
  int32 chunk_size ;
  int32 remainder___0 ;
  int32 s___0 ;
  int32 e ;
  lextree_t *lextree ;
  kb_t const   *kb___0 ;
  mdef_t const   *mdef ;
  dict2pid_t const   *d2p ;
  int32 *array_ptr ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
#line 658
  t = t_args->id;
#line 662
  kb___0 = (kb_t const   *)(t_args->sa_args)->kb;
#line 663
  mdef = (mdef_t const   *)(t_args->sa_args)->mdef;
#line 664
  d2p = (dict2pid_t const   *)(t_args->sa_args)->d2p;
#line 667
  chunk_size = (int32 )mdef->n_sseq;
#line 668
  remainder___0 = (int32 )0;
#line 670
  if (t == 0) {
#line 670
    s___0 = 0;
  } else {
#line 670
    if (t <= remainder___0) {
#line 670
      tmp = t;
    } else {
#line 670
      tmp = remainder___0;
    }
#line 670
    s___0 = t * chunk_size + tmp;
  }
#line 671
  if (t < remainder___0) {
#line 671
    tmp___0 = 1;
  } else {
#line 671
    tmp___0 = 0;
  }
#line 671
  e = (s___0 + chunk_size) + tmp___0;
#line 672
  array_ptr = (int32 *)kb___0->ssid_active;
#line 700
  i = s___0;
#line 700
  while (i < e) {
#line 701
    *(array_ptr + i) = 0;
#line 700
    i ++;
  }
#line 704
  chunk_size = (int32 )d2p->n_comsseq;
#line 705
  remainder___0 = (int32 )0;
#line 707
  if (t == 0) {
#line 707
    s___0 = 0;
  } else {
#line 707
    if (t <= remainder___0) {
#line 707
      tmp___1 = t;
    } else {
#line 707
      tmp___1 = remainder___0;
    }
#line 707
    s___0 = t * chunk_size + tmp___1;
  }
#line 708
  if (t < remainder___0) {
#line 708
    tmp___2 = 1;
  } else {
#line 708
    tmp___2 = 0;
  }
#line 708
  e = (s___0 + chunk_size) + tmp___2;
#line 709
  array_ptr = (int32 *)kb___0->comssid_active;
#line 737
  i = s___0;
#line 737
  while (i < e) {
#line 738
    *(array_ptr + i) = 0;
#line 737
    i ++;
  }
#line 741
  chunk_size = (int32 )mdef->n_sen;
#line 742
  remainder___0 = (int32 )0;
#line 744
  if (t == 0) {
#line 744
    s___0 = 0;
  } else {
#line 744
    if (t <= remainder___0) {
#line 744
      tmp___3 = t;
    } else {
#line 744
      tmp___3 = remainder___0;
    }
#line 744
    s___0 = t * chunk_size + tmp___3;
  }
#line 745
  if (t < remainder___0) {
#line 745
    tmp___4 = 1;
  } else {
#line 745
    tmp___4 = 0;
  }
#line 745
  e = (s___0 + chunk_size) + tmp___4;
#line 746
  array_ptr = (int32 *)kb___0->sen_active;
#line 774
  i = s___0;
#line 774
  while (i < e) {
#line 775
    *(array_ptr + i) = 0;
#line 774
    i ++;
  }
#line 778
  thread_barrier(t_args->id, score_barrier);
#line 780
  i = 0;
#line 780
  while (i < (int32 )(kb___0->n_lextree << 1)) {
#line 782
    if (i < (int32 )kb___0->n_lextree) {
#line 782
      lextree = *(kb___0->ugtree + i);
    } else {
#line 782
      lextree = *(kb___0->fillertree + (i - (int32 )kb___0->n_lextree));
    }
#line 785
    if (lextree->n_active >= 1) {
#line 786
      chunk_size = lextree->n_active;
#line 787
      remainder___0 = 0;
#line 789
      t_args->lextree = lextree;
#line 790
      if (t == 0) {
#line 790
        t_args->hmmeval_start = 0;
      } else {
#line 790
        if (t <= remainder___0) {
#line 790
          tmp___5 = t;
        } else {
#line 790
          tmp___5 = remainder___0;
        }
#line 790
        t_args->hmmeval_start = t * chunk_size + tmp___5;
      }
#line 792
      if (t < remainder___0) {
#line 792
        tmp___6 = 1;
      } else {
#line 792
        tmp___6 = 0;
      }
#line 792
      t_args->hmmeval_end = (t_args->hmmeval_start + chunk_size) + tmp___6;
#line 795
      lextree_ssid_active_thrd_work(t_args, (int32 *)kb___0->ssid_active, (int32 *)kb___0->comssid_active);
    } else
#line 798
    if (t == 0) {
#line 800
      t_args->lextree = lextree;
#line 801
      t_args->hmmeval_start = 0;
#line 802
      t_args->hmmeval_end = lextree->n_active;
#line 804
      lextree_ssid_active_thrd_work(t_args, (int32 *)kb___0->ssid_active, (int32 *)kb___0->comssid_active);
    }
#line 780
    i ++;
  }
#line 809
  thread_barrier(t_args->id, score_barrier);
#line 810
  sseq2sen_active_thrd_work(t_args);
#line 811
  return;
}
}
#line 813 "src/threading.c"
void *scoring_thrd_work(void *thrd_args ) 
{ 
  thread_args_t *t_args ;

  {
#line 816
  t_args = (thread_args_t *)thrd_args;
#line 818
  sen_active_thrd_work(t_args);
#line 819
  thread_barrier(t_args->id, score_barrier);
#line 820
  thread_barrier(t_args->id, score_barrier);
#line 822
  frame_eval_thrd_work(t_args);
#line 824
  thread_barrier(t_args->id, score_barrier);
#line 827
  dict2pid_comsenscr_thrd_work(t_args);
#line 831
  thread_barrier(t_args->id, score_barrier);
#line 833
  thread_barrier(t_args->id, score_barrier);
#line 836
  new_lextree_hmm_eval_thrd_work((thread_args_t *)thrd_args);
#line 840
  thread_barrier(t_args->id, score_barrier);
#line 843
  thread_barrier(t_args->id, score_barrier);
#line 846
  new_lextree_hmm_ppg_thrd_work((thread_args_t *)thrd_args);
#line 850
  return ((void *)0);
}
}
#line 854 "src/threading.c"
void thrd_sen_active_phase(sen_active_args_t *sa_args ) 
{ 
  int32 t ;

  {
#line 865
  t = 0;
#line 865
  while (t < 1) {
#line 866
    thread_data_array[t].sa_args = sa_args;
#line 867
    thread_data_array[t].id = t;
#line 865
    t ++;
  }
#line 885
  sen_active_thrd_work(& thread_data_array[0]);
#line 887
  thread_barrier(0, score_barrier);
#line 889
  return;
}
}
#line 891 "src/threading.c"
void thrd_scoring_phase(scoring_args_t *score_args ) 
{ 
  int t ;
  int feval_chunk_size ;
  int feval_remainder ;
  int feval_tmp ;
  int com_chunk_size ;
  int com_remainder ;
  int com_tmp ;
  int32 ns ;
  int32 ng ;
  int32 s___0 ;

  {
#line 899
  feval_chunk_size = (score_args->g)->n_mgau;
#line 900
  feval_remainder = 0;
#line 902
  com_chunk_size = (score_args->d2p)->n_comstate;
#line 903
  com_remainder = 0;
#line 905
  wk_idx = 0;
#line 907
  t = 0;
#line 907
  while (t < 1) {
#line 908
    if (t == 0) {
#line 909
      thread_data_array[t].feval_start = 0;
#line 910
      thread_data_array[t].com_start = 0;
    } else {
#line 912
      thread_data_array[t].feval_start = thread_data_array[t - 1].feval_end;
#line 913
      thread_data_array[t].com_start = thread_data_array[t - 1].com_end;
    }
#line 916
    feval_tmp = thread_data_array[t].feval_start + feval_chunk_size;
#line 917
    com_tmp = thread_data_array[t].com_start + com_chunk_size;
#line 919
    if (feval_remainder) {
#line 920
      feval_tmp ++;
#line 921
      feval_remainder --;
    }
#line 924
    if (com_remainder) {
#line 925
      com_tmp ++;
#line 926
      com_remainder --;
    }
#line 929
    thread_data_array[t].feval_end = feval_tmp;
#line 930
    thread_data_array[t].com_end = com_tmp;
#line 931
    thread_data_array[t].score_args = score_args;
#line 933
    thread_data_array[t].id = t;
#line 907
    t ++;
  }
#line 937
  thread_barrier(0, score_barrier);
#line 939
  frame_eval_thrd_work(& thread_data_array[0]);
#line 941
  thread_barrier(0, score_barrier);
#line 944
  ng = 0;
#line 944
  ns = ng;
#line 945
  s___0 = 0;
#line 945
  while (s___0 < 1) {
#line 946
    ns += ns_array[s___0];
#line 947
    ng += ng_array[s___0];
#line 945
    s___0 ++;
  }
#line 950
  (score_args->g)->frm_sen_eval = ns;
#line 951
  (score_args->g)->frm_gau_eval = ng;
#line 953
  dict2pid_comsenscr_thrd_work(& thread_data_array[0]);
#line 958
  thread_barrier(0, score_barrier);
#line 961
  return;
}
}
#line 963 "src/threading.c"
void new_lextree_hmm_eval_thrd_work(thread_args_t *thrd_args ) 
{ 
  int32 i ;
  int t ;
  int chunk_size ;
  int remainder___0 ;
  kb_t const   *kb___0 ;
  lextree_t *lextree ;
  int tmp ;
  int tmp___0 ;

  {
#line 966
  t = thrd_args->id;
#line 968
  kb___0 = (kb_t const   *)(thrd_args->search_args)->kb;
#line 971
  i = 0;
#line 971
  while (i < (int32 )(kb___0->n_lextree << 1)) {
#line 973
    if (i < (int32 )kb___0->n_lextree) {
#line 973
      lextree = *(kb___0->ugtree + i);
    } else {
#line 973
      lextree = *(kb___0->fillertree + (i - (int32 )kb___0->n_lextree));
    }
#line 976
    if (lextree->n_active >= 1) {
#line 977
      chunk_size = lextree->n_active;
#line 978
      remainder___0 = 0;
#line 980
      thrd_args->lextree = lextree;
#line 981
      if (t == 0) {
#line 981
        thrd_args->hmmeval_start = 0;
      } else {
#line 981
        if (t <= remainder___0) {
#line 981
          tmp = t;
        } else {
#line 981
          tmp = remainder___0;
        }
#line 981
        thrd_args->hmmeval_start = t * chunk_size + tmp;
      }
#line 983
      if (t < remainder___0) {
#line 983
        tmp___0 = 1;
      } else {
#line 983
        tmp___0 = 0;
      }
#line 983
      thrd_args->hmmeval_end = (thrd_args->hmmeval_start + chunk_size) + tmp___0;
#line 989
      lextree_hmm_eval_thrd_work(thrd_args);
#line 991
      *(he_best_array[t] + i) = thrd_args->best;
#line 992
      *(he_wbest_array[t] + i) = thrd_args->wbest;
    } else
#line 993
    if (t == 0) {
#line 994
      thrd_args->lextree = lextree;
#line 995
      thrd_args->hmmeval_start = 0;
#line 996
      thrd_args->hmmeval_end = lextree->n_active;
#line 998
      lextree_hmm_eval_thrd_work(thrd_args);
#line 1000
      *(he_best_array[t] + i) = thrd_args->best;
#line 1001
      *(he_wbest_array[t] + i) = thrd_args->wbest;
    }
#line 971
    i ++;
  }
#line 1005
  return;
}
}
#line 1007 "src/threading.c"
void new_thrd_lextree_hmm_eval(searching_args_t *search_args , int32 *besthmmscr ,
                               int32 *bestwordscr , int32 *n_hmm_eval , int32 *frm_nhmm ) 
{ 
  int32 t ;
  int32 i ;
  int32 best ;
  int32 wbest ;
  kb_t *kb___0 ;
  lextree_t *lextree ;

  {
#line 1012
  kb___0 = search_args->kb;
#line 1015
  t = 0;
#line 1015
  while (t < 1) {
#line 1016
    thread_data_array[t].search_args = search_args;
#line 1015
    t ++;
  }
#line 1018
  thread_barrier(0, score_barrier);
#line 1021
  new_lextree_hmm_eval_thrd_work(& thread_data_array[0]);
#line 1024
  thread_barrier(0, score_barrier);
#line 1029
  best = (int32 )2147483648U;
#line 1030
  wbest = (int32 )2147483648U;
#line 1032
  i = 0;
#line 1032
  while (i < kb___0->n_lextree << 1) {
#line 1033
    if (i < kb___0->n_lextree) {
#line 1033
      lextree = *(kb___0->ugtree + i);
    } else {
#line 1033
      lextree = *(kb___0->fillertree + (i - kb___0->n_lextree));
    }
#line 1036
    if (lextree->n_active) {
#line 1037
      best = *(he_best_array[0] + i);
#line 1038
      wbest = *(he_wbest_array[0] + i);
    }
#line 1041
    if (lextree->n_active >= 1) {
#line 1042
      t = 0;
#line 1042
      while (t < 0) {
#line 1043
        if (best < *(he_best_array[t] + i)) {
#line 1044
          best = *(he_best_array[t] + i);
        }
#line 1045
        if (wbest < *(he_wbest_array[t] + i)) {
#line 1046
          wbest = *(he_wbest_array[t] + i);
        }
#line 1042
        t ++;
      }
    }
#line 1050
    lextree->best = best;
#line 1051
    lextree->wbest = wbest;
#line 1053
    if (*besthmmscr < best) {
#line 1054
      *besthmmscr = best;
    }
#line 1055
    if (*bestwordscr < wbest) {
#line 1056
      *bestwordscr = wbest;
    }
#line 1058
    *n_hmm_eval += lextree->n_active;
#line 1059
    *frm_nhmm += lextree->n_active;
#line 1032
    i ++;
  }
#line 1062
  return;
}
}
#line 1064 "src/threading.c"
void new_lextree_hmm_ppg_thrd_work(thread_args_t *thrd_args ) 
{ 
  int32 i ;
  int t ;
  int chunk_size ;
  int remainder___0 ;
  kb_t *kb___0 ;
  lextree_t *lextree ;
  int tmp ;
  int tmp___0 ;

  {
#line 1067
  t = thrd_args->id;
#line 1069
  kb___0 = (thrd_args->search_args)->kb;
#line 1072
  i = 0;
#line 1072
  while (i < kb___0->n_lextree << 1) {
#line 1073
    if (i < kb___0->n_lextree) {
#line 1073
      lextree = *(kb___0->ugtree + i);
    } else {
#line 1073
      lextree = *(kb___0->fillertree + (i - kb___0->n_lextree));
    }
#line 1076
    if (lextree->n_active >= 1) {
#line 1077
      chunk_size = lextree->n_active;
#line 1078
      remainder___0 = 0;
#line 1080
      thrd_args->lextree = lextree;
#line 1081
      if (t == 0) {
#line 1081
        thrd_args->hmmppg_start = 0;
      } else {
#line 1081
        if (t <= remainder___0) {
#line 1081
          tmp = t;
        } else {
#line 1081
          tmp = remainder___0;
        }
#line 1081
        thrd_args->hmmppg_start = t * chunk_size + tmp;
      }
#line 1083
      if (t < remainder___0) {
#line 1083
        tmp___0 = 1;
      } else {
#line 1083
        tmp___0 = 0;
      }
#line 1083
      thrd_args->hmmppg_end = (thrd_args->hmmppg_start + chunk_size) + tmp___0;
#line 1085
      thrd_args->lextree_num = i;
#line 1087
      lextree_hmm_ppg_thrd_work(thrd_args);
    } else
#line 1089
    if (t == 0) {
#line 1090
      thrd_args->lextree = lextree;
#line 1091
      thrd_args->hmmppg_start = 0;
#line 1092
      thrd_args->hmmppg_end = lextree->n_active;
#line 1093
      thrd_args->lextree_num = i;
#line 1095
      lextree_hmm_ppg_thrd_work(thrd_args);
    }
#line 1072
    i ++;
  }
#line 1100
  return;
}
}
#line 1102 "src/threading.c"
void new_thrd_lextree_hmm_propagate(searching_args_t *search_args ) 
{ 
  int32 t ;
  int32 i ;
  kb_t *kb___0 ;
  lextree_t *lextree ;
  int32 sum___0 ;

  {
#line 1105
  kb___0 = search_args->kb;
#line 1109
  t = 0;
#line 1109
  while (t < 1) {
#line 1110
    thread_data_array[t].search_args = search_args;
#line 1109
    t ++;
  }
#line 1112
  thread_barrier(0, score_barrier);
#line 1115
  new_lextree_hmm_ppg_thrd_work(& thread_data_array[0]);
#line 1121
  i = 0;
#line 1121
  while (i < kb___0->n_lextree << 1) {
#line 1122
    if (i < kb___0->n_lextree) {
#line 1122
      lextree = *(kb___0->ugtree + i);
    } else {
#line 1122
      lextree = *(kb___0->fillertree + (i - kb___0->n_lextree));
    }
#line 1125
    sum___0 = 0;
#line 1127
    if (lextree->n_active >= 1) {
#line 1129
      t = 0;
#line 1129
      while (t < 1) {
#line 1130
        if (*(private_n[t] + i)) {
#line 1131
          memcpy((void * __restrict  )(lextree->next_active + sum___0), (void const   * __restrict  )*(next_active_array[t] + i),
                 (unsigned long )*(private_n[t] + i) * sizeof(lextree_node_t *));
#line 1133
          sum___0 += *(private_n[t] + i);
        }
#line 1129
        t ++;
      }
#line 1137
      lextree->n_next_active = sum___0;
    } else
#line 1138
    if (*(private_n[0] + i)) {
#line 1140
      memcpy((void * __restrict  )lextree->next_active, (void const   * __restrict  )*(next_active_array[0] + i),
             (unsigned long )*(private_n[0] + i) * sizeof(lextree_node_t *));
#line 1143
      lextree->n_next_active = *(private_n[0] + i);
    } else {
#line 1145
      lextree->n_next_active = 0;
    }
#line 1121
    i ++;
  }
#line 1149
  return;
}
}
#line 1 "mdef.o"
#pragma merger("0","/tmp/cil-kVU4wfdV.i","-g,-O4")
#line 143 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strncmp)(char const   *__s1 ,
                                                                                                char const   *__s2 ,
                                                                                                size_t __n )  __attribute__((__pure__)) ;
#line 150 "/usr/include/x86_64-linux-gnu/bits/mathinline.h"
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__, __always_inline__)) __signbitl)(long double __x )  __attribute__((__const__)) ;
#line 150 "/usr/include/x86_64-linux-gnu/bits/mathinline.h"
__inline extern int ( __attribute__((__leaf__, __always_inline__)) __signbitl)(long double __x ) 
{ 
  union __anonunion___u_29___5 __u ;

  {
#line 153
  __u.__l = __x;
#line 154
  return ((__u.__i[2] & 32768) != 0);
}
}
#line 222 "src/mdef.h"
mdef_t *mdef_init(char *mdeffile ) ;
#line 226
s3cipid_t mdef_ciphone_id(mdef_t *m , char *ci ) ;
#line 230
char const   *mdef_ciphone_str(mdef_t *m , s3cipid_t id ) ;
#line 234
int32 mdef_is_ciphone(mdef_t *m , s3pid_t p ) ;
#line 238
s3pid_t mdef_phone_id(mdef_t *m , s3cipid_t ci , s3cipid_t lc , s3cipid_t rc , word_posn_t wpos ) ;
#line 249
s3pid_t mdef_phone_id_nearest(mdef_t *m , s3cipid_t b , s3cipid_t l , s3cipid_t r ,
                              word_posn_t pos ) ;
#line 259
int32 mdef_phone_str(mdef_t *m , s3pid_t pid , char *buf ) ;
#line 267
int32 mdef_phone_components(mdef_t *m , s3pid_t p , s3cipid_t *b , s3cipid_t *l ,
                            s3cipid_t *r , word_posn_t *pos ) ;
#line 286
void mdef_sseq2sen_active(mdef_t *mdef , int32 *sseq , int32 *sen ) ;
#line 293
void mdef_dump(FILE *fp , mdef_t *m ) ;
#line 296
void mdef_free_recursive_lc(ph_lc_t *lc ) ;
#line 297
void mdef_free_recursive_rc(ph_rc_t *rc ) ;
#line 298
void mdef_free(mdef_t *m ) ;
#line 138 "src/mdef.c"
void mdef_dump(FILE *fp , mdef_t *m ) 
{ 
  int32 i ;
  int32 j ;
  int32 ssid ;
  char buf[1024] ;

  {
#line 144
  fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"%d ciphone\n", m->n_ciphone);
#line 145
  fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"%d phone\n", m->n_phone);
#line 146
  fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"%d emitstate\n",
          m->n_emit_state);
#line 147
  fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"%d cisen\n", m->n_ci_sen);
#line 148
  fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"%d sen\n", m->n_sen);
#line 149
  fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"%d tmat\n", m->n_tmat);
#line 151
  i = 0;
#line 151
  while (i < m->n_phone) {
#line 152
    mdef_phone_str(m, i, buf);
#line 153
    ssid = (m->phone + i)->ssid;
#line 155
    fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"%3d %5d", (m->phone + i)->tmat,
            ssid);
#line 156
    j = 0;
#line 156
    while (j < m->n_emit_state) {
#line 157
      fprintf((FILE * __restrict  )fp, (char const   * __restrict  )" %5d", (int )*(*(m->sseq + ssid) + j));
#line 156
      j ++;
    }
#line 158
    fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"\t");
#line 159
    j = 0;
#line 159
    while (j < m->n_emit_state) {
#line 160
      fprintf((FILE * __restrict  )fp, (char const   * __restrict  )" %3d", (int )*(m->cd2cisen + *(*(m->sseq + ssid) + j)));
#line 159
      j ++;
    }
#line 161
    fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"\t%s\n", buf);
#line 151
    i ++;
  }
#line 164
  fflush(fp);
#line 165
  return;
}
}
#line 185 "src/mdef.c"
static void ciphone_add(mdef_t *m , char *ci , s3pid_t p ) 
{ 
  char *tmp ;
  int32 tmp___0 ;

  {
#line 187
  if (! (p < m->n_ciphone)) {
#line 187
    __assert_fail("p < m->n_ciphone", "src/mdef.c", 187U, "ciphone_add");
  }
#line 189
  tmp = __ckd_salloc__((char const   *)ci, "src/mdef.c", 189);
#line 189
  (m->ciphone + p)->name = tmp;
#line 190
  tmp___0 = hash_enter(m->ciphone_ht, (char const   *)(m->ciphone + p)->name, p);
#line 190
  if (tmp___0 != p) {
#line 191
    _E__pr_header("src/mdef.c", 191L, "FATAL_ERROR");
#line 191
    _E__die_error("hash_enter(%s) failed; duplicate CIphone?\n", (m->ciphone + p)->name);
  }
#line 192
  return;
}
}
#line 195 "src/mdef.c"
static ph_lc_t *find_ph_lc(ph_lc_t *lclist , s3cipid_t lc ) 
{ 
  ph_lc_t *lcptr ;

  {
#line 199
  lcptr = lclist;
#line 199
  while (1) {
#line 199
    if (lcptr) {
#line 199
      if (! ((int )lcptr->lc != (int )lc)) {
#line 199
        break;
      }
    } else {
#line 199
      break;
    }
#line 199
    lcptr = lcptr->next;
  }
#line 200
  return (lcptr);
}
}
#line 204 "src/mdef.c"
static ph_rc_t *find_ph_rc(ph_rc_t *rclist , s3cipid_t rc ) 
{ 
  ph_rc_t *rcptr ;

  {
#line 208
  rcptr = rclist;
#line 208
  while (1) {
#line 208
    if (rcptr) {
#line 208
      if (! ((int )rcptr->rc != (int )rc)) {
#line 208
        break;
      }
    } else {
#line 208
      break;
    }
#line 208
    rcptr = rcptr->next;
  }
#line 209
  return (rcptr);
}
}
#line 213 "src/mdef.c"
static void triphone_add(mdef_t *m , s3cipid_t ci , s3cipid_t lc , s3cipid_t rc ,
                         word_posn_t wpos , s3pid_t p ) 
{ 
  ph_lc_t *lcptr ;
  ph_rc_t *rcptr ;
  void *tmp ;
  char buf[4096] ;
  void *tmp___0 ;

  {
#line 220
  if (! (p < m->n_phone)) {
#line 220
    __assert_fail("p < m->n_phone", "src/mdef.c", 220U, "triphone_add");
  }
#line 223
  (m->phone + p)->ci = ci;
#line 224
  (m->phone + p)->lc = lc;
#line 225
  (m->phone + p)->rc = rc;
#line 226
  (m->phone + p)->wpos = wpos;
#line 229
  if (p >= m->n_ciphone) {
#line 230
    lcptr = find_ph_lc(*(*(m->wpos_ci_lclist + wpos) + (int )ci), lc);
#line 230
    if ((unsigned long )lcptr == (unsigned long )((void *)0)) {
#line 233
      tmp = __ckd_calloc__((size_t )1, sizeof(ph_lc_t ), "src/mdef.c", 233);
#line 233
      lcptr = (ph_lc_t *)tmp;
#line 234
      lcptr->lc = lc;
#line 235
      lcptr->next = *(*(m->wpos_ci_lclist + wpos) + (int )ci);
#line 236
      *(*(m->wpos_ci_lclist + wpos) + (int )ci) = lcptr;
    }
#line 238
    rcptr = find_ph_rc(lcptr->rclist, rc);
#line 238
    if ((unsigned long )rcptr != (unsigned long )((void *)0)) {
#line 241
      mdef_phone_str(m, rcptr->pid, buf);
#line 242
      _E__pr_header("src/mdef.c", 242L, "FATAL_ERROR");
#line 242
      _E__die_error("Duplicate triphone: %s\n", buf);
    }
#line 245
    tmp___0 = __ckd_calloc__((size_t )1, sizeof(ph_rc_t ), "src/mdef.c", 245);
#line 245
    rcptr = (ph_rc_t *)tmp___0;
#line 246
    rcptr->rc = rc;
#line 247
    rcptr->pid = p;
#line 248
    rcptr->next = lcptr->rclist;
#line 249
    lcptr->rclist = rcptr;
  }
#line 251
  return;
}
}
#line 254 "src/mdef.c"
s3cipid_t mdef_ciphone_id(mdef_t *m , char *ci ) 
{ 
  int32 id ;
  int32 tmp ;

  {
#line 258
  if (! m) {
#line 258
    __assert_fail("m", "src/mdef.c", 258U, "mdef_ciphone_id");
  }
#line 259
  if (! ci) {
#line 259
    __assert_fail("ci", "src/mdef.c", 259U, "mdef_ciphone_id");
  }
#line 261
  tmp = hash_lookup(m->ciphone_ht, (char const   *)ci, & id);
#line 261
  if (tmp < 0) {
#line 262
    return ((s3cipid_t )-1);
  }
#line 263
  return ((s3cipid_t )id);
}
}
#line 267 "src/mdef.c"
char const   *mdef_ciphone_str(mdef_t *m , s3cipid_t id ) 
{ 


  {
#line 269
  if (! m) {
#line 269
    __assert_fail("m", "src/mdef.c", 269U, "mdef_ciphone_str");
  }
#line 270
  if ((int )id >= 0) {
#line 270
    if (! ((int )id < m->n_ciphone)) {
#line 270
      __assert_fail("(id >= 0) && (id < m->n_ciphone)", "src/mdef.c", 270U, "mdef_ciphone_str");
    }
  } else {
#line 270
    __assert_fail("(id >= 0) && (id < m->n_ciphone)", "src/mdef.c", 270U, "mdef_ciphone_str");
  }
#line 272
  return ((char const   *)(m->ciphone + (int )id)->name);
}
}
#line 276 "src/mdef.c"
int32 mdef_phone_str(mdef_t *m , s3pid_t pid , char *buf ) 
{ 
  char *wpos_name ;
  char const   *tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;

  {
#line 280
  if (! m) {
#line 280
    __assert_fail("m", "src/mdef.c", 280U, "mdef_phone_str");
  }
#line 281
  if (pid >= 0) {
#line 281
    if (! (pid < m->n_phone)) {
#line 281
      __assert_fail("(pid >= 0) && (pid < m->n_phone)", "src/mdef.c", 281U, "mdef_phone_str");
    }
  } else {
#line 281
    __assert_fail("(pid >= 0) && (pid < m->n_phone)", "src/mdef.c", 281U, "mdef_phone_str");
  }
#line 282
  wpos_name = (char *)"besiu";
#line 284
  *(buf + 0) = (char )'\000';
#line 285
  if (pid < m->n_ciphone) {
#line 286
    tmp = mdef_ciphone_str(m, (s3cipid_t )pid);
#line 286
    sprintf((char * __restrict  )buf, (char const   * __restrict  )"%s", tmp);
  } else {
#line 288
    tmp___0 = mdef_ciphone_str(m, (m->phone + pid)->rc);
#line 288
    tmp___1 = mdef_ciphone_str(m, (m->phone + pid)->lc);
#line 288
    tmp___2 = mdef_ciphone_str(m, (m->phone + pid)->ci);
#line 288
    sprintf((char * __restrict  )buf, (char const   * __restrict  )"(%s,%s,%s,%c)",
            tmp___2, tmp___1, tmp___0, (int )*(wpos_name + (m->phone + pid)->wpos));
  }
#line 294
  return (0);
}
}
#line 298 "src/mdef.c"
s3pid_t mdef_phone_id(mdef_t *m , s3cipid_t ci , s3cipid_t lc , s3cipid_t rc , word_posn_t wpos ) 
{ 
  ph_lc_t *lcptr ;
  ph_rc_t *rcptr ;
  s3cipid_t newl ;
  s3cipid_t newr ;
  s3pid_t tmp ;

  {
#line 305
  if (! m) {
#line 305
    __assert_fail("m", "src/mdef.c", 305U, "mdef_phone_id");
  }
#line 306
  if ((int )ci >= 0) {
#line 306
    if (! ((int )ci < m->n_ciphone)) {
#line 306
      __assert_fail("(ci >= 0) && (ci < m->n_ciphone)", "src/mdef.c", 306U, "mdef_phone_id");
    }
  } else {
#line 306
    __assert_fail("(ci >= 0) && (ci < m->n_ciphone)", "src/mdef.c", 306U, "mdef_phone_id");
  }
#line 307
  if ((int )lc >= 0) {
#line 307
    if (! ((int )lc < m->n_ciphone)) {
#line 307
      __assert_fail("(lc >= 0) && (lc < m->n_ciphone)", "src/mdef.c", 307U, "mdef_phone_id");
    }
  } else {
#line 307
    __assert_fail("(lc >= 0) && (lc < m->n_ciphone)", "src/mdef.c", 307U, "mdef_phone_id");
  }
#line 308
  if ((int )rc >= 0) {
#line 308
    if (! ((int )rc < m->n_ciphone)) {
#line 308
      __assert_fail("(rc >= 0) && (rc < m->n_ciphone)", "src/mdef.c", 308U, "mdef_phone_id");
    }
  } else {
#line 308
    __assert_fail("(rc >= 0) && (rc < m->n_ciphone)", "src/mdef.c", 308U, "mdef_phone_id");
  }
#line 309
  if ((unsigned int )wpos >= 0U) {
#line 309
    if (! ((unsigned int )wpos < 4U)) {
#line 309
      __assert_fail("(wpos >= 0) && (wpos < 4)", "src/mdef.c", 309U, "mdef_phone_id");
    }
  } else {
#line 309
    __assert_fail("(wpos >= 0) && (wpos < 4)", "src/mdef.c", 309U, "mdef_phone_id");
  }
#line 311
  lcptr = find_ph_lc(*(*(m->wpos_ci_lclist + wpos) + (int )ci), lc);
#line 311
  if ((unsigned long )lcptr == (unsigned long )((void *)0)) {
#line 311
    goto _L;
  } else {
#line 311
    rcptr = find_ph_rc(lcptr->rclist, rc);
#line 311
    if ((unsigned long )rcptr == (unsigned long )((void *)0)) {
      _L: /* CIL Label */ 
#line 314
      if ((int )m->sil < 0) {
#line 315
        return (-1);
      }
#line 317
      if ((m->ciphone + (int )lc)->filler) {
#line 317
        newl = m->sil;
      } else {
#line 317
        newl = lc;
      }
#line 318
      if ((m->ciphone + (int )rc)->filler) {
#line 318
        newr = m->sil;
      } else {
#line 318
        newr = rc;
      }
#line 319
      if ((int )newl == (int )lc) {
#line 319
        if ((int )newr == (int )rc) {
#line 320
          return (-1);
        }
      }
#line 322
      tmp = mdef_phone_id(m, ci, newl, newr, wpos);
#line 322
      return (tmp);
    }
  }
#line 325
  return (rcptr->pid);
}
}
#line 329 "src/mdef.c"
s3pid_t mdef_phone_id_nearest(mdef_t *m , s3cipid_t b , s3cipid_t l , s3cipid_t r ,
                              word_posn_t pos ) 
{ 
  word_posn_t tmppos ;
  s3pid_t p ;
  s3cipid_t newl ;
  s3cipid_t newr ;
  char *wpos_name ;

  {
#line 337
  if (! m) {
#line 337
    __assert_fail("m", "src/mdef.c", 337U, "mdef_phone_id_nearest");
  }
#line 338
  if ((int )b >= 0) {
#line 338
    if (! ((int )b < m->n_ciphone)) {
#line 338
      __assert_fail("(b >= 0) && (b < m->n_ciphone)", "src/mdef.c", 338U, "mdef_phone_id_nearest");
    }
  } else {
#line 338
    __assert_fail("(b >= 0) && (b < m->n_ciphone)", "src/mdef.c", 338U, "mdef_phone_id_nearest");
  }
#line 339
  if ((unsigned int )pos >= 0U) {
#line 339
    if (! ((unsigned int )pos < 4U)) {
#line 339
      __assert_fail("(pos >= 0) && (pos < 4)", "src/mdef.c", 339U, "mdef_phone_id_nearest");
    }
  } else {
#line 339
    __assert_fail("(pos >= 0) && (pos < 4)", "src/mdef.c", 339U, "mdef_phone_id_nearest");
  }
#line 341
  if ((int )l < 0) {
#line 342
    return ((s3pid_t )b);
  } else
#line 341
  if ((int )r < 0) {
#line 342
    return ((s3pid_t )b);
  }
#line 344
  if ((int )l >= 0) {
#line 344
    if (! ((int )l < m->n_ciphone)) {
#line 344
      __assert_fail("(l >= 0) && (l < m->n_ciphone)", "src/mdef.c", 344U, "mdef_phone_id_nearest");
    }
  } else {
#line 344
    __assert_fail("(l >= 0) && (l < m->n_ciphone)", "src/mdef.c", 344U, "mdef_phone_id_nearest");
  }
#line 345
  if ((int )r >= 0) {
#line 345
    if (! ((int )r < m->n_ciphone)) {
#line 345
      __assert_fail("(r >= 0) && (r < m->n_ciphone)", "src/mdef.c", 345U, "mdef_phone_id_nearest");
    }
  } else {
#line 345
    __assert_fail("(r >= 0) && (r < m->n_ciphone)", "src/mdef.c", 345U, "mdef_phone_id_nearest");
  }
#line 347
  p = mdef_phone_id(m, b, l, r, pos);
#line 348
  if (p >= 0) {
#line 349
    return (p);
  }
#line 352
  tmppos = (word_posn_t )0;
#line 352
  while ((unsigned int )tmppos < 4U) {
#line 353
    if ((unsigned int )tmppos != (unsigned int )pos) {
#line 354
      p = mdef_phone_id(m, b, l, r, tmppos);
#line 355
      if (p >= 0) {
#line 356
        return (p);
      }
    }
#line 352
    tmppos = (word_posn_t )((unsigned int )tmppos + 1U);
  }
#line 361
  if ((int )m->sil >= 0) {
#line 362
    if ((m->ciphone + (int )l)->filler) {
#line 362
      newl = m->sil;
    } else {
#line 362
      newl = l;
    }
#line 363
    if ((m->ciphone + (int )r)->filler) {
#line 363
      newr = m->sil;
    } else {
#line 363
      newr = r;
    }
#line 364
    if ((int )newl != (int )l) {
#line 364
      goto _L;
    } else
#line 364
    if ((int )newr != (int )r) {
      _L: /* CIL Label */ 
#line 365
      p = mdef_phone_id(m, b, newl, newr, pos);
#line 366
      if (p >= 0) {
#line 367
        return (p);
      }
#line 369
      tmppos = (word_posn_t )0;
#line 369
      while ((unsigned int )tmppos < 4U) {
#line 370
        if ((unsigned int )tmppos != (unsigned int )pos) {
#line 371
          p = mdef_phone_id(m, b, newl, newr, tmppos);
#line 372
          if (p >= 0) {
#line 373
            return (p);
          }
        }
#line 369
        tmppos = (word_posn_t )((unsigned int )tmppos + 1U);
      }
    }
  }
#line 380
  if (m->n_phone > m->n_ciphone) {
#line 380
    if (! (m->ciphone + (int )b)->filler) {
#line 381
      wpos_name = (char *)"besiu";
    }
  }
#line 390
  return ((s3pid_t )b);
}
}
#line 394 "src/mdef.c"
int32 mdef_phone_components(mdef_t *m , s3pid_t p , s3cipid_t *b , s3cipid_t *l ,
                            s3cipid_t *r , word_posn_t *pos ) 
{ 


  {
#line 401
  if (! m) {
#line 401
    __assert_fail("m", "src/mdef.c", 401U, "mdef_phone_components");
  }
#line 402
  if (p >= 0) {
#line 402
    if (! (p < m->n_phone)) {
#line 402
      __assert_fail("(p >= 0) && (p < m->n_phone)", "src/mdef.c", 402U, "mdef_phone_components");
    }
  } else {
#line 402
    __assert_fail("(p >= 0) && (p < m->n_phone)", "src/mdef.c", 402U, "mdef_phone_components");
  }
#line 404
  *b = (m->phone + p)->ci;
#line 405
  *l = (m->phone + p)->lc;
#line 406
  *r = (m->phone + p)->rc;
#line 407
  *pos = (m->phone + p)->wpos;
#line 409
  return (0);
}
}
#line 413 "src/mdef.c"
int32 mdef_is_ciphone(mdef_t *m , s3pid_t p ) 
{ 
  int tmp ;

  {
#line 415
  if (! m) {
#line 415
    __assert_fail("m", "src/mdef.c", 415U, "mdef_is_ciphone");
  }
#line 416
  if (p >= 0) {
#line 416
    if (! (p < m->n_phone)) {
#line 416
      __assert_fail("(p >= 0) && (p < m->n_phone)", "src/mdef.c", 416U, "mdef_is_ciphone");
    }
  } else {
#line 416
    __assert_fail("(p >= 0) && (p < m->n_phone)", "src/mdef.c", 416U, "mdef_is_ciphone");
  }
#line 418
  if (p < m->n_ciphone) {
#line 418
    tmp = 1;
  } else {
#line 418
    tmp = 0;
  }
#line 418
  return (tmp);
}
}
#line 423 "src/mdef.c"
static void parse_tmat_senmap(mdef_t *m , char *line , int32 off , s3pid_t p ) 
{ 
  int32 wlen ;
  int32 n ;
  int32 s___0 ;
  char word[1024] ;
  char *lp ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___3 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;

  {
#line 428
  lp = line + off;
#line 431
  tmp = sscanf((char const   * __restrict  )lp, (char const   * __restrict  )"%d%n",
               & n, & wlen);
#line 431
  if (tmp != 1) {
#line 432
    _E__pr_header("src/mdef.c", 432L, "FATAL_ERROR");
#line 432
    _E__die_error("Missing or bad transition matrix id: %s\n", line);
  } else
#line 431
  if (n < 0) {
#line 432
    _E__pr_header("src/mdef.c", 432L, "FATAL_ERROR");
#line 432
    _E__die_error("Missing or bad transition matrix id: %s\n", line);
  }
#line 433
  (m->phone + p)->tmat = n;
#line 434
  if (m->n_tmat <= n) {
#line 435
    _E__pr_header("src/mdef.c", 435L, "FATAL_ERROR");
#line 435
    _E__die_error("tmat-id(%d) > #tmat in header(%d): %s\n", n, m->n_tmat, line);
  }
#line 436
  lp += wlen;
#line 439
  n = 0;
#line 439
  while (n < m->n_emit_state) {
#line 440
    tmp___0 = sscanf((char const   * __restrict  )lp, (char const   * __restrict  )"%d%n",
                     & s___0, & wlen);
#line 440
    if (tmp___0 != 1) {
#line 441
      _E__pr_header("src/mdef.c", 441L, "FATAL_ERROR");
#line 441
      _E__die_error("Missing or bad state[%d]->senone mapping: %s\n", n, line);
    } else
#line 440
    if (s___0 < 0) {
#line 441
      _E__pr_header("src/mdef.c", 441L, "FATAL_ERROR");
#line 441
      _E__die_error("Missing or bad state[%d]->senone mapping: %s\n", n, line);
    }
#line 442
    if (p < m->n_ciphone) {
#line 442
      if (m->n_ci_sen <= s___0) {
#line 443
        _E__pr_header("src/mdef.c", 443L, "FATAL_ERROR");
#line 443
        _E__die_error("CI-senone-id(%d) > #CI-senones(%d): %s\n", s___0, m->n_ci_sen,
                      line);
      }
    }
#line 444
    if (m->n_sen <= s___0) {
#line 445
      _E__pr_header("src/mdef.c", 445L, "FATAL_ERROR");
#line 445
      _E__die_error("Senone-id(%d) > #senones(%d): %s\n", s___0, m->n_sen, line);
    }
#line 447
    *(*(m->sseq + p) + n) = (s3senid_t )s___0;
#line 448
    lp += wlen;
#line 439
    n ++;
  }
#line 452
  tmp___1 = sscanf((char const   * __restrict  )lp, (char const   * __restrict  )"%s%n",
                   word, & wlen);
#line 452
  if (tmp___1 != 1) {
#line 453
    _E__pr_header("src/mdef.c", 453L, "FATAL_ERROR");
#line 453
    _E__die_error("Missing non-emitting state spec: %s\n", line);
  } else {
#line 452
    if (0) {
#line 452
      __s1_len = __builtin_strlen((char const   *)(word));
#line 452
      __s2_len = __builtin_strlen("N");
#line 452
      if (! ((size_t )((void const   *)(word + 1)) - (size_t )((void const   *)(word)) == 1UL)) {
#line 452
        goto _L___0;
      } else
#line 452
      if (__s1_len >= 4UL) {
        _L___0: /* CIL Label */ 
#line 452
        if (! ((size_t )((void const   *)("N" + 1)) - (size_t )((void const   *)"N") == 1UL)) {
#line 452
          tmp___8 = 1;
        } else
#line 452
        if (__s2_len >= 4UL) {
#line 452
          tmp___8 = 1;
        } else {
#line 452
          tmp___8 = 0;
        }
      } else {
#line 452
        tmp___8 = 0;
      }
#line 452
      if (tmp___8) {
#line 452
        tmp___3 = __builtin_strcmp((char const   *)(word), "N");
#line 452
        tmp___7 = tmp___3;
      } else {
#line 452
        tmp___6 = __builtin_strcmp((char const   *)(word), "N");
#line 452
        tmp___7 = tmp___6;
      }
    } else {
#line 452
      tmp___6 = __builtin_strcmp((char const   *)(word), "N");
#line 452
      tmp___7 = tmp___6;
    }
#line 452
    if (tmp___7 != 0) {
#line 453
      _E__pr_header("src/mdef.c", 453L, "FATAL_ERROR");
#line 453
      _E__die_error("Missing non-emitting state spec: %s\n", line);
    }
  }
#line 454
  lp += wlen;
#line 457
  tmp___9 = sscanf((char const   * __restrict  )lp, (char const   * __restrict  )"%s%n",
                   word, & wlen);
#line 457
  if (tmp___9 == 1) {
#line 458
    _E__pr_header("src/mdef.c", 458L, "FATAL_ERROR");
#line 458
    _E__die_error("Non-empty beyond non-emitting final state: %s\n", line);
  }
#line 459
  return;
}
}
#line 462 "src/mdef.c"
static void parse_base_line(mdef_t *m , char *line , s3pid_t p ) 
{ 
  int32 wlen ;
  int32 n ;
  char word[1024] ;
  char *lp ;
  s3cipid_t ci ;
  int tmp ;
  int tmp___0 ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___2 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___10 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  size_t __s1_len___1 ;
  size_t __s2_len___1 ;
  int tmp___17 ;
  int tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;

  {
#line 468
  lp = line;
#line 471
  tmp = sscanf((char const   * __restrict  )lp, (char const   * __restrict  )"%s%n",
               word, & wlen);
#line 471
  if (tmp != 1) {
#line 472
    _E__pr_header("src/mdef.c", 472L, "FATAL_ERROR");
#line 472
    _E__die_error("Missing base phone name: %s\n", line);
  }
#line 473
  lp += wlen;
#line 476
  ci = mdef_ciphone_id(m, word);
#line 477
  if ((int )ci >= 0) {
#line 478
    _E__pr_header("src/mdef.c", 478L, "FATAL_ERROR");
#line 478
    _E__die_error("Duplicate base phone: %s\n", line);
  }
#line 481
  ciphone_add(m, word, p);
#line 482
  ci = (s3cipid_t )p;
#line 485
  n = 0;
#line 485
  while (n < 3) {
#line 486
    tmp___0 = sscanf((char const   * __restrict  )lp, (char const   * __restrict  )"%s%n",
                     word, & wlen);
#line 486
    if (tmp___0 != 1) {
#line 487
      _E__pr_header("src/mdef.c", 487L, "FATAL_ERROR");
#line 487
      _E__die_error("Bad context info for base phone: %s\n", line);
    } else {
#line 486
      if (0) {
#line 486
        __s1_len = __builtin_strlen((char const   *)(word));
#line 486
        __s2_len = __builtin_strlen("-");
#line 486
        if (! ((size_t )((void const   *)(word + 1)) - (size_t )((void const   *)(word)) == 1UL)) {
#line 486
          goto _L___0;
        } else
#line 486
        if (__s1_len >= 4UL) {
          _L___0: /* CIL Label */ 
#line 486
          if (! ((size_t )((void const   *)("-" + 1)) - (size_t )((void const   *)"-") == 1UL)) {
#line 486
            tmp___7 = 1;
          } else
#line 486
          if (__s2_len >= 4UL) {
#line 486
            tmp___7 = 1;
          } else {
#line 486
            tmp___7 = 0;
          }
        } else {
#line 486
          tmp___7 = 0;
        }
#line 486
        if (tmp___7) {
#line 486
          tmp___2 = __builtin_strcmp((char const   *)(word), "-");
#line 486
          tmp___6 = tmp___2;
        } else {
#line 486
          tmp___5 = __builtin_strcmp((char const   *)(word), "-");
#line 486
          tmp___6 = tmp___5;
        }
      } else {
#line 486
        tmp___5 = __builtin_strcmp((char const   *)(word), "-");
#line 486
        tmp___6 = tmp___5;
      }
#line 486
      if (tmp___6 != 0) {
#line 487
        _E__pr_header("src/mdef.c", 487L, "FATAL_ERROR");
#line 487
        _E__die_error("Bad context info for base phone: %s\n", line);
      }
    }
#line 488
    lp += wlen;
#line 485
    n ++;
  }
#line 492
  tmp___8 = sscanf((char const   * __restrict  )lp, (char const   * __restrict  )"%s%n",
                   word, & wlen);
#line 492
  if (tmp___8 != 1) {
#line 493
    _E__pr_header("src/mdef.c", 493L, "FATAL_ERROR");
#line 493
    _E__die_error("Missing filler atribute field: %s\n", line);
  }
#line 494
  lp += wlen;
#line 495
  if (0) {
#line 495
    __s1_len___1 = __builtin_strlen((char const   *)(word));
#line 495
    __s2_len___1 = __builtin_strlen("filler");
#line 495
    if (! ((size_t )((void const   *)(word + 1)) - (size_t )((void const   *)(word)) == 1UL)) {
#line 495
      goto _L___4;
    } else
#line 495
    if (__s1_len___1 >= 4UL) {
      _L___4: /* CIL Label */ 
#line 495
      if (! ((size_t )((void const   *)("filler" + 1)) - (size_t )((void const   *)"filler") == 1UL)) {
#line 495
        tmp___22 = 1;
      } else
#line 495
      if (__s2_len___1 >= 4UL) {
#line 495
        tmp___22 = 1;
      } else {
#line 495
        tmp___22 = 0;
      }
    } else {
#line 495
      tmp___22 = 0;
    }
#line 495
    if (tmp___22) {
#line 495
      tmp___17 = __builtin_strcmp((char const   *)(word), "filler");
#line 495
      tmp___21 = tmp___17;
    } else {
#line 495
      tmp___20 = __builtin_strcmp((char const   *)(word), "filler");
#line 495
      tmp___21 = tmp___20;
    }
  } else {
#line 495
    tmp___20 = __builtin_strcmp((char const   *)(word), "filler");
#line 495
    tmp___21 = tmp___20;
  }
#line 495
  if (tmp___21 == 0) {
#line 496
    (m->ciphone + (int )ci)->filler = 1;
  } else {
#line 497
    if (0) {
#line 497
      __s1_len___0 = __builtin_strlen((char const   *)(word));
#line 497
      __s2_len___0 = __builtin_strlen("n/a");
#line 497
      if (! ((size_t )((void const   *)(word + 1)) - (size_t )((void const   *)(word)) == 1UL)) {
#line 497
        goto _L___2;
      } else
#line 497
      if (__s1_len___0 >= 4UL) {
        _L___2: /* CIL Label */ 
#line 497
        if (! ((size_t )((void const   *)("n/a" + 1)) - (size_t )((void const   *)"n/a") == 1UL)) {
#line 497
          tmp___15 = 1;
        } else
#line 497
        if (__s2_len___0 >= 4UL) {
#line 497
          tmp___15 = 1;
        } else {
#line 497
          tmp___15 = 0;
        }
      } else {
#line 497
        tmp___15 = 0;
      }
#line 497
      if (tmp___15) {
#line 497
        tmp___10 = __builtin_strcmp((char const   *)(word), "n/a");
#line 497
        tmp___14 = tmp___10;
      } else {
#line 497
        tmp___13 = __builtin_strcmp((char const   *)(word), "n/a");
#line 497
        tmp___14 = tmp___13;
      }
    } else {
#line 497
      tmp___13 = __builtin_strcmp((char const   *)(word), "n/a");
#line 497
      tmp___14 = tmp___13;
    }
#line 497
    if (tmp___14 == 0) {
#line 498
      (m->ciphone + (int )ci)->filler = 0;
    } else {
#line 500
      _E__pr_header("src/mdef.c", 500L, "FATAL_ERROR");
#line 500
      _E__die_error("Bad filler attribute field: %s\n", line);
    }
  }
#line 502
  triphone_add(m, ci, (s3cipid_t )-1, (s3cipid_t )-1, (word_posn_t )4, p);
#line 505
  parse_tmat_senmap(m, line, (int32 )(lp - line), p);
#line 506
  return;
}
}
#line 509 "src/mdef.c"
static void parse_tri_line(mdef_t *m , char *line , s3pid_t p ) 
{ 
  int32 wlen ;
  char word[1024] ;
  char *lp ;
  s3cipid_t ci ;
  s3cipid_t lc ;
  s3cipid_t rc ;
  word_posn_t wpos ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___5 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___12 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;

  {
#line 514
  wpos = (word_posn_t )0;
#line 516
  lp = line;
#line 519
  tmp = sscanf((char const   * __restrict  )lp, (char const   * __restrict  )"%s%n",
               word, & wlen);
#line 519
  if (tmp != 1) {
#line 520
    _E__pr_header("src/mdef.c", 520L, "FATAL_ERROR");
#line 520
    _E__die_error("Missing base phone name: %s\n", line);
  }
#line 521
  lp += wlen;
#line 523
  ci = mdef_ciphone_id(m, word);
#line 524
  if ((int )ci < 0) {
#line 525
    _E__pr_header("src/mdef.c", 525L, "FATAL_ERROR");
#line 525
    _E__die_error("Unknown base phone: %s\n", line);
  }
#line 528
  tmp___0 = sscanf((char const   * __restrict  )lp, (char const   * __restrict  )"%s%n",
                   word, & wlen);
#line 528
  if (tmp___0 != 1) {
#line 529
    _E__pr_header("src/mdef.c", 529L, "FATAL_ERROR");
#line 529
    _E__die_error("Missing left context: %s\n", line);
  }
#line 530
  lp += wlen;
#line 531
  lc = mdef_ciphone_id(m, word);
#line 532
  if ((int )lc < 0) {
#line 533
    _E__pr_header("src/mdef.c", 533L, "FATAL_ERROR");
#line 533
    _E__die_error("Unknown left context: %s\n", line);
  }
#line 536
  tmp___1 = sscanf((char const   * __restrict  )lp, (char const   * __restrict  )"%s%n",
                   word, & wlen);
#line 536
  if (tmp___1 != 1) {
#line 537
    _E__pr_header("src/mdef.c", 537L, "FATAL_ERROR");
#line 537
    _E__die_error("Missing right context: %s\n", line);
  }
#line 538
  lp += wlen;
#line 539
  rc = mdef_ciphone_id(m, word);
#line 540
  if ((int )rc < 0) {
#line 541
    _E__pr_header("src/mdef.c", 541L, "FATAL_ERROR");
#line 541
    _E__die_error("Unknown right  context: %s\n", line);
  }
#line 544
  tmp___2 = sscanf((char const   * __restrict  )lp, (char const   * __restrict  )"%s%n",
                   word, & wlen);
#line 544
  if (tmp___2 != 1) {
#line 545
    _E__pr_header("src/mdef.c", 545L, "FATAL_ERROR");
#line 545
    _E__die_error("Missing or bad word-position spec: %s\n", line);
  } else
#line 544
  if ((int )word[1] != 0) {
#line 545
    _E__pr_header("src/mdef.c", 545L, "FATAL_ERROR");
#line 545
    _E__die_error("Missing or bad word-position spec: %s\n", line);
  }
#line 546
  lp += wlen;
#line 547
  switch ((int )word[0]) {
  case 98: 
#line 548
  wpos = (word_posn_t )0;
#line 548
  break;
  case 101: 
#line 549
  wpos = (word_posn_t )1;
#line 549
  break;
  case 115: 
#line 550
  wpos = (word_posn_t )2;
#line 550
  break;
  case 105: 
#line 551
  wpos = (word_posn_t )3;
#line 551
  break;
  default: 
#line 552
  _E__pr_header("src/mdef.c", 552L, "FATAL_ERROR");
#line 552
  _E__die_error("Bad word-position spec: %s\n", line);
  }
#line 556
  tmp___3 = sscanf((char const   * __restrict  )lp, (char const   * __restrict  )"%s%n",
                   word, & wlen);
#line 556
  if (tmp___3 != 1) {
#line 557
    _E__pr_header("src/mdef.c", 557L, "FATAL_ERROR");
#line 557
    _E__die_error("Missing filler attribute field: %s\n", line);
  }
#line 558
  lp += wlen;
#line 559
  if (0) {
#line 559
    __s1_len = __builtin_strlen((char const   *)(word));
#line 559
    __s2_len = __builtin_strlen("filler");
#line 559
    if (! ((size_t )((void const   *)(word + 1)) - (size_t )((void const   *)(word)) == 1UL)) {
#line 559
      goto _L___0;
    } else
#line 559
    if (__s1_len >= 4UL) {
      _L___0: /* CIL Label */ 
#line 559
      if (! ((size_t )((void const   *)("filler" + 1)) - (size_t )((void const   *)"filler") == 1UL)) {
#line 559
        tmp___10 = 1;
      } else
#line 559
      if (__s2_len >= 4UL) {
#line 559
        tmp___10 = 1;
      } else {
#line 559
        tmp___10 = 0;
      }
    } else {
#line 559
      tmp___10 = 0;
    }
#line 559
    if (tmp___10) {
#line 559
      tmp___5 = __builtin_strcmp((char const   *)(word), "filler");
#line 559
      tmp___9 = tmp___5;
    } else {
#line 559
      tmp___8 = __builtin_strcmp((char const   *)(word), "filler");
#line 559
      tmp___9 = tmp___8;
    }
  } else {
#line 559
    tmp___8 = __builtin_strcmp((char const   *)(word), "filler");
#line 559
    tmp___9 = tmp___8;
  }
#line 560
  if (tmp___9 == 0) {
#line 560
    if (! (m->ciphone + (int )ci)->filler) {
#line 560
      goto _L___3;
    }
  } else {
    _L___3: /* CIL Label */ 
#line 560
    if (0) {
#line 560
      __s1_len___0 = __builtin_strlen((char const   *)(word));
#line 560
      __s2_len___0 = __builtin_strlen("n/a");
#line 560
      if (! ((size_t )((void const   *)(word + 1)) - (size_t )((void const   *)(word)) == 1UL)) {
#line 560
        goto _L___2;
      } else
#line 560
      if (__s1_len___0 >= 4UL) {
        _L___2: /* CIL Label */ 
#line 560
        if (! ((size_t )((void const   *)("n/a" + 1)) - (size_t )((void const   *)"n/a") == 1UL)) {
#line 560
          tmp___17 = 1;
        } else
#line 560
        if (__s2_len___0 >= 4UL) {
#line 560
          tmp___17 = 1;
        } else {
#line 560
          tmp___17 = 0;
        }
      } else {
#line 560
        tmp___17 = 0;
      }
#line 560
      if (tmp___17) {
#line 560
        tmp___12 = __builtin_strcmp((char const   *)(word), "n/a");
#line 560
        tmp___16 = tmp___12;
      } else {
#line 560
        tmp___15 = __builtin_strcmp((char const   *)(word), "n/a");
#line 560
        tmp___16 = tmp___15;
      }
    } else {
#line 560
      tmp___15 = __builtin_strcmp((char const   *)(word), "n/a");
#line 560
      tmp___16 = tmp___15;
    }
#line 560
    if (tmp___16 == 0) {
#line 560
      if (! (! (m->ciphone + (int )ci)->filler)) {
#line 563
        _E__pr_header("src/mdef.c", 563L, "FATAL_ERROR");
#line 563
        _E__die_error("Bad filler attribute field: %s\n", line);
      }
    } else {
#line 563
      _E__pr_header("src/mdef.c", 563L, "FATAL_ERROR");
#line 563
      _E__die_error("Bad filler attribute field: %s\n", line);
    }
  }
#line 565
  triphone_add(m, ci, lc, rc, wpos, p);
#line 568
  parse_tmat_senmap(m, line, (int32 )(lp - line), p);
#line 569
  return;
}
}
#line 572 "src/mdef.c"
static void sseq_compress(mdef_t *m ) 
{ 
  hash_table_t *h ;
  s3senid_t **sseq ;
  int32 n_sseq ;
  int32 p ;
  int32 j ;
  int32 k___0 ;
  glist_t g ;
  gnode_t *gn ;
  hash_entry_t *he ;
  void **tmp ;

  {
#line 582
  k___0 = (int32 )((unsigned long )m->n_emit_state * sizeof(s3senid_t ));
#line 584
  h = hash_new(m->n_phone, 0);
#line 585
  n_sseq = 0;
#line 588
  p = 0;
#line 588
  while (p < m->n_phone) {
#line 590
    j = hash_enter_bkey(h, (char const   *)((char *)*(m->sseq + p)), k___0, n_sseq);
#line 590
    if (j == n_sseq) {
#line 591
      n_sseq ++;
    }
#line 593
    (m->phone + p)->ssid = j;
#line 588
    p ++;
  }
#line 597
  tmp = __ckd_calloc_2d__(n_sseq, m->n_emit_state, (int32 )sizeof(s3senid_t ), "src/mdef.c",
                          597);
#line 597
  sseq = (s3senid_t **)tmp;
#line 599
  g = hash_tolist(h, & j);
#line 600
  if (! (j == n_sseq)) {
#line 600
    __assert_fail("j == n_sseq", "src/mdef.c", 600U, "sseq_compress");
  }
#line 602
  gn = g;
#line 602
  while (gn) {
#line 603
    he = (hash_entry_t *)gn->data.ptr;
#line 604
    j = he->val;
#line 605
    memcpy((void * __restrict  )*(sseq + j), (void const   * __restrict  )he->key,
           (size_t )k___0);
#line 602
    gn = gn->next;
  }
#line 607
  glist_free(g);
#line 610
  ckd_free_2d((void **)m->sseq);
#line 611
  m->sseq = sseq;
#line 612
  m->n_sseq = n_sseq;
#line 614
  hash_free(h);
#line 615
  return;
}
}
#line 618 "src/mdef.c"
static int32 noncomment_line(char *line , int32 size , FILE *fp ) 
{ 
  char *tmp ;

  {
#line 620
  while (1) {
#line 620
    tmp = fgets((char * __restrict  )line, size, (FILE * __restrict  )fp);
#line 620
    if (! ((unsigned long )tmp != (unsigned long )((void *)0))) {
#line 620
      break;
    }
#line 621
    if ((int )*(line + 0) != 35) {
#line 622
      return (0);
    }
  }
#line 624
  return (-1);
}
}
#line 631 "src/mdef.c"
mdef_t *mdef_init(char *mdeffile ) 
{ 
  FILE *fp ;
  int32 n_ci ;
  int32 n_tri ;
  int32 n_map ;
  int32 n ;
  char tag[1024] ;
  char buf[1024] ;
  s3senid_t **senmap ;
  s3pid_t p ;
  int32 s___0 ;
  int32 ci ;
  int32 cd ;
  mdef_t *m ;
  int32 *cdsen_start ;
  int32 *cdsen_end ;
  void *tmp ;
  int32 tmp___0 ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___7 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  size_t tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int32 tmp___21 ;
  int tmp___22 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___24 ;
  int tmp___27 ;
  int tmp___28 ;
  int tmp___29 ;
  size_t __s1_len___1 ;
  size_t __s2_len___1 ;
  int tmp___31 ;
  int tmp___34 ;
  int tmp___35 ;
  int tmp___36 ;
  size_t __s1_len___2 ;
  size_t __s2_len___2 ;
  int tmp___38 ;
  int tmp___41 ;
  int tmp___42 ;
  int tmp___43 ;
  size_t __s1_len___3 ;
  size_t __s2_len___3 ;
  int tmp___45 ;
  int tmp___48 ;
  int tmp___49 ;
  int tmp___50 ;
  size_t __s1_len___4 ;
  size_t __s2_len___4 ;
  int tmp___52 ;
  int tmp___55 ;
  int tmp___56 ;
  int tmp___57 ;
  size_t __s1_len___5 ;
  size_t __s2_len___5 ;
  int tmp___59 ;
  int tmp___62 ;
  int tmp___63 ;
  int tmp___64 ;
  void *tmp___65 ;
  void *tmp___66 ;
  void **tmp___67 ;
  void **tmp___68 ;
  int32 tmp___69 ;
  int32 tmp___70 ;
  int32 tmp___71 ;
  void *tmp___72 ;
  void *tmp___73 ;
  void *tmp___74 ;
  void *tmp___75 ;
  void *tmp___76 ;

  {
#line 642
  if (! mdeffile) {
#line 643
    _E__pr_header("src/mdef.c", 643L, "FATAL_ERROR");
#line 643
    _E__die_error("No mdef-file\n");
  }
#line 645
  _E__pr_info_header("src/mdef.c", 645L, "INFO");
#line 645
  _E__pr_info("Reading model definition: %s\n", mdeffile);
#line 647
  tmp = __ckd_calloc__((size_t )1, sizeof(mdef_t ), "src/mdef.c", 647);
#line 647
  m = (mdef_t *)tmp;
#line 649
  fp = fopen((char const   * __restrict  )mdeffile, (char const   * __restrict  )"r");
#line 649
  if ((unsigned long )fp == (unsigned long )((void *)0)) {
#line 650
    _E__pr_header("src/mdef.c", 650L, "SYSTEM_ERROR");
#line 650
    _E__fatal_sys_error("fopen(%s,r) failed\n", mdeffile);
  }
#line 652
  tmp___0 = noncomment_line(buf, (int32 )sizeof(buf), fp);
#line 652
  if (tmp___0 < 0) {
#line 653
    _E__pr_header("src/mdef.c", 653L, "FATAL_ERROR");
#line 653
    _E__die_error("Empty file: %s\n", mdeffile);
  }
#line 655
  if (0) {
#line 655
    if (0) {
#line 655
      __s1_len = __builtin_strlen((char const   *)(buf));
#line 655
      __s2_len = __builtin_strlen("0.3");
#line 655
      if (! ((size_t )((void const   *)(buf + 1)) - (size_t )((void const   *)(buf)) == 1UL)) {
#line 655
        goto _L___0;
      } else
#line 655
      if (__s1_len >= 4UL) {
        _L___0: /* CIL Label */ 
#line 655
        if (! ((size_t )((void const   *)("0.3" + 1)) - (size_t )((void const   *)"0.3") == 1UL)) {
#line 655
          tmp___12 = 1;
        } else
#line 655
        if (__s2_len >= 4UL) {
#line 655
          tmp___12 = 1;
        } else {
#line 655
          tmp___12 = 0;
        }
      } else {
#line 655
        tmp___12 = 0;
      }
#line 655
      if (tmp___12) {
#line 655
        tmp___7 = __builtin_strcmp((char const   *)(buf), "0.3");
#line 655
        tmp___11 = tmp___7;
      } else {
#line 655
        tmp___10 = __builtin_strcmp((char const   *)(buf), "0.3");
#line 655
        tmp___11 = tmp___10;
      }
    } else {
#line 655
      tmp___10 = __builtin_strcmp((char const   *)(buf), "0.3");
#line 655
      tmp___11 = tmp___10;
    }
#line 655
    tmp___15 = tmp___11;
  } else {
#line 655
    tmp___13 = strlen("0.3");
#line 655
    tmp___14 = strncmp((char const   *)(buf), "0.3", tmp___13);
#line 655
    tmp___15 = tmp___14;
  }
#line 655
  if (tmp___15 != 0) {
#line 656
    _E__pr_header("src/mdef.c", 656L, "FATAL_ERROR");
#line 656
    _E__die_error("Version error: Expecing %s, but read %s\n", "0.3", buf);
  }
#line 659
  n_ci = -1;
#line 660
  n_tri = -1;
#line 661
  n_map = -1;
#line 662
  m->n_ci_sen = -1;
#line 663
  m->n_sen = -1;
#line 664
  m->n_tmat = -1;
#line 665
  while (1) {
#line 666
    tmp___21 = noncomment_line(buf, (int32 )sizeof(buf), fp);
#line 666
    if (tmp___21 < 0) {
#line 667
      _E__pr_header("src/mdef.c", 667L, "FATAL_ERROR");
#line 667
      _E__die_error("Incomplete header\n");
    }
#line 669
    tmp___22 = sscanf((char const   * __restrict  )(buf), (char const   * __restrict  )"%d %s",
                      & n, tag);
#line 669
    if (tmp___22 != 2) {
#line 670
      _E__pr_header("src/mdef.c", 670L, "FATAL_ERROR");
#line 670
      _E__die_error("Error in header: %s\n", buf);
    } else
#line 669
    if (n < 0) {
#line 670
      _E__pr_header("src/mdef.c", 670L, "FATAL_ERROR");
#line 670
      _E__die_error("Error in header: %s\n", buf);
    }
#line 672
    if (0) {
#line 672
      __s1_len___5 = __builtin_strlen((char const   *)(tag));
#line 672
      __s2_len___5 = __builtin_strlen("n_base");
#line 672
      if (! ((size_t )((void const   *)(tag + 1)) - (size_t )((void const   *)(tag)) == 1UL)) {
#line 672
        goto _L___12;
      } else
#line 672
      if (__s1_len___5 >= 4UL) {
        _L___12: /* CIL Label */ 
#line 672
        if (! ((size_t )((void const   *)("n_base" + 1)) - (size_t )((void const   *)"n_base") == 1UL)) {
#line 672
          tmp___64 = 1;
        } else
#line 672
        if (__s2_len___5 >= 4UL) {
#line 672
          tmp___64 = 1;
        } else {
#line 672
          tmp___64 = 0;
        }
      } else {
#line 672
        tmp___64 = 0;
      }
#line 672
      if (tmp___64) {
#line 672
        tmp___59 = __builtin_strcmp((char const   *)(tag), "n_base");
#line 672
        tmp___63 = tmp___59;
      } else {
#line 672
        tmp___62 = __builtin_strcmp((char const   *)(tag), "n_base");
#line 672
        tmp___63 = tmp___62;
      }
    } else {
#line 672
      tmp___62 = __builtin_strcmp((char const   *)(tag), "n_base");
#line 672
      tmp___63 = tmp___62;
    }
#line 672
    if (tmp___63 == 0) {
#line 673
      n_ci = n;
    } else {
#line 674
      if (0) {
#line 674
        __s1_len___4 = __builtin_strlen((char const   *)(tag));
#line 674
        __s2_len___4 = __builtin_strlen("n_tri");
#line 674
        if (! ((size_t )((void const   *)(tag + 1)) - (size_t )((void const   *)(tag)) == 1UL)) {
#line 674
          goto _L___10;
        } else
#line 674
        if (__s1_len___4 >= 4UL) {
          _L___10: /* CIL Label */ 
#line 674
          if (! ((size_t )((void const   *)("n_tri" + 1)) - (size_t )((void const   *)"n_tri") == 1UL)) {
#line 674
            tmp___57 = 1;
          } else
#line 674
          if (__s2_len___4 >= 4UL) {
#line 674
            tmp___57 = 1;
          } else {
#line 674
            tmp___57 = 0;
          }
        } else {
#line 674
          tmp___57 = 0;
        }
#line 674
        if (tmp___57) {
#line 674
          tmp___52 = __builtin_strcmp((char const   *)(tag), "n_tri");
#line 674
          tmp___56 = tmp___52;
        } else {
#line 674
          tmp___55 = __builtin_strcmp((char const   *)(tag), "n_tri");
#line 674
          tmp___56 = tmp___55;
        }
      } else {
#line 674
        tmp___55 = __builtin_strcmp((char const   *)(tag), "n_tri");
#line 674
        tmp___56 = tmp___55;
      }
#line 674
      if (tmp___56 == 0) {
#line 675
        n_tri = n;
      } else {
#line 676
        if (0) {
#line 676
          __s1_len___3 = __builtin_strlen((char const   *)(tag));
#line 676
          __s2_len___3 = __builtin_strlen("n_state_map");
#line 676
          if (! ((size_t )((void const   *)(tag + 1)) - (size_t )((void const   *)(tag)) == 1UL)) {
#line 676
            goto _L___8;
          } else
#line 676
          if (__s1_len___3 >= 4UL) {
            _L___8: /* CIL Label */ 
#line 676
            if (! ((size_t )((void const   *)("n_state_map" + 1)) - (size_t )((void const   *)"n_state_map") == 1UL)) {
#line 676
              tmp___50 = 1;
            } else
#line 676
            if (__s2_len___3 >= 4UL) {
#line 676
              tmp___50 = 1;
            } else {
#line 676
              tmp___50 = 0;
            }
          } else {
#line 676
            tmp___50 = 0;
          }
#line 676
          if (tmp___50) {
#line 676
            tmp___45 = __builtin_strcmp((char const   *)(tag), "n_state_map");
#line 676
            tmp___49 = tmp___45;
          } else {
#line 676
            tmp___48 = __builtin_strcmp((char const   *)(tag), "n_state_map");
#line 676
            tmp___49 = tmp___48;
          }
        } else {
#line 676
          tmp___48 = __builtin_strcmp((char const   *)(tag), "n_state_map");
#line 676
          tmp___49 = tmp___48;
        }
#line 676
        if (tmp___49 == 0) {
#line 677
          n_map = n;
        } else {
#line 678
          if (0) {
#line 678
            __s1_len___2 = __builtin_strlen((char const   *)(tag));
#line 678
            __s2_len___2 = __builtin_strlen("n_tied_ci_state");
#line 678
            if (! ((size_t )((void const   *)(tag + 1)) - (size_t )((void const   *)(tag)) == 1UL)) {
#line 678
              goto _L___6;
            } else
#line 678
            if (__s1_len___2 >= 4UL) {
              _L___6: /* CIL Label */ 
#line 678
              if (! ((size_t )((void const   *)("n_tied_ci_state" + 1)) - (size_t )((void const   *)"n_tied_ci_state") == 1UL)) {
#line 678
                tmp___43 = 1;
              } else
#line 678
              if (__s2_len___2 >= 4UL) {
#line 678
                tmp___43 = 1;
              } else {
#line 678
                tmp___43 = 0;
              }
            } else {
#line 678
              tmp___43 = 0;
            }
#line 678
            if (tmp___43) {
#line 678
              tmp___38 = __builtin_strcmp((char const   *)(tag), "n_tied_ci_state");
#line 678
              tmp___42 = tmp___38;
            } else {
#line 678
              tmp___41 = __builtin_strcmp((char const   *)(tag), "n_tied_ci_state");
#line 678
              tmp___42 = tmp___41;
            }
          } else {
#line 678
            tmp___41 = __builtin_strcmp((char const   *)(tag), "n_tied_ci_state");
#line 678
            tmp___42 = tmp___41;
          }
#line 678
          if (tmp___42 == 0) {
#line 679
            m->n_ci_sen = n;
          } else {
#line 680
            if (0) {
#line 680
              __s1_len___1 = __builtin_strlen((char const   *)(tag));
#line 680
              __s2_len___1 = __builtin_strlen("n_tied_state");
#line 680
              if (! ((size_t )((void const   *)(tag + 1)) - (size_t )((void const   *)(tag)) == 1UL)) {
#line 680
                goto _L___4;
              } else
#line 680
              if (__s1_len___1 >= 4UL) {
                _L___4: /* CIL Label */ 
#line 680
                if (! ((size_t )((void const   *)("n_tied_state" + 1)) - (size_t )((void const   *)"n_tied_state") == 1UL)) {
#line 680
                  tmp___36 = 1;
                } else
#line 680
                if (__s2_len___1 >= 4UL) {
#line 680
                  tmp___36 = 1;
                } else {
#line 680
                  tmp___36 = 0;
                }
              } else {
#line 680
                tmp___36 = 0;
              }
#line 680
              if (tmp___36) {
#line 680
                tmp___31 = __builtin_strcmp((char const   *)(tag), "n_tied_state");
#line 680
                tmp___35 = tmp___31;
              } else {
#line 680
                tmp___34 = __builtin_strcmp((char const   *)(tag), "n_tied_state");
#line 680
                tmp___35 = tmp___34;
              }
            } else {
#line 680
              tmp___34 = __builtin_strcmp((char const   *)(tag), "n_tied_state");
#line 680
              tmp___35 = tmp___34;
            }
#line 680
            if (tmp___35 == 0) {
#line 681
              m->n_sen = n;
            } else {
#line 682
              if (0) {
#line 682
                __s1_len___0 = __builtin_strlen((char const   *)(tag));
#line 682
                __s2_len___0 = __builtin_strlen("n_tied_tmat");
#line 682
                if (! ((size_t )((void const   *)(tag + 1)) - (size_t )((void const   *)(tag)) == 1UL)) {
#line 682
                  goto _L___2;
                } else
#line 682
                if (__s1_len___0 >= 4UL) {
                  _L___2: /* CIL Label */ 
#line 682
                  if (! ((size_t )((void const   *)("n_tied_tmat" + 1)) - (size_t )((void const   *)"n_tied_tmat") == 1UL)) {
#line 682
                    tmp___29 = 1;
                  } else
#line 682
                  if (__s2_len___0 >= 4UL) {
#line 682
                    tmp___29 = 1;
                  } else {
#line 682
                    tmp___29 = 0;
                  }
                } else {
#line 682
                  tmp___29 = 0;
                }
#line 682
                if (tmp___29) {
#line 682
                  tmp___24 = __builtin_strcmp((char const   *)(tag), "n_tied_tmat");
#line 682
                  tmp___28 = tmp___24;
                } else {
#line 682
                  tmp___27 = __builtin_strcmp((char const   *)(tag), "n_tied_tmat");
#line 682
                  tmp___28 = tmp___27;
                }
              } else {
#line 682
                tmp___27 = __builtin_strcmp((char const   *)(tag), "n_tied_tmat");
#line 682
                tmp___28 = tmp___27;
              }
#line 682
              if (tmp___28 == 0) {
#line 683
                m->n_tmat = n;
              } else {
#line 685
                _E__pr_header("src/mdef.c", 685L, "FATAL_ERROR");
#line 685
                _E__die_error("Unknown header line: %s\n", buf);
              }
            }
          }
        }
      }
    }
#line 665
    if (! (n_ci < 0)) {
#line 665
      if (! (n_tri < 0)) {
#line 665
        if (! (n_map < 0)) {
#line 665
          if (! (m->n_ci_sen < 0)) {
#line 665
            if (! (m->n_sen < 0)) {
#line 665
              if (! (m->n_tmat < 0)) {
#line 665
                break;
              }
            }
          }
        }
      }
    }
  }
#line 689
  if (n_ci == 0) {
#line 690
    _E__pr_header("src/mdef.c", 690L, "FATAL_ERROR");
#line 690
    _E__die_error("%s: Error in header\n", mdeffile);
  } else
#line 689
  if (m->n_ci_sen == 0) {
#line 690
    _E__pr_header("src/mdef.c", 690L, "FATAL_ERROR");
#line 690
    _E__die_error("%s: Error in header\n", mdeffile);
  } else
#line 689
  if (m->n_tmat == 0) {
#line 690
    _E__pr_header("src/mdef.c", 690L, "FATAL_ERROR");
#line 690
    _E__die_error("%s: Error in header\n", mdeffile);
  } else
#line 689
  if (m->n_ci_sen > m->n_sen) {
#line 690
    _E__pr_header("src/mdef.c", 690L, "FATAL_ERROR");
#line 690
    _E__die_error("%s: Error in header\n", mdeffile);
  }
#line 693
  if (n_ci >= 127) {
#line 694
    _E__pr_header("src/mdef.c", 694L, "FATAL_ERROR");
#line 694
    _E__die_error("%s: #CI phones (%d) exceeds limit (%d)\n", mdeffile, n_ci, 127);
  }
#line 695
  if (n_ci + n_tri >= 2147483646) {
#line 696
    _E__pr_header("src/mdef.c", 696L, "FATAL_ERROR");
#line 696
    _E__die_error("%s: #Phones (%d) exceeds limit (%d)\n", mdeffile, n_ci + n_tri,
                  2147483646);
  }
#line 697
  if (m->n_sen >= 32766) {
#line 698
    _E__pr_header("src/mdef.c", 698L, "FATAL_ERROR");
#line 698
    _E__die_error("%s: #senones (%d) exceeds limit (%d)\n", mdeffile, m->n_sen, (int )((int16 )32766));
  }
#line 699
  if (m->n_tmat >= 2147483646) {
#line 700
    _E__pr_header("src/mdef.c", 700L, "FATAL_ERROR");
#line 700
    _E__die_error("%s: #tmats (%d) exceeds limit (%d)\n", mdeffile, m->n_tmat, 2147483646);
  }
#line 702
  m->n_emit_state = n_map / (n_ci + n_tri) - 1;
#line 703
  if ((m->n_emit_state + 1) * (n_ci + n_tri) != n_map) {
#line 704
    _E__pr_header("src/mdef.c", 704L, "FATAL_ERROR");
#line 704
    _E__die_error("Header error: n_state_map not a multiple of n_ci*n_tri\n");
  }
#line 707
  m->n_ciphone = n_ci;
#line 708
  m->ciphone_ht = hash_new(n_ci, 1);
#line 709
  tmp___65 = __ckd_calloc__((size_t )n_ci, sizeof(ciphone_t ), "src/mdef.c", 709);
#line 709
  m->ciphone = (ciphone_t *)tmp___65;
#line 716
  m->n_phone = n_ci + n_tri;
#line 717
  tmp___66 = __ckd_calloc__((size_t )m->n_phone, sizeof(phone_t ), "src/mdef.c", 717);
#line 717
  m->phone = (phone_t *)tmp___66;
#line 720
  tmp___67 = __ckd_calloc_2d__(m->n_phone, m->n_emit_state, (int32 )sizeof(s3senid_t ),
                               "src/mdef.c", 720);
#line 720
  senmap = (s3senid_t **)tmp___67;
#line 721
  m->sseq = senmap;
#line 724
  tmp___68 = __ckd_calloc_2d__(4, m->n_ciphone, (int32 )sizeof(ph_lc_t *), "src/mdef.c",
                               724);
#line 724
  m->wpos_ci_lclist = (ph_lc_t ***)tmp___68;
#line 730
  _E__pr_info_header("src/mdef.c", 730L, "INFO");
#line 730
  _E__pr_info("reading base phones\n");
#line 732
  p = 0;
#line 732
  while (p < n_ci) {
#line 733
    tmp___69 = noncomment_line(buf, (int32 )sizeof(buf), fp);
#line 733
    if (tmp___69 < 0) {
#line 734
      _E__pr_header("src/mdef.c", 734L, "FATAL_ERROR");
#line 734
      _E__die_error("Premature EOF reading CIphone %d\n", p);
    }
#line 735
    parse_base_line(m, buf, p);
#line 732
    p ++;
  }
#line 737
  m->sil = mdef_ciphone_id(m, (char *)"SIL");
#line 739
  _E__pr_info_header("src/mdef.c", 739L, "INFO");
#line 739
  _E__pr_info("done base phones, reading triphones\n");
#line 741
  while (p < m->n_phone) {
#line 742
    tmp___70 = noncomment_line(buf, (int32 )sizeof(buf), fp);
#line 742
    if (tmp___70 < 0) {
#line 743
      _E__pr_header("src/mdef.c", 743L, "FATAL_ERROR");
#line 743
      _E__die_error("Premature EOF reading phone %d\n", p);
    }
#line 744
    parse_tri_line(m, buf, p);
#line 741
    p ++;
  }
#line 747
  tmp___71 = noncomment_line(buf, (int32 )sizeof(buf), fp);
#line 747
  if (tmp___71 >= 0) {
#line 748
    _E__pr_header("src/mdef.c", 748L, "ERROR");
#line 748
    _E__pr_warn("Non-empty file beyond expected #phones (%d)\n", m->n_phone);
  }
#line 751
  if (m->n_ciphone * m->n_emit_state != m->n_ci_sen) {
#line 752
    _E__pr_header("src/mdef.c", 752L, "FATAL_ERROR");
#line 752
    _E__die_error("#CI-senones(%d) != #CI-phone(%d) x #emitting-states(%d)\n", m->n_ci_sen,
                  m->n_ciphone, m->n_emit_state);
  }
#line 754
  tmp___72 = __ckd_calloc__((size_t )m->n_sen, sizeof(s3senid_t ), "src/mdef.c", 754);
#line 754
  m->cd2cisen = (s3senid_t *)tmp___72;
#line 756
  tmp___73 = __ckd_calloc__((size_t )m->n_sen, sizeof(s3cipid_t ), "src/mdef.c", 756);
#line 756
  m->sen2cimap = (s3cipid_t *)tmp___73;
#line 758
  _E__pr_info_header("src/mdef.c", 758L, "INFO");
#line 758
  _E__pr_info("setting BAD_S3CIPID\n");
#line 759
  s___0 = 0;
#line 759
  while (s___0 < m->n_sen) {
#line 760
    *(m->sen2cimap + s___0) = (s3cipid_t )-1;
#line 759
    s___0 ++;
  }
#line 762
  _E__pr_info_header("src/mdef.c", 762L, "INFO");
#line 762
  _E__pr_info("doing CI senones\n");
#line 763
  s___0 = 0;
#line 763
  while (s___0 < m->n_ci_sen) {
#line 764
    *(m->cd2cisen + s___0) = (s3senid_t )s___0;
#line 765
    *(m->sen2cimap + s___0) = (s3cipid_t )(s___0 / m->n_emit_state);
#line 763
    s___0 ++;
  }
#line 768
  _E__pr_info_header("src/mdef.c", 768L, "INFO");
#line 768
  _E__pr_info("doing CD senones\n");
#line 769
  p = n_ci;
#line 769
  while (p < m->n_phone) {
#line 770
    s___0 = 0;
#line 770
    while (s___0 < m->n_emit_state) {
#line 771
      cd = (int32 )*(*(m->sseq + p) + s___0);
#line 772
      ci = (int32 )*(*(m->sseq + (int )(m->phone + p)->ci) + s___0);
#line 773
      *(m->cd2cisen + cd) = (s3senid_t )ci;
#line 774
      *(m->sen2cimap + cd) = (m->phone + p)->ci;
#line 770
      s___0 ++;
    }
#line 769
    p ++;
  }
#line 783
  tmp___74 = __ckd_calloc__((size_t )m->n_ciphone, sizeof(int32 ), "src/mdef.c", 783);
#line 783
  cdsen_start = (int32 *)tmp___74;
#line 785
  tmp___75 = __ckd_calloc__((size_t )m->n_ciphone, sizeof(int32 ), "src/mdef.c", 785);
#line 785
  cdsen_end = (int32 *)tmp___75;
#line 787
  _E__pr_info_header("src/mdef.c", 787L, "INFO");
#line 787
  _E__pr_info("doing CD sen\n");
#line 788
  s___0 = m->n_ci_sen;
#line 788
  while (s___0 < m->n_sen) {
#line 789
    if ((int )*(m->sen2cimap + s___0) < 0) {
#line 790
      goto __Cont;
    }
#line 792
    if (! *(cdsen_start + (int )*(m->sen2cimap + s___0))) {
#line 793
      *(cdsen_start + (int )*(m->sen2cimap + s___0)) = s___0;
    }
#line 794
    *(cdsen_end + (int )*(m->sen2cimap + s___0)) = s___0;
    __Cont: /* CIL Label */ 
#line 788
    s___0 ++;
  }
#line 798
  _E__pr_info_header("src/mdef.c", 798L, "INFO");
#line 798
  _E__pr_info("fill up holes\n");
#line 799
  s___0 = m->n_ci_sen;
#line 799
  while (s___0 < m->n_sen) {
#line 800
    if ((int )*(m->sen2cimap + s___0) >= 0) {
#line 801
      goto __Cont___0;
    }
#line 804
    p = 0;
#line 804
    while (p < m->n_ciphone) {
#line 805
      if (s___0 > *(cdsen_start + p)) {
#line 805
        if (s___0 < *(cdsen_end + p)) {
#line 806
          break;
        }
      }
#line 804
      p ++;
    }
#line 808
    if (p >= m->n_ciphone) {
#line 809
      _E__pr_header("src/mdef.c", 809L, "FATAL_ERROR");
#line 809
      _E__die_error("Unreferenced senone %d; cannot determine parent CIphone\n", s___0);
    }
#line 810
    *(m->sen2cimap + s___0) = (s3cipid_t )p;
    __Cont___0: /* CIL Label */ 
#line 799
    s___0 ++;
  }
#line 814
  tmp___76 = __ckd_calloc__((size_t )m->n_ciphone, sizeof(int32 ), "src/mdef.c", 814);
#line 814
  m->ciphone2n_cd_sen = (int32 *)tmp___76;
#line 815
  n = 0;
#line 816
  _E__pr_info_header("src/mdef.c", 816L, "INFO");
#line 816
  _E__pr_info("build cd senones\n");
#line 817
  p = 0;
#line 817
  while (p < m->n_ciphone) {
#line 818
    if (*(cdsen_start + p) > 0) {
#line 819
      *(m->ciphone2n_cd_sen + p) = (*(cdsen_end + p) - *(cdsen_start + p)) + 1;
#line 820
      n += *(m->ciphone2n_cd_sen + p);
    }
#line 817
    p ++;
  }
#line 823
  n += m->n_ci_sen;
#line 824
  if (! (n == m->n_sen)) {
#line 824
    __assert_fail("n == m->n_sen", "src/mdef.c", 824U, "mdef_init");
  }
#line 826
  free((void *)cdsen_start);
#line 827
  free((void *)cdsen_end);
#line 829
  sseq_compress(m);
#line 831
  _E__pr_info_header("src/mdef.c", 831L, "INFO");
#line 831
  _E__pr_info("%d CI-phone, %d CD-phone, %d emitstate/phone, %d CI-sen, %d Sen, %d Sen-Seq\n",
              m->n_ciphone, m->n_phone - m->n_ciphone, m->n_emit_state, m->n_ci_sen,
              m->n_sen, m->n_sseq);
#line 835
  fclose(fp);
#line 837
  return (m);
}
}
#line 841 "src/mdef.c"
void mdef_sseq2sen_active(mdef_t *mdef , int32 *sseq , int32 *sen ) 
{ 
  int32 ss ;
  int32 i ;
  s3senid_t *sp ;

  {
#line 846
  ss = 0;
#line 846
  while (ss < mdef->n_sseq) {
#line 847
    if (*(sseq + ss)) {
#line 848
      sp = *(mdef->sseq + ss);
#line 849
      i = 0;
#line 849
      while (i < mdef->n_emit_state) {
#line 850
        *(sen + *(sp + i)) = 1;
#line 849
        i ++;
      }
    }
#line 846
    ss ++;
  }
#line 853
  return;
}
}
#line 866 "src/mdef.c"
void mdef_free_recursive_lc(ph_lc_t *lc ) 
{ 


  {
#line 868
  if ((unsigned long )lc == (unsigned long )((void *)0)) {
#line 868
    return;
  }
#line 870
  if (lc->rclist) {
#line 871
    mdef_free_recursive_rc(lc->rclist);
  }
#line 873
  if (lc->next) {
#line 874
    mdef_free_recursive_lc(lc->next);
  }
#line 876
  free((void *)lc);
#line 877
  return;
}
}
#line 879 "src/mdef.c"
void mdef_free_recursive_rc(ph_rc_t *rc ) 
{ 


  {
#line 881
  if ((unsigned long )rc == (unsigned long )((void *)0)) {
#line 881
    return;
  }
#line 883
  if (rc->next) {
#line 884
    mdef_free_recursive_rc(rc->next);
  }
#line 886
  free((void *)rc);
#line 887
  return;
}
}
#line 894 "src/mdef.c"
void mdef_free(mdef_t *m ) 
{ 
  int i ;
  int j ;

  {
#line 898
  if (m) {
#line 899
    if (m->ciphone2n_cd_sen) {
#line 900
      free((void *)m->ciphone2n_cd_sen);
    }
#line 901
    if (m->sen2cimap) {
#line 902
      free((void *)m->sen2cimap);
    }
#line 903
    if (m->cd2cisen) {
#line 904
      free((void *)m->cd2cisen);
    }
#line 907
    i = 0;
#line 907
    while (i < 4) {
#line 908
      j = 0;
#line 908
      while (j < m->n_ciphone) {
#line 909
        if (*(*(m->wpos_ci_lclist + i) + j)) {
#line 910
          mdef_free_recursive_lc((*(*(m->wpos_ci_lclist + i) + j))->next);
#line 911
          mdef_free_recursive_rc((*(*(m->wpos_ci_lclist + i) + j))->rclist);
        }
#line 908
        j ++;
      }
#line 907
      i ++;
    }
#line 914
    i = 0;
#line 914
    while (i < 4) {
#line 915
      j = 0;
#line 915
      while (j < m->n_ciphone) {
#line 916
        if (*(*(m->wpos_ci_lclist + i) + j)) {
#line 917
          free((void *)*(*(m->wpos_ci_lclist + i) + j));
        }
#line 915
        j ++;
      }
#line 914
      i ++;
    }
#line 920
    if (m->wpos_ci_lclist) {
#line 921
      ckd_free_2d((void **)((void *)m->wpos_ci_lclist));
    }
#line 922
    if (m->sseq) {
#line 923
      ckd_free_2d((void **)((void *)m->sseq));
    }
#line 925
    if (m->phone) {
#line 926
      free((void *)m->phone);
    }
#line 927
    if (m->ciphone_ht) {
#line 928
      hash_free(m->ciphone_ht);
    }
#line 930
    i = 0;
#line 930
    while (i < m->n_ciphone) {
#line 931
      if ((m->ciphone + i)->name) {
#line 932
        free((void *)(m->ciphone + i)->name);
      }
#line 930
      i ++;
    }
#line 934
    if (m->ciphone) {
#line 935
      free((void *)m->ciphone);
    }
#line 937
    free((void *)m);
  }
#line 939
  return;
}
}
#line 1 "dict.o"
#pragma merger("0","/tmp/cil-mw_DajLu.i","-g,-O4")
#line 150 "/usr/include/x86_64-linux-gnu/bits/mathinline.h"
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__, __always_inline__)) __signbitl)(long double __x )  __attribute__((__const__)) ;
#line 150 "/usr/include/x86_64-linux-gnu/bits/mathinline.h"
__inline extern int ( __attribute__((__leaf__, __always_inline__)) __signbitl)(long double __x ) 
{ 
  union __anonunion___u_29___6 __u ;

  {
#line 153
  __u.__l = __x;
#line 154
  return ((__u.__i[2] & 32768) != 0);
}
}
#line 160 "src/dict.h"
dict_t *dict_init(mdef_t *mdef , char *dictfile , char *fillerfile , char comp_sep ) ;
#line 168
s3wid_t dict_wordid(dict_t *d , char *word ) ;
#line 174
int32 dict_filler_word(dict_t *d , s3wid_t w___0 ) ;
#line 180
s3wid_t dict_add_word(dict_t *d , char *word , s3cipid_t *p , int32 np ) ;
#line 186
s3wid_t dict_wids2compwid(dict_t *d , s3wid_t *wid , int32 len ) ;
#line 193
char const   *dict_ciphone_str(dict_t *d , s3wid_t wid , int32 pos ) ;
#line 218
s3wid_t _dict_basewid(dict_t *d , s3wid_t w___0 ) ;
#line 223
char *_dict_wordstr(dict_t *d , s3wid_t wid ) ;
#line 229
s3wid_t _dict_nextalt(dict_t *d , s3wid_t wid ) ;
#line 238
int32 dict_word2basestr(char *word ) ;
#line 241
void dict_free(dict_t *d ) ;
#line 121 "src/dict.c"
static s3cipid_t dict_ciphone_id(dict_t *d , char *str ) 
{ 
  int32 id ;
  s3cipid_t tmp ;
  int32 tmp___0 ;
  char *tmp___1 ;
  int32 tmp___2 ;
  int32 tmp___3 ;

  {
#line 125
  if (d->mdef) {
#line 126
    tmp = mdef_ciphone_id(d->mdef, str);
#line 126
    return (tmp);
  } else {
#line 128
    tmp___3 = hash_lookup(d->pht, (char const   *)str, & id);
#line 128
    if (tmp___3 < 0) {
#line 129
      tmp___0 = d->n_ciphone;
#line 129
      (d->n_ciphone) ++;
#line 129
      id = tmp___0;
#line 131
      if (id >= 127) {
#line 132
        _E__pr_header("src/dict.c", 132L, "FATAL_ERROR");
#line 132
        _E__die_error("Too many CIphones in dictionary; increase MAX_S3CIPID\n");
      }
#line 133
      tmp___1 = __ckd_salloc__((char const   *)str, "src/dict.c", 133);
#line 133
      *(d->ciphone_str + id) = tmp___1;
#line 135
      tmp___2 = hash_enter(d->pht, (char const   *)*(d->ciphone_str + id), id);
#line 135
      if (tmp___2 != id) {
#line 136
        _E__pr_header("src/dict.c", 136L, "FATAL_ERROR");
#line 136
        _E__die_error("hash_enter(local-phonetable, %s) failed\n", str);
      }
    }
#line 138
    return ((s3cipid_t )id);
  }
}
}
#line 143 "src/dict.c"
char const   *dict_ciphone_str(dict_t *d , s3wid_t wid , int32 pos ) 
{ 
  char const   *tmp ;

  {
#line 145
  if (! ((unsigned long )d != (unsigned long )((void *)0))) {
#line 145
    __assert_fail("d != ((void *)0)", "src/dict.c", 145U, "dict_ciphone_str");
  }
#line 146
  if (wid >= 0) {
#line 146
    if (! (wid < d->n_word)) {
#line 146
      __assert_fail("(wid >= 0) && (wid < d->n_word)", "src/dict.c", 146U, "dict_ciphone_str");
    }
  } else {
#line 146
    __assert_fail("(wid >= 0) && (wid < d->n_word)", "src/dict.c", 146U, "dict_ciphone_str");
  }
#line 147
  if (pos >= 0) {
#line 147
    if (! (pos < (d->word + wid)->pronlen)) {
#line 147
      __assert_fail("(pos >= 0) && (pos < d->word[wid].pronlen)", "src/dict.c", 147U,
                    "dict_ciphone_str");
    }
  } else {
#line 147
    __assert_fail("(pos >= 0) && (pos < d->word[wid].pronlen)", "src/dict.c", 147U,
                  "dict_ciphone_str");
  }
#line 149
  if (d->mdef) {
#line 150
    tmp = mdef_ciphone_str(d->mdef, *((d->word + wid)->ciphone + pos));
#line 150
    return (tmp);
  } else {
#line 152
    return ((char const   *)*(d->ciphone_str + (int )*((d->word + wid)->ciphone + pos)));
  }
}
}
#line 156 "src/dict.c"
s3wid_t dict_add_word(dict_t *d , char *word , s3cipid_t *p , int32 np ) 
{ 
  int32 w___0 ;
  int32 len ;
  dictword_t *wordp ;
  s3wid_t newwid ;
  char *tmp ;
  int32 tmp___0 ;
  void *tmp___1 ;
  int32 tmp___2 ;
  int32 tmp___3 ;

  {
#line 162
  if (d->n_word >= d->max_words) {
#line 163
    _E__pr_header("src/dict.c", 163L, "ERROR");
#line 163
    _E__pr_warn("Dictionary full; add(%s) failed\n", word);
#line 164
    return (-1);
  }
#line 167
  wordp = d->word + d->n_word;
#line 168
  tmp = __ckd_salloc__((char const   *)word, "src/dict.c", 168);
#line 168
  wordp->word = tmp;
#line 171
  tmp___0 = hash_enter(d->ht, (char const   *)wordp->word, d->n_word);
#line 171
  if (tmp___0 != d->n_word) {
#line 172
    free((void *)wordp->word);
#line 173
    return (-1);
  }
#line 177
  if (p) {
#line 177
    if (np > 0) {
#line 178
      tmp___1 = __ckd_malloc__((unsigned long )np * sizeof(s3cipid_t ), "src/dict.c",
                               178);
#line 178
      wordp->ciphone = (s3cipid_t *)tmp___1;
#line 179
      memcpy((void * __restrict  )wordp->ciphone, (void const   * __restrict  )p,
             (unsigned long )np * sizeof(s3cipid_t ));
#line 180
      wordp->pronlen = np;
    } else {
#line 182
      wordp->ciphone = (s3cipid_t *)((void *)0);
#line 183
      wordp->pronlen = 0;
    }
  } else {
#line 182
    wordp->ciphone = (s3cipid_t *)((void *)0);
#line 183
    wordp->pronlen = 0;
  }
#line 185
  wordp->alt = -1;
#line 186
  wordp->basewid = d->n_word;
#line 187
  wordp->n_comp = 0;
#line 188
  wordp->comp = (s3wid_t *)((void *)0);
#line 191
  len = dict_word2basestr(word);
#line 191
  if (len > 0) {
#line 193
    tmp___2 = hash_lookup(d->ht, (char const   *)word, & w___0);
#line 193
    if (tmp___2 < 0) {
#line 194
      *(word + len) = (char )'(';
#line 195
      _E__pr_header("src/dict.c", 195L, "FATAL_ERROR");
#line 195
      _E__die_error("Missing base word for: %s\n", word);
    } else {
#line 197
      *(word + len) = (char )'(';
    }
#line 200
    wordp->basewid = w___0;
#line 201
    wordp->alt = (d->word + w___0)->alt;
#line 202
    (d->word + w___0)->alt = d->n_word;
  }
#line 205
  tmp___3 = d->n_word;
#line 205
  (d->n_word) ++;
#line 205
  newwid = tmp___3;
#line 207
  return (newwid);
}
}
#line 211 "src/dict.c"
static int32 dict_read(FILE *fp , dict_t *d ) 
{ 
  char line[16384] ;
  char **wptr ;
  s3cipid_t p[4096] ;
  int32 lineno ;
  int32 nwd ;
  s3wid_t w___0 ;
  int32 i ;
  int32 maxwd ;
  void *tmp ;
  char *tmp___0 ;

  {
#line 219
  maxwd = 4092;
#line 220
  tmp = __ckd_calloc__((size_t )maxwd, sizeof(char *), "src/dict.c", 220);
#line 220
  wptr = (char **)tmp;
#line 222
  lineno = 0;
#line 223
  while (1) {
#line 223
    tmp___0 = fgets((char * __restrict  )(line), (int )sizeof(line), (FILE * __restrict  )fp);
#line 223
    if (! ((unsigned long )tmp___0 != (unsigned long )((void *)0))) {
#line 223
      break;
    }
#line 224
    lineno ++;
#line 225
    if ((int )line[0] == 35) {
#line 226
      continue;
    }
#line 228
    nwd = str2words(line, wptr, maxwd);
#line 228
    if (nwd < 0) {
#line 229
      _E__pr_header("src/dict.c", 229L, "FATAL_ERROR");
#line 229
      _E__die_error("str2words(%s) failed; Increase maxwd from %d\n", line, maxwd);
    }
#line 231
    if (nwd == 0) {
#line 232
      continue;
    }
#line 234
    if (nwd == 1) {
#line 235
      _E__pr_header("src/dict.c", 235L, "ERROR");
#line 235
      _E__pr_warn("Line %d: No pronunciation for word %s; ignored\n", lineno, *(wptr + 0));
#line 236
      continue;
    }
#line 240
    i = 1;
#line 240
    while (i < nwd) {
#line 241
      p[i - 1] = dict_ciphone_id(d, *(wptr + i));
#line 242
      if ((int )p[i - 1] < 0) {
#line 243
        _E__pr_header("src/dict.c", 243L, "ERROR");
#line 243
        _E__pr_warn("Line %d: Bad ciphone: %s; word %s ignored\n", lineno, *(wptr + i),
                    *(wptr + 0));
#line 245
        break;
      }
#line 240
      i ++;
    }
#line 249
    if (i == nwd) {
#line 250
      w___0 = dict_add_word(d, *(wptr + 0), p, nwd - 1);
#line 251
      if (w___0 < 0) {
#line 252
        _E__pr_header("src/dict.c", 252L, "ERROR");
#line 252
        _E__pr_warn("Line %d: dict_add_word (%s) failed (duplicate?); ignored\n",
                    lineno, *(wptr + 0));
      }
    }
  }
#line 257
  free((void *)wptr);
#line 259
  return (0);
}
}
#line 263 "src/dict.c"
static s3wid_t *dict_comp_head(dict_t *d ) 
{ 
  int32 w___0 ;
  s3wid_t *comp_head ;
  void *tmp ;

  {
#line 268
  tmp = __ckd_calloc__((size_t )d->n_word, sizeof(s3wid_t ), "src/dict.c", 268);
#line 268
  comp_head = (s3wid_t *)tmp;
#line 270
  w___0 = 0;
#line 270
  while (w___0 < d->n_word) {
#line 271
    *(comp_head + w___0) = -1;
#line 270
    w___0 ++;
  }
#line 272
  w___0 = 0;
#line 272
  while (w___0 < d->n_word) {
#line 273
    if ((d->word + w___0)->n_comp > 0) {
#line 274
      *(comp_head + w___0) = *(comp_head + *((d->word + w___0)->comp + 0));
#line 275
      *(comp_head + *((d->word + w___0)->comp + 0)) = w___0;
    }
#line 272
    w___0 ++;
  }
#line 279
  return (comp_head);
}
}
#line 289 "src/dict.c"
static int32 dict_build_comp(dict_t *d , char sep ) 
{ 
  char wd[4096] ;
  int32 w___0 ;
  int32 cwid ;
  dictword_t *wordp ;
  int32 nc ;
  int32 i ;
  int32 j ;
  int32 l ;
  int32 n ;
  size_t tmp ;
  int32 tmp___0 ;
  void *tmp___1 ;

  {
#line 298
  nc = 0;
#line 299
  w___0 = 0;
#line 299
  while (w___0 < d->n_word) {
#line 300
    wordp = d->word + (d->word + w___0)->basewid;
#line 301
    strcpy((char * __restrict  )(wd), (char const   * __restrict  )wordp->word);
#line 302
    tmp = strlen((char const   *)(wd));
#line 302
    l = (int32 )tmp;
#line 303
    if ((int )wd[0] == (int )sep) {
#line 304
      _E__pr_header("src/dict.c", 304L, "FATAL_ERROR");
#line 304
      _E__die_error("Bad compound word %s: leading or trailing separator\n", wordp->word);
    } else
#line 303
    if ((int )wd[l - 1] == (int )sep) {
#line 304
      _E__pr_header("src/dict.c", 304L, "FATAL_ERROR");
#line 304
      _E__die_error("Bad compound word %s: leading or trailing separator\n", wordp->word);
    }
#line 307
    n = 1;
#line 308
    i = 1;
#line 308
    while (i < l - 1) {
#line 309
      if ((int )wd[i] == (int )sep) {
#line 310
        n ++;
      }
#line 308
      i ++;
    }
#line 311
    if (n == 1) {
#line 312
      goto __Cont;
    }
#line 313
    nc ++;
#line 315
    if (w___0 == d->startwid) {
#line 316
      _E__pr_header("src/dict.c", 316L, "FATAL_ERROR");
#line 316
      _E__die_error("Compound special/filler word (%s) not allowed\n", wordp->word);
    } else
#line 315
    if (w___0 == d->finishwid) {
#line 316
      _E__pr_header("src/dict.c", 316L, "FATAL_ERROR");
#line 316
      _E__die_error("Compound special/filler word (%s) not allowed\n", wordp->word);
    } else {
#line 315
      tmp___0 = dict_filler_word(d, w___0);
#line 315
      if (tmp___0) {
#line 316
        _E__pr_header("src/dict.c", 316L, "FATAL_ERROR");
#line 316
        _E__die_error("Compound special/filler word (%s) not allowed\n", wordp->word);
      }
    }
#line 319
    wordp->n_comp = n;
#line 320
    tmp___1 = __ckd_calloc__((size_t )n, sizeof(s3wid_t ), "src/dict.c", 320);
#line 320
    wordp->comp = (s3wid_t *)tmp___1;
#line 323
    n = 0;
#line 324
    i = 0;
#line 324
    while (i < l) {
#line 325
      j = i;
#line 325
      while (1) {
#line 325
        if (i < l) {
#line 325
          if (! ((int )wd[i] != (int )sep)) {
#line 325
            break;
          }
        } else {
#line 325
          break;
        }
#line 325
        i ++;
      }
#line 326
      if (j == i) {
#line 327
        _E__pr_header("src/dict.c", 327L, "FATAL_ERROR");
#line 327
        _E__die_error("Bad compound word %s: successive separators\n", wordp->word);
      }
#line 329
      wd[i] = (char )'\000';
#line 330
      cwid = dict_wordid(d, wd + j);
#line 331
      if (cwid < 0) {
#line 332
        _E__pr_header("src/dict.c", 332L, "FATAL_ERROR");
#line 332
        _E__die_error("Component word %s of %s not in dictionary\n", wd + j, wordp->word);
      }
#line 333
      *(wordp->comp + n) = cwid;
#line 334
      n ++;
#line 324
      i ++;
    }
    __Cont: /* CIL Label */ 
#line 299
    w___0 ++;
  }
#line 338
  if (nc > 0) {
#line 339
    d->comp_head = dict_comp_head(d);
  }
#line 341
  return (nc);
}
}
#line 345 "src/dict.c"
dict_t *dict_init(mdef_t *mdef , char *dictfile , char *fillerfile , char comp_sep ) 
{ 
  FILE *fp ;
  FILE *fp2 ;
  int32 n ;
  char line[1024] ;
  dict_t *d ;
  char *tmp ;
  char *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;

  {
#line 352
  if (! dictfile) {
#line 353
    _E__pr_header("src/dict.c", 353L, "FATAL_ERROR");
#line 353
    _E__die_error("No dictionary file\n");
  }
#line 360
  fp = fopen((char const   * __restrict  )dictfile, (char const   * __restrict  )"r");
#line 360
  if ((unsigned long )fp == (unsigned long )((void *)0)) {
#line 361
    _E__pr_header("src/dict.c", 361L, "SYSTEM_ERROR");
#line 361
    _E__fatal_sys_error("fopen(%s,r) failed\n", dictfile);
  }
#line 362
  n = 0;
#line 363
  while (1) {
#line 363
    tmp = fgets((char * __restrict  )(line), (int )sizeof(line), (FILE * __restrict  )fp);
#line 363
    if (! ((unsigned long )tmp != (unsigned long )((void *)0))) {
#line 363
      break;
    }
#line 364
    if ((int )line[0] != 35) {
#line 365
      n ++;
    }
  }
#line 367
  rewind(fp);
#line 369
  fp2 = (FILE *)((void *)0);
#line 370
  if (fillerfile) {
#line 371
    fp2 = fopen((char const   * __restrict  )fillerfile, (char const   * __restrict  )"r");
#line 371
    if ((unsigned long )fp2 == (unsigned long )((void *)0)) {
#line 372
      _E__pr_header("src/dict.c", 372L, "SYSTEM_ERROR");
#line 372
      _E__fatal_sys_error("fopen(%s,r) failed\n", fillerfile);
    }
#line 374
    while (1) {
#line 374
      tmp___0 = fgets((char * __restrict  )(line), (int )sizeof(line), (FILE * __restrict  )fp2);
#line 374
      if (! ((unsigned long )tmp___0 != (unsigned long )((void *)0))) {
#line 374
        break;
      }
#line 375
      if ((int )line[0] != 35) {
#line 376
        n ++;
      }
    }
#line 378
    rewind(fp2);
  }
#line 385
  tmp___1 = __ckd_calloc__((size_t )1, sizeof(dict_t ), "src/dict.c", 385);
#line 385
  d = (dict_t *)tmp___1;
#line 386
  if (n + 1024 < 2147483646) {
#line 386
    d->max_words = n + 1024;
  } else {
#line 386
    d->max_words = 2147483646;
  }
#line 387
  if (n >= 2147483646) {
#line 388
    _E__pr_header("src/dict.c", 388L, "FATAL_ERROR");
#line 388
    _E__die_error("#Words in dictionaries (%d) exceeds limit (%d)\n", n, 2147483646);
  }
#line 390
  tmp___2 = __ckd_calloc__((size_t )d->max_words, sizeof(dictword_t ), "src/dict.c",
                           390);
#line 390
  d->word = (dictword_t *)tmp___2;
#line 391
  d->n_word = 0;
#line 392
  d->mdef = mdef;
#line 393
  if (mdef) {
#line 394
    d->pht = (hash_table_t *)((void *)0);
#line 395
    d->ciphone_str = (char **)((void *)0);
  } else {
#line 397
    d->pht = hash_new(128, 1);
#line 398
    tmp___3 = __ckd_calloc__((size_t )128, sizeof(char *), "src/dict.c", 398);
#line 398
    d->ciphone_str = (char **)tmp___3;
  }
#line 400
  d->n_ciphone = 0;
#line 403
  d->ht = hash_new(d->max_words, 1);
#line 406
  d->comp_head = (s3wid_t *)((void *)0);
#line 409
  _E__pr_info_header("src/dict.c", 409L, "INFO");
#line 409
  _E__pr_info("Reading main dictionary: %s\n", dictfile);
#line 410
  dict_read(fp, d);
#line 411
  fclose(fp);
#line 412
  _E__pr_info_header("src/dict.c", 412L, "INFO");
#line 412
  _E__pr_info("%d words read\n", d->n_word);
#line 415
  d->filler_start = d->n_word;
#line 416
  if (fillerfile) {
#line 417
    _E__pr_info_header("src/dict.c", 417L, "INFO");
#line 417
    _E__pr_info("Reading filler dictionary: %s\n", fillerfile);
#line 418
    dict_read(fp2, d);
#line 419
    fclose(fp2);
#line 420
    _E__pr_info_header("src/dict.c", 420L, "INFO");
#line 420
    _E__pr_info("%d words read\n", d->n_word - d->filler_start);
  }
#line 422
  d->filler_end = d->n_word - 1;
#line 425
  d->startwid = dict_wordid(d, (char *)"<s>");
#line 426
  d->finishwid = dict_wordid(d, (char *)"</s>");
#line 427
  d->silwid = dict_wordid(d, (char *)"<sil>");
#line 438
  if (comp_sep) {
#line 439
    _E__pr_info_header("src/dict.c", 439L, "INFO");
#line 439
    _E__pr_info("Building compound words (separator = \'%c\')\n", (int )comp_sep);
#line 440
    n = dict_build_comp(d, comp_sep);
#line 441
    _E__pr_info_header("src/dict.c", 441L, "INFO");
#line 441
    _E__pr_info("%d compound words\n", n);
  }
#line 444
  return (d);
}
}
#line 448 "src/dict.c"
s3wid_t dict_wordid(dict_t *d , char *word ) 
{ 
  int32 w___0 ;
  int32 tmp ;

  {
#line 452
  if (! d) {
#line 452
    __assert_fail("d", "src/dict.c", 452U, "dict_wordid");
  }
#line 453
  if (! word) {
#line 453
    __assert_fail("word", "src/dict.c", 453U, "dict_wordid");
  }
#line 455
  tmp = hash_lookup(d->ht, (char const   *)word, & w___0);
#line 455
  if (tmp < 0) {
#line 456
    return (-1);
  }
#line 457
  return (w___0);
}
}
#line 461 "src/dict.c"
s3wid_t _dict_basewid(dict_t *d , s3wid_t w___0 ) 
{ 


  {
#line 463
  if (! d) {
#line 463
    __assert_fail("d", "src/dict.c", 463U, "_dict_basewid");
  }
#line 464
  if (w___0 >= 0) {
#line 464
    if (! (w___0 < d->n_word)) {
#line 464
      __assert_fail("(w >= 0) && (w < d->n_word)", "src/dict.c", 464U, "_dict_basewid");
    }
  } else {
#line 464
    __assert_fail("(w >= 0) && (w < d->n_word)", "src/dict.c", 464U, "_dict_basewid");
  }
#line 466
  return ((d->word + w___0)->basewid);
}
}
#line 470 "src/dict.c"
char *_dict_wordstr(dict_t *d , s3wid_t wid ) 
{ 


  {
#line 472
  if (! d) {
#line 472
    __assert_fail("d", "src/dict.c", 472U, "_dict_wordstr");
  }
#line 473
  if (wid >= 0) {
#line 473
    if (! (wid < d->n_word)) {
#line 473
      __assert_fail("((wid)>=0) && (wid < d->n_word)", "src/dict.c", 473U, "_dict_wordstr");
    }
  } else {
#line 473
    __assert_fail("((wid)>=0) && (wid < d->n_word)", "src/dict.c", 473U, "_dict_wordstr");
  }
#line 475
  return ((d->word + wid)->word);
}
}
#line 479 "src/dict.c"
s3wid_t _dict_nextalt(dict_t *d , s3wid_t wid ) 
{ 


  {
#line 481
  if (! d) {
#line 481
    __assert_fail("d", "src/dict.c", 481U, "_dict_nextalt");
  }
#line 482
  if (wid >= 0) {
#line 482
    if (! (wid < d->n_word)) {
#line 482
      __assert_fail("((wid)>=0) && (wid < d->n_word)", "src/dict.c", 482U, "_dict_nextalt");
    }
  } else {
#line 482
    __assert_fail("((wid)>=0) && (wid < d->n_word)", "src/dict.c", 482U, "_dict_nextalt");
  }
#line 484
  return ((d->word + wid)->alt);
}
}
#line 488 "src/dict.c"
int32 dict_filler_word(dict_t *d , s3wid_t w___0 ) 
{ 


  {
#line 490
  if (! d) {
#line 490
    __assert_fail("d", "src/dict.c", 490U, "dict_filler_word");
  }
#line 491
  if (w___0 >= 0) {
#line 491
    if (! (w___0 < d->n_word)) {
#line 491
      __assert_fail("(w >= 0) && (w < d->n_word)", "src/dict.c", 491U, "dict_filler_word");
    }
  } else {
#line 491
    __assert_fail("(w >= 0) && (w < d->n_word)", "src/dict.c", 491U, "dict_filler_word");
  }
#line 493
  w___0 = (d->word + w___0)->basewid;
#line 494
  if (w___0 == d->startwid) {
#line 495
    return (0);
  } else
#line 494
  if (w___0 == d->finishwid) {
#line 495
    return (0);
  }
#line 496
  if (w___0 >= d->filler_start) {
#line 496
    if (w___0 <= d->filler_end) {
#line 497
      return (1);
    }
  }
#line 498
  return (0);
}
}
#line 502 "src/dict.c"
s3wid_t dict_wids2compwid(dict_t *d , s3wid_t *wid , int32 len ) 
{ 
  s3wid_t w___0 ;
  int32 i ;

  {
#line 507
  if (! d->comp_head) {
#line 508
    return (-1);
  }
#line 510
  if (! (len > 1)) {
#line 510
    __assert_fail("len > 1", "src/dict.c", 510U, "dict_wids2compwid");
  }
#line 512
  w___0 = *(d->comp_head + *(wid + 0));
#line 512
  while (w___0 >= 0) {
#line 514
    if (! ((d->word + w___0)->n_comp > 1)) {
#line 514
      __assert_fail("d->word[w].n_comp > 1", "src/dict.c", 514U, "dict_wids2compwid");
    }
#line 515
    if (! (*((d->word + w___0)->comp + 0) == *(wid + 0))) {
#line 515
      __assert_fail("d->word[w].comp[0] == wid[0]", "src/dict.c", 515U, "dict_wids2compwid");
    }
#line 517
    if ((d->word + w___0)->n_comp == len) {
#line 518
      i = 0;
#line 518
      while (1) {
#line 518
        if (i < len) {
#line 518
          if (! (*((d->word + w___0)->comp + i) == *(wid + i))) {
#line 518
            break;
          }
        } else {
#line 518
          break;
        }
#line 518
        i ++;
      }
#line 519
      if (i == len) {
#line 520
        return ((d->word + w___0)->basewid);
      }
    }
#line 512
    w___0 = *(d->comp_head + w___0);
  }
#line 524
  return (-1);
}
}
#line 528 "src/dict.c"
int32 dict_word2basestr(char *word ) 
{ 
  int32 i ;
  int32 len ;
  size_t tmp ;

  {
#line 532
  tmp = strlen((char const   *)word);
#line 532
  len = (int32 )tmp;
#line 533
  if ((int )*(word + (len - 1)) == 41) {
#line 534
    i = len - 2;
#line 534
    while (1) {
#line 534
      if (i > 0) {
#line 534
        if (! ((int )*(word + i) != 40)) {
#line 534
          break;
        }
      } else {
#line 534
        break;
      }
#line 534
      i --;
    }
#line 536
    if (i > 0) {
#line 538
      *(word + i) = (char )'\000';
#line 539
      return (i);
    }
  }
#line 543
  return (-1);
}
}
#line 550 "src/dict.c"
void dict_free(dict_t *d ) 
{ 
  int i ;
  dictword_t *word ;

  {
#line 555
  if (d) {
#line 557
    i = 0;
#line 557
    while (i < d->n_word) {
#line 558
      word = d->word + i;
#line 559
      if (word->word) {
#line 560
        free((void *)word->word);
      }
#line 561
      if (word->ciphone) {
#line 562
        free((void *)word->ciphone);
      }
#line 563
      if (word->comp) {
#line 564
        free((void *)word->comp);
      }
#line 557
      i ++;
    }
#line 567
    if (d->word) {
#line 568
      free((void *)d->word);
    }
#line 569
    i = 0;
#line 569
    while (i < d->n_ciphone) {
#line 570
      if (*(d->ciphone_str + i)) {
#line 571
        free((void *)*(d->ciphone_str + i));
      }
#line 569
      i ++;
    }
#line 573
    if (d->comp_head) {
#line 574
      free((void *)d->comp_head);
    }
#line 575
    if (d->ciphone_str) {
#line 576
      free((void *)d->ciphone_str);
    }
#line 577
    if (d->pht) {
#line 578
      hash_free(d->pht);
    }
#line 579
    if (d->ht) {
#line 580
      hash_free(d->ht);
    }
#line 581
    free((void *)d);
  }
#line 583
  return;
}
}
#line 1 "dict2pid.o"
#pragma merger("0","/tmp/cil-iSMt6E8t.i","-g,-O4")
#line 150 "/usr/include/x86_64-linux-gnu/bits/mathinline.h"
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__, __always_inline__)) __signbitl)(long double __x )  __attribute__((__const__)) ;
#line 150 "/usr/include/x86_64-linux-gnu/bits/mathinline.h"
__inline extern int ( __attribute__((__leaf__, __always_inline__)) __signbitl)(long double __x ) 
{ 
  union __anonunion___u_29___7 __u ;

  {
#line 153
  __u.__l = __x;
#line 154
  return ((__u.__i[2] & 32768) != 0);
}
}
#line 176 "src/dict2pid.h"
dict2pid_t *dict2pid_build(mdef_t *mdef , dict_t *dict ) ;
#line 182
void dict2pid_comsenscr(dict2pid_t *d2p , int32 *senscr , int32 *comsenscr ) ;
#line 190
void dict2pid_comsseq2sen_active(dict2pid_t *d2p , mdef_t *mdef , int32 *comssid ,
                                 int32 *sen ) ;
#line 197
void dict2pid_dump(FILE *fp , dict2pid_t *d2p , mdef_t *mdef , dict_t *dict ) ;
#line 116 "src/dict2pid.c"
static glist_t ldiph_comsseq(mdef_t *mdef , int32 b , int32 r ) 
{ 
  int32 l ;
  int32 p ;
  int32 ssid ;
  glist_t g ;
  int32 tmp ;

  {
#line 121
  g = (glist_t )((void *)0);
#line 122
  l = 0;
#line 122
  while (l < mdef->n_ciphone) {
#line 123
    p = mdef_phone_id(mdef, (s3cipid_t )b, (s3cipid_t )l, (s3cipid_t )r, (word_posn_t )0);
#line 125
    if (p >= 0) {
#line 126
      ssid = (mdef->phone + p)->ssid;
#line 127
      tmp = glist_chkdup_int32(g, ssid);
#line 127
      if (! tmp) {
#line 128
        g = glist_add_int32(g, ssid);
      }
    }
#line 122
    l ++;
  }
#line 131
  if (! g) {
#line 132
    g = glist_add_int32(g, (mdef->phone + b)->ssid);
  }
#line 134
  return (g);
}
}
#line 143 "src/dict2pid.c"
static glist_t rdiph_comsseq(mdef_t *mdef , int32 b , int32 l ) 
{ 
  int32 r ;
  int32 p ;
  int32 ssid ;
  glist_t g ;
  int32 tmp ;

  {
#line 148
  g = (glist_t )((void *)0);
#line 149
  r = 0;
#line 149
  while (r < mdef->n_ciphone) {
#line 150
    p = mdef_phone_id(mdef, (s3cipid_t )b, (s3cipid_t )l, (s3cipid_t )r, (word_posn_t )1);
#line 152
    if (p >= 0) {
#line 153
      ssid = (mdef->phone + p)->ssid;
#line 154
      tmp = glist_chkdup_int32(g, ssid);
#line 154
      if (! tmp) {
#line 155
        g = glist_add_int32(g, ssid);
      }
    }
#line 149
    r ++;
  }
#line 158
  if (! g) {
#line 159
    g = glist_add_int32(g, (mdef->phone + b)->ssid);
  }
#line 161
  return (g);
}
}
#line 170 "src/dict2pid.c"
static glist_t single_comsseq(mdef_t *mdef , int32 b ) 
{ 
  int32 l ;
  int32 r ;
  int32 p ;
  int32 ssid ;
  glist_t g ;
  int32 tmp ;

  {
#line 175
  g = (glist_t )((void *)0);
#line 176
  l = 0;
#line 176
  while (l < mdef->n_ciphone) {
#line 177
    r = 0;
#line 177
    while (r < mdef->n_ciphone) {
#line 178
      p = mdef_phone_id(mdef, (s3cipid_t )b, (s3cipid_t )l, (s3cipid_t )r, (word_posn_t )2);
#line 180
      if (p >= 0) {
#line 181
        ssid = (mdef->phone + p)->ssid;
#line 182
        tmp = glist_chkdup_int32(g, ssid);
#line 182
        if (! tmp) {
#line 183
          g = glist_add_int32(g, ssid);
        }
      }
#line 177
      r ++;
    }
#line 176
    l ++;
  }
#line 187
  if (! g) {
#line 188
    g = glist_add_int32(g, (mdef->phone + b)->ssid);
  }
#line 190
  return (g);
}
}
#line 199 "src/dict2pid.c"
static glist_t single_lc_comsseq(mdef_t *mdef , int32 b , int32 l ) 
{ 
  int32 r ;
  int32 p ;
  int32 ssid ;
  glist_t g ;
  int32 tmp ;

  {
#line 204
  g = (glist_t )((void *)0);
#line 205
  r = 0;
#line 205
  while (r < mdef->n_ciphone) {
#line 206
    p = mdef_phone_id(mdef, (s3cipid_t )b, (s3cipid_t )l, (s3cipid_t )r, (word_posn_t )2);
#line 208
    if (p >= 0) {
#line 209
      ssid = (mdef->phone + p)->ssid;
#line 210
      tmp = glist_chkdup_int32(g, ssid);
#line 210
      if (! tmp) {
#line 211
        g = glist_add_int32(g, ssid);
      }
    }
#line 205
    r ++;
  }
#line 214
  if (! g) {
#line 215
    g = glist_add_int32(g, (mdef->phone + b)->ssid);
  }
#line 217
  return (g);
}
}
#line 224 "src/dict2pid.c"
static s3ssid_t ssidlist2comsseq(glist_t g , mdef_t *mdef , dict2pid_t *dict2pid ,
                                 hash_table_t *hs , hash_table_t *hp ) 
{ 
  int32 i ;
  int32 j ;
  int32 n ;
  int32 s___0 ;
  int32 ssid ;
  s3senid_t **sen ;
  s3senid_t *comsenid ;
  gnode_t *gn ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
#line 233
  n = glist_count(g);
#line 234
  if (n <= 0) {
#line 235
    _E__pr_header("src/dict2pid.c", 235L, "FATAL_ERROR");
#line 235
    _E__die_error("Panic: length(ssidlist)= %d\n", n);
  }
#line 238
  tmp = __ckd_calloc__((size_t )mdef->n_emit_state, sizeof(s3senid_t *), "src/dict2pid.c",
                       238);
#line 238
  sen = (s3senid_t **)tmp;
#line 239
  i = 0;
#line 239
  while (i < mdef->n_emit_state) {
#line 240
    tmp___0 = __ckd_calloc__((size_t )(n + 1), sizeof(s3senid_t ), "src/dict2pid.c",
                             240);
#line 240
    *(sen + i) = (s3senid_t *)tmp___0;
#line 241
    *(*(sen + i) + 0) = (s3senid_t )-1;
#line 239
    i ++;
  }
#line 244
  tmp___1 = __ckd_calloc__((size_t )mdef->n_emit_state, sizeof(s3senid_t ), "src/dict2pid.c",
                           244);
#line 244
  comsenid = (s3senid_t *)tmp___1;
#line 246
  gn = g;
#line 246
  while (gn) {
#line 247
    ssid = gn->data.int32;
#line 250
    i = 0;
#line 250
    while (i < mdef->n_emit_state) {
#line 251
      s___0 = (int32 )*(*(mdef->sseq + ssid) + i);
#line 253
      j = 0;
#line 253
      while (1) {
#line 253
        if ((int )*(*(sen + i) + j) >= 0) {
#line 253
          if (! ((int )*(*(sen + i) + j) != s___0)) {
#line 253
            break;
          }
        } else {
#line 253
          break;
        }
#line 253
        j ++;
      }
#line 254
      if ((int )*(*(sen + i) + j) < 0) {
#line 255
        *(*(sen + i) + j) = (s3senid_t )s___0;
#line 256
        *(*(sen + i) + (j + 1)) = (s3senid_t )-1;
      }
#line 250
      i ++;
    }
#line 246
    gn = gn->next;
  }
#line 262
  i = 0;
#line 262
  while (i < mdef->n_emit_state) {
#line 263
    j = 0;
#line 263
    while ((int )*(*(sen + i) + j) >= 0) {
#line 263
      j ++;
    }
#line 264
    if (! (j > 0)) {
#line 264
      __assert_fail("j > 0", "src/dict2pid.c", 264U, "ssidlist2comsseq");
    }
#line 266
    j = hash_enter_bkey(hs, (char const   *)((char *)*(sen + i)), (int32 )((unsigned long )j * sizeof(s3senid_t )),
                        dict2pid->n_comstate);
#line 267
    if (j == dict2pid->n_comstate) {
#line 268
      (dict2pid->n_comstate) ++;
    } else {
#line 270
      free((void *)*(sen + i));
    }
#line 272
    *(comsenid + i) = (s3senid_t )j;
#line 262
    i ++;
  }
#line 274
  free((void *)sen);
#line 277
  j = hash_enter_bkey(hp, (char const   *)((char *)comsenid), (int32 )((unsigned long )mdef->n_emit_state * sizeof(s3senid_t )),
                      dict2pid->n_comsseq);
#line 279
  if (j == dict2pid->n_comsseq) {
#line 280
    (dict2pid->n_comsseq) ++;
#line 281
    if (dict2pid->n_comsseq >= 32766) {
#line 282
      _E__pr_header("src/dict2pid.c", 282L, "FATAL_ERROR");
#line 282
      _E__die_error("#Composite sseq limit(%d) reached; increase MAX_S3SENID\n", dict2pid->n_comsseq);
    }
  } else {
#line 285
    free((void *)comsenid);
  }
#line 287
  return (j);
}
}
#line 292 "src/dict2pid.c"
dict2pid_t *dict2pid_build(mdef_t *mdef , dict_t *dict ) 
{ 
  dict2pid_t *dict2pid ;
  s3ssid_t *internal ;
  s3ssid_t **ldiph ;
  s3ssid_t **rdiph ;
  s3ssid_t *single ;
  int32 pronlen ;
  hash_table_t *hs ;
  hash_table_t *hp ;
  glist_t g ;
  gnode_t *gn ;
  s3senid_t *sen ;
  hash_entry_t *he ;
  int32 *cslen ;
  int32 i ;
  int32 j ;
  int32 b ;
  int32 l ;
  int32 r ;
  int32 w___0 ;
  int32 n ;
  int32 p ;
  void *tmp ;
  void *tmp___0 ;
  void ***tmp___1 ;
  void **tmp___2 ;
  void *tmp___3 ;
  void **tmp___4 ;
  void **tmp___5 ;
  void *tmp___6 ;
  void *tmp___7 ;
  void *tmp___8 ;
  void *tmp___9 ;
  void *tmp___10 ;
  void *tmp___11 ;
  int32 tmp___12 ;

  {
#line 305
  _E__pr_info_header("src/dict2pid.c", 305L, "INFO");
#line 305
  _E__pr_info("Building PID tables for dictionary\n");
#line 307
  tmp = __ckd_calloc__((size_t )1, sizeof(dict2pid_t ), "src/dict2pid.c", 307);
#line 307
  dict2pid = (dict2pid_t *)tmp;
#line 308
  tmp___0 = __ckd_calloc__((size_t )dict->n_word, sizeof(s3ssid_t *), "src/dict2pid.c",
                           308);
#line 308
  dict2pid->internal = (s3ssid_t **)tmp___0;
#line 309
  tmp___1 = __ckd_calloc_3d__(mdef->n_ciphone, mdef->n_ciphone, mdef->n_ciphone, (int32 )sizeof(s3ssid_t ),
                              "src/dict2pid.c", 312);
#line 309
  dict2pid->ldiph_lc = (s3ssid_t ***)tmp___1;
#line 313
  tmp___2 = __ckd_calloc_2d__(mdef->n_ciphone, mdef->n_ciphone, (int32 )sizeof(s3ssid_t ),
                              "src/dict2pid.c", 315);
#line 313
  dict2pid->single_lc = (s3ssid_t **)tmp___2;
#line 316
  dict2pid->n_comstate = 0;
#line 317
  dict2pid->n_comsseq = 0;
#line 319
  hs = hash_new((mdef->n_ciphone * mdef->n_ciphone) * mdef->n_emit_state, 0);
#line 320
  hp = hash_new(mdef->n_ciphone * mdef->n_ciphone, 0);
#line 322
  w___0 = 0;
#line 322
  n = 0;
#line 322
  while (w___0 < dict->n_word) {
#line 323
    pronlen = (dict->word + w___0)->pronlen;
#line 324
    if (pronlen < 0) {
#line 325
      _E__pr_header("src/dict2pid.c", 325L, "FATAL_ERROR");
#line 325
      _E__die_error("Pronunciation-length(%s)= %d\n", (dict->word + w___0)->word,
                    pronlen);
    }
#line 326
    n += pronlen;
#line 322
    w___0 ++;
  }
#line 329
  tmp___3 = __ckd_calloc__((size_t )n, sizeof(s3ssid_t ), "src/dict2pid.c", 329);
#line 329
  internal = (s3ssid_t *)tmp___3;
#line 332
  tmp___4 = __ckd_calloc_2d__(mdef->n_ciphone, mdef->n_ciphone, (int32 )sizeof(s3ssid_t ),
                              "src/dict2pid.c", 332);
#line 332
  ldiph = (s3ssid_t **)tmp___4;
#line 333
  tmp___5 = __ckd_calloc_2d__(mdef->n_ciphone, mdef->n_ciphone, (int32 )sizeof(s3ssid_t ),
                              "src/dict2pid.c", 333);
#line 333
  rdiph = (s3ssid_t **)tmp___5;
#line 334
  tmp___6 = __ckd_calloc__((size_t )mdef->n_ciphone, sizeof(s3ssid_t ), "src/dict2pid.c",
                           334);
#line 334
  single = (s3ssid_t *)tmp___6;
#line 335
  b = 0;
#line 335
  while (b < mdef->n_ciphone) {
#line 336
    l = 0;
#line 336
    while (l < mdef->n_ciphone) {
#line 337
      r = 0;
#line 337
      while (r < mdef->n_ciphone) {
#line 338
        *(*(*(dict2pid->ldiph_lc + b) + r) + l) = -1;
#line 337
        r ++;
      }
#line 340
      *(*(dict2pid->single_lc + b) + l) = -1;
#line 342
      *(*(ldiph + b) + l) = -1;
#line 343
      *(*(rdiph + b) + l) = -1;
#line 336
      l ++;
    }
#line 345
    *(single + b) = -1;
#line 335
    b ++;
  }
#line 348
  w___0 = 0;
#line 348
  while (w___0 < dict->n_word) {
#line 349
    *(dict2pid->internal + w___0) = internal;
#line 350
    pronlen = (dict->word + w___0)->pronlen;
#line 352
    if (pronlen >= 2) {
#line 353
      b = (int32 )*((dict->word + w___0)->ciphone + 0);
#line 354
      r = (int32 )*((dict->word + w___0)->ciphone + 1);
#line 355
      if (*(*(ldiph + b) + r) < 0) {
#line 356
        g = ldiph_comsseq(mdef, b, r);
#line 357
        *(*(ldiph + b) + r) = ssidlist2comsseq(g, mdef, dict2pid, hs, hp);
#line 358
        glist_free(g);
#line 360
        l = 0;
#line 360
        while (l < mdef->n_ciphone) {
#line 361
          p = mdef_phone_id_nearest(mdef, (s3cipid_t )b, (s3cipid_t )l, (s3cipid_t )r,
                                    (word_posn_t )0);
#line 362
          *(*(*(dict2pid->ldiph_lc + b) + r) + l) = (mdef->phone + p)->ssid;
#line 360
          l ++;
        }
      }
#line 365
      *(internal + 0) = *(*(ldiph + b) + r);
#line 367
      i = 1;
#line 367
      while (i < pronlen - 1) {
#line 368
        l = b;
#line 369
        b = r;
#line 370
        r = (int32 )*((dict->word + w___0)->ciphone + (i + 1));
#line 372
        p = mdef_phone_id_nearest(mdef, (s3cipid_t )b, (s3cipid_t )l, (s3cipid_t )r,
                                  (word_posn_t )3);
#line 373
        *(internal + i) = (mdef->phone + p)->ssid;
#line 367
        i ++;
      }
#line 376
      l = b;
#line 377
      b = r;
#line 378
      if (*(*(rdiph + b) + l) < 0) {
#line 379
        g = rdiph_comsseq(mdef, b, l);
#line 380
        *(*(rdiph + b) + l) = ssidlist2comsseq(g, mdef, dict2pid, hs, hp);
#line 381
        glist_free(g);
      }
#line 383
      *(internal + (pronlen - 1)) = *(*(rdiph + b) + l);
    } else
#line 384
    if (pronlen == 1) {
#line 385
      b = (int32 )*((dict->word + w___0)->ciphone + 0);
#line 386
      if (*(single + b) < 0) {
#line 387
        g = single_comsseq(mdef, b);
#line 388
        *(single + b) = ssidlist2comsseq(g, mdef, dict2pid, hs, hp);
#line 389
        glist_free(g);
#line 391
        l = 0;
#line 391
        while (l < mdef->n_ciphone) {
#line 392
          g = single_lc_comsseq(mdef, b, l);
#line 393
          *(*(dict2pid->single_lc + b) + l) = ssidlist2comsseq(g, mdef, dict2pid,
                                                               hs, hp);
#line 394
          glist_free(g);
#line 391
          l ++;
        }
      }
#line 397
      *(internal + 0) = *(single + b);
    }
#line 400
    internal += pronlen;
#line 348
    w___0 ++;
  }
#line 403
  ckd_free_2d((void **)ldiph);
#line 404
  ckd_free_2d((void **)rdiph);
#line 405
  free((void *)single);
#line 408
  tmp___7 = __ckd_calloc__((size_t )dict2pid->n_comstate, sizeof(int32 ), "src/dict2pid.c",
                           408);
#line 408
  cslen = (int32 *)tmp___7;
#line 409
  g = hash_tolist(hs, & n);
#line 410
  if (! (n == dict2pid->n_comstate)) {
#line 410
    __assert_fail("n == dict2pid->n_comstate", "src/dict2pid.c", 410U, "dict2pid_build");
  }
#line 411
  n = 0;
#line 412
  gn = g;
#line 412
  while (gn) {
#line 413
    he = (hash_entry_t *)gn->data.ptr;
#line 414
    sen = (s3senid_t *)he->key;
#line 415
    i = 0;
#line 415
    while ((int )*(sen + i) >= 0) {
#line 415
      i ++;
    }
#line 417
    *(cslen + he->val) = i + 1;
#line 419
    n += i + 1;
#line 412
    gn = gn->next;
  }
#line 421
  tmp___8 = __ckd_calloc__((size_t )dict2pid->n_comstate, sizeof(s3senid_t *), "src/dict2pid.c",
                           421);
#line 421
  dict2pid->comstate = (s3senid_t **)tmp___8;
#line 422
  tmp___9 = __ckd_calloc__((size_t )n, sizeof(s3senid_t ), "src/dict2pid.c", 422);
#line 422
  sen = (s3senid_t *)tmp___9;
#line 423
  i = 0;
#line 423
  while (i < dict2pid->n_comstate) {
#line 424
    *(dict2pid->comstate + i) = sen;
#line 425
    sen += *(cslen + i);
#line 423
    i ++;
  }
#line 429
  gn = g;
#line 429
  while (gn) {
#line 430
    he = (hash_entry_t *)gn->data.ptr;
#line 431
    sen = (s3senid_t *)he->key;
#line 432
    i = he->val;
#line 434
    j = 0;
#line 434
    while (j < *(cslen + i)) {
#line 435
      *(*(dict2pid->comstate + i) + j) = *(sen + j);
#line 434
      j ++;
    }
#line 436
    if (! ((int )*(sen + (j - 1)) == -1)) {
#line 436
      __assert_fail("sen[j-1] == ((s3senid_t) -1)", "src/dict2pid.c", 436U, "dict2pid_build");
    }
#line 438
    free((void *)sen);
#line 429
    gn = gn->next;
  }
#line 440
  free((void *)cslen);
#line 441
  glist_free(g);
#line 442
  hash_free(hs);
#line 445
  tmp___10 = __ckd_calloc__((size_t )dict2pid->n_comsseq, sizeof(s3senid_t *), "src/dict2pid.c",
                            445);
#line 445
  dict2pid->comsseq = (s3senid_t **)tmp___10;
#line 446
  g = hash_tolist(hp, & n);
#line 447
  if (! (n == dict2pid->n_comsseq)) {
#line 447
    __assert_fail("n == dict2pid->n_comsseq", "src/dict2pid.c", 447U, "dict2pid_build");
  }
#line 450
  gn = g;
#line 450
  while (gn) {
#line 451
    he = (hash_entry_t *)gn->data.ptr;
#line 452
    i = he->val;
#line 453
    *(dict2pid->comsseq + i) = (s3senid_t *)he->key;
#line 450
    gn = gn->next;
  }
#line 455
  glist_free(g);
#line 456
  hash_free(hp);
#line 459
  tmp___11 = __ckd_calloc__((size_t )dict2pid->n_comstate, sizeof(int32 ), "src/dict2pid.c",
                            459);
#line 459
  dict2pid->comwt = (int32 *)tmp___11;
#line 460
  i = 0;
#line 460
  while (i < dict2pid->n_comstate) {
#line 461
    sen = *(dict2pid->comstate + i);
#line 463
    j = 0;
#line 463
    while ((int )*(sen + j) >= 0) {
#line 463
      j ++;
    }
#line 469
    tmp___12 = logs3((float64 )j);
#line 469
    *(dict2pid->comwt + i) = - tmp___12;
#line 460
    i ++;
  }
#line 473
  _E__pr_info_header("src/dict2pid.c", 473L, "INFO");
#line 473
  _E__pr_info("%d composite states; %d composite sseq\n", dict2pid->n_comstate, dict2pid->n_comsseq);
#line 476
  return (dict2pid);
}
}
#line 480 "src/dict2pid.c"
void dict2pid_comsenscr(dict2pid_t *d2p , int32 *senscr , int32 *comsenscr ) 
{ 
  int32 i ;
  int32 j ;
  int32 best ;
  s3senid_t *comstate ;
  s3senid_t k___0 ;

  {
#line 486
  i = 0;
#line 486
  while (i < d2p->n_comstate) {
#line 487
    comstate = *(d2p->comstate + i);
#line 489
    best = *(senscr + *(comstate + 0));
#line 490
    j = 1;
#line 490
    while (1) {
#line 491
      k___0 = *(comstate + j);
#line 492
      if ((int )k___0 < 0) {
#line 493
        break;
      }
#line 494
      if (best < *(senscr + k___0)) {
#line 495
        best = *(senscr + k___0);
      }
#line 490
      j ++;
    }
#line 498
    *(comsenscr + i) = best + *(d2p->comwt + i);
#line 486
    i ++;
  }
#line 500
  return;
}
}
#line 503 "src/dict2pid.c"
void dict2pid_comsseq2sen_active(dict2pid_t *d2p , mdef_t *mdef , int32 *comssid ,
                                 int32 *sen ) 
{ 
  int32 ss ;
  int32 cs ;
  int32 i ;
  int32 j ;
  s3senid_t *csp ;
  s3senid_t *sp ;

  {
#line 508
  ss = 0;
#line 508
  while (ss < d2p->n_comsseq) {
#line 509
    if (*(comssid + ss)) {
#line 510
      csp = *(d2p->comsseq + ss);
#line 512
      i = 0;
#line 512
      while (i < mdef->n_emit_state) {
#line 513
        cs = (int32 )*(csp + i);
#line 514
        sp = *(d2p->comstate + cs);
#line 516
        j = 0;
#line 516
        while ((int )*(sp + j) >= 0) {
#line 517
          *(sen + *(sp + j)) = 1;
#line 516
          j ++;
        }
#line 512
        i ++;
      }
    }
#line 508
    ss ++;
  }
#line 521
  return;
}
}
#line 524 "src/dict2pid.c"
void dict2pid_dump(FILE *fp , dict2pid_t *d2p , mdef_t *mdef , dict_t *dict ) 
{ 
  int32 w___0 ;
  int32 p ;
  int32 pronlen ;
  int32 i ;
  int32 j ;
  int32 b ;
  int32 l ;
  int32 r ;
  char const   *tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;
  char const   *tmp___3 ;

  {
#line 529
  fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"# INTERNAL (wd comssid ssid ssid ... ssid comssid)\n");
#line 530
  w___0 = 0;
#line 530
  while (w___0 < dict->n_word) {
#line 531
    fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"%30s ", (dict->word + w___0)->word);
#line 533
    pronlen = (dict->word + w___0)->pronlen;
#line 534
    p = 0;
#line 534
    while (p < pronlen) {
#line 535
      fprintf((FILE * __restrict  )fp, (char const   * __restrict  )" %5d", *(*(d2p->internal + w___0) + p));
#line 534
      p ++;
    }
#line 536
    fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"\n");
#line 530
    w___0 ++;
  }
#line 538
  fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"#\n");
#line 540
  fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"# LDIPH_LC (b r l ssid)\n");
#line 541
  b = 0;
#line 541
  while (b < mdef->n_ciphone) {
#line 542
    r = 0;
#line 542
    while (r < mdef->n_ciphone) {
#line 543
      l = 0;
#line 543
      while (l < mdef->n_ciphone) {
#line 544
        if (*(*(*(d2p->ldiph_lc + b) + r) + l) >= 0) {
#line 545
          tmp = mdef_ciphone_str(mdef, (s3cipid_t )l);
#line 545
          tmp___0 = mdef_ciphone_str(mdef, (s3cipid_t )r);
#line 545
          tmp___1 = mdef_ciphone_str(mdef, (s3cipid_t )b);
#line 545
          fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"%6s %6s %6s %5d\n",
                  tmp___1, tmp___0, tmp, *(*(*(d2p->ldiph_lc + b) + r) + l));
        }
#line 543
        l ++;
      }
#line 542
      r ++;
    }
#line 541
    b ++;
  }
#line 553
  fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"#\n");
#line 555
  fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"# SINGLE_LC (b l comssid)\n");
#line 556
  b = 0;
#line 556
  while (b < mdef->n_ciphone) {
#line 557
    l = 0;
#line 557
    while (l < mdef->n_ciphone) {
#line 558
      if (*(*(d2p->single_lc + b) + l) >= 0) {
#line 559
        tmp___2 = mdef_ciphone_str(mdef, (s3cipid_t )l);
#line 559
        tmp___3 = mdef_ciphone_str(mdef, (s3cipid_t )b);
#line 559
        fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"%6s %6s %5d\n",
                tmp___3, tmp___2, *(*(d2p->single_lc + b) + l));
      }
#line 557
      l ++;
    }
#line 556
    b ++;
  }
#line 565
  fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"#\n");
#line 567
  fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"# SSEQ %d (senid senid ...)\n",
          mdef->n_sseq);
#line 568
  i = 0;
#line 568
  while (i < mdef->n_sseq) {
#line 569
    fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"%5d ", i);
#line 570
    j = 0;
#line 570
    while (j < mdef->n_emit_state) {
#line 571
      fprintf((FILE * __restrict  )fp, (char const   * __restrict  )" %5d", (int )*(*(mdef->sseq + i) + j));
#line 570
      j ++;
    }
#line 572
    fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"\n");
#line 568
    i ++;
  }
#line 574
  fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"#\n");
#line 576
  fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"# COMSSEQ %d (comstate comstate ...)\n",
          d2p->n_comsseq);
#line 577
  i = 0;
#line 577
  while (i < d2p->n_comsseq) {
#line 578
    fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"%5d ", i);
#line 579
    j = 0;
#line 579
    while (j < mdef->n_emit_state) {
#line 580
      fprintf((FILE * __restrict  )fp, (char const   * __restrict  )" %5d", (int )*(*(d2p->comsseq + i) + j));
#line 579
      j ++;
    }
#line 581
    fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"\n");
#line 577
    i ++;
  }
#line 583
  fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"#\n");
#line 585
  fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"# COMSTATE %d (senid senid ...)\n",
          d2p->n_comstate);
#line 586
  i = 0;
#line 586
  while (i < d2p->n_comstate) {
#line 587
    fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"%5d ", i);
#line 588
    j = 0;
#line 588
    while ((int )*(*(d2p->comstate + i) + j) >= 0) {
#line 589
      fprintf((FILE * __restrict  )fp, (char const   * __restrict  )" %5d", (int )*(*(d2p->comstate + i) + j));
#line 588
      j ++;
    }
#line 590
    fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"\n");
#line 586
    i ++;
  }
#line 592
  fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"#\n");
#line 593
  fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"# END\n");
#line 595
  fflush(fp);
#line 596
  return;
}
}
#line 1 "fillpen.o"
#pragma merger("0","/tmp/cil-Cd1sPi0u.i","-g,-O4")
#line 150 "/usr/include/x86_64-linux-gnu/bits/mathinline.h"
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__, __always_inline__)) __signbitl)(long double __x )  __attribute__((__const__)) ;
#line 150 "/usr/include/x86_64-linux-gnu/bits/mathinline.h"
__inline extern int ( __attribute__((__leaf__, __always_inline__)) __signbitl)(long double __x ) 
{ 
  union __anonunion___u_29___8 __u ;

  {
#line 153
  __u.__l = __x;
#line 154
  return ((__u.__i[2] & 32768) != 0);
}
}
#line 135 "src/fillpen.h"
fillpen_t *fillpen_init(dict_t *dict , char *file , float64 silprob , float64 fillprob ,
                        float64 lw , float64 wip ) ;
#line 146
int32 fillpen(fillpen_t *f , s3wid_t w___0 ) ;
#line 152
void fillpen_free(fillpen_t *f ) ;
#line 119 "src/fillpen.c"
fillpen_t *fillpen_init(dict_t *dict , char *file , float64 silprob , float64 fillprob ,
                        float64 lw , float64 wip ) 
{ 
  s3wid_t w___0 ;
  s3wid_t bw ;
  float64 prob ;
  FILE *fp ;
  char line[1024] ;
  char wd[1024] ;
  int32 k___0 ;
  fillpen_t *_fillpen ;
  void *tmp ;
  void *tmp___0 ;
  int32 tmp___1 ;
  int32 tmp___2 ;
  int32 tmp___3 ;
  int32 tmp___4 ;
  int32 tmp___5 ;
  int32 tmp___6 ;
  char *tmp___7 ;

  {
#line 129
  tmp = __ckd_calloc__((size_t )1, sizeof(fillpen_t ), "src/fillpen.c", 129);
#line 129
  _fillpen = (fillpen_t *)tmp;
#line 131
  _fillpen->dict = dict;
#line 132
  _fillpen->lw = lw;
#line 133
  _fillpen->wip = wip;
#line 134
  if (dict->filler_end >= dict->filler_start) {
#line 135
    tmp___0 = __ckd_calloc__((size_t )((dict->filler_end - dict->filler_start) + 1),
                             sizeof(int32 ), "src/fillpen.c", 136);
#line 135
    _fillpen->prob = (int32 *)tmp___0;
  } else {
#line 138
    _fillpen->prob = (int32 *)((void *)0);
  }
#line 141
  prob = fillprob;
#line 142
  w___0 = dict->filler_start;
#line 142
  while (w___0 <= dict->filler_end) {
#line 146
    tmp___1 = logs3(prob);
#line 146
    tmp___2 = logs3(wip);
#line 146
    *(_fillpen->prob + (w___0 - dict->filler_start)) = (int32 )((float64 )tmp___1 * lw + (float64 )tmp___2);
#line 142
    w___0 ++;
  }
#line 149
  w___0 = dict_wordid(dict, (char *)"<sil>");
#line 150
  if (w___0 < 0) {
#line 151
    _E__pr_header("src/fillpen.c", 151L, "FATAL_ERROR");
#line 151
    _E__die_error("%s not a filler word in the given dictionary\n", "<sil>");
  } else
#line 150
  if (w___0 < dict->filler_start) {
#line 151
    _E__pr_header("src/fillpen.c", 151L, "FATAL_ERROR");
#line 151
    _E__die_error("%s not a filler word in the given dictionary\n", "<sil>");
  } else
#line 150
  if (w___0 > dict->filler_end) {
#line 151
    _E__pr_header("src/fillpen.c", 151L, "FATAL_ERROR");
#line 151
    _E__die_error("%s not a filler word in the given dictionary\n", "<sil>");
  }
#line 152
  prob = silprob;
#line 156
  tmp___3 = logs3(prob);
#line 156
  tmp___4 = logs3(wip);
#line 156
  *(_fillpen->prob + (w___0 - dict->filler_start)) = (int32 )((float64 )tmp___3 * lw + (float64 )tmp___4);
#line 159
  if (! file) {
#line 160
    return (_fillpen);
  }
#line 162
  _E__pr_info_header("src/fillpen.c", 162L, "INFO");
#line 162
  _E__pr_info("Reading filler penalty file: %s\n", file);
#line 163
  fp = fopen((char const   * __restrict  )file, (char const   * __restrict  )"r");
#line 163
  if ((unsigned long )fp == (unsigned long )((void *)0)) {
#line 164
    _E__pr_header("src/fillpen.c", 164L, "FATAL_ERROR");
#line 164
    _E__die_error("fopen(%s,r) failed\n", file);
  }
#line 165
  while (1) {
#line 165
    tmp___7 = fgets((char * __restrict  )(line), (int )sizeof(line), (FILE * __restrict  )fp);
#line 165
    if (! ((unsigned long )tmp___7 != (unsigned long )((void *)0))) {
#line 165
      break;
    }
#line 166
    if ((int )line[0] == 35) {
#line 167
      continue;
    }
#line 169
    k___0 = sscanf((char const   * __restrict  )(line), (char const   * __restrict  )"%s %lf",
                   wd, & prob);
#line 170
    if (k___0 != 0) {
#line 170
      if (k___0 != 2) {
#line 171
        _E__pr_header("src/fillpen.c", 171L, "FATAL_ERROR");
#line 171
        _E__die_error("Bad input line: %s\n", line);
      }
    }
#line 172
    w___0 = dict_wordid(dict, wd);
#line 173
    if (w___0 < 0) {
#line 174
      _E__pr_header("src/fillpen.c", 174L, "FATAL_ERROR");
#line 174
      _E__die_error("%s not a filler word in the given dictionary\n", "<sil>");
    } else
#line 173
    if (w___0 < dict->filler_start) {
#line 174
      _E__pr_header("src/fillpen.c", 174L, "FATAL_ERROR");
#line 174
      _E__die_error("%s not a filler word in the given dictionary\n", "<sil>");
    } else
#line 173
    if (w___0 > dict->filler_end) {
#line 174
      _E__pr_header("src/fillpen.c", 174L, "FATAL_ERROR");
#line 174
      _E__die_error("%s not a filler word in the given dictionary\n", "<sil>");
    }
#line 179
    tmp___5 = logs3(prob);
#line 179
    tmp___6 = logs3(wip);
#line 179
    *(_fillpen->prob + (w___0 - dict->filler_start)) = (int32 )((float64 )tmp___5 * lw + (float64 )tmp___6);
  }
#line 181
  fclose(fp);
#line 184
  w___0 = dict->filler_start;
#line 184
  while (w___0 <= dict->filler_end) {
#line 185
    bw = (dict->word + w___0)->basewid;
#line 186
    if (bw != w___0) {
#line 187
      *(_fillpen->prob + (w___0 - dict->filler_start)) = *(_fillpen->prob + (bw - dict->filler_start));
    }
#line 184
    w___0 ++;
  }
#line 190
  return (_fillpen);
}
}
#line 194 "src/fillpen.c"
int32 fillpen(fillpen_t *f , s3wid_t w___0 ) 
{ 


  {
#line 196
  if (w___0 >= (f->dict)->filler_start) {
#line 196
    if (! (w___0 <= (f->dict)->filler_end)) {
#line 196
      __assert_fail("(w >= f->dict->filler_start) && (w <= f->dict->filler_end)",
                    "src/fillpen.c", 196U, "fillpen");
    }
  } else {
#line 196
    __assert_fail("(w >= f->dict->filler_start) && (w <= f->dict->filler_end)", "src/fillpen.c",
                  196U, "fillpen");
  }
#line 197
  return (*(f->prob + (w___0 - (f->dict)->filler_start)));
}
}
#line 202 "src/fillpen.c"
void fillpen_free(fillpen_t *f ) 
{ 


  {
#line 204
  if (f) {
#line 205
    if (f->prob) {
#line 206
      free((void *)f->prob);
    }
#line 207
    free((void *)f);
  }
#line 209
  return;
}
}
#line 1 "lm.o"
#pragma merger("0","/tmp/cil-WwQg_V5t.i","-g,-O4")
#line 749 "/usr/include/stdio.h"
extern int fseek(FILE *__stream , long __off , int __whence ) ;
#line 754
extern long ( __attribute__((__warn_unused_result__)) ftell)(FILE *__stream ) ;
#line 150 "/usr/include/x86_64-linux-gnu/bits/mathinline.h"
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__, __always_inline__)) __signbitl)(long double __x )  __attribute__((__const__)) ;
#line 150 "/usr/include/x86_64-linux-gnu/bits/mathinline.h"
__inline extern int ( __attribute__((__leaf__, __always_inline__)) __signbitl)(long double __x ) 
{ 
  union __anonunion___u_29___9 __u ;

  {
#line 153
  __u.__l = __x;
#line 154
  return ((__u.__i[2] & 32768) != 0);
}
}
#line 291 "src/lm.h"
lm_t *lm_read(char *file , float64 lw , float64 wip , float64 uw ) ;
#line 300
int32 lm_tglist(lm_t *lm , s3lmwid_t lw1 , s3lmwid_t lw2 , tg_t **tgptr , int32 *bowt ) ;
#line 310
int32 lm_bglist(lm_t *lm , s3lmwid_t w1 , bg_t **bgptr , int32 *bowt ) ;
#line 322
int32 lm_bg_wordprob(lm_t *lm , s3lmwid_t lwid , int32 th , wordprob_t *wp , int32 *bowt ) ;
#line 333
int32 lm_ug_wordprob(lm_t *lm , int32 th , wordprob_t *wp ) ;
#line 338
int32 lm_uglist(lm_t *lm , ug_t **ugptr ) ;
#line 343
int32 lm_ug_score(lm_t *lm , s3lmwid_t wid ) ;
#line 350
int32 lm_bg_score(lm_t *lm , s3lmwid_t w1 , s3lmwid_t w2 ) ;
#line 357
int32 lm_tg_score(lm_t *lm , s3lmwid_t lw1 , s3lmwid_t lw2 , s3lmwid_t lw3 ) ;
#line 364
void lm_set_param(lm_t *lm , float64 lw , float64 wip ) ;
#line 368
s3lmwid_t lm_wid(lm_t *lm , char *word ) ;
#line 372
void lm_cache_reset(lm_t *lm ) ;
#line 373
void lm_cache_stats_dump(lm_t *lm ) ;
#line 376
void lm_free(lm_t *lm ) ;
#line 129 "src/lm.c"
static char *darpa_hdr  =    (char *)"Darpa Trigram LM";
#line 130 "src/lm.c"
static int LM_IN_MEMORY  =    0;
#line 194 "src/lm.c"
static void lm_uw(lm_t *lm , float64 uw ) 
{ 
  int32 i ;
  int32 loguw ;
  int32 loguw_ ;
  int32 loguniform ;
  int32 p1 ;
  int32 p2 ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___0 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
#line 199
  loguw = logs3(uw);
#line 200
  loguw_ = logs3(1.0 - uw);
#line 201
  loguniform = logs3(1.0 / (double )(lm->n_ug - 1));
#line 203
  i = 0;
#line 203
  while (i < lm->n_ug) {
#line 204
    if (0) {
#line 204
      __s1_len = __builtin_strlen((char const   *)*(lm->wordstr + i));
#line 204
      __s2_len = __builtin_strlen("<s>");
#line 204
      if (! ((size_t )((void const   *)(*(lm->wordstr + i) + 1)) - (size_t )((void const   *)*(lm->wordstr + i)) == 1UL)) {
#line 204
        goto _L___0;
      } else
#line 204
      if (__s1_len >= 4UL) {
        _L___0: /* CIL Label */ 
#line 204
        if (! ((size_t )((void const   *)("<s>" + 1)) - (size_t )((void const   *)"<s>") == 1UL)) {
#line 204
          tmp___5 = 1;
        } else
#line 204
        if (__s2_len >= 4UL) {
#line 204
          tmp___5 = 1;
        } else {
#line 204
          tmp___5 = 0;
        }
      } else {
#line 204
        tmp___5 = 0;
      }
#line 204
      if (tmp___5) {
#line 204
        tmp___0 = __builtin_strcmp((char const   *)*(lm->wordstr + i), "<s>");
#line 204
        tmp___4 = tmp___0;
      } else {
#line 204
        tmp___3 = __builtin_strcmp((char const   *)*(lm->wordstr + i), "<s>");
#line 204
        tmp___4 = tmp___3;
      }
    } else {
#line 204
      tmp___3 = __builtin_strcmp((char const   *)*(lm->wordstr + i), "<s>");
#line 204
      tmp___4 = tmp___3;
    }
#line 204
    if (tmp___4 != 0) {
#line 205
      p1 = (lm->ug + i)->prob.l + loguw;
#line 206
      p2 = loguniform + loguw_;
#line 207
      (lm->ug + i)->prob.l = logs3_add(p1, p2);
    }
#line 203
    i ++;
  }
#line 210
  return;
}
}
#line 213 "src/lm.c"
static void lm2logs3(lm_t *lm , float64 uw ) 
{ 
  int32 i ;

  {
#line 217
  i = 0;
#line 217
  while (i < lm->n_ug) {
#line 218
    (lm->ug + i)->prob.l = log10_to_logs3((float64 )(lm->ug + i)->prob.f);
#line 219
    (lm->ug + i)->bowt.l = log10_to_logs3((float64 )(lm->ug + i)->bowt.f);
#line 217
    i ++;
  }
#line 222
  lm_uw(lm, uw);
#line 224
  i = 0;
#line 224
  while (i < lm->n_bgprob) {
#line 225
    (lm->bgprob + i)->l = log10_to_logs3((float64 )(lm->bgprob + i)->f);
#line 224
    i ++;
  }
#line 227
  if (lm->n_tg > 0) {
#line 228
    i = 0;
#line 228
    while (i < lm->n_tgprob) {
#line 229
      (lm->tgprob + i)->l = log10_to_logs3((float64 )(lm->tgprob + i)->f);
#line 228
      i ++;
    }
#line 230
    i = 0;
#line 230
    while (i < lm->n_tgbowt) {
#line 231
      (lm->tgbowt + i)->l = log10_to_logs3((float64 )(lm->tgbowt + i)->f);
#line 230
      i ++;
    }
  }
#line 233
  return;
}
}
#line 236 "src/lm.c"
void lm_set_param(lm_t *lm , float64 lw , float64 wip ) 
{ 
  int32 i ;
  int32 iwip ;
  float64 f ;

  {
#line 241
  if (lw <= 0.0) {
#line 242
    _E__pr_header("src/lm.c", 242L, "FATAL_ERROR");
#line 242
    _E__die_error("lw = %e\n", lw);
  }
#line 243
  if (wip <= 0.0) {
#line 244
    _E__pr_header("src/lm.c", 244L, "FATAL_ERROR");
#line 244
    _E__die_error("wip = %e\n", wip);
  }
#line 248
  iwip = logs3(wip);
#line 250
  f = lw / (float64 )lm->lw;
#line 252
  i = 0;
#line 252
  while (i < lm->n_ug) {
#line 253
    (lm->ug + i)->prob.l = (int32 )((float64 )((lm->ug + i)->prob.l - lm->wip) * f) + iwip;
#line 254
    (lm->ug + i)->bowt.l = (int32 )((float64 )(lm->ug + i)->bowt.l * f);
#line 252
    i ++;
  }
#line 257
  i = 0;
#line 257
  while (i < lm->n_bgprob) {
#line 258
    (lm->bgprob + i)->l = (int32 )((float64 )((lm->bgprob + i)->l - lm->wip) * f) + iwip;
#line 257
    i ++;
  }
#line 260
  if (lm->n_tg > 0) {
#line 261
    i = 0;
#line 261
    while (i < lm->n_tgprob) {
#line 262
      (lm->tgprob + i)->l = (int32 )((float64 )((lm->tgprob + i)->l - lm->wip) * f) + iwip;
#line 261
      i ++;
    }
#line 263
    i = 0;
#line 263
    while (i < lm->n_tgbowt) {
#line 264
      (lm->tgbowt + i)->l = (int32 )((float64 )(lm->tgbowt + i)->l * f);
#line 263
      i ++;
    }
  }
#line 267
  lm->lw = (float32 )lw;
#line 268
  lm->wip = iwip;
#line 269
  return;
}
}
#line 272 "src/lm.c"
static int32 lm_fread_int32(lm_t *lm ) 
{ 
  int32 val ;
  size_t tmp ;

  {
#line 276
  tmp = fread((void * __restrict  )(& val), sizeof(int32 ), (size_t )1, (FILE * __restrict  )lm->fp);
#line 276
  if (tmp != 1UL) {
#line 277
    _E__pr_header("src/lm.c", 277L, "FATAL_ERROR");
#line 277
    _E__die_error("fread failed\n");
  }
#line 278
  if (lm->byteswap) {
#line 279
    val = (int32 )((unsigned int )(((255 & (val >> 24)) | (65280 & (val >> 8))) | (16711680 & (val << 8))) | (4278190080U & (unsigned int )(val << 24)));
  }
#line 280
  return (val);
}
}
#line 288 "src/lm.c"
static lm_t *lm_read_dump(char *file , float64 lw , float64 wip , float64 uw ) 
{ 
  lm_t *lm ;
  int32 i ;
  int32 j ;
  int32 k___0 ;
  int32 vn ;
  char str[1024] ;
  char *tmp_word_str ;
  s3lmwid_t startwid ;
  s3lmwid_t endwid ;
  void *tmp ;
  FILE *tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___8 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  size_t tmp___18 ;
  size_t tmp___19 ;
  void *tmp___20 ;
  size_t tmp___21 ;
  void *tmp___22 ;
  void *tmp___23 ;
  long tmp___24 ;
  void *tmp___25 ;
  long tmp___26 ;
  void *tmp___27 ;
  long tmp___28 ;
  void *tmp___29 ;
  long tmp___30 ;
  void *tmp___31 ;
  void *tmp___32 ;
  size_t tmp___33 ;
  void *tmp___34 ;
  size_t tmp___35 ;
  void *tmp___36 ;
  size_t tmp___37 ;
  void *tmp___38 ;
  size_t tmp___39 ;
  void *tmp___40 ;
  size_t tmp___41 ;
  void *tmp___42 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___44 ;
  int tmp___47 ;
  int tmp___48 ;
  int tmp___49 ;
  size_t __s1_len___1 ;
  size_t __s2_len___1 ;
  int tmp___51 ;
  int tmp___54 ;
  int tmp___55 ;
  int tmp___56 ;
  char *tmp___57 ;
  size_t tmp___58 ;

  {
#line 296
  tmp = __ckd_calloc__((size_t )1, sizeof(lm_t ), "src/lm.c", 296);
#line 296
  lm = (lm_t *)tmp;
#line 298
  tmp___0 = fopen((char const   * __restrict  )file, (char const   * __restrict  )"rb");
#line 298
  lm->fp = tmp___0;
#line 298
  if ((unsigned long )tmp___0 == (unsigned long )((void *)0)) {
#line 299
    _E__pr_header("src/lm.c", 299L, "SYSTEM_ERROR");
#line 299
    _E__fatal_sys_error("fopen(%s,rb) failed\n", file);
  }
#line 302
  tmp___1 = fread((void * __restrict  )(& k___0), sizeof(int32 ), (size_t )1, (FILE * __restrict  )lm->fp);
#line 302
  if (tmp___1 != 1UL) {
#line 303
    _E__pr_header("src/lm.c", 303L, "FATAL_ERROR");
#line 303
    _E__die_error("fread(%s) failed\n", file);
  }
#line 304
  tmp___3 = strlen((char const   *)darpa_hdr);
#line 304
  if ((size_t )k___0 == tmp___3 + 1UL) {
#line 305
    lm->byteswap = 0;
  } else {
#line 307
    k___0 = (int32 )((unsigned int )(((255 & (k___0 >> 24)) | (65280 & (k___0 >> 8))) | (16711680 & (k___0 << 8))) | (4278190080U & (unsigned int )(k___0 << 24)));
#line 308
    tmp___2 = strlen((char const   *)darpa_hdr);
#line 308
    if ((size_t )k___0 == tmp___2 + 1UL) {
#line 309
      lm->byteswap = 1;
    } else {
#line 311
      k___0 = (int32 )((unsigned int )(((255 & (k___0 >> 24)) | (65280 & (k___0 >> 8))) | (16711680 & (k___0 << 8))) | (4278190080U & (unsigned int )(k___0 << 24)));
#line 312
      _E__pr_header("src/lm.c", 312L, "FATAL_ERROR");
#line 312
      _E__die_error("Bad magic number: %d(%08x), not an LM dumpfile??\n", k___0, k___0);
    }
  }
#line 317
  tmp___4 = fread((void * __restrict  )(str), sizeof(char ), (size_t )k___0, (FILE * __restrict  )lm->fp);
#line 317
  if (tmp___4 != (size_t )k___0) {
#line 318
    _E__pr_header("src/lm.c", 318L, "FATAL_ERROR");
#line 318
    _E__die_error("fread(%s) failed\n", file);
  }
#line 319
  if (0) {
#line 319
    if (0) {
#line 319
      __s1_len = __builtin_strlen((char const   *)(str));
#line 319
      __s2_len = __builtin_strlen((char const   *)darpa_hdr);
#line 319
      if (! ((size_t )((void const   *)(str + 1)) - (size_t )((void const   *)(str)) == 1UL)) {
#line 319
        goto _L___0;
      } else
#line 319
      if (__s1_len >= 4UL) {
        _L___0: /* CIL Label */ 
#line 319
        if (! ((size_t )((void const   *)(darpa_hdr + 1)) - (size_t )((void const   *)darpa_hdr) == 1UL)) {
#line 319
          tmp___13 = 1;
        } else
#line 319
        if (__s2_len >= 4UL) {
#line 319
          tmp___13 = 1;
        } else {
#line 319
          tmp___13 = 0;
        }
      } else {
#line 319
        tmp___13 = 0;
      }
#line 319
      if (tmp___13) {
#line 319
        tmp___8 = __builtin_strcmp((char const   *)(str), (char const   *)darpa_hdr);
#line 319
        tmp___12 = tmp___8;
      } else {
#line 319
        tmp___11 = __builtin_strcmp((char const   *)(str), (char const   *)darpa_hdr);
#line 319
        tmp___12 = tmp___11;
      }
    } else {
#line 319
      tmp___11 = __builtin_strcmp((char const   *)(str), (char const   *)darpa_hdr);
#line 319
      tmp___12 = tmp___11;
    }
#line 319
    tmp___15 = tmp___12;
  } else {
#line 319
    tmp___14 = strncmp((char const   *)(str), (char const   *)darpa_hdr, (size_t )k___0);
#line 319
    tmp___15 = tmp___14;
  }
#line 319
  if (tmp___15 != 0) {
#line 320
    _E__pr_header("src/lm.c", 320L, "FATAL_ERROR");
#line 320
    _E__die_error("Bad header\n");
  }
#line 323
  k___0 = lm_fread_int32(lm);
#line 324
  if (k___0 < 1) {
#line 325
    _E__pr_header("src/lm.c", 325L, "FATAL_ERROR");
#line 325
    _E__die_error("Bad original filename size: %d\n", k___0);
  } else
#line 324
  if (k___0 > 1024) {
#line 325
    _E__pr_header("src/lm.c", 325L, "FATAL_ERROR");
#line 325
    _E__die_error("Bad original filename size: %d\n", k___0);
  }
#line 326
  tmp___18 = fread((void * __restrict  )(str), sizeof(char ), (size_t )k___0, (FILE * __restrict  )lm->fp);
#line 326
  if (tmp___18 != (size_t )k___0) {
#line 327
    _E__pr_header("src/lm.c", 327L, "FATAL_ERROR");
#line 327
    _E__die_error("fread(%s) failed\n", file);
  }
#line 330
  vn = lm_fread_int32(lm);
#line 331
  if (vn <= 0) {
#line 333
    k___0 = lm_fread_int32(lm);
#line 336
    while (1) {
#line 337
      k___0 = lm_fread_int32(lm);
#line 337
      if (k___0 == 0) {
#line 338
        break;
      }
#line 339
      tmp___19 = fread((void * __restrict  )(str), sizeof(char ), (size_t )k___0,
                       (FILE * __restrict  )lm->fp);
#line 339
      if (tmp___19 != (size_t )k___0) {
#line 340
        _E__pr_header("src/lm.c", 340L, "FATAL_ERROR");
#line 340
        _E__die_error("fread(%s) failed\n", file);
      }
    }
#line 344
    if (vn <= -2) {
#line 345
      k___0 = lm_fread_int32(lm);
#line 346
      if (k___0 < 1) {
#line 347
        _E__pr_header("src/lm.c", 347L, "FATAL_ERROR");
#line 347
        _E__die_error("log2(bg_seg_sz) outside range 1..15\n", k___0);
      } else
#line 346
      if (k___0 > 15) {
#line 347
        _E__pr_header("src/lm.c", 347L, "FATAL_ERROR");
#line 347
        _E__die_error("log2(bg_seg_sz) outside range 1..15\n", k___0);
      }
#line 348
      lm->log_bg_seg_sz = k___0;
    } else {
#line 350
      lm->log_bg_seg_sz = 9;
    }
#line 353
    lm->n_ug = lm_fread_int32(lm);
  } else {
#line 356
    lm->n_ug = vn;
#line 357
    lm->log_bg_seg_sz = 9;
  }
#line 359
  if (lm->n_ug <= 0) {
#line 360
    _E__pr_header("src/lm.c", 360L, "FATAL_ERROR");
#line 360
    _E__die_error("Bad #unigrams: %d (must be >0, <%d\n", lm->n_ug, (uint32 )65534);
  } else
#line 359
  if ((uint32 )lm->n_ug >= 65534U) {
#line 360
    _E__pr_header("src/lm.c", 360L, "FATAL_ERROR");
#line 360
    _E__die_error("Bad #unigrams: %d (must be >0, <%d\n", lm->n_ug, (uint32 )65534);
  }
#line 362
  lm->bg_seg_sz = 1 << lm->log_bg_seg_sz;
#line 365
  lm->n_bg = lm_fread_int32(lm);
#line 366
  if (lm->n_bg < 0) {
#line 367
    _E__pr_header("src/lm.c", 367L, "FATAL_ERROR");
#line 367
    _E__die_error("Bad #bigrams: %d\n", lm->n_bg);
  }
#line 370
  lm->n_tg = lm_fread_int32(lm);
#line 371
  if (lm->n_tg < 0) {
#line 372
    _E__pr_header("src/lm.c", 372L, "FATAL_ERROR");
#line 372
    _E__die_error("Bad #trigrams: %d\n", lm->n_tg);
  }
#line 375
  tmp___20 = __ckd_calloc__((size_t )(lm->n_ug + 1), sizeof(ug_t ), "src/lm.c", 375);
#line 375
  lm->ug = (ug_t *)tmp___20;
#line 376
  tmp___21 = fread((void * __restrict  )lm->ug, sizeof(ug_t ), (size_t )(lm->n_ug + 1),
                   (FILE * __restrict  )lm->fp);
#line 376
  if (tmp___21 != (size_t )(lm->n_ug + 1)) {
#line 377
    _E__pr_header("src/lm.c", 377L, "FATAL_ERROR");
#line 377
    _E__die_error("fread(%s) failed\n", file);
  }
#line 378
  if (lm->byteswap) {
#line 379
    i = 0;
#line 379
    while (i <= lm->n_ug) {
#line 380
      (lm->ug + i)->prob.l = (int32 )((unsigned int )(((255 & ((lm->ug + i)->prob.l >> 24)) | (65280 & ((lm->ug + i)->prob.l >> 8))) | (16711680 & ((lm->ug + i)->prob.l << 8))) | (4278190080U & (unsigned int )((lm->ug + i)->prob.l << 24)));
#line 381
      (lm->ug + i)->bowt.l = (int32 )((unsigned int )(((255 & ((lm->ug + i)->bowt.l >> 24)) | (65280 & ((lm->ug + i)->bowt.l >> 8))) | (16711680 & ((lm->ug + i)->bowt.l << 8))) | (4278190080U & (unsigned int )((lm->ug + i)->bowt.l << 24)));
#line 382
      (lm->ug + i)->firstbg = (int32 )((unsigned int )(((255 & ((lm->ug + i)->firstbg >> 24)) | (65280 & ((lm->ug + i)->firstbg >> 8))) | (16711680 & ((lm->ug + i)->firstbg << 8))) | (4278190080U & (unsigned int )((lm->ug + i)->firstbg << 24)));
#line 379
      i ++;
    }
  }
#line 384
  _E__pr_info_header("src/lm.c", 384L, "INFO");
#line 384
  _E__pr_info("%8d unigrams\n", lm->n_ug);
#line 389
  if (LM_IN_MEMORY) {
#line 390
    tmp___22 = __ckd_calloc__((size_t )(lm->n_bg + 1), sizeof(bg_t ), "src/lm.c",
                              390);
#line 390
    lm->bg = (bg_t *)tmp___22;
#line 391
    tmp___23 = __ckd_calloc__((size_t )(lm->n_tg + 1), sizeof(tg_t ), "src/lm.c",
                              391);
#line 391
    lm->tg = (tg_t *)tmp___23;
#line 393
    if (lm->n_bg > 0) {
#line 394
      tmp___24 = ftell(lm->fp);
#line 394
      lm->bgoff = (int32 )tmp___24;
#line 395
      fread((void * __restrict  )lm->bg, (size_t )(lm->n_bg + 1), sizeof(bg_t ), (FILE * __restrict  )lm->fp);
#line 396
      _E__pr_info_header("src/lm.c", 396L, "INFO");
#line 396
      _E__pr_info("Read %8d bigrams [in memory]\n", lm->n_bg);
#line 398
      tmp___25 = __ckd_calloc__((size_t )lm->n_ug, sizeof(membg_t ), "src/lm.c", 398);
#line 398
      lm->membg = (membg_t *)tmp___25;
    }
#line 401
    if (lm->n_tg > 0) {
#line 402
      tmp___26 = ftell(lm->fp);
#line 402
      lm->tgoff = (int32 )tmp___26;
#line 403
      fread((void * __restrict  )lm->tg, (size_t )lm->n_tg, sizeof(tg_t ), (FILE * __restrict  )lm->fp);
#line 404
      _E__pr_info_header("src/lm.c", 404L, "INFO");
#line 404
      _E__pr_info("Read %8d trigrams [in memory]\n", lm->n_tg);
#line 406
      tmp___27 = __ckd_calloc__((size_t )lm->n_ug, sizeof(tginfo_t *), "src/lm.c",
                                406);
#line 406
      lm->tginfo = (tginfo_t **)tmp___27;
    }
  } else {
#line 409
    lm->bg = (bg_t *)((void *)0);
#line 410
    lm->tg = (tg_t *)((void *)0);
#line 413
    if (lm->n_bg > 0) {
#line 414
      tmp___28 = ftell(lm->fp);
#line 414
      lm->bgoff = (int32 )tmp___28;
#line 415
      fseek(lm->fp, (long )((unsigned long )(lm->n_bg + 1) * sizeof(bg_t )), 1);
#line 416
      _E__pr_info_header("src/lm.c", 416L, "INFO");
#line 416
      _E__pr_info("%8d bigrams [on disk]\n", lm->n_bg);
#line 417
      tmp___29 = __ckd_calloc__((size_t )lm->n_ug, sizeof(membg_t ), "src/lm.c", 417);
#line 417
      lm->membg = (membg_t *)tmp___29;
    }
#line 421
    if (lm->n_tg > 0) {
#line 422
      tmp___30 = ftell(lm->fp);
#line 422
      lm->tgoff = (int32 )tmp___30;
#line 423
      fseek(lm->fp, (long )((unsigned long )lm->n_tg * sizeof(tg_t )), 1);
#line 424
      _E__pr_info_header("src/lm.c", 424L, "INFO");
#line 424
      _E__pr_info("%8d trigrams [on disk]\n", lm->n_tg);
#line 426
      tmp___31 = __ckd_calloc__((size_t )lm->n_ug, sizeof(tginfo_t *), "src/lm.c",
                                426);
#line 426
      lm->tginfo = (tginfo_t **)tmp___31;
    }
  }
#line 430
  if (lm->n_bg > 0) {
#line 432
    lm->n_bgprob = lm_fread_int32(lm);
#line 433
    if (lm->n_bgprob <= 0) {
#line 434
      _E__pr_header("src/lm.c", 434L, "FATAL_ERROR");
#line 434
      _E__die_error("Bad bigram prob table size: %d\n", lm->n_bgprob);
    } else
#line 433
    if (lm->n_bgprob > 65536) {
#line 434
      _E__pr_header("src/lm.c", 434L, "FATAL_ERROR");
#line 434
      _E__die_error("Bad bigram prob table size: %d\n", lm->n_bgprob);
    }
#line 437
    tmp___32 = __ckd_calloc__((size_t )lm->n_bgprob, sizeof(lmlog_t ), "src/lm.c",
                              437);
#line 437
    lm->bgprob = (lmlog_t *)tmp___32;
#line 438
    tmp___33 = fread((void * __restrict  )lm->bgprob, sizeof(lmlog_t ), (size_t )lm->n_bgprob,
                     (FILE * __restrict  )lm->fp);
#line 438
    if (tmp___33 != (size_t )lm->n_bgprob) {
#line 440
      _E__pr_header("src/lm.c", 440L, "FATAL_ERROR");
#line 440
      _E__die_error("fread(%s) failed\n", file);
    }
#line 441
    if (lm->byteswap) {
#line 442
      i = 0;
#line 442
      while (i < lm->n_bgprob) {
#line 443
        (lm->bgprob + i)->l = (int32 )((unsigned int )(((255 & ((lm->bgprob + i)->l >> 24)) | (65280 & ((lm->bgprob + i)->l >> 8))) | (16711680 & ((lm->bgprob + i)->l << 8))) | (4278190080U & (unsigned int )((lm->bgprob + i)->l << 24)));
#line 442
        i ++;
      }
    }
#line 446
    _E__pr_info_header("src/lm.c", 446L, "INFO");
#line 446
    _E__pr_info("%8d bigram prob entries\n", lm->n_bgprob);
  }
#line 449
  if (lm->n_tg > 0) {
#line 451
    lm->n_tgbowt = lm_fread_int32(lm);
#line 452
    if (lm->n_tgbowt <= 0) {
#line 453
      _E__pr_header("src/lm.c", 453L, "FATAL_ERROR");
#line 453
      _E__die_error("Bad trigram bowt table size: %d\n", lm->n_tgbowt);
    } else
#line 452
    if (lm->n_tgbowt > 65536) {
#line 453
      _E__pr_header("src/lm.c", 453L, "FATAL_ERROR");
#line 453
      _E__die_error("Bad trigram bowt table size: %d\n", lm->n_tgbowt);
    }
#line 456
    tmp___34 = __ckd_calloc__((size_t )lm->n_tgbowt, sizeof(lmlog_t ), "src/lm.c",
                              456);
#line 456
    lm->tgbowt = (lmlog_t *)tmp___34;
#line 457
    tmp___35 = fread((void * __restrict  )lm->tgbowt, sizeof(lmlog_t ), (size_t )lm->n_tgbowt,
                     (FILE * __restrict  )lm->fp);
#line 457
    if (tmp___35 != (size_t )lm->n_tgbowt) {
#line 459
      _E__pr_header("src/lm.c", 459L, "FATAL_ERROR");
#line 459
      _E__die_error("fread(%s) failed\n", file);
    }
#line 460
    if (lm->byteswap) {
#line 461
      i = 0;
#line 461
      while (i < lm->n_tgbowt) {
#line 462
        (lm->tgbowt + i)->l = (int32 )((unsigned int )(((255 & ((lm->tgbowt + i)->l >> 24)) | (65280 & ((lm->tgbowt + i)->l >> 8))) | (16711680 & ((lm->tgbowt + i)->l << 8))) | (4278190080U & (unsigned int )((lm->tgbowt + i)->l << 24)));
#line 461
        i ++;
      }
    }
#line 464
    _E__pr_info_header("src/lm.c", 464L, "INFO");
#line 464
    _E__pr_info("%8d trigram bowt entries\n", lm->n_tgbowt);
#line 467
    lm->n_tgprob = lm_fread_int32(lm);
#line 468
    if (lm->n_tgprob <= 0) {
#line 469
      _E__pr_header("src/lm.c", 469L, "FATAL_ERROR");
#line 469
      _E__die_error("Bad trigram bowt table size: %d\n", lm->n_tgprob);
    } else
#line 468
    if (lm->n_tgprob > 65536) {
#line 469
      _E__pr_header("src/lm.c", 469L, "FATAL_ERROR");
#line 469
      _E__die_error("Bad trigram bowt table size: %d\n", lm->n_tgprob);
    }
#line 472
    tmp___36 = __ckd_calloc__((size_t )lm->n_tgprob, sizeof(lmlog_t ), "src/lm.c",
                              472);
#line 472
    lm->tgprob = (lmlog_t *)tmp___36;
#line 473
    tmp___37 = fread((void * __restrict  )lm->tgprob, sizeof(lmlog_t ), (size_t )lm->n_tgprob,
                     (FILE * __restrict  )lm->fp);
#line 473
    if (tmp___37 != (size_t )lm->n_tgprob) {
#line 475
      _E__pr_header("src/lm.c", 475L, "FATAL_ERROR");
#line 475
      _E__die_error("fread(%s) failed\n", file);
    }
#line 476
    if (lm->byteswap) {
#line 477
      i = 0;
#line 477
      while (i < lm->n_tgprob) {
#line 478
        (lm->tgprob + i)->l = (int32 )((unsigned int )(((255 & ((lm->tgprob + i)->l >> 24)) | (65280 & ((lm->tgprob + i)->l >> 8))) | (16711680 & ((lm->tgprob + i)->l << 8))) | (4278190080U & (unsigned int )((lm->tgprob + i)->l << 24)));
#line 477
        i ++;
      }
    }
#line 480
    _E__pr_info_header("src/lm.c", 480L, "INFO");
#line 480
    _E__pr_info("%8d trigram prob entries\n", lm->n_tgprob);
#line 483
    k___0 = lm_fread_int32(lm);
#line 484
    if (k___0 != (lm->n_bg + 1) / lm->bg_seg_sz + 1) {
#line 485
      _E__pr_header("src/lm.c", 485L, "FATAL_ERROR");
#line 485
      _E__die_error("Bad trigram seg table size: %d\n", k___0);
    }
#line 488
    tmp___38 = __ckd_calloc__((size_t )k___0, sizeof(int32 ), "src/lm.c", 488);
#line 488
    lm->tg_segbase = (int32 *)tmp___38;
#line 489
    tmp___39 = fread((void * __restrict  )lm->tg_segbase, sizeof(int32 ), (size_t )k___0,
                     (FILE * __restrict  )lm->fp);
#line 489
    if (tmp___39 != (size_t )k___0) {
#line 490
      _E__pr_header("src/lm.c", 490L, "FATAL_ERROR");
#line 490
      _E__die_error("fread(%s) failed\n", file);
    }
#line 491
    if (lm->byteswap) {
#line 492
      i = 0;
#line 492
      while (i < k___0) {
#line 493
        *(lm->tg_segbase + i) = (int32 )((unsigned int )(((255 & (*(lm->tg_segbase + i) >> 24)) | (65280 & (*(lm->tg_segbase + i) >> 8))) | (16711680 & (*(lm->tg_segbase + i) << 8))) | (4278190080U & (unsigned int )(*(lm->tg_segbase + i) << 24)));
#line 492
        i ++;
      }
    }
#line 495
    _E__pr_info_header("src/lm.c", 495L, "INFO");
#line 495
    _E__pr_info("%8d trigram segtable entries (%d segsize)\n", k___0, lm->bg_seg_sz);
  }
#line 499
  k___0 = lm_fread_int32(lm);
#line 500
  if (k___0 <= 0) {
#line 501
    _E__pr_header("src/lm.c", 501L, "FATAL_ERROR");
#line 501
    _E__die_error("Bad wordstrings size: %d\n", k___0);
  }
#line 503
  tmp___40 = __ckd_calloc__((size_t )k___0, sizeof(char ), "src/lm.c", 503);
#line 503
  tmp_word_str = (char *)tmp___40;
#line 504
  tmp___41 = fread((void * __restrict  )tmp_word_str, sizeof(char ), (size_t )k___0,
                   (FILE * __restrict  )lm->fp);
#line 504
  if (tmp___41 != (size_t )k___0) {
#line 505
    _E__pr_header("src/lm.c", 505L, "FATAL_ERROR");
#line 505
    _E__die_error("fread(%s) failed\n", file);
  }
#line 508
  i = 0;
#line 508
  j = 0;
#line 508
  while (i < k___0) {
#line 509
    if ((int )*(tmp_word_str + i) == 0) {
#line 510
      j ++;
    }
#line 508
    i ++;
  }
#line 511
  if (j != lm->n_ug) {
#line 512
    _E__pr_header("src/lm.c", 512L, "FATAL_ERROR");
#line 512
    _E__die_error("Bad #words: %d\n", j);
  }
#line 515
  endwid = (s3lmwid_t )65535;
#line 515
  startwid = endwid;
#line 516
  tmp___42 = __ckd_calloc__((size_t )lm->n_ug, sizeof(char *), "src/lm.c", 516);
#line 516
  lm->wordstr = (char **)tmp___42;
#line 517
  j = 0;
#line 518
  i = 0;
#line 518
  while (i < lm->n_ug) {
#line 519
    if (0) {
#line 519
      __s1_len___1 = __builtin_strlen((char const   *)(tmp_word_str + j));
#line 519
      __s2_len___1 = __builtin_strlen("<s>");
#line 519
      if (! ((size_t )((void const   *)((tmp_word_str + j) + 1)) - (size_t )((void const   *)(tmp_word_str + j)) == 1UL)) {
#line 519
        goto _L___4;
      } else
#line 519
      if (__s1_len___1 >= 4UL) {
        _L___4: /* CIL Label */ 
#line 519
        if (! ((size_t )((void const   *)("<s>" + 1)) - (size_t )((void const   *)"<s>") == 1UL)) {
#line 519
          tmp___56 = 1;
        } else
#line 519
        if (__s2_len___1 >= 4UL) {
#line 519
          tmp___56 = 1;
        } else {
#line 519
          tmp___56 = 0;
        }
      } else {
#line 519
        tmp___56 = 0;
      }
#line 519
      if (tmp___56) {
#line 519
        tmp___51 = __builtin_strcmp((char const   *)(tmp_word_str + j), "<s>");
#line 519
        tmp___55 = tmp___51;
      } else {
#line 519
        tmp___54 = __builtin_strcmp((char const   *)(tmp_word_str + j), "<s>");
#line 519
        tmp___55 = tmp___54;
      }
    } else {
#line 519
      tmp___54 = __builtin_strcmp((char const   *)(tmp_word_str + j), "<s>");
#line 519
      tmp___55 = tmp___54;
    }
#line 519
    if (tmp___55 == 0) {
#line 520
      startwid = (s3lmwid_t )i;
    } else {
#line 521
      if (0) {
#line 521
        __s1_len___0 = __builtin_strlen((char const   *)(tmp_word_str + j));
#line 521
        __s2_len___0 = __builtin_strlen("</s>");
#line 521
        if (! ((size_t )((void const   *)((tmp_word_str + j) + 1)) - (size_t )((void const   *)(tmp_word_str + j)) == 1UL)) {
#line 521
          goto _L___2;
        } else
#line 521
        if (__s1_len___0 >= 4UL) {
          _L___2: /* CIL Label */ 
#line 521
          if (! ((size_t )((void const   *)("</s>" + 1)) - (size_t )((void const   *)"</s>") == 1UL)) {
#line 521
            tmp___49 = 1;
          } else
#line 521
          if (__s2_len___0 >= 4UL) {
#line 521
            tmp___49 = 1;
          } else {
#line 521
            tmp___49 = 0;
          }
        } else {
#line 521
          tmp___49 = 0;
        }
#line 521
        if (tmp___49) {
#line 521
          tmp___44 = __builtin_strcmp((char const   *)(tmp_word_str + j), "</s>");
#line 521
          tmp___48 = tmp___44;
        } else {
#line 521
          tmp___47 = __builtin_strcmp((char const   *)(tmp_word_str + j), "</s>");
#line 521
          tmp___48 = tmp___47;
        }
      } else {
#line 521
        tmp___47 = __builtin_strcmp((char const   *)(tmp_word_str + j), "</s>");
#line 521
        tmp___48 = tmp___47;
      }
#line 521
      if (tmp___48 == 0) {
#line 522
        endwid = (s3lmwid_t )i;
      }
    }
#line 524
    tmp___57 = __ckd_salloc__((char const   *)(tmp_word_str + j), "src/lm.c", 524);
#line 524
    *(lm->wordstr + i) = tmp___57;
#line 526
    tmp___58 = strlen((char const   *)(tmp_word_str + j));
#line 526
    j = (int32 )((size_t )j + (tmp___58 + 1UL));
#line 518
    i ++;
  }
#line 528
  free((void *)tmp_word_str);
#line 529
  _E__pr_info_header("src/lm.c", 529L, "INFO");
#line 529
  _E__pr_info("%8d word strings\n", i);
#line 532
  if ((int )startwid != 65535) {
#line 533
    (lm->ug + startwid)->prob.f = (float32 )(- 99.0);
#line 534
    lm->startlwid = startwid;
  }
#line 538
  if ((int )endwid != 65535) {
#line 539
    (lm->ug + endwid)->bowt.f = (float32 )(- 99.0);
#line 540
    lm->finishlwid = endwid;
  }
#line 543
  lm2logs3(lm, uw);
#line 546
  lm->lw = (float32 )1.0;
#line 547
  lm->wip = 0;
#line 548
  lm_set_param(lm, lw, wip);
#line 550
  return (lm);
}
}
#line 554 "src/lm.c"
lm_t *lm_read(char *file , float64 lw , float64 wip , float64 uw ) 
{ 
  int32 i ;
  int32 u ;
  lm_t *lm ;
  int32 tmp ;
  void const   *tmp___0 ;
  void *tmp___1 ;

  {
#line 559
  if (! file) {
#line 560
    _E__pr_header("src/lm.c", 560L, "FATAL_ERROR");
#line 560
    _E__die_error("No LM file\n");
  }
#line 561
  if (lw <= 0.0) {
#line 562
    _E__pr_header("src/lm.c", 562L, "FATAL_ERROR");
#line 562
    _E__die_error("lw = %e\n", lw);
  }
#line 563
  if (wip <= 0.0) {
#line 564
    _E__pr_header("src/lm.c", 564L, "FATAL_ERROR");
#line 564
    _E__die_error("wip = %e\n", wip);
  }
#line 565
  if (uw < 0.0) {
#line 566
    _E__pr_header("src/lm.c", 566L, "FATAL_ERROR");
#line 566
    _E__die_error("uw = %e\n", uw);
  } else
#line 565
  if (uw > 1.0) {
#line 566
    _E__pr_header("src/lm.c", 566L, "FATAL_ERROR");
#line 566
    _E__die_error("uw = %e\n", uw);
  }
#line 568
  _E__pr_info_header("src/lm.c", 568L, "INFO");
#line 568
  tmp = logs3(wip);
#line 568
  _E__pr_info("LM read(\'%s\', lw= %.2f, wip= %d, uw= %.2f)\n", file, lw, tmp, uw);
#line 569
  tmp___0 = cmd_ln_access((char *)"-lminmemory");
#line 569
  if (*((int32 *)tmp___0)) {
#line 570
    LM_IN_MEMORY = 1;
  } else {
#line 572
    LM_IN_MEMORY = 0;
  }
#line 575
  lm = lm_read_dump(file, lw, wip, uw);
#line 577
  u = 0;
#line 577
  while (u < lm->n_ug) {
#line 578
    (lm->ug + u)->dictwid = -1;
#line 577
    u ++;
  }
#line 581
  tmp___1 = __ckd_calloc__((size_t )100003, sizeof(lm_tgcache_entry_t ), "src/lm.c",
                           581);
#line 581
  lm->tgcache = (lm_tgcache_entry_t *)tmp___1;
#line 582
  i = 0;
#line 582
  while (i < 100003) {
#line 583
    (lm->tgcache + i)->lwid[0] = (s3lmwid_t )65535;
#line 582
    i ++;
  }
#line 585
  return (lm);
}
}
#line 592 "src/lm.c"
void lm_cache_reset(lm_t *lm ) 
{ 
  int32 i ;
  int32 n_bgfree ;
  int32 n_tgfree ;
  tginfo_t *tginfo ;
  tginfo_t *next_tginfo ;
  tginfo_t *prev_tginfo ;

  {
#line 597
  n_tgfree = 0;
#line 597
  n_bgfree = n_tgfree;
#line 599
  if (LM_IN_MEMORY) {
#line 600
    return;
  }
#line 602
  if (lm->n_bg > 0) {
#line 602
    if (! lm->bg) {
#line 603
      i = 0;
#line 603
      while (i < lm->n_ug) {
#line 604
        if ((lm->membg + i)->bg) {
#line 604
          if (! (lm->membg + i)->used) {
#line 605
            lm->n_bg_inmem -= (lm->ug + (i + 1))->firstbg - (lm->ug + i)->firstbg;
#line 607
            free((void *)(lm->membg + i)->bg);
#line 608
            (lm->membg + i)->bg = (bg_t *)((void *)0);
#line 609
            n_bgfree ++;
          }
        }
#line 612
        (lm->membg + i)->used = 0;
#line 603
        i ++;
      }
    }
  }
#line 616
  if (lm->n_tg > 0) {
#line 617
    i = 0;
#line 617
    while (i < lm->n_ug) {
#line 618
      prev_tginfo = (tginfo_t *)((void *)0);
#line 619
      tginfo = *(lm->tginfo + i);
#line 619
      while (tginfo) {
#line 620
        next_tginfo = tginfo->next;
#line 622
        if (! tginfo->used) {
#line 623
          if (! lm->tg) {
#line 623
            if (tginfo->tg) {
#line 624
              lm->n_tg_inmem -= tginfo->n_tg;
#line 625
              free((void *)tginfo->tg);
#line 626
              n_tgfree ++;
            }
          }
#line 629
          free((void *)tginfo);
#line 630
          if (prev_tginfo) {
#line 631
            prev_tginfo->next = next_tginfo;
          } else {
#line 633
            *(lm->tginfo + i) = next_tginfo;
          }
        } else {
#line 635
          tginfo->used = 0;
#line 636
          prev_tginfo = tginfo;
        }
#line 619
        tginfo = next_tginfo;
      }
#line 617
      i ++;
    }
  }
#line 642
  if (n_tgfree > 0) {
#line 643
    _E__pr_info_header("src/lm.c", 643L, "INFO");
#line 643
    _E__pr_info("%d tg frees, %d in mem; %d bg frees, %d in mem\n", n_tgfree, lm->n_tg_inmem,
                n_bgfree, lm->n_bg_inmem);
  } else
#line 642
  if (n_bgfree > 0) {
#line 643
    _E__pr_info_header("src/lm.c", 643L, "INFO");
#line 643
    _E__pr_info("%d tg frees, %d in mem; %d bg frees, %d in mem\n", n_tgfree, lm->n_tg_inmem,
                n_bgfree, lm->n_bg_inmem);
  }
#line 646
  return;
}
}
#line 649 "src/lm.c"
void lm_cache_stats_dump(lm_t *lm ) 
{ 


  {
#line 651
  _E__pr_info_header("src/lm.c", 651L, "INFO");
#line 651
  _E__pr_info("%9d tg(), %9d tgcache, %8d bo; %5d fills, %8d in mem (%.1f%%)\n", lm->n_tg_score,
              lm->n_tgcache_hit, lm->n_tg_bo, lm->n_tg_fill, lm->n_tg_inmem, ((double )lm->n_tg_inmem * 100.0) / (double )(lm->n_tg + 1));
#line 654
  _E__pr_info_header("src/lm.c", 654L, "INFO");
#line 654
  _E__pr_info("%8d bg(), %8d bo; %5d fills, %8d in mem (%.1f%%)\n", lm->n_bg_score,
              lm->n_bg_bo, lm->n_bg_fill, lm->n_bg_inmem, ((double )lm->n_bg_inmem * 100.0) / (double )(lm->n_bg + 1));
#line 658
  lm->n_tgcache_hit = 0;
#line 659
  lm->n_tg_fill = 0;
#line 660
  lm->n_tg_score = 0;
#line 661
  lm->n_tg_bo = 0;
#line 662
  lm->n_bg_fill = 0;
#line 663
  lm->n_bg_score = 0;
#line 664
  lm->n_bg_bo = 0;
#line 665
  return;
}
}
#line 668 "src/lm.c"
int32 lm_ug_score(lm_t *lm , s3lmwid_t wid ) 
{ 


  {
#line 670
  if ((int )wid == 65535) {
#line 671
    _E__pr_header("src/lm.c", 671L, "FATAL_ERROR");
#line 671
    _E__die_error("Bad argument (%d) to lm_ug_score\n", (int )wid);
  } else
#line 670
  if ((int )wid >= lm->n_ug) {
#line 671
    _E__pr_header("src/lm.c", 671L, "FATAL_ERROR");
#line 671
    _E__die_error("Bad argument (%d) to lm_ug_score\n", (int )wid);
  }
#line 673
  lm->access_type = 1;
#line 675
  return ((lm->ug + wid)->prob.l);
}
}
#line 679 "src/lm.c"
int32 lm_uglist(lm_t *lm , ug_t **ugptr ) 
{ 


  {
#line 681
  *ugptr = lm->ug;
#line 682
  return (lm->n_ug);
}
}
#line 686 "src/lm.c"
int32 lm_ug_wordprob(lm_t *lm , int32 th , wordprob_t *wp ) 
{ 
  int32 i ;
  int32 j ;
  int32 n ;
  int32 p ;
  s3wid_t w___0 ;

  {
#line 691
  n = lm->n_ug;
#line 693
  i = 0;
#line 693
  j = 0;
#line 693
  while (i < n) {
#line 694
    w___0 = (lm->ug + i)->dictwid;
#line 696
    if (w___0 >= 0) {
#line 697
      p = (lm->ug + i)->prob.l;
#line 697
      if (p >= th) {
#line 698
        (wp + j)->wid = w___0;
#line 699
        (wp + j)->prob = p;
#line 700
        j ++;
      }
    }
#line 693
    i ++;
  }
#line 705
  return (j);
}
}
#line 712 "src/lm.c"
static void load_bg(lm_t *lm , s3lmwid_t lw1 ) 
{ 
  int32 i ;
  int32 n ;
  int32 b ;
  bg_t *bg ;
  bg_t *tmp ;
  bg_t *tmp___0 ;
  void *tmp___1 ;
  int tmp___2 ;
  size_t tmp___3 ;

  {
#line 717
  b = (lm->ug + lw1)->firstbg;
#line 718
  n = (lm->ug + ((int )lw1 + 1))->firstbg - b;
#line 720
  if (LM_IN_MEMORY) {
#line 721
    tmp = lm->bg + b;
#line 721
    (lm->membg + lw1)->bg = tmp;
#line 721
    bg = tmp;
  } else {
#line 723
    tmp___1 = __ckd_calloc__((size_t )(n + 1), sizeof(bg_t ), "src/lm.c", 723);
#line 723
    tmp___0 = (bg_t *)tmp___1;
#line 723
    (lm->membg + lw1)->bg = tmp___0;
#line 723
    bg = tmp___0;
#line 725
    tmp___2 = fseek(lm->fp, (long )((unsigned long )lm->bgoff + (unsigned long )b * sizeof(bg_t )),
                    0);
#line 725
    if (tmp___2 < 0) {
#line 726
      _E__pr_header("src/lm.c", 726L, "SYSTEM_ERROR");
#line 726
      _E__fatal_sys_error("fseek failed\n");
    }
#line 729
    tmp___3 = fread((void * __restrict  )bg, sizeof(bg_t ), (size_t )(n + 1), (FILE * __restrict  )lm->fp);
#line 729
    if (tmp___3 != (size_t )(n + 1)) {
#line 730
      _E__pr_header("src/lm.c", 730L, "FATAL_ERROR");
#line 730
      _E__die_error("fread failed\n");
    }
#line 731
    if (lm->byteswap) {
#line 732
      i = 0;
#line 732
      while (i <= n) {
#line 733
        (bg + i)->wid = (s3lmwid_t )((255 & ((int )(bg + i)->wid >> 8)) | (65280 & ((int )(bg + i)->wid << 8)));
#line 734
        (bg + i)->probid = (uint16 )((255 & ((int )(bg + i)->probid >> 8)) | (65280 & ((int )(bg + i)->probid << 8)));
#line 735
        (bg + i)->bowtid = (uint16 )((255 & ((int )(bg + i)->bowtid >> 8)) | (65280 & ((int )(bg + i)->bowtid << 8)));
#line 736
        (bg + i)->firsttg = (uint16 )((255 & ((int )(bg + i)->firsttg >> 8)) | (65280 & ((int )(bg + i)->firsttg << 8)));
#line 732
        i ++;
      }
    }
  }
#line 740
  (lm->n_bg_fill) ++;
#line 741
  lm->n_bg_inmem += n;
#line 742
  return;
}
}
#line 748 "src/lm.c"
static int32 find_bg(bg_t *bg , int32 n , s3lmwid_t w___0 ) 
{ 
  int32 i ;
  int32 b ;
  int32 e ;
  int32 tmp ;

  {
#line 753
  b = 0;
#line 754
  e = n;
#line 755
  while (e - b > 16) {
#line 756
    i = (b + e) >> 1;
#line 757
    if ((int )(bg + i)->wid < (int )w___0) {
#line 758
      b = i + 1;
    } else
#line 759
    if ((int )(bg + i)->wid > (int )w___0) {
#line 760
      e = i;
    } else {
#line 762
      return (i);
    }
  }
#line 766
  i = b;
#line 766
  while (1) {
#line 766
    if (i < e) {
#line 766
      if (! ((int )(bg + i)->wid != (int )w___0)) {
#line 766
        break;
      }
    } else {
#line 766
      break;
    }
#line 766
    i ++;
  }
#line 767
  if (i < e) {
#line 767
    tmp = i;
  } else {
#line 767
    tmp = -1;
  }
#line 767
  return (tmp);
}
}
#line 771 "src/lm.c"
int32 lm_bglist(lm_t *lm , s3lmwid_t w1 , bg_t **bgptr , int32 *bowt ) 
{ 
  int32 n ;

  {
#line 775
  if ((int )w1 == 65535) {
#line 776
    _E__pr_header("src/lm.c", 776L, "FATAL_ERROR");
#line 776
    _E__die_error("Bad w1 argument (%d) to lm_bglist\n", (int )w1);
  } else
#line 775
  if ((int )w1 >= lm->n_ug) {
#line 776
    _E__pr_header("src/lm.c", 776L, "FATAL_ERROR");
#line 776
    _E__die_error("Bad w1 argument (%d) to lm_bglist\n", (int )w1);
  }
#line 778
  if (lm->n_bg > 0) {
#line 778
    n = (lm->ug + ((int )w1 + 1))->firstbg - (lm->ug + w1)->firstbg;
  } else {
#line 778
    n = 0;
  }
#line 780
  if (n > 0) {
#line 781
    if (! (lm->membg + w1)->bg) {
#line 782
      load_bg(lm, w1);
    }
#line 783
    (lm->membg + w1)->used = 1;
#line 785
    *bgptr = (lm->membg + w1)->bg;
#line 786
    *bowt = (lm->ug + w1)->bowt.l;
  } else {
#line 788
    *bgptr = (bg_t *)((void *)0);
#line 789
    *bowt = 0;
  }
#line 792
  return (n);
}
}
#line 796 "src/lm.c"
int32 lm_bg_wordprob(lm_t *lm , s3lmwid_t lwid , int32 th , wordprob_t *wp , int32 *bowt ) 
{ 
  bg_t *bgptr ;
  int32 i ;
  int32 j ;
  int32 n ;
  int32 ugprob ;
  int32 bgprob ;
  s3wid_t w___0 ;

  {
#line 802
  n = lm_bglist(lm, lwid, & bgptr, bowt);
#line 803
  ugprob = lm_ug_score(lm, lwid);
#line 806
  i = 0;
#line 806
  j = 0;
#line 806
  while (i < n) {
#line 807
    w___0 = (lm->ug + bgptr->wid)->dictwid;
#line 808
    if (w___0 >= 0) {
#line 809
      bgprob = (lm->bgprob + bgptr->probid)->l;
#line 811
      if (ugprob + bgprob >= th) {
#line 812
        (wp + j)->wid = w___0;
#line 813
        (wp + j)->prob = bgprob;
#line 814
        j ++;
      }
    }
#line 806
    i ++;
#line 806
    bgptr ++;
  }
#line 819
  return (j);
}
}
#line 823 "src/lm.c"
int32 lm_bg_score(lm_t *lm , s3lmwid_t w1 , s3lmwid_t w2 ) 
{ 
  int32 i ;
  int32 n ;
  int32 score ;
  bg_t *bg ;
  int32 tmp ;

  {
#line 826
  bg = (bg_t *)0;
#line 828
  if (lm->n_bg == 0) {
#line 829
    tmp = lm_ug_score(lm, w2);
#line 829
    return (tmp);
  } else
#line 828
  if ((int )w1 == 65535) {
#line 829
    tmp = lm_ug_score(lm, w2);
#line 829
    return (tmp);
  }
#line 831
  (lm->n_bg_score) ++;
#line 833
  if ((int )w2 == 65535) {
#line 834
    _E__pr_header("src/lm.c", 834L, "FATAL_ERROR");
#line 834
    _E__die_error("Bad w2 argument (%d) to lm_bg_score\n", (int )w2);
  } else
#line 833
  if ((int )w2 >= lm->n_ug) {
#line 834
    _E__pr_header("src/lm.c", 834L, "FATAL_ERROR");
#line 834
    _E__die_error("Bad w2 argument (%d) to lm_bg_score\n", (int )w2);
  }
#line 836
  n = (lm->ug + ((int )w1 + 1))->firstbg - (lm->ug + w1)->firstbg;
#line 838
  if (n > 0) {
#line 839
    if (! (lm->membg + w1)->bg) {
#line 840
      load_bg(lm, w1);
    }
#line 841
    (lm->membg + w1)->used = 1;
#line 842
    bg = (lm->membg + w1)->bg;
#line 844
    i = find_bg(bg, n, w2);
  } else {
#line 846
    i = -1;
  }
#line 848
  if (i >= 0) {
#line 849
    score = (lm->bgprob + (bg + i)->probid)->l;
#line 850
    lm->access_type = 2;
  } else {
#line 852
    (lm->n_bg_bo) ++;
#line 853
    lm->access_type = 1;
#line 854
    score = (lm->ug + w1)->bowt.l + (lm->ug + w2)->prob.l;
  }
#line 861
  return (score);
}
}
#line 865 "src/lm.c"
static void load_tg(lm_t *lm , s3lmwid_t lw1 , s3lmwid_t lw2 ) 
{ 
  int32 i ;
  int32 n ;
  int32 b ;
  int32 t ;
  bg_t *bg ;
  tg_t *tg ;
  tginfo_t *tginfo ;
  void *tmp ;
  int32 tmp___0 ;
  tg_t *tmp___1 ;
  tg_t *tmp___2 ;
  void *tmp___3 ;
  int tmp___4 ;
  size_t tmp___5 ;

  {
#line 868
  t = -1;
#line 875
  tmp = __ckd_malloc__(sizeof(tginfo_t ), "src/lm.c", 875);
#line 875
  tginfo = (tginfo_t *)tmp;
#line 876
  tginfo->w1 = lw1;
#line 877
  tginfo->tg = (tg_t *)((void *)0);
#line 878
  tginfo->next = *(lm->tginfo + lw2);
#line 879
  *(lm->tginfo + lw2) = tginfo;
#line 883
  b = (lm->ug + lw1)->firstbg;
#line 884
  n = (lm->ug + ((int )lw1 + 1))->firstbg - b;
#line 887
  if (n > 0) {
#line 888
    if (! (lm->membg + lw1)->bg) {
#line 889
      load_bg(lm, lw1);
    }
#line 890
    (lm->membg + lw1)->used = 1;
#line 891
    bg = (lm->membg + lw1)->bg;
  }
#line 895
  if (n > 0) {
#line 895
    i = find_bg(bg, n, lw2);
#line 895
    if (i >= 0) {
#line 896
      tginfo->bowt = (lm->tgbowt + (bg + i)->bowtid)->l;
#line 899
      b += i;
#line 900
      t = *(lm->tg_segbase + (b >> lm->log_bg_seg_sz));
#line 901
      t += (int32 )(bg + i)->firsttg;
#line 904
      n = *(lm->tg_segbase + ((b + 1) >> lm->log_bg_seg_sz));
#line 905
      n += (int32 )(bg + (i + 1))->firsttg;
#line 906
      n -= t;
#line 907
      tginfo->n_tg = n;
    } else {
#line 909
      tginfo->bowt = 0;
#line 910
      tmp___0 = 0;
#line 910
      tginfo->n_tg = tmp___0;
#line 910
      n = tmp___0;
    }
  } else {
#line 909
    tginfo->bowt = 0;
#line 910
    tmp___0 = 0;
#line 910
    tginfo->n_tg = tmp___0;
#line 910
    n = tmp___0;
  }
#line 920
  if (LM_IN_MEMORY) {
#line 922
    if (n > 0) {
#line 923
      if (! (t != -1)) {
#line 923
        __assert_fail("t != -1", "src/lm.c", 923U, "load_tg");
      }
#line 924
      tmp___1 = lm->tg + t;
#line 924
      tginfo->tg = tmp___1;
#line 924
      tg = tmp___1;
    }
  } else
#line 927
  if (n > 0) {
#line 928
    tmp___3 = __ckd_calloc__((size_t )n, sizeof(tg_t ), "src/lm.c", 928);
#line 928
    tmp___2 = (tg_t *)tmp___3;
#line 928
    tginfo->tg = tmp___2;
#line 928
    tg = tmp___2;
#line 929
    tmp___4 = fseek(lm->fp, (long )((unsigned long )lm->tgoff + (unsigned long )t * sizeof(tg_t )),
                    0);
#line 929
    if (tmp___4 < 0) {
#line 930
      _E__pr_header("src/lm.c", 930L, "SYSTEM_ERROR");
#line 930
      _E__fatal_sys_error("fseek failed\n");
    }
#line 932
    tmp___5 = fread((void * __restrict  )tg, sizeof(tg_t ), (size_t )n, (FILE * __restrict  )lm->fp);
#line 932
    if (tmp___5 != (size_t )n) {
#line 933
      _E__pr_header("src/lm.c", 933L, "FATAL_ERROR");
#line 933
      _E__die_error("fread(tg, %d at %d) failed\n", n, lm->tgoff);
    }
#line 934
    if (lm->byteswap) {
#line 935
      i = 0;
#line 935
      while (i < n) {
#line 936
        (tg + i)->wid = (s3lmwid_t )((255 & ((int )(tg + i)->wid >> 8)) | (65280 & ((int )(tg + i)->wid << 8)));
#line 937
        (tg + i)->probid = (uint16 )((255 & ((int )(tg + i)->probid >> 8)) | (65280 & ((int )(tg + i)->probid << 8)));
#line 935
        i ++;
      }
    }
  }
#line 942
  (lm->n_tg_fill) ++;
#line 943
  lm->n_tg_inmem += n;
#line 944
  return;
}
}
#line 948 "src/lm.c"
static int32 find_tg(tg_t *tg , int32 n , s3lmwid_t w___0 ) 
{ 
  int32 i ;
  int32 b ;
  int32 e ;
  int32 tmp ;

  {
#line 952
  b = 0;
#line 953
  e = n;
#line 954
  while (e - b > 16) {
#line 955
    i = (b + e) >> 1;
#line 956
    if ((int )(tg + i)->wid < (int )w___0) {
#line 957
      b = i + 1;
    } else
#line 958
    if ((int )(tg + i)->wid > (int )w___0) {
#line 959
      e = i;
    } else {
#line 961
      return (i);
    }
  }
#line 964
  i = b;
#line 964
  while (1) {
#line 964
    if (i < e) {
#line 964
      if (! ((int )(tg + i)->wid != (int )w___0)) {
#line 964
        break;
      }
    } else {
#line 964
      break;
    }
#line 964
    i ++;
  }
#line 965
  if (i < e) {
#line 965
    tmp = i;
  } else {
#line 965
    tmp = -1;
  }
#line 965
  return (tmp);
}
}
#line 969 "src/lm.c"
int32 lm_tglist(lm_t *lm , s3lmwid_t lw1 , s3lmwid_t lw2 , tg_t **tgptr , int32 *bowt ) 
{ 
  tginfo_t *tginfo ;
  tginfo_t *prev_tginfo ;

  {
#line 973
  if (lm->n_tg <= 0) {
#line 974
    *tgptr = (tg_t *)((void *)0);
#line 975
    *bowt = 0;
#line 976
    return (0);
  }
#line 979
  if ((int )lw1 == 65535) {
#line 980
    _E__pr_header("src/lm.c", 980L, "FATAL_ERROR");
#line 980
    _E__die_error("Bad lw1 argument (%d) to lm_tglist\n", (int )lw1);
  } else
#line 979
  if ((int )lw1 >= lm->n_ug) {
#line 980
    _E__pr_header("src/lm.c", 980L, "FATAL_ERROR");
#line 980
    _E__die_error("Bad lw1 argument (%d) to lm_tglist\n", (int )lw1);
  }
#line 981
  if ((int )lw2 == 65535) {
#line 982
    _E__pr_header("src/lm.c", 982L, "FATAL_ERROR");
#line 982
    _E__die_error("Bad lw2 argument (%d) to lm_tglist\n", (int )lw2);
  } else
#line 981
  if ((int )lw2 >= lm->n_ug) {
#line 982
    _E__pr_header("src/lm.c", 982L, "FATAL_ERROR");
#line 982
    _E__die_error("Bad lw2 argument (%d) to lm_tglist\n", (int )lw2);
  }
#line 984
  prev_tginfo = (tginfo_t *)((void *)0);
#line 985
  tginfo = *(lm->tginfo + lw2);
#line 985
  while (tginfo) {
#line 986
    if ((int )tginfo->w1 == (int )lw1) {
#line 987
      break;
    }
#line 988
    prev_tginfo = tginfo;
#line 985
    tginfo = tginfo->next;
  }
#line 991
  if (! tginfo) {
#line 992
    load_tg(lm, lw1, lw2);
#line 993
    tginfo = *(lm->tginfo + lw2);
  } else
#line 994
  if (prev_tginfo) {
#line 995
    prev_tginfo->next = tginfo->next;
#line 996
    tginfo->next = *(lm->tginfo + lw2);
#line 997
    *(lm->tginfo + lw2) = tginfo;
  }
#line 999
  tginfo->used = 1;
#line 1001
  *tgptr = tginfo->tg;
#line 1002
  *bowt = tginfo->bowt;
#line 1004
  return (tginfo->n_tg);
}
}
#line 1008 "src/lm.c"
int32 lm_tg_score(lm_t *lm , s3lmwid_t lw1 , s3lmwid_t lw2 , s3lmwid_t lw3 ) 
{ 
  int32 i ;
  int32 h ;
  int32 n ;
  int32 score ;
  tg_t *tg ;
  tginfo_t *tginfo ;
  tginfo_t *prev_tginfo ;
  int32 tmp ;
  int32 tmp___0 ;

  {
#line 1014
  if (lm->n_tg == 0) {
#line 1015
    tmp = lm_bg_score(lm, lw2, lw3);
#line 1015
    return (tmp);
  } else
#line 1014
  if ((int )lw1 == 65535) {
#line 1015
    tmp = lm_bg_score(lm, lw2, lw3);
#line 1015
    return (tmp);
  }
#line 1017
  (lm->n_tg_score) ++;
#line 1019
  if ((int )lw1 == 65535) {
#line 1020
    _E__pr_header("src/lm.c", 1020L, "FATAL_ERROR");
#line 1020
    _E__die_error("Bad lw1 argument (%d) to lm_tg_score\n", (int )lw1);
  } else
#line 1019
  if ((int )lw1 >= lm->n_ug) {
#line 1020
    _E__pr_header("src/lm.c", 1020L, "FATAL_ERROR");
#line 1020
    _E__die_error("Bad lw1 argument (%d) to lm_tg_score\n", (int )lw1);
  }
#line 1021
  if ((int )lw2 == 65535) {
#line 1022
    _E__pr_header("src/lm.c", 1022L, "FATAL_ERROR");
#line 1022
    _E__die_error("Bad lw2 argument (%d) to lm_tg_score\n", (int )lw2);
  } else
#line 1021
  if ((int )lw2 >= lm->n_ug) {
#line 1022
    _E__pr_header("src/lm.c", 1022L, "FATAL_ERROR");
#line 1022
    _E__die_error("Bad lw2 argument (%d) to lm_tg_score\n", (int )lw2);
  }
#line 1023
  if ((int )lw3 == 65535) {
#line 1024
    _E__pr_header("src/lm.c", 1024L, "FATAL_ERROR");
#line 1024
    _E__die_error("Bad lw3 argument (%d) to lm_tg_score\n", (int )lw3);
  } else
#line 1023
  if ((int )lw3 >= lm->n_ug) {
#line 1024
    _E__pr_header("src/lm.c", 1024L, "FATAL_ERROR");
#line 1024
    _E__die_error("Bad lw3 argument (%d) to lm_tg_score\n", (int )lw3);
  }
#line 1027
  h = ((((int )lw1 & 1023) << 21) + (((int )lw2 & 1023) << 11)) + ((int )lw3 & 2047);
#line 1028
  h %= 100003;
#line 1029
  if ((int )(lm->tgcache + h)->lwid[0] == (int )lw1) {
#line 1029
    if ((int )(lm->tgcache + h)->lwid[1] == (int )lw2) {
#line 1029
      if ((int )(lm->tgcache + h)->lwid[2] == (int )lw3) {
#line 1032
        (lm->n_tgcache_hit) ++;
#line 1033
        return ((lm->tgcache + h)->lscr);
      }
    }
  }
#line 1036
  prev_tginfo = (tginfo_t *)((void *)0);
#line 1037
  tginfo = *(lm->tginfo + lw2);
#line 1037
  while (tginfo) {
#line 1038
    if ((int )tginfo->w1 == (int )lw1) {
#line 1039
      break;
    }
#line 1040
    prev_tginfo = tginfo;
#line 1037
    tginfo = tginfo->next;
  }
#line 1043
  if (! tginfo) {
#line 1044
    load_tg(lm, lw1, lw2);
#line 1045
    tginfo = *(lm->tginfo + lw2);
  } else
#line 1046
  if (prev_tginfo) {
#line 1047
    prev_tginfo->next = tginfo->next;
#line 1048
    tginfo->next = *(lm->tginfo + lw2);
#line 1049
    *(lm->tginfo + lw2) = tginfo;
  }
#line 1052
  tginfo->used = 1;
#line 1055
  n = tginfo->n_tg;
#line 1056
  tg = tginfo->tg;
#line 1057
  i = find_tg(tg, n, lw3);
#line 1057
  if (i >= 0) {
#line 1058
    score = (lm->tgprob + (tg + i)->probid)->l;
#line 1059
    lm->access_type = 3;
  } else {
#line 1061
    (lm->n_tg_bo) ++;
#line 1062
    tmp___0 = lm_bg_score(lm, lw2, lw3);
#line 1062
    score = tginfo->bowt + tmp___0;
  }
#line 1069
  (lm->tgcache + h)->lwid[0] = lw1;
#line 1070
  (lm->tgcache + h)->lwid[1] = lw2;
#line 1071
  (lm->tgcache + h)->lwid[2] = lw3;
#line 1072
  (lm->tgcache + h)->lscr = score;
#line 1074
  return (score);
}
}
#line 1078 "src/lm.c"
s3lmwid_t lm_wid(lm_t *lm , char *word ) 
{ 
  int32 i ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___0 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
#line 1082
  i = 0;
#line 1082
  while (i < lm->n_ug) {
#line 1083
    if (0) {
#line 1083
      __s1_len = __builtin_strlen((char const   *)*(lm->wordstr + i));
#line 1083
      __s2_len = __builtin_strlen((char const   *)word);
#line 1083
      if (! ((size_t )((void const   *)(*(lm->wordstr + i) + 1)) - (size_t )((void const   *)*(lm->wordstr + i)) == 1UL)) {
#line 1083
        goto _L___0;
      } else
#line 1083
      if (__s1_len >= 4UL) {
        _L___0: /* CIL Label */ 
#line 1083
        if (! ((size_t )((void const   *)(word + 1)) - (size_t )((void const   *)word) == 1UL)) {
#line 1083
          tmp___5 = 1;
        } else
#line 1083
        if (__s2_len >= 4UL) {
#line 1083
          tmp___5 = 1;
        } else {
#line 1083
          tmp___5 = 0;
        }
      } else {
#line 1083
        tmp___5 = 0;
      }
#line 1083
      if (tmp___5) {
#line 1083
        tmp___0 = __builtin_strcmp((char const   *)*(lm->wordstr + i), (char const   *)word);
#line 1083
        tmp___4 = tmp___0;
      } else {
#line 1083
        tmp___3 = __builtin_strcmp((char const   *)*(lm->wordstr + i), (char const   *)word);
#line 1083
        tmp___4 = tmp___3;
      }
    } else {
#line 1083
      tmp___3 = __builtin_strcmp((char const   *)*(lm->wordstr + i), (char const   *)word);
#line 1083
      tmp___4 = tmp___3;
    }
#line 1083
    if (tmp___4 == 0) {
#line 1084
      return ((s3lmwid_t )i);
    }
#line 1082
    i ++;
  }
#line 1086
  return ((s3lmwid_t )65535);
}
}
#line 1089 "src/lm.c"
void lm_free(lm_t *lm ) 
{ 
  int i ;

  {
#line 1093
  i = 0;
#line 1093
  while (i < lm->n_ug) {
#line 1094
    free((void *)*(lm->wordstr + i));
#line 1093
    i ++;
  }
#line 1095
  free((void *)lm->membg);
#line 1096
  free((void *)lm->wordstr);
#line 1097
  free((void *)lm->tgcache);
#line 1098
  free((void *)lm->tg_segbase);
#line 1099
  free((void *)lm->tgprob);
#line 1100
  free((void *)lm->tgbowt);
#line 1101
  free((void *)lm->bgprob);
#line 1102
  free((void *)lm->tginfo);
#line 1103
  free((void *)lm->ug);
#line 1104
  free((void *)lm);
#line 1106
  return;
}
}
#line 1 "wid.o"
#pragma merger("0","/tmp/cil-Nrm18VVP.i","-g,-O4")
#line 150 "/usr/include/x86_64-linux-gnu/bits/mathinline.h"
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__, __always_inline__)) __signbitl)(long double __x )  __attribute__((__const__)) ;
#line 150 "/usr/include/x86_64-linux-gnu/bits/mathinline.h"
__inline extern int ( __attribute__((__leaf__, __always_inline__)) __signbitl)(long double __x ) 
{ 
  union __anonunion___u_29___10 __u ;

  {
#line 153
  __u.__l = __x;
#line 154
  return ((__u.__i[2] & 32768) != 0);
}
}
#line 120 "src/wid.h"
s3lmwid_t *wid_dict_lm_map(dict_t *dict , lm_t *lm ) ;
#line 128
int32 wid_wordprob2alt(dict_t *dict , wordprob_t *wp , int32 n ) ;
#line 107 "src/wid.c"
s3lmwid_t *wid_dict_lm_map(dict_t *dict , lm_t *lm ) 
{ 
  int32 u ;
  int32 n ;
  s3wid_t w___0 ;
  s3lmwid_t *map ;
  void *tmp ;
  int32 tmp___0 ;

  {
#line 113
  if (! (dict->n_word > 0)) {
#line 113
    __assert_fail("((dict)->n_word) > 0", "src/wid.c", 113U, "wid_dict_lm_map");
  }
#line 114
  tmp = __ckd_calloc__((size_t )dict->n_word, sizeof(s3lmwid_t ), "src/wid.c", 114);
#line 114
  map = (s3lmwid_t *)tmp;
#line 115
  n = 0;
#line 115
  while (n < dict->n_word) {
#line 116
    *(map + n) = (s3lmwid_t )65535;
#line 115
    n ++;
  }
#line 118
  n = 0;
#line 119
  u = 0;
#line 119
  while (u < lm->n_ug) {
#line 120
    w___0 = dict_wordid(dict, *(lm->wordstr + u));
#line 121
    (lm->ug + u)->dictwid = w___0;
#line 123
    if (w___0 < 0) {
#line 124
      n ++;
    } else {
#line 126
      tmp___0 = dict_filler_word(dict, w___0);
#line 126
      if (tmp___0) {
#line 127
        _E__pr_header("src/wid.c", 127L, "ERROR");
#line 127
        _E__pr_warn("Filler dictionary word \'%s\' found in LM\n", *(lm->wordstr + u));
      }
#line 129
      if (w___0 != (dict->word + w___0)->basewid) {
#line 130
        _E__pr_header("src/wid.c", 130L, "ERROR");
#line 130
        _E__pr_warn("LM word \'%s\' is an alternative pronunciation in dictionary\n",
                    *(lm->wordstr + u));
#line 133
        w___0 = (dict->word + w___0)->basewid;
#line 134
        (lm->ug + u)->dictwid = w___0;
      }
#line 137
      while (w___0 >= 0) {
#line 138
        *(map + w___0) = (s3lmwid_t )u;
#line 137
        w___0 = (dict->word + w___0)->alt;
      }
    }
#line 119
    u ++;
  }
#line 142
  if (n > 0) {
#line 143
    _E__pr_info_header("src/wid.c", 143L, "INFO");
#line 143
    _E__pr_info("%d LM words not in dictionary; ignored\n", n);
  }
#line 145
  return (map);
}
}
#line 149 "src/wid.c"
int32 wid_wordprob2alt(dict_t *dict , wordprob_t *wp , int32 n ) 
{ 
  int32 i ;
  int32 j ;
  s3wid_t w___0 ;

  {
#line 154
  i = 0;
#line 154
  j = n;
#line 154
  while (i < n) {
#line 155
    w___0 = (wp + i)->wid;
#line 157
    w___0 = (dict->word + w___0)->alt;
#line 157
    while (w___0 >= 0) {
#line 158
      (wp + j)->wid = w___0;
#line 159
      (wp + j)->prob = (wp + i)->prob;
#line 160
      j ++;
#line 157
      w___0 = (dict->word + w___0)->alt;
    }
#line 154
    i ++;
  }
#line 164
  return (j);
}
}
#line 1 "tmat.o"
#pragma merger("0","/tmp/cil-7TYItAL1.i","-g,-O4")
#line 150 "/usr/include/x86_64-linux-gnu/bits/mathinline.h"
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__, __always_inline__)) __signbitl)(long double __x )  __attribute__((__const__)) ;
#line 150 "/usr/include/x86_64-linux-gnu/bits/mathinline.h"
__inline extern int ( __attribute__((__leaf__, __always_inline__)) __signbitl)(long double __x ) 
{ 
  union __anonunion___u_29___11 __u ;

  {
#line 153
  __u.__l = __x;
#line 154
  return ((__u.__i[2] & 32768) != 0);
}
}
#line 134 "src/tmat.h"
tmat_t *tmat_init(char *file_name , float64 tpfloor ) ;
#line 138
void tmat_dump(tmat_t *tmat , FILE *fp ) ;
#line 145
int32 tmat_chk_uppertri(tmat_t *tmat ) ;
#line 152
int32 tmat_chk_1skip(tmat_t *tmat ) ;
#line 157
void tmat_free(tmat_t *t ) ;
#line 122 "src/tmat.c"
void tmat_dump(tmat_t *tmat , FILE *fp ) 
{ 
  int32 i ;
  int32 src ;
  int32 dst ;

  {
#line 126
  i = 0;
#line 126
  while (i < tmat->n_tmat) {
#line 127
    fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"TMAT %d = %d x %d\n",
            i, tmat->n_state, tmat->n_state + 1);
#line 128
    src = 0;
#line 128
    while (src < tmat->n_state) {
#line 129
      dst = 0;
#line 129
      while (dst <= tmat->n_state) {
#line 130
        fprintf((FILE * __restrict  )fp, (char const   * __restrict  )" %12d", *(*(*(tmat->tp + i) + src) + dst));
#line 129
        dst ++;
      }
#line 131
      fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"\n");
#line 128
      src ++;
    }
#line 133
    fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"\n");
#line 126
    i ++;
  }
#line 135
  fflush(fp);
#line 136
  return;
}
}
#line 143 "src/tmat.c"
int32 tmat_chk_uppertri(tmat_t *tmat ) 
{ 
  int32 i ;
  int32 src ;
  int32 dst ;

  {
#line 148
  i = 0;
#line 148
  while (i < tmat->n_tmat) {
#line 149
    dst = 0;
#line 149
    while (dst < tmat->n_state) {
#line 150
      src = dst + 1;
#line 150
      while (src < tmat->n_state) {
#line 151
        if (*(*(*(tmat->tp + i) + src) + dst) > -939524096) {
#line 152
          return (-1);
        }
#line 150
        src ++;
      }
#line 149
      dst ++;
    }
#line 148
    i ++;
  }
#line 155
  return (0);
}
}
#line 159 "src/tmat.c"
int32 tmat_chk_1skip(tmat_t *tmat ) 
{ 
  int32 i ;
  int32 src ;
  int32 dst ;

  {
#line 163
  i = 0;
#line 163
  while (i < tmat->n_tmat) {
#line 164
    src = 0;
#line 164
    while (src < tmat->n_state) {
#line 165
      dst = src + 3;
#line 165
      while (dst <= tmat->n_state) {
#line 166
        if (*(*(*(tmat->tp + i) + src) + dst) > -939524096) {
#line 167
          return (-1);
        }
#line 165
        dst ++;
      }
#line 164
      src ++;
    }
#line 163
    i ++;
  }
#line 170
  return (0);
}
}
#line 174 "src/tmat.c"
tmat_t *tmat_init(char *file_name , float64 tpfloor ) 
{ 
  char tmp ;
  int32 n_src ;
  int32 n_dst ;
  FILE *fp ;
  int32 byteswap ;
  int32 chksum_present ;
  uint32 chksum ;
  float32 **tp ;
  int32 i ;
  int32 j ;
  int32 k___0 ;
  int32 tp_per_tmat ;
  char **argname ;
  char **argval___0 ;
  tmat_t *t ;
  void *tmp___0 ;
  int32 tmp___1 ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___3 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___10 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  size_t __s1_len___1 ;
  size_t __s2_len___1 ;
  int tmp___17 ;
  int tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  int32 tmp___23 ;
  int32 tmp___24 ;
  int32 tmp___25 ;
  int32 tmp___26 ;
  void ***tmp___27 ;
  void **tmp___28 ;
  int32 tmp___29 ;
  float64 tmp___30 ;
  int32 tmp___31 ;
  size_t tmp___32 ;
  int32 tmp___33 ;

  {
#line 186
  _E__pr_info_header("src/tmat.c", 186L, "INFO");
#line 186
  _E__pr_info("Reading HMM transition probability matrices: %s\n", file_name);
#line 188
  tmp___0 = __ckd_calloc__((size_t )1, sizeof(tmat_t ), "src/tmat.c", 188);
#line 188
  t = (tmat_t *)tmp___0;
#line 190
  fp = fopen((char const   * __restrict  )file_name, (char const   * __restrict  )"rb");
#line 190
  if ((unsigned long )fp == (unsigned long )((void *)0)) {
#line 191
    _E__pr_header("src/tmat.c", 191L, "SYSTEM_ERROR");
#line 191
    _E__fatal_sys_error("fopen(%s,rb) failed\n", file_name);
  }
#line 194
  tmp___1 = bio_readhdr(fp, & argname, & argval___0, & byteswap);
#line 194
  if (tmp___1 < 0) {
#line 195
    _E__pr_header("src/tmat.c", 195L, "FATAL_ERROR");
#line 195
    _E__die_error("bio_readhdr(%s) failed\n", file_name);
  }
#line 198
  chksum_present = 0;
#line 199
  i = 0;
#line 199
  while (*(argname + i)) {
#line 200
    if (0) {
#line 200
      __s1_len___1 = __builtin_strlen((char const   *)*(argname + i));
#line 200
      __s2_len___1 = __builtin_strlen("version");
#line 200
      if (! ((size_t )((void const   *)(*(argname + i) + 1)) - (size_t )((void const   *)*(argname + i)) == 1UL)) {
#line 200
        goto _L___4;
      } else
#line 200
      if (__s1_len___1 >= 4UL) {
        _L___4: /* CIL Label */ 
#line 200
        if (! ((size_t )((void const   *)("version" + 1)) - (size_t )((void const   *)"version") == 1UL)) {
#line 200
          tmp___22 = 1;
        } else
#line 200
        if (__s2_len___1 >= 4UL) {
#line 200
          tmp___22 = 1;
        } else {
#line 200
          tmp___22 = 0;
        }
      } else {
#line 200
        tmp___22 = 0;
      }
#line 200
      if (tmp___22) {
#line 200
        tmp___17 = __builtin_strcmp((char const   *)*(argname + i), "version");
#line 200
        tmp___21 = tmp___17;
      } else {
#line 200
        tmp___20 = __builtin_strcmp((char const   *)*(argname + i), "version");
#line 200
        tmp___21 = tmp___20;
      }
    } else {
#line 200
      tmp___20 = __builtin_strcmp((char const   *)*(argname + i), "version");
#line 200
      tmp___21 = tmp___20;
    }
#line 200
    if (tmp___21 == 0) {
#line 201
      if (0) {
#line 201
        __s1_len = __builtin_strlen((char const   *)*(argval___0 + i));
#line 201
        __s2_len = __builtin_strlen("1.0");
#line 201
        if (! ((size_t )((void const   *)(*(argval___0 + i) + 1)) - (size_t )((void const   *)*(argval___0 + i)) == 1UL)) {
#line 201
          goto _L___0;
        } else
#line 201
        if (__s1_len >= 4UL) {
          _L___0: /* CIL Label */ 
#line 201
          if (! ((size_t )((void const   *)("1.0" + 1)) - (size_t )((void const   *)"1.0") == 1UL)) {
#line 201
            tmp___8 = 1;
          } else
#line 201
          if (__s2_len >= 4UL) {
#line 201
            tmp___8 = 1;
          } else {
#line 201
            tmp___8 = 0;
          }
        } else {
#line 201
          tmp___8 = 0;
        }
#line 201
        if (tmp___8) {
#line 201
          tmp___3 = __builtin_strcmp((char const   *)*(argval___0 + i), "1.0");
#line 201
          tmp___7 = tmp___3;
        } else {
#line 201
          tmp___6 = __builtin_strcmp((char const   *)*(argval___0 + i), "1.0");
#line 201
          tmp___7 = tmp___6;
        }
      } else {
#line 201
        tmp___6 = __builtin_strcmp((char const   *)*(argval___0 + i), "1.0");
#line 201
        tmp___7 = tmp___6;
      }
#line 201
      if (tmp___7 != 0) {
#line 202
        _E__pr_header("src/tmat.c", 202L, "WARNING");
#line 202
        _E__pr_warn("Version mismatch(%s): %s, expecting %s\n", file_name, *(argval___0 + i),
                    "1.0");
      }
    } else {
#line 204
      if (0) {
#line 204
        __s1_len___0 = __builtin_strlen((char const   *)*(argname + i));
#line 204
        __s2_len___0 = __builtin_strlen("chksum0");
#line 204
        if (! ((size_t )((void const   *)(*(argname + i) + 1)) - (size_t )((void const   *)*(argname + i)) == 1UL)) {
#line 204
          goto _L___2;
        } else
#line 204
        if (__s1_len___0 >= 4UL) {
          _L___2: /* CIL Label */ 
#line 204
          if (! ((size_t )((void const   *)("chksum0" + 1)) - (size_t )((void const   *)"chksum0") == 1UL)) {
#line 204
            tmp___15 = 1;
          } else
#line 204
          if (__s2_len___0 >= 4UL) {
#line 204
            tmp___15 = 1;
          } else {
#line 204
            tmp___15 = 0;
          }
        } else {
#line 204
          tmp___15 = 0;
        }
#line 204
        if (tmp___15) {
#line 204
          tmp___10 = __builtin_strcmp((char const   *)*(argname + i), "chksum0");
#line 204
          tmp___14 = tmp___10;
        } else {
#line 204
          tmp___13 = __builtin_strcmp((char const   *)*(argname + i), "chksum0");
#line 204
          tmp___14 = tmp___13;
        }
      } else {
#line 204
        tmp___13 = __builtin_strcmp((char const   *)*(argname + i), "chksum0");
#line 204
        tmp___14 = tmp___13;
      }
#line 204
      if (tmp___14 == 0) {
#line 205
        chksum_present = 1;
      }
    }
#line 199
    i ++;
  }
#line 208
  bio_hdrarg_free(argname, argval___0);
#line 209
  argval___0 = (char **)((void *)0);
#line 209
  argname = argval___0;
#line 211
  chksum = (uint32 )0;
#line 214
  tmp___23 = bio_fread((void *)(& t->n_tmat), (int32 )sizeof(int32 ), 1, fp, byteswap,
                       & chksum);
#line 214
  if (tmp___23 != 1) {
#line 218
    _E__pr_header("src/tmat.c", 218L, "FATAL_ERROR");
#line 218
    _E__die_error("bio_fread(%s) (arraysize) failed\n", file_name);
  } else {
#line 214
    tmp___24 = bio_fread((void *)(& n_src), (int32 )sizeof(int32 ), 1, fp, byteswap,
                         & chksum);
#line 214
    if (tmp___24 != 1) {
#line 218
      _E__pr_header("src/tmat.c", 218L, "FATAL_ERROR");
#line 218
      _E__die_error("bio_fread(%s) (arraysize) failed\n", file_name);
    } else {
#line 214
      tmp___25 = bio_fread((void *)(& n_dst), (int32 )sizeof(int32 ), 1, fp, byteswap,
                           & chksum);
#line 214
      if (tmp___25 != 1) {
#line 218
        _E__pr_header("src/tmat.c", 218L, "FATAL_ERROR");
#line 218
        _E__die_error("bio_fread(%s) (arraysize) failed\n", file_name);
      } else {
#line 214
        tmp___26 = bio_fread((void *)(& i), (int32 )sizeof(int32 ), 1, fp, byteswap,
                             & chksum);
#line 214
        if (tmp___26 != 1) {
#line 218
          _E__pr_header("src/tmat.c", 218L, "FATAL_ERROR");
#line 218
          _E__die_error("bio_fread(%s) (arraysize) failed\n", file_name);
        }
      }
    }
  }
#line 220
  if (t->n_tmat >= 2147483646) {
#line 221
    _E__pr_header("src/tmat.c", 221L, "FATAL_ERROR");
#line 221
    _E__die_error("%s: #tmat (%d) exceeds limit (%d)\n", file_name, t->n_tmat, 2147483646);
  }
#line 222
  if (n_dst != n_src + 1) {
#line 223
    _E__pr_header("src/tmat.c", 223L, "FATAL_ERROR");
#line 223
    _E__die_error("%s: #from-states(%d) != #to-states(%d)-1\n", file_name, n_src,
                  n_dst);
  }
#line 224
  t->n_state = n_src;
#line 226
  if (i != (t->n_tmat * n_src) * n_dst) {
#line 227
    _E__pr_header("src/tmat.c", 227L, "FATAL_ERROR");
#line 227
    _E__die_error("%s: #float32s(%d) doesn\'t match dimensions: %d x %d x %d\n", file_name,
                  i, t->n_tmat, n_src, n_dst);
  }
#line 232
  tmp___27 = __ckd_calloc_3d__(t->n_tmat, n_src, n_dst, (int32 )sizeof(int32 ), "src/tmat.c",
                               232);
#line 232
  t->tp = (int32 ***)tmp___27;
#line 235
  tmp___28 = __ckd_calloc_2d__(n_src, n_dst, (int32 )sizeof(float32 ), "src/tmat.c",
                               235);
#line 235
  tp = (float32 **)tmp___28;
#line 238
  tp_per_tmat = n_src * n_dst;
#line 239
  i = 0;
#line 239
  while (i < t->n_tmat) {
#line 240
    tmp___29 = bio_fread((void *)*(tp + 0), (int32 )sizeof(float32 ), tp_per_tmat,
                         fp, byteswap, & chksum);
#line 240
    if (tmp___29 != tp_per_tmat) {
#line 242
      _E__pr_header("src/tmat.c", 242L, "FATAL_ERROR");
#line 242
      _E__die_error("fread(%s) (arraydata) failed\n", file_name);
    }
#line 246
    j = 0;
#line 246
    while (j < n_src) {
#line 247
      tmp___30 = vector_sum_norm(*(tp + j), n_dst);
#line 247
      if (tmp___30 == 0.0) {
#line 248
        _E__pr_header("src/tmat.c", 248L, "ERROR");
#line 248
        _E__pr_warn("Normalization failed for tmat %d from state %d\n", i, j);
      }
#line 249
      vector_nz_floor(*(tp + j), n_dst, tpfloor);
#line 250
      vector_sum_norm(*(tp + j), n_dst);
#line 253
      k___0 = 0;
#line 253
      while (k___0 < n_dst) {
#line 254
        if ((double )*(*(tp + j) + k___0) == 0.0) {
#line 254
          *(*(*(t->tp + i) + j) + k___0) = (int32 )3355443200U;
        } else {
#line 254
          tmp___31 = logs3((float64 )*(*(tp + j) + k___0));
#line 254
          *(*(*(t->tp + i) + j) + k___0) = tmp___31;
        }
#line 253
        k___0 ++;
      }
#line 246
      j ++;
    }
#line 239
    i ++;
  }
#line 258
  ckd_free_2d((void **)tp);
#line 260
  if (chksum_present) {
#line 261
    bio_verify_chksum(fp, byteswap, chksum);
  }
#line 263
  tmp___32 = fread((void * __restrict  )(& tmp), (size_t )1, (size_t )1, (FILE * __restrict  )fp);
#line 263
  if (tmp___32 == 1UL) {
#line 264
    _E__pr_header("src/tmat.c", 264L, "ERROR");
#line 264
    _E__pr_warn("Non-empty file beyond end of data\n");
  }
#line 266
  fclose(fp);
#line 268
  _E__pr_info_header("src/tmat.c", 268L, "INFO");
#line 268
  _E__pr_info("Read %d transition matrices of size %dx%d\n", t->n_tmat, t->n_state,
              t->n_state + 1);
#line 271
  tmp___33 = tmat_chk_uppertri(t);
#line 271
  if (tmp___33 < 0) {
#line 272
    _E__pr_header("src/tmat.c", 272L, "FATAL_ERROR");
#line 272
    _E__die_error("Tmat not upper triangular\n");
  }
#line 274
  return (t);
}
}
#line 280 "src/tmat.c"
void tmat_free(tmat_t *t ) 
{ 


  {
#line 282
  if (t) {
#line 283
    if (t->tp) {
#line 284
      ckd_free_3d((void ***)t->tp);
    }
#line 285
    free((void *)t);
  }
#line 287
  return;
}
}
#line 1 "kbcore.o"
#pragma merger("0","/tmp/cil-VOTfg3_H.i","-g,-O4")
#line 150 "/usr/include/x86_64-linux-gnu/bits/mathinline.h"
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__, __always_inline__)) __signbitl)(long double __x )  __attribute__((__const__)) ;
#line 150 "/usr/include/x86_64-linux-gnu/bits/mathinline.h"
__inline extern int ( __attribute__((__leaf__, __always_inline__)) __signbitl)(long double __x ) 
{ 
  union __anonunion___u_29___12 __u ;

  {
#line 153
  __u.__l = __x;
#line 154
  return ((__u.__i[2] & 32768) != 0);
}
}
#line 234 "src/feat.h"
feat_t *feat_init(char *type , char *cmn___0 , char *varnorm , char *agc ) ;
#line 295
void feat_free(feat_t *f ) ;
#line 154 "src/kbcore.h"
kbcore_t *kbcore_init(float64 logbase , char *feattype , char *cmn___0 , char *varnorm ,
                      char *agc , char *mdeffile , char *dictfile , char *fdictfile ,
                      char *compsep , char *lmfile , char *fillpenfile , float64 silprob ,
                      float64 fillprob , float64 langwt , float64 inspen , float64 uw ,
                      char *meanfile , char *varfile , float64 varfloor , char *mixwfile ,
                      float64 mixwfloor , char *subvqfile , char *tmatfile , float64 tmatfloor ) ;
#line 185
void kbcore_free(kbcore_t *kbcore___0 ) ;
#line 114 "src/kbcore.c"
kbcore_t *kbcore_init(float64 logbase , char *feattype , char *cmn___0 , char *varnorm ,
                      char *agc , char *mdeffile , char *dictfile , char *fdictfile ,
                      char *compsep , char *lmfile , char *fillpenfile , float64 silprob ,
                      float64 fillprob , float64 langwt , float64 inspen , float64 uw ,
                      char *meanfile , char *varfile , float64 varfloor , char *mixwfile ,
                      float64 mixwfloor , char *subvqfile , char *tmatfile , float64 tmatfloor ) 
{ 
  kbcore_t *kb___0 ;
  void *tmp ;
  feat_t *tmp___0 ;
  mdef_t *tmp___1 ;
  char const   *tmp___2 ;
  dict_t *tmp___3 ;
  lm_t *tmp___4 ;
  fillpen_t *tmp___5 ;
  subvq_t *tmp___6 ;
  tmat_t *tmp___7 ;
  s3lmwid_t *tmp___8 ;

  {
#line 141
  _E__pr_info_header("src/kbcore.c", 141L, "INFO");
#line 141
  _E__pr_info("Initializing core models:\n");
#line 143
  tmp = __ckd_calloc__((size_t )1, sizeof(kbcore_t ), "src/kbcore.c", 143);
#line 143
  kb___0 = (kbcore_t *)tmp;
#line 144
  kb___0->fcb = (feat_t *)((void *)0);
#line 145
  kb___0->mdef = (mdef_t *)((void *)0);
#line 146
  kb___0->dict = (dict_t *)((void *)0);
#line 147
  kb___0->dict2pid = (dict2pid_t *)((void *)0);
#line 148
  kb___0->lm = (lm_t *)((void *)0);
#line 149
  kb___0->fillpen = (fillpen_t *)((void *)0);
#line 150
  kb___0->dict2lmwid = (s3lmwid_t *)((void *)0);
#line 151
  kb___0->mgau = (mgau_model_t *)((void *)0);
#line 152
  kb___0->svq = (subvq_t *)((void *)0);
#line 153
  kb___0->tmat = (tmat_t *)((void *)0);
#line 155
  logs3_init(logbase);
#line 157
  if (feattype) {
#line 158
    tmp___0 = feat_init(feattype, cmn___0, varnorm, agc);
#line 158
    kb___0->fcb = tmp___0;
#line 158
    if ((unsigned long )tmp___0 == (unsigned long )((void *)0)) {
#line 159
      _E__pr_header("src/kbcore.c", 159L, "FATAL_ERROR");
#line 159
      _E__die_error("feat_init(%s) failed\n", feattype);
    }
#line 160
    if ((kb___0->fcb)->n_stream != 1) {
#line 161
      _E__pr_header("src/kbcore.c", 161L, "FATAL_ERROR");
#line 161
      _E__die_error("#Feature streams(%d) != 1\n", (kb___0->fcb)->n_stream);
    }
  }
#line 164
  if (mdeffile) {
#line 165
    tmp___1 = mdef_init(mdeffile);
#line 165
    kb___0->mdef = tmp___1;
#line 165
    if ((unsigned long )tmp___1 == (unsigned long )((void *)0)) {
#line 166
      _E__pr_header("src/kbcore.c", 166L, "FATAL_ERROR");
#line 166
      _E__die_error("mdef_init(%s) failed\n", mdeffile);
    }
  }
#line 169
  if (dictfile) {
#line 170
    if (! compsep) {
#line 171
      compsep = (char *)"";
    } else
#line 172
    if ((int )*(compsep + 0) != 0) {
#line 172
      if ((int )*(compsep + 1) != 0) {
#line 173
        _E__pr_header("src/kbcore.c", 173L, "FATAL_ERROR");
#line 173
        _E__die_error("Compound word separator(%s) must be empty or single character string\n",
                      compsep);
      }
    }
#line 176
    tmp___3 = dict_init(kb___0->mdef, dictfile, fdictfile, *(compsep + 0));
#line 176
    kb___0->dict = tmp___3;
#line 176
    if ((unsigned long )tmp___3 == (unsigned long )((void *)0)) {
#line 177
      _E__pr_header("src/kbcore.c", 177L, "FATAL_ERROR");
#line 177
      if (fdictfile) {
#line 177
        tmp___2 = (char const   *)fdictfile;
      } else {
#line 177
        tmp___2 = "";
      }
#line 177
      _E__die_error("dict_init(%s,%s,%s) failed\n", dictfile, tmp___2, compsep);
    }
  }
#line 181
  if (lmfile) {
#line 182
    tmp___4 = lm_read(lmfile, langwt, inspen, uw);
#line 182
    kb___0->lm = tmp___4;
#line 182
    if ((unsigned long )tmp___4 == (unsigned long )((void *)0)) {
#line 183
      _E__pr_header("src/kbcore.c", 183L, "FATAL_ERROR");
#line 183
      _E__die_error("lm_read(%s, %e, %e, %e) failed\n", lmfile, langwt, inspen, uw);
    }
  }
#line 186
  if (fillpenfile) {
#line 186
    goto _L;
  } else
#line 186
  if (lmfile) {
#line 186
    if (kb___0->dict) {
      _L: /* CIL Label */ 
#line 187
      if (! kb___0->dict) {
#line 188
        _E__pr_header("src/kbcore.c", 188L, "FATAL_ERROR");
#line 188
        _E__die_error("No dictionary for associating filler penalty file(%s)\n", fillpenfile);
      }
#line 190
      tmp___5 = fillpen_init(kb___0->dict, fillpenfile, silprob, fillprob, langwt,
                             inspen);
#line 190
      kb___0->fillpen = tmp___5;
#line 190
      if ((unsigned long )tmp___5 == (unsigned long )((void *)0)) {
#line 192
        _E__pr_header("src/kbcore.c", 192L, "FATAL_ERROR");
#line 192
        _E__die_error("fillpen_init(%s) failed\n", fillpenfile);
      }
    }
  }
#line 195
  if (meanfile) {
#line 196
    if (! varfile) {
#line 197
      _E__pr_header("src/kbcore.c", 197L, "FATAL_ERROR");
#line 197
      _E__die_error("Varfile or mixwfile not specified along with meanfile(%s)\n",
                    meanfile);
    } else
#line 196
    if (! mixwfile) {
#line 197
      _E__pr_header("src/kbcore.c", 197L, "FATAL_ERROR");
#line 197
      _E__die_error("Varfile or mixwfile not specified along with meanfile(%s)\n",
                    meanfile);
    }
#line 198
    kb___0->mgau = mgau_init(meanfile, varfile, varfloor, mixwfile, mixwfloor, 1);
#line 199
    if ((unsigned long )kb___0->mgau == (unsigned long )((void *)0)) {
#line 200
      _E__pr_header("src/kbcore.c", 200L, "FATAL_ERROR");
#line 200
      _E__die_error("gauden_init(%s, %s, %e) failed\n", meanfile, varfile, varfloor);
    }
#line 202
    if (subvqfile) {
#line 203
      tmp___6 = subvq_init(subvqfile, varfloor, -1, kb___0->mgau);
#line 203
      kb___0->svq = tmp___6;
#line 203
      if ((unsigned long )tmp___6 == (unsigned long )((void *)0)) {
#line 204
        _E__pr_header("src/kbcore.c", 204L, "FATAL_ERROR");
#line 204
        _E__die_error("subvq_init (%s, %e, -1) failed\n", subvqfile, varfloor);
      }
    }
  }
#line 208
  if (tmatfile) {
#line 209
    tmp___7 = tmat_init(tmatfile, tmatfloor);
#line 209
    kb___0->tmat = tmp___7;
#line 209
    if ((unsigned long )tmp___7 == (unsigned long )((void *)0)) {
#line 210
      _E__pr_header("src/kbcore.c", 210L, "FATAL_ERROR");
#line 210
      _E__die_error("tmat_init (%s, %e) failed\n", tmatfile, tmatfloor);
    }
  }
#line 213
  if (kb___0->dict) {
#line 213
    if (kb___0->lm) {
#line 214
      tmp___8 = wid_dict_lm_map(kb___0->dict, kb___0->lm);
#line 214
      kb___0->dict2lmwid = tmp___8;
#line 214
      if ((unsigned long )tmp___8 == (unsigned long )((void *)0)) {
#line 215
        _E__pr_header("src/kbcore.c", 215L, "FATAL_ERROR");
#line 215
        _E__die_error("Dict/LM word-id mapping failed\n");
      }
    }
  }
#line 218
  if (kb___0->mdef) {
#line 218
    if (kb___0->dict) {
#line 219
      kb___0->dict2pid = dict2pid_build(kb___0->mdef, kb___0->dict);
    }
  }
#line 223
  _E__pr_info_header("src/kbcore.c", 223L, "INFO");
#line 223
  _E__pr_info("Verifying models consistency:\n");
#line 225
  if (kb___0->fcb) {
#line 225
    if (kb___0->mgau) {
#line 227
      if (*((kb___0->fcb)->stream_len + 0) != (kb___0->mgau)->veclen) {
#line 228
        _E__pr_header("src/kbcore.c", 228L, "FATAL_ERROR");
#line 228
        _E__die_error("Feature streamlen(%d) != mgau streamlen(%d)\n", *((kb___0->fcb)->stream_len + 0),
                      (kb___0->mgau)->veclen);
      }
    }
  }
#line 232
  if (kb___0->mdef) {
#line 232
    if (kb___0->mgau) {
#line 234
      if ((kb___0->mdef)->n_sen != (kb___0->mgau)->n_mgau) {
#line 235
        _E__pr_header("src/kbcore.c", 235L, "FATAL_ERROR");
#line 235
        _E__die_error("Mdef #senones(%d) != mgau #senones(%d)\n", (kb___0->mdef)->n_sen,
                      (kb___0->mgau)->n_mgau);
      }
    }
  }
#line 239
  if (kb___0->mdef) {
#line 239
    if (kb___0->tmat) {
#line 241
      if ((kb___0->mdef)->n_tmat != (kb___0->tmat)->n_tmat) {
#line 242
        _E__pr_header("src/kbcore.c", 242L, "FATAL_ERROR");
#line 242
        _E__die_error("Mdef #tmat(%d) != tmatfile(%d)\n", (kb___0->mdef)->n_tmat,
                      (kb___0->tmat)->n_tmat);
      }
#line 243
      if ((kb___0->mdef)->n_emit_state != (kb___0->tmat)->n_state) {
#line 244
        _E__pr_header("src/kbcore.c", 244L, "FATAL_ERROR");
#line 244
        _E__die_error("Mdef #states(%d) != tmat #states(%d)\n", (kb___0->mdef)->n_emit_state,
                      (kb___0->tmat)->n_state);
      }
    }
  }
#line 248
  return (kb___0);
}
}
#line 252 "src/kbcore.c"
void kbcore_free(kbcore_t *kbcore___0 ) 
{ 
  feat_t *fcb ;
  mdef_t *mdef ;
  dict_t *dict ;
  dict2pid_t *dict2pid ;
  lm_t *lm ;

  {
#line 254
  fcb = kbcore___0->fcb;
#line 255
  mdef = kbcore___0->mdef;
#line 256
  dict = kbcore___0->dict;
#line 257
  dict2pid = kbcore___0->dict2pid;
#line 259
  lm = kbcore___0->lm;
#line 262
  lm_free(lm);
#line 265
  dict_free(dict);
#line 269
  free((void *)dict2pid->comwt);
#line 270
  free((void *)dict2pid->comsseq);
#line 271
  free((void *)dict2pid->comstate);
#line 272
  ckd_free_2d((void **)((void *)dict2pid->single_lc));
#line 273
  ckd_free_3d((void ***)dict2pid->ldiph_lc);
#line 279
  free((void *)dict2pid->internal);
#line 282
  mdef_free(mdef);
#line 284
  fillpen_free(kbcore___0->fillpen);
#line 286
  tmat_free(kbcore___0->tmat);
#line 287
  subvq_free(kbcore___0->svq);
#line 288
  mgau_free(kbcore___0->mgau);
#line 291
  if (fcb) {
#line 292
    free((void *)fcb->name);
#line 293
    free((void *)fcb->stream_len);
#line 294
    free((void *)fcb);
  }
#line 298
  logs_free();
#line 299
  feat_free(kbcore___0->fcb);
#line 302
  free((void *)kbcore___0);
#line 303
  return;
}
}
#line 1 "hmm.o"
#pragma merger("0","/tmp/cil-7gK5gUyR.i","-g,-O4")
#line 150 "/usr/include/x86_64-linux-gnu/bits/mathinline.h"
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__, __always_inline__)) __signbitl)(long double __x )  __attribute__((__const__)) ;
#line 150 "/usr/include/x86_64-linux-gnu/bits/mathinline.h"
__inline extern int ( __attribute__((__leaf__, __always_inline__)) __signbitl)(long double __x ) 
{ 
  union __anonunion___u_29___13 __u ;

  {
#line 153
  __u.__l = __x;
#line 154
  return ((__u.__i[2] & 32768) != 0);
}
}
#line 187 "src/hmm.h"
int32 hmm_vit_eval_5st(hmm_t *hmm , s3senid_t *senid , int32 *senscr ) ;
#line 200
int32 hmm_dump_vit_eval(hmm_t *hmm , int32 n_state , s3senid_t *senid , int32 *senscr ,
                        FILE *fp ) ;
#line 204
void hmm_dump(hmm_t *hmm , int32 n_state , s3senid_t *senid , int32 *senscr , FILE *fp ) ;
#line 129 "src/hmm.c"
void hmm_dump(hmm_t *hmm , int32 n_state , s3senid_t *senid , int32 *senscr , FILE *fp ) 
{ 
  int32 i ;

  {
#line 133
  fprintf((FILE * __restrict  )fp, (char const   * __restrict  )" %11d    ", hmm->in.score);
#line 134
  i = 0;
#line 134
  while (i < n_state) {
#line 135
    fprintf((FILE * __restrict  )fp, (char const   * __restrict  )" %11d", (hmm->state + i)->score);
#line 134
    i ++;
  }
#line 136
  fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"     %11d\n", hmm->out.score);
#line 138
  fprintf((FILE * __restrict  )fp, (char const   * __restrict  )" %11d    ", hmm->in.history);
#line 139
  i = 0;
#line 139
  while (i < n_state) {
#line 140
    fprintf((FILE * __restrict  )fp, (char const   * __restrict  )" %11d", (hmm->state + i)->history);
#line 139
    i ++;
  }
#line 141
  fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"     %11d\n", hmm->out.history);
#line 143
  if (senid) {
#line 144
    fprintf((FILE * __restrict  )fp, (char const   * __restrict  )" %-11s    ", "senid");
#line 145
    i = 0;
#line 145
    while (i < n_state) {
#line 146
      fprintf((FILE * __restrict  )fp, (char const   * __restrict  )" %11d", (int )*(senid + i));
#line 145
      i ++;
    }
#line 147
    fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"\n");
#line 149
    if (senscr) {
#line 150
      fprintf((FILE * __restrict  )fp, (char const   * __restrict  )" %-11s    ",
              "senscr");
#line 151
      i = 0;
#line 151
      while (i < n_state) {
#line 152
        fprintf((FILE * __restrict  )fp, (char const   * __restrict  )" %11d", *(senscr + *(senid + i)));
#line 151
        i ++;
      }
#line 153
      fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"\n");
    }
  }
#line 157
  fflush(fp);
#line 158
  return;
}
}
#line 161 "src/hmm.c"
void hmm_clear(hmm_t *h , int32 n_state ) 
{ 
  int32 i ;

  {
#line 165
  h->in.score = (int32 )3355443200U;
#line 166
  h->in.history = -1;
#line 167
  i = 0;
#line 167
  while (i < n_state) {
#line 168
    (h->state + i)->score = (int32 )3355443200U;
#line 169
    (h->state + i)->history = -1;
#line 167
    i ++;
  }
#line 171
  h->out.score = (int32 )3355443200U;
#line 172
  h->out.history = -1;
#line 174
  h->bestscore = (int32 )3355443200U;
#line 175
  return;
}
}
#line 178 "src/hmm.c"
int32 hmm_vit_eval_5st(hmm_t *hmm , s3senid_t *senid , int32 *senscr ) 
{ 
  int32 s0 ;
  int32 s1 ;
  int32 s2 ;
  int32 s3 ;
  int32 s4 ;
  int32 best ;
  int32 *tp ;

  {
#line 182
  tp = *(hmm->tp + 0);
#line 185
  s4 = (hmm->state + 4)->score + *(tp + 28);
#line 186
  s3 = (hmm->state + 3)->score + *(tp + 22);
#line 187
  s2 = (hmm->state + 2)->score + *(tp + 16);
#line 188
  if (s4 < s3) {
#line 189
    if (s3 >= s2) {
#line 190
      s4 = s3;
#line 191
      (hmm->state + 4)->history = (hmm->state + 3)->history;
    } else {
#line 193
      s4 = s2;
#line 194
      (hmm->state + 4)->history = (hmm->state + 2)->history;
    }
  } else
#line 196
  if (s4 < s2) {
#line 197
    s4 = s2;
#line 198
    (hmm->state + 4)->history = (hmm->state + 2)->history;
  }
#line 200
  s4 += *(senscr + *(senid + 4));
#line 201
  (hmm->state + 4)->score = s4;
#line 204
  s3 = (hmm->state + 3)->score + *(tp + 21);
#line 205
  s2 = (hmm->state + 2)->score + *(tp + 15);
#line 206
  s1 = (hmm->state + 1)->score + *(tp + 9);
#line 207
  if (s3 < s2) {
#line 208
    if (s2 >= s1) {
#line 209
      s3 = s2;
#line 210
      (hmm->state + 3)->history = (hmm->state + 2)->history;
    } else {
#line 212
      s3 = s1;
#line 213
      (hmm->state + 3)->history = (hmm->state + 1)->history;
    }
  } else
#line 215
  if (s3 < s1) {
#line 216
    s3 = s1;
#line 217
    (hmm->state + 3)->history = (hmm->state + 1)->history;
  }
#line 219
  s3 += *(senscr + *(senid + 3));
#line 220
  (hmm->state + 3)->score = s3;
#line 222
  if (s4 > s3) {
#line 222
    best = s4;
  } else {
#line 222
    best = s3;
  }
#line 225
  s4 += *(tp + 29);
#line 226
  s3 += *(tp + 23);
#line 227
  if (s4 < s3) {
#line 228
    hmm->out.score = s3;
#line 229
    hmm->out.history = (hmm->state + 3)->history;
  } else {
#line 231
    hmm->out.score = s4;
#line 232
    hmm->out.history = (hmm->state + 4)->history;
  }
#line 236
  s2 = (hmm->state + 2)->score + *(tp + 14);
#line 237
  s1 = (hmm->state + 1)->score + *(tp + 8);
#line 238
  s0 = (hmm->state + 0)->score + *(tp + 2);
#line 239
  if (s2 < s1) {
#line 240
    if (s1 >= s0) {
#line 241
      s2 = s1;
#line 242
      (hmm->state + 2)->history = (hmm->state + 1)->history;
    } else {
#line 244
      s2 = s0;
#line 245
      (hmm->state + 2)->history = (hmm->state + 0)->history;
    }
  } else
#line 247
  if (s2 < s0) {
#line 248
    s2 = s0;
#line 249
    (hmm->state + 2)->history = (hmm->state + 0)->history;
  }
#line 251
  s2 += *(senscr + *(senid + 2));
#line 252
  (hmm->state + 2)->score = s2;
#line 253
  if (best < s2) {
#line 254
    best = s2;
  }
#line 257
  s1 = (hmm->state + 1)->score + *(tp + 7);
#line 258
  s0 = (hmm->state + 0)->score + *(tp + 1);
#line 259
  if (s1 < s0) {
#line 260
    s1 = s0;
#line 261
    (hmm->state + 1)->history = (hmm->state + 0)->history;
  }
#line 263
  s1 += *(senscr + *(senid + 1));
#line 264
  (hmm->state + 1)->score = s1;
#line 265
  if (best < s1) {
#line 266
    best = s1;
  }
#line 269
  s0 = (hmm->state + 0)->score + *(tp + 0);
#line 270
  if (s0 < hmm->in.score) {
#line 271
    s0 = hmm->in.score;
#line 272
    (hmm->state + 0)->history = hmm->in.history;
  }
#line 274
  s0 += *(senscr + *(senid + 0));
#line 275
  (hmm->state + 0)->score = s0;
#line 276
  if (best < s0) {
#line 277
    best = s0;
  }
#line 279
  hmm->in.score = (int32 )3355443200U;
#line 280
  hmm->bestscore = best;
#line 282
  return (best);
}
}
#line 286 "src/hmm.c"
int32 hmm_vit_eval_3st(hmm_t *hmm , s3senid_t *senid , int32 *senscr ) 
{ 
  int32 s0 ;
  int32 s1 ;
  int32 s2 ;
  int32 best ;
  int32 *tp ;

  {
#line 293
  tp = *(hmm->tp + 0);
#line 296
  s2 = (hmm->state + 2)->score + *(tp + 10);
#line 297
  s1 = (hmm->state + 1)->score + *(tp + 6);
#line 298
  if (*(tp + 2) > -939524096) {
#line 299
    s0 = (hmm->state + 0)->score + *(tp + 2);
#line 300
    if (s2 < s1) {
#line 301
      if (s1 >= s0) {
#line 302
        s2 = s1;
#line 303
        (hmm->state + 2)->history = (hmm->state + 1)->history;
      } else {
#line 305
        s2 = s0;
#line 306
        (hmm->state + 2)->history = (hmm->state + 0)->history;
      }
    } else
#line 308
    if (s2 < s0) {
#line 309
      s2 = s0;
#line 310
      (hmm->state + 2)->history = (hmm->state + 0)->history;
    }
  } else
#line 313
  if (s2 < s1) {
#line 314
    s2 = s1;
#line 315
    (hmm->state + 2)->history = (hmm->state + 1)->history;
  }
#line 324
  s2 += *(senscr + *(senid + 2));
#line 326
  (hmm->state + 2)->score = s2;
#line 330
  s1 = (hmm->state + 1)->score + *(tp + 5);
#line 331
  s0 = (hmm->state + 0)->score + *(tp + 1);
#line 332
  if (s1 < s0) {
#line 333
    s1 = s0;
#line 334
    (hmm->state + 1)->history = (hmm->state + 0)->history;
  }
#line 341
  s1 += *(senscr + *(senid + 1));
#line 343
  (hmm->state + 1)->score = s1;
#line 345
  if (s2 > s1) {
#line 345
    best = s2;
  } else {
#line 345
    best = s1;
  }
#line 353
  s2 += *(tp + 11);
#line 355
  if (*(tp + 7) > -939524096) {
#line 356
    s1 += *(tp + 7);
#line 357
    if (s2 < s1) {
#line 358
      hmm->out.score = s1;
#line 359
      hmm->out.history = (hmm->state + 1)->history;
    } else {
#line 361
      hmm->out.score = s2;
#line 362
      hmm->out.history = (hmm->state + 2)->history;
    }
  } else {
#line 365
    hmm->out.score = s2;
#line 366
    hmm->out.history = (hmm->state + 2)->history;
  }
#line 370
  s0 = (hmm->state + 0)->score + *(tp + 0);
#line 371
  if (s0 < hmm->in.score) {
#line 372
    s0 = hmm->in.score;
#line 373
    (hmm->state + 0)->history = hmm->in.history;
  }
#line 380
  s0 += *(senscr + *(senid + 0));
#line 382
  (hmm->state + 0)->score = s0;
#line 384
  if (best < s0) {
#line 385
    best = s0;
  }
#line 387
  hmm->in.score = (int32 )3355443200U;
#line 388
  hmm->bestscore = best;
#line 390
  return (best);
}
}
#line 394 "src/hmm.c"
int32 hmm_dump_vit_eval(hmm_t *hmm , int32 n_state , s3senid_t *senid , int32 *senscr ,
                        FILE *fp ) 
{ 
  int32 bs___0 ;

  {
#line 396
  bs___0 = 0;
#line 398
  if (fp) {
#line 399
    hmm_dump(hmm, n_state, senid, senscr, fp);
  }
#line 401
  if (n_state == 5) {
#line 402
    bs___0 = hmm_vit_eval_5st(hmm, senid, senscr);
  } else
#line 403
  if (n_state == 3) {
#line 404
    bs___0 = hmm_vit_eval_3st(hmm, senid, senscr);
  } else {
#line 406
    _E__pr_header("src/hmm.c", 406L, "FATAL_ERROR");
#line 406
    _E__die_error("#States= %d unsupported\n", n_state);
  }
#line 408
  if (fp) {
#line 409
    hmm_dump(hmm, n_state, senid, senscr, fp);
  }
#line 411
  return (bs___0);
}
}
#line 1 "lextree.o"
#pragma merger("0","/tmp/cil-0lk3kCim.i","-g,-O4")
#line 150 "/usr/include/x86_64-linux-gnu/bits/mathinline.h"
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__, __always_inline__)) __signbitl)(long double __x )  __attribute__((__const__)) ;
#line 150 "/usr/include/x86_64-linux-gnu/bits/mathinline.h"
__inline extern int ( __attribute__((__leaf__, __always_inline__)) __signbitl)(long double __x ) 
{ 
  union __anonunion___u_29___14 __u ;

  {
#line 153
  __u.__l = __x;
#line 154
  return ((__u.__i[2] & 32768) != 0);
}
}
#line 215 "src/lextree.h"
lextree_t *lextree_build(kbcore_t *kbc , wordprob_t *wordprob , int32 n_word , s3cipid_t *lc ) ;
#line 223
void lextree_free(lextree_t *lextree ) ;
#line 230
void lextree_utt_end(lextree_t *l , kbcore_t *kbc ) ;
#line 236
void lextree_enter(lextree_t *lextree , s3cipid_t lc , int32 cf , int32 inscore ,
                   int32 inhist , int32 thresh ) ;
#line 249
void lextree_active_swap(lextree_t *lextree ) ;
#line 256
void lextree_ssid_active(lextree_t *lextree , int32 *ssid , int32 *comssid ) ;
#line 265
void lextree_ci_active(lextree_t *lextree , bitvec_t ci_active ) ;
#line 272
int32 lextree_hmm_eval(lextree_t *lextree , kbcore_t *kbc , ascr_t *ascr , int32 frm ,
                       FILE *fp ) ;
#line 283
void lextree_hmm_propagate(lextree_t *lextree , kbcore_t *kbc , vithist_t *vh , int32 cf ,
                           int32 th , int32 pth , int32 wth ) ;
#line 299
void lextree_hmm_histbin(lextree_t *lextree , int32 bestscr , int32 *bin , int32 nbin ,
                         int32 bw ) ;
#line 307
void lextree_dump(lextree_t *lextree , dict_t *dict , FILE *fp ) ;
#line 123 "src/lextree.c"
static lextree_node_t *lextree_node_alloc(int32 wid , int32 prob , int32 comp , int32 ssid ,
                                          int32 n_state , int32 ci ) 
{ 
  lextree_node_t *ln ;
  char *tmp ;
  void *tmp___0 ;

  {
#line 128
  tmp = __mymalloc__((int32 )sizeof(lextree_node_t ), (char *)"src/lextree.c", 128);
#line 128
  ln = (lextree_node_t *)tmp;
#line 129
  ln->children = (glist_t )((void *)0);
#line 130
  ln->wid = wid;
#line 131
  ln->prob = prob;
#line 132
  ln->ssid = ssid;
#line 133
  ln->ci = (s3cipid_t )ci;
#line 134
  ln->composite = (int8 )comp;
#line 135
  ln->frame = (s3frmid_t )-1;
#line 136
  tmp___0 = __ckd_calloc__((size_t )n_state, sizeof(hmm_state_t ), "src/lextree.c",
                           136);
#line 136
  ln->hmm.state = (hmm_state_t *)tmp___0;
#line 138
  hmm_clear(& ln->hmm, n_state);
#line 139
  ln->synch = (int8 )0;
#line 140
  return (ln);
}
}
#line 144 "src/lextree.c"
lextree_t *lextree_build(kbcore_t *kbc , wordprob_t *wordprob , int32 n_word , s3cipid_t *lc ) 
{ 
  mdef_t *mdef ;
  dict_t *dict ;
  tmat_t *tmat ;
  dict2pid_t *d2p ;
  s3ssid_t *ldiph_lc ;
  lextree_t *lextree ;
  lextree_lcroot_t *lcroot ;
  int32 n_lc ;
  int32 n_node ;
  int32 n_ci ;
  int32 n_sseq ;
  int32 pronlen ;
  int32 ssid ;
  int32 prob ;
  int32 ci ;
  int32 rc ;
  int32 wid ;
  int32 np ;
  int32 n_st ;
  lextree_node_t *ln ;
  lextree_node_t **parent ;
  lextree_node_t **ssid2ln ;
  gnode_t *gn ;
  bitvec_t *ssid_lc ;
  int32 i ;
  int32 j ;
  int32 k___0 ;
  int32 p ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  void *tmp___5 ;
  int32 tmp___6 ;
  int32 tmp___7 ;
  int32 tmp___8 ;
  void *tmp___9 ;
  void *tmp___10 ;

  {
#line 154
  ln = (lextree_node_t *)0;
#line 155
  gn = (gnode_t *)0;
#line 159
  mdef = kbc->mdef;
#line 160
  dict = kbc->dict;
#line 161
  tmat = kbc->tmat;
#line 162
  d2p = kbc->dict2pid;
#line 163
  n_ci = mdef->n_ciphone;
#line 164
  n_sseq = mdef->n_sseq;
#line 165
  n_st = mdef->n_emit_state;
#line 167
  tmp = __ckd_calloc__((size_t )1, sizeof(lextree_t ), "src/lextree.c", 167);
#line 167
  lextree = (lextree_t *)tmp;
#line 168
  lextree->root = (glist_t )((void *)0);
#line 171
  tmp___0 = __ckd_calloc__((size_t )n_sseq, sizeof(lextree_node_t *), "src/lextree.c",
                           171);
#line 171
  ssid2ln = (lextree_node_t **)tmp___0;
#line 174
  tmp___1 = __ckd_calloc__((size_t )n_sseq, sizeof(bitvec_t ), "src/lextree.c", 174);
#line 174
  ssid_lc = (bitvec_t *)tmp___1;
#line 175
  i = 0;
#line 175
  while (i < n_sseq) {
#line 176
    tmp___2 = __ckd_calloc__((size_t )((n_ci + 31) >> 5), sizeof(uint32 ), "src/lextree.c",
                             176);
#line 176
    *(ssid_lc + i) = (bitvec_t )tmp___2;
#line 175
    i ++;
  }
#line 178
  n_node = 0;
#line 181
  n_lc = 0;
#line 182
  lcroot = (lextree_lcroot_t *)((void *)0);
#line 183
  if (! lc) {
#line 184
    lextree->n_lc = 0;
#line 185
    lextree->lcroot = (lextree_lcroot_t *)((void *)0);
#line 187
    tmp___3 = __ckd_calloc__((size_t )1, sizeof(lextree_node_t *), "src/lextree.c",
                             187);
#line 187
    parent = (lextree_node_t **)tmp___3;
  } else {
#line 189
    n_lc = 0;
#line 189
    while ((int )*(lc + n_lc) >= 0) {
#line 189
      n_lc ++;
    }
#line 190
    if (! (n_lc > 0)) {
#line 190
      __assert_fail("n_lc > 0", "src/lextree.c", 190U, "lextree_build");
    }
#line 192
    lextree->n_lc = n_lc;
#line 193
    tmp___4 = __ckd_calloc__((size_t )n_lc, sizeof(lextree_lcroot_t ), "src/lextree.c",
                             193);
#line 193
    lcroot = (lextree_lcroot_t *)tmp___4;
#line 194
    lextree->lcroot = lcroot;
#line 196
    i = 0;
#line 196
    while (i < n_lc) {
#line 197
      (lcroot + i)->lc = *(lc + i);
#line 198
      (lcroot + i)->root = (glist_t )((void *)0);
#line 196
      i ++;
    }
#line 201
    tmp___5 = __ckd_calloc__((size_t )n_lc, sizeof(lextree_node_t *), "src/lextree.c",
                             201);
#line 201
    parent = (lextree_node_t **)tmp___5;
  }
#line 223
  i = 0;
#line 223
  while (i < n_word) {
#line 224
    wid = (wordprob + i)->wid;
#line 225
    prob = (wordprob + i)->prob;
#line 227
    pronlen = (dict->word + wid)->pronlen;
#line 229
    if (pronlen == 1) {
#line 231
      ci = (int32 )*((dict->word + wid)->ciphone + 0);
#line 232
      if (! lc) {
#line 233
        ln = lextree_node_alloc(wid, prob, 1, *(*(d2p->internal + wid) + 0), n_st,
                                (int32 )*((dict->word + wid)->ciphone + 0));
#line 235
        ln->hmm.tp = *(tmat->tp + (mdef->phone + ci)->tmat);
#line 237
        lextree->root = glist_add_ptr(lextree->root, (void *)ln);
#line 238
        n_node ++;
      } else {
#line 240
        np = 0;
#line 241
        j = 0;
#line 241
        while (j < n_lc) {
#line 242
          ssid = *(*(d2p->single_lc + ci) + (int )*(lc + j));
#line 245
          k___0 = 0;
#line 245
          while (1) {
#line 245
            if (k___0 < np) {
#line 245
              if (! ((*(parent + k___0))->ssid != ssid)) {
#line 245
                break;
              }
            } else {
#line 245
              break;
            }
#line 245
            k___0 ++;
          }
#line 246
          if (k___0 >= np) {
#line 247
            ln = lextree_node_alloc(wid, prob, 1, ssid, n_st, ci);
#line 248
            ln->hmm.tp = *(tmat->tp + (mdef->phone + ci)->tmat);
#line 250
            lextree->root = glist_add_ptr(lextree->root, (void *)ln);
#line 251
            n_node ++;
#line 253
            (lcroot + j)->root = glist_add_ptr((lcroot + j)->root, (void *)ln);
#line 254
            tmp___6 = np;
#line 254
            np ++;
#line 254
            *(parent + tmp___6) = ln;
          } else {
#line 256
            (lcroot + j)->root = glist_add_ptr((lcroot + j)->root, (void *)*(parent + k___0));
          }
#line 241
          j ++;
        }
      }
    } else {
#line 261
      if (! (pronlen > 1)) {
#line 261
        __assert_fail("pronlen > 1", "src/lextree.c", 261U, "lextree_build");
      }
#line 264
      if (! lc) {
#line 265
        ssid = *(*(d2p->internal + wid) + 0);
#line 266
        ci = (int32 )*((dict->word + wid)->ciphone + 0);
#line 269
        gn = lextree->root;
#line 269
        while (gn) {
#line 270
          ln = (lextree_node_t *)gn->data.ptr;
#line 271
          if (ln->ssid == ssid) {
#line 271
            if (ln->composite) {
#line 271
              if (ln->wid < 0) {
#line 272
                break;
              }
            }
          }
#line 269
          gn = gn->next;
        }
#line 274
        if (! gn) {
#line 275
          ln = lextree_node_alloc(-1, prob, 1, ssid, n_st, ci);
#line 276
          ln->hmm.tp = *(tmat->tp + (mdef->phone + ci)->tmat);
#line 278
          lextree->root = glist_add_ptr(lextree->root, (void *)ln);
#line 279
          n_node ++;
        } else
#line 281
        if (ln->prob < prob) {
#line 282
          ln->prob = prob;
        }
#line 284
        *(parent + 0) = ln;
#line 285
        np = 1;
      } else {
#line 287
        ci = (int32 )*((dict->word + wid)->ciphone + 0);
#line 288
        rc = (int32 )*((dict->word + wid)->ciphone + 1);
#line 289
        ldiph_lc = *(*(d2p->ldiph_lc + ci) + rc);
#line 291
        np = 0;
#line 292
        j = 0;
#line 292
        while (j < n_lc) {
#line 293
          ssid = *(ldiph_lc + (int )*(lc + j));
#line 296
          ln = *(ssid2ln + ssid);
#line 297
          if (! ln) {
#line 298
            ln = lextree_node_alloc(-1, prob, 0, ssid, n_st, ci);
#line 299
            ln->hmm.tp = *(tmat->tp + (mdef->phone + ci)->tmat);
#line 300
            lextree->root = glist_add_ptr(lextree->root, (void *)ln);
#line 301
            n_node ++;
#line 303
            *(ssid2ln + ssid) = ln;
          } else
#line 304
          if (ln->prob < prob) {
#line 305
            ln->prob = prob;
          }
#line 308
          if (! (*(*(ssid_lc + ssid) + ((int )*(lc + j) >> 5)) & (unsigned int )(1 << ((int )*(lc + j) & 31)))) {
#line 309
            (lcroot + j)->root = glist_add_ptr((lcroot + j)->root, (void *)ln);
#line 310
            *(*(ssid_lc + ssid) + ((int )*(lc + j) >> 5)) |= (unsigned int )(1 << ((int )*(lc + j) & 31));
          }
#line 314
          k___0 = 0;
#line 314
          while (1) {
#line 314
            if (k___0 < np) {
#line 314
              if (! ((*(parent + k___0))->ssid != ssid)) {
#line 314
                break;
              }
            } else {
#line 314
              break;
            }
#line 314
            k___0 ++;
          }
#line 315
          if (k___0 >= np) {
#line 316
            tmp___7 = np;
#line 316
            np ++;
#line 316
            *(parent + tmp___7) = ln;
          }
#line 292
          j ++;
        }
      }
#line 321
      p = 1;
#line 321
      while (p < pronlen - 1) {
#line 322
        ssid = *(*(d2p->internal + wid) + p);
#line 323
        ci = (int32 )*((dict->word + wid)->ciphone + p);
#line 326
        j = 0;
#line 326
        while (j < np) {
#line 327
          gn = (*(parent + j))->children;
#line 327
          while (gn) {
#line 328
            ln = (lextree_node_t *)gn->data.ptr;
#line 330
            if (ln->ssid == ssid) {
#line 330
              if (! ln->composite) {
#line 331
                if (! (ln->wid < 0)) {
#line 331
                  __assert_fail("((ln->wid)<0)", "src/lextree.c", 331U, "lextree_build");
                }
#line 332
                break;
              }
            }
#line 327
            gn = gn->next;
          }
#line 335
          if (gn) {
#line 336
            break;
          }
#line 326
          j ++;
        }
#line 339
        if (! gn) {
#line 340
          ln = lextree_node_alloc(-1, prob, 0, ssid, n_st, ci);
#line 341
          ln->hmm.tp = *(tmat->tp + (mdef->phone + ci)->tmat);
#line 343
          j = 0;
#line 343
          while (j < np) {
#line 344
            (*(parent + j))->children = glist_add_ptr((*(parent + j))->children, (void *)ln);
#line 343
            j ++;
          }
#line 345
          n_node ++;
        } else {
#line 347
          if (ln->prob < prob) {
#line 348
            ln->prob = prob;
          }
#line 350
          k___0 = j;
#line 353
          j = 0;
#line 353
          while (j < k___0) {
#line 354
            (*(parent + j))->children = glist_add_ptr((*(parent + j))->children, (void *)ln);
#line 353
            j ++;
          }
#line 357
          j = k___0 + 1;
#line 357
          while (j < np) {
#line 358
            tmp___8 = glist_chkdup_ptr((*(parent + j))->children, (void *)ln);
#line 358
            if (! tmp___8) {
#line 359
              (*(parent + j))->children = glist_add_ptr((*(parent + j))->children,
                                                        (void *)ln);
            }
#line 357
            j ++;
          }
        }
#line 363
        *(parent + 0) = ln;
#line 364
        np = 1;
#line 321
        p ++;
      }
#line 368
      ssid = *(*(d2p->internal + wid) + p);
#line 369
      ci = (int32 )*((dict->word + wid)->ciphone + p);
#line 370
      ln = lextree_node_alloc(wid, prob, 1, ssid, n_st, ci);
#line 371
      ln->hmm.tp = *(tmat->tp + (mdef->phone + ci)->tmat);
#line 373
      j = 0;
#line 373
      while (j < np) {
#line 374
        (*(parent + j))->children = glist_add_ptr((*(parent + j))->children, (void *)ln);
#line 373
        j ++;
      }
#line 375
      n_node ++;
    }
#line 223
    i ++;
  }
#line 379
  lextree->n_node = n_node;
#line 381
  tmp___9 = __ckd_calloc__((size_t )n_node, sizeof(lextree_node_t *), "src/lextree.c",
                           381);
#line 381
  lextree->active = (lextree_node_t **)tmp___9;
#line 382
  tmp___10 = __ckd_calloc__((size_t )n_node, sizeof(lextree_node_t *), "src/lextree.c",
                            382);
#line 382
  lextree->next_active = (lextree_node_t **)tmp___10;
#line 383
  lextree->n_active = 0;
#line 384
  lextree->n_next_active = 0;
#line 386
  free((void *)ssid2ln);
#line 387
  i = 0;
#line 387
  while (i < n_sseq) {
#line 388
    free((void *)((char *)*(ssid_lc + i)));
#line 387
    i ++;
  }
#line 389
  free((void *)ssid_lc);
#line 390
  free((void *)parent);
#line 392
  return (lextree);
}
}
#line 396 "src/lextree.c"
static int32 lextree_subtree_free(lextree_node_t *ln , int32 level ) 
{ 
  gnode_t *gn ;
  lextree_node_t *ln2 ;
  int32 k___0 ;
  int32 tmp ;

  {
#line 402
  k___0 = 0;
#line 405
  gn = ln->children;
#line 405
  while (gn) {
#line 406
    ln2 = (lextree_node_t *)gn->data.ptr;
#line 407
    tmp = lextree_subtree_free(ln2, level + 1);
#line 407
    k___0 += tmp;
#line 405
    gn = gn->next;
  }
#line 409
  glist_free(ln->children);
#line 410
  ln->children = (glist_t )((void *)0);
#line 413
  if (level != 1) {
#line 414
    __myfree__((char *)((void *)ln), (int32 )sizeof(lextree_node_t ), (char *)"src/lextree.c",
               414);
#line 415
    k___0 ++;
  } else {
#line 413
    (ln->ssid) --;
#line 413
    if (ln->ssid == 0) {
#line 414
      __myfree__((char *)((void *)ln), (int32 )sizeof(lextree_node_t ), (char *)"src/lextree.c",
                 414);
#line 415
      k___0 ++;
    }
  }
#line 418
  return (k___0);
}
}
#line 427 "src/lextree.c"
void lextree_free(lextree_t *lextree ) 
{ 
  gnode_t *gn ;
  gnode_t *gn2 ;
  lextree_node_t *ln ;
  lextree_node_t *ln2 ;
  int32 i ;
  int32 k___0 ;
  int32 tmp ;

  {
#line 433
  if (lextree->n_lc > 0) {
#line 434
    i = 0;
#line 434
    while (i < lextree->n_lc) {
#line 435
      glist_free((lextree->lcroot + i)->root);
#line 434
      i ++;
    }
#line 437
    free((void *)lextree->lcroot);
  }
#line 441
  gn = lextree->root;
#line 441
  while (gn) {
#line 442
    ln = (lextree_node_t *)gn->data.ptr;
#line 443
    gn2 = ln->children;
#line 443
    while (gn2) {
#line 444
      ln2 = (lextree_node_t *)gn2->data.ptr;
#line 445
      if ((int )ln2->composite >= 0) {
#line 446
        ln2->composite = (int8 )-1;
#line 447
        ln2->ssid = 1;
      } else {
#line 449
        (ln2->ssid) ++;
      }
#line 443
      gn2 = gn2->next;
    }
#line 441
    gn = gn->next;
  }
#line 454
  k___0 = 0;
#line 455
  gn = lextree->root;
#line 455
  while (gn) {
#line 456
    ln = (lextree_node_t *)gn->data.ptr;
#line 457
    tmp = lextree_subtree_free(ln, 0);
#line 457
    k___0 += tmp;
#line 455
    gn = gn->next;
  }
#line 459
  glist_free(lextree->root);
#line 461
  free((void *)lextree->active);
#line 462
  free((void *)lextree->next_active);
#line 464
  if (k___0 != lextree->n_node) {
#line 465
    _E__pr_header("src/lextree.c", 465L, "ERROR");
#line 465
    _E__pr_warn("#Nodes allocated(%d) != #nodes freed(%d)\n", lextree->n_node, k___0);
  }
#line 467
  free((void *)lextree);
#line 468
  return;
}
}
#line 471 "src/lextree.c"
void lextree_ci_active(lextree_t *lextree , bitvec_t ci_active ) 
{ 
  lextree_node_t **list ;
  lextree_node_t *ln ;
  int32 i ;

  {
#line 476
  list = lextree->active;
#line 478
  i = 0;
#line 478
  while (i < lextree->n_active) {
#line 479
    ln = *(list + i);
#line 480
    *(ci_active + ((int )ln->ci >> 5)) |= (unsigned int )(1 << ((int )ln->ci & 31));
#line 478
    i ++;
  }
#line 482
  return;
}
}
#line 485 "src/lextree.c"
void lextree_ssid_active(lextree_t *lextree , int32 *ssid , int32 *comssid ) 
{ 
  lextree_node_t **list ;
  lextree_node_t *ln ;
  int32 i ;

  {
#line 490
  list = lextree->active;
#line 492
  i = 0;
#line 492
  while (i < lextree->n_active) {
#line 493
    ln = *(list + i);
#line 494
    if (ln->composite) {
#line 495
      *(comssid + ln->ssid) = 1;
    } else {
#line 497
      *(ssid + ln->ssid) = 1;
    }
#line 492
    i ++;
  }
#line 499
  return;
}
}
#line 502 "src/lextree.c"
void lextree_utt_end(lextree_t *l , kbcore_t *kbc ) 
{ 
  mdef_t *mdef ;
  lextree_node_t *ln ;
  int32 i ;

  {
#line 508
  mdef = kbc->mdef;
#line 510
  i = 0;
#line 510
  while (i < l->n_active) {
#line 511
    ln = *(l->active + i);
#line 513
    ln->frame = (s3frmid_t )-1;
#line 514
    hmm_clear(& ln->hmm, mdef->n_emit_state);
#line 510
    i ++;
  }
#line 517
  l->n_active = 0;
#line 518
  l->n_next_active = 0;
#line 519
  return;
}
}
#line 522 "src/lextree.c"
static void lextree_node_print(lextree_node_t *ln , dict_t *dict , FILE *fp ) 
{ 


  {
#line 524
  fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"wid(%d)pr(%d)com(%d)ss(%d)",
          ln->wid, ln->prob, (int )ln->composite, ln->ssid);
#line 525
  if (ln->wid >= 0) {
#line 526
    fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"%s", (dict->word + ln->wid)->word);
  }
#line 527
  fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"\n");
#line 528
  return;
}
}
#line 531 "src/lextree.c"
static void lextree_subtree_print(lextree_node_t *ln , int32 level , dict_t *dict ,
                                  FILE *fp ) 
{ 
  int32 i ;
  gnode_t *gn ;

  {
#line 536
  i = 0;
#line 536
  while (i < level) {
#line 537
    fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"    ");
#line 536
    i ++;
  }
#line 538
  lextree_node_print(ln, dict, fp);
#line 540
  gn = ln->children;
#line 540
  while (gn) {
#line 541
    ln = (lextree_node_t *)gn->data.ptr;
#line 542
    lextree_subtree_print(ln, level + 1, dict, fp);
#line 540
    gn = gn->next;
  }
#line 544
  return;
}
}
#line 547 "src/lextree.c"
void lextree_dump(lextree_t *lextree , dict_t *dict , FILE *fp ) 
{ 
  gnode_t *gn ;
  lextree_node_t *ln ;
  int32 i ;

  {
#line 553
  gn = lextree->root;
#line 553
  while (gn) {
#line 554
    ln = (lextree_node_t *)gn->data.ptr;
#line 555
    lextree_subtree_print(ln, 0, dict, fp);
#line 553
    gn = gn->next;
  }
#line 558
  if (lextree->n_lc > 0) {
#line 559
    i = 0;
#line 559
    while (i < lextree->n_lc) {
#line 560
      fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"lcroot %d\n",
              (int )(lextree->lcroot + i)->lc);
#line 561
      gn = (lextree->lcroot + i)->root;
#line 561
      while (gn) {
#line 562
        ln = (lextree_node_t *)gn->data.ptr;
#line 563
        lextree_node_print(ln, dict, fp);
#line 561
        gn = gn->next;
      }
#line 559
      i ++;
    }
  }
#line 567
  return;
}
}
#line 570 "src/lextree.c"
void lextree_enter(lextree_t *lextree , s3cipid_t lc , int32 cf , int32 inscore ,
                   int32 inhist , int32 thresh ) 
{ 
  glist_t root ;
  gnode_t *gn ;
  lextree_node_t *ln ;
  int32 nf ;
  int32 scr ;
  int32 i ;
  int32 n ;
  hmm_t *hmm ;
  int32 tmp ;

  {
#line 580
  nf = cf + 1;
#line 583
  if (lextree->n_lc == 0) {
#line 584
    if (! ((int )lc < 0)) {
#line 584
      __assert_fail("((lc)<0)", "src/lextree.c", 584U, "lextree_enter");
    }
#line 585
    root = lextree->root;
  } else {
#line 587
    i = 0;
#line 587
    while (1) {
#line 587
      if (i < lextree->n_lc) {
#line 587
        if (! ((int )(lextree->lcroot + i)->lc != (int )lc)) {
#line 587
          break;
        }
      } else {
#line 587
        break;
      }
#line 587
      i ++;
    }
#line 588
    if (! (i < lextree->n_lc)) {
#line 588
      __assert_fail("i < lextree->n_lc", "src/lextree.c", 588U, "lextree_enter");
    }
#line 590
    root = (lextree->lcroot + i)->root;
  }
#line 594
  n = lextree->n_next_active;
#line 595
  gn = root;
#line 595
  while (gn) {
#line 596
    ln = (lextree_node_t *)gn->data.ptr;
#line 598
    hmm = & ln->hmm;
#line 600
    scr = inscore + ln->prob;
#line 601
    if (scr >= thresh) {
#line 601
      if (hmm->in.score < scr) {
#line 602
        hmm->in.score = scr;
#line 603
        hmm->in.history = inhist;
#line 605
        if ((int )ln->frame != nf) {
#line 606
          ln->frame = (s3frmid_t )nf;
#line 607
          tmp = n;
#line 607
          n ++;
#line 607
          *(lextree->next_active + tmp) = ln;
        }
      }
    }
#line 595
    gn = gn->next;
  }
#line 611
  lextree->n_next_active = n;
#line 612
  return;
}
}
#line 615 "src/lextree.c"
void lextree_active_swap(lextree_t *lextree ) 
{ 
  lextree_node_t **t ;

  {
#line 619
  t = lextree->active;
#line 620
  lextree->active = lextree->next_active;
#line 621
  lextree->next_active = t;
#line 622
  lextree->n_active = lextree->n_next_active;
#line 623
  lextree->n_next_active = 0;
#line 624
  return;
}
}
#line 627 "src/lextree.c"
int32 lextree_hmm_eval(lextree_t *lextree , kbcore_t *kbc , ascr_t *ascr , int32 frm ,
                       FILE *fp ) 
{ 
  int32 best ;
  int32 wbest ;
  int32 n_st ;
  int32 i ;
  int32 k___0 ;
  lextree_node_t **list ;
  lextree_node_t *ln ;
  mdef_t *mdef ;
  dict2pid_t *d2p ;

  {
#line 635
  mdef = kbc->mdef;
#line 636
  d2p = kbc->dict2pid;
#line 637
  n_st = mdef->n_emit_state;
#line 639
  list = lextree->active;
#line 640
  best = (int32 )2147483648U;
#line 641
  wbest = (int32 )2147483648U;
#line 645
  if (fp) {
#line 646
    i = 0;
#line 646
    while (i < lextree->n_active) {
#line 647
      ln = *(list + i);
#line 648
      if (! ((int )ln->frame == frm)) {
#line 648
        __assert_fail("ln->frame == frm", "src/lextree.c", 648U, "lextree_hmm_eval");
      }
#line 650
      lextree_node_print(ln, kbc->dict, fp);
#line 652
      if (! ln->composite) {
#line 653
        k___0 = hmm_dump_vit_eval(& ln->hmm, n_st, *(mdef->sseq + ln->ssid), ascr->sen,
                                  fp);
      } else {
#line 656
        k___0 = hmm_dump_vit_eval(& ln->hmm, n_st, *(d2p->comsseq + ln->ssid), ascr->comsen,
                                  fp);
      }
#line 659
      if (best < k___0) {
#line 660
        best = k___0;
      }
#line 662
      if (ln->wid >= 0) {
#line 663
        if (wbest < k___0) {
#line 664
          wbest = k___0;
        }
      }
#line 646
      i ++;
    }
  } else
#line 668
  if (n_st == 3) {
#line 670
    i = 0;
#line 670
    while (i < lextree->n_active) {
#line 671
      ln = *(list + i);
#line 673
      if (! ((int )ln->frame == frm)) {
#line 673
        __assert_fail("ln->frame == frm", "src/lextree.c", 673U, "lextree_hmm_eval");
      }
#line 675
      if (! ln->composite) {
#line 676
        k___0 = hmm_vit_eval_3st(& ln->hmm, *(mdef->sseq + ln->ssid), ascr->sen);
      } else {
#line 678
        k___0 = hmm_vit_eval_3st(& ln->hmm, *(d2p->comsseq + ln->ssid), ascr->comsen);
      }
#line 680
      if (best < k___0) {
#line 681
        best = k___0;
      }
#line 683
      if (ln->wid >= 0) {
#line 684
        if (wbest < k___0) {
#line 685
          wbest = k___0;
        }
      }
#line 670
      i ++;
    }
  } else
#line 688
  if (n_st == 5) {
#line 689
    i = 0;
#line 689
    while (i < lextree->n_active) {
#line 690
      ln = *(list + i);
#line 691
      if (! ((int )ln->frame == frm)) {
#line 691
        __assert_fail("ln->frame == frm", "src/lextree.c", 691U, "lextree_hmm_eval");
      }
#line 693
      if (! ln->composite) {
#line 694
        k___0 = hmm_vit_eval_5st(& ln->hmm, *(mdef->sseq + ln->ssid), ascr->sen);
      } else {
#line 696
        k___0 = hmm_vit_eval_5st(& ln->hmm, *(d2p->comsseq + ln->ssid), ascr->comsen);
      }
#line 698
      if (best < k___0) {
#line 699
        best = k___0;
      }
#line 701
      if (ln->wid >= 0) {
#line 702
        if (wbest < k___0) {
#line 703
          wbest = k___0;
        }
      }
#line 689
      i ++;
    }
  } else {
#line 707
    _E__pr_header("src/lextree.c", 707L, "FATAL_ERROR");
#line 707
    _E__die_error("#State= %d unsupported\n", n_st);
  }
#line 710
  lextree->best = best;
#line 711
  lextree->wbest = wbest;
#line 713
  if (fp) {
#line 714
    fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"Fr %d  #active %d  best %d  wbest %d\n",
            frm, lextree->n_active, best, wbest);
#line 716
    fflush(fp);
  }
#line 719
  return (best);
}
}
#line 723 "src/lextree.c"
void lextree_hmm_histbin(lextree_t *lextree , int32 bestscr , int32 *bin , int32 nbin ,
                         int32 bw ) 
{ 
  lextree_node_t **list ;
  lextree_node_t *ln ;
  hmm_t *hmm ;
  int32 i ;
  int32 k___0 ;
  glist_t *binln ;
  gnode_t *gn ;
  void *tmp ;
  int32 tmp___0 ;

  {
#line 731
  tmp = __ckd_calloc__((size_t )nbin, sizeof(glist_t ), "src/lextree.c", 731);
#line 731
  binln = (glist_t *)tmp;
#line 733
  list = lextree->active;
#line 735
  i = 0;
#line 735
  while (i < lextree->n_active) {
#line 736
    ln = *(list + i);
#line 737
    hmm = & ln->hmm;
#line 739
    k___0 = (bestscr - hmm->bestscore) / bw;
#line 740
    if (k___0 >= nbin) {
#line 741
      k___0 = nbin - 1;
    }
#line 742
    if (! (k___0 >= 0)) {
#line 742
      __assert_fail("k >= 0", "src/lextree.c", 742U, "lextree_hmm_histbin");
    }
#line 744
    (*(bin + k___0)) ++;
#line 745
    *(binln + k___0) = glist_add_ptr(*(binln + k___0), (void *)ln);
#line 735
    i ++;
  }
#line 749
  k___0 = 0;
#line 750
  i = 0;
#line 750
  while (i < nbin) {
#line 751
    gn = *(binln + i);
#line 751
    while (gn) {
#line 752
      ln = (lextree_node_t *)gn->data.ptr;
#line 753
      tmp___0 = k___0;
#line 753
      k___0 ++;
#line 753
      *(list + tmp___0) = ln;
#line 751
      gn = gn->next;
    }
#line 755
    glist_free(*(binln + i));
#line 750
    i ++;
  }
#line 757
  if (! (k___0 == lextree->n_active)) {
#line 757
    __assert_fail("k == lextree->n_active", "src/lextree.c", 757U, "lextree_hmm_histbin");
  }
#line 759
  free((void *)binln);
#line 760
  return;
}
}
#line 763 "src/lextree.c"
void lextree_hmm_propagate(lextree_t *lextree , kbcore_t *kbc , vithist_t *vh , int32 cf ,
                           int32 th , int32 pth , int32 wth ) 
{ 
  mdef_t *mdef ;
  int32 nf ;
  int32 newscore ;
  lextree_node_t **list ;
  lextree_node_t *ln ;
  lextree_node_t *ln2 ;
  hmm_t *hmm ;
  hmm_t *hmm2 ;
  gnode_t *gn ;
  int32 i ;
  int32 n ;
  int32 tmp ;
  int32 tmp___0 ;

  {
#line 773
  mdef = kbc->mdef;
#line 775
  nf = cf + 1;
#line 777
  list = lextree->active;
#line 779
  n = lextree->n_next_active;
#line 780
  if (! (n == 0)) {
#line 780
    __assert_fail("n == 0", "src/lextree.c", 780U, "lextree_hmm_propagate");
  }
#line 781
  i = 0;
#line 781
  while (i < lextree->n_active) {
#line 782
    ln = *(list + i);
#line 783
    hmm = & ln->hmm;
#line 785
    if ((int )ln->frame < nf) {
#line 786
      if (hmm->bestscore >= th) {
#line 787
        ln->frame = (s3frmid_t )nf;
#line 788
        tmp = n;
#line 788
        n ++;
#line 788
        *(lextree->next_active + tmp) = ln;
      } else {
#line 790
        ln->frame = (s3frmid_t )-1;
#line 791
        hmm_clear(hmm, mdef->n_emit_state);
      }
    }
#line 795
    if (ln->wid < 0) {
#line 800
      if (hmm->out.score < pth) {
#line 801
        goto __Cont;
      }
#line 804
      gn = ln->children;
#line 804
      while (gn) {
#line 805
        ln2 = (lextree_node_t *)gn->data.ptr;
#line 806
        hmm2 = & ln2->hmm;
#line 808
        newscore = hmm->out.score + (ln2->prob - ln->prob);
#line 809
        if (newscore >= th) {
#line 809
          if (hmm2->in.score < newscore) {
#line 810
            hmm2->in.score = newscore;
#line 811
            hmm2->in.history = hmm->out.history;
#line 813
            if ((int )ln2->frame != nf) {
#line 814
              ln2->frame = (s3frmid_t )nf;
#line 815
              tmp___0 = n;
#line 815
              n ++;
#line 815
              *(lextree->next_active + tmp___0) = ln2;
            }
          }
        }
#line 804
        gn = gn->next;
      }
    } else {
#line 820
      if (hmm->out.score < wth) {
#line 821
        goto __Cont;
      }
#line 824
      vithist_rescore(vh, kbc, ln->wid, cf, hmm->out.score - ln->prob, hmm->out.history,
                      lextree->type);
    }
    __Cont: /* CIL Label */ 
#line 781
    i ++;
  }
#line 828
  lextree->n_next_active = n;
#line 829
  return;
}
}
#line 1 "vithist.o"
#pragma merger("0","/tmp/cil-dW8sxbxJ.i","-g,-O4")
#line 150 "/usr/include/x86_64-linux-gnu/bits/mathinline.h"
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__, __always_inline__)) __signbitl)(long double __x )  __attribute__((__const__)) ;
#line 150 "/usr/include/x86_64-linux-gnu/bits/mathinline.h"
__inline extern int ( __attribute__((__leaf__, __always_inline__)) __signbitl)(long double __x ) 
{ 
  union __anonunion___u_29___15 __u ;

  {
#line 153
  __u.__l = __x;
#line 154
  return ((__u.__i[2] & 32768) != 0);
}
}
#line 221 "src/vithist.h"
vithist_t *vithist_init(kbcore_t *kbc , int32 wbeam , int32 bghist ) ;
#line 228
int32 vithist_utt_begin(vithist_t *vh , kbcore_t *kbc ) ;
#line 236
int32 vithist_utt_end(vithist_t *vh , kbcore_t *kbc ) ;
#line 243
int32 vithist_partialutt_end(vithist_t *vh , kbcore_t *kbc ) ;
#line 246
void vithist_utt_reset(vithist_t *vh ) ;
#line 253
glist_t vithist_backtrace(vithist_t *vh , int32 id ) ;
#line 259
vithist_entry_t *vithist_id2entry(vithist_t *vh , int32 id ) ;
#line 276
void vithist_frame_windup(vithist_t *vh , int32 frm , FILE *fp , kbcore_t *kbc ) ;
#line 287
void vithist_prune(vithist_t *vh , dict_t *dict , int32 frm , int32 maxwpf___0 , int32 maxhist ,
                   int32 beam ) ;
#line 297
void vithist_dump(vithist_t *vh , int32 frm , kbcore_t *kbc , FILE *fp ) ;
#line 307
void vithist_dag_write(vithist_t *vh , glist_t hyp , dict_t *dict , int32 oldfmt ,
                       FILE *fp ) ;
#line 117 "src/vithist.c"
vithist_t *vithist_init(kbcore_t *kbc , int32 wbeam , int32 bghist ) 
{ 
  vithist_t *vh ;
  lm_t *lm ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;

  {
#line 122
  _E__pr_info_header("src/vithist.c", 122L, "INFO");
#line 122
  _E__pr_info("Initializing Viterbi-history module\n");
#line 124
  tmp = __ckd_calloc__((size_t )1, sizeof(vithist_t ), "src/vithist.c", 124);
#line 124
  vh = (vithist_t *)tmp;
#line 126
  tmp___0 = __ckd_calloc__((size_t )256, sizeof(vithist_entry_t *), "src/vithist.c",
                           126);
#line 126
  vh->entry = (vithist_entry_t **)tmp___0;
#line 127
  vh->n_entry = 0;
#line 129
  tmp___1 = __ckd_calloc__((size_t )15001, sizeof(int32 ), "src/vithist.c", 129);
#line 129
  vh->frame_start = (int32 *)tmp___1;
#line 131
  tmp___2 = __ckd_calloc__((size_t )15001, sizeof(int32 ), "src/vithist.c", 131);
#line 131
  vh->bestscore = (int32 *)tmp___2;
#line 132
  tmp___3 = __ckd_calloc__((size_t )15001, sizeof(int32 ), "src/vithist.c", 132);
#line 132
  vh->bestvh = (int32 *)tmp___3;
#line 134
  vh->wbeam = wbeam;
#line 135
  vh->bghist = bghist;
#line 137
  lm = kbc->lm;
#line 138
  tmp___4 = __ckd_calloc__((size_t )lm->n_ug, sizeof(vh_lms2vh_t *), "src/vithist.c",
                           138);
#line 138
  vh->lms2vh_root = (vh_lms2vh_t **)tmp___4;
#line 139
  vh->lwidlist = (glist_t )((void *)0);
#line 141
  return (vh);
}
}
#line 148 "src/vithist.c"
static vithist_entry_t *vithist_entry_alloc(vithist_t *vh ) 
{ 
  int32 b ;
  int32 l ;
  vithist_entry_t *ve ;
  void *tmp ;

  {
#line 153
  b = vh->n_entry >> 14;
#line 154
  l = vh->n_entry & 16383;
#line 156
  if (l == 0) {
#line 157
    if (b >= 256) {
#line 158
      _E__pr_header("src/vithist.c", 158L, "FATAL_ERROR");
#line 158
      _E__die_error("Viterbi history array exhausted; increase VITHIST_MAXBLKS\n");
    }
#line 160
    if (! ((unsigned long )*(vh->entry + b) == (unsigned long )((void *)0))) {
#line 160
      __assert_fail("vh->entry[b] == ((void *)0)", "src/vithist.c", 160U, "vithist_entry_alloc");
    }
#line 162
    tmp = __ckd_calloc__((size_t )16384, sizeof(vithist_entry_t ), "src/vithist.c",
                         162);
#line 162
    ve = (vithist_entry_t *)tmp;
#line 163
    *(vh->entry + b) = ve;
  } else {
#line 165
    ve = *(vh->entry + b) + l;
  }
#line 167
  (vh->n_entry) ++;
#line 169
  return (ve);
}
}
#line 173 "src/vithist.c"
int32 vithist_utt_begin(vithist_t *vh , kbcore_t *kbc ) 
{ 
  vithist_entry_t *ve ;
  lm_t *lm ;
  dict_t *dict ;

  {
#line 179
  lm = kbc->lm;
#line 180
  dict = kbc->dict;
#line 182
  if (! (vh->n_entry == 0)) {
#line 182
    __assert_fail("vh->n_entry == 0", "src/vithist.c", 182U, "vithist_utt_begin");
  }
#line 183
  if (! ((unsigned long )*(vh->entry + 0) == (unsigned long )((void *)0))) {
#line 183
    __assert_fail("vh->entry[0] == ((void *)0)", "src/vithist.c", 183U, "vithist_utt_begin");
  }
#line 184
  if (! ((unsigned long )vh->lwidlist == (unsigned long )((void *)0))) {
#line 184
    __assert_fail("vh->lwidlist == ((void *)0)", "src/vithist.c", 184U, "vithist_utt_begin");
  }
#line 187
  ve = vithist_entry_alloc(vh);
#line 189
  ve->wid = dict->startwid;
#line 190
  ve->sf = (s3frmid_t )-1;
#line 191
  ve->ef = (s3frmid_t )-1;
#line 192
  ve->ascr = 0;
#line 193
  ve->lscr = 0;
#line 194
  ve->score = 0;
#line 195
  ve->pred = -1;
#line 196
  ve->type = 0;
#line 197
  ve->valid = 1;
#line 198
  ve->lmstate.lm3g.lwid[0] = lm->startlwid;
#line 199
  ve->lmstate.lm3g.lwid[1] = (s3lmwid_t )65535;
#line 201
  vh->n_frm = 0;
#line 202
  *(vh->frame_start + 0) = 1;
#line 203
  *(vh->bestscore + 0) = (int32 )2147483648U;
#line 204
  *(vh->bestvh + 0) = -1;
#line 206
  return (0);
}
}
#line 210 "src/vithist.c"
static int32 vh_lmstate_find(vithist_t *vh , vh_lmstate_t *lms ) 
{ 
  vh_lms2vh_t *lms2vh ;
  s3lmwid_t lwid ;
  gnode_t *gn ;

  {
#line 216
  lwid = lms->lm3g.lwid[0];
#line 217
  lms2vh = *(vh->lms2vh_root + lwid);
#line 217
  if ((unsigned long )lms2vh == (unsigned long )((void *)0)) {
#line 218
    return (-1);
  }
#line 220
  if (! (lms2vh->state == (int32 )lwid)) {
#line 220
    __assert_fail("lms2vh->state == lwid", "src/vithist.c", 220U, "vh_lmstate_find");
  }
#line 222
  lwid = lms->lm3g.lwid[1];
#line 223
  gn = lms2vh->children;
#line 223
  while (gn) {
#line 224
    lms2vh = (vh_lms2vh_t *)gn->data.ptr;
#line 225
    if (lms2vh->state == (int32 )lwid) {
#line 226
      return (lms2vh->vhid);
    }
#line 223
    gn = gn->next;
  }
#line 229
  return (-1);
}
}
#line 237 "src/vithist.c"
static void vithist_lmstate_enter(vithist_t *vh , int32 vhid , vithist_entry_t *ve ) 
{ 
  vh_lms2vh_t *lms2vh ;
  vh_lms2vh_t *child ;
  s3lmwid_t lwid ;
  void *tmp ;
  void *tmp___0 ;

  {
#line 242
  lwid = ve->lmstate.lm3g.lwid[0];
#line 243
  lms2vh = *(vh->lms2vh_root + lwid);
#line 243
  if ((unsigned long )lms2vh == (unsigned long )((void *)0)) {
#line 244
    tmp = __ckd_calloc__((size_t )1, sizeof(vh_lms2vh_t ), "src/vithist.c", 244);
#line 244
    lms2vh = (vh_lms2vh_t *)tmp;
#line 245
    *(vh->lms2vh_root + lwid) = lms2vh;
#line 247
    lms2vh->state = (int32 )lwid;
#line 248
    lms2vh->children = (glist_t )((void *)0);
#line 250
    vh->lwidlist = glist_add_int32(vh->lwidlist, (int32 )lwid);
  } else
#line 252
  if (! (lms2vh->state == (int32 )lwid)) {
#line 252
    __assert_fail("lms2vh->state == lwid", "src/vithist.c", 252U, "vithist_lmstate_enter");
  }
#line 255
  tmp___0 = __ckd_calloc__((size_t )1, sizeof(vh_lms2vh_t ), "src/vithist.c", 255);
#line 255
  child = (vh_lms2vh_t *)tmp___0;
#line 256
  child->state = (int32 )ve->lmstate.lm3g.lwid[1];
#line 257
  child->children = (glist_t )((void *)0);
#line 258
  child->vhid = vhid;
#line 259
  child->ve = ve;
#line 261
  lms2vh->children = glist_add_ptr(lms2vh->children, (void *)child);
#line 262
  return;
}
}
#line 265 "src/vithist.c"
vithist_entry_t *vithist_id2entry(vithist_t *vh , int32 id ) 
{ 
  vithist_entry_t *ve ;

  {
#line 269
  ve = *(vh->entry + (id >> 14)) + (id & 16383);
#line 270
  return (ve);
}
}
#line 274 "src/vithist.c"
static void vithist_enter(vithist_t *vh , kbcore_t *kbc , vithist_entry_t *tve ) 
{ 
  vithist_entry_t *ve ;
  int32 vhid ;

  {
#line 280
  vhid = vh_lmstate_find(vh, & tve->lmstate);
#line 281
  if (vhid < 0) {
#line 282
    vhid = vh->n_entry;
#line 283
    ve = vithist_entry_alloc(vh);
#line 285
    *ve = *tve;
#line 286
    vithist_lmstate_enter(vh, vhid, ve);
  } else {
#line 288
    ve = *(vh->entry + (vhid >> 14)) + (vhid & 16383);
#line 290
    if (ve->score < tve->score) {
#line 291
      *ve = *tve;
    }
  }
#line 295
  if (*(vh->bestscore + vh->n_frm) < tve->score) {
#line 296
    *(vh->bestscore + vh->n_frm) = tve->score;
#line 297
    *(vh->bestvh + vh->n_frm) = vhid;
  }
#line 299
  return;
}
}
#line 302 "src/vithist.c"
void vithist_rescore(vithist_t *vh , kbcore_t *kbc , s3wid_t wid , int32 ef , int32 score ,
                     int32 pred , int32 type ) 
{ 
  vithist_entry_t *pve ;
  vithist_entry_t tve ;
  s3lmwid_t lwid ;
  int32 se ;
  int32 fe___0 ;
  int32 i ;
  int32 tmp ;

  {
#line 310
  if (! (vh->n_frm == ef)) {
#line 310
    __assert_fail("vh->n_frm == ef", "src/vithist.c", 310U, "vithist_rescore");
  }
#line 312
  pve = *(vh->entry + (pred >> 14)) + (pred & 16383);
#line 315
  tve.wid = wid;
#line 316
  tve.sf = (s3frmid_t )((int )pve->ef + 1);
#line 317
  tve.ef = (s3frmid_t )ef;
#line 318
  tve.type = type;
#line 319
  tve.valid = 1;
#line 320
  tve.ascr = score - pve->score;
#line 322
  if (pred == 0) {
#line 323
    se = 0;
#line 324
    fe___0 = 1;
  } else {
#line 326
    se = *(vh->frame_start + pve->ef);
#line 327
    fe___0 = *(vh->frame_start + ((int )pve->ef + 1));
  }
#line 330
  tmp = dict_filler_word(kbc->dict, wid);
#line 330
  if (tmp) {
#line 331
    tve.lscr = fillpen(kbc->fillpen, wid);
#line 332
    tve.score = score + tve.lscr;
#line 333
    tve.pred = pred;
#line 334
    tve.lmstate.lm3g = pve->lmstate.lm3g;
#line 336
    vithist_enter(vh, kbc, & tve);
  } else {
#line 338
    lwid = *(kbc->dict2lmwid + wid);
#line 339
    tve.lmstate.lm3g.lwid[0] = lwid;
#line 341
    i = se;
#line 341
    while (i < fe___0) {
#line 342
      pve = *(vh->entry + (i >> 14)) + (i & 16383);
#line 344
      if (pve->valid) {
#line 345
        tve.lscr = lm_tg_score(kbc->lm, pve->lmstate.lm3g.lwid[1], pve->lmstate.lm3g.lwid[0],
                               lwid);
#line 350
        tve.score = (pve->score + tve.ascr) + tve.lscr;
#line 352
        if (tve.score - vh->wbeam >= *(vh->bestscore + vh->n_frm)) {
#line 353
          tve.pred = i;
#line 354
          tve.lmstate.lm3g.lwid[1] = pve->lmstate.lm3g.lwid[0];
#line 356
          vithist_enter(vh, kbc, & tve);
        }
      }
#line 341
      i ++;
    }
  }
#line 361
  return;
}
}
#line 367 "src/vithist.c"
static void vithist_frame_gc(vithist_t *vh , int32 frm ) 
{ 
  vithist_entry_t *ve ;
  vithist_entry_t *tve ;
  int32 se ;
  int32 fe___0 ;
  int32 te ;
  int32 bs___0 ;
  int32 bv___0 ;
  int32 i ;
  int32 j ;

  {
#line 373
  se = *(vh->frame_start + frm);
#line 374
  fe___0 = vh->n_entry - 1;
#line 375
  te = se;
#line 377
  bs___0 = (int32 )2147483648U;
#line 378
  bv___0 = -1;
#line 379
  i = se;
#line 379
  while (i <= fe___0) {
#line 380
    ve = *(vh->entry + (i >> 14)) + (i & 16383);
#line 381
    if (ve->valid) {
#line 382
      if (i != te) {
#line 383
        tve = *(vh->entry + (te >> 14)) + (te & 16383);
#line 384
        *tve = *ve;
      }
#line 387
      if (ve->score > bs___0) {
#line 388
        bs___0 = ve->score;
#line 389
        bv___0 = te;
      }
#line 392
      te ++;
    }
#line 379
    i ++;
  }
#line 396
  if (! (bs___0 == *(vh->bestscore + frm))) {
#line 396
    __assert_fail("bs == vh->bestscore[frm]", "src/vithist.c", 396U, "vithist_frame_gc");
  }
#line 397
  *(vh->bestvh + frm) = bv___0;
#line 400
  i = (vh->n_entry - 1) >> 14;
#line 401
  j = (te - 1) >> 14;
#line 402
  while (i > j) {
#line 403
    free((void *)*(vh->entry + i));
#line 404
    *(vh->entry + i) = (vithist_entry_t *)((void *)0);
#line 402
    i --;
  }
#line 406
  vh->n_entry = te;
#line 407
  return;
}
}
#line 410 "src/vithist.c"
void vithist_prune(vithist_t *vh , dict_t *dict , int32 frm , int32 maxwpf___0 , int32 maxhist ,
                   int32 beam ) 
{ 
  int32 se ;
  int32 fe___0 ;
  int32 filler_done ;
  int32 th ;
  vithist_entry_t *ve ;
  heap_t h ;
  s3wid_t *wid ;
  int32 i ;
  void *tmp ;
  int32 tmp___0 ;
  int32 tmp___1 ;

  {
#line 419
  if (! (frm >= 0)) {
#line 419
    __assert_fail("frm >= 0", "src/vithist.c", 419U, "vithist_prune");
  }
#line 421
  se = *(vh->frame_start + frm);
#line 422
  fe___0 = vh->n_entry - 1;
#line 424
  th = *(vh->bestscore + frm) + beam;
#line 426
  h = heap_new();
#line 427
  tmp = __ckd_calloc__((size_t )(maxwpf___0 + 1), sizeof(s3wid_t ), "src/vithist.c",
                       427);
#line 427
  wid = (s3wid_t *)tmp;
#line 428
  *(wid + 0) = -1;
#line 430
  i = se;
#line 430
  while (i <= fe___0) {
#line 431
    ve = *(vh->entry + (i >> 14)) + (i & 16383);
#line 432
    heap_insert(h, (void *)ve, - ve->score);
#line 433
    ve->valid = 0;
#line 430
    i ++;
  }
#line 437
  filler_done = 0;
#line 438
  while (1) {
#line 438
    tmp___1 = heap_pop(h, (void **)(& ve), & i);
#line 438
    if (tmp___1 > 0) {
#line 438
      if (ve->score >= th) {
#line 438
        if (! (maxhist > 0)) {
#line 438
          break;
        }
      } else {
#line 438
        break;
      }
    } else {
#line 438
      break;
    }
#line 439
    tmp___0 = dict_filler_word(dict, ve->wid);
#line 439
    if (tmp___0) {
#line 441
      if (filler_done) {
#line 442
        continue;
      }
#line 443
      filler_done = 1;
    }
#line 447
    i = 0;
#line 447
    while (1) {
#line 447
      if (*(wid + i) >= 0) {
#line 447
        if (! (*(wid + i) != ve->wid)) {
#line 447
          break;
        }
      } else {
#line 447
        break;
      }
#line 447
      i ++;
    }
#line 448
    if (*(wid + i) < 0) {
#line 450
      if (maxwpf___0 > 0) {
#line 451
        *(wid + i) = ve->wid;
#line 452
        *(wid + (i + 1)) = -1;
#line 454
        maxwpf___0 --;
#line 455
        maxhist --;
#line 456
        ve->valid = 1;
      }
    } else
#line 458
    if (! vh->bghist) {
#line 459
      maxhist --;
#line 460
      ve->valid = 1;
    }
  }
#line 464
  free((void *)wid);
#line 465
  heap_destroy(h);
#line 468
  vithist_frame_gc(vh, frm);
#line 469
  return;
}
}
#line 472 "src/vithist.c"
static void vithist_lmstate_reset(vithist_t *vh ) 
{ 
  gnode_t *lgn ;
  gnode_t *gn ;
  int32 i ;
  vh_lms2vh_t *lms2vh ;
  vh_lms2vh_t *child ;

  {
#line 478
  lgn = vh->lwidlist;
#line 478
  while (lgn) {
#line 479
    i = lgn->data.int32;
#line 480
    lms2vh = *(vh->lms2vh_root + i);
#line 482
    gn = lms2vh->children;
#line 482
    while (gn) {
#line 483
      child = (vh_lms2vh_t *)gn->data.ptr;
#line 484
      free((void *)child);
#line 482
      gn = gn->next;
    }
#line 486
    glist_free(lms2vh->children);
#line 488
    free((void *)lms2vh);
#line 490
    *(vh->lms2vh_root + i) = (vh_lms2vh_t *)((void *)0);
#line 478
    lgn = lgn->next;
  }
#line 493
  glist_free(vh->lwidlist);
#line 494
  vh->lwidlist = (glist_t )((void *)0);
#line 495
  return;
}
}
#line 498 "src/vithist.c"
void vithist_frame_windup(vithist_t *vh , int32 frm , FILE *fp , kbcore_t *kbc ) 
{ 


  {
#line 500
  if (! (vh->n_frm == frm)) {
#line 500
    __assert_fail("vh->n_frm == frm", "src/vithist.c", 500U, "vithist_frame_windup");
  }
#line 502
  (vh->n_frm) ++;
#line 503
  *(vh->frame_start + vh->n_frm) = vh->n_entry;
#line 505
  if (fp) {
#line 506
    vithist_dump(vh, frm, kbc, fp);
  }
#line 508
  vithist_lmstate_reset(vh);
#line 510
  *(vh->bestscore + vh->n_frm) = (int32 )2147483648U;
#line 511
  *(vh->bestvh + vh->n_frm) = -1;
#line 512
  return;
}
}
#line 514 "src/vithist.c"
int32 vithist_utt_end(vithist_t *vh , kbcore_t *kbc ) 
{ 
  int32 f ;
  int32 i ;
  int32 b ;
  int32 l ;
  int32 sv ;
  int32 nsv ;
  int32 scr ;
  int32 bestscore ;
  int32 bestvh ;
  int32 vhid ;
  vithist_entry_t *ve ;
  vithist_entry_t *bestve ;
  s3lmwid_t endwid ;
  lm_t *lm ;
  dict_t *dict ;
  int32 tmp ;
  int32 tmp___0 ;

  {
#line 518
  bestve = (vithist_entry_t *)0;
#line 524
  f = vh->n_frm - 1;
#line 524
  while (f >= 0) {
#line 525
    sv = *(vh->frame_start + f);
#line 526
    nsv = *(vh->frame_start + (f + 1));
#line 528
    if (sv < nsv) {
#line 529
      break;
    }
#line 524
    f --;
  }
#line 531
  if (f < 0) {
#line 532
    return (-1);
  }
#line 534
  if (f != vh->n_frm - 1) {
#line 535
    _E__pr_header("src/vithist.c", 535L, "ERROR");
#line 535
    _E__pr_warn("No word exit in frame %d, using exits from frame %d\n", vh->n_frm - 1,
                f);
  }
#line 538
  lm = kbc->lm;
#line 539
  endwid = lm->finishlwid;
#line 541
  bestscore = (int32 )2147483648U;
#line 542
  bestvh = -1;
#line 544
  i = sv;
#line 544
  while (i < nsv) {
#line 545
    b = i >> 14;
#line 546
    l = i & 16383;
#line 547
    ve = *(vh->entry + b) + l;
#line 549
    scr = ve->score;
#line 550
    tmp = lm_tg_score(lm, ve->lmstate.lm3g.lwid[1], ve->lmstate.lm3g.lwid[0], endwid);
#line 550
    scr += tmp;
#line 552
    if (bestscore < scr) {
#line 553
      bestscore = scr;
#line 554
      bestvh = i;
#line 555
      bestve = ve;
    }
#line 544
    i ++;
  }
#line 558
  if (! (bestvh >= 0)) {
#line 558
    __assert_fail("bestvh >= 0", "src/vithist.c", 558U, "vithist_utt_end");
  }
#line 560
  dict = kbc->dict;
#line 562
  if (f != vh->n_frm - 1) {
#line 563
    _E__pr_header("src/vithist.c", 563L, "ERROR");
#line 563
    _E__pr_warn("No word exit in frame %d, using exits from frame %d\n", vh->n_frm - 1,
                f);
#line 566
    if (! (*(vh->frame_start + (vh->n_frm - 1)) == *(vh->frame_start + vh->n_frm))) {
#line 566
      __assert_fail("vh->frame_start[vh->n_frm-1] == vh->frame_start[vh->n_frm]",
                    "src/vithist.c", 566U, "vithist_utt_end");
    }
#line 567
    (vh->n_frm) --;
#line 568
    vithist_rescore(vh, kbc, dict->silwid, vh->n_frm, bestve->score, bestvh, -1);
#line 569
    (vh->n_frm) ++;
#line 570
    *(vh->frame_start + vh->n_frm) = vh->n_entry;
#line 572
    tmp___0 = vithist_utt_end(vh, kbc);
#line 572
    return (tmp___0);
  }
#line 576
  vhid = vh->n_entry;
#line 577
  ve = vithist_entry_alloc(vh);
#line 579
  ve->wid = dict->finishwid;
#line 580
  if ((int )bestve->ef == -1) {
#line 580
    ve->sf = (s3frmid_t )0;
  } else {
#line 580
    ve->sf = (s3frmid_t )((int )bestve->ef + 1);
  }
#line 581
  ve->ef = (s3frmid_t )vh->n_frm;
#line 582
  ve->ascr = 0;
#line 583
  ve->lscr = bestscore - bestve->score;
#line 584
  ve->score = bestscore;
#line 585
  ve->pred = bestvh;
#line 586
  ve->type = 0;
#line 587
  ve->valid = 1;
#line 588
  ve->lmstate.lm3g.lwid[0] = endwid;
#line 589
  ve->lmstate.lm3g.lwid[1] = ve->lmstate.lm3g.lwid[0];
#line 591
  return (vhid);
}
}
#line 595 "src/vithist.c"
int32 vithist_partialutt_end(vithist_t *vh , kbcore_t *kbc ) 
{ 
  int32 f ;
  int32 i ;
  int32 b ;
  int32 l ;
  int32 sv ;
  int32 nsv ;
  int32 scr ;
  int32 bestscore ;
  int32 bestvh ;
  vithist_entry_t *ve ;
  vithist_entry_t *bestve ;
  s3lmwid_t endwid ;
  lm_t *lm ;
  int32 tmp ;

  {
#line 604
  f = vh->n_frm - 1;
#line 604
  while (f >= 0) {
#line 605
    sv = *(vh->frame_start + f);
#line 606
    nsv = *(vh->frame_start + (f + 1));
#line 608
    if (sv < nsv) {
#line 609
      break;
    }
#line 604
    f --;
  }
#line 611
  if (f < 0) {
#line 612
    return (-1);
  }
#line 614
  if (f != vh->n_frm - 1) {
#line 615
    _E__pr_header("src/vithist.c", 615L, "ERROR");
#line 615
    _E__pr_warn("No word exits from last frame in block %d\n", vh->n_frm - 1);
#line 616
    return (-1);
  }
#line 620
  lm = kbc->lm;
#line 621
  endwid = lm->finishlwid;
#line 623
  bestscore = (int32 )2147483648U;
#line 624
  bestvh = -1;
#line 626
  i = sv;
#line 626
  while (i < nsv) {
#line 627
    b = i >> 14;
#line 628
    l = i & 16383;
#line 629
    ve = *(vh->entry + b) + l;
#line 631
    scr = ve->score;
#line 632
    tmp = lm_tg_score(lm, ve->lmstate.lm3g.lwid[1], ve->lmstate.lm3g.lwid[0], endwid);
#line 632
    scr += tmp;
#line 634
    if (bestscore < scr) {
#line 635
      bestscore = scr;
#line 636
      bestvh = i;
#line 637
      bestve = ve;
    }
#line 626
    i ++;
  }
#line 641
  return (bestvh);
}
}
#line 645 "src/vithist.c"
void vithist_utt_reset(vithist_t *vh ) 
{ 
  int32 b ;

  {
#line 649
  vithist_lmstate_reset(vh);
#line 651
  b = (vh->n_entry - 1) >> 14;
#line 651
  while (b >= 0) {
#line 652
    free((void *)*(vh->entry + b));
#line 653
    *(vh->entry + b) = (vithist_entry_t *)((void *)0);
#line 651
    b --;
  }
#line 655
  vh->n_entry = 0;
#line 657
  *(vh->bestscore + 0) = (int32 )2147483648U;
#line 658
  *(vh->bestvh + 0) = -1;
#line 659
  return;
}
}
#line 718 "src/vithist.c"
void vithist_dump(vithist_t *vh , int32 frm , kbcore_t *kbc , FILE *fp ) 
{ 
  int32 b ;
  int32 l ;
  int32 i ;
  int32 j ;
  dict_t *dict ;
  lm_t *lm ;
  vithist_entry_t *ve ;
  s3lmwid_t lwid ;
  int32 sf ;
  int32 ef ;
  int tmp ;

  {
#line 727
  dict = kbc->dict;
#line 728
  lm = kbc->lm;
#line 730
  if (frm >= 0) {
#line 731
    sf = frm;
#line 732
    ef = frm;
#line 734
    fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"VITHIST  frame %d  #entries %d\n",
            frm, *(vh->frame_start + (sf + 1)) - *(vh->frame_start + sf));
  } else {
#line 737
    sf = 0;
#line 738
    ef = vh->n_frm - 1;
#line 740
    fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"VITHIST  #frames %d  #entries %d\n",
            vh->n_frm, vh->n_entry);
  }
#line 742
  fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"\t%7s %5s %5s %11s %9s %8s %7s %4s Word (LM-state)\n",
          "Seq/Val", "SFrm", "EFrm", "PathScr", "SegAScr", "SegLScr", "Pred", "Type");
#line 745
  i = sf;
#line 745
  while (i <= ef) {
#line 746
    fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"%5d BS: %11d BV: %8d\n",
            i, *(vh->bestscore + i), *(vh->bestvh + i));
#line 748
    j = *(vh->frame_start + i);
#line 748
    while (j < *(vh->frame_start + (i + 1))) {
#line 750
      b = j >> 14;
#line 751
      l = j & 16383;
#line 752
      ve = *(vh->entry + b) + l;
#line 754
      if (ve->valid) {
#line 754
        tmp = ' ';
      } else {
#line 754
        tmp = '*';
      }
#line 754
      fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"\t%c%6d %5d %5d %11d %9d %8d %7d %4d %s",
              tmp, j, (int )ve->sf, (int )ve->ef, ve->score, ve->ascr, ve->lscr, ve->pred,
              ve->type, (dict->word + ve->wid)->word);
#line 759
      fprintf((FILE * __restrict  )fp, (char const   * __restrict  )" (%s", *(lm->wordstr + ve->lmstate.lm3g.lwid[0]));
#line 760
      lwid = ve->lmstate.lm3g.lwid[1];
#line 761
      if ((int )lwid != 65535) {
#line 762
        fprintf((FILE * __restrict  )fp, (char const   * __restrict  )", %s", *(lm->wordstr + lwid));
      }
#line 763
      fprintf((FILE * __restrict  )fp, (char const   * __restrict  )")\n");
#line 748
      j ++;
    }
#line 766
    if (j == *(vh->frame_start + i)) {
#line 767
      fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"\n");
    }
#line 745
    i ++;
  }
#line 775
  fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"END_VITHIST\n");
#line 776
  fflush(fp);
#line 777
  return;
}
}
#line 779 "src/vithist.c"
glist_t vithist_backtrace(vithist_t *vh , int32 id ) 
{ 
  vithist_entry_t *ve ;
  int32 b ;
  int32 l ;
  glist_t hyp ;
  hyp_t *h ;
  void *tmp ;

  {
#line 786
  hyp = (glist_t )((void *)0);
#line 788
  while (id > 0) {
#line 789
    b = id >> 14;
#line 790
    l = id & 16383;
#line 791
    ve = *(vh->entry + b) + l;
#line 793
    tmp = __ckd_calloc__((size_t )1, sizeof(hyp_t ), "src/vithist.c", 793);
#line 793
    h = (hyp_t *)tmp;
#line 794
    h->id = ve->wid;
#line 795
    h->sf = (int32 )ve->sf;
#line 796
    h->ef = (int32 )ve->ef;
#line 797
    h->ascr = ve->ascr;
#line 798
    h->lscr = ve->lscr;
#line 799
    h->type = ve->type;
#line 800
    h->vhid = id;
#line 802
    hyp = glist_add_ptr(hyp, (void *)h);
#line 804
    id = ve->pred;
  }
#line 807
  return (hyp);
}
}
#line 822 "src/vithist.c"
void vithist_dag_write(vithist_t *vh , glist_t hyp , dict_t *dict , int32 oldfmt ,
                       FILE *fp ) 
{ 
  glist_t *sfwid ;
  vithist_entry_t *ve ;
  vithist_entry_t *ve2 ;
  gnode_t *gn ;
  gnode_t *gn2 ;
  gnode_t *gn3 ;
  dagnode_t *dn ;
  dagnode_t *dn2 ;
  int32 sf ;
  int32 ef ;
  int32 n_node ;
  int32 f ;
  int32 i ;
  hyp_t *h ;
  void *tmp ;
  void *tmp___0 ;
  int32 tmp___1 ;

  {
#line 832
  tmp = __ckd_calloc__((size_t )(vh->n_frm + 1), sizeof(glist_t ), "src/vithist.c",
                       832);
#line 832
  sfwid = (glist_t *)tmp;
#line 834
  n_node = 0;
#line 835
  i = 0;
#line 835
  while (i < vh->n_entry) {
#line 836
    ve = *(vh->entry + (i >> 14)) + (i & 16383);
#line 837
    if (! ve->valid) {
#line 838
      goto __Cont;
    }
#line 846
    if ((int )ve->sf <= 0) {
#line 847
      if (! ((int )ve->sf >= -1)) {
#line 847
        __assert_fail("ve->sf >= -1", "src/vithist.c", 847U, "vithist_dag_write");
      }
#line 848
      if (! ((int )ve->ef == -1)) {
#line 848
        if (! ((int )ve->ef > 1)) {
#line 848
          __assert_fail("(ve->ef == -1) || (ve->ef > 1)", "src/vithist.c", 848U, "vithist_dag_write");
        }
      }
#line 850
      sf = (int )ve->sf + 1;
#line 851
      if ((int )ve->ef < 0) {
#line 851
        ef = 0;
      } else {
#line 851
        ef = (int32 )ve->ef;
      }
    } else {
#line 853
      sf = (int32 )ve->sf;
#line 854
      ef = (int32 )ve->ef;
    }
#line 857
    gn = *(sfwid + sf);
#line 857
    while (gn) {
#line 858
      dn = (dagnode_t *)gn->data.ptr;
#line 859
      if (dn->wid == ve->wid) {
#line 860
        break;
      }
#line 857
      gn = gn->next;
    }
#line 862
    if (! gn) {
#line 863
      tmp___0 = __ckd_calloc__((size_t )1, sizeof(dagnode_t ), "src/vithist.c", 863);
#line 863
      dn = (dagnode_t *)tmp___0;
#line 864
      dn->wid = ve->wid;
#line 865
      dn->fef = ef;
#line 866
      dn->lef = ef;
#line 867
      dn->seqid = -1;
#line 868
      dn->velist = (glist_t )((void *)0);
#line 869
      n_node ++;
#line 871
      *(sfwid + sf) = glist_add_ptr(*(sfwid + sf), (void *)dn);
    } else {
#line 873
      dn->lef = ef;
    }
#line 880
    gn = dn->velist;
#line 880
    while (gn) {
#line 881
      ve2 = (vithist_entry_t *)gn->data.ptr;
#line 882
      if ((int )ve2->ef == (int )ve->ef) {
#line 883
        break;
      }
#line 880
      gn = gn->next;
    }
#line 885
    if (gn) {
#line 886
      if (ve->score > ve2->score) {
#line 887
        gn->data.ptr = (void *)ve;
      }
    } else {
#line 889
      dn->velist = glist_add_ptr(dn->velist, (void *)ve);
    }
    __Cont: /* CIL Label */ 
#line 835
    i ++;
  }
#line 896
  gn = hyp;
#line 896
  while (gn) {
#line 897
    h = (hyp_t *)gn->data.ptr;
#line 898
    gn2 = *(sfwid + h->sf);
#line 898
    while (gn2) {
#line 899
      dn = (dagnode_t *)gn2->data.ptr;
#line 900
      if (h->id == dn->wid) {
#line 901
        dn->seqid = 0;
      }
#line 898
      gn2 = gn2->next;
    }
#line 896
    gn = gn->next;
  }
#line 906
  dn = (dagnode_t *)(*(sfwid + 0))->data.ptr;
#line 907
  if (! (dn->wid == dict->startwid)) {
#line 907
    __assert_fail("dn->wid == ((dict)->startwid)", "src/vithist.c", 907U, "vithist_dag_write");
  }
#line 908
  dn->seqid = 0;
#line 909
  dn = (dagnode_t *)(*(sfwid + vh->n_frm))->data.ptr;
#line 910
  if (! (dn->wid == dict->finishwid)) {
#line 910
    __assert_fail("dn->wid == ((dict)->finishwid)", "src/vithist.c", 910U, "vithist_dag_write");
  }
#line 911
  dn->seqid = 0;
#line 914
  i = 0;
#line 915
  f = vh->n_frm;
#line 915
  while (f >= 0) {
#line 916
    gn = *(sfwid + f);
#line 916
    while (gn) {
#line 917
      dn = (dagnode_t *)gn->data.ptr;
#line 918
      if (dn->lef > dn->fef) {
#line 919
        tmp___1 = i;
#line 919
        i ++;
#line 919
        dn->seqid = tmp___1;
      } else
#line 918
      if (dn->seqid >= 0) {
#line 919
        tmp___1 = i;
#line 919
        i ++;
#line 919
        dn->seqid = tmp___1;
      } else {
#line 921
        dn->seqid = -1;
      }
#line 916
      gn = gn->next;
    }
#line 915
    f --;
  }
#line 924
  n_node = i;
#line 927
  fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"Nodes %d (NODEID WORD STARTFRAME FIRST-ENDFRAME LAST-ENDFRAME)\n",
          n_node);
#line 928
  f = vh->n_frm;
#line 928
  while (f >= 0) {
#line 929
    gn = *(sfwid + f);
#line 929
    while (gn) {
#line 930
      dn = (dagnode_t *)gn->data.ptr;
#line 931
      if (dn->seqid >= 0) {
#line 932
        fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"%d %s %d %d %d\n",
                dn->seqid, (dict->word + dn->wid)->word, f, dn->fef, dn->lef);
      }
#line 929
      gn = gn->next;
    }
#line 928
    f --;
  }
#line 937
  fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"#\n");
#line 939
  fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"Initial %d\nFinal %d\n",
          n_node - 1, 0);
#line 940
  fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"#\n");
#line 942
  fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"BestSegAscr 0 (NODEID ENDFRAME ASCORE)\n");
#line 943
  fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"#\n");
#line 946
  if (oldfmt) {
#line 947
    fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"Edges (FROM-NODEID TO-NODEID ASCORE)\n");
  } else {
#line 949
    fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"Edges (FROM-NODEID ENDFRAME ASCORE)\n");
  }
#line 950
  f = vh->n_frm - 1;
#line 950
  while (f >= 0) {
#line 951
    gn = *(sfwid + f);
#line 951
    while (gn) {
#line 952
      dn = (dagnode_t *)gn->data.ptr;
#line 954
      if (dn->seqid < 0) {
#line 955
        goto __Cont___0;
      }
#line 957
      gn2 = dn->velist;
#line 957
      while (gn2) {
#line 958
        ve = (vithist_entry_t *)gn2->data.ptr;
#line 960
        if ((int )ve->ef < 0) {
#line 960
          sf = 1;
        } else {
#line 960
          sf = (int )ve->ef + 1;
        }
#line 962
        if (oldfmt) {
#line 963
          gn3 = *(sfwid + sf);
#line 963
          while (gn3) {
#line 964
            dn2 = (dagnode_t *)gn3->data.ptr;
#line 965
            if (dn2->seqid >= 0) {
#line 966
              fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"%d %d %d\n",
                      dn->seqid, dn2->seqid, ve->ascr);
            }
#line 963
            gn3 = gn3->next;
          }
        } else {
#line 969
          gn3 = *(sfwid + sf);
#line 969
          while (gn3) {
#line 970
            dn2 = (dagnode_t *)gn3->data.ptr;
#line 971
            if (dn2->seqid >= 0) {
#line 972
              fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"%d %d %d\n",
                      dn->seqid, sf - 1, ve->ascr);
#line 973
              break;
            }
#line 969
            gn3 = gn3->next;
          }
        }
#line 957
        gn2 = gn2->next;
      }
      __Cont___0: /* CIL Label */ 
#line 951
      gn = gn->next;
    }
#line 950
    f --;
  }
#line 980
  fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"End\n");
#line 983
  f = 0;
#line 983
  while (f <= vh->n_frm) {
#line 984
    gn = *(sfwid + f);
#line 984
    while (gn) {
#line 985
      dn = (dagnode_t *)gn->data.ptr;
#line 987
      glist_free(dn->velist);
#line 988
      free((void *)dn);
#line 984
      gn = gn->next;
    }
#line 991
    glist_free(*(sfwid + f));
#line 983
    f ++;
  }
#line 993
  free((void *)sfwid);
#line 994
  return;
}
}
#line 999 "src/vithist.c"
void vithist_free(vithist_t *v ) 
{ 


  {
#line 1001
  if (v) {
#line 1002
    free((void *)v);
  }
#line 1005
  return;
}
}
#line 1 "ascr.o"
#pragma merger("0","/tmp/cil-VoGT6PsD.i","-g,-O4")
#line 150 "/usr/include/x86_64-linux-gnu/bits/mathinline.h"
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__, __always_inline__)) __signbitl)(long double __x )  __attribute__((__const__)) ;
#line 150 "/usr/include/x86_64-linux-gnu/bits/mathinline.h"
__inline extern int ( __attribute__((__leaf__, __always_inline__)) __signbitl)(long double __x ) 
{ 
  union __anonunion___u_29___16 __u ;

  {
#line 153
  __u.__l = __x;
#line 154
  return ((__u.__i[2] & 32768) != 0);
}
}
#line 125 "src/ascr.h"
ascr_t *ascr_init(int32 n_sen , int32 n_comsen ) ;
#line 107 "src/ascr.c"
ascr_t *ascr_init(int32 n_sen , int32 n_comsen ) 
{ 
  ascr_t *ascr ;
  void *tmp ;
  void *tmp___0 ;

  {
#line 111
  tmp = __ckd_calloc__((size_t )1, sizeof(ascr_t ), "src/ascr.c", 111);
#line 111
  ascr = (ascr_t *)tmp;
#line 112
  tmp___0 = __ckd_calloc__((size_t )(n_sen + n_comsen), sizeof(int32 ), "src/ascr.c",
                           112);
#line 112
  ascr->sen = (int32 *)tmp___0;
#line 113
  ascr->comsen = ascr->sen + n_sen;
#line 115
  return (ascr);
}
}
#line 1 "beam.o"
#pragma merger("0","/tmp/cil-IgmAUpIs.i","-g,-O4")
#line 150 "/usr/include/x86_64-linux-gnu/bits/mathinline.h"
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__, __always_inline__)) __signbitl)(long double __x )  __attribute__((__const__)) ;
#line 150 "/usr/include/x86_64-linux-gnu/bits/mathinline.h"
__inline extern int ( __attribute__((__leaf__, __always_inline__)) __signbitl)(long double __x ) 
{ 
  union __anonunion___u_29___17 __u ;

  {
#line 153
  __u.__l = __x;
#line 154
  return ((__u.__i[2] & 32768) != 0);
}
}
#line 128 "src/beam.h"
beam_t *beam_init(float64 svq , float64 hmm , float64 ptr , float64 wd ) ;
#line 108 "src/beam.c"
beam_t *beam_init(float64 svq , float64 hmm , float64 ptr , float64 wd ) 
{ 
  beam_t *beam ;
  void *tmp ;

  {
#line 112
  tmp = __ckd_calloc__((size_t )1, sizeof(beam_t ), "src/beam.c", 112);
#line 112
  beam = (beam_t *)tmp;
#line 114
  beam->subvq = logs3(svq);
#line 115
  beam->hmm = logs3(hmm);
#line 116
  beam->ptrans = logs3(ptr);
#line 117
  beam->word = logs3(wd);
#line 119
  return (beam);
}
}
#line 1 "kb.o"
#pragma merger("0","/tmp/cil-E0Nsk7II.i","-g,-O4")
#line 150 "/usr/include/x86_64-linux-gnu/bits/mathinline.h"
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__, __always_inline__)) __signbitl)(long double __x )  __attribute__((__const__)) ;
#line 150 "/usr/include/x86_64-linux-gnu/bits/mathinline.h"
__inline extern int ( __attribute__((__leaf__, __always_inline__)) __signbitl)(long double __x ) 
{ 
  union __anonunion___u_29___18 __u ;

  {
#line 153
  __u.__l = __x;
#line 154
  return ((__u.__i[2] & 32768) != 0);
}
}
#line 210 "src/feat.h"
float32 ***feat_array_alloc(feat_t *fcb , int32 nfr ) ;
#line 168 "src/kb.h"
void kb_init(kb_t *kb___0 ) ;
#line 169
void kb_lextree_active_swap(kb_t *kb___0 ) ;
#line 170
void kb_free(kb_t *kb___0 ) ;
#line 115 "src/kb.c"
void kb_init(kb_t *kb___0 ) 
{ 
  kbcore_t *kbcore___0 ;
  mdef_t *mdef ;
  dict_t *dict ;
  dict2pid_t *d2p ;
  lm_t *lm ;
  s3cipid_t sil ;
  s3cipid_t ci ;
  s3wid_t w___0 ;
  int32 i ;
  int32 n ;
  int32 n_lc ;
  wordprob_t *wp ;
  s3cipid_t *lc ;
  bitvec_t lc_active ;
  char *str ;
  void const   *tmp ;
  void const   *tmp___0 ;
  void const   *tmp___1 ;
  void const   *tmp___2 ;
  void const   *tmp___3 ;
  void const   *tmp___4 ;
  void const   *tmp___5 ;
  void const   *tmp___6 ;
  void const   *tmp___7 ;
  void const   *tmp___8 ;
  void const   *tmp___9 ;
  void const   *tmp___10 ;
  void const   *tmp___11 ;
  void const   *tmp___12 ;
  void const   *tmp___13 ;
  void const   *tmp___14 ;
  void const   *tmp___15 ;
  void const   *tmp___16 ;
  void const   *tmp___17 ;
  void const   *tmp___18 ;
  void const   *tmp___19 ;
  void const   *tmp___20 ;
  int32 tmp___21 ;
  void *tmp___22 ;
  void *tmp___23 ;
  void *tmp___24 ;
  void *tmp___25 ;
  void const   *tmp___26 ;
  void *tmp___27 ;
  void *tmp___28 ;
  int32 tmp___29 ;
  void const   *tmp___30 ;
  void *tmp___31 ;
  int32 tmp___32 ;
  void *tmp___33 ;
  void const   *tmp___34 ;
  void const   *tmp___35 ;
  void const   *tmp___36 ;
  void const   *tmp___37 ;
  void const   *tmp___38 ;
  float32 ***tmp___39 ;
  void const   *tmp___40 ;
  void const   *tmp___41 ;
  void *tmp___42 ;
  void const   *tmp___43 ;
  FILE *tmp___44 ;

  {
#line 131
  memset((void *)kb___0, 0, sizeof(*kb___0));
#line 133
  tmp = cmd_ln_access((char *)"-tmatfloor");
#line 133
  tmp___0 = cmd_ln_access((char *)"-tmat");
#line 133
  tmp___1 = cmd_ln_access((char *)"-subvq");
#line 133
  tmp___2 = cmd_ln_access((char *)"-mixwfloor");
#line 133
  tmp___3 = cmd_ln_access((char *)"-mixw");
#line 133
  tmp___4 = cmd_ln_access((char *)"-varfloor");
#line 133
  tmp___5 = cmd_ln_access((char *)"-var");
#line 133
  tmp___6 = cmd_ln_access((char *)"-mean");
#line 133
  tmp___7 = cmd_ln_access((char *)"-uw");
#line 133
  tmp___8 = cmd_ln_access((char *)"-wip");
#line 133
  tmp___9 = cmd_ln_access((char *)"-lw");
#line 133
  tmp___10 = cmd_ln_access((char *)"-fillprob");
#line 133
  tmp___11 = cmd_ln_access((char *)"-silprob");
#line 133
  tmp___12 = cmd_ln_access((char *)"-fillpen");
#line 133
  tmp___13 = cmd_ln_access((char *)"-lm");
#line 133
  tmp___14 = cmd_ln_access((char *)"-fdict");
#line 133
  tmp___15 = cmd_ln_access((char *)"-dict");
#line 133
  tmp___16 = cmd_ln_access((char *)"-mdef");
#line 133
  tmp___17 = cmd_ln_access((char *)"-agc");
#line 133
  tmp___18 = cmd_ln_access((char *)"-varnorm");
#line 133
  tmp___19 = cmd_ln_access((char *)"-cmn");
#line 133
  tmp___20 = cmd_ln_access((char *)"-logbase");
#line 133
  kb___0->kbcore = kbcore_init((float64 )*((float32 *)tmp___20), (char *)"1s_c_d_dd",
                               (char *)tmp___19, (char *)tmp___18, (char *)tmp___17,
                               (char *)tmp___16, (char *)tmp___15, (char *)tmp___14,
                               (char *)"", (char *)tmp___13, (char *)tmp___12, (float64 )*((float32 *)tmp___11),
                               (float64 )*((float32 *)tmp___10), (float64 )*((float32 *)tmp___9),
                               (float64 )*((float32 *)tmp___8), (float64 )*((float32 *)tmp___7),
                               (char *)tmp___6, (char *)tmp___5, (float64 )*((float32 *)tmp___4),
                               (char *)tmp___3, (float64 )*((float32 *)tmp___2), (char *)tmp___1,
                               (char *)tmp___0, (float64 )*((float32 *)tmp));
#line 159
  kbcore___0 = kb___0->kbcore;
#line 161
  mdef = kbcore___0->mdef;
#line 162
  dict = kbcore___0->dict;
#line 163
  lm = kbcore___0->lm;
#line 164
  d2p = kbcore___0->dict2pid;
#line 166
  if (dict->startwid < 0) {
#line 167
    _E__pr_header("src/kb.c", 167L, "FATAL_ERROR");
#line 167
    _E__die_error("%s or %s not in dictionary\n", "<s>", "</s>");
  } else
#line 166
  if (dict->finishwid < 0) {
#line 167
    _E__pr_header("src/kb.c", 167L, "FATAL_ERROR");
#line 167
    _E__die_error("%s or %s not in dictionary\n", "<s>", "</s>");
  }
#line 168
  if ((int )lm->startlwid == 65535) {
#line 169
    _E__pr_header("src/kb.c", 169L, "FATAL_ERROR");
#line 169
    _E__die_error("%s or %s not in LM\n", "<s>", "</s>");
  } else
#line 168
  if ((int )lm->finishlwid == 65535) {
#line 169
    _E__pr_header("src/kb.c", 169L, "FATAL_ERROR");
#line 169
    _E__die_error("%s or %s not in LM\n", "<s>", "</s>");
  }
#line 172
  tmp___21 = tmat_chk_1skip(kbcore___0->tmat);
#line 172
  if (tmp___21 < 0) {
#line 173
    _E__pr_header("src/kb.c", 173L, "FATAL_ERROR");
#line 173
    _E__die_error("Tmat contains arcs skipping more than 1 state\n");
  }
#line 180
  (lm->ug + lm->startlwid)->dictwid = -1;
#line 181
  (lm->ug + lm->finishlwid)->dictwid = -1;
#line 182
  w___0 = dict->startwid;
#line 182
  while (w___0 >= 0) {
#line 183
    *(kbcore___0->dict2lmwid + w___0) = (s3lmwid_t )65535;
#line 182
    w___0 = (dict->word + w___0)->alt;
  }
#line 184
  w___0 = dict->finishwid;
#line 184
  while (w___0 >= 0) {
#line 185
    *(kbcore___0->dict2lmwid + w___0) = (s3lmwid_t )65535;
#line 184
    w___0 = (dict->word + w___0)->alt;
  }
#line 187
  sil = (kbcore___0->mdef)->sil;
#line 188
  if ((int )sil < 0) {
#line 189
    _E__pr_header("src/kb.c", 189L, "FATAL_ERROR");
#line 189
    _E__die_error("Silence phone \'%s\' not in mdef\n", "SIL");
  }
#line 191
  _E__pr_info_header("src/kb.c", 191L, "INFO");
#line 191
  _E__pr_info("Building lextrees\n");
#line 201
  tmp___22 = __ckd_calloc__((size_t )mdef->n_sen, sizeof(int32 ), "src/kb.c", 201);
#line 201
  kb___0->sen_active = (int32 *)tmp___22;
#line 202
  tmp___23 = __ckd_calloc__((size_t )mdef->n_sseq, sizeof(int32 ), "src/kb.c", 202);
#line 202
  kb___0->ssid_active = (int32 *)tmp___23;
#line 203
  tmp___24 = __ckd_calloc__((size_t )d2p->n_comsseq, sizeof(int32 ), "src/kb.c", 204);
#line 203
  kb___0->comssid_active = (int32 *)tmp___24;
#line 207
  _E__pr_info_header("src/kb.c", 207L, "INFO");
#line 207
  _E__pr_info("ALEX sen_active %d ssid_active %d comssid_active %d\n", mdef->n_sen,
              mdef->n_sseq, d2p->n_comsseq);
#line 210
  tmp___25 = __ckd_calloc__((size_t )dict->n_word, sizeof(wordprob_t ), "src/kb.c",
                            210);
#line 210
  wp = (wordprob_t *)tmp___25;
#line 211
  n = lm_ug_wordprob(lm, (int32 )2147483648U, wp);
#line 212
  if (n < 1) {
#line 213
    _E__pr_header("src/kb.c", 213L, "FATAL_ERROR");
#line 213
    _E__die_error("%d active words\n", n);
  }
#line 214
  n = wid_wordprob2alt(dict, wp, n);
#line 217
  tmp___26 = cmd_ln_access((char *)"-treeugprob");
#line 217
  if (*((int32 *)tmp___26) == 0) {
#line 218
    i = 0;
#line 218
    while (i < n) {
#line 219
      (wp + i)->prob = -1;
#line 218
      i ++;
    }
  }
#line 223
  tmp___27 = __ckd_calloc__((size_t )(mdef->n_ciphone + 1), sizeof(s3cipid_t ), "src/kb.c",
                            223);
#line 223
  lc = (s3cipid_t *)tmp___27;
#line 224
  tmp___28 = __ckd_calloc__((size_t )((mdef->n_ciphone + 31) >> 5), sizeof(uint32 ),
                            "src/kb.c", 224);
#line 224
  lc_active = (bitvec_t )tmp___28;
#line 225
  w___0 = 0;
#line 225
  while (w___0 < dict->n_word) {
#line 226
    ci = *((dict->word + w___0)->ciphone + ((dict->word + w___0)->pronlen - 1));
#line 227
    if (! (mdef->ciphone + (int )ci)->filler) {
#line 228
      *(lc_active + ((int )ci >> 5)) |= (unsigned int )(1 << ((int )ci & 31));
    }
#line 225
    w___0 ++;
  }
#line 230
  ci = mdef->sil;
#line 231
  *(lc_active + ((int )ci >> 5)) |= (unsigned int )(1 << ((int )ci & 31));
#line 232
  ci = (s3cipid_t )0;
#line 232
  n_lc = 0;
#line 232
  while ((int )ci < mdef->n_ciphone) {
#line 233
    if (*(lc_active + ((int )ci >> 5)) & (unsigned int )(1 << ((int )ci & 31))) {
#line 234
      tmp___29 = n_lc;
#line 234
      n_lc ++;
#line 234
      *(lc + tmp___29) = ci;
    }
#line 232
    ci = (s3cipid_t )((int )ci + 1);
  }
#line 236
  *(lc + n_lc) = (s3cipid_t )-1;
#line 239
  tmp___30 = cmd_ln_access((char *)"-Nlextree");
#line 239
  kb___0->n_lextree = *((int32 *)tmp___30);
#line 240
  if (kb___0->n_lextree < 1) {
#line 241
    _E__pr_header("src/kb.c", 241L, "ERROR");
#line 241
    _E__pr_warn("No. of ugtrees specified: %d; will instantiate 1 ugtree\n", kb___0->n_lextree);
#line 243
    kb___0->n_lextree = 1;
  }
#line 245
  tmp___31 = __ckd_calloc__((size_t )kb___0->n_lextree, sizeof(lextree_t *), "src/kb.c",
                            245);
#line 245
  kb___0->ugtree = (lextree_t **)tmp___31;
#line 246
  i = 0;
#line 246
  while (i < kb___0->n_lextree) {
#line 247
    *(kb___0->ugtree + i) = lextree_build(kbcore___0, wp, n, lc);
#line 248
    (*(kb___0->ugtree + i))->type = 0;
#line 246
    i ++;
  }
#line 250
  free((void *)((char *)lc_active));
#line 251
  free((void *)lc);
#line 254
  n = 0;
#line 255
  i = dict->filler_start;
#line 255
  while (i <= dict->filler_end) {
#line 256
    tmp___32 = dict_filler_word(dict, i);
#line 256
    if (tmp___32) {
#line 257
      (wp + n)->wid = i;
#line 258
      (wp + n)->prob = fillpen(kbcore___0->fillpen, i);
#line 259
      n ++;
    }
#line 255
    i ++;
  }
#line 262
  tmp___33 = __ckd_calloc__((size_t )kb___0->n_lextree, sizeof(lextree_t *), "src/kb.c",
                            262);
#line 262
  kb___0->fillertree = (lextree_t **)tmp___33;
#line 263
  i = 0;
#line 263
  while (i < kb___0->n_lextree) {
#line 264
    *(kb___0->fillertree + i) = lextree_build(kbcore___0, wp, n, (s3cipid_t *)((void *)0));
#line 265
    (*(kb___0->fillertree + i))->type = -1;
#line 263
    i ++;
  }
#line 267
  free((void *)wp);
#line 269
  _E__pr_info_header("src/kb.c", 269L, "INFO");
#line 269
  _E__pr_info("Lextrees(%d), %d nodes(ug), %d nodes(filler)\n", kb___0->n_lextree,
              (*(kb___0->ugtree + 0))->n_node, (*(kb___0->fillertree + 0))->n_node);
#line 273
  tmp___34 = cmd_ln_access((char *)"-lextreedump");
#line 273
  if (*((int32 *)tmp___34)) {
#line 274
    i = 0;
#line 274
    while (i < kb___0->n_lextree) {
#line 275
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"UGTREE %d\n",
              i);
#line 276
      lextree_dump(*(kb___0->ugtree + i), dict, stderr);
#line 274
      i ++;
    }
#line 278
    i = 0;
#line 278
    while (i < kb___0->n_lextree) {
#line 279
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"FILLERTREE %d\n",
              i);
#line 280
      lextree_dump(*(kb___0->fillertree + i), dict, stderr);
#line 278
      i ++;
    }
#line 282
    fflush(stderr);
  }
#line 285
  kb___0->ascr = ascr_init((kbcore___0->mgau)->n_mgau, (kbcore___0->dict2pid)->n_comstate);
#line 287
  tmp___35 = cmd_ln_access((char *)"-wbeam");
#line 287
  tmp___36 = cmd_ln_access((char *)"-pbeam");
#line 287
  tmp___37 = cmd_ln_access((char *)"-beam");
#line 287
  tmp___38 = cmd_ln_access((char *)"-subvqbeam");
#line 287
  kb___0->beam = beam_init(*((float64 *)tmp___38), *((float64 *)tmp___37), *((float64 *)tmp___36),
                           *((float64 *)tmp___35));
#line 291
  _E__pr_info_header("src/kb.c", 291L, "INFO");
#line 291
  _E__pr_info("Beam= %d, PBeam= %d, WBeam= %d, SVQBeam= %d\n", (kb___0->beam)->hmm,
              (kb___0->beam)->ptrans, (kb___0->beam)->word, (kb___0->beam)->subvq);
#line 294
  tmp___39 = feat_array_alloc(kbcore___0->fcb, 15000);
#line 294
  kb___0->feat = tmp___39;
#line 294
  if ((unsigned long )tmp___39 == (unsigned long )((void *)0)) {
#line 295
    _E__pr_header("src/kb.c", 295L, "FATAL_ERROR");
#line 295
    _E__die_error("feat_array_alloc() failed\n");
  }
#line 297
  tmp___40 = cmd_ln_access((char *)"-bghist");
#line 297
  kb___0->vithist = vithist_init(kbcore___0, (kb___0->beam)->word, *((int32 *)tmp___40));
#line 299
  ptmr_init(& kb___0->tm_sen);
#line 300
  ptmr_init(& kb___0->tm_srch);
#line 301
  kb___0->tot_fr = 0;
#line 302
  kb___0->tot_sen_eval = 0.0;
#line 303
  kb___0->tot_gau_eval = 0.0;
#line 304
  kb___0->tot_hmm_eval = 0.0;
#line 305
  kb___0->tot_wd_exit = 0.0;
#line 307
  tmp___41 = cmd_ln_access((char *)"-hmmhistbinsize");
#line 307
  kb___0->hmm_hist_binsize = *((int32 *)tmp___41);
#line 308
  n = ((*(kb___0->ugtree + 0))->n_node + (*(kb___0->fillertree + 0))->n_node) * kb___0->n_lextree;
#line 309
  n /= kb___0->hmm_hist_binsize;
#line 310
  kb___0->hmm_hist_bins = n + 1;
#line 311
  tmp___42 = __ckd_calloc__((size_t )(n + 1), sizeof(int32 ), "src/kb.c", 311);
#line 311
  kb___0->hmm_hist = (int32 *)tmp___42;
#line 314
  tmp___43 = cmd_ln_access((char *)"-hypseg");
#line 314
  str = (char *)tmp___43;
#line 315
  kb___0->matchsegfp = (FILE *)((void *)0);
#line 316
  if (str) {
#line 320
    tmp___44 = fopen((char const   * __restrict  )str, (char const   * __restrict  )"w");
#line 320
    kb___0->matchsegfp = tmp___44;
#line 320
    if ((unsigned long )tmp___44 == (unsigned long )((void *)0)) {
#line 322
      _E__pr_header("src/kb.c", 322L, "ERROR");
#line 322
      _E__pr_warn("fopen(%s,w) failed; use FWDXCT: from std logfile\n", str);
    }
  }
#line 324
  return;
}
}
#line 331 "src/kb.c"
void kb_lextree_active_swap(kb_t *kb___0 ) 
{ 
  int32 i ;

  {
#line 335
  i = 0;
#line 335
  while (i < kb___0->n_lextree) {
#line 336
    lextree_active_swap(*(kb___0->ugtree + i));
#line 337
    lextree_active_swap(*(kb___0->fillertree + i));
#line 335
    i ++;
  }
#line 339
  return;
}
}
#line 343 "src/kb.c"
void kb_free(kb_t *kb___0 ) 
{ 
  vithist_t *vithist ;

  {
#line 345
  vithist = kb___0->vithist;
#line 355
  if (kb___0->sen_active) {
#line 356
    free((void *)kb___0->sen_active);
  }
#line 357
  if (kb___0->ssid_active) {
#line 358
    free((void *)kb___0->ssid_active);
  }
#line 359
  if (kb___0->comssid_active) {
#line 360
    free((void *)kb___0->comssid_active);
  }
#line 362
  if (kb___0->fillertree) {
#line 363
    free((void *)kb___0->fillertree);
  }
#line 364
  if (kb___0->hmm_hist) {
#line 365
    free((void *)kb___0->hmm_hist);
  }
#line 369
  if (vithist) {
#line 370
    free((void *)vithist->entry);
#line 371
    free((void *)vithist->frame_start);
#line 372
    free((void *)vithist->bestscore);
#line 373
    free((void *)vithist->bestvh);
#line 374
    free((void *)vithist->lms2vh_root);
#line 375
    free((void *)kb___0->vithist);
  }
#line 379
  kbcore_free(kb___0->kbcore);
#line 381
  if (kb___0->feat) {
#line 382
    free((void *)*(*(kb___0->feat + 0) + 0));
#line 383
    ckd_free_2d((void **)kb___0->feat);
  }
#line 386
  return;
}
}
#line 1 "corpus.o"
#pragma merger("0","/tmp/cil-0izygFls.i","-g,-O4")
#line 150 "/usr/include/x86_64-linux-gnu/bits/mathinline.h"
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__, __always_inline__)) __signbitl)(long double __x )  __attribute__((__const__)) ;
#line 150 "/usr/include/x86_64-linux-gnu/bits/mathinline.h"
__inline extern int ( __attribute__((__leaf__, __always_inline__)) __signbitl)(long double __x ) 
{ 
  union __anonunion___u_29___19 __u ;

  {
#line 153
  __u.__l = __x;
#line 154
  return ((__u.__i[2] & 32768) != 0);
}
}
#line 165 "src/corpus.h"
corpus_t *corpus_load_headid(char *file , int32 (*validate)(char *str ) , int32 (*dup_resolve)(char *s1 ,
                                                                                               char *s2 ) ) ;
#line 172
corpus_t *corpus_load_tailid(char *file , int32 (*validate)(char *str ) , int32 (*dup_resolve)(char *s1 ,
                                                                                               char *s2 ) ) ;
#line 180
char *corpus_lookup(corpus_t *corp , char *id ) ;
#line 190
int32 ctl_read_entry(FILE *fp , char *uttfile , int32 *sf , int32 *ef , char *uttid ) ;
#line 204
ptmr_t ctl_process(char *ctlfile , int32 nskip , int32 count , void (*func)(void *kb ,
                                                                            char *uttfile ,
                                                                            int32 sf ,
                                                                            int32 ef ,
                                                                            char *uttid ) ,
                   void *kb___0 ) ;
#line 221
ptmr_t ctl_process_utt(char *uttfile , int32 count , void (*func)(void *kb , char *uttfile ,
                                                                  int32 sf , int32 ef ,
                                                                  char *uttid ) ,
                       void *kb___0 ) ;
#line 232
void ctl_infile(char *file , char *dir , char *ext , char *utt ) ;
#line 247
void ctl_outfile(char *file , char *dir , char *ext , char *utt , char *uttid ) ;
#line 122 "src/corpus.c"
corpus_t *corpus_load_headid(char *file , int32 (*validate)(char *str ) , int32 (*dup_resolve)(char *s1 ,
                                                                                               char *s2 ) ) 
{ 
  FILE *fp ;
  char line[16384] ;
  char wd[4096] ;
  char *id ;
  int32 j ;
  int32 k___0 ;
  int32 m ;
  int32 n ;
  corpus_t *corp ;
  void *tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  void *tmp___2 ;
  int tmp___3 ;
  size_t tmp___4 ;
  int32 tmp___5 ;
  char *tmp___6 ;

  {
#line 131
  _E__pr_info_header("src/corpus.c", 131L, "INFO");
#line 131
  _E__pr_info("Loading corpus (%s)\n", file);
#line 133
  fp = fopen((char const   * __restrict  )file, (char const   * __restrict  )"r");
#line 133
  if ((unsigned long )fp == (unsigned long )((void *)0)) {
#line 134
    _E__pr_header("src/corpus.c", 134L, "SYSTEM_ERROR");
#line 134
    _E__fatal_sys_error("fopen(%s,r) failed\n", file);
  }
#line 136
  tmp = __ckd_calloc__((size_t )1, sizeof(corpus_t ), "src/corpus.c", 136);
#line 136
  corp = (corpus_t *)tmp;
#line 138
  n = 0;
#line 139
  while (1) {
#line 139
    tmp___1 = fgets((char * __restrict  )(line), (int )sizeof(line), (FILE * __restrict  )fp);
#line 139
    if (! ((unsigned long )tmp___1 != (unsigned long )((void *)0))) {
#line 139
      break;
    }
#line 141
    tmp___0 = sscanf((char const   * __restrict  )(line), (char const   * __restrict  )"%s",
                     wd);
#line 141
    if (tmp___0 == 1) {
#line 142
      n ++;
    }
  }
#line 144
  rewind(fp);
#line 146
  corp->ht = hash_new(n, 0);
#line 147
  corp->n = 0;
#line 148
  tmp___2 = __ckd_calloc__((size_t )n, sizeof(char *), "src/corpus.c", 148);
#line 148
  corp->str = (char **)tmp___2;
#line 150
  n = 0;
#line 151
  while (1) {
#line 151
    tmp___6 = fgets((char * __restrict  )(line), (int )sizeof(line), (FILE * __restrict  )fp);
#line 151
    if (! ((unsigned long )tmp___6 != (unsigned long )((void *)0))) {
#line 151
      break;
    }
#line 153
    tmp___3 = sscanf((char const   * __restrict  )(line), (char const   * __restrict  )"%s%n",
                     wd, & k___0);
#line 153
    if (tmp___3 != 1) {
#line 154
      continue;
    }
#line 157
    tmp___4 = strlen((char const   *)(line));
#line 157
    j = (int32 )tmp___4;
#line 158
    if (j > 0) {
#line 158
      if ((int )line[j - 1] == 10) {
#line 159
        line[j - 1] = (char )'\000';
      }
    }
#line 162
    if (validate) {
#line 162
      tmp___5 = (*validate)(line + k___0);
#line 162
      if (! tmp___5) {
#line 163
        _E__pr_info_header("src/corpus.c", 163L, "INFO");
#line 163
        _E__pr_info("Corpus validation %s failed; skipping\n", wd);
#line 164
        continue;
      }
    }
#line 167
    id = __ckd_salloc__((char const   *)(wd), "src/corpus.c", 167);
#line 168
    m = hash_enter(corp->ht, (char const   *)id, n);
#line 168
    if (m != n) {
#line 170
      if (! dup_resolve) {
#line 171
        _E__pr_header("src/corpus.c", 171L, "FATAL_ERROR");
#line 171
        _E__die_error("corpus_load_headid(%s) failed; duplicate ID: %s\n", file, id);
      } else {
#line 174
        j = (*dup_resolve)(*(corp->str + m), line + k___0);
#line 174
        if (j < 0) {
#line 175
          _E__pr_header("src/corpus.c", 175L, "FATAL_ERROR");
#line 175
          _E__die_error("corpus_load_headid(%s) failed; duplicate ID: %s\n", file,
                        id);
        }
#line 176
        free((void *)id);
#line 177
        if (j > 0) {
#line 179
          free((void *)*(corp->str + m));
#line 180
          *(corp->str + m) = __ckd_salloc__((char const   *)(line + k___0), "src/corpus.c",
                                            180);
        }
      }
    } else {
#line 187
      *(corp->str + n) = __ckd_salloc__((char const   *)(line + k___0), "src/corpus.c",
                                        187);
#line 188
      n ++;
    }
  }
#line 191
  corp->n = n;
#line 193
  fclose(fp);
#line 195
  _E__pr_info_header("src/corpus.c", 195L, "INFO");
#line 195
  _E__pr_info("%s: %d entries\n", file, n);
#line 197
  return (corp);
}
}
#line 201 "src/corpus.c"
static int32 sep_tailid(char *line , char *uttid ) 
{ 
  int32 i ;
  int32 k___0 ;
  int32 l ;
  size_t tmp ;

  {
#line 205
  tmp = strlen((char const   *)line);
#line 205
  l = (int32 )tmp;
#line 206
  *(uttid + 0) = (char )'\000';
#line 209
  i = l - 1;
#line 209
  while (1) {
#line 209
    if (i >= 0) {
#line 209
      if (! ((int )*(line + i) == 10)) {
#line 209
        if (! ((int )*(line + i) == 32)) {
#line 209
          if (! ((int )*(line + i) == 9)) {
#line 209
            break;
          }
        }
      }
    } else {
#line 209
      break;
    }
#line 209
    i --;
  }
#line 212
  if (i < 0) {
#line 213
    return (-1);
  } else
#line 212
  if ((int )*(line + i) != 41) {
#line 213
    return (-1);
  }
#line 214
  k___0 = i;
#line 217
  i --;
#line 217
  while (1) {
#line 217
    if (i >= 0) {
#line 217
      if ((int )*(line + i) != 32) {
#line 217
        if ((int )*(line + i) != 9) {
#line 217
          if (! ((int )*(line + i) != 40)) {
#line 217
            break;
          }
        } else {
#line 217
          break;
        }
      } else {
#line 217
        break;
      }
    } else {
#line 217
      break;
    }
#line 217
    i --;
  }
#line 218
  if (i < 0) {
#line 219
    return (-1);
  } else
#line 218
  if (k___0 - i < 2) {
#line 219
    return (-1);
  } else
#line 218
  if ((int )*(line + i) != 40) {
#line 219
    return (-1);
  }
#line 222
  *(line + k___0) = (char )'\000';
#line 223
  strcpy((char * __restrict  )uttid, (char const   * __restrict  )((line + i) + 1));
#line 226
  *(line + i) = (char )'\000';
#line 228
  return (0);
}
}
#line 232 "src/corpus.c"
corpus_t *corpus_load_tailid(char *file , int32 (*validate)(char *str ) , int32 (*dup_resolve)(char *s1 ,
                                                                                               char *s2 ) ) 
{ 
  FILE *fp ;
  char line[16384] ;
  char uttid[4096] ;
  char *id ;
  int32 j ;
  int32 m ;
  int32 n ;
  corpus_t *corp ;
  void *tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  void *tmp___2 ;
  int tmp___3 ;
  int32 tmp___4 ;
  int32 tmp___5 ;
  char *tmp___6 ;

  {
#line 241
  _E__pr_info_header("src/corpus.c", 241L, "INFO");
#line 241
  _E__pr_info("Loading corpus (%s)\n", file);
#line 243
  fp = fopen((char const   * __restrict  )file, (char const   * __restrict  )"r");
#line 243
  if ((unsigned long )fp == (unsigned long )((void *)0)) {
#line 244
    _E__pr_header("src/corpus.c", 244L, "SYSTEM_ERROR");
#line 244
    _E__fatal_sys_error("fopen(%s,r) failed\n", file);
  }
#line 246
  tmp = __ckd_calloc__((size_t )1, sizeof(corpus_t ), "src/corpus.c", 246);
#line 246
  corp = (corpus_t *)tmp;
#line 248
  n = 0;
#line 249
  while (1) {
#line 249
    tmp___1 = fgets((char * __restrict  )(line), (int )sizeof(line), (FILE * __restrict  )fp);
#line 249
    if (! ((unsigned long )tmp___1 != (unsigned long )((void *)0))) {
#line 249
      break;
    }
#line 251
    tmp___0 = sscanf((char const   * __restrict  )(line), (char const   * __restrict  )"%s",
                     uttid);
#line 251
    if (tmp___0 == 1) {
#line 252
      n ++;
    }
  }
#line 254
  rewind(fp);
#line 256
  corp->ht = hash_new(n, 0);
#line 257
  corp->n = 0;
#line 258
  tmp___2 = __ckd_calloc__((size_t )n, sizeof(char *), "src/corpus.c", 258);
#line 258
  corp->str = (char **)tmp___2;
#line 260
  n = 0;
#line 261
  while (1) {
#line 261
    tmp___6 = fgets((char * __restrict  )(line), (int )sizeof(line), (FILE * __restrict  )fp);
#line 261
    if (! ((unsigned long )tmp___6 != (unsigned long )((void *)0))) {
#line 261
      break;
    }
#line 263
    tmp___3 = sscanf((char const   * __restrict  )(line), (char const   * __restrict  )"%s",
                     uttid);
#line 263
    if (tmp___3 < 1) {
#line 264
      continue;
    }
#line 267
    tmp___4 = sep_tailid(line, uttid);
#line 267
    if (tmp___4 < 0) {
#line 268
      _E__pr_header("src/corpus.c", 268L, "FATAL_ERROR");
#line 268
      _E__die_error("corpus_load_tailid(%s) failed; bad line: %s\n", file, line);
    }
#line 271
    if (validate) {
#line 271
      tmp___5 = (*validate)(line);
#line 271
      if (! tmp___5) {
#line 272
        _E__pr_info_header("src/corpus.c", 272L, "INFO");
#line 272
        _E__pr_info("Corpus validation %s failed; skipping\n", uttid);
#line 273
        continue;
      }
    }
#line 276
    id = __ckd_salloc__((char const   *)(uttid), "src/corpus.c", 276);
#line 277
    m = hash_enter(corp->ht, (char const   *)id, n);
#line 277
    if (m != n) {
#line 279
      if (! dup_resolve) {
#line 280
        _E__pr_header("src/corpus.c", 280L, "FATAL_ERROR");
#line 280
        _E__die_error("corpus_load_tailid(%s) failed; duplicate ID: %s\n", file, id);
      } else {
#line 283
        j = (*dup_resolve)(*(corp->str + m), line);
#line 283
        if (j < 0) {
#line 284
          _E__pr_header("src/corpus.c", 284L, "FATAL_ERROR");
#line 284
          _E__die_error("corpus_load(tailid(%s) failed; duplicate ID: %s\n", file,
                        id);
        }
#line 285
        free((void *)id);
#line 286
        if (j > 0) {
#line 288
          free((void *)*(corp->str + m));
#line 289
          *(corp->str + m) = __ckd_salloc__((char const   *)(line), "src/corpus.c",
                                            289);
        }
      }
    } else {
#line 296
      *(corp->str + n) = __ckd_salloc__((char const   *)(line), "src/corpus.c", 296);
#line 297
      n ++;
    }
  }
#line 300
  corp->n = n;
#line 302
  fclose(fp);
#line 304
  _E__pr_info_header("src/corpus.c", 304L, "INFO");
#line 304
  _E__pr_info("%s: %d entries\n", file, n);
#line 306
  return (corp);
}
}
#line 310 "src/corpus.c"
char *corpus_lookup(corpus_t *corp , char *id ) 
{ 
  int32 n ;
  int32 tmp ;

  {
#line 314
  tmp = hash_lookup(corp->ht, (char const   *)id, & n);
#line 314
  if (tmp < 0) {
#line 315
    return ((char *)((void *)0));
  }
#line 317
  if (n >= 0) {
#line 317
    if (! (n < corp->n)) {
#line 317
      __assert_fail("(n >= 0) && (n < corp->n)", "src/corpus.c", 317U, "corpus_lookup");
    }
  } else {
#line 317
    __assert_fail("(n >= 0) && (n < corp->n)", "src/corpus.c", 317U, "corpus_lookup");
  }
#line 318
  return (*(corp->str + n));
}
}
#line 353 "src/corpus.c"
int32 ctl_read_entry(FILE *fp , char *uttfile , int32 *sf , int32 *ef , char *uttid ) 
{ 
  char line[16384] ;
  char base[16384] ;
  int32 k___0 ;
  char *tmp ;
  size_t tmp___0 ;

  {
#line 359
  while (1) {
#line 360
    tmp = fgets((char * __restrict  )(line), (int )sizeof(line), (FILE * __restrict  )fp);
#line 360
    if ((unsigned long )tmp == (unsigned long )((void *)0)) {
#line 361
      return (-1);
    }
#line 362
    if ((int )line[0] == 35) {
#line 363
      k___0 = 0;
    } else {
#line 365
      k___0 = sscanf((char const   * __restrict  )(line), (char const   * __restrict  )"%s %d %d %s",
                     uttfile, sf, ef, uttid);
    }
#line 359
    if (! (k___0 <= 0)) {
#line 359
      break;
    }
  }
#line 368
  if (k___0 == 2) {
#line 369
    _E__pr_header("src/corpus.c", 369L, "FATAL_ERROR");
#line 369
    _E__die_error("Error in ctlfile: %s\n", line);
  } else
#line 368
  if (k___0 >= 3) {
#line 368
    if (*sf >= *ef) {
#line 369
      _E__pr_header("src/corpus.c", 369L, "FATAL_ERROR");
#line 369
      _E__die_error("Error in ctlfile: %s\n", line);
    } else
#line 368
    if (*sf < 0) {
#line 369
      _E__pr_header("src/corpus.c", 369L, "FATAL_ERROR");
#line 369
      _E__die_error("Error in ctlfile: %s\n", line);
    }
  }
#line 371
  if (k___0 < 4) {
#line 373
    path2basename(uttfile, base);
#line 374
    strip_fileext(base, uttid);
#line 376
    if (k___0 == 3) {
#line 377
      tmp___0 = strlen((char const   *)uttid);
#line 377
      k___0 = (int32 )tmp___0;
#line 378
      sprintf((char * __restrict  )(uttid + k___0), (char const   * __restrict  )"_%d_%d",
              *sf, *ef);
    } else {
#line 380
      *sf = 0;
#line 381
      *ef = -1;
    }
  }
#line 385
  return (0);
}
}
#line 389 "src/corpus.c"
ptmr_t ctl_process(char *ctlfile , int32 nskip , int32 count , void (*func)(void *kb ,
                                                                            char *uttfile ,
                                                                            int32 sf ,
                                                                            int32 ef ,
                                                                            char *uttid ) ,
                   void *kb___0 ) 
{ 
  FILE *fp ;
  char uttfile[16384] ;
  char uttid[4096] ;
  int32 sf ;
  int32 ef ;
  ptmr_t tm ;
  int32 tmp ;
  int32 tmp___0 ;

  {
#line 398
  if (ctlfile) {
#line 399
    fp = fopen((char const   * __restrict  )ctlfile, (char const   * __restrict  )"r");
#line 399
    if ((unsigned long )fp == (unsigned long )((void *)0)) {
#line 400
      _E__pr_header("src/corpus.c", 400L, "SYSTEM_ERROR");
#line 400
      _E__fatal_sys_error("fopen(%s,r) failed\n", ctlfile);
    }
  } else {
#line 402
    fp = stdin;
  }
#line 404
  ptmr_init(& tm);
#line 406
  if (nskip > 0) {
#line 407
    _E__pr_info_header("src/corpus.c", 407L, "INFO");
#line 407
    _E__pr_info("Skipping %d entries at the beginning of %s\n", nskip, ctlfile);
#line 409
    while (nskip > 0) {
#line 410
      tmp = ctl_read_entry(fp, uttfile, & sf, & ef, uttid);
#line 410
      if (tmp < 0) {
#line 411
        fclose(fp);
#line 412
        return (tm);
      }
#line 409
      nskip --;
    }
  }
#line 417
  while (count > 0) {
#line 418
    tmp___0 = ctl_read_entry(fp, uttfile, & sf, & ef, uttid);
#line 418
    if (tmp___0 < 0) {
#line 419
      break;
    }
#line 422
    ptmr_start(& tm);
#line 423
    if (func) {
#line 424
      (*func)(kb___0, uttfile, sf, ef, uttid);
    }
#line 425
    ptmr_stop(& tm);
#line 427
    _E__pr_info_header("src/corpus.c", 427L, "INFO");
#line 427
    _E__pr_info("%s: %6.1f sec CPU, %6.1f sec Clk;  TOT: %8.1f sec CPU, %8.1f sec Clk\n\n",
                uttid, tm.t_cpu, tm.t_elapsed, tm.t_tot_cpu, tm.t_tot_elapsed);
#line 430
    ptmr_reset(& tm);
#line 417
    count --;
  }
#line 433
  fclose(fp);
#line 435
  return (tm);
}
}
#line 439 "src/corpus.c"
ptmr_t ctl_process_utt(char *uttfile , int32 count , void (*func)(void *kb , char *uttfile ,
                                                                  int32 sf , int32 ef ,
                                                                  char *uttid ) ,
                       void *kb___0 ) 
{ 
  char uttid[4096] ;
  char base[16384] ;
  int32 i ;
  int32 c ;
  int32 ts ;
  int32 newts ;
  ptmr_t tm ;

  {
#line 449
  ptmr_init(& tm);
#line 450
  path2basename(uttfile, base);
#line 451
  strip_fileext(base, uttid);
#line 452
  strcpy((char * __restrict  )(base), (char const   * __restrict  )(uttid));
#line 454
  ts = -1;
#line 455
  c = 0;
#line 455
  while (c < count) {
#line 457
    i = 0;
#line 457
    while (1) {
#line 458
      newts = stat_mtime(uttfile);
#line 459
      if (newts >= 0) {
#line 459
        if (newts != ts) {
#line 460
          break;
        }
      }
#line 462
      if (i == 0) {
#line 463
        _E__pr_info_header("src/corpus.c", 463L, "INFO");
#line 463
        _E__pr_info("Waiting for %s\n", uttfile);
      }
#line 457
      i ++;
    }
#line 466
    ts = newts;
#line 469
    sprintf((char * __restrict  )(uttid), (char const   * __restrict  )"%s_%08d",
            base, c);
#line 472
    ptmr_start(& tm);
#line 473
    if (func) {
#line 474
      (*func)(kb___0, uttfile, 0, -1, uttid);
    }
#line 475
    ptmr_stop(& tm);
#line 477
    _E__pr_info_header("src/corpus.c", 477L, "INFO");
#line 477
    _E__pr_info("%s: %6.1f sec CPU, %6.1f sec Clk;  TOT: %8.1f sec CPU, %8.1f sec Clk\n\n",
                uttid, tm.t_cpu, tm.t_elapsed, tm.t_tot_cpu, tm.t_tot_elapsed);
#line 480
    ptmr_reset(& tm);
#line 455
    c ++;
  }
#line 483
  return (tm);
}
}
#line 487 "src/corpus.c"
void ctl_infile(char *file , char *dir , char *ext , char *utt ) 
{ 
  int32 l1 ;
  int32 l2 ;
  size_t tmp ;
  size_t tmp___0 ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___2 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;

  {
#line 491
  if (! utt) {
#line 491
    __assert_fail("utt", "src/corpus.c", 491U, "ctl_infile");
  }
#line 493
  if (ext) {
#line 493
    if ((int )*(ext + 0) != 0) {
#line 494
      tmp = strlen((char const   *)ext);
#line 494
      l1 = (int32 )tmp;
#line 495
      tmp___0 = strlen((char const   *)utt);
#line 495
      l2 = (int32 )tmp___0;
#line 496
      if (l2 > l1) {
#line 496
        if ((int )*(utt + ((l2 - l1) - 1)) == 46) {
#line 496
          if (0) {
#line 496
            __s1_len = __builtin_strlen((char const   *)(utt + (l2 - l1)));
#line 496
            __s2_len = __builtin_strlen((char const   *)ext);
#line 496
            if (! ((size_t )((void const   *)((utt + (l2 - l1)) + 1)) - (size_t )((void const   *)(utt + (l2 - l1))) == 1UL)) {
#line 496
              goto _L___0;
            } else
#line 496
            if (__s1_len >= 4UL) {
              _L___0: /* CIL Label */ 
#line 496
              if (! ((size_t )((void const   *)(ext + 1)) - (size_t )((void const   *)ext) == 1UL)) {
#line 496
                tmp___7 = 1;
              } else
#line 496
              if (__s2_len >= 4UL) {
#line 496
                tmp___7 = 1;
              } else {
#line 496
                tmp___7 = 0;
              }
            } else {
#line 496
              tmp___7 = 0;
            }
#line 496
            if (tmp___7) {
#line 496
              tmp___2 = __builtin_strcmp((char const   *)(utt + (l2 - l1)), (char const   *)ext);
#line 496
              tmp___6 = tmp___2;
            } else {
#line 496
              tmp___5 = __builtin_strcmp((char const   *)(utt + (l2 - l1)), (char const   *)ext);
#line 496
              tmp___6 = tmp___5;
            }
          } else {
#line 496
            tmp___5 = __builtin_strcmp((char const   *)(utt + (l2 - l1)), (char const   *)ext);
#line 496
            tmp___6 = tmp___5;
          }
#line 496
          if (tmp___6 == 0) {
#line 497
            ext = (char *)((void *)0);
          }
        }
      }
    }
  }
#line 500
  if ((int )*(utt + 0) != 47) {
#line 500
    if (dir) {
#line 502
      if (ext) {
#line 502
        if ((int )*(ext + 0) != 0) {
#line 503
          sprintf((char * __restrict  )file, (char const   * __restrict  )"%s/%s.%s",
                  dir, utt, ext);
        } else {
#line 505
          sprintf((char * __restrict  )file, (char const   * __restrict  )"%s/%s",
                  dir, utt);
        }
      } else {
#line 505
        sprintf((char * __restrict  )file, (char const   * __restrict  )"%s/%s", dir,
                utt);
      }
    } else {
#line 500
      goto _L___1;
    }
  } else
  _L___1: /* CIL Label */ 
#line 507
  if (ext) {
#line 507
    if ((int )*(ext + 0) != 0) {
#line 508
      sprintf((char * __restrict  )file, (char const   * __restrict  )"%s.%s", utt,
              ext);
    } else {
#line 510
      strcpy((char * __restrict  )file, (char const   * __restrict  )utt);
    }
  } else {
#line 510
    strcpy((char * __restrict  )file, (char const   * __restrict  )utt);
  }
#line 512
  return;
}
}
#line 515 "src/corpus.c"
void ctl_outfile(char *file , char *dir , char *ext , char *utt , char *uttid ) 
{ 
  int32 k___0 ;
  size_t tmp ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___1 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
#line 519
  tmp = strlen((char const   *)dir);
#line 519
  k___0 = (int32 )tmp;
#line 521
  if (k___0 > 4) {
#line 521
    if (0) {
#line 521
      __s1_len = __builtin_strlen((char const   *)((dir + k___0) - 4));
#line 521
      __s2_len = __builtin_strlen(",CTL");
#line 521
      if (! ((size_t )((void const   *)(((dir + k___0) - 4) + 1)) - (size_t )((void const   *)((dir + k___0) - 4)) == 1UL)) {
#line 521
        goto _L___0;
      } else
#line 521
      if (__s1_len >= 4UL) {
        _L___0: /* CIL Label */ 
#line 521
        if (! ((size_t )((void const   *)(",CTL" + 1)) - (size_t )((void const   *)",CTL") == 1UL)) {
#line 521
          tmp___6 = 1;
        } else
#line 521
        if (__s2_len >= 4UL) {
#line 521
          tmp___6 = 1;
        } else {
#line 521
          tmp___6 = 0;
        }
      } else {
#line 521
        tmp___6 = 0;
      }
#line 521
      if (tmp___6) {
#line 521
        tmp___1 = __builtin_strcmp((char const   *)((dir + k___0) - 4), ",CTL");
#line 521
        tmp___5 = tmp___1;
      } else {
#line 521
        tmp___4 = __builtin_strcmp((char const   *)((dir + k___0) - 4), ",CTL");
#line 521
        tmp___5 = tmp___4;
      }
    } else {
#line 521
      tmp___4 = __builtin_strcmp((char const   *)((dir + k___0) - 4), ",CTL");
#line 521
      tmp___5 = tmp___4;
    }
#line 521
    if (tmp___5 == 0) {
#line 522
      if ((int )*(utt + 0) != 47) {
#line 523
        strcpy((char * __restrict  )file, (char const   * __restrict  )dir);
#line 524
        *(file + (k___0 - 4)) = (char )'/';
#line 525
        strcpy((char * __restrict  )((file + k___0) - 3), (char const   * __restrict  )utt);
      } else {
#line 527
        strcpy((char * __restrict  )file, (char const   * __restrict  )utt);
      }
    } else {
#line 529
      strcpy((char * __restrict  )file, (char const   * __restrict  )dir);
#line 530
      *(file + k___0) = (char )'/';
#line 531
      strcpy((char * __restrict  )((file + k___0) + 1), (char const   * __restrict  )uttid);
    }
  } else {
#line 529
    strcpy((char * __restrict  )file, (char const   * __restrict  )dir);
#line 530
    *(file + k___0) = (char )'/';
#line 531
    strcpy((char * __restrict  )((file + k___0) + 1), (char const   * __restrict  )uttid);
  }
#line 534
  if (ext) {
#line 534
    if ((int )*(ext + 0) != 0) {
#line 535
      strcat((char * __restrict  )file, (char const   * __restrict  )".");
#line 536
      strcat((char * __restrict  )file, (char const   * __restrict  )ext);
    }
  }
#line 538
  return;
}
}
#line 1 "utt.o"
#pragma merger("0","/tmp/cil-BmOOgqIL.i","-g,-O4")
#line 716 "/usr/include/stdlib.h"
extern int ( __attribute__((__warn_unused_result__)) system)(char const   *__command ) ;
#line 150 "/usr/include/x86_64-linux-gnu/bits/mathinline.h"
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__, __always_inline__)) __signbitl)(long double __x )  __attribute__((__const__)) ;
#line 150 "/usr/include/x86_64-linux-gnu/bits/mathinline.h"
__inline extern int ( __attribute__((__leaf__, __always_inline__)) __signbitl)(long double __x ) 
{ 
  union __anonunion___u_29___20 __u ;

  {
#line 153
  __u.__l = __x;
#line 154
  return ((__u.__i[2] & 32768) != 0);
}
}
#line 261 "src/feat.h"
int32 feat_s2mfc2feat(feat_t *fcb , char *file , char *dir , int32 sf , int32 ef ,
                      float32 ***feat___0 , int32 maxfr ) ;
#line 95 "src/utt.h"
void utt_begin(kb_t *kb___0 ) ;
#line 97
void utt_end(kb_t *kb___0 ) ;
#line 99
void utt_word_trans(kb_t *kb___0 , int32 cf ) ;
#line 101
void utt_decode(void *data , char *uttfile , int32 sf , int32 ef , char *uttid ) ;
#line 112
void utt_decode_block(float **block_feat , int32 block_nfeatvec , int32 *curfrm ,
                      kb_t *kb___0 , int32 maxwpf___0 , int32 maxhistpf___0 , int32 maxhmmpf___0 ,
                      int32 ptranskip___0 , FILE *hmmdumpfp___0 ) ;
#line 125
void single_utt_decode_block(float **block_feat , int32 block_nfeatvec , int32 *curfrm ,
                             kb_t *kb___0 , int32 maxwpf___0 , int32 maxhistpf___0 ,
                             int32 maxhmmpf___0 , int32 ptranskip___0 , FILE *hmmdumpfp___0 ) ;
#line 134 "src/utt.c"
void matchseg_write(FILE *fp , kb_t *kb___0 , glist_t hyp , char *hdr ) 
{ 
  gnode_t *gn ;
  hyp_t *h ;
  int32 ascr ;
  int32 lscr ;
  dict_t *dict ;
  char const   *tmp ;

  {
#line 141
  ascr = 0;
#line 142
  lscr = 0;
#line 144
  gn = hyp;
#line 144
  while (gn) {
#line 145
    h = (hyp_t *)gn->data.ptr;
#line 146
    ascr += h->ascr;
#line 147
    lscr += h->lscr;
#line 144
    gn = gn->next;
  }
#line 150
  dict = (kb___0->kbcore)->dict;
#line 152
  if (hdr) {
#line 152
    tmp = (char const   *)hdr;
  } else {
#line 152
    tmp = "";
  }
#line 152
  fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"%s%s S 0 T %d A %d L %d",
          tmp, kb___0->uttid, ascr + lscr, ascr, lscr);
#line 153
  gn = hyp;
#line 153
  while (1) {
#line 153
    if (gn) {
#line 153
      if (! gn->next) {
#line 153
        break;
      }
    } else {
#line 153
      break;
    }
#line 154
    h = (hyp_t *)gn->data.ptr;
#line 155
    fprintf((FILE * __restrict  )fp, (char const   * __restrict  )" %d %d %d %s",
            h->sf, h->ascr, h->lscr, (dict->word + h->id)->word);
#line 153
    gn = gn->next;
  }
#line 157
  fprintf((FILE * __restrict  )fp, (char const   * __restrict  )" %d\n", kb___0->nfr);
#line 158
  fflush(fp);
#line 159
  return;
}
}
#line 164 "src/utt.c"
void utt_begin(kb_t *kb___0 ) 
{ 
  kbcore_t *kbc ;
  int32 n ;
  int32 pred ;

  {
#line 169
  kbc = kb___0->kbcore;
#line 172
  pred = vithist_utt_begin(kb___0->vithist, kbc);
#line 173
  if (! (pred == 0)) {
#line 173
    __assert_fail("pred == 0", "src/utt.c", 173U, "utt_begin");
  }
#line 176
  n = (*(kb___0->ugtree + 0))->n_next_active;
#line 177
  if (! (n == 0)) {
#line 177
    __assert_fail("n == 0", "src/utt.c", 177U, "utt_begin");
  }
#line 178
  lextree_enter(*(kb___0->ugtree + 0), (kbc->mdef)->sil, -1, 0, pred, (kb___0->beam)->hmm);
#line 181
  n = (*(kb___0->fillertree + 0))->n_next_active;
#line 182
  if (! (n == 0)) {
#line 182
    __assert_fail("n == 0", "src/utt.c", 182U, "utt_begin");
  }
#line 183
  lextree_enter(*(kb___0->fillertree + 0), (s3cipid_t )-1, -1, 0, pred, (kb___0->beam)->hmm);
#line 185
  kb___0->n_lextrans = 1;
#line 187
  kb_lextree_active_swap(kb___0);
#line 190
  threading_support_init(kb___0);
#line 193
  return;
}
}
#line 195 "src/utt.c"
void utt_end(kb_t *kb___0 ) 
{ 
  int32 id ;
  int32 ascr ;
  int32 lscr ;
  glist_t hyp ;
  gnode_t *gn ;
  hyp_t *h ;
  FILE *fp ;
  FILE *latfp ;
  dict_t *dict ;
  int32 i ;
  char file[8192] ;
  void const   *tmp ;
  void const   *tmp___0 ;
  int32 tmp___1 ;
  char str[16384] ;
  int32 ispipe ;
  float64 logbase ;
  void const   *tmp___2 ;
  void const   *tmp___3 ;
  void const   *tmp___4 ;
  void const   *tmp___5 ;
  void const   *tmp___6 ;
  void const   *tmp___7 ;
  void const   *tmp___8 ;
  void const   *tmp___9 ;
  void const   *tmp___10 ;
  void const   *tmp___11 ;
  void const   *tmp___12 ;
  void const   *tmp___13 ;
  void const   *tmp___14 ;
  void const   *tmp___15 ;
  int32 j ;
  int32 k___0 ;

  {
#line 205
  fp = stderr;
#line 206
  dict = (kb___0->kbcore)->dict;
#line 208
  id = vithist_utt_end(kb___0->vithist, kb___0->kbcore);
#line 208
  if (id >= 0) {
#line 209
    tmp___0 = cmd_ln_access((char *)"-bptbldir");
#line 209
    if ((char *)tmp___0) {
#line 212
      tmp = cmd_ln_access((char *)"-bptbldir");
#line 212
      sprintf((char * __restrict  )(file), (char const   * __restrict  )"%s/%s.bpt",
              (char *)tmp, kb___0->uttid);
#line 213
      latfp = fopen((char const   * __restrict  )(file), (char const   * __restrict  )"w");
#line 213
      if ((unsigned long )latfp == (unsigned long )((void *)0)) {
#line 214
        _E__pr_header("src/utt.c", 214L, "ERROR");
#line 214
        _E__pr_warn("fopen(%s,w) failed; using stdout\n", file);
#line 215
        latfp = stdout;
      }
#line 218
      vithist_dump(kb___0->vithist, -1, kb___0->kbcore, latfp);
#line 219
      if ((unsigned long )latfp != (unsigned long )stdout) {
#line 220
        fclose(latfp);
      }
    }
#line 223
    hyp = vithist_backtrace(kb___0->vithist, id);
#line 226
    fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"\nBacktrace(%s)\n",
            kb___0->uttid);
#line 227
    fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"%6s %5s %5s %11s %8s %4s\n",
            "LatID", "SFrm", "EFrm", "AScr", "LScr", "Type");
#line 230
    ascr = 0;
#line 231
    lscr = 0;
#line 233
    gn = hyp;
#line 233
    while (gn) {
#line 234
      h = (hyp_t *)gn->data.ptr;
#line 235
      fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"%6d %5d %5d %11d %8d %4d %s\n",
              h->vhid, h->sf, h->ef, h->ascr, h->lscr, h->type, (dict->word + h->id)->word);
#line 239
      ascr += h->ascr;
#line 240
      lscr += h->lscr;
#line 233
      gn = gn->next;
    }
#line 242
    fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"       %5d %5d %11d %8d (Total)\n",
            0, kb___0->nfr, ascr, lscr);
#line 245
    fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"\nFWDVIT: ");
#line 246
    gn = hyp;
#line 246
    while (gn) {
#line 247
      h = (hyp_t *)gn->data.ptr;
#line 248
      tmp___1 = dict_filler_word(dict, h->id);
#line 248
      if (! tmp___1) {
#line 248
        if (h->id != dict->finishwid) {
#line 249
          fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"%s ", (dict->word + (dict->word + h->id)->basewid)->word);
        }
      }
#line 246
      gn = gn->next;
    }
#line 251
    fprintf((FILE * __restrict  )fp, (char const   * __restrict  )" (%s)\n\n", kb___0->uttid);
#line 254
    if (kb___0->matchsegfp) {
#line 255
      matchseg_write(kb___0->matchsegfp, kb___0, hyp, (char *)((void *)0));
    }
#line 256
    matchseg_write(fp, kb___0, hyp, (char *)"FWDXCT: ");
#line 257
    fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"\n");
#line 259
    tmp___15 = cmd_ln_access((char *)"-outlatdir");
#line 259
    if ((char *)tmp___15) {
#line 264
      tmp___2 = cmd_ln_access((char *)"-latext");
#line 264
      tmp___3 = cmd_ln_access((char *)"-outlatdir");
#line 264
      sprintf((char * __restrict  )(str), (char const   * __restrict  )"%s/%s.%s",
              (char *)tmp___3, kb___0->uttid, (char *)tmp___2);
#line 266
      _E__pr_info_header("src/utt.c", 266L, "INFO");
#line 266
      _E__pr_info("Writing lattice file: %s\n", str);
#line 268
      latfp = fopen_comp(str, (char *)"w", & ispipe);
#line 268
      if ((unsigned long )latfp == (unsigned long )((void *)0)) {
#line 269
        _E__pr_header("src/utt.c", 269L, "ERROR");
#line 269
        _E__pr_warn("fopen_comp (%s,w) failed\n", str);
      } else {
#line 272
        __assert_fail("0&&\"used to be getcwd\"", "src/utt.c", 272U, "utt_end");
#line 274
        fprintf((FILE * __restrict  )latfp, (char const   * __restrict  )"# getcwd: %s\n",
                str);
#line 277
        tmp___4 = cmd_ln_access((char *)"-logbase");
#line 277
        logbase = (float64 )*((float32 *)tmp___4);
#line 278
        fprintf((FILE * __restrict  )latfp, (char const   * __restrict  )"# -logbase %e\n",
                logbase);
#line 280
        tmp___5 = cmd_ln_access((char *)"-dict");
#line 280
        fprintf((FILE * __restrict  )latfp, (char const   * __restrict  )"# -dict %s\n",
                (char *)tmp___5);
#line 281
        tmp___7 = cmd_ln_access((char *)"-fdict");
#line 281
        if ((char *)tmp___7) {
#line 282
          tmp___6 = cmd_ln_access((char *)"-fdict");
#line 282
          fprintf((FILE * __restrict  )latfp, (char const   * __restrict  )"# -fdict %s\n",
                  (char *)tmp___6);
        }
#line 283
        tmp___8 = cmd_ln_access((char *)"-lm");
#line 283
        fprintf((FILE * __restrict  )latfp, (char const   * __restrict  )"# -lm %s\n",
                (char *)tmp___8);
#line 284
        tmp___9 = cmd_ln_access((char *)"-mdef");
#line 284
        fprintf((FILE * __restrict  )latfp, (char const   * __restrict  )"# -mdef %s\n",
                (char *)tmp___9);
#line 285
        tmp___10 = cmd_ln_access((char *)"-mean");
#line 285
        fprintf((FILE * __restrict  )latfp, (char const   * __restrict  )"# -mean %s\n",
                (char *)tmp___10);
#line 286
        tmp___11 = cmd_ln_access((char *)"-var");
#line 286
        fprintf((FILE * __restrict  )latfp, (char const   * __restrict  )"# -var %s\n",
                (char *)tmp___11);
#line 287
        tmp___12 = cmd_ln_access((char *)"-mixw");
#line 287
        fprintf((FILE * __restrict  )latfp, (char const   * __restrict  )"# -mixw %s\n",
                (char *)tmp___12);
#line 288
        tmp___13 = cmd_ln_access((char *)"-tmat");
#line 288
        fprintf((FILE * __restrict  )latfp, (char const   * __restrict  )"# -tmat %s\n",
                (char *)tmp___13);
#line 289
        fprintf((FILE * __restrict  )latfp, (char const   * __restrict  )"#\n");
#line 291
        fprintf((FILE * __restrict  )latfp, (char const   * __restrict  )"Frames %d\n",
                kb___0->nfr);
#line 292
        fprintf((FILE * __restrict  )latfp, (char const   * __restrict  )"#\n");
#line 294
        tmp___14 = cmd_ln_access((char *)"-outlatoldfmt");
#line 294
        vithist_dag_write(kb___0->vithist, hyp, dict, *((int32 *)tmp___14), latfp);
#line 295
        fclose_comp(latfp, ispipe);
      }
    }
#line 300
    gn = hyp;
#line 300
    while (1) {
#line 300
      if (gn) {
#line 300
        if (! gn->next) {
#line 300
          break;
        }
      } else {
#line 300
        break;
      }
#line 301
      h = (hyp_t *)gn->data.ptr;
#line 302
      free((void *)h);
#line 300
      gn = gn->next;
    }
#line 304
    glist_free(hyp);
  } else {
#line 306
    _E__pr_header("src/utt.c", 306L, "ERROR");
#line 306
    _E__pr_warn("%s: No recognition\n\n", kb___0->uttid);
  }
#line 321
  _E__pr_info_header("src/utt.c", 321L, "INFO");
#line 321
  _E__pr_info("%4d frm;  %4d sen, %5d gau/fr, %4.1f CPU %4.1f Clk;  %5d hmm, %3d wd/fr, %4.1f CPU %4.1f Clk (%s)\n",
              kb___0->nfr, (kb___0->utt_sen_eval + (kb___0->nfr >> 1)) / kb___0->nfr,
              (kb___0->utt_gau_eval + (kb___0->nfr >> 1)) / kb___0->nfr, 0.0, 0.0,
              (kb___0->utt_hmm_eval + (kb___0->nfr >> 1)) / kb___0->nfr, ((kb___0->vithist)->n_entry + (kb___0->nfr >> 1)) / kb___0->nfr,
              0.0, 0.0, kb___0->uttid);
#line 335
  j = kb___0->hmm_hist_bins - 1;
#line 335
  while (1) {
#line 335
    if (j >= 0) {
#line 335
      if (! (*(kb___0->hmm_hist + j) == 0)) {
#line 335
        break;
      }
    } else {
#line 335
      break;
    }
#line 335
    j --;
  }
#line 336
  _E__pr_info_header("src/utt.c", 336L, "INFO");
#line 336
  _E__pr_info("HMMHist[0..%d](%s):", j, kb___0->uttid);
#line 337
  i = 0;
#line 337
  k___0 = 0;
#line 337
  while (i <= j) {
#line 338
    k___0 += *(kb___0->hmm_hist + i);
#line 339
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )" %d(%d)", *(kb___0->hmm_hist + i),
            (k___0 * 100) / kb___0->nfr);
#line 337
    i ++;
  }
#line 341
  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"\n");
#line 342
  fflush(stderr);
#line 345
  kb___0->tot_sen_eval += (float64 )kb___0->utt_sen_eval;
#line 346
  kb___0->tot_gau_eval += (float64 )kb___0->utt_gau_eval;
#line 347
  kb___0->tot_hmm_eval += (float64 )kb___0->utt_hmm_eval;
#line 348
  kb___0->tot_wd_exit += (float64 )(kb___0->vithist)->n_entry;
#line 350
  ptmr_reset(& kb___0->tm_sen);
#line 351
  ptmr_reset(& kb___0->tm_srch);
#line 354
  system("ps aguxwww | grep /live | grep -v grep");
#line 356
  i = 0;
#line 356
  while (i < kb___0->n_lextree) {
#line 357
    lextree_utt_end(*(kb___0->ugtree + i), kb___0->kbcore);
#line 358
    lextree_utt_end(*(kb___0->fillertree + i), kb___0->kbcore);
#line 356
    i ++;
  }
#line 361
  vithist_utt_reset(kb___0->vithist);
#line 363
  lm_cache_stats_dump((kb___0->kbcore)->lm);
#line 364
  lm_cache_reset((kb___0->kbcore)->lm);
#line 365
  return;
}
}
#line 374 "src/utt.c"
static int32 *bs  =    (int32 *)((void *)0);
#line 374 "src/utt.c"
static int32 *bv  =    (int32 *)((void *)0);
#line 374 "src/utt.c"
static int32 epl  ;
#line 368 "src/utt.c"
void utt_word_trans(kb_t *kb___0 , int32 cf ) 
{ 
  int32 k___0 ;
  int32 th ;
  vithist_t *vh ;
  vithist_entry_t *ve ;
  int32 vhid ;
  int32 le ;
  int32 n_ci ;
  int32 score ;
  s3wid_t wid ;
  int32 p ;
  dict_t *dict ;
  mdef_t *mdef ;
  void *tmp ;
  void *tmp___0 ;
  void const   *tmp___1 ;
  int32 tmp___2 ;

  {
#line 380
  vh = kb___0->vithist;
#line 381
  th = kb___0->bestscore + (kb___0->beam)->hmm;
#line 383
  if (*(vh->bestvh + cf) < 0) {
#line 384
    return;
  }
#line 386
  dict = (kb___0->kbcore)->dict;
#line 387
  mdef = (kb___0->kbcore)->mdef;
#line 388
  n_ci = mdef->n_ciphone;
#line 391
  if (! bs) {
#line 392
    tmp = __ckd_calloc__((size_t )n_ci, sizeof(int32 ), "src/utt.c", 392);
#line 392
    bs = (int32 *)tmp;
#line 393
    tmp___0 = __ckd_calloc__((size_t )n_ci, sizeof(int32 ), "src/utt.c", 393);
#line 393
    bv = (int32 *)tmp___0;
#line 394
    tmp___1 = cmd_ln_access((char *)"-epl");
#line 394
    epl = *((int32 *)tmp___1);
  }
#line 396
  p = 0;
#line 396
  while (p < n_ci) {
#line 397
    *(bs + p) = (int32 )2147483648U;
#line 398
    *(bv + p) = -1;
#line 396
    p ++;
  }
#line 402
  vhid = *(vh->frame_start + cf);
#line 403
  le = vh->n_entry - 1;
#line 404
  while (vhid <= le) {
#line 405
    ve = vithist_id2entry(vh, vhid);
#line 406
    if (! ve->valid) {
#line 407
      goto __Cont;
    }
#line 409
    wid = ve->wid;
#line 410
    p = (int32 )*((dict->word + wid)->ciphone + ((dict->word + wid)->pronlen - 1));
#line 411
    if ((mdef->ciphone + p)->filler) {
#line 412
      p = (int32 )mdef->sil;
    }
#line 414
    score = ve->score;
#line 415
    if (score > *(bs + p)) {
#line 416
      *(bs + p) = score;
#line 417
      *(bv + p) = vhid;
    }
    __Cont: /* CIL Label */ 
#line 404
    vhid ++;
  }
#line 422
  tmp___2 = kb___0->n_lextrans;
#line 422
  (kb___0->n_lextrans) ++;
#line 422
  k___0 = tmp___2;
#line 423
  k___0 = (k___0 % (kb___0->n_lextree * epl)) / epl;
#line 426
  p = 0;
#line 426
  while (p < n_ci) {
#line 427
    if (*(bv + p) >= 0) {
#line 428
      lextree_enter(*(kb___0->ugtree + k___0), (s3cipid_t )p, cf, *(bs + p), *(bv + p),
                    th);
    }
#line 426
    p ++;
  }
#line 432
  lextree_enter(*(kb___0->fillertree + k___0), (s3cipid_t )-1, cf, *(vh->bestscore + cf),
                *(vh->bestvh + cf), th);
#line 433
  return;
}
}
#line 437 "src/utt.c"
void utt_decode(void *data , char *uttfile , int32 sf , int32 ef , char *uttid ) 
{ 
  kb_t *kb___0 ;
  kbcore_t *kbcore___0 ;
  mdef_t *mdef ;
  dict_t *dict ;
  dict2pid_t *d2p ;
  mgau_model_t *mgau ;
  subvq_t *svq ;
  lextree_t *lextree ;
  int32 besthmmscr ;
  int32 bestwordscr ;
  int32 th ;
  int32 pth ;
  int32 wth ;
  int32 maxwpf___0 ;
  int32 maxhistpf___0 ;
  int32 maxhmmpf___0 ;
  int32 ptranskip___0 ;
  int32 i ;
  int32 j ;
  int32 f ;
  int32 n_hmm_eval ;
  int32 frm_nhmm ;
  int32 hb ;
  int32 pb ;
  int32 wb ;
  FILE *hmmdumpfp___0 ;
  void const   *tmp___0 ;
  void const   *tmp___1 ;
  void const   *tmp___2 ;
  void const   *tmp___3 ;
  void const   *tmp___4 ;
  void const   *tmp___5 ;
  int32 *bin ;
  int32 nbin ;
  int32 bw ;
  void *tmp___6 ;

  {
#line 452
  _E__pr_info_header("src/utt.c", 452L, "INFO");
#line 452
  _E__pr_info("Processing: %s\n", uttid);
#line 454
  kb___0 = (kb_t *)data;
#line 455
  kbcore___0 = kb___0->kbcore;
#line 456
  mdef = kbcore___0->mdef;
#line 457
  dict = kbcore___0->dict;
#line 458
  d2p = kbcore___0->dict2pid;
#line 459
  mgau = kbcore___0->mgau;
#line 460
  svq = kbcore___0->svq;
#line 462
  kb___0->uttid = uttid;
#line 464
  tmp___0 = cmd_ln_access((char *)"-hmmdump");
#line 464
  if (*((int32 *)tmp___0)) {
#line 464
    hmmdumpfp___0 = stderr;
  } else {
#line 464
    hmmdumpfp___0 = (FILE *)((void *)0);
  }
#line 465
  tmp___1 = cmd_ln_access((char *)"-maxwpf");
#line 465
  maxwpf___0 = *((int32 *)tmp___1);
#line 466
  tmp___2 = cmd_ln_access((char *)"-maxhistpf");
#line 466
  maxhistpf___0 = *((int32 *)tmp___2);
#line 467
  tmp___3 = cmd_ln_access((char *)"-maxhmmpf");
#line 467
  maxhmmpf___0 = *((int32 *)tmp___3);
#line 468
  tmp___4 = cmd_ln_access((char *)"-ptranskip");
#line 468
  ptranskip___0 = *((int32 *)tmp___4);
#line 471
  tmp___5 = cmd_ln_access((char *)"-cepdir");
#line 471
  kb___0->nfr = feat_s2mfc2feat(kbcore___0->fcb, uttfile, (char *)tmp___5, sf, ef,
                                kb___0->feat, 15000);
#line 473
  _E__pr_info_header("src/utt.c", 473L, "INFO");
#line 473
  _E__pr_info("%s: %d frames\n", kb___0->uttid, kb___0->nfr);
#line 475
  i = 0;
#line 475
  while (i < kb___0->hmm_hist_bins) {
#line 476
    *(kb___0->hmm_hist + i) = 0;
#line 475
    i ++;
  }
#line 478
  utt_begin(kb___0);
#line 480
  n_hmm_eval = 0;
#line 481
  kb___0->utt_sen_eval = 0;
#line 482
  kb___0->utt_gau_eval = 0;
#line 484
  f = 0;
#line 484
  while (f < kb___0->nfr) {
#line 486
    ptmr_start(& kb___0->tm_sen);
#line 489
    if (kb___0->sen_active) {
#line 490
      memset((void *)kb___0->ssid_active, 0, (unsigned long )mdef->n_sseq * sizeof(int32 ));
#line 491
      memset((void *)kb___0->comssid_active, 0, (unsigned long )d2p->n_comsseq * sizeof(int32 ));
#line 493
      i = 0;
#line 493
      while (i < kb___0->n_lextree << 1) {
#line 494
        if (i < kb___0->n_lextree) {
#line 494
          lextree = *(kb___0->ugtree + i);
        } else {
#line 494
          lextree = *(kb___0->fillertree + (i - kb___0->n_lextree));
        }
#line 496
        lextree_ssid_active(lextree, kb___0->ssid_active, kb___0->comssid_active);
#line 493
        i ++;
      }
#line 500
      memset((void *)kb___0->sen_active, 0, (unsigned long )mdef->n_sen * sizeof(int32 ));
#line 501
      mdef_sseq2sen_active(mdef, kb___0->ssid_active, kb___0->sen_active);
#line 504
      dict2pid_comsseq2sen_active(d2p, mdef, kb___0->comssid_active, kb___0->sen_active);
    }
#line 508
    subvq_frame_eval(svq, mgau, (kb___0->beam)->subvq, *(*(kb___0->feat + f) + 0),
                     kb___0->sen_active, (kb___0->ascr)->sen);
#line 510
    kb___0->utt_sen_eval += mgau->frm_sen_eval;
#line 511
    kb___0->utt_gau_eval += mgau->frm_gau_eval;
#line 514
    dict2pid_comsenscr(kbcore___0->dict2pid, (kb___0->ascr)->sen, (kb___0->ascr)->comsen);
#line 516
    ptmr_stop(& kb___0->tm_sen);
#line 519
    ptmr_start(& kb___0->tm_srch);
#line 522
    besthmmscr = (int32 )2147483648U;
#line 523
    bestwordscr = (int32 )2147483648U;
#line 524
    frm_nhmm = 0;
#line 525
    i = 0;
#line 525
    while (i < kb___0->n_lextree << 1) {
#line 526
      if (i < kb___0->n_lextree) {
#line 526
        lextree = *(kb___0->ugtree + i);
      } else {
#line 526
        lextree = *(kb___0->fillertree + (i - kb___0->n_lextree));
      }
#line 528
      if ((unsigned long )hmmdumpfp___0 != (unsigned long )((void *)0)) {
#line 529
        fprintf((FILE * __restrict  )hmmdumpfp___0, (char const   * __restrict  )"Fr %d Lextree %d #HMM %d\n",
                f, i, lextree->n_active);
      }
#line 531
      lextree_hmm_eval(lextree, kbcore___0, kb___0->ascr, f, hmmdumpfp___0);
#line 533
      if (besthmmscr < lextree->best) {
#line 534
        besthmmscr = lextree->best;
      }
#line 535
      if (bestwordscr < lextree->wbest) {
#line 536
        bestwordscr = lextree->wbest;
      }
#line 538
      n_hmm_eval += lextree->n_active;
#line 539
      frm_nhmm += lextree->n_active;
#line 525
      i ++;
    }
#line 541
    if (besthmmscr > 0) {
#line 542
      _E__pr_header("src/utt.c", 542L, "ERROR");
#line 542
      _E__pr_warn("***ERROR*** Fr %d, best HMM score > 0 (%d); int32 wraparound?\n",
                  f, besthmmscr);
    }
#line 546
    (*(kb___0->hmm_hist + frm_nhmm / kb___0->hmm_hist_binsize)) ++;
#line 549
    if (frm_nhmm > maxhmmpf___0 + (maxhmmpf___0 >> 1)) {
#line 553
      nbin = 1000;
#line 554
      bw = - (kb___0->beam)->hmm / nbin;
#line 555
      tmp___6 = __ckd_calloc__((size_t )nbin, sizeof(int32 ), "src/utt.c", 555);
#line 555
      bin = (int32 *)tmp___6;
#line 557
      i = 0;
#line 557
      while (i < kb___0->n_lextree << 1) {
#line 558
        if (i < kb___0->n_lextree) {
#line 558
          lextree = *(kb___0->ugtree + i);
        } else {
#line 558
          lextree = *(kb___0->fillertree + (i - kb___0->n_lextree));
        }
#line 561
        lextree_hmm_histbin(lextree, besthmmscr, bin, nbin, bw);
#line 557
        i ++;
      }
#line 564
      i = 0;
#line 564
      j = 0;
#line 564
      while (1) {
#line 564
        if (i < nbin) {
#line 564
          if (! (j < maxhmmpf___0)) {
#line 564
            break;
          }
        } else {
#line 564
          break;
        }
#line 564
        i ++;
#line 564
        j += *(bin + i);
      }
#line 565
      free((void *)bin);
#line 568
      hb = - (i * bw);
#line 569
      if (hb > (kb___0->beam)->ptrans) {
#line 569
        pb = hb;
      } else {
#line 569
        pb = (kb___0->beam)->ptrans;
      }
#line 570
      if (hb > (kb___0->beam)->word) {
#line 570
        wb = hb;
      } else {
#line 570
        wb = (kb___0->beam)->word;
      }
    } else {
#line 573
      hb = (kb___0->beam)->hmm;
#line 574
      pb = (kb___0->beam)->ptrans;
#line 575
      wb = (kb___0->beam)->word;
    }
#line 578
    kb___0->bestscore = besthmmscr;
#line 579
    kb___0->bestwordscore = bestwordscr;
#line 580
    th = kb___0->bestscore + hb;
#line 581
    pth = kb___0->bestscore + pb;
#line 582
    wth = kb___0->bestwordscore + wb;
#line 588
    i = 0;
#line 588
    while (i < kb___0->n_lextree << 1) {
#line 589
      if (i < kb___0->n_lextree) {
#line 589
        lextree = *(kb___0->ugtree + i);
      } else {
#line 589
        lextree = *(kb___0->fillertree + (i - kb___0->n_lextree));
      }
#line 592
      if (ptranskip___0 < 1) {
#line 593
        lextree_hmm_propagate(lextree, kbcore___0, kb___0->vithist, f, th, pth, wth);
      } else
#line 592
      if (f % ptranskip___0 != 0) {
#line 593
        lextree_hmm_propagate(lextree, kbcore___0, kb___0->vithist, f, th, pth, wth);
      } else {
#line 595
        lextree_hmm_propagate(lextree, kbcore___0, kb___0->vithist, f, th, wth, wth);
      }
#line 588
      i ++;
    }
#line 599
    vithist_prune(kb___0->vithist, dict, f, maxwpf___0, maxhistpf___0, wb);
#line 602
    utt_word_trans(kb___0, f);
#line 605
    vithist_frame_windup(kb___0->vithist, f, (FILE *)((void *)0), kbcore___0);
#line 607
    kb_lextree_active_swap(kb___0);
#line 609
    ptmr_stop(& kb___0->tm_srch);
#line 611
    if (f % 100 == 0) {
#line 612
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )".");
#line 613
      fflush(stderr);
    }
#line 484
    f ++;
  }
#line 617
  kb___0->utt_hmm_eval = n_hmm_eval;
#line 619
  utt_end(kb___0);
#line 620
  kb___0->tot_fr += kb___0->nfr;
#line 622
  fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )"\n");
#line 623
  return;
}
}
#line 626 "src/utt.c"
sen_active_args_t sen_active_args  ;
#line 627 "src/utt.c"
scoring_args_t scoring_args  ;
#line 628 "src/utt.c"
searching_args_t searching_args  ;
#line 639 "src/utt.c"
void utt_decode_block(float **block_feat , int32 block_nfeatvec , int32 *curfrm ,
                      kb_t *kb___0 , int32 maxwpf___0 , int32 maxhistpf___0 , int32 maxhmmpf___0 ,
                      int32 ptranskip___0 , FILE *hmmdumpfp___0 ) 
{ 
  kbcore_t *kbcore___0 ;
  mdef_t *mdef ;
  dict_t *dict ;
  dict2pid_t *d2p ;
  mgau_model_t *mgau ;
  subvq_t *svq ;
  lextree_t *lextree ;
  int32 besthmmscr ;
  int32 bestwordscr ;
  int32 th ;
  int32 pth ;
  int32 wth ;
  int32 i ;
  int32 j ;
  int32 t ;
  int32 n_hmm_eval ;
  int32 frmno___0 ;
  int32 frm_nhmm ;
  int32 hb ;
  int32 pb ;
  int32 wb ;
  int32 *bin ;
  int32 nbin ;
  int32 bw ;
  void *tmp ;

  {
#line 665
  kbcore___0 = kb___0->kbcore;
#line 666
  mdef = kbcore___0->mdef;
#line 667
  dict = kbcore___0->dict;
#line 668
  d2p = kbcore___0->dict2pid;
#line 669
  mgau = kbcore___0->mgau;
#line 670
  svq = kbcore___0->svq;
#line 672
  frmno___0 = *curfrm;
#line 675
  memset((void *)kb___0->hmm_hist, 0, (unsigned long )kb___0->hmm_hist_bins * sizeof(int32 ));
#line 680
  n_hmm_eval = 0;
#line 683
  t = 0;
#line 683
  while (t < block_nfeatvec) {
#line 686
    ptmr_start(& kb___0->tm_sen);
#line 689
    if (kb___0->sen_active) {
#line 692
      sen_active_args.kb = kb___0;
#line 693
      sen_active_args.mdef = mdef;
#line 694
      sen_active_args.d2p = d2p;
#line 696
      thrd_sen_active_phase(& sen_active_args);
    } else {
#line 718
      __assert_fail("0&&\"!sen_active\\n\"", "src/utt.c", 718U, "utt_decode_block");
    }
#line 722
    scoring_args.vq = svq;
#line 723
    scoring_args.g = mgau;
#line 724
    scoring_args.beam = (kb___0->beam)->subvq;
#line 725
    scoring_args.feat = *(block_feat + t);
#line 726
    scoring_args.sen_active = kb___0->sen_active;
#line 727
    scoring_args.senscr = (kb___0->ascr)->sen;
#line 729
    scoring_args.d2p = d2p;
#line 730
    scoring_args.comsenscr = (kb___0->ascr)->comsen;
#line 732
    thrd_scoring_phase(& scoring_args);
#line 734
    kb___0->utt_sen_eval += mgau->frm_sen_eval;
#line 735
    kb___0->utt_gau_eval += mgau->frm_gau_eval;
#line 757
    ptmr_stop(& kb___0->tm_sen);
#line 760
    ptmr_start(& kb___0->tm_srch);
#line 764
    besthmmscr = (int32 )2147483648U;
#line 765
    bestwordscr = (int32 )2147483648U;
#line 766
    frm_nhmm = 0;
#line 771
    searching_args.kbc = kbcore___0;
#line 772
    searching_args.ascr = kb___0->ascr;
#line 773
    searching_args.frm = frmno___0;
#line 774
    searching_args.fp = hmmdumpfp___0;
#line 775
    searching_args.kb = kb___0;
#line 777
    new_thrd_lextree_hmm_eval(& searching_args, & besthmmscr, & bestwordscr, & n_hmm_eval,
                              & frm_nhmm);
#line 812
    if (besthmmscr > 0) {
#line 813
      _E__pr_header("src/utt.c", 813L, "ERROR");
#line 813
      _E__pr_warn("***ERROR*** Fr %d, best HMM score > 0 (%d); int32 wraparound?\n",
                  frmno___0, besthmmscr);
    }
#line 817
    (*(kb___0->hmm_hist + frm_nhmm / kb___0->hmm_hist_binsize)) ++;
#line 822
    if (frm_nhmm > maxhmmpf___0 + (maxhmmpf___0 >> 1)) {
#line 826
      nbin = 1000;
#line 827
      bw = - (kb___0->beam)->hmm / nbin;
#line 828
      tmp = __ckd_calloc__((size_t )nbin, sizeof(int32 ), "src/utt.c", 828);
#line 828
      bin = (int32 *)tmp;
#line 830
      i = 0;
#line 830
      while (i < kb___0->n_lextree << 1) {
#line 831
        if (i < kb___0->n_lextree) {
#line 831
          lextree = *(kb___0->ugtree + i);
        } else {
#line 831
          lextree = *(kb___0->fillertree + (i - kb___0->n_lextree));
        }
#line 834
        lextree_hmm_histbin(lextree, besthmmscr, bin, nbin, bw);
#line 830
        i ++;
      }
#line 837
      i = 0;
#line 837
      j = 0;
#line 837
      while (1) {
#line 837
        if (i < nbin) {
#line 837
          if (! (j < maxhmmpf___0)) {
#line 837
            break;
          }
        } else {
#line 837
          break;
        }
#line 837
        i ++;
#line 837
        j += *(bin + i);
      }
#line 838
      free((void *)bin);
#line 841
      hb = - (i * bw);
#line 842
      if (hb > (kb___0->beam)->ptrans) {
#line 842
        pb = hb;
      } else {
#line 842
        pb = (kb___0->beam)->ptrans;
      }
#line 843
      if (hb > (kb___0->beam)->word) {
#line 843
        wb = hb;
      } else {
#line 843
        wb = (kb___0->beam)->word;
      }
    } else {
#line 845
      hb = (kb___0->beam)->hmm;
#line 846
      pb = (kb___0->beam)->ptrans;
#line 847
      wb = (kb___0->beam)->word;
    }
#line 850
    kb___0->bestscore = besthmmscr;
#line 851
    kb___0->bestwordscore = bestwordscr;
#line 852
    th = kb___0->bestscore + hb;
#line 853
    pth = kb___0->bestscore + pb;
#line 854
    wth = kb___0->bestwordscore + wb;
#line 857
    searching_args.ptranskip = ptranskip___0;
#line 858
    searching_args.vithist = kb___0->vithist;
#line 859
    searching_args.th = th;
#line 863
    if (ptranskip___0 < 1) {
#line 865
      searching_args.pth = pth;
    } else
#line 863
    if (frmno___0 % ptranskip___0 != 0) {
#line 865
      searching_args.pth = pth;
    } else {
#line 867
      searching_args.pth = wth;
    }
#line 868
    searching_args.wth = wth;
#line 870
    new_thrd_lextree_hmm_propagate(& searching_args);
#line 901
    vithist_prune(kb___0->vithist, dict, frmno___0, maxwpf___0, maxhistpf___0, wb);
#line 904
    utt_word_trans(kb___0, frmno___0);
#line 907
    vithist_frame_windup(kb___0->vithist, frmno___0, (FILE *)((void *)0), kbcore___0);
#line 909
    kb_lextree_active_swap(kb___0);
#line 911
    ptmr_stop(& kb___0->tm_srch);
#line 683
    t ++;
#line 683
    frmno___0 ++;
  }
#line 915
  kb___0->utt_hmm_eval += n_hmm_eval;
#line 916
  kb___0->nfr += block_nfeatvec;
#line 918
  *curfrm = frmno___0;
#line 919
  return;
}
}
#line 921 "src/utt.c"
void single_utt_decode_block(float **block_feat , int32 block_nfeatvec , int32 *curfrm ,
                             kb_t *kb___0 , int32 maxwpf___0 , int32 maxhistpf___0 ,
                             int32 maxhmmpf___0 , int32 ptranskip___0 , FILE *hmmdumpfp___0 ) 
{ 
  kbcore_t *kbcore___0 ;
  mdef_t *mdef ;
  dict_t *dict ;
  dict2pid_t *d2p ;
  mgau_model_t *mgau ;
  subvq_t *svq ;
  lextree_t *lextree ;
  int32 besthmmscr ;
  int32 bestwordscr ;
  int32 th ;
  int32 pth ;
  int32 wth ;
  int32 i ;
  int32 j ;
  int32 t ;
  int32 n_hmm_eval ;
  int32 frmno___0 ;
  int32 frm_nhmm ;
  int32 hb ;
  int32 pb ;
  int32 wb ;
  int32 *bin ;
  int32 nbin ;
  int32 bw ;
  void *tmp ;

  {
#line 947
  kbcore___0 = kb___0->kbcore;
#line 948
  mdef = kbcore___0->mdef;
#line 949
  dict = kbcore___0->dict;
#line 950
  d2p = kbcore___0->dict2pid;
#line 951
  mgau = kbcore___0->mgau;
#line 952
  svq = kbcore___0->svq;
#line 954
  frmno___0 = *curfrm;
#line 956
  memset((void *)kb___0->hmm_hist, 0, (unsigned long )kb___0->hmm_hist_bins * sizeof(int32 ));
#line 961
  n_hmm_eval = 0;
#line 964
  t = 0;
#line 964
  while (t < block_nfeatvec) {
#line 967
    ptmr_start(& kb___0->tm_sen);
#line 970
    if (kb___0->sen_active) {
#line 971
      memset((void *)kb___0->ssid_active, 0, (unsigned long )mdef->n_sseq * sizeof(int32 ));
#line 972
      memset((void *)kb___0->comssid_active, 0, (unsigned long )d2p->n_comsseq * sizeof(int32 ));
#line 974
      memset((void *)kb___0->sen_active, 0, (unsigned long )mdef->n_sen * sizeof(int32 ));
#line 977
      i = 0;
#line 977
      while (i < kb___0->n_lextree << 1) {
#line 978
        if (i < kb___0->n_lextree) {
#line 978
          lextree = *(kb___0->ugtree + i);
        } else {
#line 978
          lextree = *(kb___0->fillertree + (i - kb___0->n_lextree));
        }
#line 980
        lextree_ssid_active(lextree, kb___0->ssid_active, kb___0->comssid_active);
#line 977
        i ++;
      }
#line 984
      mdef_sseq2sen_active(mdef, kb___0->ssid_active, kb___0->sen_active);
#line 987
      dict2pid_comsseq2sen_active(d2p, mdef, kb___0->comssid_active, kb___0->sen_active);
    } else {
#line 990
      __assert_fail("0&&\"!sen_active\\n\"", "src/utt.c", 990U, "single_utt_decode_block");
    }
#line 994
    subvq_frame_eval(svq, mgau, (kb___0->beam)->subvq, *(block_feat + t), kb___0->sen_active,
                     (kb___0->ascr)->sen);
#line 997
    kb___0->utt_sen_eval += mgau->frm_sen_eval;
#line 998
    kb___0->utt_gau_eval += mgau->frm_gau_eval;
#line 1003
    dict2pid_comsenscr(d2p, (kb___0->ascr)->sen, (kb___0->ascr)->comsen);
#line 1006
    ptmr_stop(& kb___0->tm_sen);
#line 1009
    ptmr_start(& kb___0->tm_srch);
#line 1012
    besthmmscr = (int32 )2147483648U;
#line 1013
    bestwordscr = (int32 )2147483648U;
#line 1014
    frm_nhmm = 0;
#line 1016
    i = 0;
#line 1016
    while (i < kb___0->n_lextree << 1) {
#line 1017
      if (i < kb___0->n_lextree) {
#line 1017
        lextree = *(kb___0->ugtree + i);
      } else {
#line 1017
        lextree = *(kb___0->fillertree + (i - kb___0->n_lextree));
      }
#line 1020
      if ((unsigned long )hmmdumpfp___0 != (unsigned long )((void *)0)) {
#line 1021
        fprintf((FILE * __restrict  )hmmdumpfp___0, (char const   * __restrict  )"Fr %d Lextree %d #HMM %d\n",
                frmno___0, i, lextree->n_active);
      }
#line 1024
      lextree_hmm_eval(lextree, kbcore___0, kb___0->ascr, frmno___0, hmmdumpfp___0);
#line 1026
      if (besthmmscr < lextree->best) {
#line 1027
        besthmmscr = lextree->best;
      }
#line 1028
      if (bestwordscr < lextree->wbest) {
#line 1029
        bestwordscr = lextree->wbest;
      }
#line 1031
      n_hmm_eval += lextree->n_active;
#line 1032
      frm_nhmm += lextree->n_active;
#line 1016
      i ++;
    }
#line 1035
    if (besthmmscr > 0) {
#line 1036
      _E__pr_header("src/utt.c", 1036L, "ERROR");
#line 1036
      _E__pr_warn("***ERROR*** Fr %d, best HMM score > 0 (%d); int32 wraparound?\n",
                  frmno___0, besthmmscr);
    }
#line 1040
    (*(kb___0->hmm_hist + frm_nhmm / kb___0->hmm_hist_binsize)) ++;
#line 1045
    if (frm_nhmm > maxhmmpf___0 + (maxhmmpf___0 >> 1)) {
#line 1049
      nbin = 1000;
#line 1050
      bw = - (kb___0->beam)->hmm / nbin;
#line 1051
      tmp = __ckd_calloc__((size_t )nbin, sizeof(int32 ), "src/utt.c", 1051);
#line 1051
      bin = (int32 *)tmp;
#line 1053
      i = 0;
#line 1053
      while (i < kb___0->n_lextree << 1) {
#line 1054
        if (i < kb___0->n_lextree) {
#line 1054
          lextree = *(kb___0->ugtree + i);
        } else {
#line 1054
          lextree = *(kb___0->fillertree + (i - kb___0->n_lextree));
        }
#line 1057
        lextree_hmm_histbin(lextree, besthmmscr, bin, nbin, bw);
#line 1053
        i ++;
      }
#line 1060
      i = 0;
#line 1060
      j = 0;
#line 1060
      while (1) {
#line 1060
        if (i < nbin) {
#line 1060
          if (! (j < maxhmmpf___0)) {
#line 1060
            break;
          }
        } else {
#line 1060
          break;
        }
#line 1060
        i ++;
#line 1060
        j += *(bin + i);
      }
#line 1061
      free((void *)bin);
#line 1064
      hb = - (i * bw);
#line 1065
      if (hb > (kb___0->beam)->ptrans) {
#line 1065
        pb = hb;
      } else {
#line 1065
        pb = (kb___0->beam)->ptrans;
      }
#line 1066
      if (hb > (kb___0->beam)->word) {
#line 1066
        wb = hb;
      } else {
#line 1066
        wb = (kb___0->beam)->word;
      }
    } else {
#line 1068
      hb = (kb___0->beam)->hmm;
#line 1069
      pb = (kb___0->beam)->ptrans;
#line 1070
      wb = (kb___0->beam)->word;
    }
#line 1073
    kb___0->bestscore = besthmmscr;
#line 1074
    kb___0->bestwordscore = bestwordscr;
#line 1075
    th = kb___0->bestscore + hb;
#line 1076
    pth = kb___0->bestscore + pb;
#line 1077
    wth = kb___0->bestwordscore + wb;
#line 1084
    i = 0;
#line 1084
    while (i < kb___0->n_lextree << 1) {
#line 1085
      if (i < kb___0->n_lextree) {
#line 1085
        lextree = *(kb___0->ugtree + i);
      } else {
#line 1085
        lextree = *(kb___0->fillertree + (i - kb___0->n_lextree));
      }
#line 1089
      if (ptranskip___0 < 1) {
#line 1090
        lextree_hmm_propagate(lextree, kbcore___0, kb___0->vithist, frmno___0, th,
                              pth, wth);
      } else
#line 1089
      if (frmno___0 % ptranskip___0 != 0) {
#line 1090
        lextree_hmm_propagate(lextree, kbcore___0, kb___0->vithist, frmno___0, th,
                              pth, wth);
      } else {
#line 1093
        lextree_hmm_propagate(lextree, kbcore___0, kb___0->vithist, frmno___0, th,
                              wth, wth);
      }
#line 1084
      i ++;
    }
#line 1098
    vithist_prune(kb___0->vithist, dict, frmno___0, maxwpf___0, maxhistpf___0, wb);
#line 1101
    utt_word_trans(kb___0, frmno___0);
#line 1104
    vithist_frame_windup(kb___0->vithist, frmno___0, (FILE *)((void *)0), kbcore___0);
#line 1106
    kb_lextree_active_swap(kb___0);
#line 1108
    ptmr_stop(& kb___0->tm_srch);
#line 964
    t ++;
#line 964
    frmno___0 ++;
  }
#line 1112
  kb___0->utt_hmm_eval += n_hmm_eval;
#line 1113
  kb___0->nfr += block_nfeatvec;
#line 1115
  *curfrm = frmno___0;
#line 1116
  return;
}
}
#line 1 "new_fe_sp.o"
#pragma merger("0","/tmp/cil-PYPCMFJy.i","-g,-O4")
#line 63 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h"
extern  __attribute__((__nothrow__)) double ( __attribute__((__leaf__)) cos)(double __x ) ;
#line 65
extern  __attribute__((__nothrow__)) double ( __attribute__((__leaf__)) sin)(double __x ) ;
#line 150 "/usr/include/x86_64-linux-gnu/bits/mathinline.h"
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__, __always_inline__)) __signbitl)(long double __x )  __attribute__((__const__)) ;
#line 150 "/usr/include/x86_64-linux-gnu/bits/mathinline.h"
__inline extern int ( __attribute__((__leaf__, __always_inline__)) __signbitl)(long double __x ) 
{ 
  union __anonunion___u_8 __u ;

  {
#line 153
  __u.__l = __x;
#line 154
  return ((__u.__i[2] & 32768) != 0);
}
}
#line 99 "src/new_fe_sp.h"
int fe_build_melfilters(melfb_t *MEL_FB ) ;
#line 100
int fe_compute_melcosine(melfb_t *MEL_FB ) ;
#line 101
float fe_mel(float x___0 ) ;
#line 102
float fe_melinv(float x___0 ) ;
#line 103
void fe_pre_emphasis(int16 *in , double *out , int len , float factor , int16 prior ) ;
#line 104
void fe_hamming_window(double *in , double *window , int in_len ) ;
#line 106
void fe_spec_magnitude(double *data , int data_len , double *spec , int fftsize ) ;
#line 107
void fe_frame_to_fea(fe_t *FE , double *in , double *fea ) ;
#line 108
void fe_mel_spec(fe_t *FE , double *spec , double *mfspec ) ;
#line 109
void fe_mel_cep(fe_t *FE , double *mfspec , double *mfcep ) ;
#line 110
int fe_fft(complex *in , complex *out , int N , int invert ) ;
#line 111
void fe_short_to_double(int16 *in , double *out , int len ) ;
#line 112
char **fe_create_2d(int d1 , int d2 , int elem_size ) ;
#line 113
void fe_free_2d(void **arr ) ;
#line 114
void fe_print_current(fe_t *FE ) ;
#line 115
void fe_parse_general_params(param_t *P , fe_t *FE ) ;
#line 116
void fe_parse_melfb_params(param_t *P , melfb_t *MEL ) ;
#line 117
void fe_create_hamming(double *in , int in_len ) ;
#line 107 "src/new_fe_sp.c"
int fe_build_melfilters(melfb_t *MEL_FB ) 
{ 
  int i ;
  int whichfilt ;
  int start_pt ;
  float leftfr ;
  float centerfr ;
  float rightfr ;
  float fwidth ;
  float height ;
  float *filt_edge ;
  float melmax ;
  float melmin ;
  float dmelbw ;
  float freq ;
  float dfreq ;
  float leftslope ;
  float rightslope ;
  char **tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;

  {
#line 114
  tmp = fe_create_2d(MEL_FB->num_filters, MEL_FB->fft_size, (int )sizeof(float ));
#line 114
  MEL_FB->filter_coeffs = (float **)tmp;
#line 115
  tmp___0 = calloc((size_t )MEL_FB->num_filters, sizeof(float ));
#line 115
  MEL_FB->left_apex = (float *)tmp___0;
#line 116
  tmp___1 = calloc((size_t )MEL_FB->num_filters, sizeof(int ));
#line 116
  MEL_FB->width = (int *)tmp___1;
#line 118
  tmp___2 = calloc((size_t )(MEL_FB->num_filters + 2), sizeof(float ));
#line 118
  filt_edge = (float *)tmp___2;
#line 120
  if ((unsigned long )MEL_FB->filter_coeffs == (unsigned long )((void *)0)) {
#line 121
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"memory alloc failed in fe_build_mel_filters()\n...exiting\n");
#line 122
    exit(0);
  } else
#line 120
  if ((unsigned long )MEL_FB->left_apex == (unsigned long )((void *)0)) {
#line 121
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"memory alloc failed in fe_build_mel_filters()\n...exiting\n");
#line 122
    exit(0);
  } else
#line 120
  if ((unsigned long )MEL_FB->width == (unsigned long )((void *)0)) {
#line 121
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"memory alloc failed in fe_build_mel_filters()\n...exiting\n");
#line 122
    exit(0);
  } else
#line 120
  if ((unsigned long )filt_edge == (unsigned long )((void *)0)) {
#line 121
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"memory alloc failed in fe_build_mel_filters()\n...exiting\n");
#line 122
    exit(0);
  }
#line 125
  dfreq = MEL_FB->sampling_rate / (float )MEL_FB->fft_size;
#line 127
  melmax = fe_mel(MEL_FB->upper_filt_freq);
#line 128
  melmin = fe_mel(MEL_FB->lower_filt_freq);
#line 129
  dmelbw = (melmax - melmin) / (float )(MEL_FB->num_filters + 1);
#line 131
  i = 0;
#line 131
  while (i <= MEL_FB->num_filters + 1) {
#line 132
    *(filt_edge + i) = fe_melinv((float )i * dmelbw + melmin);
#line 131
    i ++;
  }
#line 138
  whichfilt = 0;
#line 138
  while (whichfilt < MEL_FB->num_filters) {
#line 147
    leftfr = (float )((int )((double )(*(filt_edge + whichfilt) / dfreq) + 0.5)) * dfreq;
#line 148
    centerfr = (float )((int )((double )(*(filt_edge + (whichfilt + 1)) / dfreq) + 0.5)) * dfreq;
#line 149
    rightfr = (float )((int )((double )(*(filt_edge + (whichfilt + 2)) / dfreq) + 0.5)) * dfreq;
#line 151
    *(MEL_FB->left_apex + whichfilt) = leftfr;
#line 153
    fwidth = rightfr - leftfr;
#line 156
    height = (float )2 / fwidth;
#line 157
    leftslope = height / (centerfr - leftfr);
#line 158
    rightslope = height / (centerfr - rightfr);
#line 160
    start_pt = 1 + (int )(leftfr / dfreq);
#line 161
    freq = (float )start_pt * dfreq;
#line 162
    i = 0;
#line 164
    while (freq <= centerfr) {
#line 165
      *(*(MEL_FB->filter_coeffs + whichfilt) + i) = (freq - leftfr) * leftslope;
#line 166
      freq += dfreq;
#line 167
      i ++;
    }
#line 169
    while (freq < rightfr) {
#line 170
      *(*(MEL_FB->filter_coeffs + whichfilt) + i) = (freq - rightfr) * rightslope;
#line 171
      freq += dfreq;
#line 172
      i ++;
    }
#line 175
    *(MEL_FB->width + whichfilt) = i;
#line 138
    whichfilt ++;
  }
#line 178
  free((void *)filt_edge);
#line 179
  return (0);
}
}
#line 182 "src/new_fe_sp.c"
int fe_compute_melcosine(melfb_t *MEL_FB ) 
{ 
  float period ;
  float freq ;
  int i ;
  int j ;
  float **tmp ;
  char **tmp___0 ;
  double tmp___1 ;

  {
#line 188
  period = (float )2 * (float )MEL_FB->num_filters;
#line 190
  tmp___0 = fe_create_2d(MEL_FB->num_cepstra, MEL_FB->num_filters, (int )sizeof(float ));
#line 190
  tmp = (float **)tmp___0;
#line 190
  MEL_FB->mel_cosine = tmp;
#line 190
  if ((unsigned long )tmp == (unsigned long )((void *)0)) {
#line 192
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"memory alloc failed in fe_compute_melcosine()\n...exiting\n");
#line 193
    exit(0);
  }
#line 197
  i = 0;
#line 197
  while (i < MEL_FB->num_cepstra) {
#line 198
    freq = (((float )2 * (float )3.14159265358979323846) * (float )i) / period;
#line 199
    j = 0;
#line 199
    while (j < MEL_FB->num_filters) {
#line 200
      tmp___1 = cos((double )freq * ((double )j + 0.5));
#line 200
      *(*(MEL_FB->mel_cosine + i) + j) = (float )tmp___1;
#line 199
      j ++;
    }
#line 197
    i ++;
  }
#line 203
  return (0);
}
}
#line 208 "src/new_fe_sp.c"
float fe_mel(float x___0 ) 
{ 
  double tmp ;

  {
#line 210
  tmp = log10(1.0 + (double )x___0 / 700.0);
#line 210
  return ((float )(2595.0 * (double )((float )tmp)));
}
}
#line 213 "src/new_fe_sp.c"
float fe_melinv(float x___0 ) 
{ 
  double tmp ;

  {
#line 215
  tmp = pow(10.0, (double )x___0 / 2595.0);
#line 215
  return ((float )(700.0 * ((double )((float )tmp) - 1.0)));
}
}
#line 219 "src/new_fe_sp.c"
void fe_pre_emphasis(int16 *in , double *out , int len , float factor , int16 prior ) 
{ 
  int i ;

  {
#line 224
  *(out + 0) = (double )*(in + 0) - (double )factor * (double )prior;
#line 225
  i = 1;
#line 225
  while (i < len) {
#line 226
    *(out + i) = (double )*(in + i) - (double )factor * (double )*(in + (i - 1));
#line 225
    i ++;
  }
#line 229
  return;
}
}
#line 231 "src/new_fe_sp.c"
void fe_short_to_double(int16 *in , double *out , int len ) 
{ 
  int i ;

  {
#line 235
  i = 0;
#line 235
  while (i < len) {
#line 236
    *(out + i) = (double )*(in + i);
#line 235
    i ++;
  }
#line 237
  return;
}
}
#line 240 "src/new_fe_sp.c"
void fe_create_hamming(double *in , int in_len ) 
{ 
  int i ;
  double tmp ;

  {
#line 244
  if (in_len > 1) {
#line 246
    i = 0;
#line 246
    while (i < in_len) {
#line 247
      tmp = cos((((double )2 * 3.14159265358979323846) * (double )i) / ((double )in_len - 1.0));
#line 247
      *(in + i) = 0.54 - 0.46 * tmp;
#line 246
      i ++;
    }
  }
#line 249
  return;
}
}
#line 254 "src/new_fe_sp.c"
void fe_hamming_window(double *in , double *window , int in_len ) 
{ 
  int i ;

  {
#line 258
  if (in_len > 1) {
#line 259
    i = 0;
#line 259
    while (i < in_len) {
#line 260
      *(in + i) *= *(window + i);
#line 259
      i ++;
    }
  }
#line 262
  return;
}
}
#line 267 "src/new_fe_sp.c"
void fe_frame_to_fea(fe_t *FE , double *in , double *fea ) 
{ 
  double *spec ;
  double *mfspec ;
  void *tmp ;
  void *tmp___0 ;

  {
#line 272
  if (FE->FB_TYPE == 1) {
#line 273
    tmp = calloc((size_t )FE->FFT_SIZE, sizeof(double ));
#line 273
    spec = (double *)tmp;
#line 274
    tmp___0 = calloc((size_t )(FE->MEL_FB)->num_filters, sizeof(double ));
#line 274
    mfspec = (double *)tmp___0;
#line 276
    if ((unsigned long )spec == (unsigned long )((void *)0)) {
#line 277
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"memory alloc failed in fe_frame_to_fea()\n...exiting\n");
#line 278
      exit(0);
    } else
#line 276
    if ((unsigned long )mfspec == (unsigned long )((void *)0)) {
#line 277
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"memory alloc failed in fe_frame_to_fea()\n...exiting\n");
#line 278
      exit(0);
    }
#line 281
    fe_spec_magnitude(in, FE->FRAME_SIZE, spec, FE->FFT_SIZE);
#line 282
    fe_mel_spec(FE, spec, mfspec);
#line 283
    fe_mel_cep(FE, mfspec, fea);
#line 285
    free((void *)spec);
#line 286
    free((void *)mfspec);
  } else {
#line 289
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"MEL SCALE IS CURRENTLY THE ONLY IMPLEMENTATION!\n");
#line 290
    exit(0);
  }
#line 293
  return;
}
}
#line 297 "src/new_fe_sp.c"
void fe_spec_magnitude(double *data , int data_len , double *spec , int fftsize ) 
{ 
  int j ;
  int wrap ;
  complex *FFT ;
  complex *IN ;
  void *tmp ;
  void *tmp___0 ;

  {
#line 303
  tmp = calloc((size_t )fftsize, sizeof(complex ));
#line 303
  FFT = (complex *)tmp;
#line 304
  tmp___0 = calloc((size_t )fftsize, sizeof(complex ));
#line 304
  IN = (complex *)tmp___0;
#line 306
  if ((unsigned long )FFT == (unsigned long )((void *)0)) {
#line 307
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"memory alloc failed in fe_spec_magnitude()\n...exiting\n");
#line 308
    exit(0);
  } else
#line 306
  if ((unsigned long )IN == (unsigned long )((void *)0)) {
#line 307
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"memory alloc failed in fe_spec_magnitude()\n...exiting\n");
#line 308
    exit(0);
  }
#line 311
  if (data_len > fftsize) {
#line 314
    j = 0;
#line 314
    while (j < fftsize) {
#line 315
      (IN + j)->r = *(data + j);
#line 316
      (IN + j)->i = 0.0;
#line 314
      j ++;
    }
#line 318
    wrap = 0;
#line 318
    while (j < data_len) {
#line 319
      (IN + wrap)->r += *(data + j);
#line 320
      (IN + wrap)->i += 0.0;
#line 318
      wrap ++;
#line 318
      j ++;
    }
  } else {
#line 325
    j = 0;
#line 325
    while (j < data_len) {
#line 326
      (IN + j)->r = *(data + j);
#line 327
      (IN + j)->i = 0.0;
#line 325
      j ++;
    }
#line 329
    while (j < fftsize) {
#line 330
      (IN + j)->r = 0.0;
#line 331
      (IN + j)->i = 0.0;
#line 329
      j ++;
    }
  }
#line 336
  fe_fft(IN, FFT, fftsize, 1);
#line 338
  j = 0;
#line 338
  while (j <= fftsize / 2) {
#line 340
    *(spec + j) = (FFT + j)->r * (FFT + j)->r + (FFT + j)->i * (FFT + j)->i;
#line 338
    j ++;
  }
#line 343
  free((void *)FFT);
#line 344
  free((void *)IN);
#line 345
  return;
}
}
#line 348 "src/new_fe_sp.c"
void fe_mel_spec(fe_t *FE , double *spec , double *mfspec ) 
{ 
  int whichfilt ;
  int start ;
  int i ;
  float dfreq ;

  {
#line 353
  dfreq = FE->SAMPLING_RATE / (float )FE->FFT_SIZE;
#line 355
  whichfilt = 0;
#line 355
  while (whichfilt < (FE->MEL_FB)->num_filters) {
#line 356
    start = (int )(*((FE->MEL_FB)->left_apex + whichfilt) / dfreq) + 1;
#line 357
    *(mfspec + whichfilt) = (double )0;
#line 358
    i = 0;
#line 358
    while (i < *((FE->MEL_FB)->width + whichfilt)) {
#line 359
      *(mfspec + whichfilt) += (double )*(*((FE->MEL_FB)->filter_coeffs + whichfilt) + i) * *(spec + (start + i));
#line 358
      i ++;
    }
#line 355
    whichfilt ++;
  }
#line 363
  return;
}
}
#line 368 "src/new_fe_sp.c"
void fe_mel_cep(fe_t *FE , double *mfspec , double *mfcep ) 
{ 
  int i ;
  int j ;
  int period ;
  float beta ;

  {
#line 375
  period = (FE->MEL_FB)->num_filters;
#line 377
  i = 0;
#line 377
  while (i < (FE->MEL_FB)->num_filters) {
#line 379
    if (*(mfspec + i) > (double )0) {
#line 380
      *(mfspec + i) = log(*(mfspec + i));
    } else {
#line 382
      *(mfspec + i) = - 1.0e+5;
    }
#line 377
    i ++;
  }
#line 386
  i = 0;
#line 386
  while (i < FE->NUM_CEPSTRA) {
#line 387
    *(mfcep + i) = (double )0;
#line 388
    j = 0;
#line 388
    while (j < (FE->MEL_FB)->num_filters) {
#line 389
      if (j == 0) {
#line 390
        beta = (float )0.5;
      } else {
#line 392
        beta = (float )1.0;
      }
#line 393
      *(mfcep + i) += ((double )beta * *(mfspec + j)) * (double )*(*((FE->MEL_FB)->mel_cosine + i) + j);
#line 388
      j ++;
    }
#line 395
    *(mfcep + i) /= (double )((float )period);
#line 386
    i ++;
  }
#line 397
  return;
}
}
#line 402 "src/new_fe_sp.c"
static int s  ;
#line 402 "src/new_fe_sp.c"
static int k  ;
#line 402 "src/new_fe_sp.c"
static int lgN  ;
#line 409 "src/new_fe_sp.c"
static complex *w  ;
#line 409 "src/new_fe_sp.c"
static complex *from  ;
#line 409 "src/new_fe_sp.c"
static complex *to  ;
#line 409 "src/new_fe_sp.c"
static complex wwf2  ;
#line 409 "src/new_fe_sp.c"
static complex *buffer  ;
#line 409 "src/new_fe_sp.c"
static complex *exch  ;
#line 409 "src/new_fe_sp.c"
static complex *wEnd  ;
#line 415 "src/new_fe_sp.c"
static double div___0  ;
#line 415 "src/new_fe_sp.c"
static double x  ;
#line 400 "src/new_fe_sp.c"
int fe_fft(complex *in , complex *out , int N , int invert ) 
{ 
  complex *f1 ;
  complex *f2 ;
  complex *t1 ;
  complex *t2 ;
  complex *ww ;
  void *tmp ;
  void *tmp___0 ;

  {
#line 421
  k = N;
#line 421
  lgN = 0;
#line 421
  while (k > 1) {
#line 423
    if (k % 2 != 0) {
#line 425
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"fft: N must be a power of 2 (is %d)\n",
              N);
#line 426
      return (-1);
    } else
#line 423
    if (N < 0) {
#line 425
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"fft: N must be a power of 2 (is %d)\n",
              N);
#line 426
      return (-1);
    }
#line 421
    k /= 2;
#line 421
    lgN ++;
  }
#line 431
  if (invert == 1) {
#line 432
    div___0 = 1.0;
  } else
#line 433
  if (invert == -1) {
#line 434
    div___0 = (double )N;
  } else {
#line 437
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"fft: invert must be either +1 or -1 (is %d)\n",
            invert);
#line 438
    return (-1);
  }
#line 442
  tmp = calloc((size_t )N, sizeof(complex ));
#line 442
  buffer = (complex *)tmp;
#line 443
  if (lgN % 2 == 0) {
#line 445
    from = out;
#line 446
    to = buffer;
  } else {
#line 450
    to = out;
#line 451
    from = buffer;
  }
#line 455
  s = 0;
#line 455
  while (s < N) {
#line 457
    (from + s)->r = (in + s)->r / div___0;
#line 458
    (from + s)->i = (in + s)->i / div___0;
#line 455
    s ++;
  }
#line 463
  tmp___0 = calloc((size_t )(N / 2), sizeof(complex ));
#line 463
  w = (complex *)tmp___0;
#line 464
  k = 0;
#line 464
  while (k < N / 2) {
#line 466
    x = ((- 6.28318530717958647 * (double )invert) * (double )k) / (double )N;
#line 467
    (w + k)->r = cos(x);
#line 468
    (w + k)->i = sin(x);
#line 464
    k ++;
  }
#line 470
  wEnd = w + N / 2;
#line 473
  k = N / 2;
#line 473
  while (k > 0) {
#line 475
    s = 0;
#line 475
    while (s < k) {
#line 478
      f1 = from + s;
#line 478
      f2 = from + (s + k);
#line 479
      t1 = to + s;
#line 479
      t2 = to + (s + N / 2);
#line 480
      ww = w + 0;
#line 482
      while ((unsigned long )ww < (unsigned long )wEnd) {
#line 485
        wwf2.r = f2->r * ww->r - f2->i * ww->i;
#line 486
        wwf2.i = f2->r * ww->i + f2->i * ww->r;
#line 488
        t1->r = f1->r + wwf2.r;
#line 489
        t1->i = f1->i + wwf2.i;
#line 491
        t2->r = f1->r - wwf2.r;
#line 492
        t2->i = f1->i - wwf2.i;
#line 494
        f1 += 2 * k;
#line 494
        f2 += 2 * k;
#line 495
        t1 += k;
#line 495
        t2 += k;
#line 496
        ww += k;
      }
#line 475
      s ++;
    }
#line 499
    exch = from;
#line 499
    from = to;
#line 499
    to = exch;
#line 473
    k /= 2;
  }
#line 501
  free((void *)buffer);
#line 502
  free((void *)w);
#line 503
  return (0);
}
}
#line 508 "src/new_fe_sp.c"
char **fe_create_2d(int d1 , int d2 , int elem_size ) 
{ 
  char *store ;
  char **out ;
  int i ;
  int j ;
  void *tmp ;
  void *tmp___0 ;

  {
#line 513
  tmp = calloc((size_t )(d1 * d2), (size_t )elem_size);
#line 513
  store = (char *)tmp;
#line 515
  if ((unsigned long )store == (unsigned long )((void *)0)) {
#line 516
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"fe_create_2d failed\n");
#line 517
    return ((char **)((void *)0));
  }
#line 520
  tmp___0 = calloc((size_t )d1, sizeof(void *));
#line 520
  out = (char **)tmp___0;
#line 522
  if ((unsigned long )out == (unsigned long )((void *)0)) {
#line 523
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"fe_create_2d failed\n");
#line 524
    free((void *)store);
#line 525
    return ((char **)((void *)0));
  }
#line 528
  i = 0;
#line 528
  j = 0;
#line 528
  while (i < d1) {
#line 529
    *(out + i) = store + j * elem_size;
#line 528
    i ++;
#line 528
    j += d2;
  }
#line 532
  return (out);
}
}
#line 535 "src/new_fe_sp.c"
void fe_free_2d(void **arr ) 
{ 


  {
#line 537
  if ((unsigned long )arr != (unsigned long )((void *)0)) {
#line 538
    free(*(arr + 0));
#line 539
    free((void *)arr);
  }
#line 542
  return;
}
}
#line 544 "src/new_fe_sp.c"
void fe_parse_general_params(param_t *P , fe_t *FE ) 
{ 


  {
#line 547
  if (P->SAMPLING_RATE != (float )0) {
#line 548
    FE->SAMPLING_RATE = P->SAMPLING_RATE;
  } else {
#line 550
    FE->SAMPLING_RATE = (float )16000.0;
  }
#line 552
  if (P->FRAME_RATE != 0) {
#line 553
    FE->FRAME_RATE = P->FRAME_RATE;
  } else {
#line 555
    FE->FRAME_RATE = 100;
  }
#line 557
  if (P->WINDOW_LENGTH != (float )0) {
#line 558
    FE->WINDOW_LENGTH = P->WINDOW_LENGTH;
  } else {
#line 560
    FE->WINDOW_LENGTH = (float )0.025625;
  }
#line 562
  if (P->FB_TYPE != 0) {
#line 563
    FE->FB_TYPE = P->FB_TYPE;
  } else {
#line 565
    FE->FB_TYPE = 1;
  }
#line 567
  if (P->PRE_EMPHASIS_ALPHA != (float )0) {
#line 568
    FE->PRE_EMPHASIS_ALPHA = P->PRE_EMPHASIS_ALPHA;
  } else {
#line 570
    FE->PRE_EMPHASIS_ALPHA = (float )0.97;
  }
#line 572
  if (P->NUM_CEPSTRA != 0) {
#line 573
    FE->NUM_CEPSTRA = P->NUM_CEPSTRA;
  } else {
#line 575
    FE->NUM_CEPSTRA = 13;
  }
#line 577
  if (P->FFT_SIZE != 0) {
#line 578
    FE->FFT_SIZE = P->FFT_SIZE;
  } else {
#line 580
    FE->FFT_SIZE = 512;
  }
#line 582
  return;
}
}
#line 584 "src/new_fe_sp.c"
void fe_parse_melfb_params(param_t *P , melfb_t *MEL ) 
{ 


  {
#line 586
  if (P->SAMPLING_RATE != (float )0) {
#line 587
    MEL->sampling_rate = P->SAMPLING_RATE;
  } else {
#line 589
    MEL->sampling_rate = (float )16000.0;
  }
#line 591
  if (P->FFT_SIZE != 0) {
#line 592
    MEL->fft_size = P->FFT_SIZE;
  } else {
#line 594
    if (MEL->sampling_rate == (float )16000) {
#line 595
      MEL->fft_size = 512;
    }
#line 596
    if (MEL->sampling_rate == (float )8000) {
#line 597
      MEL->fft_size = 512;
    } else {
#line 599
      MEL->fft_size = 512;
    }
  }
#line 602
  if (P->NUM_CEPSTRA != 0) {
#line 603
    MEL->num_cepstra = P->NUM_CEPSTRA;
  } else {
#line 605
    MEL->num_cepstra = 13;
  }
#line 607
  if (P->NUM_FILTERS != 0) {
#line 608
    MEL->num_filters = P->NUM_FILTERS;
  } else
#line 610
  if (MEL->sampling_rate == (float )16000) {
#line 611
    MEL->num_filters = 40;
  } else
#line 612
  if (MEL->sampling_rate == (float )8000) {
#line 613
    MEL->num_filters = 31;
  } else {
#line 615
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Please define the number of MEL filters needed\n");
#line 616
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Modify include/new_fe.h and new_fe_sp.c\n");
#line 617
    fflush(stderr);
#line 617
    exit(0);
  }
#line 621
  if (P->UPPER_FILT_FREQ != (float )0) {
#line 622
    MEL->upper_filt_freq = P->UPPER_FILT_FREQ;
  } else
#line 624
  if (MEL->sampling_rate == (float )16000) {
#line 625
    MEL->upper_filt_freq = (float )6855.4976;
  } else
#line 626
  if (MEL->sampling_rate == (float )8000) {
#line 627
    MEL->upper_filt_freq = (float )3500;
  } else {
#line 629
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Please define the upper filt frequency needed\n");
#line 630
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Modify include/new_fe.h and new_fe_sp.c\n");
#line 631
    fflush(stderr);
#line 631
    exit(0);
  }
#line 636
  if (P->LOWER_FILT_FREQ != (float )0) {
#line 637
    MEL->lower_filt_freq = P->LOWER_FILT_FREQ;
  } else
#line 639
  if (MEL->sampling_rate == (float )16000) {
#line 640
    MEL->lower_filt_freq = (float )133.33334;
  } else
#line 641
  if (MEL->sampling_rate == (float )8000) {
#line 642
    MEL->lower_filt_freq = (float )200;
  } else {
#line 644
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Please define the lower filt frequency needed\n");
#line 645
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Modify include/new_fe.h and new_fe_sp.c\n");
#line 646
    fflush(stderr);
#line 646
    exit(0);
  }
#line 649
  return;
}
}
#line 651 "src/new_fe_sp.c"
void fe_print_current(fe_t *FE ) 
{ 


  {
#line 653
  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Current FE Parameters:\n");
#line 654
  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"\tSampling Rate:             %f\n",
          (double )FE->SAMPLING_RATE);
#line 655
  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"\tFrame Size:                %d\n",
          FE->FRAME_SIZE);
#line 656
  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"\tFrame Shift:               %d\n",
          FE->FRAME_SHIFT);
#line 657
  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"\tFFT Size:                  %d\n",
          FE->FFT_SIZE);
#line 658
  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"\tNumber of Overflow Samps:  %d\n",
          FE->NUM_OVERFLOW_SAMPS);
#line 659
  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"\tStart Utt Status:          %d\n",
          FE->START_FLAG);
#line 660
  return;
}
}
#line 1 "new_fe.o"
#pragma merger("0","/tmp/cil-1BoQGL_B.i","-g,-O4")
#line 150 "/usr/include/x86_64-linux-gnu/bits/mathinline.h"
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__, __always_inline__)) __signbitl)(long double __x )  __attribute__((__const__)) ;
#line 150 "/usr/include/x86_64-linux-gnu/bits/mathinline.h"
__inline extern int ( __attribute__((__leaf__, __always_inline__)) __signbitl)(long double __x ) 
{ 
  union __anonunion___u_8___0 __u ;

  {
#line 153
  __u.__l = __x;
#line 154
  return ((__u.__i[2] & 32768) != 0);
}
}
#line 192 "src/new_fe.h"
fe_t *fe_init(param_t *P ) ;
#line 193
int fe_start_utt(fe_t *FE ) ;
#line 194
int fe_end_utt(fe_t *FE , float *cepvector ) ;
#line 195
int fe_close(fe_t *FE ) ;
#line 196
int fe_process_utt(fe_t *FE , int16 *spch , int nsamps , float32 ***cep_block ) ;
#line 137 "src/new_fe.c"
fe_t *fe_init(param_t *P ) 
{ 
  fe_t *FE ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  melfb_t *tmp___2 ;
  void *tmp___3 ;

  {
#line 139
  tmp = calloc((size_t )1, sizeof(fe_t ));
#line 139
  FE = (fe_t *)tmp;
#line 141
  if ((unsigned long )FE == (unsigned long )((void *)0)) {
#line 142
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"memory alloc failed in fe_init()\n...exiting\n");
#line 143
    return ((fe_t *)((void *)0));
  }
#line 147
  fe_parse_general_params(P, FE);
#line 150
  FE->FRAME_SHIFT = (int )((double )(FE->SAMPLING_RATE / (float )FE->FRAME_RATE) + 0.5);
#line 151
  FE->FRAME_SIZE = (int )((double )(FE->WINDOW_LENGTH * FE->SAMPLING_RATE) + 0.5);
#line 152
  FE->PRIOR = (int16 )0;
#line 155
  tmp___0 = calloc((size_t )FE->FRAME_SIZE, sizeof(int16 ));
#line 155
  FE->OVERFLOW_SAMPS = (int16 *)tmp___0;
#line 156
  tmp___1 = calloc((size_t )FE->FRAME_SIZE, sizeof(double ));
#line 156
  FE->HAMMING_WINDOW = (double *)tmp___1;
#line 158
  if ((unsigned long )FE->OVERFLOW_SAMPS == (unsigned long )((void *)0)) {
#line 159
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"memory alloc failed in fe_init()\n...exiting\n");
#line 160
    return ((fe_t *)((void *)0));
  } else
#line 158
  if ((unsigned long )FE->HAMMING_WINDOW == (unsigned long )((void *)0)) {
#line 159
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"memory alloc failed in fe_init()\n...exiting\n");
#line 160
    return ((fe_t *)((void *)0));
  }
#line 164
  fe_create_hamming(FE->HAMMING_WINDOW, FE->FRAME_SIZE);
#line 167
  if (FE->FB_TYPE == 1) {
#line 168
    tmp___3 = calloc((size_t )1, sizeof(melfb_t ));
#line 168
    tmp___2 = (melfb_t *)tmp___3;
#line 168
    FE->MEL_FB = tmp___2;
#line 168
    if ((unsigned long )tmp___2 == (unsigned long )((void *)0)) {
#line 169
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"memory alloc failed in fe_init()\n...exiting\n");
#line 170
      return ((fe_t *)((void *)0));
    }
#line 173
    fe_parse_melfb_params(P, FE->MEL_FB);
#line 175
    fe_build_melfilters(FE->MEL_FB);
#line 176
    fe_compute_melcosine(FE->MEL_FB);
  } else {
#line 179
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"MEL SCALE IS CURRENTLY THE ONLY IMPLEMENTATION!\n");
#line 180
    return ((fe_t *)((void *)0));
  }
#line 182
  return (FE);
}
}
#line 193 "src/new_fe.c"
int fe_start_utt(fe_t *FE ) 
{ 


  {
#line 195
  FE->NUM_OVERFLOW_SAMPS = 0;
#line 196
  memset((void *)FE->OVERFLOW_SAMPS, 0, (unsigned long )FE->FRAME_SIZE * sizeof(int16 ));
#line 197
  FE->START_FLAG = 1;
#line 198
  FE->PRIOR = (int16 )0;
#line 199
  return (0);
}
}
#line 211 "src/new_fe.c"
int fe_process_utt(fe_t *FE , int16 *spch , int nsamps , float32 ***cep_block ) 
{ 
  int frame_start ;
  int frame_count ;
  int whichframe ;
  int i ;
  int spbuf_len ;
  int offset ;
  double *spbuf ;
  double *fr_data ;
  double *fr_fea ;
  int16 *tmp_spch ;
  float32 **cep ;
  void *tmp ;
  char **tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;

  {
#line 213
  frame_count = 0;
#line 213
  whichframe = 0;
#line 214
  offset = 0;
#line 216
  tmp_spch = spch;
#line 217
  cep = (float32 **)((void *)0);
#line 220
  if (nsamps + FE->NUM_OVERFLOW_SAMPS >= FE->FRAME_SIZE) {
#line 223
    if (FE->NUM_OVERFLOW_SAMPS > 0) {
#line 225
      tmp = malloc(sizeof(int16 ) * (unsigned long )(FE->NUM_OVERFLOW_SAMPS + nsamps));
#line 225
      tmp_spch = (int16 *)tmp;
#line 225
      if ((unsigned long )tmp_spch == (unsigned long )((void *)0)) {
#line 226
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"memory alloc failed in fe_process_utt()\n...exiting\n");
#line 227
        exit(0);
      }
#line 230
      memcpy((void * __restrict  )tmp_spch, (void const   * __restrict  )FE->OVERFLOW_SAMPS,
             (unsigned long )FE->NUM_OVERFLOW_SAMPS * sizeof(int16 ));
#line 231
      memcpy((void * __restrict  )(tmp_spch + FE->NUM_OVERFLOW_SAMPS), (void const   * __restrict  )spch,
             (unsigned long )nsamps * sizeof(int16 ));
#line 234
      nsamps += FE->NUM_OVERFLOW_SAMPS;
#line 235
      FE->NUM_OVERFLOW_SAMPS = 0;
    }
#line 238
    frame_count = 0;
#line 239
    frame_start = 0;
#line 239
    while (frame_start + FE->FRAME_SIZE <= nsamps) {
#line 240
      frame_count ++;
#line 239
      frame_start += FE->FRAME_SHIFT;
    }
#line 245
    tmp___0 = fe_create_2d(frame_count + 1, FE->NUM_CEPSTRA, (int )sizeof(float32 ));
#line 245
    cep = (float32 **)tmp___0;
#line 245
    if ((unsigned long )cep == (unsigned long )((void *)0)) {
#line 246
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"memory alloc for cep failed in fe_process_utt()\n\tfe_create_2d(%ld,%d,%d)\n...exiting\n",
              (long )(frame_count + 1), FE->NUM_CEPSTRA, sizeof(float32 ));
#line 247
      exit(0);
    }
#line 251
    spbuf_len = (frame_count - 1) * FE->FRAME_SHIFT + FE->FRAME_SIZE;
#line 253
    tmp___1 = calloc((size_t )spbuf_len, sizeof(double ));
#line 253
    spbuf = (double *)tmp___1;
#line 253
    if ((unsigned long )spbuf == (unsigned long )((void *)0)) {
#line 254
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"memory alloc failed in fe_process_utt()\n...exiting\n");
#line 255
      exit(0);
    }
#line 259
    if ((double )FE->PRE_EMPHASIS_ALPHA != 0.0) {
#line 260
      fe_pre_emphasis(tmp_spch, spbuf, spbuf_len, FE->PRE_EMPHASIS_ALPHA, FE->PRIOR);
    } else {
#line 262
      fe_short_to_double(tmp_spch, spbuf, spbuf_len);
    }
#line 266
    tmp___2 = calloc((size_t )FE->FRAME_SIZE, sizeof(double ));
#line 266
    fr_data = (double *)tmp___2;
#line 267
    tmp___3 = calloc((size_t )FE->NUM_CEPSTRA, sizeof(double ));
#line 267
    fr_fea = (double *)tmp___3;
#line 269
    if ((unsigned long )fr_data == (unsigned long )((void *)0)) {
#line 270
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"memory alloc failed in fe_process_utt()\n...exiting\n");
#line 271
      exit(0);
    } else
#line 269
    if ((unsigned long )fr_fea == (unsigned long )((void *)0)) {
#line 270
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"memory alloc failed in fe_process_utt()\n...exiting\n");
#line 271
      exit(0);
    }
#line 274
    whichframe = 0;
#line 274
    while (whichframe < frame_count) {
#line 275
      i = 0;
#line 275
      while (i < FE->FRAME_SIZE) {
#line 276
        *(fr_data + i) = *(spbuf + (whichframe * FE->FRAME_SHIFT + i));
#line 275
        i ++;
      }
#line 278
      fe_hamming_window(fr_data, FE->HAMMING_WINDOW, FE->FRAME_SIZE);
#line 280
      fe_frame_to_fea(FE, fr_data, fr_fea);
#line 282
      i = 0;
#line 282
      while (i < FE->NUM_CEPSTRA) {
#line 283
        *(*(cep + whichframe) + i) = (float32 )*(fr_fea + i);
#line 282
        i ++;
      }
#line 274
      whichframe ++;
    }
#line 289
    if (spbuf_len < nsamps) {
#line 290
      offset = frame_count * FE->FRAME_SHIFT;
#line 291
      memcpy((void * __restrict  )FE->OVERFLOW_SAMPS, (void const   * __restrict  )(tmp_spch + offset),
             (unsigned long )(nsamps - offset) * sizeof(int16 ));
#line 292
      FE->NUM_OVERFLOW_SAMPS = nsamps - offset;
#line 293
      FE->PRIOR = *(tmp_spch + (offset - 1));
#line 294
      if (! (FE->NUM_OVERFLOW_SAMPS < FE->FRAME_SIZE)) {
#line 294
        __assert_fail("FE->NUM_OVERFLOW_SAMPS<FE->FRAME_SIZE", "src/new_fe.c", 294U,
                      "fe_process_utt");
      }
    }
#line 297
    if ((unsigned long )spch != (unsigned long )tmp_spch) {
#line 298
      free((void *)tmp_spch);
    }
#line 300
    free((void *)spbuf);
#line 301
    free((void *)fr_data);
#line 302
    free((void *)fr_fea);
  } else {
#line 308
    memcpy((void * __restrict  )(FE->OVERFLOW_SAMPS + FE->NUM_OVERFLOW_SAMPS), (void const   * __restrict  )tmp_spch,
           (unsigned long )nsamps * sizeof(int16 ));
#line 309
    FE->NUM_OVERFLOW_SAMPS += nsamps;
#line 310
    if (! (FE->NUM_OVERFLOW_SAMPS < FE->FRAME_SIZE)) {
#line 310
      __assert_fail("FE->NUM_OVERFLOW_SAMPS < FE->FRAME_SIZE", "src/new_fe.c", 310U,
                    "fe_process_utt");
    }
#line 311
    frame_count = 0;
  }
#line 314
  *cep_block = cep;
#line 315
  return (frame_count);
}
}
#line 328 "src/new_fe.c"
int fe_end_utt(fe_t *FE , float *cepvector ) 
{ 
  int pad_len ;
  int frame_count ;
  int i ;
  double *spbuf ;
  double *fr_fea ;
  void *tmp ;
  void *tmp___0 ;

  {
#line 330
  pad_len = 0;
#line 330
  frame_count = 0;
#line 332
  fr_fea = (double *)((void *)0);
#line 337
  if (FE->NUM_OVERFLOW_SAMPS > 0) {
#line 338
    pad_len = FE->FRAME_SIZE - FE->NUM_OVERFLOW_SAMPS;
#line 339
    memset((void *)(FE->OVERFLOW_SAMPS + FE->NUM_OVERFLOW_SAMPS), 0, (unsigned long )pad_len * sizeof(int16 ));
#line 340
    FE->NUM_OVERFLOW_SAMPS += pad_len;
#line 341
    if (! (FE->NUM_OVERFLOW_SAMPS == FE->FRAME_SIZE)) {
#line 341
      __assert_fail("FE->NUM_OVERFLOW_SAMPS==FE->FRAME_SIZE", "src/new_fe.c", 341U,
                    "fe_end_utt");
    }
#line 343
    tmp = calloc((size_t )FE->FRAME_SIZE, sizeof(double ));
#line 343
    spbuf = (double *)tmp;
#line 343
    if ((unsigned long )spbuf == (unsigned long )((void *)0)) {
#line 344
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"memory alloc failed in fe_end_utt()\n...exiting\n");
#line 345
      exit(0);
    }
#line 348
    if ((double )FE->PRE_EMPHASIS_ALPHA != 0.0) {
#line 349
      fe_pre_emphasis(FE->OVERFLOW_SAMPS, spbuf, FE->FRAME_SIZE, FE->PRE_EMPHASIS_ALPHA,
                      FE->PRIOR);
    } else {
#line 351
      fe_short_to_double(FE->OVERFLOW_SAMPS, spbuf, FE->FRAME_SIZE);
    }
#line 356
    tmp___0 = calloc((size_t )FE->NUM_CEPSTRA, sizeof(double ));
#line 356
    fr_fea = (double *)tmp___0;
#line 356
    if ((unsigned long )fr_fea == (unsigned long )((void *)0)) {
#line 357
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"memory alloc failed in fe_end_utt()\n...exiting\n");
#line 358
      exit(0);
    }
#line 361
    fe_hamming_window(spbuf, FE->HAMMING_WINDOW, FE->FRAME_SIZE);
#line 362
    fe_frame_to_fea(FE, spbuf, fr_fea);
#line 363
    i = 0;
#line 363
    while (i < FE->NUM_CEPSTRA) {
#line 364
      *(cepvector + i) = (float32 )*(fr_fea + i);
#line 363
      i ++;
    }
#line 365
    frame_count = 1;
#line 366
    free((void *)fr_fea);
#line 367
    free((void *)spbuf);
  } else {
#line 369
    frame_count = 0;
#line 370
    cepvector = (float *)((void *)0);
  }
#line 374
  FE->NUM_OVERFLOW_SAMPS = 0;
#line 375
  FE->START_FLAG = 0;
#line 377
  return (frame_count);
}
}
#line 387 "src/new_fe.c"
int fe_close(fe_t *FE ) 
{ 


  {
#line 390
  if (FE->FB_TYPE == 1) {
#line 391
    fe_free_2d((void **)((void *)(FE->MEL_FB)->filter_coeffs));
#line 392
    fe_free_2d((void **)((void *)(FE->MEL_FB)->mel_cosine));
#line 393
    free((void *)(FE->MEL_FB)->left_apex);
#line 394
    free((void *)(FE->MEL_FB)->width);
#line 395
    free((void *)FE->MEL_FB);
  } else {
#line 397
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"MEL SCALE IS CURRENTLY THE ONLY IMPLEMENTATION!\n");
  }
#line 400
  free((void *)FE->OVERFLOW_SAMPS);
#line 401
  free((void *)FE);
#line 402
  return (0);
}
}
#line 1 "cmn.o"
#pragma merger("0","/tmp/cil-W5fXJgV1.i","-g,-O4")
#line 157 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h"
extern  __attribute__((__nothrow__)) double ( __attribute__((__leaf__)) sqrt)(double __x ) ;
#line 150 "/usr/include/x86_64-linux-gnu/bits/mathinline.h"
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__, __always_inline__)) __signbitl)(long double __x )  __attribute__((__const__)) ;
#line 150 "/usr/include/x86_64-linux-gnu/bits/mathinline.h"
__inline extern int ( __attribute__((__leaf__, __always_inline__)) __signbitl)(long double __x ) 
{ 
  union __anonunion___u_29___21 __u ;

  {
#line 153
  __u.__l = __x;
#line 154
  return ((__u.__i[2] & 32768) != 0);
}
}
#line 120 "src/cmn.h"
void cmn(float32 **mfc , int32 varnorm , int32 n_frame , int32 veclen ) ;
#line 139
void cmn_free(void) ;
#line 115 "src/cmn.c"
static float32 *cmn_mean  =    (float32 *)((void *)0);
#line 116 "src/cmn.c"
static float32 *cmn_var  =    (float32 *)((void *)0);
#line 119 "src/cmn.c"
void cmn(float32 **mfc , int32 varnorm , int32 n_frame , int32 veclen ) 
{ 
  float32 *mfcp ;
  float32 t ;
  int32 i ;
  int32 f ;
  void *tmp ;
  void *tmp___0 ;
  double tmp___1 ;

  {
#line 129
  if (n_frame <= 0) {
#line 130
    return;
  } else
#line 129
  if (veclen <= 0) {
#line 130
    return;
  }
#line 133
  if ((unsigned long )cmn_mean == (unsigned long )((void *)0)) {
#line 134
    tmp = __ckd_calloc__((size_t )veclen, sizeof(float32 ), "src/cmn.c", 134);
#line 134
    cmn_mean = (float32 *)tmp;
  }
#line 137
  i = 0;
#line 137
  while (i < veclen) {
#line 138
    *(cmn_mean + i) = (float32 )0.0;
#line 137
    i ++;
  }
#line 139
  f = 0;
#line 139
  while (f < n_frame) {
#line 140
    mfcp = *(mfc + f);
#line 141
    i = 0;
#line 141
    while (i < veclen) {
#line 142
      *(cmn_mean + i) += *(mfcp + i);
#line 141
      i ++;
    }
#line 139
    f ++;
  }
#line 144
  i = 0;
#line 144
  while (i < veclen) {
#line 145
    *(cmn_mean + i) /= (float32 )n_frame;
#line 144
    i ++;
  }
#line 147
  if (! varnorm) {
#line 149
    f = 0;
#line 149
    while (f < n_frame) {
#line 150
      mfcp = *(mfc + f);
#line 151
      i = 0;
#line 151
      while (i < veclen) {
#line 152
        *(mfcp + i) -= *(cmn_mean + i);
#line 151
        i ++;
      }
#line 149
      f ++;
    }
  } else {
#line 156
    if ((unsigned long )cmn_var == (unsigned long )((void *)0)) {
#line 157
      tmp___0 = __ckd_calloc__((size_t )veclen, sizeof(float32 ), "src/cmn.c", 157);
#line 157
      cmn_var = (float32 *)tmp___0;
    }
#line 159
    i = 0;
#line 159
    while (i < veclen) {
#line 160
      *(cmn_var + i) = (float32 )0.0;
#line 159
      i ++;
    }
#line 162
    f = 0;
#line 162
    while (f < n_frame) {
#line 163
      mfcp = *(mfc + f);
#line 165
      i = 0;
#line 165
      while (i < veclen) {
#line 166
        t = *(mfcp + i) - *(cmn_mean + i);
#line 167
        *(cmn_var + i) += t * t;
#line 165
        i ++;
      }
#line 162
      f ++;
    }
#line 170
    i = 0;
#line 170
    while (i < veclen) {
#line 171
      tmp___1 = sqrt((float64 )n_frame / (float64 )*(cmn_var + i));
#line 171
      *(cmn_var + i) = (float32 )tmp___1;
#line 170
      i ++;
    }
#line 173
    f = 0;
#line 173
    while (f < n_frame) {
#line 174
      mfcp = *(mfc + f);
#line 175
      i = 0;
#line 175
      while (i < veclen) {
#line 176
        *(mfcp + i) = (*(mfcp + i) - *(cmn_mean + i)) * *(cmn_var + i);
#line 175
        i ++;
      }
#line 173
      f ++;
    }
  }
#line 179
  return;
}
}
#line 184 "src/cmn.c"
void cmn_free(void) 
{ 


  {
#line 186
  free((void *)cmn_var);
#line 187
  free((void *)cmn_mean);
#line 188
  return;
}
}
#line 1 "cmn_prior.o"
#pragma merger("0","/tmp/cil-umJCCahD.i","-g,-O4")
#line 150 "/usr/include/x86_64-linux-gnu/bits/mathinline.h"
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__, __always_inline__)) __signbitl)(long double __x )  __attribute__((__const__)) ;
#line 150 "/usr/include/x86_64-linux-gnu/bits/mathinline.h"
__inline extern int ( __attribute__((__leaf__, __always_inline__)) __signbitl)(long double __x ) 
{ 
  union __anonunion___u_29___22 __u ;

  {
#line 153
  __u.__l = __x;
#line 154
  return ((__u.__i[2] & 32768) != 0);
}
}
#line 119 "src/cmn_prior.h"
void cmn_prior(float32 **incep , int32 varnorm , int32 nfr , int32 ceplen , int32 endutt ) ;
#line 104 "src/cmn_prior.c"
static float32 *cur_mean  =    (float32 *)((void *)0);
#line 105 "src/cmn_prior.c"
static float32 *sum  =    (float32 *)((void *)0);
#line 106 "src/cmn_prior.c"
static int32 nframe  ;
#line 107 "src/cmn_prior.c"
static int32 initialize  =    1;
#line 101 "src/cmn_prior.c"
void cmn_prior(float32 **incep , int32 varnorm , int32 nfr , int32 ceplen , int32 endutt ) 
{ 
  float32 sf ;
  int32 i ;
  int32 j ;
  void *tmp ;
  void *tmp___0 ;

  {
#line 111
  if (varnorm) {
#line 112
    _E__pr_header("src/cmn_prior.c", 112L, "FATAL_ERROR");
#line 112
    _E__die_error("Variance normalization not implemented in live mode decode\n");
  }
#line 114
  if (initialize) {
#line 115
    tmp = __ckd_calloc__((size_t )ceplen, sizeof(float32 ), "src/cmn_prior.c", 115);
#line 115
    cur_mean = (float32 *)tmp;
#line 118
    *(cur_mean + 0) = (float32 )12.0;
#line 120
    tmp___0 = __ckd_calloc__((size_t )ceplen, sizeof(float32 ), "src/cmn_prior.c",
                             120);
#line 120
    sum = (float32 *)tmp___0;
#line 121
    nframe = 0;
#line 122
    initialize = 0;
#line 123
    _E__pr_info_header("src/cmn_prior.c", 123L, "INFO");
#line 123
    _E__pr_info("mean[0]= %.2f, mean[1..%d]= 0.0\n", (double )*(cur_mean + 0), ceplen - 1);
  }
#line 126
  if (nfr <= 0) {
#line 127
    return;
  }
#line 129
  i = 0;
#line 129
  while (i < nfr) {
#line 130
    j = 0;
#line 130
    while (j < ceplen) {
#line 131
      *(sum + j) += *(*(incep + i) + j);
#line 132
      *(*(incep + i) + j) -= *(cur_mean + j);
#line 130
      j ++;
    }
#line 134
    nframe ++;
#line 129
    i ++;
  }
#line 138
  if (nframe > 800) {
#line 139
    sf = (float32 )(1.0 / (double )nframe);
#line 140
    i = 0;
#line 140
    while (i < ceplen) {
#line 141
      *(cur_mean + i) = *(sum + i) * sf;
#line 140
      i ++;
    }
#line 144
    if (nframe >= 800) {
#line 145
      sf = (float32 )500 * sf;
#line 146
      i = 0;
#line 146
      while (i < ceplen) {
#line 147
        *(sum + i) *= sf;
#line 146
        i ++;
      }
#line 148
      nframe = 500;
    }
  }
#line 152
  if (endutt) {
#line 162
    sf = (float32 )(1.0 / (double )nframe);
#line 163
    i = 0;
#line 163
    while (i < ceplen) {
#line 164
      *(cur_mean + i) = *(sum + i) * sf;
#line 163
      i ++;
    }
#line 167
    if (nframe > 800) {
#line 168
      sf = (float32 )500 * sf;
#line 169
      i = 0;
#line 169
      while (i < ceplen) {
#line 170
        *(sum + i) *= sf;
#line 169
        i ++;
      }
#line 171
      nframe = 500;
    }
  }
#line 181
  return;
}
}
#line 1 "agc.o"
#pragma merger("0","/tmp/cil-3g5BA5WD.i","-g,-O4")
#line 150 "/usr/include/x86_64-linux-gnu/bits/mathinline.h"
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__, __always_inline__)) __signbitl)(long double __x )  __attribute__((__const__)) ;
#line 150 "/usr/include/x86_64-linux-gnu/bits/mathinline.h"
__inline extern int ( __attribute__((__leaf__, __always_inline__)) __signbitl)(long double __x ) 
{ 
  union __anonunion___u_29___23 __u ;

  {
#line 153
  __u.__l = __x;
#line 154
  return ((__u.__i[2] & 32768) != 0);
}
}
#line 117 "src/agc.h"
void agc_max(float **mfc , int32 n_frame ) ;
#line 110 "src/agc.c"
void agc_max(float **mfc , int32 n_frame ) 
{ 
  float32 maxc0 ;
  int32 i ;

  {
#line 115
  if (! (n_frame > 0)) {
#line 115
    __assert_fail("n_frame > 0", "src/agc.c", 115U, "agc_max");
  }
#line 117
  maxc0 = *(*(mfc + 0) + 0);
#line 118
  i = 1;
#line 118
  while (i < n_frame) {
#line 119
    if (*(*(mfc + i) + 0) > maxc0) {
#line 120
      maxc0 = *(*(mfc + i) + 0);
    }
#line 118
    i ++;
  }
#line 123
  i = 0;
#line 123
  while (i < n_frame) {
#line 124
    *(*(mfc + i) + 0) -= maxc0;
#line 123
    i ++;
  }
#line 125
  return;
}
}
/* compiler builtin: 
   int __builtin_va_arg_pack_len(void) ;  */
#line 1 "feat.o"
#pragma merger("0","/tmp/cil-Dy2ulrre.i","-g,-O4")
#line 150 "/usr/include/x86_64-linux-gnu/bits/mathinline.h"
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__, __always_inline__)) __signbitl)(long double __x )  __attribute__((__const__)) ;
#line 150 "/usr/include/x86_64-linux-gnu/bits/mathinline.h"
__inline extern int ( __attribute__((__leaf__, __always_inline__)) __signbitl)(long double __x ) 
{ 
  union __anonunion___u_29___24 __u ;

  {
#line 153
  __u.__l = __x;
#line 154
  return ((__u.__i[2] & 32768) != 0);
}
}
#line 167 "src/feat.h"
int32 feat_readfile(feat_t *fcb , char *file , int32 sf , int32 ef , float32 ***feat___0 ,
                    int32 maxfr ) ;
#line 182
int32 feat_writefile(feat_t *fcb , char *file , float32 ***feat___0 , int32 nfr ) ;
#line 191
int32 feat_s2mfc_read(char *file , int32 sf , int32 ef , float32 **mfc , int32 maxfr ) ;
#line 218
float32 **feat_vector_alloc(feat_t *fcb ) ;
#line 248
void feat_print(feat_t *fcb , float32 ***feat___0 , int32 nfr , FILE *fp ) ;
#line 279
int32 feat_s2mfc2feat_block(feat_t *fcb , float32 **uttcep , int32 nfr , int32 beginutt ,
                            int32 endutt , float32 ***ofeat ) ;
#line 146 "/usr/include/fcntl.h"
__inline extern int ( __attribute__((__nonnull__(1), __artificial__, __always_inline__)) open)(char const   *__path ,
                                                                                               int __oflag 
                                                                                               , ...) ;
#line 170
__inline extern int ( __attribute__((__nonnull__(2), __artificial__, __always_inline__)) openat)(int __fd ,
                                                                                                 char const   *__path ,
                                                                                                 int __oflag 
                                                                                                 , ...) ;
#line 26 "/usr/include/x86_64-linux-gnu/bits/fcntl2.h"
extern int ( __attribute__((__nonnull__(1))) __open_2)(char const   *__path , int __oflag ) ;
#line 27
extern int ( __attribute__((__nonnull__(1))) __open_alias)(char const   *__path ,
                                                           int __oflag  , ...)  __asm__("open")  ;
#line 35
extern void __open_too_many_args(void)  __attribute__((__error__("open can be called either with 2 or 3 arguments, not more"))) ;
#line 40 "/usr/include/x86_64-linux-gnu/bits/fcntl2.h"
__inline extern int ( __attribute__((__nonnull__(1), __artificial__, __always_inline__)) open)(char const   *__path ,
                                                                                               int __oflag 
                                                                                               , ...) 
{ 
  int tmp ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
#line 43
  tmp = __builtin_va_arg_pack_len();
#line 43
  if (tmp > 1) {
#line 44
    __open_too_many_args();
  }
#line 56
  tmp___4 = __builtin_va_arg_pack_len();
#line 56
  if (tmp___4 < 1) {
#line 57
    tmp___3 = __open_2(__path, __oflag);
#line 57
    return (tmp___3);
  }
#line 59
  tmp___5 = __open_alias(__path, __oflag, __builtin_va_arg_pack());
#line 59
  return (tmp___5);
}
}
#line 98
extern int ( __attribute__((__nonnull__(2))) __openat_2)(int __fd , char const   *__path ,
                                                         int __oflag ) ;
#line 100
extern int ( __attribute__((__nonnull__(2))) __openat_alias)(int __fd , char const   *__path ,
                                                             int __oflag  , ...)  __asm__("openat")  ;
#line 111
extern void __openat_too_many_args(void)  __attribute__((__error__("openat can be called either with 3 or 4 arguments, not more"))) ;
#line 116 "/usr/include/x86_64-linux-gnu/bits/fcntl2.h"
__inline extern int ( __attribute__((__nonnull__(2), __artificial__, __always_inline__)) openat)(int __fd ,
                                                                                                 char const   *__path ,
                                                                                                 int __oflag 
                                                                                                 , ...) 
{ 
  int tmp ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
#line 119
  tmp = __builtin_va_arg_pack_len();
#line 119
  if (tmp > 1) {
#line 120
    __openat_too_many_args();
  }
#line 132
  tmp___4 = __builtin_va_arg_pack_len();
#line 132
  if (tmp___4 < 1) {
#line 133
    tmp___3 = __openat_2(__fd, __path, __oflag);
#line 133
    return (tmp___3);
  }
#line 135
  tmp___5 = __openat_alias(__fd, __path, __oflag, __builtin_va_arg_pack());
#line 135
  return (tmp___5);
}
}
#line 103 "/usr/include/x86_64-linux-gnu/bits/sigset.h"
__inline extern int __sigismember(__sigset_t const   *__set , int __sig ) ;
#line 104
__inline extern int __sigaddset(__sigset_t *__set , int __sig ) ;
#line 105
__inline extern int __sigdelset(__sigset_t *__set , int __sig ) ;
#line 117 "/usr/include/x86_64-linux-gnu/bits/sigset.h"
__inline extern int __sigismember(__sigset_t const   *__set , int __sig ) 
{ 
  unsigned long __mask ;
  unsigned long __word ;
  int tmp ;

  {
#line 117
  __mask = 1UL << (unsigned long )(__sig - 1) % (8UL * sizeof(unsigned long ));
#line 117
  __word = (unsigned long )(__sig - 1) / (8UL * sizeof(unsigned long ));
#line 117
  if (__set->__val[__word] & __mask) {
#line 117
    tmp = 1;
  } else {
#line 117
    tmp = 0;
  }
#line 117
  return (tmp);
}
}
#line 118 "/usr/include/x86_64-linux-gnu/bits/sigset.h"
__inline extern int __sigaddset(__sigset_t *__set , int __sig ) 
{ 
  unsigned long __mask ;
  unsigned long __word ;

  {
#line 118
  __mask = 1UL << (unsigned long )(__sig - 1) % (8UL * sizeof(unsigned long ));
#line 118
  __word = (unsigned long )(__sig - 1) / (8UL * sizeof(unsigned long ));
#line 118
  __set->__val[__word] |= __mask;
#line 118
  return (0);
}
}
#line 119 "/usr/include/x86_64-linux-gnu/bits/sigset.h"
__inline extern int __sigdelset(__sigset_t *__set , int __sig ) 
{ 
  unsigned long __mask ;
  unsigned long __word ;

  {
#line 119
  __mask = 1UL << (unsigned long )(__sig - 1) % (8UL * sizeof(unsigned long ));
#line 119
  __word = (unsigned long )(__sig - 1) / (8UL * sizeof(unsigned long ));
#line 119
  __set->__val[__word] &= ~ __mask;
#line 119
  return (0);
}
}
#line 170 "src/feat.c"
int32 feat_readfile(feat_t *fcb , char *file , int32 sf , int32 ef , float32 ***feat___0 ,
                    int32 maxfr ) 
{ 
  FILE *fp ;
  int32 i ;
  int32 l ;
  int32 k___0 ;
  int32 nfr ;
  int32 byteswap ;
  int32 chksum_present ;
  uint32 chksum ;
  char **argname ;
  char **argval___0 ;
  int32 tmp ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___1 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___8 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  size_t __s1_len___1 ;
  size_t __s2_len___1 ;
  int tmp___15 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  int32 tmp___21 ;
  int32 tmp___22 ;
  int32 tmp___23 ;
  int32 tmp___24 ;

  {
#line 178
  _E__pr_info_header("src/feat.c", 178L, "INFO");
#line 178
  _E__pr_info("Reading feature file: \'%s\'[%d..%d]\n", file, sf, ef);
#line 179
  if (! fcb) {
#line 179
    __assert_fail("fcb", "src/feat.c", 179U, "feat_readfile");
  }
#line 181
  if (ef <= sf) {
#line 182
    _E__pr_header("src/feat.c", 182L, "ERROR");
#line 182
    _E__pr_warn("%s: End frame (%d) <= Start frame (%d)\n", file, ef, sf);
#line 183
    return (-1);
  }
#line 186
  fp = fopen((char const   * __restrict  )file, (char const   * __restrict  )"rb");
#line 186
  if ((unsigned long )fp == (unsigned long )((void *)0)) {
#line 187
    _E__pr_header("src/feat.c", 187L, "ERROR");
#line 187
    _E__pr_warn("fopen(%s,rb) failed\n", file);
#line 188
    return (-1);
  }
#line 192
  tmp = bio_readhdr(fp, & argname, & argval___0, & byteswap);
#line 192
  if (tmp < 0) {
#line 193
    _E__pr_header("src/feat.c", 193L, "ERROR");
#line 193
    _E__pr_warn("bio_readhdr(%s) failed\n", file);
#line 194
    fclose(fp);
#line 195
    return (-1);
  }
#line 199
  chksum_present = 0;
#line 200
  i = 0;
#line 200
  while (*(argname + i)) {
#line 201
    if (0) {
#line 201
      __s1_len___1 = __builtin_strlen((char const   *)*(argname + i));
#line 201
      __s2_len___1 = __builtin_strlen("version");
#line 201
      if (! ((size_t )((void const   *)(*(argname + i) + 1)) - (size_t )((void const   *)*(argname + i)) == 1UL)) {
#line 201
        goto _L___4;
      } else
#line 201
      if (__s1_len___1 >= 4UL) {
        _L___4: /* CIL Label */ 
#line 201
        if (! ((size_t )((void const   *)("version" + 1)) - (size_t )((void const   *)"version") == 1UL)) {
#line 201
          tmp___20 = 1;
        } else
#line 201
        if (__s2_len___1 >= 4UL) {
#line 201
          tmp___20 = 1;
        } else {
#line 201
          tmp___20 = 0;
        }
      } else {
#line 201
        tmp___20 = 0;
      }
#line 201
      if (tmp___20) {
#line 201
        tmp___15 = __builtin_strcmp((char const   *)*(argname + i), "version");
#line 201
        tmp___19 = tmp___15;
      } else {
#line 201
        tmp___18 = __builtin_strcmp((char const   *)*(argname + i), "version");
#line 201
        tmp___19 = tmp___18;
      }
    } else {
#line 201
      tmp___18 = __builtin_strcmp((char const   *)*(argname + i), "version");
#line 201
      tmp___19 = tmp___18;
    }
#line 201
    if (tmp___19 == 0) {
#line 202
      if (0) {
#line 202
        __s1_len = __builtin_strlen((char const   *)*(argval___0 + i));
#line 202
        __s2_len = __builtin_strlen("1.0");
#line 202
        if (! ((size_t )((void const   *)(*(argval___0 + i) + 1)) - (size_t )((void const   *)*(argval___0 + i)) == 1UL)) {
#line 202
          goto _L___0;
        } else
#line 202
        if (__s1_len >= 4UL) {
          _L___0: /* CIL Label */ 
#line 202
          if (! ((size_t )((void const   *)("1.0" + 1)) - (size_t )((void const   *)"1.0") == 1UL)) {
#line 202
            tmp___6 = 1;
          } else
#line 202
          if (__s2_len >= 4UL) {
#line 202
            tmp___6 = 1;
          } else {
#line 202
            tmp___6 = 0;
          }
        } else {
#line 202
          tmp___6 = 0;
        }
#line 202
        if (tmp___6) {
#line 202
          tmp___1 = __builtin_strcmp((char const   *)*(argval___0 + i), "1.0");
#line 202
          tmp___5 = tmp___1;
        } else {
#line 202
          tmp___4 = __builtin_strcmp((char const   *)*(argval___0 + i), "1.0");
#line 202
          tmp___5 = tmp___4;
        }
      } else {
#line 202
        tmp___4 = __builtin_strcmp((char const   *)*(argval___0 + i), "1.0");
#line 202
        tmp___5 = tmp___4;
      }
#line 202
      if (tmp___5 != 0) {
#line 203
        _E__pr_header("src/feat.c", 203L, "WARNING");
#line 203
        _E__pr_warn("%s: Version mismatch: %s, expecting %s\n", file, *(argval___0 + i),
                    "1.0");
      }
    } else {
#line 205
      if (0) {
#line 205
        __s1_len___0 = __builtin_strlen((char const   *)*(argname + i));
#line 205
        __s2_len___0 = __builtin_strlen("chksum0");
#line 205
        if (! ((size_t )((void const   *)(*(argname + i) + 1)) - (size_t )((void const   *)*(argname + i)) == 1UL)) {
#line 205
          goto _L___2;
        } else
#line 205
        if (__s1_len___0 >= 4UL) {
          _L___2: /* CIL Label */ 
#line 205
          if (! ((size_t )((void const   *)("chksum0" + 1)) - (size_t )((void const   *)"chksum0") == 1UL)) {
#line 205
            tmp___13 = 1;
          } else
#line 205
          if (__s2_len___0 >= 4UL) {
#line 205
            tmp___13 = 1;
          } else {
#line 205
            tmp___13 = 0;
          }
        } else {
#line 205
          tmp___13 = 0;
        }
#line 205
        if (tmp___13) {
#line 205
          tmp___8 = __builtin_strcmp((char const   *)*(argname + i), "chksum0");
#line 205
          tmp___12 = tmp___8;
        } else {
#line 205
          tmp___11 = __builtin_strcmp((char const   *)*(argname + i), "chksum0");
#line 205
          tmp___12 = tmp___11;
        }
      } else {
#line 205
        tmp___11 = __builtin_strcmp((char const   *)*(argname + i), "chksum0");
#line 205
        tmp___12 = tmp___11;
      }
#line 205
      if (tmp___12 == 0) {
#line 206
        chksum_present = 1;
      }
    }
#line 200
    i ++;
  }
#line 210
  bio_hdrarg_free(argname, argval___0);
#line 211
  argval___0 = (char **)((void *)0);
#line 211
  argname = argval___0;
#line 213
  chksum = (uint32 )0;
#line 216
  tmp___21 = bio_fread((void *)(& nfr), (int32 )sizeof(int32 ), 1, fp, byteswap, & chksum);
#line 216
  if (tmp___21 != 1) {
#line 217
    _E__pr_header("src/feat.c", 217L, "ERROR");
#line 217
    _E__pr_warn("%s: fread(#frames) failed\n", file);
#line 218
    fclose(fp);
#line 219
    return (-1);
  }
#line 223
  tmp___22 = bio_fread((void *)(& l), (int32 )sizeof(int32 ), 1, fp, byteswap, & chksum);
#line 223
  if (tmp___22 != 1) {
#line 225
    _E__pr_header("src/feat.c", 225L, "ERROR");
#line 225
    _E__pr_warn("%s: Missing or bad #feature streams\n", file);
#line 226
    fclose(fp);
#line 227
    return (-1);
  } else
#line 223
  if (l != fcb->n_stream) {
#line 225
    _E__pr_header("src/feat.c", 225L, "ERROR");
#line 225
    _E__pr_warn("%s: Missing or bad #feature streams\n", file);
#line 226
    fclose(fp);
#line 227
    return (-1);
  }
#line 231
  k___0 = 0;
#line 232
  i = 0;
#line 232
  while (i < fcb->n_stream) {
#line 233
    tmp___23 = bio_fread((void *)(& l), (int32 )sizeof(int32 ), 1, fp, byteswap, & chksum);
#line 233
    if (tmp___23 != 1) {
#line 235
      _E__pr_header("src/feat.c", 235L, "ERROR");
#line 235
      _E__pr_warn("%s: Missing or bad feature stream size\n", file);
#line 236
      fclose(fp);
#line 237
      return (-1);
    } else
#line 233
    if (l != *(fcb->stream_len + i)) {
#line 235
      _E__pr_header("src/feat.c", 235L, "ERROR");
#line 235
      _E__pr_warn("%s: Missing or bad feature stream size\n", file);
#line 236
      fclose(fp);
#line 237
      return (-1);
    }
#line 239
    k___0 += l;
#line 232
    i ++;
  }
#line 243
  if (sf > 0) {
#line 244
    if (sf >= nfr) {
#line 245
      _E__pr_header("src/feat.c", 245L, "ERROR");
#line 245
      _E__pr_warn("%s: Start frame (%d) beyond file size (%d)\n", file, sf, nfr);
#line 246
      fclose(fp);
#line 247
      return (-1);
    }
#line 249
    nfr -= sf;
  }
#line 253
  if ((ef - sf) + 1 < nfr) {
#line 254
    nfr = (ef - sf) + 1;
  }
#line 255
  if (nfr > maxfr) {
#line 256
    _E__pr_header("src/feat.c", 256L, "ERROR");
#line 256
    _E__pr_warn("%s: Feature buffer size(%d frames) < actual #frames(%d)\n", file,
                maxfr, nfr);
#line 258
    fclose(fp);
#line 259
    return (-1);
  }
#line 263
  if (sf > 0) {
#line 264
    fseek(fp, (long )((unsigned long )(sf * k___0) * sizeof(float32 )), 1);
  }
#line 265
  tmp___24 = bio_fread((void *)*(*(feat___0 + 0) + 0), (int32 )sizeof(float32 ), nfr * k___0,
                       fp, byteswap, & chksum);
#line 265
  if (tmp___24 != nfr * k___0) {
#line 266
    _E__pr_header("src/feat.c", 266L, "ERROR");
#line 266
    _E__pr_warn("%s: fread(%dx%d) (feature data) failed\n", file, nfr, k___0);
#line 267
    fclose(fp);
#line 268
    return (-1);
  }
#line 271
  fclose(fp);
#line 273
  return (nfr);
}
}
#line 277 "src/feat.c"
int32 feat_writefile(feat_t *fcb , char *file , float32 ***feat___0 , int32 nfr ) 
{ 
  FILE *fp ;
  int32 i ;
  int32 k___0 ;
  size_t tmp ;

  {
#line 282
  _E__pr_info_header("src/feat.c", 282L, "INFO");
#line 282
  _E__pr_info("Writing feature file: \'%s\'\n", file);
#line 283
  if (! fcb) {
#line 283
    __assert_fail("fcb", "src/feat.c", 283U, "feat_writefile");
  }
#line 285
  fp = fopen((char const   * __restrict  )file, (char const   * __restrict  )"wb");
#line 285
  if ((unsigned long )fp == (unsigned long )((void *)0)) {
#line 286
    _E__pr_header("src/feat.c", 286L, "ERROR");
#line 286
    _E__pr_warn("fopen(%s,wb) failed\n", file);
#line 287
    return (-1);
  }
#line 291
  bio_writehdr_version(fp, (char *)"1.0");
#line 293
  fwrite((void const   * __restrict  )(& nfr), sizeof(int32 ), (size_t )1, (FILE * __restrict  )fp);
#line 294
  fwrite((void const   * __restrict  )(& fcb->n_stream), sizeof(int32 ), (size_t )1,
         (FILE * __restrict  )fp);
#line 295
  k___0 = 0;
#line 296
  i = 0;
#line 296
  while (i < fcb->n_stream) {
#line 297
    fwrite((void const   * __restrict  )(fcb->stream_len + i), sizeof(int32 ), (size_t )1,
           (FILE * __restrict  )fp);
#line 298
    k___0 += *(fcb->stream_len + i);
#line 296
    i ++;
  }
#line 302
  tmp = fwrite((void const   * __restrict  )*(*(feat___0 + 0) + 0), sizeof(float32 ),
               (size_t )(nfr * k___0), (FILE * __restrict  )fp);
#line 302
  if ((int32 )tmp != nfr * k___0) {
#line 303
    _E__pr_header("src/feat.c", 303L, "ERROR");
#line 303
    _E__pr_warn("%s: fwrite(%dx%d feature data) failed\n", file, nfr, k___0);
#line 304
    fclose(fp);
#line 305
    return (-1);
  }
#line 308
  fclose(fp);
#line 310
  return (0);
}
}
#line 318 "src/feat.c"
int32 feat_s2mfc_read(char *file , int32 sf , int32 ef , float32 **mfc , int32 maxfr ) 
{ 
  FILE *fp ;
  int32 n_float32 ;
  struct stat statbuf ;
  int32 i ;
  int32 n ;
  int32 byterev ;
  int32 cepsize ;
  int32 tmp ;
  int32 tmp___0 ;
  int32 tmp___1 ;

  {
#line 325
  if (ef < 0) {
#line 326
    ef = 2147418112;
  }
#line 328
  _E__pr_info_header("src/feat.c", 328L, "INFO");
#line 328
  _E__pr_info("Reading mfc file: \'%s\'[%d..%d]\n", file, sf, ef);
#line 329
  if (ef <= sf) {
#line 330
    _E__pr_header("src/feat.c", 330L, "ERROR");
#line 330
    _E__pr_warn("%s: End frame (%d) <= Start frame (%d)\n", file, ef, sf);
#line 331
    return (-1);
  }
#line 334
  cepsize = 13;
#line 337
  tmp = stat_retry(file, & statbuf);
#line 337
  if (tmp < 0) {
#line 338
    _E__pr_header("src/feat.c", 338L, "ERROR");
#line 338
    _E__pr_warn("stat_retry/fopen(%s) failed\n", file);
#line 339
    return (-1);
  } else {
#line 337
    fp = fopen((char const   * __restrict  )file, (char const   * __restrict  )"rb");
#line 337
    if ((unsigned long )fp == (unsigned long )((void *)0)) {
#line 338
      _E__pr_header("src/feat.c", 338L, "ERROR");
#line 338
      _E__pr_warn("stat_retry/fopen(%s) failed\n", file);
#line 339
      return (-1);
    }
  }
#line 343
  tmp___0 = fread_retry((void *)(& n_float32), (int32 )sizeof(int32 ), 1, fp);
#line 343
  if (tmp___0 != 1) {
#line 344
    _E__pr_header("src/feat.c", 344L, "ERROR");
#line 344
    _E__pr_warn("%s: fread(#floats) failed\n", file);
#line 345
    fclose(fp);
#line 346
    return (-1);
  }
#line 350
  byterev = 0;
#line 351
  if ((int32 )((unsigned long )n_float32 * sizeof(float32 ) + 4UL) != (int32 )statbuf.st_size) {
#line 352
    n = n_float32;
#line 353
    n = (int32 )((unsigned int )(((255 & (n >> 24)) | (65280 & (n >> 8))) | (16711680 & (n << 8))) | (4278190080U & (unsigned int )(n << 24)));
#line 355
    if ((int32 )((unsigned long )n * sizeof(float32 ) + 4UL) != (int32 )statbuf.st_size) {
#line 356
      _E__pr_header("src/feat.c", 356L, "ERROR");
#line 356
      _E__pr_warn("%s: Header size field: %d(%08x); filesize: %d(%08x)\n", file, n_float32,
                  n_float32, statbuf.st_size, statbuf.st_size);
#line 358
      fclose(fp);
#line 359
      return (-1);
    }
#line 362
    n_float32 = n;
#line 363
    byterev = 1;
  }
#line 365
  if (n_float32 <= 0) {
#line 366
    _E__pr_header("src/feat.c", 366L, "ERROR");
#line 366
    _E__pr_warn("%s: Header size field (#floats) = %d\n", file, n_float32);
#line 367
    fclose(fp);
#line 368
    return (-1);
  }
#line 372
  n = n_float32 / cepsize;
#line 373
  if (n * cepsize != n_float32) {
#line 374
    _E__pr_header("src/feat.c", 374L, "ERROR");
#line 374
    _E__pr_warn("Header size field: %d; not multiple of %d\n", n_float32, cepsize);
#line 375
    fclose(fp);
#line 376
    return (-1);
  }
#line 380
  if (sf > 0) {
#line 381
    if (sf >= n) {
#line 382
      _E__pr_header("src/feat.c", 382L, "ERROR");
#line 382
      _E__pr_warn("%s: Start frame (%d) beyond file size (%d)\n", file, sf, n);
#line 383
      fclose(fp);
#line 384
      return (-1);
    }
#line 386
    n -= sf;
  }
#line 390
  if ((ef - sf) + 1 < n) {
#line 391
    n = (ef - sf) + 1;
  }
#line 392
  if (n > maxfr) {
#line 393
    _E__pr_header("src/feat.c", 393L, "ERROR");
#line 393
    _E__pr_warn("%s: MFC buffer size(%d frames) < actual #frames(%d)\n", file, maxfr,
                n);
#line 394
    fclose(fp);
#line 395
    return (-1);
  }
#line 399
  if (sf > 0) {
#line 400
    fseek(fp, (long )((unsigned long )(sf * cepsize) * sizeof(float32 )), 1);
  }
#line 401
  n_float32 = n * cepsize;
#line 402
  tmp___1 = fread_retry((void *)*(mfc + 0), (int32 )sizeof(float32 ), n_float32, fp);
#line 402
  if (tmp___1 != n_float32) {
#line 403
    _E__pr_header("src/feat.c", 403L, "ERROR");
#line 403
    _E__pr_warn("%s: fread(%dx%d) (MFC data) failed\n", file, n, cepsize);
#line 404
    fclose(fp);
#line 405
    return (-1);
  }
#line 407
  if (byterev) {
#line 408
    i = 0;
#line 408
    while (i < n_float32) {
#line 409
      *((int32 *)(*(mfc + 0) + i)) = (int32 )((unsigned int )(((255 & (*((int32 *)(*(mfc + 0) + i)) >> 24)) | (65280 & (*((int32 *)(*(mfc + 0) + i)) >> 8))) | (16711680 & (*((int32 *)(*(mfc + 0) + i)) << 8))) | (4278190080U & (unsigned int )(*((int32 *)(*(mfc + 0) + i)) << 24)));
#line 408
      i ++;
    }
  }
#line 412
  fclose(fp);
#line 414
  return (n);
}
}
#line 418 "src/feat.c"
static int32 feat_stream_len_sum(feat_t *fcb ) 
{ 
  int32 i ;
  int32 k___0 ;

  {
#line 422
  k___0 = 0;
#line 423
  i = 0;
#line 423
  while (i < fcb->n_stream) {
#line 424
    k___0 += *(fcb->stream_len + i);
#line 423
    i ++;
  }
#line 425
  return (k___0);
}
}
#line 429 "src/feat.c"
float32 **feat_vector_alloc(feat_t *fcb ) 
{ 
  int32 i ;
  int32 k___0 ;
  float32 *data ;
  float32 **feat___0 ;
  void *tmp ;
  void *tmp___0 ;

  {
#line 434
  if (! fcb) {
#line 434
    __assert_fail("fcb", "src/feat.c", 434U, "feat_vector_alloc");
  }
#line 436
  k___0 = feat_stream_len_sum(fcb);
#line 436
  if (k___0 <= 0) {
#line 437
    _E__pr_header("src/feat.c", 437L, "ERROR");
#line 437
    _E__pr_warn("Sum(feature stream lengths) = %d\n", k___0);
#line 438
    return ((float32 **)((void *)0));
  }
#line 442
  tmp = __ckd_calloc__((size_t )fcb->n_stream, sizeof(float32 *), "src/feat.c", 442);
#line 442
  feat___0 = (float32 **)tmp;
#line 443
  tmp___0 = __ckd_calloc__((size_t )k___0, sizeof(float32 ), "src/feat.c", 443);
#line 443
  data = (float32 *)tmp___0;
#line 445
  i = 0;
#line 445
  while (i < fcb->n_stream) {
#line 446
    *(feat___0 + i) = data;
#line 447
    data += *(fcb->stream_len + i);
#line 445
    i ++;
  }
#line 450
  return (feat___0);
}
}
#line 454 "src/feat.c"
float32 ***feat_array_alloc(feat_t *fcb , int32 nfr ) 
{ 
  int32 i ;
  int32 j ;
  int32 k___0 ;
  float32 *data ;
  float32 ***feat___0 ;
  void **tmp ;
  void *tmp___0 ;

  {
#line 459
  if (! fcb) {
#line 459
    __assert_fail("fcb", "src/feat.c", 459U, "feat_array_alloc");
  }
#line 460
  if (! (nfr > 0)) {
#line 460
    __assert_fail("nfr > 0", "src/feat.c", 460U, "feat_array_alloc");
  }
#line 462
  k___0 = feat_stream_len_sum(fcb);
#line 462
  if (k___0 <= 0) {
#line 463
    _E__pr_header("src/feat.c", 463L, "ERROR");
#line 463
    _E__pr_warn("Sum(feature stream lengths) = %d\n", k___0);
#line 464
    return ((float32 ***)((void *)0));
  }
#line 468
  tmp = __ckd_calloc_2d__(nfr, fcb->n_stream, (int32 )sizeof(float32 *), "src/feat.c",
                          468);
#line 468
  feat___0 = (float32 ***)tmp;
#line 469
  tmp___0 = __ckd_calloc__((size_t )(nfr * k___0), sizeof(float32 ), "src/feat.c",
                           469);
#line 469
  data = (float32 *)tmp___0;
#line 471
  i = 0;
#line 471
  while (i < nfr) {
#line 472
    j = 0;
#line 472
    while (j < fcb->n_stream) {
#line 473
      *(*(feat___0 + i) + j) = data;
#line 474
      data += *(fcb->stream_len + j);
#line 472
      j ++;
    }
#line 471
    i ++;
  }
#line 478
  return (feat___0);
}
}
#line 482 "src/feat.c"
static void feat_s2_4x_cep2feat(feat_t *fcb , float32 **mfc , float32 **feat___0 ) 
{ 
  float32 *f ;
  float32 *w___0 ;
  float32 *_w ;
  float32 *w1 ;
  float32 *w_1 ;
  float32 *_w1 ;
  float32 *_w_1 ;
  float32 d1 ;
  float32 d2 ;
  int32 i ;
  int32 j ;

  {
#line 490
  if (! fcb) {
#line 490
    __assert_fail("fcb", "src/feat.c", 490U, "feat_s2_4x_cep2feat");
  }
#line 491
  if (! (fcb->cepsize == 13)) {
#line 491
    __assert_fail("((fcb)->cepsize) == 13", "src/feat.c", 491U, "feat_s2_4x_cep2feat");
  }
#line 492
  if (! (fcb->cepsize_used == 13)) {
#line 492
    __assert_fail("((fcb)->cepsize_used) == 13", "src/feat.c", 492U, "feat_s2_4x_cep2feat");
  }
#line 493
  if (! (fcb->n_stream == 4)) {
#line 493
    __assert_fail("((fcb)->n_stream) == 4", "src/feat.c", 493U, "feat_s2_4x_cep2feat");
  }
#line 494
  if (! (*(fcb->stream_len + 0) == 12)) {
#line 494
    __assert_fail("((fcb)->stream_len[0]) == 12", "src/feat.c", 494U, "feat_s2_4x_cep2feat");
  }
#line 495
  if (! (*(fcb->stream_len + 1) == 24)) {
#line 495
    __assert_fail("((fcb)->stream_len[1]) == 24", "src/feat.c", 495U, "feat_s2_4x_cep2feat");
  }
#line 496
  if (! (*(fcb->stream_len + 2) == 3)) {
#line 496
    __assert_fail("((fcb)->stream_len[2]) == 3", "src/feat.c", 496U, "feat_s2_4x_cep2feat");
  }
#line 497
  if (! (*(fcb->stream_len + 3) == 12)) {
#line 497
    __assert_fail("((fcb)->stream_len[3]) == 12", "src/feat.c", 497U, "feat_s2_4x_cep2feat");
  }
#line 498
  if (! (fcb->window_size == 4)) {
#line 498
    __assert_fail("((fcb)->window_size) == 4", "src/feat.c", 498U, "feat_s2_4x_cep2feat");
  }
#line 501
  memcpy((void * __restrict  )*(feat___0 + 0), (void const   * __restrict  )(*(mfc + 0) + 1),
         (unsigned long )(fcb->cepsize - 1) * sizeof(float32 ));
#line 507
  w___0 = *(mfc + 2) + 1;
#line 508
  _w = *(mfc + -2) + 1;
#line 510
  f = *(feat___0 + 1);
#line 511
  i = 0;
#line 511
  while (i < fcb->cepsize - 1) {
#line 512
    *(f + i) = *(w___0 + i) - *(_w + i);
#line 511
    i ++;
  }
#line 514
  w___0 = *(mfc + 4) + 1;
#line 515
  _w = *(mfc + -4) + 1;
#line 517
  j = 0;
#line 517
  while (j < fcb->cepsize - 1) {
#line 518
    *(f + i) = *(w___0 + j) - *(_w + j);
#line 517
    i ++;
#line 517
    j ++;
  }
#line 521
  w1 = *(mfc + 3) + 1;
#line 522
  _w1 = *(mfc + -1) + 1;
#line 523
  w_1 = *(mfc + 1) + 1;
#line 524
  _w_1 = *(mfc + -3) + 1;
#line 526
  f = *(feat___0 + 3);
#line 527
  i = 0;
#line 527
  while (i < fcb->cepsize - 1) {
#line 528
    d1 = *(w1 + i) - *(_w1 + i);
#line 529
    d2 = *(w_1 + i) - *(_w_1 + i);
#line 531
    *(f + i) = d1 - d2;
#line 527
    i ++;
  }
#line 535
  f = *(feat___0 + 2);
#line 536
  *(f + 0) = *(*(mfc + 0) + 0);
#line 537
  *(f + 1) = *(*(mfc + 2) + 0) - *(*(mfc + -2) + 0);
#line 539
  d1 = *(*(mfc + 3) + 0) - *(*(mfc + -1) + 0);
#line 540
  d2 = *(*(mfc + 1) + 0) - *(*(mfc + -3) + 0);
#line 541
  *(f + 2) = d1 - d2;
#line 542
  return;
}
}
#line 545 "src/feat.c"
static void feat_s3_1x39_cep2feat(feat_t *fcb , float32 **mfc , float32 **feat___0 ) 
{ 
  float32 *f ;
  float32 *w___0 ;
  float32 *_w ;
  float32 *w1 ;
  float32 *w_1 ;
  float32 *_w1 ;
  float32 *_w_1 ;
  float32 d1 ;
  float32 d2 ;
  int32 i ;

  {
#line 553
  if (! fcb) {
#line 553
    __assert_fail("fcb", "src/feat.c", 553U, "feat_s3_1x39_cep2feat");
  }
#line 554
  if (! (fcb->cepsize == 13)) {
#line 554
    __assert_fail("((fcb)->cepsize) == 13", "src/feat.c", 554U, "feat_s3_1x39_cep2feat");
  }
#line 555
  if (! (fcb->cepsize_used == 13)) {
#line 555
    __assert_fail("((fcb)->cepsize_used) == 13", "src/feat.c", 555U, "feat_s3_1x39_cep2feat");
  }
#line 556
  if (! (fcb->n_stream == 1)) {
#line 556
    __assert_fail("((fcb)->n_stream) == 1", "src/feat.c", 556U, "feat_s3_1x39_cep2feat");
  }
#line 557
  if (! (*(fcb->stream_len + 0) == 39)) {
#line 557
    __assert_fail("((fcb)->stream_len[0]) == 39", "src/feat.c", 557U, "feat_s3_1x39_cep2feat");
  }
#line 558
  if (! (fcb->window_size == 3)) {
#line 558
    __assert_fail("((fcb)->window_size) == 3", "src/feat.c", 558U, "feat_s3_1x39_cep2feat");
  }
#line 561
  memcpy((void * __restrict  )*(feat___0 + 0), (void const   * __restrict  )(*(mfc + 0) + 1),
         (unsigned long )(fcb->cepsize - 1) * sizeof(float32 ));
#line 566
  f = (*(feat___0 + 0) + fcb->cepsize) - 1;
#line 567
  w___0 = *(mfc + 2) + 1;
#line 568
  _w = *(mfc + -2) + 1;
#line 570
  i = 0;
#line 570
  while (i < fcb->cepsize - 1) {
#line 571
    *(f + i) = *(w___0 + i) - *(_w + i);
#line 570
    i ++;
  }
#line 574
  f += fcb->cepsize - 1;
#line 576
  *(f + 0) = *(*(mfc + 0) + 0);
#line 577
  *(f + 1) = *(*(mfc + 2) + 0) - *(*(mfc + -2) + 0);
#line 579
  d1 = *(*(mfc + 3) + 0) - *(*(mfc + -1) + 0);
#line 580
  d2 = *(*(mfc + 1) + 0) - *(*(mfc + -3) + 0);
#line 581
  *(f + 2) = d1 - d2;
#line 584
  f += 3;
#line 586
  w1 = *(mfc + 3) + 1;
#line 587
  _w1 = *(mfc + -1) + 1;
#line 588
  w_1 = *(mfc + 1) + 1;
#line 589
  _w_1 = *(mfc + -3) + 1;
#line 591
  i = 0;
#line 591
  while (i < fcb->cepsize - 1) {
#line 592
    d1 = *(w1 + i) - *(_w1 + i);
#line 593
    d2 = *(w_1 + i) - *(_w_1 + i);
#line 595
    *(f + i) = d1 - d2;
#line 591
    i ++;
  }
#line 597
  return;
}
}
#line 600 "src/feat.c"
static void feat_s3_cep(feat_t *fcb , float32 **mfc , float32 **feat___0 ) 
{ 


  {
#line 602
  if (! fcb) {
#line 602
    __assert_fail("fcb", "src/feat.c", 602U, "feat_s3_cep");
  }
#line 603
  if (! (fcb->cepsize == 13)) {
#line 603
    __assert_fail("((fcb)->cepsize) == 13", "src/feat.c", 603U, "feat_s3_cep");
  }
#line 604
  if (fcb->cepsize_used <= 13) {
#line 604
    if (! (fcb->cepsize_used > 0)) {
#line 604
      __assert_fail("(((fcb)->cepsize_used) <= 13) && (((fcb)->cepsize_used) > 0)",
                    "src/feat.c", 604U, "feat_s3_cep");
    }
  } else {
#line 604
    __assert_fail("(((fcb)->cepsize_used) <= 13) && (((fcb)->cepsize_used) > 0)",
                  "src/feat.c", 604U, "feat_s3_cep");
  }
#line 605
  if (! (fcb->n_stream == 1)) {
#line 605
    __assert_fail("((fcb)->n_stream) == 1", "src/feat.c", 605U, "feat_s3_cep");
  }
#line 606
  if (! (*(fcb->stream_len + 0) == fcb->cepsize_used)) {
#line 606
    __assert_fail("((fcb)->stream_len[0]) == ((fcb)->cepsize_used)", "src/feat.c",
                  606U, "feat_s3_cep");
  }
#line 607
  if (! (fcb->window_size == 0)) {
#line 607
    __assert_fail("((fcb)->window_size) == 0", "src/feat.c", 607U, "feat_s3_cep");
  }
#line 610
  memcpy((void * __restrict  )*(feat___0 + 0), (void const   * __restrict  )*(mfc + 0),
         (unsigned long )fcb->cepsize_used * sizeof(float32 ));
#line 611
  return;
}
}
#line 614 "src/feat.c"
static void feat_s3_cep_dcep(feat_t *fcb , float32 **mfc , float32 **feat___0 ) 
{ 
  float32 *f ;
  float32 *w___0 ;
  float32 *_w ;
  int32 i ;

  {
#line 620
  if (! fcb) {
#line 620
    __assert_fail("fcb", "src/feat.c", 620U, "feat_s3_cep_dcep");
  }
#line 621
  if (! (fcb->cepsize == 13)) {
#line 621
    __assert_fail("((fcb)->cepsize) == 13", "src/feat.c", 621U, "feat_s3_cep_dcep");
  }
#line 622
  if (fcb->cepsize_used <= 13) {
#line 622
    if (! (fcb->cepsize_used > 0)) {
#line 622
      __assert_fail("(((fcb)->cepsize_used) <= 13) && (((fcb)->cepsize_used) > 0)",
                    "src/feat.c", 622U, "feat_s3_cep_dcep");
    }
  } else {
#line 622
    __assert_fail("(((fcb)->cepsize_used) <= 13) && (((fcb)->cepsize_used) > 0)",
                  "src/feat.c", 622U, "feat_s3_cep_dcep");
  }
#line 623
  if (! (fcb->n_stream == 1)) {
#line 623
    __assert_fail("((fcb)->n_stream) == 1", "src/feat.c", 623U, "feat_s3_cep_dcep");
  }
#line 624
  if (! (*(fcb->stream_len + 0) == fcb->cepsize_used * 2)) {
#line 624
    __assert_fail("((fcb)->stream_len[0]) == (((fcb)->cepsize_used) * 2)", "src/feat.c",
                  624U, "feat_s3_cep_dcep");
  }
#line 625
  if (! (fcb->window_size == 2)) {
#line 625
    __assert_fail("((fcb)->window_size) == 2", "src/feat.c", 625U, "feat_s3_cep_dcep");
  }
#line 628
  memcpy((void * __restrict  )*(feat___0 + 0), (void const   * __restrict  )*(mfc + 0),
         (unsigned long )fcb->cepsize_used * sizeof(float32 ));
#line 633
  f = *(feat___0 + 0) + fcb->cepsize_used;
#line 634
  w___0 = *(mfc + 2);
#line 635
  _w = *(mfc + -2);
#line 637
  i = 0;
#line 637
  while (i < fcb->cepsize_used) {
#line 638
    *(f + i) = *(w___0 + i) - *(_w + i);
#line 637
    i ++;
  }
#line 639
  return;
}
}
#line 641 "src/feat.c"
void feat_1s_c_d_dd_cep2feat(feat_t *fcb , float32 **mfc , float32 **feat___0 ) 
{ 
  float32 *f ;
  float32 *w___0 ;
  float32 *_w ;
  float32 *w1 ;
  float32 *w_1 ;
  float32 *_w1 ;
  float32 *_w_1 ;
  float32 d1 ;
  float32 d2 ;
  int32 i ;

  {
#line 649
  if (! fcb) {
#line 649
    __assert_fail("fcb", "src/feat.c", 649U, "feat_1s_c_d_dd_cep2feat");
  }
#line 650
  if (! (fcb->cepsize == 13)) {
#line 650
    __assert_fail("((fcb)->cepsize) == 13", "src/feat.c", 650U, "feat_1s_c_d_dd_cep2feat");
  }
#line 651
  if (! (fcb->cepsize_used == 13)) {
#line 651
    __assert_fail("((fcb)->cepsize_used) == 13", "src/feat.c", 651U, "feat_1s_c_d_dd_cep2feat");
  }
#line 652
  if (! (fcb->n_stream == 1)) {
#line 652
    __assert_fail("((fcb)->n_stream) == 1", "src/feat.c", 652U, "feat_1s_c_d_dd_cep2feat");
  }
#line 653
  if (! (*(fcb->stream_len + 0) == 39)) {
#line 653
    __assert_fail("((fcb)->stream_len[0]) == 39", "src/feat.c", 653U, "feat_1s_c_d_dd_cep2feat");
  }
#line 654
  if (! (fcb->window_size == 3)) {
#line 654
    __assert_fail("((fcb)->window_size) == 3", "src/feat.c", 654U, "feat_1s_c_d_dd_cep2feat");
  }
#line 657
  memcpy((void * __restrict  )*(feat___0 + 0), (void const   * __restrict  )*(mfc + 0),
         (unsigned long )fcb->cepsize * sizeof(float32 ));
#line 662
  f = *(feat___0 + 0) + fcb->cepsize;
#line 663
  w___0 = *(mfc + 2);
#line 664
  _w = *(mfc + -2);
#line 666
  i = 0;
#line 666
  while (i < fcb->cepsize) {
#line 667
    *(f + i) = *(w___0 + i) - *(_w + i);
#line 666
    i ++;
  }
#line 673
  f += fcb->cepsize;
#line 675
  w1 = *(mfc + 3);
#line 676
  _w1 = *(mfc + -1);
#line 677
  w_1 = *(mfc + 1);
#line 678
  _w_1 = *(mfc + -3);
#line 680
  i = 0;
#line 680
  while (i < fcb->cepsize) {
#line 681
    d1 = *(w1 + i) - *(_w1 + i);
#line 682
    d2 = *(w_1 + i) - *(_w_1 + i);
#line 684
    *(f + i) = d1 - d2;
#line 680
    i ++;
  }
#line 686
  return;
}
}
#line 688 "src/feat.c"
feat_t *feat_init(char *type , char *cmn___0 , char *varnorm , char *agc ) 
{ 
  feat_t *fcb ;
  int32 i ;
  int32 l ;
  int32 k___0 ;
  char wd[16384] ;
  char *strp ;
  void *tmp ;
  char *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  int tmp___4 ;
  void *tmp___5 ;
  int tmp___6 ;
  void *tmp___7 ;
  size_t tmp___8 ;
  void *tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___15 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___28 ;
  int tmp___31 ;
  int tmp___32 ;
  int tmp___33 ;
  int tmp___34 ;
  int tmp___35 ;
  size_t __s1_len___1 ;
  size_t __s2_len___1 ;
  int tmp___39 ;
  int tmp___42 ;
  int tmp___43 ;
  int tmp___44 ;
  size_t __s1_len___2 ;
  size_t __s2_len___2 ;
  int tmp___46 ;
  int tmp___49 ;
  int tmp___50 ;
  int tmp___51 ;
  size_t __s1_len___3 ;
  size_t __s2_len___3 ;
  int tmp___53 ;
  int tmp___56 ;
  int tmp___57 ;
  int tmp___58 ;
  size_t __s1_len___4 ;
  size_t __s2_len___4 ;
  int tmp___60 ;
  int tmp___63 ;
  int tmp___64 ;
  int tmp___65 ;
  size_t __s1_len___5 ;
  size_t __s2_len___5 ;
  int tmp___67 ;
  int tmp___70 ;
  int tmp___71 ;
  int tmp___72 ;
  size_t __s1_len___6 ;
  size_t __s2_len___6 ;
  int tmp___74 ;
  int tmp___77 ;
  int tmp___78 ;
  int tmp___79 ;
  size_t __s1_len___7 ;
  size_t __s2_len___7 ;
  int tmp___81 ;
  int tmp___84 ;
  int tmp___85 ;
  int tmp___86 ;
  size_t __s1_len___8 ;
  size_t __s2_len___8 ;
  int tmp___88 ;
  int tmp___91 ;
  int tmp___92 ;
  int tmp___93 ;
  size_t __s1_len___9 ;
  size_t __s2_len___9 ;
  int tmp___95 ;
  int tmp___98 ;
  int tmp___99 ;
  int tmp___100 ;

  {
#line 694
  _E__pr_info_header("src/feat.c", 694L, "INFO");
#line 694
  _E__pr_info("Initializing feature stream to type: \'%s\', CMN=\'%s\', VARNORM=\'%s\', AGC=\'%s\'\n",
              type, cmn___0, varnorm, agc);
#line 697
  tmp = __ckd_calloc__((size_t )1, sizeof(feat_t ), "src/feat.c", 697);
#line 697
  fcb = (feat_t *)tmp;
#line 699
  tmp___0 = __ckd_salloc__((char const   *)type, "src/feat.c", 699);
#line 699
  fcb->name = tmp___0;
#line 700
  if (0) {
#line 700
    __s1_len___3 = __builtin_strlen((char const   *)type);
#line 700
    __s2_len___3 = __builtin_strlen("s2_4x");
#line 700
    if (! ((size_t )((void const   *)(type + 1)) - (size_t )((void const   *)type) == 1UL)) {
#line 700
      goto _L___8;
    } else
#line 700
    if (__s1_len___3 >= 4UL) {
      _L___8: /* CIL Label */ 
#line 700
      if (! ((size_t )((void const   *)("s2_4x" + 1)) - (size_t )((void const   *)"s2_4x") == 1UL)) {
#line 700
        tmp___58 = 1;
      } else
#line 700
      if (__s2_len___3 >= 4UL) {
#line 700
        tmp___58 = 1;
      } else {
#line 700
        tmp___58 = 0;
      }
    } else {
#line 700
      tmp___58 = 0;
    }
#line 700
    if (tmp___58) {
#line 700
      tmp___53 = __builtin_strcmp((char const   *)type, "s2_4x");
#line 700
      tmp___57 = tmp___53;
    } else {
#line 700
      tmp___56 = __builtin_strcmp((char const   *)type, "s2_4x");
#line 700
      tmp___57 = tmp___56;
    }
  } else {
#line 700
    tmp___56 = __builtin_strcmp((char const   *)type, "s2_4x");
#line 700
    tmp___57 = tmp___56;
  }
#line 700
  if (tmp___57 == 0) {
#line 702
    fcb->cepsize = 13;
#line 703
    fcb->cepsize_used = 13;
#line 704
    fcb->n_stream = 4;
#line 705
    tmp___1 = __ckd_calloc__((size_t )4, sizeof(int32 ), "src/feat.c", 705);
#line 705
    fcb->stream_len = (int32 *)tmp___1;
#line 706
    *(fcb->stream_len + 0) = 12;
#line 707
    *(fcb->stream_len + 1) = 24;
#line 708
    *(fcb->stream_len + 2) = 3;
#line 709
    *(fcb->stream_len + 3) = 12;
#line 710
    fcb->window_size = 4;
#line 711
    fcb->compute_feat = & feat_s2_4x_cep2feat;
  } else {
#line 712
    if (0) {
#line 712
      __s1_len___2 = __builtin_strlen((char const   *)type);
#line 712
      __s2_len___2 = __builtin_strlen("s3_1x39");
#line 712
      if (! ((size_t )((void const   *)(type + 1)) - (size_t )((void const   *)type) == 1UL)) {
#line 712
        goto _L___6;
      } else
#line 712
      if (__s1_len___2 >= 4UL) {
        _L___6: /* CIL Label */ 
#line 712
        if (! ((size_t )((void const   *)("s3_1x39" + 1)) - (size_t )((void const   *)"s3_1x39") == 1UL)) {
#line 712
          tmp___51 = 1;
        } else
#line 712
        if (__s2_len___2 >= 4UL) {
#line 712
          tmp___51 = 1;
        } else {
#line 712
          tmp___51 = 0;
        }
      } else {
#line 712
        tmp___51 = 0;
      }
#line 712
      if (tmp___51) {
#line 712
        tmp___46 = __builtin_strcmp((char const   *)type, "s3_1x39");
#line 712
        tmp___50 = tmp___46;
      } else {
#line 712
        tmp___49 = __builtin_strcmp((char const   *)type, "s3_1x39");
#line 712
        tmp___50 = tmp___49;
      }
    } else {
#line 712
      tmp___49 = __builtin_strcmp((char const   *)type, "s3_1x39");
#line 712
      tmp___50 = tmp___49;
    }
#line 712
    if (tmp___50 == 0) {
#line 714
      fcb->cepsize = 13;
#line 715
      fcb->cepsize_used = 13;
#line 716
      fcb->n_stream = 1;
#line 717
      tmp___2 = __ckd_calloc__((size_t )1, sizeof(int32 ), "src/feat.c", 717);
#line 717
      fcb->stream_len = (int32 *)tmp___2;
#line 718
      *(fcb->stream_len + 0) = 39;
#line 719
      fcb->window_size = 3;
#line 720
      fcb->compute_feat = & feat_s3_1x39_cep2feat;
    } else {
#line 721
      if (0) {
#line 721
        __s1_len___1 = __builtin_strlen((char const   *)type);
#line 721
        __s2_len___1 = __builtin_strlen("1s_c_d_dd");
#line 721
        if (! ((size_t )((void const   *)(type + 1)) - (size_t )((void const   *)type) == 1UL)) {
#line 721
          goto _L___4;
        } else
#line 721
        if (__s1_len___1 >= 4UL) {
          _L___4: /* CIL Label */ 
#line 721
          if (! ((size_t )((void const   *)("1s_c_d_dd" + 1)) - (size_t )((void const   *)"1s_c_d_dd") == 1UL)) {
#line 721
            tmp___44 = 1;
          } else
#line 721
          if (__s2_len___1 >= 4UL) {
#line 721
            tmp___44 = 1;
          } else {
#line 721
            tmp___44 = 0;
          }
        } else {
#line 721
          tmp___44 = 0;
        }
#line 721
        if (tmp___44) {
#line 721
          tmp___39 = __builtin_strcmp((char const   *)type, "1s_c_d_dd");
#line 721
          tmp___43 = tmp___39;
        } else {
#line 721
          tmp___42 = __builtin_strcmp((char const   *)type, "1s_c_d_dd");
#line 721
          tmp___43 = tmp___42;
        }
      } else {
#line 721
        tmp___42 = __builtin_strcmp((char const   *)type, "1s_c_d_dd");
#line 721
        tmp___43 = tmp___42;
      }
#line 721
      if (tmp___43 == 0) {
#line 722
        fcb->cepsize = 13;
#line 723
        fcb->cepsize_used = 13;
#line 724
        fcb->n_stream = 1;
#line 725
        tmp___3 = __ckd_calloc__((size_t )1, sizeof(int32 ), "src/feat.c", 725);
#line 725
        fcb->stream_len = (int32 *)tmp___3;
#line 726
        *(fcb->stream_len + 0) = 39;
#line 727
        fcb->window_size = 3;
#line 728
        fcb->compute_feat = & feat_1s_c_d_dd_cep2feat;
      } else {
#line 729
        if (0) {
#line 729
          if (0) {
#line 729
            __s1_len___0 = __builtin_strlen((char const   *)type);
#line 729
            __s2_len___0 = __builtin_strlen("cep_dcep");
#line 729
            if (! ((size_t )((void const   *)(type + 1)) - (size_t )((void const   *)type) == 1UL)) {
#line 729
              goto _L___2;
            } else
#line 729
            if (__s1_len___0 >= 4UL) {
              _L___2: /* CIL Label */ 
#line 729
              if (! ((size_t )((void const   *)("cep_dcep" + 1)) - (size_t )((void const   *)"cep_dcep") == 1UL)) {
#line 729
                tmp___33 = 1;
              } else
#line 729
              if (__s2_len___0 >= 4UL) {
#line 729
                tmp___33 = 1;
              } else {
#line 729
                tmp___33 = 0;
              }
            } else {
#line 729
              tmp___33 = 0;
            }
#line 729
            if (tmp___33) {
#line 729
              tmp___28 = __builtin_strcmp((char const   *)type, "cep_dcep");
#line 729
              tmp___32 = tmp___28;
            } else {
#line 729
              tmp___31 = __builtin_strcmp((char const   *)type, "cep_dcep");
#line 729
              tmp___32 = tmp___31;
            }
          } else {
#line 729
            tmp___31 = __builtin_strcmp((char const   *)type, "cep_dcep");
#line 729
            tmp___32 = tmp___31;
          }
#line 729
          tmp___35 = tmp___32;
        } else {
#line 729
          tmp___34 = strncmp((char const   *)type, "cep_dcep", (size_t )8);
#line 729
          tmp___35 = tmp___34;
        }
#line 729
        if (tmp___35 == 0) {
#line 731
          fcb->cepsize = 13;
#line 733
          if ((int )*(type + 8) == 44) {
#line 734
            tmp___4 = sscanf((char const   * __restrict  )(type + 9), (char const   * __restrict  )"%d%n",
                             & fcb->cepsize_used, & l);
#line 734
            if (tmp___4 != 1) {
#line 738
              _E__pr_header("src/feat.c", 738L, "FATAL_ERROR");
#line 738
              _E__die_error("Bad feature type argument: \'%s\'\n", type);
            } else
#line 734
            if ((int )*(type + (l + 9)) != 0) {
#line 738
              _E__pr_header("src/feat.c", 738L, "FATAL_ERROR");
#line 738
              _E__die_error("Bad feature type argument: \'%s\'\n", type);
            } else
#line 734
            if (fcb->cepsize_used <= 0) {
#line 738
              _E__pr_header("src/feat.c", 738L, "FATAL_ERROR");
#line 738
              _E__die_error("Bad feature type argument: \'%s\'\n", type);
            } else
#line 734
            if (fcb->cepsize_used > fcb->cepsize) {
#line 738
              _E__pr_header("src/feat.c", 738L, "FATAL_ERROR");
#line 738
              _E__die_error("Bad feature type argument: \'%s\'\n", type);
            }
          } else {
#line 740
            fcb->cepsize_used = 13;
          }
#line 741
          fcb->n_stream = 1;
#line 742
          tmp___5 = __ckd_calloc__((size_t )1, sizeof(int32 ), "src/feat.c", 742);
#line 742
          fcb->stream_len = (int32 *)tmp___5;
#line 743
          *(fcb->stream_len + 0) = fcb->cepsize_used * 2;
#line 744
          fcb->window_size = 2;
#line 745
          fcb->compute_feat = & feat_s3_cep_dcep;
        } else {
#line 746
          if (0) {
#line 746
            if (0) {
#line 746
              __s1_len = __builtin_strlen((char const   *)type);
#line 746
              __s2_len = __builtin_strlen("cep");
#line 746
              if (! ((size_t )((void const   *)(type + 1)) - (size_t )((void const   *)type) == 1UL)) {
#line 746
                goto _L___0;
              } else
#line 746
              if (__s1_len >= 4UL) {
                _L___0: /* CIL Label */ 
#line 746
                if (! ((size_t )((void const   *)("cep" + 1)) - (size_t )((void const   *)"cep") == 1UL)) {
#line 746
                  tmp___20 = 1;
                } else
#line 746
                if (__s2_len >= 4UL) {
#line 746
                  tmp___20 = 1;
                } else {
#line 746
                  tmp___20 = 0;
                }
              } else {
#line 746
                tmp___20 = 0;
              }
#line 746
              if (tmp___20) {
#line 746
                tmp___15 = __builtin_strcmp((char const   *)type, "cep");
#line 746
                tmp___19 = tmp___15;
              } else {
#line 746
                tmp___18 = __builtin_strcmp((char const   *)type, "cep");
#line 746
                tmp___19 = tmp___18;
              }
            } else {
#line 746
              tmp___18 = __builtin_strcmp((char const   *)type, "cep");
#line 746
              tmp___19 = tmp___18;
            }
#line 746
            tmp___22 = tmp___19;
          } else {
#line 746
            tmp___21 = strncmp((char const   *)type, "cep", (size_t )3);
#line 746
            tmp___22 = tmp___21;
          }
#line 746
          if (tmp___22 == 0) {
#line 748
            fcb->cepsize = 13;
#line 750
            if ((int )*(type + 3) == 44) {
#line 751
              tmp___6 = sscanf((char const   * __restrict  )(type + 4), (char const   * __restrict  )"%d%n",
                               & fcb->cepsize_used, & l);
#line 751
              if (tmp___6 != 1) {
#line 755
                _E__pr_header("src/feat.c", 755L, "FATAL_ERROR");
#line 755
                _E__die_error("Bad feature type argument: \'%s\'\n", type);
              } else
#line 751
              if ((int )*(type + (l + 4)) != 0) {
#line 755
                _E__pr_header("src/feat.c", 755L, "FATAL_ERROR");
#line 755
                _E__die_error("Bad feature type argument: \'%s\'\n", type);
              } else
#line 751
              if (fcb->cepsize_used <= 0) {
#line 755
                _E__pr_header("src/feat.c", 755L, "FATAL_ERROR");
#line 755
                _E__die_error("Bad feature type argument: \'%s\'\n", type);
              } else
#line 751
              if (fcb->cepsize_used > fcb->cepsize) {
#line 755
                _E__pr_header("src/feat.c", 755L, "FATAL_ERROR");
#line 755
                _E__die_error("Bad feature type argument: \'%s\'\n", type);
              }
            } else {
#line 757
              fcb->cepsize_used = 13;
            }
#line 758
            fcb->n_stream = 1;
#line 759
            tmp___7 = __ckd_calloc__((size_t )1, sizeof(int32 ), "src/feat.c", 759);
#line 759
            fcb->stream_len = (int32 *)tmp___7;
#line 760
            *(fcb->stream_len + 0) = fcb->cepsize_used;
#line 761
            fcb->window_size = 0;
#line 762
            fcb->compute_feat = & feat_s3_cep;
          } else {
#line 768
            tmp___8 = strlen((char const   *)type);
#line 768
            l = (int32 )tmp___8;
#line 769
            k___0 = 0;
#line 770
            i = 1;
#line 770
            while (i < l - 1) {
#line 771
              if ((int )*(type + i) == 44) {
#line 772
                *(type + i) = (char )' ';
#line 773
                k___0 ++;
              }
#line 770
              i ++;
            }
#line 775
            k___0 ++;
#line 776
            fcb->n_stream = k___0;
#line 777
            tmp___9 = __ckd_calloc__((size_t )k___0, sizeof(int32 ), "src/feat.c",
                                     777);
#line 777
            fcb->stream_len = (int32 *)tmp___9;
#line 780
            strp = type;
#line 781
            i = 0;
#line 782
            while (1) {
#line 782
              tmp___11 = sscanf((char const   * __restrict  )strp, (char const   * __restrict  )"%s%n",
                                wd, & l);
#line 782
              if (! (tmp___11 == 1)) {
#line 782
                break;
              }
#line 783
              strp += l;
#line 784
              if (i >= fcb->n_stream) {
#line 786
                _E__pr_header("src/feat.c", 786L, "FATAL_ERROR");
#line 786
                _E__die_error("Bad feature type argument\n");
              } else {
#line 784
                tmp___10 = sscanf((char const   * __restrict  )(wd), (char const   * __restrict  )"%d",
                                  fcb->stream_len + i);
#line 784
                if (tmp___10 != 1) {
#line 786
                  _E__pr_header("src/feat.c", 786L, "FATAL_ERROR");
#line 786
                  _E__die_error("Bad feature type argument\n");
                } else
#line 784
                if (*(fcb->stream_len + i) <= 0) {
#line 786
                  _E__pr_header("src/feat.c", 786L, "FATAL_ERROR");
#line 786
                  _E__die_error("Bad feature type argument\n");
                }
              }
#line 787
              i ++;
            }
#line 789
            if (i != fcb->n_stream) {
#line 790
              _E__pr_header("src/feat.c", 790L, "FATAL_ERROR");
#line 790
              _E__die_error("Bad feature type argument\n");
            }
#line 793
            fcb->cepsize = -1;
#line 794
            fcb->cepsize_used = -1;
#line 795
            fcb->window_size = 0;
#line 796
            fcb->compute_feat = (void (*)(struct feat_s *fcb , float32 **input , float32 **feat ))((void *)0);
          }
        }
      }
    }
  }
#line 799
  if (0) {
#line 799
    __s1_len___5 = __builtin_strlen((char const   *)cmn___0);
#line 799
    __s2_len___5 = __builtin_strlen("current");
#line 799
    if (! ((size_t )((void const   *)(cmn___0 + 1)) - (size_t )((void const   *)cmn___0) == 1UL)) {
#line 799
      goto _L___12;
    } else
#line 799
    if (__s1_len___5 >= 4UL) {
      _L___12: /* CIL Label */ 
#line 799
      if (! ((size_t )((void const   *)("current" + 1)) - (size_t )((void const   *)"current") == 1UL)) {
#line 799
        tmp___72 = 1;
      } else
#line 799
      if (__s2_len___5 >= 4UL) {
#line 799
        tmp___72 = 1;
      } else {
#line 799
        tmp___72 = 0;
      }
    } else {
#line 799
      tmp___72 = 0;
    }
#line 799
    if (tmp___72) {
#line 799
      tmp___67 = __builtin_strcmp((char const   *)cmn___0, "current");
#line 799
      tmp___71 = tmp___67;
    } else {
#line 799
      tmp___70 = __builtin_strcmp((char const   *)cmn___0, "current");
#line 799
      tmp___71 = tmp___70;
    }
  } else {
#line 799
    tmp___70 = __builtin_strcmp((char const   *)cmn___0, "current");
#line 799
    tmp___71 = tmp___70;
  }
#line 799
  if (tmp___71 == 0) {
#line 800
    fcb->cmn = 1;
  } else {
#line 801
    if (0) {
#line 801
      __s1_len___4 = __builtin_strlen((char const   *)cmn___0);
#line 801
      __s2_len___4 = __builtin_strlen("none");
#line 801
      if (! ((size_t )((void const   *)(cmn___0 + 1)) - (size_t )((void const   *)cmn___0) == 1UL)) {
#line 801
        goto _L___10;
      } else
#line 801
      if (__s1_len___4 >= 4UL) {
        _L___10: /* CIL Label */ 
#line 801
        if (! ((size_t )((void const   *)("none" + 1)) - (size_t )((void const   *)"none") == 1UL)) {
#line 801
          tmp___65 = 1;
        } else
#line 801
        if (__s2_len___4 >= 4UL) {
#line 801
          tmp___65 = 1;
        } else {
#line 801
          tmp___65 = 0;
        }
      } else {
#line 801
        tmp___65 = 0;
      }
#line 801
      if (tmp___65) {
#line 801
        tmp___60 = __builtin_strcmp((char const   *)cmn___0, "none");
#line 801
        tmp___64 = tmp___60;
      } else {
#line 801
        tmp___63 = __builtin_strcmp((char const   *)cmn___0, "none");
#line 801
        tmp___64 = tmp___63;
      }
    } else {
#line 801
      tmp___63 = __builtin_strcmp((char const   *)cmn___0, "none");
#line 801
      tmp___64 = tmp___63;
    }
#line 801
    if (tmp___64 == 0) {
#line 802
      fcb->cmn = 0;
    } else {
#line 804
      _E__pr_header("src/feat.c", 804L, "FATAL_ERROR");
#line 804
      _E__die_error("Unsupported CMN type \'%s\'\n", cmn___0);
    }
  }
#line 806
  if (0) {
#line 806
    __s1_len___7 = __builtin_strlen((char const   *)varnorm);
#line 806
    __s2_len___7 = __builtin_strlen("yes");
#line 806
    if (! ((size_t )((void const   *)(varnorm + 1)) - (size_t )((void const   *)varnorm) == 1UL)) {
#line 806
      goto _L___16;
    } else
#line 806
    if (__s1_len___7 >= 4UL) {
      _L___16: /* CIL Label */ 
#line 806
      if (! ((size_t )((void const   *)("yes" + 1)) - (size_t )((void const   *)"yes") == 1UL)) {
#line 806
        tmp___86 = 1;
      } else
#line 806
      if (__s2_len___7 >= 4UL) {
#line 806
        tmp___86 = 1;
      } else {
#line 806
        tmp___86 = 0;
      }
    } else {
#line 806
      tmp___86 = 0;
    }
#line 806
    if (tmp___86) {
#line 806
      tmp___81 = __builtin_strcmp((char const   *)varnorm, "yes");
#line 806
      tmp___85 = tmp___81;
    } else {
#line 806
      tmp___84 = __builtin_strcmp((char const   *)varnorm, "yes");
#line 806
      tmp___85 = tmp___84;
    }
  } else {
#line 806
    tmp___84 = __builtin_strcmp((char const   *)varnorm, "yes");
#line 806
    tmp___85 = tmp___84;
  }
#line 806
  if (tmp___85 == 0) {
#line 807
    fcb->varnorm = 1;
  } else {
#line 808
    if (0) {
#line 808
      __s1_len___6 = __builtin_strlen((char const   *)varnorm);
#line 808
      __s2_len___6 = __builtin_strlen("no");
#line 808
      if (! ((size_t )((void const   *)(varnorm + 1)) - (size_t )((void const   *)varnorm) == 1UL)) {
#line 808
        goto _L___14;
      } else
#line 808
      if (__s1_len___6 >= 4UL) {
        _L___14: /* CIL Label */ 
#line 808
        if (! ((size_t )((void const   *)("no" + 1)) - (size_t )((void const   *)"no") == 1UL)) {
#line 808
          tmp___79 = 1;
        } else
#line 808
        if (__s2_len___6 >= 4UL) {
#line 808
          tmp___79 = 1;
        } else {
#line 808
          tmp___79 = 0;
        }
      } else {
#line 808
        tmp___79 = 0;
      }
#line 808
      if (tmp___79) {
#line 808
        tmp___74 = __builtin_strcmp((char const   *)varnorm, "no");
#line 808
        tmp___78 = tmp___74;
      } else {
#line 808
        tmp___77 = __builtin_strcmp((char const   *)varnorm, "no");
#line 808
        tmp___78 = tmp___77;
      }
    } else {
#line 808
      tmp___77 = __builtin_strcmp((char const   *)varnorm, "no");
#line 808
      tmp___78 = tmp___77;
    }
#line 808
    if (tmp___78 == 0) {
#line 809
      fcb->varnorm = 0;
    } else {
#line 811
      _E__pr_header("src/feat.c", 811L, "FATAL_ERROR");
#line 811
      _E__die_error("Unsupported VARNORM type \'%s\'\n", varnorm);
    }
  }
#line 813
  if (0) {
#line 813
    __s1_len___9 = __builtin_strlen((char const   *)agc);
#line 813
    __s2_len___9 = __builtin_strlen("max");
#line 813
    if (! ((size_t )((void const   *)(agc + 1)) - (size_t )((void const   *)agc) == 1UL)) {
#line 813
      goto _L___20;
    } else
#line 813
    if (__s1_len___9 >= 4UL) {
      _L___20: /* CIL Label */ 
#line 813
      if (! ((size_t )((void const   *)("max" + 1)) - (size_t )((void const   *)"max") == 1UL)) {
#line 813
        tmp___100 = 1;
      } else
#line 813
      if (__s2_len___9 >= 4UL) {
#line 813
        tmp___100 = 1;
      } else {
#line 813
        tmp___100 = 0;
      }
    } else {
#line 813
      tmp___100 = 0;
    }
#line 813
    if (tmp___100) {
#line 813
      tmp___95 = __builtin_strcmp((char const   *)agc, "max");
#line 813
      tmp___99 = tmp___95;
    } else {
#line 813
      tmp___98 = __builtin_strcmp((char const   *)agc, "max");
#line 813
      tmp___99 = tmp___98;
    }
  } else {
#line 813
    tmp___98 = __builtin_strcmp((char const   *)agc, "max");
#line 813
    tmp___99 = tmp___98;
  }
#line 813
  if (tmp___99 == 0) {
#line 814
    fcb->agc = 1;
  } else {
#line 815
    if (0) {
#line 815
      __s1_len___8 = __builtin_strlen((char const   *)agc);
#line 815
      __s2_len___8 = __builtin_strlen("none");
#line 815
      if (! ((size_t )((void const   *)(agc + 1)) - (size_t )((void const   *)agc) == 1UL)) {
#line 815
        goto _L___18;
      } else
#line 815
      if (__s1_len___8 >= 4UL) {
        _L___18: /* CIL Label */ 
#line 815
        if (! ((size_t )((void const   *)("none" + 1)) - (size_t )((void const   *)"none") == 1UL)) {
#line 815
          tmp___93 = 1;
        } else
#line 815
        if (__s2_len___8 >= 4UL) {
#line 815
          tmp___93 = 1;
        } else {
#line 815
          tmp___93 = 0;
        }
      } else {
#line 815
        tmp___93 = 0;
      }
#line 815
      if (tmp___93) {
#line 815
        tmp___88 = __builtin_strcmp((char const   *)agc, "none");
#line 815
        tmp___92 = tmp___88;
      } else {
#line 815
        tmp___91 = __builtin_strcmp((char const   *)agc, "none");
#line 815
        tmp___92 = tmp___91;
      }
    } else {
#line 815
      tmp___91 = __builtin_strcmp((char const   *)agc, "none");
#line 815
      tmp___92 = tmp___91;
    }
#line 815
    if (tmp___92 == 0) {
#line 816
      fcb->agc = 0;
    } else {
#line 818
      _E__pr_header("src/feat.c", 818L, "FATAL_ERROR");
#line 818
      _E__die_error("Unsupported AGC type \'%s\'\n", agc);
    }
  }
#line 820
  return (fcb);
}
}
#line 824 "src/feat.c"
void feat_print(feat_t *fcb , float32 ***feat___0 , int32 nfr , FILE *fp ) 
{ 
  int32 i ;
  int32 j ;
  int32 k___0 ;

  {
#line 828
  i = 0;
#line 828
  while (i < nfr) {
#line 829
    fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"%8d:", i);
#line 831
    j = 0;
#line 831
    while (j < fcb->n_stream) {
#line 832
      fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"\t%2d:", j);
#line 834
      k___0 = 0;
#line 834
      while (k___0 < *(fcb->stream_len + j)) {
#line 835
        fprintf((FILE * __restrict  )fp, (char const   * __restrict  )" %8.4f", (double )*(*(*(feat___0 + i) + j) + k___0));
#line 834
        k___0 ++;
      }
#line 836
      fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"\n");
#line 831
      j ++;
    }
#line 828
    i ++;
  }
#line 840
  fflush(fp);
#line 841
  return;
}
}
#line 844 "src/feat.c"
int32 feat_s2mfc2feat(feat_t *fcb , char *file , char *dir , int32 sf , int32 ef ,
                      float32 ***feat___0 , int32 maxfr ) 
{ 
  char path[16384] ;
  int32 win ;
  int32 nfr ;
  int32 i ;
  int32 k___0 ;
  float32 **mfc ;
  size_t tmp ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___1 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  void **tmp___7 ;

  {
#line 852
  if (fcb->cepsize <= 0) {
#line 853
    _E__pr_header("src/feat.c", 853L, "ERROR");
#line 853
    _E__pr_warn("Bad cepsize: %d\n", fcb->cepsize);
#line 854
    return (-1);
  }
#line 858
  tmp = strlen((char const   *)file);
#line 858
  k___0 = (int32 )tmp;
#line 859
  if (k___0 > 4) {
#line 859
    if (0) {
#line 859
      __s1_len = __builtin_strlen((char const   *)((file + k___0) - 4));
#line 859
      __s2_len = __builtin_strlen(".mfc");
#line 859
      if (! ((size_t )((void const   *)(((file + k___0) - 4) + 1)) - (size_t )((void const   *)((file + k___0) - 4)) == 1UL)) {
#line 859
        goto _L___0;
      } else
#line 859
      if (__s1_len >= 4UL) {
        _L___0: /* CIL Label */ 
#line 859
        if (! ((size_t )((void const   *)(".mfc" + 1)) - (size_t )((void const   *)".mfc") == 1UL)) {
#line 859
          tmp___6 = 1;
        } else
#line 859
        if (__s2_len >= 4UL) {
#line 859
          tmp___6 = 1;
        } else {
#line 859
          tmp___6 = 0;
        }
      } else {
#line 859
        tmp___6 = 0;
      }
#line 859
      if (tmp___6) {
#line 859
        tmp___1 = __builtin_strcmp((char const   *)((file + k___0) - 4), ".mfc");
#line 859
        tmp___5 = tmp___1;
      } else {
#line 859
        tmp___4 = __builtin_strcmp((char const   *)((file + k___0) - 4), ".mfc");
#line 859
        tmp___5 = tmp___4;
      }
    } else {
#line 859
      tmp___4 = __builtin_strcmp((char const   *)((file + k___0) - 4), ".mfc");
#line 859
      tmp___5 = tmp___4;
    }
#line 859
    if (tmp___5 == 0) {
#line 860
      if (dir) {
#line 860
        if ((int )*(file + 0) != 47) {
#line 861
          sprintf((char * __restrict  )(path), (char const   * __restrict  )"%s/%s",
                  dir, file);
        } else {
#line 863
          strcpy((char * __restrict  )(path), (char const   * __restrict  )file);
        }
      } else {
#line 863
        strcpy((char * __restrict  )(path), (char const   * __restrict  )file);
      }
    } else {
#line 859
      goto _L___1;
    }
  } else
  _L___1: /* CIL Label */ 
#line 865
  if (dir) {
#line 865
    if ((int )*(file + 0) != 47) {
#line 866
      sprintf((char * __restrict  )(path), (char const   * __restrict  )"%s/%s.mfc",
              dir, file);
    } else {
#line 868
      sprintf((char * __restrict  )(path), (char const   * __restrict  )"%s.mfc",
              file);
    }
  } else {
#line 868
    sprintf((char * __restrict  )(path), (char const   * __restrict  )"%s.mfc", file);
  }
#line 871
  win = fcb->window_size;
#line 874
  if (ef < 0) {
#line 875
    ef = 2147418112 - win;
  }
#line 876
  sf -= win;
#line 877
  ef += win;
#line 880
  tmp___7 = __ckd_calloc_2d__(15000, fcb->cepsize, (int32 )sizeof(float32 ), "src/feat.c",
                              880);
#line 880
  mfc = (float32 **)tmp___7;
#line 881
  if (sf < 0) {
#line 882
    nfr = feat_s2mfc_read(path, 0, ef, mfc - sf, (15000 + sf) - win);
  } else {
#line 884
    nfr = feat_s2mfc_read(path, sf, ef, mfc, 15000 - win);
  }
#line 885
  if (nfr < 0) {
#line 886
    ckd_free_2d((void **)mfc);
#line 887
    return (-1);
  }
#line 890
  if (nfr < 2 * win + 1) {
#line 891
    _E__pr_header("src/feat.c", 891L, "ERROR");
#line 891
    _E__pr_warn("%s: MFC file/segment too short to compute features: %d frames\n",
                file, nfr);
#line 892
    ckd_free_2d((void **)mfc);
#line 893
    return (-1);
  }
#line 897
  if (sf < 0) {
#line 898
    i = 0;
#line 898
    while (i < - sf) {
#line 899
      memcpy((void * __restrict  )*(mfc + i), (void const   * __restrict  )*(mfc + ((i - sf) + 1)),
             (unsigned long )fcb->cepsize * sizeof(float32 ));
#line 898
      i ++;
    }
#line 900
    nfr -= sf;
  }
#line 904
  k___0 = (ef - sf) + 1;
#line 905
  if (nfr < k___0) {
#line 906
    k___0 -= nfr;
#line 907
    if (k___0 > win) {
#line 908
      k___0 = win;
    }
#line 910
    i = 0;
#line 910
    while (i < k___0) {
#line 911
      memcpy((void * __restrict  )*(mfc + (nfr + i)), (void const   * __restrict  )*(mfc + (((nfr + i) - 1) - k___0)),
             (unsigned long )fcb->cepsize * sizeof(float32 ));
#line 910
      i ++;
    }
#line 912
    nfr += k___0;
  }
#line 916
  if (nfr - win * 2 > maxfr) {
#line 917
    _E__pr_header("src/feat.c", 917L, "ERROR");
#line 917
    _E__pr_warn("%s: Feature buffer size(%d frames) < required(%d)\n", maxfr, nfr - win * 2);
#line 918
    ckd_free_2d((void **)mfc);
#line 919
    return (-1);
  }
#line 922
  if (fcb->cmn) {
#line 923
    cmn(mfc, fcb->varnorm, nfr, fcb->cepsize);
  }
#line 924
  if (fcb->agc) {
#line 925
    agc_max(mfc, nfr);
  }
#line 928
  i = win;
#line 928
  while (i < nfr - win) {
#line 929
    (*(fcb->compute_feat))(fcb, mfc + i, *(feat___0 + (i - win)));
#line 928
    i ++;
  }
#line 931
  ckd_free_2d((void **)mfc);
#line 933
  return (nfr - win * 2);
}
}
#line 958 "src/feat.c"
static float32 **feat  =    (float32 **)((void *)0);
#line 959 "src/feat.c"
static float32 **cepbuf  =    (float32 **)((void *)0);
#line 963 "src/feat.c"
static int32 bufpos  ;
#line 964 "src/feat.c"
static int32 curpos  ;
#line 965 "src/feat.c"
static int32 jp1  ;
#line 965 "src/feat.c"
static int32 jp2  ;
#line 965 "src/feat.c"
static int32 jp3  ;
#line 965 "src/feat.c"
static int32 jf1  ;
#line 965 "src/feat.c"
static int32 jf2  ;
#line 965 "src/feat.c"
static int32 jf3  ;
#line 955 "src/feat.c"
int32 feat_s2mfc2feat_block(feat_t *fcb , float32 **uttcep , int32 nfr , int32 beginutt ,
                            int32 endutt , float32 ***ofeat ) 
{ 
  int32 win ;
  int32 cepsize ;
  int32 i ;
  int32 j ;
  int32 nfeatvec ;
  int32 residualvecs ;
  float32 *w___0 ;
  float32 *_w ;
  float32 *f ;
  float32 *w1 ;
  float32 *w_1 ;
  float32 *_w1 ;
  float32 *_w_1 ;
  float32 d1 ;
  float32 d2 ;
  int32 tmp ;
  void **tmp___0 ;
  void **tmp___1 ;
  int32 tmp___2 ;
  int32 tmp___3 ;
  int16 tpos ;
  int32 tmp___4 ;

  {
#line 975
  if (! (nfr < 256)) {
#line 975
    __assert_fail("nfr < 256", "src/feat.c", 975U, "feat_s2mfc2feat_block");
  }
#line 976
  win = fcb->window_size;
#line 978
  if (fcb->cepsize <= 0) {
#line 979
    _E__pr_header("src/feat.c", 979L, "FATAL_ERROR");
#line 979
    _E__die_error("Bad cepsize: %d\n", fcb->cepsize);
  }
#line 980
  cepsize = fcb->cepsize;
#line 981
  if ((unsigned long )feat == (unsigned long )((void *)0)) {
#line 984
    tmp = *(fcb->stream_len + 0);
#line 985
    if (tmp % 4) {
#line 985
      tmp += 4 - tmp % 4;
    } else {
#line 985
      tmp = tmp;
    }
#line 986
    tmp___0 = __ckd_calloc_2d__(256, tmp, (int32 )sizeof(float32 ), "src/feat.c",
                                988);
#line 986
    feat = (float32 **)tmp___0;
  }
#line 995
  if ((unsigned long )cepbuf == (unsigned long )((void *)0)) {
#line 996
    tmp___1 = __ckd_calloc_2d__(256, cepsize, (int32 )sizeof(float32 ), "src/feat.c",
                                998);
#line 996
    cepbuf = (float32 **)tmp___1;
#line 999
    beginutt = 1;
#line 1000
    if (! feat) {
#line 1001
      _E__pr_header("src/feat.c", 1001L, "FATAL_ERROR");
#line 1001
      _E__die_error("Unable to allocate feat ckd_calloc_2d(%ld,%d,%d)\n", 256, *(fcb->stream_len + 0),
                    sizeof(float32 ));
    }
#line 1002
    if (! cepbuf) {
#line 1003
      _E__pr_header("src/feat.c", 1003L, "FATAL_ERROR");
#line 1003
      _E__die_error("Unable to allocate cepbuf ckd_calloc_2d(%ld,%d,%d)\n", 256, cepsize,
                    sizeof(float32 ));
    }
#line 1004
    _E__pr_info_header("src/feat.c", 1004L, "INFO");
#line 1004
    _E__pr_info("Feature buffers initialized to %d vectors\n", 256);
  }
#line 1008
  if (fcb->cmn) {
#line 1009
    cmn_prior(uttcep, fcb->varnorm, nfr, fcb->cepsize, endutt);
  }
#line 1011
  residualvecs = 0;
#line 1012
  if (beginutt) {
#line 1014
    i = 0;
#line 1014
    while (i < win) {
#line 1015
      memcpy((void * __restrict  )*(cepbuf + i), (void const   * __restrict  )*(uttcep + 0),
             (unsigned long )cepsize * sizeof(float32 ));
#line 1014
      i ++;
    }
#line 1018
    bufpos = win;
#line 1019
    bufpos %= 256;
#line 1020
    curpos = bufpos;
#line 1021
    jp1 = curpos - 1;
#line 1022
    jp1 %= 256;
#line 1023
    jp2 = curpos - 2;
#line 1024
    jp2 %= 256;
#line 1025
    jp3 = curpos - 3;
#line 1026
    jp3 %= 256;
#line 1027
    jf1 = curpos + 1;
#line 1028
    jf1 %= 256;
#line 1029
    jf2 = curpos + 2;
#line 1030
    jf2 %= 256;
#line 1031
    jf3 = curpos + 3;
#line 1032
    jf3 %= 256;
#line 1033
    residualvecs -= win;
  }
#line 1036
  i = 0;
#line 1036
  while (i < nfr) {
#line 1037
    if (! (bufpos < 256)) {
#line 1037
      __assert_fail("bufpos < 256", "src/feat.c", 1037U, "feat_s2mfc2feat_block");
    }
#line 1038
    tmp___2 = bufpos;
#line 1038
    bufpos ++;
#line 1038
    memcpy((void * __restrict  )*(cepbuf + tmp___2), (void const   * __restrict  )*(uttcep + i),
           (unsigned long )cepsize * sizeof(float32 ));
#line 1039
    bufpos %= 256;
#line 1036
    i ++;
  }
#line 1042
  if (endutt) {
#line 1044
    if (nfr > 0) {
#line 1045
      i = 0;
#line 1045
      while (i < win) {
#line 1046
        if (! (bufpos < 256)) {
#line 1046
          __assert_fail("bufpos < 256", "src/feat.c", 1046U, "feat_s2mfc2feat_block");
        }
#line 1047
        tmp___3 = bufpos;
#line 1047
        bufpos ++;
#line 1047
        memcpy((void * __restrict  )*(cepbuf + tmp___3), (void const   * __restrict  )*(uttcep + (nfr - 1)),
               (unsigned long )cepsize * sizeof(float32 ));
#line 1048
        bufpos %= 256;
#line 1045
        i ++;
      }
    } else {
#line 1052
      tpos = (int16 )(bufpos - 1);
#line 1053
      tpos = (int16 )((int )tpos % 256);
#line 1054
      i = 0;
#line 1054
      while (i < win) {
#line 1055
        if (! (bufpos < 256)) {
#line 1055
          __assert_fail("bufpos < 256", "src/feat.c", 1055U, "feat_s2mfc2feat_block");
        }
#line 1056
        tmp___4 = bufpos;
#line 1056
        bufpos ++;
#line 1056
        memcpy((void * __restrict  )*(cepbuf + tmp___4), (void const   * __restrict  )*(cepbuf + tpos),
               (unsigned long )cepsize * sizeof(float32 ));
#line 1057
        bufpos %= 256;
#line 1054
        i ++;
      }
    }
#line 1060
    residualvecs += win;
  }
#line 1064
  nfeatvec = 0;
#line 1065
  nfr += residualvecs;
#line 1067
  i = 0;
#line 1067
  while (i < nfr) {
#line 1069
    memcpy((void * __restrict  )*(feat + i), (void const   * __restrict  )*(cepbuf + curpos),
           (unsigned long )cepsize * sizeof(float32 ));
#line 1074
    f = *(feat + i) + cepsize;
#line 1075
    w___0 = *(cepbuf + jf2);
#line 1076
    _w = *(cepbuf + jp2);
#line 1078
    j = 0;
#line 1078
    while (j < cepsize) {
#line 1079
      *(f + j) = *(w___0 + j) - *(_w + j);
#line 1078
      j ++;
    }
#line 1082
    f += cepsize;
#line 1084
    w1 = *(cepbuf + jf3);
#line 1085
    _w1 = *(cepbuf + jp1);
#line 1086
    w_1 = *(cepbuf + jf1);
#line 1087
    _w_1 = *(cepbuf + jp3);
#line 1089
    j = 0;
#line 1089
    while (j < cepsize) {
#line 1090
      d1 = *(w1 + j) - *(_w1 + j);
#line 1091
      d2 = *(w_1 + j) - *(_w_1 + j);
#line 1093
      *(f + j) = d1 - d2;
#line 1089
      j ++;
    }
#line 1095
    jf1 ++;
#line 1095
    jf2 ++;
#line 1095
    jf3 ++;
#line 1096
    jp1 ++;
#line 1096
    jp2 ++;
#line 1096
    jp3 ++;
#line 1097
    curpos ++;
#line 1098
    jf1 %= 256;
#line 1099
    jf2 %= 256;
#line 1100
    jf3 %= 256;
#line 1101
    jp1 %= 256;
#line 1102
    jp2 %= 256;
#line 1103
    jp3 %= 256;
#line 1104
    curpos %= 256;
#line 1067
    i ++;
#line 1067
    nfeatvec ++;
  }
#line 1106
  *ofeat = feat;
#line 1108
  return (nfeatvec);
}
}
#line 1115 "src/feat.c"
void feat_free(feat_t *f ) 
{ 


  {
#line 1124
  return;
}
}
#line 1 "live.o"
#pragma merger("0","/tmp/cil-wWF_Ld9z.i","-g,-O4")
#line 1301 "/usr/include/x86_64-linux-gnu/bits/string2.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) __strdup)(char const   *__string )  __attribute__((__malloc__)) ;
#line 150 "/usr/include/x86_64-linux-gnu/bits/mathinline.h"
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__, __always_inline__)) __signbitl)(long double __x )  __attribute__((__const__)) ;
#line 150 "/usr/include/x86_64-linux-gnu/bits/mathinline.h"
__inline extern int ( __attribute__((__leaf__, __always_inline__)) __signbitl)(long double __x ) 
{ 
  union __anonunion___u_29___25 __u ;

  {
#line 153
  __u.__l = __x;
#line 154
  return ((__u.__i[2] & 32768) != 0);
}
}
#line 105 "src/live.h"
void live_initialize_decoder(char *live_args ) ;
#line 107
int32 live_get_partialhyp(int32 endutt ) ;
#line 118
int32 live_utt_decode_block(int16 *samples , int32 nsamples , int32 live_endutt ,
                            partialhyp_t **ohyp ) ;
#line 123
int32 live_free_memory(void) ;
#line 117 "src/live.c"
static fe_t *fe  ;
#line 119 "src/live.c"
static kb_t *kb  ;
#line 120 "src/live.c"
static kbcore_t *kbcore  ;
#line 121 "src/live.c"
static FILE *hmmdumpfp  ;
#line 122 "src/live.c"
static int32 maxwpf  ;
#line 123 "src/live.c"
static int32 maxhistpf  ;
#line 124 "src/live.c"
static int32 maxhmmpf  ;
#line 125 "src/live.c"
static int32 ptranskip  ;
#line 127 "src/live.c"
static partialhyp_t *parthyp  =    (partialhyp_t *)((void *)0);
#line 128 "src/live.c"
static float32 *dummyframe  ;
#line 134 "src/live.c"
barrier_t *score_barrier  ;
#line 141 "src/live.c"
static kb_t live_kb  ;
#line 139 "src/live.c"
void live_initialize_decoder(char *live_args ) 
{ 
  int32 maxcepvecs ;
  int32 maxhyplen ;
  int32 samprate ;
  int32 ceplen ;
  param_t *fe_param ;
  char const   *uttIdNotDefined ;
  void const   *tmp___0 ;
  void const   *tmp___1 ;
  void const   *tmp___2 ;
  void const   *tmp___3 ;
  void const   *tmp___4 ;
  void const   *tmp___5 ;
  void *tmp___6 ;
  void *tmp___7 ;
  void const   *tmp___8 ;
  void const   *tmp___9 ;
  void const   *tmp___10 ;
  void const   *tmp___11 ;
  void const   *tmp___12 ;
  void *tmp___13 ;

  {
#line 144
  uttIdNotDefined = "null";
#line 146
  parse_args_file(live_args);
#line 147
  unlimit();
#line 148
  kb_init(& live_kb);
#line 149
  kb = & live_kb;
#line 150
  kbcore = kb->kbcore;
#line 152
  kb->uttid = __ckd_salloc__(uttIdNotDefined, "src/live.c", 152);
#line 153
  tmp___0 = cmd_ln_access((char *)"-hmmdump");
#line 153
  if (*((int32 *)tmp___0)) {
#line 153
    hmmdumpfp = stderr;
  } else {
#line 153
    hmmdumpfp = (FILE *)((void *)0);
  }
#line 154
  tmp___1 = cmd_ln_access((char *)"-maxwpf");
#line 154
  maxwpf = *((int32 *)tmp___1);
#line 155
  tmp___2 = cmd_ln_access((char *)"-maxhistpf");
#line 155
  maxhistpf = *((int32 *)tmp___2);
#line 156
  tmp___3 = cmd_ln_access((char *)"-maxhmmpf");
#line 156
  maxhmmpf = *((int32 *)tmp___3);
#line 157
  tmp___4 = cmd_ln_access((char *)"-ptranskip");
#line 157
  ptranskip = *((int32 *)tmp___4);
#line 159
  tmp___5 = cmd_ln_access((char *)"-maxhyplen");
#line 159
  maxhyplen = *((int32 *)tmp___5);
#line 160
  if (! parthyp) {
#line 161
    tmp___6 = __ckd_calloc__((size_t )maxhyplen, sizeof(partialhyp_t ), "src/live.c",
                             161);
#line 161
    parthyp = (partialhyp_t *)tmp___6;
  }
#line 163
  tmp___7 = __ckd_calloc__((size_t )1, sizeof(param_t ), "src/live.c", 163);
#line 163
  fe_param = (param_t *)tmp___7;
#line 164
  tmp___8 = cmd_ln_access((char *)"-samprate");
#line 164
  samprate = *((int32 *)tmp___8);
#line 165
  if (samprate != 8000) {
#line 165
    if (samprate != 16000) {
#line 166
      _E__pr_header("src/live.c", 166L, "FATAL_ERROR");
#line 166
      _E__die_error("Sampling rate %s not supported. Must be 8000 or 16000\n", samprate);
    }
  }
#line 168
  fe_param->SAMPLING_RATE = (float32 )samprate;
#line 169
  tmp___9 = cmd_ln_access((char *)"-lowerf");
#line 169
  fe_param->LOWER_FILT_FREQ = *((float32 *)tmp___9);
#line 170
  tmp___10 = cmd_ln_access((char *)"-upperf");
#line 170
  fe_param->UPPER_FILT_FREQ = *((float32 *)tmp___10);
#line 171
  tmp___11 = cmd_ln_access((char *)"-nfilt");
#line 171
  fe_param->NUM_FILTERS = *((int32 *)tmp___11);
#line 172
  fe_param->FRAME_RATE = 100;
#line 173
  fe_param->PRE_EMPHASIS_ALPHA = (float32 )0.97;
#line 174
  fe = fe_init(fe_param);
#line 175
  if (! fe) {
#line 176
    _E__pr_header("src/live.c", 176L, "FATAL_ERROR");
#line 176
    _E__die_error("Front end initialization fe_init() failed\n");
  }
#line 178
  tmp___12 = cmd_ln_access((char *)"-maxcepvecs");
#line 178
  maxcepvecs = *((int32 *)tmp___12);
#line 179
  ceplen = (kbcore->fcb)->cepsize;
#line 181
  tmp___13 = __ckd_calloc__((size_t )ceplen, sizeof(float32 ), "src/live.c", 181);
#line 181
  dummyframe = (float32 *)tmp___13;
#line 184
  score_barrier = thread_barrier_init(1);
#line 185
  if (! score_barrier) {
#line 186
    _E__pr_header("src/live.c", 186L, "FATAL_ERROR");
#line 186
    _E__die_error("Cannot initialize score_barrier\n");
  }
#line 188
  return;
}
}
#line 192 "src/live.c"
int32 live_free_memory(void) 
{ 


  {
#line 194
  parse_args_free();
#line 195
  fe_close(fe);
#line 196
  free((void *)kb->uttid);
#line 197
  kb_free(kb);
#line 198
  free((void *)dummyframe);
#line 199
  free((void *)parthyp);
#line 201
  thread_barrier_destroy(score_barrier);
#line 203
  return (0);
}
}
#line 216 "src/live.c"
int32 live_get_partialhyp(int32 endutt ) 
{ 
  int32 id ;
  int32 nwds ;
  glist_t hyp ;
  gnode_t *gn ;
  hyp_t *h ;
  dict_t *dict ;
  char *tmp___4 ;

  {
#line 224
  dict = (kb->kbcore)->dict;
#line 225
  if (endutt) {
#line 226
    id = vithist_utt_end(kb->vithist, kb->kbcore);
  } else {
#line 228
    id = vithist_partialutt_end(kb->vithist, kb->kbcore);
  }
#line 230
  if (id > 0) {
#line 231
    hyp = vithist_backtrace(kb->vithist, id);
#line 233
    gn = hyp;
#line 233
    nwds = 0;
#line 233
    while (gn) {
#line 234
      h = (hyp_t *)gn->data.ptr;
#line 235
      if ((unsigned long )(parthyp + nwds)->word != (unsigned long )((void *)0)) {
#line 236
        free((void *)(parthyp + nwds)->word);
#line 237
        (parthyp + nwds)->word = (char *)((void *)0);
      }
#line 239
      tmp___4 = __strdup((char const   *)(dict->word + h->id)->word);
#line 239
      (parthyp + nwds)->word = tmp___4;
#line 240
      (parthyp + nwds)->sf = h->sf;
#line 241
      (parthyp + nwds)->ef = h->ef;
#line 242
      (parthyp + nwds)->ascr = h->ascr;
#line 243
      (parthyp + nwds)->lscr = h->lscr;
#line 233
      gn = gn->next;
#line 233
      nwds ++;
    }
#line 245
    if ((unsigned long )(parthyp + nwds)->word != (unsigned long )((void *)0)) {
#line 246
      free((void *)(parthyp + nwds)->word);
#line 247
      (parthyp + nwds)->word = (char *)((void *)0);
    }
#line 250
    gn = hyp;
#line 250
    while (1) {
#line 250
      if (gn) {
#line 250
        if (! gn->next) {
#line 250
          break;
        }
      } else {
#line 250
        break;
      }
#line 251
      h = (hyp_t *)gn->data.ptr;
#line 252
      free((void *)h);
#line 250
      gn = gn->next;
    }
#line 254
    glist_free(hyp);
  } else {
#line 256
    nwds = 0;
#line 257
    if ((unsigned long )(parthyp + nwds)->word != (unsigned long )((void *)0)) {
#line 258
      free((void *)(parthyp + nwds)->word);
#line 259
      (parthyp + nwds)->word = (char *)((void *)0);
    }
  }
#line 263
  return (nwds);
}
}
#line 277 "src/live.c"
int32 sample_blk  =    0;
#line 283 "src/live.c"
static int32 live_begin_new_utt  =    1;
#line 284 "src/live.c"
static int32 frmno  ;
#line 280 "src/live.c"
int32 live_utt_decode_block(int16 *samples , int32 nsamples , int32 live_endutt ,
                            partialhyp_t **ohyp ) 
{ 
  float32 **live_feat ;
  int32 live_nfr ;
  int32 live_nfeatvec ;
  int32 nwds ;
  float32 **mfcbuf ;

  {
#line 295
  if (live_begin_new_utt) {
#line 296
    fe_start_utt(fe);
#line 297
    utt_begin(kb);
#line 298
    frmno = 0;
#line 299
    kb->nfr = 0;
#line 300
    kb->utt_hmm_eval = 0;
#line 301
    kb->utt_sen_eval = 0;
#line 302
    kb->utt_gau_eval = 0;
#line 303
    live_begin_new_utt = 0;
  }
#line 306
  sample_blk ++;
#line 309
  mfcbuf = (float32 **)((void *)0);
#line 311
  live_nfr = fe_process_utt(fe, samples, nsamples, & mfcbuf);
#line 312
  if (live_endutt) {
#line 313
    fe_end_utt(fe, dummyframe);
  }
#line 316
  live_nfeatvec = feat_s2mfc2feat_block(kbcore->fcb, mfcbuf, live_nfr, live_begin_new_utt,
                                        live_endutt, & live_feat);
#line 319
  _E__pr_info_header("src/live.c", 319L, "INFO");
#line 319
  _E__pr_info("live_nfeatvec: %ld\n", live_nfeatvec);
#line 323
  if (sample_blk <= 0) {
#line 324
    single_utt_decode_block(live_feat, live_nfeatvec, & frmno, kb, maxwpf, maxhistpf,
                            maxhmmpf, ptranskip, hmmdumpfp);
  } else {
#line 327
    utt_decode_block(live_feat, live_nfeatvec, & frmno, kb, maxwpf, maxhistpf, maxhmmpf,
                     ptranskip, hmmdumpfp);
  }
#line 331
  nwds = live_get_partialhyp(live_endutt);
#line 332
  *ohyp = parthyp;
#line 335
  if (live_endutt) {
#line 336
    live_begin_new_utt = 1;
#line 337
    kb->tot_fr += kb->nfr;
#line 338
    utt_end(kb);
  } else {
#line 341
    live_begin_new_utt = 0;
  }
#line 347
  ckd_free_2d((void **)mfcbuf);
#line 350
  return (nwds);
}
}
#line 1 "main_live_pretend.o"
#pragma merger("0","/tmp/cil-al7HWFag.i","-g,-O4")
#line 150 "/usr/include/x86_64-linux-gnu/bits/mathinline.h"
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__, __always_inline__)) __signbitl)(long double __x )  __attribute__((__const__)) ;
#line 150 "/usr/include/x86_64-linux-gnu/bits/mathinline.h"
__inline extern int ( __attribute__((__leaf__, __always_inline__)) __signbitl)(long double __x ) 
{ 
  union __anonunion___u_29___26 __u ;

  {
#line 153
  __u.__l = __x;
#line 154
  return ((__u.__i[2] & 32768) != 0);
}
}
#line 108 "src/main_live_pretend.c"
int main(int argc , char **argv ) 
{ 
  short *samps ;
  int i ;
  int j ;
  int buflen ;
  int endutt ;
  int blksize ;
  int nhypwds ;
  int nsamp ;
  char *argsfile ;
  char *ctlfile ;
  char *indir ;
  char filename[512] ;
  char cepfile[512] ;
  partialhyp_t *parthyp___0 ;
  FILE *fp ;
  FILE *sfp ;
  void *tmp ;
  size_t tmp___0 ;
  int tmp___1 ;

  {
#line 117
  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"At the beginning\n");
#line 118
  if (argc != 4) {
#line 119
    argsfile = (char *)((void *)0);
#line 120
    parse_args_file(argsfile);
#line 121
    _E__pr_header("src/main_live_pretend.c", 121L, "FATAL_ERROR");
#line 121
    _E__die_error("\nUSAGE: %s <ctlfile> <inrawdir> <argsfile>\n", *(argv + 0));
  }
#line 123
  ctlfile = *(argv + 1);
#line 123
  indir = *(argv + 2);
#line 123
  argsfile = *(argv + 3);
#line 124
  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"before calloc\n");
#line 125
  tmp = calloc((size_t )1000000, sizeof(short ));
#line 125
  samps = (short *)tmp;
#line 126
  blksize = 2000;
#line 128
  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"after calloc\n");
#line 129
  fp = fopen((char const   * __restrict  )ctlfile, (char const   * __restrict  )"r");
#line 129
  if ((unsigned long )fp == (unsigned long )((void *)0)) {
#line 130
    _E__pr_header("src/main_live_pretend.c", 130L, "FATAL_ERROR");
#line 130
    _E__die_error("Unable to read %s\n", ctlfile);
  }
#line 132
  live_initialize_decoder(argsfile);
#line 133
  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"after initialize decode\n");
#line 139
  while (1) {
#line 139
    tmp___1 = fscanf((FILE * __restrict  )fp, (char const   * __restrict  )"%s", filename);
#line 139
    if (! (tmp___1 != -1)) {
#line 139
      break;
    }
#line 140
    sprintf((char * __restrict  )(cepfile), (char const   * __restrict  )"%s/%s.raw",
            indir, filename);
#line 141
    sfp = fopen((char const   * __restrict  )(cepfile), (char const   * __restrict  )"rb");
#line 141
    if ((unsigned long )sfp == (unsigned long )((void *)0)) {
#line 142
      _E__pr_header("src/main_live_pretend.c", 142L, "FATAL_ERROR");
#line 142
      _E__die_error("Unable to read %s\n", cepfile);
    }
#line 143
    tmp___0 = fread((void * __restrict  )samps, sizeof(short ), (size_t )1000000,
                    (FILE * __restrict  )sfp);
#line 143
    nsamp = (int )tmp___0;
#line 144
    fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )"%d samples in file %s.\nWill be decoded in blocks of %d\n",
            nsamp, cepfile, blksize);
#line 145
    fflush(stdout);
#line 145
    fclose(sfp);
#line 147
    i = 0;
#line 147
    while (i < nsamp) {
#line 148
      if (i + blksize < nsamp) {
#line 148
        buflen = blksize;
      } else {
#line 148
        buflen = nsamp - i;
      }
#line 149
      if (i + blksize <= nsamp - 1) {
#line 149
        endutt = 0;
      } else {
#line 149
        endutt = 1;
      }
#line 150
      nhypwds = live_utt_decode_block(samps + i, buflen, endutt, & parthyp___0);
#line 152
      _E__pr_info_header("src/main_live_pretend.c", 152L, "INFO");
#line 152
      _E__pr_info("PARTIAL HYP:");
#line 153
      if (nhypwds > 0) {
#line 154
        j = 0;
#line 154
        while (j < nhypwds) {
#line 154
          fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )" %s",
                  (parthyp___0 + j)->word);
#line 154
          j ++;
        }
      }
#line 155
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"\n");
#line 147
      i += blksize;
    }
  }
#line 159
  return (0);
}
}
