/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is true */

#line 4 "/usr/local/ddv/models/con2/include/asm/posix_types.h"
typedef unsigned long __kernel_ino_t;
#line 5 "/usr/local/ddv/models/con2/include/asm/posix_types.h"
typedef unsigned short __kernel_mode_t;
#line 12 "/usr/local/ddv/models/con2/include/asm/posix_types.h"
typedef unsigned int __kernel_size_t;
#line 13 "/usr/local/ddv/models/con2/include/asm/posix_types.h"
typedef int __kernel_ssize_t;
#line 4 "/usr/local/ddv/models/con2/include/asm/types.h"
typedef unsigned short umode_t;
#line 13 "/usr/local/ddv/models/con2/include/asm/types.h"
typedef unsigned int __u32;
#line 9 "/usr/local/ddv/models/con2/include/linux/types.h"
typedef __u32 __kernel_dev_t;
#line 11 "/usr/local/ddv/models/con2/include/linux/types.h"
typedef __kernel_dev_t dev_t;
#line 12 "/usr/local/ddv/models/con2/include/linux/types.h"
typedef __kernel_ino_t ino_t;
#line 13 "/usr/local/ddv/models/con2/include/linux/types.h"
typedef __kernel_mode_t mode_t;
#line 30 "/usr/local/ddv/models/con2/include/linux/types.h"
typedef long long loff_t;
#line 38 "/usr/local/ddv/models/con2/include/linux/types.h"
typedef __kernel_size_t size_t;
#line 43 "/usr/local/ddv/models/con2/include/linux/types.h"
typedef __kernel_ssize_t ssize_t;
#line 44 "/usr/local/ddv/models/con2/include/ddverify/satabs.h"
struct __pthread_t_struct {
   int id ;
};
#line 49 "/usr/local/ddv/models/con2/include/ddverify/satabs.h"
struct __pthread_attr_t_struct {
   int dummy ;
};
#line 54 "/usr/local/ddv/models/con2/include/ddverify/satabs.h"
typedef struct __pthread_t_struct pthread_t;
#line 55 "/usr/local/ddv/models/con2/include/ddverify/satabs.h"
typedef struct __pthread_attr_t_struct pthread_attr_t;
#line 6 "/usr/local/ddv/models/con2/include/asm/atomic.h"
typedef int atomic_t;
#line 67 "/usr/local/ddv/models/con2/include/linux/gfp.h"
struct page;
#line 4 "/usr/local/ddv/models/con2/include/linux/dcache.h"
struct inode;
#line 4 "/usr/local/ddv/models/con2/include/linux/dcache.h"
struct dentry {
   struct inode *d_inode ;
};
#line 83 "/usr/local/ddv/models/con2/include/linux/fs.h"
struct iovec;
#line 84
struct poll_table_struct;
#line 85
struct vm_area_struct;
#line 90 "/usr/local/ddv/models/con2/include/linux/fs.h"
struct address_space {
   struct inode *host ;
};
#line 94
struct file_operations;
#line 94 "/usr/local/ddv/models/con2/include/linux/fs.h"
struct file {
   struct dentry *f_dentry ;
   struct file_operations *f_op ;
   atomic_t f_count ;
   unsigned int f_flags ;
   mode_t f_mode ;
   loff_t f_pos ;
   void *private_data ;
   struct address_space *f_mapping ;
};
#line 105
struct gendisk;
#line 105 "/usr/local/ddv/models/con2/include/linux/fs.h"
struct block_device {
   struct inode *bd_inode ;
   struct gendisk *bd_disk ;
   struct block_device *bd_contains ;
   unsigned int bd_block_size ;
};
#line 113
struct cdev;
#line 113 "/usr/local/ddv/models/con2/include/linux/fs.h"
struct inode {
   umode_t i_mode ;
   struct block_device *i_bdev ;
   dev_t i_rdev ;
   loff_t i_size ;
   struct cdev *i_cdev ;
};
#line 122 "/usr/local/ddv/models/con2/include/linux/fs.h"
struct __anonstruct_read_descriptor_t_4 {
   size_t written ;
   size_t count ;
};
#line 122 "/usr/local/ddv/models/con2/include/linux/fs.h"
typedef struct __anonstruct_read_descriptor_t_4 read_descriptor_t;
#line 130 "/usr/local/ddv/models/con2/include/linux/fs.h"
struct file_lock {
   int something ;
};
#line 134
struct module;
#line 134 "/usr/local/ddv/models/con2/include/linux/fs.h"
struct file_operations {
   struct module *owner ;
   loff_t (*llseek)(struct file * , loff_t  , int  ) ;
   ssize_t (*read)(struct file * , char * , size_t  , loff_t * ) ;
   ssize_t (*write)(struct file * , char const   * , size_t  , loff_t * ) ;
   int (*readdir)(struct file * , void * , int (*)(void * , char const   * , int  ,
                                                   loff_t  , ino_t  , unsigned int  ) ) ;
   unsigned int (*poll)(struct file * , struct poll_table_struct * ) ;
   int (*ioctl)(struct inode * , struct file * , unsigned int  , unsigned long  ) ;
   long (*unlocked_ioctl)(struct file * , unsigned int  , unsigned long  ) ;
   long (*compat_ioctl)(struct file * , unsigned int  , unsigned long  ) ;
   int (*mmap)(struct file * , struct vm_area_struct * ) ;
   int (*open)(struct inode * , struct file * ) ;
   int (*flush)(struct file * ) ;
   int (*release)(struct inode * , struct file * ) ;
   int (*fsync)(struct file * , struct dentry * , int datasync ) ;
   int (*fasync)(int  , struct file * , int  ) ;
   int (*lock)(struct file * , int  , struct file_lock * ) ;
   ssize_t (*readv)(struct file * , struct iovec  const  * , unsigned long  , loff_t * ) ;
   ssize_t (*writev)(struct file * , struct iovec  const  * , unsigned long  , loff_t * ) ;
   ssize_t (*sendfile)(struct file * , loff_t * , size_t  , int (*)(read_descriptor_t * ,
                                                                    struct page * ,
                                                                    unsigned long  ,
                                                                    unsigned long  ) ,
                       void * ) ;
   ssize_t (*sendpage)(struct file * , struct page * , int  , size_t  , loff_t * ,
                       int  ) ;
   unsigned long (*get_unmapped_area)(struct file * , unsigned long  , unsigned long  ,
                                      unsigned long  , unsigned long  ) ;
   int (*check_flags)(int  ) ;
   int (*dir_notify)(struct file *filp , unsigned long arg ) ;
   int (*flock)(struct file * , int  , struct file_lock * ) ;
   int (*open_exec)(struct inode * ) ;
};
#line 4 "/usr/local/ddv/models/con2/include/linux/cdev.h"
struct cdev {
   struct module *owner ;
   struct file_operations *ops ;
   dev_t dev ;
   unsigned int count ;
};
#line 13 "/usr/local/ddv/models/con2/include/ddverify/cdev.h"
struct ddv_cdev {
   struct cdev *cdevp ;
   struct file filp ;
   struct inode inode ;
   int open ;
};
#line 30 "/usr/local/ddv/models/con2/include/asm/types.h"
typedef unsigned long long u64;
#line 91 "/usr/local/ddv/models/con2/include/linux/types.h"
typedef unsigned long sector_t;
#line 15 "/usr/local/ddv/models/con2/include/ddverify/pthread.h"
struct __pthread_t_struct___0 {
   int id ;
};
#line 25 "/usr/local/ddv/models/con2/include/ddverify/pthread.h"
struct __pthread_mutex_t_struct {
   _Bool locked ;
};
#line 30 "/usr/local/ddv/models/con2/include/ddverify/pthread.h"
struct __pthread_mutexattr_t_struct {
   int dummy ;
};
#line 50 "/usr/local/ddv/models/con2/include/ddverify/pthread.h"
typedef struct __pthread_t_struct___0 pthread_t___0;
#line 52 "/usr/local/ddv/models/con2/include/ddverify/pthread.h"
typedef struct __pthread_mutex_t_struct pthread_mutex_t;
#line 53 "/usr/local/ddv/models/con2/include/ddverify/pthread.h"
typedef struct __pthread_mutexattr_t_struct pthread_mutexattr_t;
#line 9 "/usr/local/ddv/models/con2/include/linux/list.h"
struct list_head {
   struct list_head *next ;
   struct list_head *prev ;
};
#line 4 "/usr/local/ddv/models/con2/include/linux/spinlock_types.h"
struct __anonstruct_spinlock_t_9 {
   int init ;
   int locked ;
};
#line 4 "/usr/local/ddv/models/con2/include/linux/spinlock_types.h"
typedef struct __anonstruct_spinlock_t_9 spinlock_t;
#line 4 "/usr/local/ddv/models/con2/include/linux/timer.h"
struct timer_list {
   unsigned long expires ;
   void (*function)(unsigned long  ) ;
   unsigned long data ;
   short __ddv_active ;
   short __ddv_init ;
};
#line 82 "/usr/local/ddv/models/con2/include/linux/fs.h"
struct hd_geometry;
#line 168 "/usr/local/ddv/models/con2/include/linux/fs.h"
struct block_device_operations {
   int (*open)(struct inode * , struct file * ) ;
   int (*release)(struct inode * , struct file * ) ;
   int (*ioctl)(struct inode * , struct file * , unsigned int  , unsigned long  ) ;
   long (*unlocked_ioctl)(struct file * , unsigned int  , unsigned long  ) ;
   long (*compat_ioctl)(struct file * , unsigned int  , unsigned long  ) ;
   int (*direct_access)(struct block_device * , sector_t  , unsigned long * ) ;
   int (*media_changed)(struct gendisk * ) ;
   int (*revalidate_disk)(struct gendisk * ) ;
   int (*getgeo)(struct block_device * , struct hd_geometry * ) ;
   struct module *owner ;
};
#line 18 "/usr/local/ddv/models/con2/include/linux/ioport.h"
struct resource {
   char const   *name ;
   unsigned long start ;
   unsigned long end ;
   unsigned long flags ;
};
#line 24 "/usr/local/ddv/models/con2/include/linux/module.h"
struct module {
   int something ;
};
#line 8 "/usr/local/ddv/models/con2/include/linux/pm.h"
struct pm_message {
   int event ;
};
#line 8 "/usr/local/ddv/models/con2/include/linux/pm.h"
typedef struct pm_message pm_message_t;
#line 25 "/usr/local/ddv/models/con2/include/linux/device.h"
struct device {
   void *driver_data ;
   void (*release)(struct device *dev ) ;
};
#line 17 "/usr/local/ddv/models/con2/include/linux/genhd.h"
struct request_queue;
#line 17 "/usr/local/ddv/models/con2/include/linux/genhd.h"
struct gendisk {
   int major ;
   int first_minor ;
   int minors ;
   char disk_name[32] ;
   struct block_device_operations *fops ;
   struct request_queue *queue ;
   void *private_data ;
   int flags ;
   struct device *driverfs_dev ;
   char devfs_name[64] ;
};
#line 12 "/usr/local/ddv/models/con2/include/linux/workqueue.h"
struct work_struct {
   unsigned long pending ;
   void (*func)(void * ) ;
   void *data ;
   int init ;
};
#line 9 "/usr/local/ddv/models/con2/include/linux/mm_types.h"
struct page {
   int something ;
};
#line 4 "/usr/local/ddv/models/con2/include/asm/ptrace.h"
struct pt_regs {
   int something ;
};
#line 28 "/usr/local/ddv/models/con2/include/linux/interrupt.h"
typedef int irqreturn_t;
#line 34 "/usr/local/ddv/models/con2/include/linux/interrupt.h"
struct tasklet_struct {
   atomic_t count ;
   void (*func)(unsigned long  ) ;
   unsigned long data ;
   int init ;
};
#line 11 "/usr/local/ddv/models/con2/include/linux/backing-dev.h"
struct backing_dev_info {
   unsigned long ra_pages ;
   unsigned long state ;
   unsigned int capabilities ;
};
#line 6 "/usr/local/ddv/models/con2/include/linux/bio.h"
struct bio_vec {
   struct page *bv_page ;
   unsigned int bv_len ;
   unsigned int bv_offset ;
};
#line 13
struct bio;
#line 14 "/usr/local/ddv/models/con2/include/linux/bio.h"
typedef int bio_end_io_t(struct bio * , unsigned int  , int  );
#line 17 "/usr/local/ddv/models/con2/include/linux/bio.h"
struct bio {
   sector_t bi_sector ;
   struct bio *bi_next ;
   struct block_device *bi_bdev ;
   unsigned long bi_flags ;
   unsigned long bi_rw ;
   unsigned short bi_vcnt ;
   unsigned short bi_idx ;
   unsigned short bi_phys_segments ;
   unsigned int bi_size ;
   struct bio_vec *bi_io_vec ;
   bio_end_io_t *bi_end_io ;
   void *bi_private ;
};
#line 4 "/usr/local/ddv/models/con2/include/linux/elevator.h"
struct request;
#line 23 "/usr/local/ddv/models/con2/include/linux/blkdev.h"
typedef struct request_queue request_queue_t;
#line 25 "/usr/local/ddv/models/con2/include/linux/blkdev.h"
typedef void request_fn_proc(request_queue_t *q );
#line 26 "/usr/local/ddv/models/con2/include/linux/blkdev.h"
typedef int make_request_fn(request_queue_t *q , struct bio *bio );
#line 27 "/usr/local/ddv/models/con2/include/linux/blkdev.h"
typedef void unplug_fn(request_queue_t * );
#line 32
enum rq_cmd_type_bits {
    REQ_TYPE_FS = 1,
    REQ_TYPE_BLOCK_PC = 2,
    REQ_TYPE_SENSE = 3,
    REQ_TYPE_PM_SUSPEND = 4,
    REQ_TYPE_PM_RESUME = 5,
    REQ_TYPE_PM_SHUTDOWN = 6,
    REQ_TYPE_FLUSH = 7,
    REQ_TYPE_SPECIAL = 8,
    REQ_TYPE_LINUX_BLOCK = 9,
    REQ_TYPE_ATA_CMD = 10,
    REQ_TYPE_ATA_TASK = 11,
    REQ_TYPE_ATA_TASKFILE = 12,
    REQ_TYPE_ATA_PC = 13
} ;
#line 54 "/usr/local/ddv/models/con2/include/linux/blkdev.h"
struct request_queue {
   request_fn_proc *request_fn ;
   make_request_fn *make_request_fn ;
   unplug_fn *unplug_fn ;
   struct backing_dev_info backing_dev_info ;
   void *queuedata ;
   unsigned long queue_flags ;
   spinlock_t *queue_lock ;
   unsigned short hardsect_size ;
   int __ddv_genhd_no ;
   int __ddv_queue_alive ;
};
#line 90 "/usr/local/ddv/models/con2/include/linux/blkdev.h"
struct request {
   struct list_head queuelist ;
   struct list_head donelist ;
   request_queue_t *q ;
   unsigned long flags ;
   unsigned int cmd_flags ;
   enum rq_cmd_type_bits cmd_type ;
   struct bio *bio ;
   void *completion_data ;
   struct gendisk *rq_disk ;
   sector_t sector ;
   unsigned long nr_sectors ;
   unsigned int current_nr_sectors ;
   char *buffer ;
   int errors ;
   unsigned short nr_phys_segments ;
   unsigned char cmd[16] ;
};
#line 15 "/usr/local/ddv/models/con2/include/ddverify/genhd.h"
struct ddv_genhd {
   struct gendisk *gd ;
   struct inode inode ;
   struct file file ;
   struct request current_request ;
   int requests_open ;
};
#line 6 "/usr/local/ddv/models/con2/include/linux/mod_devicetable.h"
typedef unsigned long kernel_ulong_t;
#line 10 "/usr/local/ddv/models/con2/include/linux/mod_devicetable.h"
struct pci_device_id {
   __u32 vendor ;
   __u32 device ;
   __u32 subvendor ;
   __u32 subdevice ;
   __u32 class ;
   __u32 class_mask ;
   kernel_ulong_t driver_data ;
};
#line 40 "/usr/local/ddv/models/con2/include/linux/pci.h"
typedef int pci_power_t;
#line 43
struct pci_bus;
#line 43 "/usr/local/ddv/models/con2/include/linux/pci.h"
struct pci_dev {
   struct pci_bus *bus ;
   unsigned int devfn ;
   unsigned short vendor ;
   unsigned short device ;
   u64 dma_mask ;
   struct device dev ;
   unsigned int irq ;
   struct resource resource[12] ;
};
#line 62 "/usr/local/ddv/models/con2/include/linux/pci.h"
struct pci_bus {
   unsigned char number ;
};
#line 67 "/usr/local/ddv/models/con2/include/linux/pci.h"
struct pci_driver {
   char *name ;
   struct pci_device_id  const  *id_table ;
   int (*probe)(struct pci_dev *dev , struct pci_device_id  const  *id ) ;
   void (*remove)(struct pci_dev *dev ) ;
   int (*suspend)(struct pci_dev *dev , pm_message_t state ) ;
   int (*resume)(struct pci_dev *dev ) ;
   int (*enable_wake)(struct pci_dev *dev , pci_power_t state , int enable ) ;
   void (*shutdown)(struct pci_dev *dev ) ;
};
#line 6 "/usr/local/ddv/models/con2/include/ddverify/pci.h"
struct ddv_pci_driver {
   struct pci_driver *pci_driver ;
   struct pci_dev pci_dev ;
   unsigned int no_pci_device_id ;
   int dev_initialized ;
};
#line 9 "/usr/local/ddv/models/con2/include/ddverify/interrupt.h"
struct registered_irq {
   irqreturn_t (*handler)(int  , void * , struct pt_regs * ) ;
   void *dev_id ;
};
#line 10 "/usr/local/ddv/models/con2/include/ddverify/tasklet.h"
struct ddv_tasklet {
   struct tasklet_struct *tasklet ;
   unsigned short is_running ;
};
#line 10 "/usr/local/ddv/models/con2/include/ddverify/timer.h"
struct ddv_timer {
   struct timer_list *timer ;
};
#line 88 "/usr/local/ddv/models/con2/include/linux/types.h"
typedef unsigned int gfp_t;
#line 8 "/usr/local/ddv/models/con2/include/asm/posix_types.h"
typedef int __kernel_pid_t;
#line 27 "/usr/local/ddv/models/con2/include/asm/types.h"
typedef unsigned int u32;
#line 16 "/usr/local/ddv/models/con2/include/linux/types.h"
typedef __kernel_pid_t pid_t;
#line 7 "/usr/local/ddv/models/con2/include/asm/current.h"
struct task_struct;
#line 11 "/usr/local/ddv/models/con2/include/linux/wait.h"
struct __wait_queue {
   int something ;
};
#line 14 "/usr/local/ddv/models/con2/include/linux/wait.h"
typedef struct __wait_queue wait_queue_t;
#line 16 "/usr/local/ddv/models/con2/include/linux/wait.h"
struct __wait_queue_head {
   int number_process_waiting ;
   int wakeup ;
   int init ;
};
#line 22 "/usr/local/ddv/models/con2/include/linux/wait.h"
typedef struct __wait_queue_head wait_queue_head_t;
#line 10 "/usr/local/ddv/models/con2/include/asm/signal.h"
struct __anonstruct_sigset_t_3 {
   unsigned long sig[2] ;
};
#line 10 "/usr/local/ddv/models/con2/include/asm/signal.h"
typedef struct __anonstruct_sigset_t_3 sigset_t;
#line 24 "/usr/local/ddv/models/con2/include/linux/sched.h"
struct sighand_struct {
   spinlock_t siglock ;
};
#line 28 "/usr/local/ddv/models/con2/include/linux/sched.h"
struct task_struct {
   long state ;
   pid_t pid ;
   char comm[16] ;
   sigset_t blocked ;
   sigset_t real_blocked ;
   struct sighand_struct *sighand ;
};
#line 12 "/usr/local/ddv/models/con2/include/linux/fd.h"
struct floppy_struct {
   unsigned int size ;
   unsigned int sect ;
   unsigned int head ;
   unsigned int track ;
   unsigned int stretch ;
   unsigned char gap ;
   unsigned char rate ;
   unsigned char spec1 ;
   unsigned char fmt_gap ;
   char const   *name ;
};
#line 65 "/usr/local/ddv/models/con2/include/linux/fd.h"
struct format_descr {
   unsigned int device ;
   unsigned int head ;
   unsigned int track ;
};
#line 80 "/usr/local/ddv/models/con2/include/linux/fd.h"
struct floppy_max_errors {
   unsigned int abort ;
   unsigned int read_track ;
   unsigned int reset ;
   unsigned int recal ;
   unsigned int reporting ;
};
#line 111 "/usr/local/ddv/models/con2/include/linux/fd.h"
typedef char floppy_drive_name[16];
#line 119 "/usr/local/ddv/models/con2/include/linux/fd.h"
struct floppy_drive_params {
   signed char cmos ;
   unsigned long max_dtr ;
   unsigned long hlt ;
   unsigned long hut ;
   unsigned long srt ;
   unsigned long spinup ;
   unsigned long spindown ;
   unsigned char spindown_offset ;
   unsigned char select_delay ;
   unsigned char rps ;
   unsigned char tracks ;
   unsigned long timeout ;
   unsigned char interleave_sect ;
   struct floppy_max_errors max_errors ;
   char flags ;
   char read_track ;
   short autodetect[8] ;
   int checkfreq ;
   int native_format ;
};
#line 192 "/usr/local/ddv/models/con2/include/linux/fd.h"
struct floppy_drive_struct {
   unsigned long flags ;
   unsigned long spinup_date ;
   unsigned long select_date ;
   unsigned long first_read_date ;
   short probed_format ;
   short track ;
   short maxblock ;
   short maxtrack ;
   int generation ;
   int keep_data ;
   int fd_ref ;
   int fd_device ;
   unsigned long last_checked ;
   char *dmabuf ;
   int bufblocks ;
};
#line 246 "/usr/local/ddv/models/con2/include/linux/fd.h"
struct floppy_fdc_state {
   int spec1 ;
   int spec2 ;
   int dtr ;
   unsigned char version ;
   unsigned char dor ;
   unsigned long address ;
   unsigned int rawcmd : 2 ;
   unsigned int reset : 1 ;
   unsigned int need_configure : 1 ;
   unsigned int perp_mode : 2 ;
   unsigned int has_fifo : 1 ;
   unsigned int driver_version ;
   unsigned char track[4] ;
};
#line 284 "/usr/local/ddv/models/con2/include/linux/fd.h"
struct floppy_write_errors {
   unsigned int write_errors ;
   unsigned long first_error_sector ;
   int first_error_generation ;
   unsigned long last_error_sector ;
   int last_error_generation ;
   unsigned int badness ;
};
#line 318 "/usr/local/ddv/models/con2/include/linux/fd.h"
struct floppy_raw_cmd {
   unsigned int flags ;
   void *data ;
   char *kernel_data ;
   struct floppy_raw_cmd *next ;
   long length ;
   long phys_length ;
   int buffer_length ;
   unsigned char rate ;
   unsigned char cmd_count ;
   unsigned char cmd[16] ;
   unsigned char reply_count ;
   unsigned char reply[16] ;
   int track ;
   int resultcode ;
   int reserved1 ;
   int reserved2 ;
};
#line 4 "/usr/local/ddv/models/con2/include/linux/hdreg.h"
struct hd_geometry {
   unsigned char heads ;
   unsigned char sectors ;
   unsigned short cylinders ;
   unsigned long start ;
};
#line 20 "/usr/local/ddv/models/con2/include/linux/mutex.h"
struct mutex {
   int locked ;
   int init ;
};
#line 7 "/usr/local/ddv/models/con2/include/linux/sysfs.h"
struct kobject;
#line 10 "/usr/local/ddv/models/con2/include/linux/sysfs.h"
struct attribute {
   char const   *name ;
   struct module *owner ;
   mode_t mode ;
};
#line 30 "/usr/local/ddv/models/con2/include/linux/kobject.h"
struct kobject {
   int something ;
};
#line 68 "/usr/local/ddv/models/con2/include/linux/device.h"
struct device_attribute {
   struct attribute attr ;
   ssize_t (*show)(struct device *dev , struct device_attribute *attr , char *buf ) ;
   ssize_t (*store)(struct device *dev , struct device_attribute *attr , char const   *buf ,
                    size_t count ) ;
};
#line 10 "/usr/local/ddv/models/con2/include/linux/poll.h"
struct poll_table_struct {
   int something ;
};
#line 6 "/usr/local/ddv/models/con2/include/linux/platform_device.h"
struct platform_device {
   char const   *name ;
   u32 id ;
   struct device dev ;
   u32 num_resources ;
   struct resource *resource ;
};
#line 221 "floppy.c"
struct completion;
#line 13 "/usr/local/ddv/models/con2/include/linux/completion.h"
struct completion {
   unsigned int done ;
   wait_queue_head_t wait ;
};
#line 365 "floppy.c"
struct __anonstruct_default_drive_params_14 {
   struct floppy_drive_params params ;
   char const   *name ;
};
#line 543 "floppy.c"
struct cont_t {
   void (*interrupt)(void) ;
   void (*redo)(void) ;
   void (*error)(void) ;
   void (*done)(int  ) ;
};
#line 656 "floppy.c"
struct output_log {
   unsigned char data ;
   unsigned char status ;
   unsigned long jiffies ;
};
#line 2172 "floppy.c"
struct fparm {
   unsigned char track ;
   unsigned char head ;
   unsigned char sect ;
   unsigned char size ;
};
#line 3464 "floppy.c"
union inparam {
   struct floppy_struct g ;
   struct format_descr f ;
   struct floppy_max_errors max_errors ;
   struct floppy_drive_params dp ;
};
#line 4065 "floppy.c"
struct param_table {
   char const   *name ;
   void (*fn)(int *ints , int param , int param2 ) ;
   int *var ;
   int def_param ;
   int param2 ;
};
#line 34 "/usr/local/ddv/models/con2/include/linux/miscdevice.h"
struct miscdevice {
   int minor ;
   char const   *name ;
   struct file_operations *fops ;
};
#line 7 "/usr/local/ddv/models/con2/include/linux/proc_fs.h"
struct proc_dir_entry {
   int something ;
};
#line 4 "/usr/local/ddv/models/con2/include/asm/semaphore.h"
struct semaphore {
   int init ;
   int locked ;
};
#line 7 "/usr/local/ddv/models/con2/include/asm/posix_types.h"
typedef long __kernel_off_t;
#line 15 "/usr/local/ddv/models/con2/include/linux/types.h"
typedef __kernel_off_t off_t;
#line 6 "/usr/local/ddv/models/con2/include/asm/termbits.h"
typedef unsigned char cc_t;
#line 8 "/usr/local/ddv/models/con2/include/asm/termbits.h"
typedef unsigned int tcflag_t;
#line 11 "/usr/local/ddv/models/con2/include/asm/termbits.h"
struct termios {
   tcflag_t c_iflag ;
   tcflag_t c_oflag ;
   tcflag_t c_cflag ;
   tcflag_t c_lflag ;
   cc_t c_line ;
   cc_t c_cc[19] ;
};
#line 9 "/usr/local/ddv/models/con2/include/linux/tty_driver.h"
struct tty_struct;
#line 12 "/usr/local/ddv/models/con2/include/linux/tty_driver.h"
struct tty_operations {
   int (*open)(struct tty_struct *tty , struct file *filp ) ;
   void (*close)(struct tty_struct *tty , struct file *filp ) ;
   int (*write)(struct tty_struct *tty , unsigned char const   *buf , int count ) ;
   void (*put_char)(struct tty_struct *tty , unsigned char ch ) ;
   void (*flush_chars)(struct tty_struct *tty ) ;
   int (*write_room)(struct tty_struct *tty ) ;
   int (*chars_in_buffer)(struct tty_struct *tty ) ;
   int (*ioctl)(struct tty_struct *tty , struct file *file , unsigned int cmd , unsigned long arg ) ;
   void (*set_termios)(struct tty_struct *tty , struct termios *old ) ;
   void (*throttle)(struct tty_struct *tty ) ;
   void (*unthrottle)(struct tty_struct *tty ) ;
   void (*stop)(struct tty_struct *tty ) ;
   void (*start)(struct tty_struct *tty ) ;
   void (*hangup)(struct tty_struct *tty ) ;
   void (*break_ctl)(struct tty_struct *tty , int state ) ;
   void (*flush_buffer)(struct tty_struct *tty ) ;
   void (*set_ldisc)(struct tty_struct *tty ) ;
   void (*wait_until_sent)(struct tty_struct *tty , int timeout ) ;
   void (*send_xchar)(struct tty_struct *tty , char ch ) ;
   int (*read_proc)(char *page , char **start , off_t off , int count , int *eof ,
                    void *data ) ;
   int (*write_proc)(struct file *file , char const   *buffer , unsigned long count ,
                     void *data ) ;
   int (*tiocmget)(struct tty_struct *tty , struct file *file ) ;
   int (*tiocmset)(struct tty_struct *tty , struct file *file , unsigned int set ,
                   unsigned int clear ) ;
};
#line 43 "/usr/local/ddv/models/con2/include/linux/tty_driver.h"
struct tty_driver {
   int magic ;
   struct cdev cdev ;
   struct module *owner ;
   char const   *driver_name ;
   char const   *name ;
   int name_base ;
   int major ;
   int minor_start ;
   int minor_num ;
   int num ;
   short type ;
   short subtype ;
   struct termios init_termios ;
   int flags ;
   int refcount ;
   struct proc_dir_entry *proc_entry ;
   int (*open)(struct tty_struct *tty , struct file *filp ) ;
   void (*close)(struct tty_struct *tty , struct file *filp ) ;
   int (*write)(struct tty_struct *tty , unsigned char const   *buf , int count ) ;
   void (*put_char)(struct tty_struct *tty , unsigned char ch ) ;
   void (*flush_chars)(struct tty_struct *tty ) ;
   int (*write_room)(struct tty_struct *tty ) ;
   int (*chars_in_buffer)(struct tty_struct *tty ) ;
   int (*ioctl)(struct tty_struct *tty , struct file *file , unsigned int cmd , unsigned long arg ) ;
   void (*set_termios)(struct tty_struct *tty , struct termios *old ) ;
   void (*throttle)(struct tty_struct *tty ) ;
   void (*unthrottle)(struct tty_struct *tty ) ;
   void (*stop)(struct tty_struct *tty ) ;
   void (*start)(struct tty_struct *tty ) ;
   void (*hangup)(struct tty_struct *tty ) ;
   void (*break_ctl)(struct tty_struct *tty , int state ) ;
   void (*flush_buffer)(struct tty_struct *tty ) ;
   void (*set_ldisc)(struct tty_struct *tty ) ;
   void (*wait_until_sent)(struct tty_struct *tty , int timeout ) ;
   void (*send_xchar)(struct tty_struct *tty , char ch ) ;
   int (*read_proc)(char *page , char **start , off_t off , int count , int *eof ,
                    void *data ) ;
   int (*write_proc)(struct file *file , char const   *buffer , unsigned long count ,
                     void *data ) ;
   int (*tiocmget)(struct tty_struct *tty , struct file *file ) ;
   int (*tiocmset)(struct tty_struct *tty , struct file *file , unsigned int set ,
                   unsigned int clear ) ;
};
#line 113 "/usr/local/ddv/models/con2/include/linux/tty.h"
struct tty_struct {
   int magic ;
   struct tty_driver *driver ;
   int index ;
   struct termios *termios ;
   struct termios *termios_locked ;
   char name[64] ;
   unsigned long flags ;
   int count ;
   unsigned char stopped : 1 ;
   unsigned char hw_stopped : 1 ;
   unsigned char flow_stopped : 1 ;
   unsigned char packet : 1 ;
   unsigned int receive_room ;
   wait_queue_head_t write_wait ;
   wait_queue_head_t read_wait ;
   void *disc_data ;
   void *driver_data ;
   unsigned char closing : 1 ;
};
#line 7 "/usr/local/ddv/models/con2/include/ddverify/tty.h"
struct ddv_tty_driver {
   struct tty_driver driver ;
   unsigned short allocated ;
   unsigned short registered ;
};
#line 1 "cdev.o"
#pragma merger("0","/tmp/cil-Gt1ZfmqS.i","")
#line 11 "/usr/local/ddv/models/con2/include/ddverify/ddverify.h"
int current_execution_context  ;
#line 42 "/usr/local/ddv/models/con2/include/ddverify/ddverify.h"
int (*_ddv_module_init)(void)  ;
#line 43 "/usr/local/ddv/models/con2/include/ddverify/ddverify.h"
void (*_ddv_module_exit)(void)  ;
#line 15 "/usr/local/ddv/models/con2/include/ddverify/satabs.h"
extern unsigned short nondet_ushort() ;
#line 16
extern int nondet_int() ;
#line 17
extern unsigned int nondet_uint() ;
#line 19
extern unsigned long nondet_ulong() ;
#line 20
extern char nondet_char() ;
#line 23
extern loff_t nondet_loff_t() ;
#line 24
extern size_t nondet_size_t() ;
#line 57
extern pthread_t nondet_pthread_t() ;
#line 59 "/usr/local/ddv/models/con2/include/ddverify/satabs.h"
__inline extern int pthread_create(pthread_t *__threadp , pthread_attr_t const   *__attr ,
                                   void *(*__start_routine)(void * ) , void *__arg ) 
{ 


  {
#line 65
  *__threadp = nondet_pthread_t();
#line 66
  (*__start_routine)(__arg);
#line 67
  return (0);
}
}
#line 7 "/usr/local/ddv/models/con2/include/linux/jiffies.h"
unsigned long jiffies  ;
#line 12 "/usr/local/ddv/models/con2/include/ddverify/fixed_cdev.h"
struct cdev fixed_cdev[10]  ;
#line 13 "/usr/local/ddv/models/con2/include/ddverify/fixed_cdev.h"
int fixed_cdev_used  =    0;
#line 11 "/usr/local/ddv/models/con2/include/ddverify/cdev.h"
short number_cdev_registered  =    (short)0;
#line 22 "/usr/local/ddv/models/con2/include/ddverify/cdev.h"
struct ddv_cdev cdev_registered[10]  ;
#line 24
void call_cdev_functions(void) ;
#line 21 "/usr/local/ddv/models/con2/src/ddverify/cdev.c"
extern int ( /* missing proto */  __CPROVER_assume)() ;
#line 5 "/usr/local/ddv/models/con2/src/ddverify/cdev.c"
void call_cdev_functions(void) 
{ 
  int cdev_no ;
  int result___0 ;
  loff_t loff_t_value ;
  int int_value ;
  unsigned int uint_value ;
  unsigned long ulong_value ;
  char char_value ;
  size_t size_t_value ;
  unsigned short tmp ;
  int tmp___0 ;
  unsigned short tmp___1 ;

  {
#line 16
  if ((int )number_cdev_registered == 0) {
#line 17
    return;
  }
#line 20
  tmp = nondet_ushort();
#line 20
  cdev_no = (int )tmp;
#line 21
  if (0 <= cdev_no) {
#line 21
    if (cdev_no < (int )number_cdev_registered) {
#line 21
      tmp___0 = 1;
    } else {
#line 21
      tmp___0 = 0;
    }
  } else {
#line 21
    tmp___0 = 0;
  }
#line 21
  __CPROVER_assume(tmp___0);
#line 23
  tmp___1 = nondet_ushort();
#line 23
  switch ((int )tmp___1) {
  case 0: 
#line 25
  if (((cdev_registered[cdev_no].cdevp)->ops)->llseek) {
#line 26
    loff_t_value = nondet_loff_t();
#line 27
    int_value = nondet_int();
#line 29
    (*(((cdev_registered[cdev_no].cdevp)->ops)->llseek))(& cdev_registered[cdev_no].filp,
                                                         loff_t_value, int_value);
  }
#line 33
  break;
  case 1: 
#line 35
  if (((cdev_registered[cdev_no].cdevp)->ops)->read) {
#line 36
    char_value = nondet_char();
#line 37
    size_t_value = nondet_size_t();
#line 39
    (*(((cdev_registered[cdev_no].cdevp)->ops)->read))(& cdev_registered[cdev_no].filp,
                                                       & char_value, size_t_value,
                                                       & loff_t_value);
  }
#line 44
  break;
  case 2: 
#line 47
  break;
  case 3: 
#line 49
  if (((cdev_registered[cdev_no].cdevp)->ops)->write) {
#line 50
    char_value = nondet_char();
#line 51
    size_t_value = nondet_size_t();
#line 53
    (*(((cdev_registered[cdev_no].cdevp)->ops)->write))(& cdev_registered[cdev_no].filp,
                                                        (char const   *)(& char_value),
                                                        size_t_value, & loff_t_value);
  }
#line 58
  break;
  case 4: 
#line 61
  break;
  case 5: 
#line 64
  break;
  case 6: 
#line 67
  break;
  case 7: 
#line 69
  if (((cdev_registered[cdev_no].cdevp)->ops)->ioctl) {
#line 70
    uint_value = nondet_uint();
#line 71
    ulong_value = nondet_ulong();
#line 73
    (*(((cdev_registered[cdev_no].cdevp)->ops)->ioctl))(& cdev_registered[cdev_no].inode,
                                                        & cdev_registered[cdev_no].filp,
                                                        uint_value, ulong_value);
  }
#line 79
  break;
  case 8: 
#line 82
  break;
  case 9: 
#line 85
  break;
  case 10: 
#line 88
  break;
  case 11: 
#line 90
  if (((cdev_registered[cdev_no].cdevp)->ops)->open) {
#line 90
    if (! cdev_registered[cdev_no].open) {
#line 92
      result___0 = (*(((cdev_registered[cdev_no].cdevp)->ops)->open))(& cdev_registered[cdev_no].inode,
                                                                      & cdev_registered[cdev_no].filp);
#line 95
      if (! result___0) {
#line 96
        cdev_registered[cdev_no].open = 1;
      }
    }
  }
#line 99
  break;
  case 12: 
#line 102
  break;
  case 13: 
#line 104
  if (((cdev_registered[cdev_no].cdevp)->ops)->release) {
#line 104
    if (cdev_registered[cdev_no].open) {
#line 106
      result___0 = (*(((cdev_registered[cdev_no].cdevp)->ops)->release))(& cdev_registered[cdev_no].inode,
                                                                         & cdev_registered[cdev_no].filp);
#line 109
      if (! result___0) {
#line 110
        cdev_registered[cdev_no].open = 0;
      }
    }
  }
#line 113
  break;
  case 14: 
#line 116
  break;
  case 15: 
#line 119
  break;
  case 16: 
#line 122
  break;
  case 17: 
#line 125
  break;
  case 18: 
#line 128
  break;
  case 19: 
#line 131
  break;
  case 20: 
#line 134
  break;
  case 21: 
#line 137
  break;
  case 22: 
#line 140
  break;
  case 23: 
#line 143
  break;
  case 24: 
#line 146
  break;
  case 25: 
#line 149
  break;
  case 26: 
#line 152
  break;
  default: 
#line 154
  break;
  }
#line 156
  return;
}
}
#line 1 "char_dev.o"
#pragma merger("0","/tmp/cil-nASnDGt6.i","")
#line 8 "/usr/local/ddv/models/con2/include/linux/slab.h"
extern void kfree(void const   * ) ;
#line 195 "/usr/local/ddv/models/con2/include/linux/fs.h"
__inline int alloc_chrdev_region(dev_t *dev , unsigned int baseminor , unsigned int count ,
                                 char const   *name ) ;
#line 196
__inline int register_chrdev_region(dev_t from , unsigned int count , char const   *name ) ;
#line 199
__inline int register_chrdev(unsigned int major , char const   *name , struct file_operations *fops ) ;
#line 200
__inline int unregister_chrdev(unsigned int major , char const   *name ) ;
#line 11 "/usr/local/ddv/models/con2/include/linux/cdev.h"
__inline void cdev_init(struct cdev *cdev , struct file_operations *fops ) ;
#line 13
__inline struct cdev *cdev_alloc(void) ;
#line 17
__inline int cdev_add(struct cdev *p , dev_t dev , unsigned int count ) ;
#line 19
__inline void cdev_del(struct cdev *p ) ;
#line 9 "/usr/local/ddv/models/con2/src/linux/fs/char_dev.c"
__inline int alloc_chrdev_region(dev_t *dev , unsigned int baseminor , unsigned int count ,
                                 char const   *name ) 
{ 
  int major ;
  int return_value ;
  int tmp ;
  int tmp___0 ;
  unsigned int tmp___1 ;

  {
#line 12
  tmp = nondet_int();
#line 12
  return_value = tmp;
#line 13
  if (return_value == 0) {
#line 13
    tmp___0 = 1;
  } else
#line 13
  if (return_value == -1) {
#line 13
    tmp___0 = 1;
  } else {
#line 13
    tmp___0 = 0;
  }
#line 13
  __CPROVER_assume(tmp___0);
#line 15
  if (return_value == 0) {
#line 16
    tmp___1 = nondet_uint();
#line 16
    major = (int )tmp___1;
#line 17
    *dev = (unsigned int )(major << 20) | baseminor;
  }
#line 20
  return (return_value);
}
}
#line 23 "/usr/local/ddv/models/con2/src/linux/fs/char_dev.c"
__inline int register_chrdev_region(dev_t from , unsigned int count , char const   *name ) 
{ 
  int return_value ;
  int tmp ;
  int tmp___0 ;

  {
#line 25
  tmp = nondet_int();
#line 25
  return_value = tmp;
#line 26
  if (return_value == 0) {
#line 26
    tmp___0 = 1;
  } else
#line 26
  if (return_value == -1) {
#line 26
    tmp___0 = 1;
  } else {
#line 26
    tmp___0 = 0;
  }
#line 26
  __CPROVER_assume(tmp___0);
#line 28
  return (return_value);
}
}
#line 33 "/usr/local/ddv/models/con2/src/linux/fs/char_dev.c"
__inline int register_chrdev(unsigned int major , char const   *name , struct file_operations *fops ) 
{ 
  struct cdev *cdev ;
  int err ;
  int tmp ;

  {
#line 39
  tmp = register_chrdev_region((dev_t )0, 256U, name);
#line 39
  major = (unsigned int )tmp;
#line 41
  cdev = cdev_alloc();
#line 42
  cdev->owner = fops->owner;
#line 43
  cdev->ops = fops;
#line 45
  err = cdev_add(cdev, major << 20, 256U);
#line 47
  if (err) {
#line 48
    kfree((void const   *)cdev);
#line 49
    return (err);
  }
#line 52
  return ((int )major);
}
}
#line 55 "/usr/local/ddv/models/con2/src/linux/fs/char_dev.c"
__inline int unregister_chrdev(unsigned int major , char const   *name ) 
{ 


  {
#line 57
  return (0);
}
}
#line 60 "/usr/local/ddv/models/con2/src/linux/fs/char_dev.c"
__inline struct cdev *cdev_alloc(void) 
{ 
  int tmp ;

  {
#line 62
  if (fixed_cdev_used < 10) {
#line 63
    tmp = fixed_cdev_used;
#line 63
    fixed_cdev_used ++;
#line 63
    return (& fixed_cdev[tmp]);
  }
#line 65
  return ((struct cdev *)0);
}
}
#line 67 "/usr/local/ddv/models/con2/src/linux/fs/char_dev.c"
__inline void cdev_init(struct cdev *cdev , struct file_operations *fops ) 
{ 


  {
#line 69
  cdev->ops = fops;
#line 70
  return;
}
}
#line 72 "/usr/local/ddv/models/con2/src/linux/fs/char_dev.c"
__inline int cdev_add(struct cdev *p , dev_t dev , unsigned int count ) 
{ 
  int return_value ;
  int tmp ;
  int tmp___0 ;

  {
#line 74
  p->dev = dev;
#line 75
  p->count = count;
#line 77
  tmp = nondet_int();
#line 77
  return_value = tmp;
#line 78
  if (return_value == 0) {
#line 78
    tmp___0 = 1;
  } else
#line 78
  if (return_value == -1) {
#line 78
    tmp___0 = 1;
  } else {
#line 78
    tmp___0 = 0;
  }
#line 78
  __CPROVER_assume(tmp___0);
#line 80
  if (return_value == 0) {
#line 81
    if ((int )number_cdev_registered < 10) {
#line 83
      cdev_registered[number_cdev_registered].cdevp = p;
#line 84
      cdev_registered[number_cdev_registered].inode.i_rdev = dev;
#line 85
      cdev_registered[number_cdev_registered].inode.i_cdev = p;
#line 86
      cdev_registered[number_cdev_registered].open = 0;
#line 88
      number_cdev_registered = (short )((int )number_cdev_registered + 1);
    } else {
#line 90
      return (-1);
    }
  }
#line 94
  return (return_value);
}
}
#line 97 "/usr/local/ddv/models/con2/src/linux/fs/char_dev.c"
__inline void cdev_del(struct cdev *p ) 
{ 
  int i ;

  {
#line 101
  i = 0;
#line 101
  while (i < (int )number_cdev_registered) {
#line 102
    if ((unsigned long )cdev_registered[i].cdevp == (unsigned long )p) {
#line 103
      cdev_registered[i].cdevp = (struct cdev *)0;
#line 105
      return;
    }
#line 101
    i ++;
  }
#line 108
  return;
}
}
#line 1 "ddverify.o"
#pragma merger("0","/tmp/cil-W5K7Dsug.i","")
#line 45 "/usr/local/ddv/models/con2/include/ddverify/ddverify.h"
int call_ddv(void) ;
#line 39 "/usr/local/ddv/models/con2/include/ddverify/satabs.h"
extern void __CPROVER_atomic_begin() ;
#line 40
extern void __CPROVER_atomic_end() ;
#line 186 "/usr/local/ddv/models/con2/include/ddverify/pthread.h"
__inline extern int pthread_mutex_init(pthread_mutex_t *__mutex , pthread_mutexattr_t const   *__mutex_attr ) 
{ 
  pthread_mutex_t i ;

  {
#line 190
  i.locked = (_Bool)0;
#line 191
  *__mutex = i;
#line 192
  return (0);
}
}
#line 194 "/usr/local/ddv/models/con2/include/ddverify/pthread.h"
__inline extern int pthread_mutex_destroy(pthread_mutex_t *__mutex ) 
{ 


  {
#line 196
  return (0);
}
}
#line 203 "/usr/local/ddv/models/con2/include/ddverify/pthread.h"
__inline extern int pthread_mutex_lock(pthread_mutex_t *__mutex ) 
{ 


  {
#line 206
  __CPROVER_atomic_begin();
#line 207
  __CPROVER_assume(! __mutex->locked);
#line 208
  __mutex->locked = (_Bool)1;
#line 209
  __CPROVER_atomic_end();
#line 210
  return (0);
}
}
#line 216
extern int ( /* missing proto */  __CPROVER_assert)() ;
#line 213 "/usr/local/ddv/models/con2/include/ddverify/pthread.h"
__inline extern int pthread_mutex_unlock(pthread_mutex_t *__mutex ) 
{ 


  {
#line 216
  __CPROVER_assert((int )__mutex->locked, "pthread_mutex_unlock without lock");
#line 217
  __mutex->locked = (_Bool)0;
#line 218
  return (0);
}
}
#line 9 "/usr/local/ddv/models/con2/include/linux/spinlock.h"
void spin_lock_init(spinlock_t *lock ) ;
#line 12 "/usr/local/ddv/models/con2/include/ddverify/genhd.h"
short number_genhd_registered  =    (short)0;
#line 13 "/usr/local/ddv/models/con2/include/ddverify/genhd.h"
short number_fixed_genhd_used  =    (short)0;
#line 24 "/usr/local/ddv/models/con2/include/ddverify/genhd.h"
struct gendisk fixed_gendisk[10]  ;
#line 25 "/usr/local/ddv/models/con2/include/ddverify/genhd.h"
struct ddv_genhd genhd_registered[10]  ;
#line 14 "/usr/local/ddv/models/con2/include/ddverify/pci.h"
struct ddv_pci_driver registered_pci_driver  ;
#line 19
extern void call_pci_functions() ;
#line 14 "/usr/local/ddv/models/con2/include/ddverify/interrupt.h"
struct registered_irq registered_irq[16]  ;
#line 16
void call_interrupt_handler(void) ;
#line 8 "/usr/local/ddv/models/con2/include/ddverify/tasklet.h"
short number_tasklet_registered  =    (short)0;
#line 15 "/usr/local/ddv/models/con2/include/ddverify/tasklet.h"
struct ddv_tasklet tasklet_registered[10]  ;
#line 17
void call_tasklet_functions(void) ;
#line 8 "/usr/local/ddv/models/con2/include/ddverify/timer.h"
short number_timer_registered  =    (short)0;
#line 14 "/usr/local/ddv/models/con2/include/ddverify/timer.h"
struct ddv_timer timer_registered[5]  ;
#line 16
extern void call_timer_functions() ;
#line 8 "/usr/local/ddv/models/con2/include/ddverify/workqueue.h"
struct work_struct *shared_workqueue[10]  ;
#line 10
void call_shared_workqueue_functions(void) ;
#line 7 "/usr/local/ddv/models/con2/include/linux/smp_lock.h"
spinlock_t kernel_lock  ;
#line 15 "/usr/local/ddv/models/con2/src/ddverify/ddverify.c"
void init_kernel(void) 
{ 
  int i ;

  {
#line 19
  spin_lock_init(& kernel_lock);
#line 21
  i = 0;
#line 21
  while (i < 10) {
#line 22
    shared_workqueue[i] = (struct work_struct *)((void *)0);
#line 21
    i ++;
  }
#line 25
  i = 0;
#line 25
  while (i < 10) {
#line 26
    tasklet_registered[i].tasklet = (struct tasklet_struct *)((void *)0);
#line 27
    tasklet_registered[i].is_running = (unsigned short)0;
#line 25
    i ++;
  }
#line 29
  return;
}
}
#line 31 "/usr/local/ddv/models/con2/src/ddverify/ddverify.c"
static void *ddv_2(void *arg ) 
{ 
  unsigned short random ;

  {
#line 35
  while (1) {
#line 36
    random = nondet_ushort();
#line 38
    switch ((int )random) {
    case 1: 
#line 40
    current_execution_context = 2;
#line 41
    call_timer_functions();
#line 42
    current_execution_context = 1;
#line 43
    break;
    case 2: 
#line 46
    current_execution_context = 2;
#line 47
    call_interrupt_handler();
#line 48
    current_execution_context = 1;
#line 49
    break;
    case 3: 
#line 52
    current_execution_context = 1;
#line 53
    call_shared_workqueue_functions();
#line 54
    current_execution_context = 1;
#line 55
    break;
    case 4: 
#line 58
    current_execution_context = 2;
#line 59
    call_tasklet_functions();
#line 60
    current_execution_context = 1;
#line 61
    break;
    case 5: 
#line 64
    current_execution_context = 1;
#line 65
    call_pci_functions();
#line 66
    current_execution_context = 1;
#line 67
    break;
    default: 
#line 70
    break;
    }
#line 35
    if (! random) {
#line 35
      break;
    }
  }
#line 73
  return ((void *)0);
}
}
#line 75 "/usr/local/ddv/models/con2/src/ddverify/ddverify.c"
void ddv(void) 
{ 
  pthread_t___0 thread ;
  int tmp ;

  {
#line 81
  pthread_create((struct __pthread_t_struct *)(& thread), (struct __pthread_attr_t_struct  const  *)((void *)0),
                 & ddv_2, (void *)0);
#line 83
  while (1) {
#line 84
    current_execution_context = 1;
#line 86
    call_cdev_functions();
#line 83
    tmp = nondet_int();
#line 83
    if (! tmp) {
#line 83
      break;
    }
  }
#line 93
  return;
}
}
#line 95 "/usr/local/ddv/models/con2/src/ddverify/ddverify.c"
int call_ddv(void) 
{ 
  int err ;

  {
#line 99
  current_execution_context = 1;
#line 101
  init_kernel();
#line 103
  err = (*_ddv_module_init)();
#line 105
  if (err) {
#line 106
    return (-1);
  }
#line 110
  ddv();
#line 112
  current_execution_context = 1;
#line 113
  (*_ddv_module_exit)();
#line 115
  return (0);
}
}
#line 1 "genhd.o"
#pragma merger("0","/tmp/cil-eR4tzjv0.i","")
#line 9 "/usr/local/ddv/models/con2/include/ddverify/satabs.h"
extern void *malloc(size_t size ) ;
#line 207 "/usr/local/ddv/models/con2/include/linux/fs.h"
int register_blkdev(unsigned int major , char const   *name ) ;
#line 208
int unregister_blkdev(unsigned int major , char const   *name ) ;
#line 33 "/usr/local/ddv/models/con2/include/linux/genhd.h"
void add_disk(struct gendisk *disk ) ;
#line 35
void del_gendisk(struct gendisk *gp ) ;
#line 37
struct gendisk *alloc_disk(int minors ) ;
#line 6 "/usr/local/ddv/models/con2/src/linux/block/genhd.c"
int register_blkdev(unsigned int major , char const   *name ) 
{ 
  int result___0 ;
  int tmp ;

  {
#line 8
  tmp = nondet_int();
#line 8
  result___0 = tmp;
#line 14
  return (result___0);
}
}
#line 17 "/usr/local/ddv/models/con2/src/linux/block/genhd.c"
int unregister_blkdev(unsigned int major , char const   *name ) 
{ 


  {
#line 19
  return (0);
}
}
#line 22 "/usr/local/ddv/models/con2/src/linux/block/genhd.c"
struct gendisk *alloc_disk(int minors ) 
{ 
  struct gendisk *gd ;

  {
#line 26
  if ((int )number_fixed_genhd_used < 10) {
#line 27
    gd = & fixed_gendisk[number_fixed_genhd_used];
#line 28
    gd->minors = minors;
#line 30
    number_fixed_genhd_used = (short )((int )number_fixed_genhd_used + 1);
#line 32
    return (gd);
  } else {
#line 34
    return ((struct gendisk *)((void *)0));
  }
}
}
#line 38 "/usr/local/ddv/models/con2/src/linux/block/genhd.c"
void add_disk(struct gendisk *disk ) 
{ 
  void *tmp ;

  {
#line 40
  if ((int )number_genhd_registered < 10) {
#line 41
    genhd_registered[number_genhd_registered].gd = disk;
#line 42
    tmp = malloc((size_t )sizeof(struct block_device ));
#line 42
    genhd_registered[number_genhd_registered].inode.i_bdev = (struct block_device *)tmp;
#line 43
    (genhd_registered[number_genhd_registered].inode.i_bdev)->bd_disk = disk;
#line 45
    number_genhd_registered = (short )((int )number_genhd_registered + 1);
  }
#line 47
  return;
}
}
#line 49 "/usr/local/ddv/models/con2/src/linux/block/genhd.c"
void del_gendisk(struct gendisk *gp ) 
{ 
  int i ;

  {
#line 53
  i = 0;
#line 53
  while (i < (int )number_genhd_registered) {
#line 54
    if ((unsigned long )genhd_registered[i].gd == (unsigned long )gp) {
#line 55
      genhd_registered[i].gd = (struct gendisk *)((void *)0);
    }
#line 53
    i ++;
  }
#line 58
  return;
}
}
#line 1 "interrupt.o"
#pragma merger("0","/tmp/cil-6cvqaCu2.i","")
#line 10 "/usr/local/ddv/models/con2/src/ddverify/interrupt.c"
void call_interrupt_handler(void) 
{ 
  unsigned short i ;
  struct pt_regs regs ;
  int tmp ;

  {
#line 15
  tmp = nondet_int();
#line 15
  i = (unsigned short )tmp;
#line 16
  __CPROVER_assume((int )i < 16);
#line 18
  if (registered_irq[i].handler) {
#line 19
    (*(registered_irq[i].handler))((int )i, registered_irq[i].dev_id, & regs);
  }
#line 22
  return;
}
}
#line 1 "ioctl.o"
#pragma merger("0","/tmp/cil-gHbHQay8.i","")
#line 1 "ll_rw_blk.o"
#pragma merger("0","/tmp/cil-ijfcAMzd.i","")
#line 192 "/usr/local/ddv/models/con2/include/linux/blkdev.h"
request_queue_t *blk_alloc_queue(gfp_t gfp_mask ) ;
#line 194
request_queue_t *blk_init_queue(request_fn_proc *rfn , spinlock_t *lock ) ;
#line 196
void blk_queue_make_request(request_queue_t *q , make_request_fn *mfn ) ;
#line 198
void blk_queue_hardsect_size(request_queue_t *q , unsigned short size ) ;
#line 200
void blk_cleanup_queue(request_queue_t *q ) ;
#line 220
void end_request(struct request *req , int uptodate ) ;
#line 6 "/usr/local/ddv/models/con2/include/ddverify/blkdev.h"
request_queue_t fixed_request_queue[10]  ;
#line 8 "/usr/local/ddv/models/con2/include/ddverify/blkdev.h"
int number_request_queue_used  =    0;
#line 7 "/usr/local/ddv/models/con2/src/linux/block/ll_rw_blk.c"
request_queue_t *get_fixed_request_queue(void) 
{ 
  int tmp ;

  {
#line 9
  if (number_request_queue_used < 10) {
#line 10
    tmp = number_request_queue_used;
#line 10
    number_request_queue_used ++;
#line 10
    return (& fixed_request_queue[tmp]);
  } else {
#line 12
    return ((request_queue_t *)((void *)0));
  }
}
}
#line 16 "/usr/local/ddv/models/con2/src/linux/block/ll_rw_blk.c"
request_queue_t *blk_init_queue(request_fn_proc *rfn , spinlock_t *lock ) 
{ 
  request_queue_t *queue ;
  int tmp ;

  {
#line 20
  tmp = nondet_int();
#line 20
  if (tmp) {
#line 21
    queue = get_fixed_request_queue();
#line 23
    queue->queue_lock = lock;
#line 24
    queue->request_fn = rfn;
#line 25
    queue->make_request_fn = (make_request_fn *)((void *)0);
#line 26
    queue->__ddv_queue_alive = 1;
#line 28
    return (queue);
  } else {
#line 30
    return ((request_queue_t *)((void *)0));
  }
}
}
#line 34 "/usr/local/ddv/models/con2/src/linux/block/ll_rw_blk.c"
request_queue_t *blk_alloc_queue(gfp_t gfp_mask ) 
{ 
  request_queue_t *queue ;
  int tmp ;

  {
#line 38
  tmp = nondet_int();
#line 38
  if (tmp) {
#line 39
    queue = get_fixed_request_queue();
#line 41
    queue->request_fn = (request_fn_proc *)((void *)0);
#line 42
    queue->make_request_fn = (make_request_fn *)((void *)0);
#line 43
    queue->__ddv_queue_alive = 1;
#line 45
    return (queue);
  } else {
#line 47
    return ((request_queue_t *)((void *)0));
  }
}
}
#line 51 "/usr/local/ddv/models/con2/src/linux/block/ll_rw_blk.c"
void blk_queue_make_request(request_queue_t *q , make_request_fn *mfn ) 
{ 


  {
#line 53
  q->make_request_fn = mfn;
#line 54
  return;
}
}
#line 56 "/usr/local/ddv/models/con2/src/linux/block/ll_rw_blk.c"
void end_request(struct request *req , int uptodate ) 
{ 
  int genhd_no ;

  {
#line 58
  genhd_no = ((req->rq_disk)->queue)->__ddv_genhd_no;
#line 60
  genhd_registered[genhd_no].requests_open = 0;
#line 61
  return;
}
}
#line 64 "/usr/local/ddv/models/con2/src/linux/block/ll_rw_blk.c"
void blk_queue_hardsect_size(request_queue_t *q , unsigned short size ) 
{ 


  {
#line 66
  q->hardsect_size = size;
#line 67
  return;
}
}
#line 69 "/usr/local/ddv/models/con2/src/linux/block/ll_rw_blk.c"
void blk_cleanup_queue(request_queue_t *q ) 
{ 


  {
#line 71
  q->__ddv_queue_alive = 0;
#line 72
  return;
}
}
#line 1 "__main.o"
#pragma merger("0","/tmp/cil-_zJCLRzz.i","")
#line 155 "floppy.c"
static int print_unex  =    1;
#line 242 "/usr/local/ddv/models/con2/include/linux/capability.h"
extern int capable(int cap ) ;
#line 26 "/usr/local/ddv/models/con2/include/linux/timer.h"
void init_timer(struct timer_list *timer ) ;
#line 28
void add_timer(struct timer_list *timer ) ;
#line 29
int del_timer(struct timer_list *timer ) ;
#line 11 "/usr/local/ddv/models/con2/include/linux/spinlock.h"
void spin_lock_irqsave(spinlock_t *lock , unsigned long flags ) ;
#line 12
void spin_lock_irq(spinlock_t *lock ) ;
#line 16
void spin_unlock_irqrestore(spinlock_t *lock , unsigned long flags ) ;
#line 17
void spin_unlock_irq(spinlock_t *lock ) ;
#line 9 "/usr/local/ddv/models/con2/include/asm/current.h"
extern struct task_struct *get_current(void) ;
#line 71 "/usr/local/ddv/models/con2/include/linux/wait.h"
void wake_up(wait_queue_head_t *q ) ;
#line 78
extern void add_wait_queue(wait_queue_head_t *q , wait_queue_t *wait ) ;
#line 82
extern void remove_wait_queue(wait_queue_head_t *q , wait_queue_t *wait ) ;
#line 62 "/usr/local/ddv/models/con2/include/linux/gfp.h"
extern void free_pages(unsigned long addr , unsigned int order ) ;
#line 72
struct page *alloc_page(gfp_t gfp_mask ) ;
#line 10 "/usr/local/ddv/models/con2/include/linux/slab.h"
void *kmalloc(size_t size , gfp_t flags ) ;
#line 4 "/usr/local/ddv/models/con2/include/asm/string.h"
extern void *memset(void *s , int c , unsigned int n ) ;
#line 14 "/usr/local/ddv/models/con2/include/linux/string.h"
extern int strcmp(char const   * , char const   * ) ;
#line 22
extern __kernel_size_t strlen(char const   * ) ;
#line 30
extern void *memcpy(void * , void const   * , __kernel_size_t  ) ;
#line 4 "/usr/local/ddv/models/con2/include/asm/bitops.h"
extern void set_bit(int nr , unsigned long *addr ) ;
#line 6
extern int test_and_set_bit(int nr , unsigned long *addr ) ;
#line 9
extern int test_bit(int nr , void const   *addr ) ;
#line 10
extern void clear_bit(int nr , unsigned long volatile   *addr ) ;
#line 40 "/usr/local/ddv/models/con2/include/linux/sched.h"
extern int signal_pending(struct task_struct *p ) ;
#line 43
void schedule(void) ;
#line 56
extern void set_current_state(int  ) ;
#line 34 "/usr/local/ddv/models/con2/include/linux/kernel.h"
extern int printk(char const   *fmt  , ...) ;
#line 35
extern int sprintf(char *buf , char const   *fmt  , ...) ;
#line 41
extern char *get_options(char const   *str , int nints , int *ints ) ;
#line 51 "/usr/local/ddv/models/con2/include/asm-generic/ioctl.h"
extern unsigned int __invalid_size_argument_for_IOC ;
#line 213 "/usr/local/ddv/models/con2/include/linux/fs.h"
__inline static unsigned int iminor(struct inode *inode ) 
{ 


  {
#line 215
  return (inode->i_rdev & ((1U << 20) - 1U));
}
}
#line 226
extern int check_disk_change(struct block_device * ) ;
#line 46 "/usr/local/ddv/models/con2/include/linux/workqueue.h"
int schedule_work(struct work_struct *work ) ;
#line 48
extern void flush_scheduled_work(void) ;
#line 34 "/usr/local/ddv/models/con2/include/linux/mutex.h"
void mutex_lock(struct mutex *lock ) ;
#line 36
void mutex_unlock(struct mutex *lock ) ;
#line 15 "/usr/local/ddv/models/con2/include/linux/mm.h"
extern void *page_address(struct page *page ) ;
#line 4 "/usr/local/ddv/models/con2/include/asm/delay.h"
extern void udelay(int  ) ;
#line 18 "/usr/local/ddv/models/con2/include/linux/delay.h"
extern void msleep(unsigned int msecs ) ;
#line 90 "/usr/local/ddv/models/con2/include/linux/ioport.h"
struct resource *request_region(unsigned long start , unsigned long len , char const   *name ) ;
#line 92
void release_region(unsigned long start , unsigned long len ) ;
#line 51 "/usr/local/ddv/models/con2/include/asm/uaccess.h"
unsigned long copy_to_user(void *to , void const   *from , unsigned long n ) ;
#line 53
unsigned long copy_from_user(void *to , void *from , unsigned long n ) ;
#line 29 "/usr/local/ddv/models/con2/include/asm/mc146818rtc.h"
extern unsigned char rtc_cmos_read(unsigned char addr ) ;
#line 189 "floppy.c"
static int slow_floppy  ;
#line 197 "floppy.c"
static int FLOPPY_IRQ  =    6;
#line 198 "floppy.c"
static int FLOPPY_DMA  =    2;
#line 199 "floppy.c"
static int can_use_virtual_dma  =    2;
#line 208 "floppy.c"
static int use_virtual_dma  ;
#line 220 "floppy.c"
static spinlock_t floppy_lock  =    {1, 0};
#line 221 "floppy.c"
static struct completion device_release  ;
#line 223 "floppy.c"
static unsigned short virtual_dma_port  =    (unsigned short)1008;
#line 224
irqreturn_t floppy_interrupt(int irq , void *dev_id ) ;
#line 225
static int set_dor(int fdc___0 , char mask , char data ) ;
#line 239 "floppy.c"
static int allowed_drive_mask  =    51;
#line 6 "/usr/local/ddv/models/con2/include/asm/floppy.h"
static int FDC1  =    1008;
#line 7 "/usr/local/ddv/models/con2/include/asm/floppy.h"
static int FDC2  =    -1;
#line 243 "floppy.c"
static int irqdma_allocated  ;
#line 39 "/usr/local/ddv/models/con2/include/linux/genhd.h"
extern void put_disk(struct gendisk *disk ) ;
#line 41
extern struct kobject *get_disk(struct gendisk *disk ) ;
#line 44
extern void set_capacity(struct gendisk *disk , sector_t size ) ;
#line 47
extern void add_disk_randomness(struct gendisk *disk ) ;
#line 4 "/usr/local/ddv/models/con2/include/linux/elevator.h"
extern struct request *elv_next_request(struct request_queue *q ) ;
#line 211 "/usr/local/ddv/models/con2/include/linux/blkdev.h"
extern void blkdev_dequeue_request(struct request *req ) ;
#line 214
extern int end_that_request_first(struct request * , int  , int  ) ;
#line 218
extern void end_that_request_last(struct request * , int  ) ;
#line 252 "floppy.c"
static struct request *current_req  ;
#line 253 "floppy.c"
static struct request_queue *floppy_queue  ;
#line 254
static void do_fd_request(request_queue_t *q ) ;
#line 270 "floppy.c"
__inline static void fallback_on_nodma_alloc(char **addr , size_t l ) 
{ 


  {
#line 281
  return;
}
}
#line 287 "floppy.c"
static unsigned long fake_change  ;
#line 288 "floppy.c"
static int initialising  =    1;
#line 349 "floppy.c"
static unsigned char reply_buffer[16]  ;
#line 350 "floppy.c"
static int inr  ;
#line 365 "floppy.c"
static struct __anonstruct_default_drive_params_14 default_drive_params[7]  = {      {{(signed char)0, 500UL, 16UL, 16UL, 8000UL, 100UL, 300UL, (unsigned char)0,
       (unsigned char)2, (unsigned char)5, (unsigned char)80, 300UL, (unsigned char)20,
       {3U, 1U, 2U, 0U, 2U}, (char)0, (char)0, {(short)7, (short)4, (short)8, (short)2,
                                                (short)1, (short)5, (short)3, (short)10},
       150, 0}, "unknown"}, 
        {{(signed char)1, 300UL, 16UL, 16UL, 8000UL, 100UL, 300UL, (unsigned char)0,
       (unsigned char)2, (unsigned char)5, (unsigned char)40, 300UL, (unsigned char)17,
       {3U, 1U, 2U, 0U, 2U}, (char)0, (char)0, {(short)1, (short)0, (short)0, (short)0,
                                                (short)0, (short)0, (short)0, (short)0},
       150, 1}, "360K PC"}, 
        {{(signed char)2, 500UL, 16UL, 16UL, 6000UL, 40UL, 300UL, (unsigned char)14,
       (unsigned char)2, (unsigned char)6, (unsigned char)83, 300UL, (unsigned char)17,
       {3U, 1U, 2U, 0U, 2U}, (char)0, (char)0, {(short)2, (short)5, (short)6, (short)23,
                                                (short)10, (short)20, (short)12, (short)0},
       150, 2}, "1.2M"}, 
        {{(signed char)3, 250UL, 16UL, 16UL, 3000UL, 100UL, 300UL, (unsigned char)0,
       (unsigned char)2, (unsigned char)5, (unsigned char)83, 300UL, (unsigned char)20,
       {3U, 1U, 2U, 0U, 2U}, (char)0, (char)0, {(short)4, (short)22, (short)21, (short)30,
                                                (short)3, (short)0, (short)0, (short)0},
       150, 4}, "720k"}, 
        {{(signed char)4, 500UL, 16UL, 16UL, 4000UL, 40UL, 300UL, (unsigned char)10,
       (unsigned char)2, (unsigned char)5, (unsigned char)83, 300UL, (unsigned char)20,
       {3U, 1U, 2U, 0U, 2U}, (char)0, (char)0, {(short)7, (short)4, (short)25, (short)22,
                                                (short)31, (short)21, (short)29, (short)11},
       150, 7}, "1.44M"}, 
        {{(signed char)5, 1000UL, 15UL, 8UL, 3000UL, 40UL, 300UL, (unsigned char)10,
       (unsigned char)2, (unsigned char)5, (unsigned char)83, 300UL, (unsigned char)40,
       {3U, 1U, 2U, 0U, 2U}, (char)0, (char)0, {(short)7, (short)8, (short)4, (short)25,
                                                (short)28, (short)22, (short)31, (short)21},
       150, 8}, "2.88M AMI BIOS"}, 
        {{(signed char)6, 1000UL, 15UL, 8UL, 3000UL, 40UL, 300UL, (unsigned char)10,
       (unsigned char)2, (unsigned char)5, (unsigned char)83, 300UL, (unsigned char)40,
       {3U, 1U, 2U, 0U, 2U}, (char)0, (char)0, {(short)7, (short)8, (short)4, (short)25,
                                                (short)28, (short)22, (short)31, (short)21},
       150, 8}, "2.88M"}};
#line 410 "floppy.c"
static struct floppy_drive_params drive_params[8]  ;
#line 411 "floppy.c"
static struct floppy_drive_struct drive_state[8]  ;
#line 412 "floppy.c"
static struct floppy_write_errors write_errors[8]  ;
#line 413 "floppy.c"
static struct timer_list motor_off_timer[8]  ;
#line 414 "floppy.c"
static struct gendisk *disks[8]  ;
#line 415 "floppy.c"
static struct block_device *opened_bdev[8]  ;
#line 416 "floppy.c"
static struct mutex open_lock  =    {0, 1};
#line 417 "floppy.c"
static struct floppy_raw_cmd *raw_cmd  ;
#line 417 "floppy.c"
static struct floppy_raw_cmd default_raw_cmd  ;
#line 443 "floppy.c"
static struct floppy_struct floppy_type[32]  = 
#line 443
  {      {0U, 0U, 0U, 0U, 0U, (unsigned char)0, (unsigned char)0, (unsigned char)0, (unsigned char)0,
      (char const   *)((void *)0)}, 
        {720U, 9U, 2U, 40U, 0U, (unsigned char)42, (unsigned char)2, (unsigned char)223,
      (unsigned char)80, "d360"}, 
        {2400U, 15U, 2U, 80U, 0U, (unsigned char)27, (unsigned char)0, (unsigned char)223,
      (unsigned char)84, "h1200"}, 
        {720U, 9U, 1U, 80U, 0U, (unsigned char)42, (unsigned char)2, (unsigned char)223,
      (unsigned char)80, "D360"}, 
        {1440U, 9U, 2U, 80U, 0U, (unsigned char)42, (unsigned char)2, (unsigned char)223,
      (unsigned char)80, "D720"}, 
        {720U, 9U, 2U, 40U, 1U, (unsigned char)35, (unsigned char)1, (unsigned char)223,
      (unsigned char)80, "h360"}, 
        {1440U, 9U, 2U, 80U, 0U, (unsigned char)35, (unsigned char)1, (unsigned char)223,
      (unsigned char)80, "h720"}, 
        {2880U, 18U, 2U, 80U, 0U, (unsigned char)27, (unsigned char)0, (unsigned char)207,
      (unsigned char)108, "H1440"}, 
        {5760U, 36U, 2U, 80U, 0U, (unsigned char)27, (unsigned char)67, (unsigned char)175,
      (unsigned char)84, "E2880"}, 
        {6240U, 39U, 2U, 80U, 0U, (unsigned char)27, (unsigned char)67, (unsigned char)175,
      (unsigned char)40, "E3120"}, 
        {2880U, 18U, 2U, 80U, 0U, (unsigned char)37, (unsigned char)0, (unsigned char)223,
      (unsigned char)2, "h1440"}, 
        {3360U, 21U, 2U, 80U, 0U, (unsigned char)28, (unsigned char)0, (unsigned char)207,
      (unsigned char)12, "H1680"}, 
        {820U, 10U, 2U, 41U, 1U, (unsigned char)37, (unsigned char)1, (unsigned char)223,
      (unsigned char)46, "h410"}, 
        {1640U, 10U, 2U, 82U, 0U, (unsigned char)37, (unsigned char)2, (unsigned char)223,
      (unsigned char)46, "H820"}, 
        {2952U, 18U, 2U, 82U, 0U, (unsigned char)37, (unsigned char)0, (unsigned char)223,
      (unsigned char)2, "h1476"}, 
        {3444U, 21U, 2U, 82U, 0U, (unsigned char)37, (unsigned char)0, (unsigned char)223,
      (unsigned char)12, "H1722"}, 
        {840U, 10U, 2U, 42U, 1U, (unsigned char)37, (unsigned char)1, (unsigned char)223,
      (unsigned char)46, "h420"}, 
        {1660U, 10U, 2U, 83U, 0U, (unsigned char)37, (unsigned char)2, (unsigned char)223,
      (unsigned char)46, "H830"}, 
        {2988U, 18U, 2U, 83U, 0U, (unsigned char)37, (unsigned char)0, (unsigned char)223,
      (unsigned char)2, "h1494"}, 
        {3486U, 21U, 2U, 83U, 0U, (unsigned char)37, (unsigned char)0, (unsigned char)223,
      (unsigned char)12, "H1743"}, 
        {1760U, 11U, 2U, 80U, 0U, (unsigned char)28, (unsigned char)9, (unsigned char)207,
      (unsigned char)0, "h880"}, 
        {2080U, 13U, 2U, 80U, 0U, (unsigned char)28, (unsigned char)1, (unsigned char)207,
      (unsigned char)0, "D1040"}, 
        {2240U, 14U, 2U, 80U, 0U, (unsigned char)28, (unsigned char)25, (unsigned char)207,
      (unsigned char)0, "D1120"}, 
        {3200U, 20U, 2U, 80U, 0U, (unsigned char)28, (unsigned char)32, (unsigned char)207,
      (unsigned char)44, "h1600"}, 
        {3520U, 22U, 2U, 80U, 0U, (unsigned char)28, (unsigned char)8, (unsigned char)207,
      (unsigned char)46, "H1760"}, 
        {3840U, 24U, 2U, 80U, 0U, (unsigned char)28, (unsigned char)32, (unsigned char)207,
      (unsigned char)0, "H1920"}, 
        {6400U, 40U, 2U, 80U, 0U, (unsigned char)37, (unsigned char)91, (unsigned char)207,
      (unsigned char)0, "E3200"}, 
        {7040U, 44U, 2U, 80U, 0U, (unsigned char)37, (unsigned char)91, (unsigned char)207,
      (unsigned char)0, "E3520"}, 
        {7680U, 48U, 2U, 80U, 0U, (unsigned char)37, (unsigned char)99, (unsigned char)207,
      (unsigned char)0, "E3840"}, 
        {3680U, 23U, 2U, 80U, 0U, (unsigned char)28, (unsigned char)16, (unsigned char)207,
      (unsigned char)0, "H1840"}, 
        {1600U, 10U, 2U, 80U, 0U, (unsigned char)37, (unsigned char)2, (unsigned char)223,
      (unsigned char)46, "D800"}, 
        {3200U, 20U, 2U, 80U, 0U, (unsigned char)28, (unsigned char)0, (unsigned char)207,
      (unsigned char)44, "H1600"}};
#line 484 "floppy.c"
static struct floppy_struct *current_type[8]  ;
#line 490 "floppy.c"
static struct floppy_struct user_params[8]  ;
#line 492 "floppy.c"
static sector_t floppy_sizes[256]  ;
#line 494 "floppy.c"
static char floppy_device_name[7]  = {      (char )'f',      (char )'l',      (char )'o',      (char )'p', 
        (char )'p',      (char )'y',      (char )'\000'};
#line 501 "floppy.c"
static int probing  ;
#line 508 "floppy.c"
static int volatile   command_status  =    (int volatile   )-1;
#line 509 "floppy.c"
static unsigned long fdc_busy  ;
#line 510 "floppy.c"
static wait_queue_head_t fdc_wait  =    {0, 0, 1};
#line 511 "floppy.c"
static wait_queue_head_t command_done  =    {0, 0, 1};
#line 521 "floppy.c"
static int format_errors  ;
#line 524 "floppy.c"
static struct format_descr format_req  ;
#line 538 "floppy.c"
static char *floppy_track_buffer  ;
#line 539 "floppy.c"
static int max_buffer_sectors  ;
#line 541 "floppy.c"
static int *errors  ;
#line 543 "floppy.c"
static struct cont_t *cont  ;
#line 552
static void floppy_ready(void) ;
#line 553
static void floppy_start(void) ;
#line 554
static void process_fd_request(void) ;
#line 555
static void recalibrate_floppy(void) ;
#line 556
static void floppy_shutdown(unsigned long data ) ;
#line 558
static int floppy_grab_irq_and_dma(void) ;
#line 559
static void floppy_release_irq_and_dma(void) ;
#line 569
static void reset_fdc(void) ;
#line 580 "floppy.c"
static int usage_count  ;
#line 583 "floppy.c"
static int buffer_track  =    -1;
#line 584 "floppy.c"
static int buffer_drive  =    -1;
#line 585 "floppy.c"
static int buffer_min  =    -1;
#line 586 "floppy.c"
static int buffer_max  =    -1;
#line 589 "floppy.c"
static struct floppy_fdc_state fdc_state[2]  ;
#line 590 "floppy.c"
static int fdc  ;
#line 592 "floppy.c"
static struct floppy_struct *_floppy  =    floppy_type;
#line 593 "floppy.c"
static unsigned char current_drive  ;
#line 594 "floppy.c"
static long current_count_sectors  ;
#line 595 "floppy.c"
static unsigned char fsector_t  ;
#line 596 "floppy.c"
static unsigned char in_sector_offset  ;
#line 600 "floppy.c"
__inline static int fd_eject(int drive ) 
{ 


  {
#line 602
  return (-22);
}
}
#line 611 "floppy.c"
static unsigned long debugtimer  ;
#line 613 "floppy.c"
__inline static void set_debugt(void) 
{ 


  {
#line 615
  debugtimer = jiffies;
#line 616
  return;
}
}
#line 618 "floppy.c"
__inline static void debugt(char const   *message ) 
{ 


  {
#line 620
  if ((int )drive_params[current_drive].flags & 2) {
#line 621
    printk("%s dtime=%lu\n", message, jiffies - debugtimer);
  }
#line 622
  return;
}
}
#line 629 "floppy.c"
static struct timer_list fd_timeout  =    {0UL, & floppy_shutdown, 0UL, (short)0, (short)1};
#line 631 "floppy.c"
static char const   *timeout_message  ;
#line 637
extern int ( /* missing proto */  timer_pending)() ;
#line 634 "floppy.c"
static void is_alive(char const   *message ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 637
  tmp = test_bit(0, (void const   *)(& fdc_busy));
#line 637
  if (tmp) {
#line 637
    if (command_status < (int volatile   )2) {
#line 637
      tmp___0 = timer_pending(& fd_timeout);
#line 637
      if (! tmp___0) {
#line 639
        printk("floppy%d: timeout handler died: %s\n", (int )current_drive, message);
      }
    }
  }
#line 641
  return;
}
}
#line 644 "floppy.c"
static void (*do_floppy)(void)  =    (void (*)(void))((void *)0);
#line 650 "floppy.c"
static void (*lasthandler)(void)  ;
#line 651 "floppy.c"
static unsigned long interruptjiffies  ;
#line 652 "floppy.c"
static unsigned long resultjiffies  ;
#line 653 "floppy.c"
static int resultsize  ;
#line 654 "floppy.c"
static unsigned long lastredo  ;
#line 656 "floppy.c"
static struct output_log output_log[20]  ;
#line 662 "floppy.c"
static int output_log_pos  ;
#line 668 "floppy.c"
static void __reschedule_timeout(int drive , char const   *message , int marg ) 
{ 


  {
#line 670
  if (drive == -1) {
#line 671
    drive = (int )current_drive;
  }
#line 672
  del_timer(& fd_timeout);
#line 673
  if (drive < 0) {
#line 674
    fd_timeout.expires = jiffies + 2000UL;
#line 675
    drive = 0;
  } else
#line 673
  if (drive > 8) {
#line 674
    fd_timeout.expires = jiffies + 2000UL;
#line 675
    drive = 0;
  } else {
#line 677
    fd_timeout.expires = jiffies + drive_params[drive].timeout;
  }
#line 678
  add_timer(& fd_timeout);
#line 679
  if ((int )drive_params[drive].flags & 2) {
#line 680
    printk("floppy%d: reschedule timeout ", (int )current_drive);
#line 681
    printk(message, marg);
#line 682
    printk("\n");
  }
#line 684
  timeout_message = message;
#line 685
  return;
}
}
#line 687 "floppy.c"
static void reschedule_timeout(int drive , char const   *message , int marg ) 
{ 
  unsigned long flags ;

  {
#line 691
  spin_lock_irqsave(& floppy_lock, flags);
#line 692
  __reschedule_timeout(drive, message, marg);
#line 693
  spin_unlock_irqrestore(& floppy_lock, flags);
#line 694
  return;
}
}
#line 751
extern int ( /* missing proto */  fd_inb)() ;
#line 733 "floppy.c"
static int disk_change(int drive ) 
{ 
  int fdc___0 ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 735
  fdc___0 = (drive & 4) >> 2;
#line 737
  if ((long )jiffies - (long )(drive_state[drive].select_date + (unsigned long )drive_params[drive].select_delay) < 0L) {
#line 738
    printk("floppy%d: WARNING disk change called early\n", (int )current_drive);
  }
#line 739
  if (! ((int )fdc_state[fdc___0].dor & (16 << (drive & 3)))) {
#line 741
    printk("floppy%d: probing disk change on unselected drive\n", (int )current_drive);
#line 742
    printk("floppy%d: drive=%d fdc=%d dor=%x\n", (int )current_drive, drive, (drive & 4) >> 2,
           (unsigned int )fdc_state[fdc___0].dor);
  } else
#line 739
  if (((int )fdc_state[fdc___0].dor & 3) != (drive & 3)) {
#line 741
    printk("floppy%d: probing disk change on unselected drive\n", (int )current_drive);
#line 742
    printk("floppy%d: drive=%d fdc=%d dor=%x\n", (int )current_drive, drive, (drive & 4) >> 2,
           (unsigned int )fdc_state[fdc___0].dor);
  } else
#line 739
  if (fdc___0 != (drive & 4) >> 2) {
#line 741
    printk("floppy%d: probing disk change on unselected drive\n", (int )current_drive);
#line 742
    printk("floppy%d: drive=%d fdc=%d dor=%x\n", (int )current_drive, drive, (drive & 4) >> 2,
           (unsigned int )fdc_state[fdc___0].dor);
  }
#line 748
  if ((int )drive_params[drive].flags & 2) {
#line 749
    printk("floppy%d: checking disk change line for drive %d\n", (int )current_drive,
           drive);
#line 750
    printk("floppy%d: jiffies=%lu\n", (int )current_drive, jiffies);
#line 751
    tmp = fd_inb(7UL + fdc_state[fdc___0].address);
#line 751
    printk("floppy%d: disk change line=%x\n", (int )current_drive, tmp & 128);
#line 752
    printk("floppy%d: flags=%lx\n", (int )current_drive, drive_state[drive].flags);
  }
#line 755
  if ((int )drive_params[drive].flags & 32) {
#line 756
    tmp___0 = test_bit(4, (void const   *)(& drive_state[drive].flags));
#line 756
    return (tmp___0);
  }
#line 757
  tmp___1 = fd_inb(7UL + fdc_state[fdc___0].address);
#line 757
  if ((tmp___1 ^ (int )drive_params[drive].flags) & 128) {
#line 758
    set_bit(1, & drive_state[drive].flags);
#line 759
    if (drive_state[drive].maxblock) {
#line 761
      set_bit(4, & drive_state[drive].flags);
    }
#line 765
    if (drive_state[drive].keep_data >= 0) {
#line 766
      if ((int )drive_params[drive].flags & 16) {
#line 766
        if ((unsigned long )current_type[drive] != (unsigned long )((void *)0)) {
#line 768
          printk("floppy%d: Disk type is undefined after disk change\n", (int )current_drive);
        }
      }
#line 770
      current_type[drive] = (struct floppy_struct *)((void *)0);
#line 771
      floppy_sizes[(drive & 3) | ((drive & 4) << 5)] = (sector_t )(4 << 1);
    }
#line 775
    return (1);
  } else {
#line 777
    drive_state[drive].last_checked = jiffies;
#line 778
    clear_bit(2, (unsigned long volatile   *)(& drive_state[drive].flags));
  }
#line 780
  return (0);
}
}
#line 783 "floppy.c"
__inline static int is_selected(int dor , int unit ) 
{ 
  int tmp ;

  {
#line 785
  if (dor & (16 << unit)) {
#line 785
    if ((dor & 3) == unit) {
#line 785
      tmp = 1;
    } else {
#line 785
      tmp = 0;
    }
  } else {
#line 785
    tmp = 0;
  }
#line 785
  return (tmp);
}
}
#line 809
extern int ( /* missing proto */  fd_outb)() ;
#line 788 "floppy.c"
static int set_dor(int fdc___0 , char mask , char data ) 
{ 
  register unsigned char drive ;
  register unsigned char unit ;
  register unsigned char newdor ;
  register unsigned char olddor ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 792
  if (fdc_state[fdc___0].address == 0xffffffffffffffffUL) {
#line 793
    return (-1);
  }
#line 795
  olddor = fdc_state[fdc___0].dor;
#line 796
  newdor = (unsigned char )(((int )olddor & (int )mask) | (int )data);
#line 797
  if ((int )newdor != (int )olddor) {
#line 798
    unit = (unsigned char )((int )olddor & 3);
#line 799
    tmp = is_selected((int )olddor, (int )unit);
#line 799
    if (tmp) {
#line 799
      tmp___0 = is_selected((int )newdor, (int )unit);
#line 799
      if (! tmp___0) {
#line 800
        drive = (unsigned char )((int )unit + (fdc___0 << 2));
#line 802
        if ((int )drive_params[drive].flags & 2) {
#line 803
          printk("floppy%d: calling disk change from set_dor\n", (int )current_drive);
        }
#line 806
        disk_change((int )drive);
      }
    }
#line 808
    fdc_state[fdc___0].dor = newdor;
#line 809
    fd_outb((int )newdor, 2UL + fdc_state[fdc___0].address);
#line 811
    unit = (unsigned char )((int )newdor & 3);
#line 812
    tmp___1 = is_selected((int )olddor, (int )unit);
#line 812
    if (! tmp___1) {
#line 812
      tmp___2 = is_selected((int )newdor, (int )unit);
#line 812
      if (tmp___2) {
#line 813
        drive = (unsigned char )((int )unit + (fdc___0 << 2));
#line 814
        drive_state[drive].select_date = jiffies;
      }
    }
  }
#line 817
  return ((int )olddor);
}
}
#line 820 "floppy.c"
static void twaddle(void) 
{ 


  {
#line 822
  if (drive_params[current_drive].select_delay) {
#line 823
    return;
  }
#line 824
  fd_outb((int )fdc_state[fdc].dor & ~ (16 << ((int )current_drive & 3)), 2UL + fdc_state[fdc].address);
#line 825
  fd_outb((int )fdc_state[fdc].dor, 2UL + fdc_state[fdc].address);
#line 826
  drive_state[current_drive].select_date = jiffies;
#line 827
  return;
}
}
#line 831 "floppy.c"
static void reset_fdc_info(int mode ) 
{ 
  int drive ;
  int tmp ;

  {
#line 835
  tmp = -1;
#line 835
  fdc_state[fdc].spec2 = tmp;
#line 835
  fdc_state[fdc].spec1 = tmp;
#line 836
  fdc_state[fdc].need_configure = 1U;
#line 837
  fdc_state[fdc].perp_mode = 1U;
#line 838
  fdc_state[fdc].rawcmd = 0U;
#line 839
  drive = 0;
#line 839
  while (drive < 8) {
#line 840
    if ((drive & 4) >> 2 == fdc) {
#line 840
      if (mode) {
#line 841
        drive_state[drive].track = (short)-3;
      } else
#line 840
      if ((int )drive_state[drive].track != -2) {
#line 841
        drive_state[drive].track = (short)-3;
      }
    }
#line 839
    drive ++;
  }
#line 842
  return;
}
}
#line 845 "floppy.c"
static void set_fdc(int drive ) 
{ 
  int tmp ;

  {
#line 847
  if (drive >= 0) {
#line 847
    if (drive < 8) {
#line 848
      fdc = (drive & 4) >> 2;
#line 849
      current_drive = (unsigned char )drive;
    }
  }
#line 851
  if (fdc != 1) {
#line 851
    if (fdc != 0) {
#line 852
      printk("bad fdc value\n");
#line 853
      return;
    }
  }
#line 855
  set_dor(fdc, (char )(~ 0), (char)8);
#line 857
  set_dor(1 - fdc, (char )(~ 8), (char)0);
#line 859
  if (fdc_state[fdc].rawcmd == 2U) {
#line 860
    reset_fdc_info(1);
  }
#line 861
  tmp = fd_inb(4UL + fdc_state[fdc].address);
#line 861
  if (tmp != 128) {
#line 862
    fdc_state[fdc].reset = 1U;
  }
#line 863
  return;
}
}
#line 866 "floppy.c"
static int _lock_fdc(int drive , int interruptible , int line ) 
{ 
  wait_queue_t wait ;
  int tmp ;
  struct task_struct *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 868
  if (! usage_count) {
#line 869
    printk("<3>Trying to lock fdc while usage count=0 at line %d\n", line);
#line 872
    return (-1);
  }
#line 875
  tmp___2 = test_and_set_bit(0, & fdc_busy);
#line 875
  if (tmp___2) {
#line 877
    add_wait_queue(& fdc_wait, & wait);
#line 879
    while (1) {
#line 880
      set_current_state(1);
#line 882
      tmp = test_and_set_bit(0, & fdc_busy);
#line 882
      if (! tmp) {
#line 883
        break;
      }
#line 885
      schedule();
#line 887
      if (! (! interruptible)) {
#line 887
        tmp___0 = get_current();
#line 887
        tmp___1 = signal_pending(tmp___0);
#line 887
        if (tmp___1) {
#line 888
          remove_wait_queue(& fdc_wait, & wait);
#line 889
          return (-4);
        }
      }
    }
#line 893
    set_current_state(0);
#line 894
    remove_wait_queue(& fdc_wait, & wait);
#line 896
    flush_scheduled_work();
  }
#line 898
  command_status = (int volatile   )-1;
#line 900
  __reschedule_timeout(drive, "lock fdc", 0);
#line 901
  set_fdc(drive);
#line 902
  return (0);
}
}
#line 911 "floppy.c"
__inline static void unlock_fdc(void) 
{ 
  unsigned long flags ;
  int tmp ;
  struct request *tmp___0 ;

  {
#line 915
  raw_cmd = (struct floppy_raw_cmd *)((void *)0);
#line 916
  tmp = test_bit(0, (void const   *)(& fdc_busy));
#line 916
  if (! tmp) {
#line 917
    printk("floppy%d: FDC access conflict!\n", (int )current_drive);
  }
#line 919
  if (do_floppy) {
#line 920
    printk("floppy%d: device interrupt still active at FDC release: %p!\n", (int )current_drive,
           do_floppy);
  }
#line 922
  command_status = (int volatile   )-1;
#line 923
  spin_lock_irqsave(& floppy_lock, flags);
#line 924
  del_timer(& fd_timeout);
#line 925
  cont = (struct cont_t *)((void *)0);
#line 926
  clear_bit(0, (unsigned long volatile   *)(& fdc_busy));
#line 927
  tmp___0 = elv_next_request(floppy_queue);
#line 927
  if (tmp___0) {
#line 928
    do_fd_request(floppy_queue);
  }
#line 929
  spin_unlock_irqrestore(& floppy_lock, flags);
#line 930
  wake_up(& fdc_wait);
#line 931
  return;
}
}
#line 934 "floppy.c"
static void motor_off_callback(unsigned long nr ) 
{ 
  unsigned char mask ;

  {
#line 936
  mask = (unsigned char )(~ (16 << (nr & 3UL)));
#line 938
  set_dor((int )((nr & 4UL) >> 2), (char )mask, (char)0);
#line 939
  return;
}
}
#line 942 "floppy.c"
static void floppy_off(unsigned int drive ) 
{ 
  unsigned long volatile   delta ;
  register int fdc___0 ;

  {
#line 945
  fdc___0 = (int )((drive & 4U) >> 2);
#line 947
  if (! ((int )fdc_state[fdc___0].dor & (16 << (drive & 3U)))) {
#line 948
    return;
  }
#line 950
  del_timer(motor_off_timer + drive);
#line 954
  if (drive_params[drive].rps) {
#line 955
    delta = (unsigned long volatile   )(((jiffies - drive_state[drive].first_read_date) + 100UL) - (unsigned long )drive_params[drive].spindown_offset);
#line 957
    delta = ((delta * (unsigned long volatile   )drive_params[drive].rps) % (unsigned long volatile   )100) / (unsigned long volatile   )drive_params[drive].rps;
#line 958
    motor_off_timer[drive].expires = (jiffies + drive_params[drive].spindown) - (unsigned long )delta;
  }
#line 961
  add_timer(motor_off_timer + drive);
#line 962
  return;
}
}
#line 969 "floppy.c"
static void scandrives(void) 
{ 
  int i ;
  int drive ;
  int saved_drive ;
  int tmp ;

  {
#line 973
  if (drive_params[current_drive].select_delay) {
#line 974
    return;
  }
#line 976
  saved_drive = (int )current_drive;
#line 977
  i = 0;
#line 977
  while (i < 8) {
#line 978
    drive = ((saved_drive + i) + 1) % 8;
#line 979
    if (drive_state[drive].fd_ref == 0) {
#line 980
      goto __Cont;
    } else
#line 979
    if ((int )drive_params[drive].select_delay != 0) {
#line 980
      goto __Cont;
    }
#line 981
    set_fdc(drive);
#line 982
    tmp = set_dor(fdc, (char )(~ 3), (char )((drive & 3) | (16 << (drive & 3))));
#line 982
    if (! (tmp & (16 << (drive & 3)))) {
#line 986
      set_dor(fdc, (char )(~ (16 << (drive & 3))), (char)0);
    }
    __Cont: /* CIL Label */ 
#line 977
    i ++;
  }
#line 988
  set_fdc(saved_drive);
#line 989
  return;
}
}
#line 991 "floppy.c"
static void empty(void) 
{ 


  {
#line 993
  return;
}
}
#line 995 "floppy.c"
static struct work_struct floppy_work  =    {0UL, (void (*)(void * ))((void *)0), (void *)0, 1};
#line 997 "floppy.c"
static void schedule_bh(void (*handler)(void) ) 
{ 


  {
#line 999
  while (1) {
#line 999
    floppy_work.func = (void (*)(void * ))handler;
#line 999
    floppy_work.data = (void *)0;
#line 999
    floppy_work.init = 1;
#line 999
    break;
  }
#line 1000
  schedule_work(& floppy_work);
#line 1001
  return;
}
}
#line 1003 "floppy.c"
static struct timer_list fd_timer  =    {0UL, (void (*)(unsigned long  ))((void *)0), 0UL, (short)0, (short)1};
#line 1005 "floppy.c"
static void cancel_activity(void) 
{ 
  unsigned long flags ;

  {
#line 1009
  spin_lock_irqsave(& floppy_lock, flags);
#line 1010
  do_floppy = (void (*)(void))((void *)0);
#line 1011
  while (1) {
#line 1011
    floppy_work.func = (void (*)(void * ))((void *)(& empty));
#line 1011
    floppy_work.data = (void *)0;
#line 1011
    floppy_work.init = 1;
#line 1011
    break;
  }
#line 1012
  del_timer(& fd_timer);
#line 1013
  spin_unlock_irqrestore(& floppy_lock, flags);
#line 1014
  return;
}
}
#line 1018 "floppy.c"
static void fd_watchdog(void) 
{ 
  int tmp ;

  {
#line 1021
  if ((int )drive_params[current_drive].flags & 2) {
#line 1022
    printk("floppy%d: calling disk change from watchdog\n", (int )current_drive);
  }
#line 1026
  tmp = disk_change((int )current_drive);
#line 1026
  if (tmp) {
#line 1027
    printk("floppy%d: disk removed during i/o\n", (int )current_drive);
#line 1028
    cancel_activity();
#line 1029
    (*(cont->done))(0);
#line 1030
    reset_fdc();
  } else {
#line 1032
    del_timer(& fd_timer);
#line 1033
    fd_timer.function = (void (*)(unsigned long  ))(& fd_watchdog);
#line 1034
    fd_timer.expires = jiffies + 10UL;
#line 1035
    add_timer(& fd_timer);
  }
#line 1037
  return;
}
}
#line 1039 "floppy.c"
static void main_command_interrupt(void) 
{ 


  {
#line 1041
  del_timer(& fd_timer);
#line 1042
  (*(cont->interrupt))();
#line 1043
  return;
}
}
#line 1046 "floppy.c"
static int fd_wait_for_completion(unsigned long delay , void (*function)(unsigned long  ) ) 
{ 


  {
#line 1048
  if (fdc_state[fdc].reset) {
#line 1049
    reset_fdc();
#line 1052
    return (1);
  }
#line 1055
  if ((long )jiffies - (long )delay < 0L) {
#line 1056
    del_timer(& fd_timer);
#line 1057
    fd_timer.function = function;
#line 1058
    fd_timer.expires = delay;
#line 1059
    add_timer(& fd_timer);
#line 1060
    return (1);
  }
#line 1062
  return (0);
}
}
#line 1065 "floppy.c"
static spinlock_t floppy_hlt_lock  =    {1, 0};
#line 1066 "floppy.c"
static int hlt_disabled  ;
#line 1067 "floppy.c"
static void floppy_disable_hlt(void) 
{ 
  unsigned long flags ;

  {
#line 1071
  spin_lock_irqsave(& floppy_hlt_lock, flags);
#line 1072
  if (! hlt_disabled) {
#line 1073
    hlt_disabled = 1;
  }
#line 1078
  spin_unlock_irqrestore(& floppy_hlt_lock, flags);
#line 1079
  return;
}
}
#line 1081 "floppy.c"
static void floppy_enable_hlt(void) 
{ 
  unsigned long flags ;

  {
#line 1085
  spin_lock_irqsave(& floppy_hlt_lock, flags);
#line 1086
  if (hlt_disabled) {
#line 1087
    hlt_disabled = 0;
  }
#line 1092
  spin_unlock_irqrestore(& floppy_hlt_lock, flags);
#line 1093
  return;
}
}
#line 1118
extern int ( /* missing proto */  claim_dma_lock)() ;
#line 1119
extern int ( /* missing proto */  fd_disable_dma)() ;
#line 1131
extern int ( /* missing proto */  fd_clear_dma_ff)() ;
#line 1132
extern int ( /* missing proto */  fd_cacheflush)() ;
#line 1133
extern int ( /* missing proto */  fd_set_dma_mode)() ;
#line 1135
extern int ( /* missing proto */  fd_set_dma_addr)() ;
#line 1136
extern int ( /* missing proto */  fd_set_dma_count)() ;
#line 1138
extern int ( /* missing proto */  fd_enable_dma)() ;
#line 1139
extern int ( /* missing proto */  release_dma_lock)() ;
#line 1095 "floppy.c"
static void setup_DMA(void) 
{ 
  unsigned long f ;
  int i ;
  int tmp ;
  int tmp___0 ;

  {
#line 1100
  if (raw_cmd->length == 0L) {
#line 1103
    printk("zero dma transfer size:");
#line 1104
    i = 0;
#line 1104
    while (i < (int )raw_cmd->cmd_count) {
#line 1105
      printk("%x,", (int )raw_cmd->cmd[i]);
#line 1104
      i ++;
    }
#line 1106
    printk("\n");
#line 1107
    (*(cont->done))(0);
#line 1108
    fdc_state[fdc].reset = 1U;
#line 1109
    return;
  }
#line 1111
  if ((unsigned long )raw_cmd->kernel_data % 512UL) {
#line 1112
    printk("non aligned address: %p\n", raw_cmd->kernel_data);
#line 1113
    (*(cont->done))(0);
#line 1114
    fdc_state[fdc].reset = 1U;
#line 1115
    return;
  }
#line 1118
  tmp = claim_dma_lock();
#line 1118
  f = (unsigned long )tmp;
#line 1119
  fd_disable_dma();
#line 1131
  fd_clear_dma_ff();
#line 1132
  fd_cacheflush(raw_cmd->kernel_data, raw_cmd->length);
#line 1133
  if (raw_cmd->flags & 1U) {
#line 1133
    tmp___0 = 68;
  } else {
#line 1133
    tmp___0 = 72;
  }
#line 1133
  fd_set_dma_mode(tmp___0);
#line 1135
  fd_set_dma_addr(raw_cmd->kernel_data);
#line 1136
  fd_set_dma_count(raw_cmd->length);
#line 1137
  virtual_dma_port = (unsigned short )fdc_state[fdc].address;
#line 1138
  fd_enable_dma();
#line 1139
  release_dma_lock(f);
#line 1141
  floppy_disable_hlt();
#line 1142
  return;
}
}
#line 1144
static void show_floppy(void) ;
#line 1147 "floppy.c"
static int wait_til_ready(void) 
{ 
  int counter ;
  int status ;

  {
#line 1150
  if (fdc_state[fdc].reset) {
#line 1151
    return (-1);
  }
#line 1152
  counter = 0;
#line 1152
  while (counter < 10000) {
#line 1153
    status = fd_inb(4UL + fdc_state[fdc].address);
#line 1154
    if (status & 128) {
#line 1155
      return (status);
    }
#line 1152
    counter ++;
  }
#line 1157
  if (! initialising) {
#line 1158
    printk("floppy%d: Getstatus times out (%x) on fdc %d\n", (int )current_drive,
           status, fdc);
#line 1159
    show_floppy();
  }
#line 1161
  fdc_state[fdc].reset = 1U;
#line 1162
  return (-1);
}
}
#line 1166 "floppy.c"
static int output_byte(char byte ) 
{ 
  int status ;

  {
#line 1170
  status = wait_til_ready();
#line 1170
  if (status < 0) {
#line 1171
    return (-1);
  }
#line 1172
  if ((status & 224) == 128) {
#line 1173
    fd_outb((int )byte, 5UL + fdc_state[fdc].address);
#line 1175
    output_log[output_log_pos].data = (unsigned char )byte;
#line 1176
    output_log[output_log_pos].status = (unsigned char )status;
#line 1177
    output_log[output_log_pos].jiffies = jiffies;
#line 1178
    output_log_pos = (output_log_pos + 1) % 20;
#line 1180
    return (0);
  }
#line 1182
  fdc_state[fdc].reset = 1U;
#line 1183
  if (! initialising) {
#line 1184
    printk("floppy%d: Unable to send byte %x to FDC. Fdc=%x Status=%x\n", (int )current_drive,
           (int )byte, fdc, status);
#line 1186
    show_floppy();
  }
#line 1188
  return (-1);
}
}
#line 1194 "floppy.c"
static int result(void) 
{ 
  int i ;
  int status ;
  int tmp ;

  {
#line 1196
  status = 0;
#line 1198
  i = 0;
#line 1198
  while (i < 16) {
#line 1199
    status = wait_til_ready();
#line 1199
    if (status < 0) {
#line 1200
      break;
    }
#line 1201
    status &= 240;
#line 1202
    if ((status & -17) == 128) {
#line 1204
      resultjiffies = jiffies;
#line 1205
      resultsize = i;
#line 1207
      return (i);
    }
#line 1209
    if (status == 208) {
#line 1210
      tmp = fd_inb(5UL + fdc_state[fdc].address);
#line 1210
      reply_buffer[i] = (unsigned char )tmp;
    } else {
#line 1212
      break;
    }
#line 1198
    i ++;
  }
#line 1214
  if (! initialising) {
#line 1215
    printk("floppy%d: get result error. Fdc=%d Last status=%x Read bytes=%d\n", (int )current_drive,
           fdc, status, i);
#line 1218
    show_floppy();
  }
#line 1220
  fdc_state[fdc].reset = 1U;
#line 1221
  return (-1);
}
}
#line 1226 "floppy.c"
static int need_more_output(void) 
{ 
  int status ;
  int tmp ;

  {
#line 1229
  status = wait_til_ready();
#line 1229
  if (status < 0) {
#line 1230
    return (-1);
  }
#line 1231
  if ((status & 224) == 128) {
#line 1232
    return (-2);
  }
#line 1233
  tmp = result();
#line 1233
  return (tmp);
}
}
#line 1239 "floppy.c"
__inline static void perpendicular_mode(void) 
{ 
  unsigned char perp_mode ;

  {
#line 1243
  if ((int )raw_cmd->rate & 64) {
#line 1244
    switch ((int )raw_cmd->rate & 3) {
    case 0: 
#line 1246
    perp_mode = (unsigned char)2;
#line 1247
    break;
    case 3: 
#line 1249
    perp_mode = (unsigned char)3;
#line 1250
    break;
    default: 
#line 1252
    printk("floppy%d: Invalid data rate for perpendicular mode!\n", (int )current_drive);
#line 1253
    (*(cont->done))(0);
#line 1254
    fdc_state[fdc].reset = 1U;
#line 1257
    return;
    }
  } else {
#line 1260
    perp_mode = (unsigned char)0;
  }
#line 1262
  if (fdc_state[fdc].perp_mode == (unsigned int )perp_mode) {
#line 1263
    return;
  }
#line 1264
  if ((int )fdc_state[fdc].version >= 81) {
#line 1265
    output_byte((char)18);
#line 1266
    output_byte((char )perp_mode);
#line 1267
    fdc_state[fdc].perp_mode = (unsigned int )perp_mode;
  } else
#line 1268
  if (perp_mode) {
#line 1269
    printk("floppy%d: perpendicular mode not supported by this FDC.\n", (int )current_drive);
  }
#line 1271
  return;
}
}
#line 1273 "floppy.c"
static int fifo_depth  =    10;
#line 1274 "floppy.c"
static int no_fifo  ;
#line 1276 "floppy.c"
static int fdc_configure(void) 
{ 
  int tmp ;

  {
#line 1279
  output_byte((char)19);
#line 1280
  tmp = need_more_output();
#line 1280
  if (tmp != -2) {
#line 1281
    return (0);
  }
#line 1282
  output_byte((char)0);
#line 1283
  output_byte((char )((16 | (no_fifo & 32)) | (fifo_depth & 15)));
#line 1284
  output_byte((char)0);
#line 1286
  return (1);
}
}
#line 1310 "floppy.c"
static void fdc_specify(void) 
{ 
  unsigned char spec1 ;
  unsigned char spec2 ;
  unsigned long srt ;
  unsigned long hlt ;
  unsigned long hut ;
  unsigned long dtr ;
  unsigned long scale_dtr ;
  int hlt_max_code ;
  int hut_max_code ;
  int tmp ;
  int __x ;
  int __y ;
  int tmp___0 ;
  int __x___0 ;
  int __y___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 1314
  dtr = 500UL;
#line 1315
  scale_dtr = 500UL;
#line 1316
  hlt_max_code = 127;
#line 1317
  hut_max_code = 15;
#line 1319
  if (fdc_state[fdc].need_configure) {
#line 1319
    if ((int )fdc_state[fdc].version >= 69) {
#line 1320
      fdc_configure();
#line 1321
      fdc_state[fdc].need_configure = 0U;
    }
  }
#line 1325
  switch ((int )raw_cmd->rate & 3) {
  case 3: 
#line 1327
  dtr = 1000UL;
#line 1328
  break;
  case 1: 
#line 1330
  dtr = 300UL;
#line 1331
  if ((int )fdc_state[fdc].version >= 96) {
#line 1334
    output_byte((char)-114);
#line 1335
    tmp = need_more_output();
#line 1335
    if (tmp == -2) {
#line 1336
      output_byte((char )((int )current_drive & 3));
#line 1337
      output_byte((char)-64);
    }
  }
#line 1340
  break;
  case 2: 
#line 1342
  dtr = 250UL;
#line 1343
  break;
  }
#line 1346
  if ((int )fdc_state[fdc].version >= 64) {
#line 1347
    scale_dtr = dtr;
#line 1348
    hlt_max_code = 0;
#line 1349
    hut_max_code = 0;
  }
#line 1353
  srt = 16UL - (((drive_params[current_drive].srt * scale_dtr) / 1000UL + 500UL) - 1UL) / 500UL;
#line 1354
  if (slow_floppy) {
#line 1355
    srt /= 4UL;
  }
#line 1357
  __x = (int )srt;
#line 1357
  __y = 15;
#line 1357
  if (__x < __y) {
#line 1357
    tmp___0 = __x;
  } else {
#line 1357
    tmp___0 = __y;
  }
#line 1357
  srt = (unsigned long )tmp___0;
#line 1358
  __x___0 = (int )srt;
#line 1358
  __y___0 = 0;
#line 1358
  if (__x___0 > __y___0) {
#line 1358
    tmp___1 = __x___0;
  } else {
#line 1358
    tmp___1 = __y___0;
  }
#line 1358
  srt = (unsigned long )tmp___1;
#line 1360
  hlt = (((drive_params[current_drive].hlt * scale_dtr) / 2UL + 500UL) - 1UL) / 500UL;
#line 1361
  if (hlt < 1UL) {
#line 1362
    hlt = 1UL;
  } else
#line 1363
  if (hlt > 127UL) {
#line 1364
    hlt = (unsigned long )hlt_max_code;
  }
#line 1366
  hut = (((drive_params[current_drive].hut * scale_dtr) / 16UL + 500UL) - 1UL) / 500UL;
#line 1367
  if (hut < 1UL) {
#line 1368
    hut = 1UL;
  } else
#line 1369
  if (hut > 15UL) {
#line 1370
    hut = (unsigned long )hut_max_code;
  }
#line 1372
  spec1 = (unsigned char )((srt << 4) | hut);
#line 1373
  spec2 = (unsigned char )((hlt << 1) | (unsigned long )(use_virtual_dma & 1));
#line 1376
  if (fdc_state[fdc].spec1 != (int )spec1) {
#line 1376
    goto _L;
  } else
#line 1376
  if (fdc_state[fdc].spec2 != (int )spec2) {
    _L: /* CIL Label */ 
#line 1378
    output_byte((char)3);
#line 1379
    tmp___2 = (int )spec1;
#line 1379
    fdc_state[fdc].spec1 = tmp___2;
#line 1379
    output_byte((char )tmp___2);
#line 1380
    tmp___3 = (int )spec2;
#line 1380
    fdc_state[fdc].spec2 = tmp___3;
#line 1380
    output_byte((char )tmp___3);
  }
#line 1382
  return;
}
}
#line 1388 "floppy.c"
static int fdc_dtr(void) 
{ 
  int tmp ;

  {
#line 1391
  if (((int )raw_cmd->rate & 3) == fdc_state[fdc].dtr) {
#line 1392
    return (0);
  }
#line 1395
  fd_outb((int )raw_cmd->rate & 3, 7UL + fdc_state[fdc].address);
#line 1402
  fdc_state[fdc].dtr = (int )raw_cmd->rate & 3;
#line 1403
  tmp = fd_wait_for_completion(jiffies + 2UL, (void (*)(unsigned long  ))(& floppy_ready));
#line 1403
  return (tmp);
}
}
#line 1407 "floppy.c"
static void tell_sector(void) 
{ 


  {
#line 1409
  printk(": track %d, head %d, sector %d, size %d", (int )reply_buffer[3], (int )reply_buffer[4],
         (int )reply_buffer[5], (int )reply_buffer[6]);
#line 1411
  return;
}
}
#line 1420 "floppy.c"
static int interpret_errors(void) 
{ 
  char bad ;

  {
#line 1424
  if (inr != 7) {
#line 1425
    printk("floppy%d: -- FDC reply error", (int )current_drive);
#line 1426
    fdc_state[fdc].reset = 1U;
#line 1427
    return (1);
  }
#line 1431
  switch ((int )reply_buffer[0] & 192) {
  case 64: 
#line 1433
  if ((int )reply_buffer[1] & 128) {
#line 1434
    return (0);
  }
#line 1435
  bad = (char)1;
#line 1436
  if ((int )reply_buffer[1] & 2) {
#line 1437
    printk("floppy%d: Drive is write protected\n", (int )current_drive);
#line 1438
    clear_bit(5, (unsigned long volatile   *)(& drive_state[current_drive].flags));
#line 1439
    (*(cont->done))(0);
#line 1440
    bad = (char)2;
  } else
#line 1441
  if ((int )reply_buffer[1] & 4) {
#line 1442
    set_bit(0, & drive_state[current_drive].flags);
  } else
#line 1443
  if ((int )reply_buffer[1] & 16) {
#line 1444
    if ((int )drive_params[current_drive].flags & 16) {
#line 1445
      printk("floppy%d: Over/Underrun - retrying\n", (int )current_drive);
    }
#line 1446
    bad = (char)0;
  } else
#line 1447
  if ((unsigned int )*errors >= drive_params[current_drive].max_errors.reporting) {
#line 1448
    printk("floppy%d: ", (int )current_drive);
#line 1449
    if ((int )reply_buffer[0] & 16) {
#line 1450
      printk("Recalibrate failed!");
    } else
#line 1451
    if ((int )reply_buffer[2] & 32) {
#line 1452
      printk("data CRC error");
#line 1453
      tell_sector();
    } else
#line 1454
    if ((int )reply_buffer[1] & 32) {
#line 1455
      printk("CRC error");
#line 1456
      tell_sector();
    } else
#line 1457
    if ((int )reply_buffer[1] & 5) {
#line 1457
      goto _L;
    } else
#line 1457
    if ((int )reply_buffer[2] & 1) {
      _L: /* CIL Label */ 
#line 1459
      if (! probing) {
#line 1460
        printk("sector not found");
#line 1461
        tell_sector();
      } else {
#line 1463
        printk("probe failed...");
      }
    } else
#line 1464
    if ((int )reply_buffer[2] & 16) {
#line 1465
      printk("wrong cylinder");
    } else
#line 1466
    if ((int )reply_buffer[2] & 2) {
#line 1467
      printk("bad cylinder");
    } else {
#line 1469
      printk("unknown error. ST[0..2] are: 0x%x 0x%x 0x%x", (int )reply_buffer[0],
             (int )reply_buffer[1], (int )reply_buffer[2]);
#line 1472
      tell_sector();
    }
#line 1474
    printk("\n");
  }
#line 1477
  if ((int )reply_buffer[2] & 16) {
#line 1479
    drive_state[current_drive].track = (short)-3;
  } else
#line 1477
  if ((int )reply_buffer[2] & 2) {
#line 1479
    drive_state[current_drive].track = (short)-3;
  }
#line 1480
  return ((int )bad);
  case 128: 
#line 1482
  printk("floppy%d: Invalid FDC command given!\n", (int )current_drive);
#line 1483
  (*(cont->done))(0);
#line 1484
  return (2);
  case 192: 
#line 1486
  printk("floppy%d: Abnormal termination caused by polling\n", (int )current_drive);
#line 1487
  (*(cont->error))();
#line 1488
  return (2);
  default: 
#line 1490
  return (0);
  }
}
}
#line 1499 "floppy.c"
static void setup_rw_floppy(void) 
{ 
  int i ;
  int r ;
  int flags ;
  int dflags ;
  unsigned long ready_date ;
  void (*function)(unsigned long  ) ;
  int tmp ;
  int tmp___0 ;

  {
#line 1505
  flags = (int )raw_cmd->flags;
#line 1506
  if (flags & 3) {
#line 1507
    flags |= 8;
  }
#line 1509
  if (flags & 16) {
#line 1509
    if (! (flags & 4)) {
#line 1510
      ready_date = drive_state[current_drive].spinup_date + drive_params[current_drive].spinup;
#line 1515
      if ((long )(jiffies + (unsigned long )drive_params[current_drive].select_delay) - (long )ready_date < 0L) {
#line 1516
        ready_date -= (unsigned long )drive_params[current_drive].select_delay;
#line 1517
        function = (void (*)(unsigned long  ))(& floppy_start);
      } else {
#line 1519
        function = (void (*)(unsigned long  ))(& setup_rw_floppy);
      }
#line 1522
      tmp = fd_wait_for_completion(ready_date, function);
#line 1522
      if (tmp) {
#line 1523
        return;
      }
    }
  }
#line 1525
  dflags = (int )drive_state[current_drive].flags;
#line 1527
  if (flags & 1) {
#line 1528
    setup_DMA();
  } else
#line 1527
  if (flags & 2) {
#line 1528
    setup_DMA();
  }
#line 1530
  if (flags & 8) {
#line 1531
    do_floppy = & main_command_interrupt;
  }
#line 1533
  r = 0;
#line 1534
  i = 0;
#line 1534
  while (i < (int )raw_cmd->cmd_count) {
#line 1535
    tmp___0 = output_byte((char )raw_cmd->cmd[i]);
#line 1535
    r |= tmp___0;
#line 1534
    i ++;
  }
#line 1537
  debugt("rw_command: ");
#line 1539
  if (r) {
#line 1540
    (*(cont->error))();
#line 1541
    reset_fdc();
#line 1542
    return;
  }
#line 1545
  if (! (flags & 8)) {
#line 1546
    inr = result();
#line 1547
    (*(cont->interrupt))();
  } else
#line 1548
  if (flags & 64) {
#line 1549
    fd_watchdog();
  }
#line 1550
  return;
}
}
#line 1552 "floppy.c"
static int blind_seek  ;
#line 1558 "floppy.c"
static void seek_interrupt(void) 
{ 


  {
#line 1560
  debugt("seek interrupt:");
#line 1561
  if (inr != 2) {
#line 1562
    printk("floppy%d: seek failed\n", (int )current_drive);
#line 1563
    drive_state[current_drive].track = (short)-3;
#line 1564
    (*(cont->error))();
#line 1565
    (*(cont->redo))();
#line 1566
    return;
  } else
#line 1561
  if (((int )reply_buffer[0] & 248) != 32) {
#line 1562
    printk("floppy%d: seek failed\n", (int )current_drive);
#line 1563
    drive_state[current_drive].track = (short)-3;
#line 1564
    (*(cont->error))();
#line 1565
    (*(cont->redo))();
#line 1566
    return;
  }
#line 1568
  if ((int )drive_state[current_drive].track >= 0) {
#line 1568
    if ((int )drive_state[current_drive].track != (int )reply_buffer[1]) {
#line 1568
      if (! blind_seek) {
#line 1570
        if ((int )drive_params[current_drive].flags & 2) {
#line 1571
          printk("floppy%d: clearing NEWCHANGE flag because of effective seek\n",
                 (int )current_drive);
#line 1573
          printk("floppy%d: jiffies=%lu\n", (int )current_drive, jiffies);
        }
#line 1576
        clear_bit(2, (unsigned long volatile   *)(& drive_state[current_drive].flags));
#line 1577
        drive_state[current_drive].select_date = jiffies;
      }
    }
  }
#line 1579
  drive_state[current_drive].track = (short )reply_buffer[1];
#line 1580
  floppy_ready();
#line 1581
  return;
}
}
#line 1583 "floppy.c"
static void check_wp(void) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 1585
  tmp___0 = test_bit(1, (void const   *)(& drive_state[current_drive].flags));
#line 1585
  if (tmp___0) {
#line 1587
    output_byte((char)4);
#line 1588
    output_byte((char )((int )current_drive & 3));
#line 1589
    tmp = result();
#line 1589
    if (tmp != 1) {
#line 1590
      fdc_state[fdc].reset = 1U;
#line 1591
      return;
    }
#line 1593
    clear_bit(1, (unsigned long volatile   *)(& drive_state[current_drive].flags));
#line 1594
    clear_bit(0, (unsigned long volatile   *)(& drive_state[current_drive].flags));
#line 1596
    if ((int )drive_params[current_drive].flags & 2) {
#line 1597
      printk("floppy%d: checking whether disk is write protected\n", (int )current_drive);
#line 1598
      printk("floppy%d: wp=%x\n", (int )current_drive, (int )reply_buffer[0] & 64);
    }
#line 1601
    if (! ((int )reply_buffer[0] & 64)) {
#line 1602
      set_bit(5, & drive_state[current_drive].flags);
    } else {
#line 1604
      clear_bit(5, (unsigned long volatile   *)(& drive_state[current_drive].flags));
    }
  }
#line 1606
  return;
}
}
#line 1608 "floppy.c"
static void seek_floppy(void) 
{ 
  int track ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 1612
  blind_seek = 0;
#line 1615
  if ((int )drive_params[current_drive].flags & 2) {
#line 1616
    printk("floppy%d: calling disk change from seek\n", (int )current_drive);
  }
#line 1620
  tmp = test_bit(2, (void const   *)(& drive_state[current_drive].flags));
#line 1620
  if (! tmp) {
#line 1620
    tmp___0 = disk_change((int )current_drive);
#line 1620
    if (tmp___0) {
#line 1620
      if (raw_cmd->flags & 64U) {
#line 1626
        set_bit(4, & drive_state[current_drive].flags);
#line 1627
        (*(cont->done))(0);
#line 1628
        (*(cont->redo))();
#line 1629
        return;
      }
    }
  }
#line 1631
  if ((int )drive_state[current_drive].track <= -2) {
#line 1632
    recalibrate_floppy();
#line 1633
    return;
  } else {
#line 1634
    tmp___1 = test_bit(2, (void const   *)(& drive_state[current_drive].flags));
#line 1634
    if (tmp___1) {
#line 1634
      if (raw_cmd->flags & 64U) {
#line 1634
        if ((int )drive_state[current_drive].track <= -1) {
#line 1634
          goto _L___0;
        } else
#line 1634
        if ((int )drive_state[current_drive].track == raw_cmd->track) {
          _L___0: /* CIL Label */ 
#line 1639
          if (raw_cmd->track) {
#line 1640
            track = raw_cmd->track - 1;
          } else {
#line 1642
            if ((int )drive_params[current_drive].flags & 4) {
#line 1643
              set_dor(fdc, (char )(~ (16 << ((int )current_drive & 3))), (char)0);
#line 1644
              blind_seek = 1;
#line 1645
              raw_cmd->flags |= 128U;
            }
#line 1647
            track = 1;
          }
        } else {
#line 1634
          goto _L___1;
        }
      } else {
#line 1634
        goto _L___1;
      }
    } else {
      _L___1: /* CIL Label */ 
#line 1650
      check_wp();
#line 1651
      if (raw_cmd->track != (int )drive_state[current_drive].track) {
#line 1651
        if (raw_cmd->flags & 128U) {
#line 1653
          track = raw_cmd->track;
        } else {
#line 1655
          setup_rw_floppy();
#line 1656
          return;
        }
      } else {
#line 1655
        setup_rw_floppy();
#line 1656
        return;
      }
    }
  }
#line 1660
  do_floppy = & seek_interrupt;
#line 1661
  output_byte((char)15);
#line 1662
  output_byte((char )((int )current_drive & 3));
#line 1663
  tmp___2 = output_byte((char )track);
#line 1663
  if (tmp___2 < 0) {
#line 1663
    reset_fdc();
#line 1663
    return;
  }
#line 1664
  debugt("seek command:");
#line 1665
  return;
}
}
#line 1667 "floppy.c"
static void recal_interrupt(void) 
{ 


  {
#line 1669
  debugt("recal interrupt:");
#line 1670
  if (inr != 2) {
#line 1671
    fdc_state[fdc].reset = 1U;
  } else
#line 1672
  if ((int )reply_buffer[0] & 16) {
#line 1673
    switch ((int )drive_state[current_drive].track) {
    case -2: 
#line 1675
    debugt("recal interrupt need 1 recal:");
#line 1680
    (*(cont->error))();
#line 1681
    (*(cont->redo))();
#line 1682
    return;
    case -3: 
#line 1684
    debugt("recal interrupt need 2 recal:");
#line 1692
    if ((int )drive_params[current_drive].flags & 2) {
#line 1693
      printk("floppy%d: clearing NEWCHANGE flag because of second recalibrate\n",
             (int )current_drive);
    }
#line 1698
    clear_bit(2, (unsigned long volatile   *)(& drive_state[current_drive].flags));
#line 1699
    drive_state[current_drive].select_date = jiffies;
    default: 
#line 1702
    debugt("recal interrupt default:");
#line 1709
    drive_state[current_drive].track = (short)-2;
#line 1710
    break;
    }
  } else {
#line 1713
    drive_state[current_drive].track = (short )reply_buffer[1];
  }
#line 1714
  floppy_ready();
#line 1715
  return;
}
}
#line 1717 "floppy.c"
static void print_result(char *message , int inr___0 ) 
{ 
  int i ;

  {
#line 1721
  printk("floppy%d: %s ", (int )current_drive, message);
#line 1722
  if (inr___0 >= 0) {
#line 1723
    i = 0;
#line 1723
    while (i < inr___0) {
#line 1724
      printk("repl[%d]=%x ", i, (int )reply_buffer[i]);
#line 1723
      i ++;
    }
  }
#line 1725
  printk("\n");
#line 1726
  return;
}
}
#line 1729 "floppy.c"
irqreturn_t floppy_interrupt(int irq , void *dev_id ) 
{ 
  void (*handler)(void) ;
  int do_print ;
  unsigned long f ;
  int tmp ;
  int tmp___0 ;
  int max_sensei ;

  {
#line 1731
  handler = do_floppy;
#line 1735
  lasthandler = handler;
#line 1736
  interruptjiffies = jiffies;
#line 1738
  tmp = claim_dma_lock();
#line 1738
  f = (unsigned long )tmp;
#line 1739
  fd_disable_dma();
#line 1740
  release_dma_lock(f);
#line 1742
  floppy_enable_hlt();
#line 1743
  do_floppy = (void (*)(void))((void *)0);
#line 1744
  if (fdc >= 2) {
#line 1746
    printk("DOR0=%x\n", (int )fdc_state[0].dor);
#line 1747
    printk("floppy interrupt on bizarre fdc %d\n", fdc);
#line 1748
    printk("handler=%p\n", handler);
#line 1749
    is_alive("bizarre fdc");
#line 1750
    return (0);
  } else
#line 1744
  if (fdc_state[fdc].address == 0xffffffffffffffffUL) {
#line 1746
    printk("DOR0=%x\n", (int )fdc_state[0].dor);
#line 1747
    printk("floppy interrupt on bizarre fdc %d\n", fdc);
#line 1748
    printk("handler=%p\n", handler);
#line 1749
    is_alive("bizarre fdc");
#line 1750
    return (0);
  }
#line 1753
  fdc_state[fdc].reset = 0U;
#line 1763
  if (! handler) {
#line 1763
    if (print_unex) {
#line 1763
      if (! initialising) {
#line 1763
        tmp___0 = 1;
      } else {
#line 1763
        tmp___0 = 0;
      }
    } else {
#line 1763
      tmp___0 = 0;
    }
  } else {
#line 1763
    tmp___0 = 0;
  }
#line 1763
  do_print = tmp___0;
#line 1765
  inr = result();
#line 1766
  if (do_print) {
#line 1767
    print_result((char *)"unexpected interrupt", inr);
  }
#line 1768
  if (inr == 0) {
#line 1769
    max_sensei = 4;
#line 1770
    while (1) {
#line 1771
      output_byte((char)8);
#line 1772
      inr = result();
#line 1773
      if (do_print) {
#line 1774
        print_result((char *)"sensei", inr);
      }
#line 1775
      max_sensei --;
#line 1770
      if (((int )reply_buffer[0] & 131) != ((int )current_drive & 3)) {
#line 1770
        if (inr == 2) {
#line 1770
          if (! max_sensei) {
#line 1770
            break;
          }
        } else {
#line 1770
          break;
        }
      } else {
#line 1770
        break;
      }
    }
  }
#line 1779
  if (! handler) {
#line 1780
    fdc_state[fdc].reset = 1U;
#line 1781
    return (0);
  }
#line 1783
  schedule_bh(handler);
#line 1784
  is_alive("normal interrupt end");
#line 1787
  return (1);
}
}
#line 1790 "floppy.c"
static void recalibrate_floppy(void) 
{ 
  int tmp ;

  {
#line 1792
  debugt("recalibrate floppy:");
#line 1793
  do_floppy = & recal_interrupt;
#line 1794
  output_byte((char)7);
#line 1795
  tmp = output_byte((char )((int )current_drive & 3));
#line 1795
  if (tmp < 0) {
#line 1795
    reset_fdc();
#line 1795
    return;
  }
#line 1796
  return;
}
}
#line 1801 "floppy.c"
static void reset_interrupt(void) 
{ 


  {
#line 1803
  debugt("reset interrupt:");
#line 1804
  result();
#line 1805
  if (fdc_state[fdc].reset) {
#line 1806
    printk("reset set in interrupt, calling %p\n", cont->error);
#line 1807
    (*(cont->error))();
  }
#line 1809
  (*(cont->redo))();
#line 1810
  return;
}
}
#line 1816 "floppy.c"
static void reset_fdc(void) 
{ 
  unsigned long flags ;
  int tmp ;

  {
#line 1820
  do_floppy = & reset_interrupt;
#line 1821
  fdc_state[fdc].reset = 0U;
#line 1822
  reset_fdc_info(0);
#line 1827
  tmp = claim_dma_lock();
#line 1827
  flags = (unsigned long )tmp;
#line 1828
  fd_disable_dma();
#line 1829
  release_dma_lock(flags);
#line 1831
  if ((int )fdc_state[fdc].version >= 69) {
#line 1832
    fd_outb(128 | (fdc_state[fdc].dtr & 3), 4UL + fdc_state[fdc].address);
  } else {
#line 1834
    fd_outb((int )fdc_state[fdc].dor & -5, 2UL + fdc_state[fdc].address);
#line 1835
    udelay(20);
#line 1836
    fd_outb((int )fdc_state[fdc].dor, 2UL + fdc_state[fdc].address);
  }
#line 1838
  return;
}
}
#line 1840 "floppy.c"
static void show_floppy(void) 
{ 
  int i ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 1844
  printk("\n");
#line 1845
  printk("floppy driver state\n");
#line 1846
  printk("-------------------\n");
#line 1847
  printk("now=%lu last interrupt=%lu diff=%lu last called handler=%p\n", jiffies,
         interruptjiffies, jiffies - interruptjiffies, lasthandler);
#line 1852
  printk("timeout_message=%s\n", timeout_message);
#line 1853
  printk("last output bytes:\n");
#line 1854
  i = 0;
#line 1854
  while (i < 20) {
#line 1855
    printk("%2x %2x %lu\n", (int )output_log[(i + output_log_pos) % 20].data, (int )output_log[(i + output_log_pos) % 20].status,
           output_log[(i + output_log_pos) % 20].jiffies);
#line 1854
    i ++;
  }
#line 1859
  printk("last result at %lu\n", resultjiffies);
#line 1860
  printk("last redo_fd_request at %lu\n", lastredo);
#line 1861
  i = 0;
#line 1861
  while (i < resultsize) {
#line 1862
    printk("%2x ", (int )reply_buffer[i]);
#line 1861
    i ++;
  }
#line 1864
  printk("\n");
#line 1867
  tmp = fd_inb(4UL + fdc_state[fdc].address);
#line 1867
  printk("status=%x\n", tmp);
#line 1868
  printk("fdc_busy=%lu\n", fdc_busy);
#line 1869
  if (do_floppy) {
#line 1870
    printk("do_floppy=%p\n", do_floppy);
  }
#line 1871
  if (floppy_work.pending) {
#line 1872
    printk("floppy_work.func=%p\n", floppy_work.func);
  }
#line 1873
  tmp___0 = timer_pending(& fd_timer);
#line 1873
  if (tmp___0) {
#line 1874
    printk("fd_timer.function=%p\n", fd_timer.function);
  }
#line 1875
  tmp___1 = timer_pending(& fd_timeout);
#line 1875
  if (tmp___1) {
#line 1876
    printk("timer_function=%p\n", fd_timeout.function);
#line 1877
    printk("expires=%lu\n", fd_timeout.expires - jiffies);
#line 1878
    printk("now=%lu\n", jiffies);
  }
#line 1880
  printk("cont=%p\n", cont);
#line 1881
  printk("current_req=%p\n", current_req);
#line 1882
  printk("command_status=%d\n", command_status);
#line 1883
  printk("\n");
#line 1884
  return;
}
}
#line 1886 "floppy.c"
static void floppy_shutdown(unsigned long data ) 
{ 
  unsigned long flags ;
  int tmp ;

  {
#line 1890
  if (! initialising) {
#line 1891
    show_floppy();
  }
#line 1892
  cancel_activity();
#line 1894
  floppy_enable_hlt();
#line 1896
  tmp = claim_dma_lock();
#line 1896
  flags = (unsigned long )tmp;
#line 1897
  fd_disable_dma();
#line 1898
  release_dma_lock(flags);
#line 1902
  if (! initialising) {
#line 1903
    printk("floppy%d: floppy timeout called\n", (int )current_drive);
  }
#line 1904
  fdc_state[fdc].reset = 1U;
#line 1905
  if (cont) {
#line 1906
    (*(cont->done))(0);
#line 1907
    (*(cont->redo))();
  } else {
#line 1909
    printk("no cont in shutdown!\n");
#line 1910
    process_fd_request();
  }
#line 1912
  is_alive("floppy shutdown");
#line 1913
  return;
}
}
#line 1918 "floppy.c"
static int start_motor(void (*function)(void) ) 
{ 
  int mask ;
  int data ;
  int tmp ;

  {
#line 1922
  mask = 252;
#line 1923
  data = (int )current_drive & 3;
#line 1924
  if (! (raw_cmd->flags & 4U)) {
#line 1925
    if (! ((int )fdc_state[fdc].dor & (16 << ((int )current_drive & 3)))) {
#line 1926
      set_debugt();
#line 1928
      drive_state[current_drive].first_read_date = 0UL;
#line 1930
      drive_state[current_drive].spinup_date = jiffies;
#line 1931
      data |= 16 << ((int )current_drive & 3);
    }
  } else
#line 1933
  if ((int )fdc_state[fdc].dor & (16 << ((int )current_drive & 3))) {
#line 1934
    mask &= ~ (16 << ((int )current_drive & 3));
  }
#line 1937
  del_timer(motor_off_timer + (int )current_drive);
#line 1938
  set_dor(fdc, (char )mask, (char )data);
#line 1941
  tmp = fd_wait_for_completion(drive_state[current_drive].select_date + (unsigned long )drive_params[current_drive].select_delay,
                               (void (*)(unsigned long  ))function);
#line 1941
  return (tmp);
}
}
#line 1945 "floppy.c"
static void floppy_ready(void) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 1947
  if (fdc_state[fdc].reset) {
#line 1947
    reset_fdc();
#line 1947
    return;
  }
#line 1948
  tmp = start_motor(& floppy_ready);
#line 1948
  if (tmp) {
#line 1949
    return;
  }
#line 1950
  tmp___0 = fdc_dtr();
#line 1950
  if (tmp___0) {
#line 1951
    return;
  }
#line 1954
  if ((int )drive_params[current_drive].flags & 2) {
#line 1955
    printk("floppy%d: calling disk change from floppy_ready\n", (int )current_drive);
  }
#line 1958
  if (! (raw_cmd->flags & 4U)) {
#line 1958
    tmp___1 = disk_change((int )current_drive);
#line 1958
    if (tmp___1) {
#line 1958
      if (! drive_params[current_drive].select_delay) {
#line 1960
        twaddle();
      }
    }
  }
#line 1971
  if (raw_cmd->flags & 192U) {
#line 1972
    perpendicular_mode();
#line 1973
    fdc_specify();
#line 1974
    seek_floppy();
  } else {
#line 1976
    if (raw_cmd->flags & 1U) {
#line 1978
      fdc_specify();
    } else
#line 1976
    if (raw_cmd->flags & 2U) {
#line 1978
      fdc_specify();
    }
#line 1979
    setup_rw_floppy();
  }
#line 1981
  return;
}
}
#line 1983 "floppy.c"
static void floppy_start(void) 
{ 


  {
#line 1985
  reschedule_timeout(-1, "floppy start", 0);
#line 1987
  scandrives();
#line 1989
  if ((int )drive_params[current_drive].flags & 2) {
#line 1990
    printk("floppy%d: setting NEWCHANGE in floppy_start\n", (int )current_drive);
  }
#line 1993
  set_bit(2, & drive_state[current_drive].flags);
#line 1994
  floppy_ready();
#line 1995
  return;
}
}
#line 2011 "floppy.c"
static void do_wakeup(void) 
{ 


  {
#line 2013
  reschedule_timeout(-2, "do wakeup", 0);
#line 2014
  cont = (struct cont_t *)((void *)0);
#line 2015
  command_status += (int volatile   )2;
#line 2016
  wake_up(& command_done);
#line 2017
  return;
}
}
#line 2019 "floppy.c"
static struct cont_t wakeup_cont  =    {& empty, & do_wakeup, & empty, (void (*)(int  ))(& empty)};
#line 2026 "floppy.c"
static struct cont_t intr_cont  =    {& empty, & process_fd_request, & empty, (void (*)(int  ))(& empty)};
#line 2033 "floppy.c"
static int wait_til_done(void (*handler)(void) , int interruptible ) 
{ 
  int ret ;
  wait_queue_t wait ;
  int tmp ;
  struct task_struct *tmp___0 ;
  int tmp___1 ;
  struct task_struct *tmp___2 ;
  int tmp___3 ;

  {
#line 2037
  schedule_bh(handler);
#line 2039
  if (command_status < (int volatile   )2) {
#line 2039
    if (! interruptible) {
#line 2039
      goto _L;
    } else {
#line 2039
      tmp___2 = get_current();
#line 2039
      tmp___3 = signal_pending(tmp___2);
#line 2039
      if (! tmp___3) {
        _L: /* CIL Label */ 
#line 2042
        add_wait_queue(& command_done, & wait);
#line 2043
        while (1) {
#line 2044
          if (interruptible) {
#line 2044
            tmp = 1;
          } else {
#line 2044
            tmp = 2;
          }
#line 2044
          set_current_state(tmp);
#line 2048
          if (command_status >= (int volatile   )2) {
#line 2049
            break;
          } else
#line 2048
          if (! (! interruptible)) {
#line 2048
            tmp___0 = get_current();
#line 2048
            tmp___1 = signal_pending(tmp___0);
#line 2048
            if (tmp___1) {
#line 2049
              break;
            }
          }
#line 2051
          is_alive("wait_til_done");
#line 2053
          schedule();
        }
#line 2056
        set_current_state(0);
#line 2057
        remove_wait_queue(& command_done, & wait);
      }
    }
  }
#line 2060
  if (command_status < (int volatile   )2) {
#line 2061
    cancel_activity();
#line 2062
    cont = & intr_cont;
#line 2063
    reset_fdc();
#line 2064
    return (-4);
  }
#line 2067
  if (fdc_state[fdc].reset) {
#line 2068
    command_status = (int volatile   )2;
  }
#line 2069
  if (command_status == (int volatile   )3) {
#line 2070
    ret = 0;
  } else {
#line 2072
    ret = -5;
  }
#line 2073
  command_status = (int volatile   )-1;
#line 2074
  return (ret);
}
}
#line 2077 "floppy.c"
static void generic_done(int result___0 ) 
{ 


  {
#line 2079
  command_status = (int volatile   )result___0;
#line 2080
  cont = & wakeup_cont;
#line 2081
  return;
}
}
#line 2083 "floppy.c"
static void generic_success(void) 
{ 


  {
#line 2085
  (*(cont->done))(1);
#line 2086
  return;
}
}
#line 2088 "floppy.c"
static void generic_failure(void) 
{ 


  {
#line 2090
  (*(cont->done))(0);
#line 2091
  return;
}
}
#line 2093 "floppy.c"
static void success_and_wakeup(void) 
{ 


  {
#line 2095
  generic_success();
#line 2096
  (*(cont->redo))();
#line 2097
  return;
}
}
#line 2104 "floppy.c"
static int next_valid_format(void) 
{ 
  int probed_format ;

  {
#line 2108
  probed_format = (int )drive_state[current_drive].probed_format;
#line 2109
  while (1) {
#line 2110
    if (probed_format >= 8) {
#line 2111
      drive_state[current_drive].probed_format = (short)0;
#line 2112
      return (1);
    } else
#line 2110
    if (! drive_params[current_drive].autodetect[probed_format]) {
#line 2111
      drive_state[current_drive].probed_format = (short)0;
#line 2112
      return (1);
    }
#line 2114
    if (floppy_type[drive_params[current_drive].autodetect[probed_format]].sect) {
#line 2115
      drive_state[current_drive].probed_format = (short )probed_format;
#line 2116
      return (0);
    }
#line 2118
    probed_format ++;
  }
}
}
#line 2122 "floppy.c"
static void bad_flp_intr(void) 
{ 
  int err_count ;
  int tmp ;
  int __x ;
  int __y ;
  int tmp___0 ;

  {
#line 2126
  if (probing) {
#line 2127
    drive_state[current_drive].probed_format = (short )((int )drive_state[current_drive].probed_format + 1);
#line 2128
    tmp = next_valid_format();
#line 2128
    if (! tmp) {
#line 2129
      return;
    }
  }
#line 2131
  (*errors) ++;
#line 2131
  err_count = *errors;
#line 2132
  __x = (int )write_errors[current_drive].badness;
#line 2132
  __y = err_count;
#line 2132
  if (__x > __y) {
#line 2132
    tmp___0 = __x;
  } else {
#line 2132
    tmp___0 = __y;
  }
#line 2132
  write_errors[current_drive].badness = (unsigned int )tmp___0;
#line 2133
  if ((unsigned int )err_count > drive_params[current_drive].max_errors.abort) {
#line 2134
    (*(cont->done))(0);
  }
#line 2135
  if ((unsigned int )err_count > drive_params[current_drive].max_errors.reset) {
#line 2136
    fdc_state[fdc].reset = 1U;
  } else
#line 2137
  if ((unsigned int )err_count > drive_params[current_drive].max_errors.recal) {
#line 2138
    drive_state[current_drive].track = (short)-3;
  }
#line 2139
  return;
}
}
#line 2141 "floppy.c"
static void set_floppy(int drive ) 
{ 
  int type ;

  {
#line 2143
  type = (drive_state[drive].fd_device >> 2) & 31;
#line 2144
  if (type) {
#line 2145
    _floppy = floppy_type + type;
  } else {
#line 2147
    _floppy = current_type[drive];
  }
#line 2148
  return;
}
}
#line 2154 "floppy.c"
static void format_interrupt(void) 
{ 
  int tmp ;

  {
#line 2156
  tmp = interpret_errors();
#line 2156
  switch (tmp) {
  case 1: 
#line 2158
  (*(cont->error))();
  case 2: 
#line 2160
  break;
  case 0: 
#line 2162
  (*(cont->done))(1);
  }
#line 2164
  (*(cont->redo))();
#line 2165
  return;
}
}
#line 2170 "floppy.c"
static void setup_format_params(int track ) 
{ 
  struct fparm *here ;
  int il ;
  int n ;
  int count ;
  int head_shift ;
  int track_shift ;

  {
#line 2172
  here = (struct fparm *)floppy_track_buffer;
#line 2178
  raw_cmd = & default_raw_cmd;
#line 2179
  raw_cmd->track = track;
#line 2181
  raw_cmd->flags = 218U;
#line 2183
  raw_cmd->rate = (unsigned char )((int )_floppy->rate & 67);
#line 2184
  raw_cmd->cmd_count = (unsigned char)6;
#line 2185
  raw_cmd->cmd[0] = (unsigned char )(77 & ~ (((int )_floppy->rate & 128) >> 1));
#line 2186
  raw_cmd->cmd[1] = (unsigned char )((unsigned int )((int )current_drive & 3) + ((((_floppy->stretch & 2U) >> 1) ^ format_req.head) << 2));
#line 2187
  raw_cmd->cmd[2] = (unsigned char )(((((int )_floppy->rate & 56) >> 3) + 2) % 8);
#line 2188
  raw_cmd->cmd[3] = (unsigned char )((_floppy->sect << 2) >> (int )raw_cmd->cmd[2]);
#line 2189
  raw_cmd->cmd[4] = _floppy->fmt_gap;
#line 2190
  raw_cmd->cmd[5] = (unsigned char)246;
#line 2192
  raw_cmd->kernel_data = floppy_track_buffer;
#line 2193
  raw_cmd->length = (long )(4 * (int )raw_cmd->cmd[3]);
#line 2196
  head_shift = ((int )raw_cmd->cmd[3] + 5) / 6;
#line 2199
  track_shift = 2 * head_shift + 3;
#line 2202
  n = (int )(((unsigned int )track_shift * format_req.track + (unsigned int )head_shift * format_req.head) % (unsigned int )raw_cmd->cmd[3]);
#line 2206
  il = 1;
#line 2207
  if ((int )_floppy->fmt_gap < 34) {
#line 2208
    il ++;
  }
#line 2211
  count = 0;
#line 2211
  while (count < (int )raw_cmd->cmd[3]) {
#line 2212
    (here + count)->track = (unsigned char )format_req.track;
#line 2213
    (here + count)->head = (unsigned char )format_req.head;
#line 2214
    (here + count)->sect = (unsigned char)0;
#line 2215
    (here + count)->size = raw_cmd->cmd[2];
#line 2211
    count ++;
  }
#line 2218
  count = 1;
#line 2218
  while (count <= (int )raw_cmd->cmd[3]) {
#line 2219
    (here + n)->sect = (unsigned char )count;
#line 2220
    n = (n + il) % (int )raw_cmd->cmd[3];
#line 2221
    if ((here + n)->sect) {
#line 2222
      n ++;
#line 2223
      if (n >= (int )raw_cmd->cmd[3]) {
#line 2224
        n -= (int )raw_cmd->cmd[3];
#line 2225
        while ((here + n)->sect) {
#line 2226
          n ++;
        }
      }
    }
#line 2218
    count ++;
  }
#line 2230
  if (_floppy->stretch & 4U) {
#line 2231
    count = 0;
#line 2231
    while (count < (int )raw_cmd->cmd[3]) {
#line 2232
      (here + count)->sect = (unsigned char )((int )(here + count)->sect - 1);
#line 2231
      count ++;
    }
  }
#line 2234
  return;
}
}
#line 2236 "floppy.c"
static void redo_format(void) 
{ 


  {
#line 2238
  buffer_track = -1;
#line 2239
  setup_format_params((int )(format_req.track << (_floppy->stretch & 1U)));
#line 2240
  floppy_start();
#line 2241
  debugt("queue format request");
#line 2242
  return;
}
}
#line 2244 "floppy.c"
static struct cont_t format_cont  =    {& format_interrupt, & redo_format, & bad_flp_intr, & generic_done};
#line 2251 "floppy.c"
static int do_format(int drive , struct format_descr *tmp_format_req ) 
{ 
  int ret ;
  int tmp ;

  {
#line 2255
  tmp = _lock_fdc(drive, 1, 2255);
#line 2255
  if (tmp) {
#line 2255
    return (-4);
  }
#line 2256
  set_floppy(drive);
#line 2257
  if (! _floppy) {
#line 2263
    process_fd_request();
#line 2264
    return (-22);
  } else
#line 2257
  if (_floppy->track > (unsigned int )drive_params[current_drive].tracks) {
#line 2263
    process_fd_request();
#line 2264
    return (-22);
  } else
#line 2257
  if (tmp_format_req->track >= _floppy->track) {
#line 2263
    process_fd_request();
#line 2264
    return (-22);
  } else
#line 2257
  if (tmp_format_req->head >= _floppy->head) {
#line 2263
    process_fd_request();
#line 2264
    return (-22);
  } else
#line 2257
  if ((_floppy->sect << 2) % (unsigned int )(1 << ((((int )_floppy->rate & 56) >> 3) + 2) % 8)) {
#line 2263
    process_fd_request();
#line 2264
    return (-22);
  } else
#line 2257
  if (! _floppy->fmt_gap) {
#line 2263
    process_fd_request();
#line 2264
    return (-22);
  }
#line 2266
  format_req = *tmp_format_req;
#line 2267
  format_errors = 0;
#line 2268
  cont = & format_cont;
#line 2269
  errors = & format_errors;
#line 2270
  ret = wait_til_done(& redo_format, 1);
#line 2270
  if (ret == -4) {
#line 2270
    return (-4);
  }
#line 2271
  process_fd_request();
#line 2272
  return (ret);
}
}
#line 2280 "floppy.c"
static void floppy_end_request(struct request *req , int uptodate ) 
{ 
  unsigned int nr_sectors ;
  int tmp ;

  {
#line 2282
  nr_sectors = (unsigned int )current_count_sectors;
#line 2285
  if (! uptodate) {
#line 2286
    nr_sectors = req->current_nr_sectors;
  }
#line 2287
  tmp = end_that_request_first(req, uptodate, (int )nr_sectors);
#line 2287
  if (tmp) {
#line 2288
    return;
  }
#line 2289
  add_disk_randomness(req->rq_disk);
#line 2290
  floppy_off((unsigned int )((long )(req->rq_disk)->private_data));
#line 2291
  blkdev_dequeue_request(req);
#line 2292
  end_that_request_last(req, uptodate);
#line 2295
  current_req = (struct request *)((void *)0);
#line 2296
  return;
}
}
#line 2300 "floppy.c"
static void request_done(int uptodate ) 
{ 
  struct request_queue *q ;
  struct request *req ;
  unsigned long flags ;
  int block ;
  int __x ;
  int __y ;
  int tmp ;

  {
#line 2302
  q = floppy_queue;
#line 2303
  req = current_req;
#line 2307
  probing = 0;
#line 2308
  reschedule_timeout(-2, "request done %d", uptodate);
#line 2310
  if (! req) {
#line 2311
    printk("floppy.c: no request in request_done\n");
#line 2312
    return;
  }
#line 2315
  if (uptodate) {
#line 2318
    block = (int )((sector_t )current_count_sectors + req->sector);
#line 2319
    __x = (int )drive_state[current_drive].maxblock;
#line 2319
    __y = block;
#line 2319
    if (__x > __y) {
#line 2319
      tmp = __x;
    } else {
#line 2319
      tmp = __y;
    }
#line 2319
    drive_state[current_drive].maxblock = (short )tmp;
#line 2320
    if ((unsigned int )block > _floppy->sect) {
#line 2321
      drive_state[current_drive].maxtrack = (short)1;
    }
#line 2324
    spin_lock_irqsave(q->queue_lock, flags);
#line 2325
    floppy_end_request(req, 1);
#line 2326
    spin_unlock_irqrestore(q->queue_lock, flags);
  } else {
#line 2328
    if ((req->cmd_flags & 1U) == 1U) {
#line 2330
      (write_errors[current_drive].write_errors) ++;
#line 2331
      if (write_errors[current_drive].write_errors == 1U) {
#line 2332
        write_errors[current_drive].first_error_sector = req->sector;
#line 2333
        write_errors[current_drive].first_error_generation = drive_state[current_drive].generation;
      }
#line 2335
      write_errors[current_drive].last_error_sector = req->sector;
#line 2336
      write_errors[current_drive].last_error_generation = drive_state[current_drive].generation;
    }
#line 2338
    spin_lock_irqsave(q->queue_lock, flags);
#line 2339
    floppy_end_request(req, 0);
#line 2340
    spin_unlock_irqrestore(q->queue_lock, flags);
  }
#line 2342
  return;
}
}
#line 2345 "floppy.c"
static void rw_interrupt(void) 
{ 
  int nr_sectors ;
  int ssize ;
  int eoc ;
  int heads ;
  int __x ;
  int __y ;
  int tmp ;
  int __x___0 ;
  int __y___0 ;
  int tmp___0 ;
  int tmp___1 ;
  int __x___1 ;
  int __y___1 ;
  int tmp___2 ;

  {
#line 2349
  if ((int )reply_buffer[4] >= 2) {
#line 2353
    return;
  }
#line 2356
  if (! drive_state[current_drive].first_read_date) {
#line 2357
    drive_state[current_drive].first_read_date = jiffies;
  }
#line 2359
  nr_sectors = 0;
#line 2360
  ssize = ((1 << (int )raw_cmd->cmd[5]) + 3) >> 2;
#line 2362
  if ((int )reply_buffer[1] & 128) {
#line 2363
    eoc = 1;
  } else {
#line 2365
    eoc = 0;
  }
#line 2367
  if ((int )raw_cmd->cmd[0] & 128) {
#line 2368
    heads = 2;
  } else {
#line 2370
    heads = 1;
  }
#line 2372
  nr_sectors = ((((((((int )reply_buffer[3] - (int )raw_cmd->cmd[2]) * heads + (int )reply_buffer[4]) - (int )raw_cmd->cmd[3]) * (int )raw_cmd->cmd[6] + (int )reply_buffer[5]) - (int )raw_cmd->cmd[4]) + eoc) << (int )raw_cmd->cmd[5]) >> 2;
#line 2377
  if ((long )(nr_sectors / ssize) > ((((long )in_sector_offset + current_count_sectors) + (long )ssize) - 1L) / (long )ssize) {
#line 2379
    printk("floppy%d: long rw: %x instead of %lx\n", (int )current_drive, nr_sectors,
           current_count_sectors);
#line 2381
    printk("rs=%d s=%d\n", (int )reply_buffer[5], (int )raw_cmd->cmd[4]);
#line 2382
    printk("rh=%d h=%d\n", (int )reply_buffer[4], (int )raw_cmd->cmd[3]);
#line 2383
    printk("rt=%d t=%d\n", (int )reply_buffer[3], (int )raw_cmd->cmd[2]);
#line 2384
    printk("heads=%d eoc=%d\n", heads, eoc);
#line 2385
    printk("spt=%d st=%d ss=%d\n", (int )raw_cmd->cmd[6], (int )fsector_t, ssize);
#line 2387
    printk("in_sector_offset=%d\n", (int )in_sector_offset);
  }
#line 2391
  nr_sectors -= (int )in_sector_offset;
#line 2392
  __x = nr_sectors;
#line 2392
  __y = 0;
#line 2392
  if (__x > __y) {
#line 2392
    tmp = __x;
  } else {
#line 2392
    tmp = __y;
  }
#line 2392
  nr_sectors = tmp;
#line 2393
  __x___0 = (int )current_count_sectors;
#line 2393
  __y___0 = nr_sectors;
#line 2393
  if (__x___0 < __y___0) {
#line 2393
    tmp___0 = __x___0;
  } else {
#line 2393
    tmp___0 = __y___0;
  }
#line 2393
  current_count_sectors = (long )tmp___0;
#line 2395
  tmp___1 = interpret_errors();
#line 2395
  switch (tmp___1) {
  case 2: 
#line 2397
  (*(cont->redo))();
#line 2398
  return;
  case 1: 
#line 2400
  if (! current_count_sectors) {
#line 2401
    (*(cont->error))();
#line 2402
    (*(cont->redo))();
#line 2403
    return;
  }
#line 2405
  break;
  case 0: 
#line 2407
  if (! current_count_sectors) {
#line 2408
    (*(cont->redo))();
#line 2409
    return;
  }
#line 2411
  current_type[current_drive] = _floppy;
#line 2412
  floppy_sizes[((int )current_drive & 3) | (((int )current_drive & 4) << 5)] = (sector_t )_floppy->size;
#line 2413
  break;
  }
#line 2416
  if (probing) {
#line 2417
    if ((int )drive_params[current_drive].flags & 16) {
#line 2418
      printk("floppy%d: Auto-detected floppy type %s in fd%d\n", (int )current_drive,
             _floppy->name, (int )current_drive);
    }
#line 2420
    current_type[current_drive] = _floppy;
#line 2421
    floppy_sizes[((int )current_drive & 3) | (((int )current_drive & 4) << 5)] = (sector_t )_floppy->size;
#line 2422
    probing = 0;
  }
#line 2425
  if (((int )raw_cmd->cmd[0] | 192) != 230) {
#line 2428
    (*(cont->done))(1);
  } else
#line 2425
  if ((unsigned long )raw_cmd->kernel_data == (unsigned long )current_req->buffer) {
#line 2428
    (*(cont->done))(1);
  } else
#line 2429
  if (((int )raw_cmd->cmd[0] | 192) == 230) {
#line 2430
    buffer_track = raw_cmd->track;
#line 2431
    buffer_drive = (int )current_drive;
#line 2432
    __x___1 = buffer_max;
#line 2432
    __y___1 = nr_sectors + (int )fsector_t;
#line 2432
    if (__x___1 > __y___1) {
#line 2432
      tmp___2 = __x___1;
    } else {
#line 2432
      tmp___2 = __y___1;
    }
#line 2432
    buffer_max = tmp___2;
  }
#line 2434
  (*(cont->redo))();
#line 2435
  return;
}
}
#line 2438 "floppy.c"
static int buffer_chain_size(void) 
{ 
  struct bio *bio ;
  struct bio_vec *bv ;
  int size ;
  int i ;
  char *base ;
  void *tmp ;
  void *tmp___0 ;

  {
#line 2445
  tmp = page_address(((current_req->bio)->bi_io_vec + (current_req->bio)->bi_idx)->bv_page);
#line 2445
  base = (char *)(tmp + ((current_req->bio)->bi_io_vec + (current_req->bio)->bi_idx)->bv_offset);
#line 2446
  size = 0;
#line 2448
  if (current_req->bio) {
#line 2448
    bio = current_req->bio;
#line 2448
    while (bio) {
#line 2449
      bv = bio->bi_io_vec + bio->bi_idx;
#line 2449
      i = (int )bio->bi_idx;
#line 2449
      while (i < (int )bio->bi_vcnt) {
#line 2450
        tmp___0 = page_address(bv->bv_page);
#line 2450
        if ((unsigned long )(tmp___0 + bv->bv_offset) != (unsigned long )(base + size)) {
#line 2452
          break;
        }
#line 2454
        size = (int )((unsigned int )size + bv->bv_len);
#line 2449
        bv ++;
#line 2449
        i ++;
      }
#line 2448
      bio = bio->bi_next;
    }
  }
#line 2458
  return (size >> 9);
}
}
#line 2462 "floppy.c"
static int transfer_size(int ssize , int max_sector , int max_size ) 
{ 
  int __x ;
  int __y ;
  int tmp ;

  {
#line 2464
  __x = max_sector;
#line 2464
  __y = (int )fsector_t + max_size;
#line 2464
  if (__x < __y) {
#line 2464
    tmp = __x;
  } else {
#line 2464
    tmp = __y;
  }
#line 2464
  max_sector = tmp;
#line 2467
  max_sector = (int )((unsigned int )max_sector - ((unsigned int )max_sector % _floppy->sect) % (unsigned int )ssize);
#line 2470
  current_count_sectors = (long )(max_sector - (int )fsector_t);
#line 2472
  return (max_sector);
}
}
#line 2478 "floppy.c"
static void copy_buffer(int ssize , int max_sector , int max_sector_2 ) 
{ 
  int remaining ;
  struct bio_vec *bv ;
  struct bio *bio ;
  char *buffer ;
  char *dma_buffer ;
  int size ;
  int i ;
  int _x ;
  int _y ;
  int tmp ;
  int __x ;
  int __y ;
  int tmp___0 ;
  int _x___0 ;
  int _y___0 ;
  int tmp___1 ;
  int __x___0 ;
  int __y___0 ;
  int tmp___2 ;
  void *tmp___3 ;

  {
#line 2487
  _x = max_sector;
#line 2487
  _y = max_sector_2;
#line 2487
  if (_x < _y) {
#line 2487
    tmp = _x;
  } else {
#line 2487
    tmp = _y;
  }
#line 2487
  max_sector = transfer_size(ssize, tmp, (int )current_req->nr_sectors);
#line 2490
  if (current_count_sectors <= 0L) {
#line 2490
    if (((int )raw_cmd->cmd[0] | 192) == 197) {
#line 2490
      if ((unsigned long )buffer_max > (unsigned long )fsector_t + current_req->nr_sectors) {
#line 2492
        __x = buffer_max - (int )fsector_t;
#line 2492
        __y = (int )current_req->nr_sectors;
#line 2492
        if (__x < __y) {
#line 2492
          tmp___0 = __x;
        } else {
#line 2492
          tmp___0 = __y;
        }
#line 2492
        current_count_sectors = (long )tmp___0;
      }
    }
  }
#line 2495
  remaining = (int )(current_count_sectors << 9);
#line 2497
  if ((unsigned long )(remaining >> 9) > current_req->nr_sectors) {
#line 2497
    if (((int )raw_cmd->cmd[0] | 192) == 197) {
#line 2499
      printk("floppy%d: in copy buffer\n", (int )current_drive);
#line 2500
      printk("current_count_sectors=%ld\n", current_count_sectors);
#line 2501
      printk("remaining=%d\n", remaining >> 9);
#line 2502
      printk("current_req->nr_sectors=%ld\n", current_req->nr_sectors);
#line 2504
      printk("current_req->current_nr_sectors=%u\n", current_req->current_nr_sectors);
#line 2506
      printk("max_sector=%d\n", max_sector);
#line 2507
      printk("ssize=%d\n", ssize);
    }
  }
#line 2511
  _x___0 = max_sector;
#line 2511
  _y___0 = buffer_max;
#line 2511
  if (_x___0 > _y___0) {
#line 2511
    tmp___1 = _x___0;
  } else {
#line 2511
    tmp___1 = _y___0;
  }
#line 2511
  buffer_max = tmp___1;
#line 2513
  dma_buffer = floppy_track_buffer + (((int )fsector_t - buffer_min) << 9);
#line 2515
  size = (int )(current_req->current_nr_sectors << 9);
#line 2517
  if (current_req->bio) {
#line 2517
    bio = current_req->bio;
#line 2517
    while (bio) {
#line 2518
      bv = bio->bi_io_vec + bio->bi_idx;
#line 2518
      i = (int )bio->bi_idx;
#line 2518
      while (i < (int )bio->bi_vcnt) {
#line 2519
        if (! remaining) {
#line 2520
          break;
        }
#line 2522
        size = (int )bv->bv_len;
#line 2523
        __x___0 = size;
#line 2523
        __y___0 = remaining;
#line 2523
        if (__x___0 < __y___0) {
#line 2523
          tmp___2 = __x___0;
        } else {
#line 2523
          tmp___2 = __y___0;
        }
#line 2523
        size = tmp___2;
#line 2525
        tmp___3 = page_address(bv->bv_page);
#line 2525
        buffer = (char *)(tmp___3 + bv->bv_offset);
#line 2527
        if ((unsigned long )(dma_buffer + size) > (unsigned long )(floppy_track_buffer + (max_buffer_sectors << 10))) {
#line 2527
          goto _L;
        } else
#line 2527
        if ((unsigned long )dma_buffer < (unsigned long )floppy_track_buffer) {
          _L: /* CIL Label */ 
#line 2530
          printk("floppy%d: buffer overrun in copy buffer %d\n", (int )current_drive,
                 (int )((floppy_track_buffer - dma_buffer) >> 9));
#line 2533
          printk("fsector_t=%d buffer_min=%d\n", (int )fsector_t, buffer_min);
#line 2535
          printk("current_count_sectors=%ld\n", current_count_sectors);
#line 2537
          if (((int )raw_cmd->cmd[0] | 192) == 230) {
#line 2538
            printk("read\n");
          }
#line 2539
          if (((int )raw_cmd->cmd[0] | 192) == 197) {
#line 2540
            printk("write\n");
          }
#line 2541
          break;
        }
#line 2543
        if ((unsigned long )buffer % 512UL) {
#line 2544
          printk("floppy%d: %p buffer not aligned\n", (int )current_drive, buffer);
        }
#line 2546
        if (((int )raw_cmd->cmd[0] | 192) == 230) {
#line 2547
          memcpy((void *)buffer, (void const   *)dma_buffer, (__kernel_size_t )size);
        } else {
#line 2549
          memcpy((void *)dma_buffer, (void const   *)buffer, (__kernel_size_t )size);
        }
#line 2551
        remaining -= size;
#line 2552
        dma_buffer += size;
#line 2518
        bv ++;
#line 2518
        i ++;
      }
#line 2517
      bio = bio->bi_next;
    }
  }
#line 2556
  if (remaining) {
#line 2557
    if (remaining > 0) {
#line 2558
      max_sector -= remaining >> 9;
    }
#line 2559
    printk("floppy%d: weirdness: remaining %d\n", (int )current_drive, remaining >> 9);
  }
#line 2562
  return;
}
}
#line 2584 "floppy.c"
static void virtualdmabug_workaround(void) 
{ 
  int hard_sectors ;
  int end_sector ;

  {
#line 2588
  if (((int )raw_cmd->cmd[0] | 192) == 197) {
#line 2589
    raw_cmd->cmd[0] = (unsigned char )((int )raw_cmd->cmd[0] & -129);
#line 2591
    hard_sectors = (int )(raw_cmd->length >> (7 + (int )raw_cmd->cmd[5]));
#line 2592
    end_sector = ((int )raw_cmd->cmd[4] + hard_sectors) - 1;
#line 2594
    if (end_sector > (int )raw_cmd->cmd[6]) {
#line 2595
      printk("too many sectors %d > %d\n", end_sector, (int )raw_cmd->cmd[6]);
#line 2597
      return;
    }
#line 2600
    raw_cmd->cmd[6] = (unsigned char )end_sector;
  }
#line 2603
  return;
}
}
#line 2756
extern int ( /* missing proto */  CROSS_64KB)() ;
#line 2615 "floppy.c"
static int make_raw_rw_request(void) 
{ 
  int aligned_sector_t ;
  int max_sector ;
  int max_size ;
  int tracksize ;
  int ssize ;
  int tmp ;
  int __x ;
  int __y ;
  int tmp___0 ;
  int tmp___1 ;
  unsigned long dma_limit ;
  int direct ;
  int indirect ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 2620
  if (max_buffer_sectors == 0) {
#line 2621
    printk("VFS: Block I/O scheduled on unopened device\n");
#line 2622
    return (0);
  }
#line 2625
  set_fdc((int )((long )(current_req->rq_disk)->private_data));
#line 2627
  raw_cmd = & default_raw_cmd;
#line 2628
  raw_cmd->flags = 208U;
#line 2630
  raw_cmd->cmd_count = (unsigned char)9;
#line 2631
  if ((current_req->cmd_flags & 1U) == 0U) {
#line 2632
    raw_cmd->flags |= 1U;
#line 2633
    raw_cmd->cmd[0] = (unsigned char )(230 & ~ (((int )_floppy->rate & 128) >> 1));
  } else
#line 2634
  if ((current_req->cmd_flags & 1U) == 1U) {
#line 2635
    raw_cmd->flags |= 2U;
#line 2636
    raw_cmd->cmd[0] = (unsigned char )(197 & ~ (((int )_floppy->rate & 128) >> 1));
  } else {
#line 2638
    printk("floppy%d: make_raw_rw_request: unknown command\n", (int )current_drive);
#line 2639
    return (0);
  }
#line 2642
  max_sector = (int )(_floppy->sect * _floppy->head);
#line 2644
  raw_cmd->cmd[2] = (unsigned char )((int )current_req->sector / max_sector);
#line 2645
  fsector_t = (unsigned char )((int )current_req->sector % max_sector);
#line 2646
  if (_floppy->track) {
#line 2646
    if ((unsigned int )raw_cmd->cmd[2] >= _floppy->track) {
#line 2647
      if (current_req->current_nr_sectors & 1U) {
#line 2648
        current_count_sectors = 1L;
#line 2649
        return (1);
      } else {
#line 2651
        return (0);
      }
    }
  }
#line 2653
  raw_cmd->cmd[3] = (unsigned char )((unsigned int )fsector_t / _floppy->sect);
#line 2655
  if (_floppy->stretch & 6U) {
#line 2655
    goto _L;
  } else {
#line 2655
    tmp = test_bit(0, (void const   *)(& drive_state[current_drive].flags));
#line 2655
    if (tmp) {
      _L: /* CIL Label */ 
#line 2655
      if ((unsigned int )fsector_t < _floppy->sect) {
#line 2657
        max_sector = (int )_floppy->sect;
      }
    }
  }
#line 2660
  if ((int )_floppy->rate & 4) {
#line 2660
    if (! raw_cmd->cmd[2]) {
#line 2660
      if (! raw_cmd->cmd[3]) {
#line 2661
        max_sector = (int )((2U * _floppy->sect) / 3U);
#line 2662
        if ((int )fsector_t >= max_sector) {
#line 2664
          __x = (int )(_floppy->sect - (unsigned int )fsector_t);
#line 2664
          __y = (int )current_req->nr_sectors;
#line 2664
          if (__x < __y) {
#line 2664
            tmp___0 = __x;
          } else {
#line 2664
            tmp___0 = __y;
          }
#line 2664
          current_count_sectors = (long )tmp___0;
#line 2666
          return (1);
        }
#line 2668
        raw_cmd->cmd[5] = (unsigned char)2;
      } else {
#line 2670
        raw_cmd->cmd[5] = (unsigned char )(((((int )_floppy->rate & 56) >> 3) + 2) % 8);
      }
    } else {
#line 2670
      raw_cmd->cmd[5] = (unsigned char )(((((int )_floppy->rate & 56) >> 3) + 2) % 8);
    }
  } else {
#line 2670
    raw_cmd->cmd[5] = (unsigned char )(((((int )_floppy->rate & 56) >> 3) + 2) % 8);
  }
#line 2671
  raw_cmd->rate = (unsigned char )((int )_floppy->rate & 67);
#line 2672
  if ((int )_floppy->rate & 4) {
#line 2672
    if (raw_cmd->cmd[2]) {
#line 2672
      goto _L___0;
    } else
#line 2672
    if (raw_cmd->cmd[3]) {
      _L___0: /* CIL Label */ 
#line 2672
      if ((int )raw_cmd->rate == 2) {
#line 2673
        raw_cmd->rate = (unsigned char)1;
      }
    }
  }
#line 2675
  if (raw_cmd->cmd[5]) {
#line 2676
    raw_cmd->cmd[8] = (unsigned char)255;
  } else {
#line 2678
    raw_cmd->cmd[8] = (unsigned char)128;
  }
#line 2679
  raw_cmd->track = (int )raw_cmd->cmd[2] << (_floppy->stretch & 1U);
#line 2680
  raw_cmd->cmd[1] = (unsigned char )((unsigned int )((int )current_drive & 3) + ((((_floppy->stretch & 2U) >> 1) ^ (unsigned int )raw_cmd->cmd[3]) << 2));
#line 2681
  raw_cmd->cmd[7] = _floppy->gap;
#line 2682
  ssize = ((1 << (int )raw_cmd->cmd[5]) + 3) >> 2;
#line 2683
  raw_cmd->cmd[6] = (unsigned char )((_floppy->sect << 2) >> (int )raw_cmd->cmd[5]);
#line 2684
  if (_floppy->stretch & 4U) {
#line 2684
    tmp___1 = 0;
  } else {
#line 2684
    tmp___1 = 1;
  }
#line 2684
  raw_cmd->cmd[4] = (unsigned char )((((unsigned int )fsector_t % _floppy->sect << 2) >> (int )raw_cmd->cmd[5]) + (unsigned int )tmp___1);
#line 2690
  tracksize = (int )(_floppy->sect - _floppy->sect % (unsigned int )ssize);
#line 2691
  if ((unsigned int )tracksize < _floppy->sect) {
#line 2692
    raw_cmd->cmd[6] = (unsigned char )((int )raw_cmd->cmd[6] + 1);
#line 2693
    if ((unsigned int )tracksize <= (unsigned int )fsector_t % _floppy->sect) {
#line 2694
      raw_cmd->cmd[4] = (unsigned char )((int )raw_cmd->cmd[4] - 1);
    }
#line 2697
    while ((unsigned int )tracksize <= (unsigned int )fsector_t % _floppy->sect) {
#line 2698
      while ((unsigned int )(tracksize + ssize) > _floppy->sect) {
#line 2699
        raw_cmd->cmd[5] = (unsigned char )((int )raw_cmd->cmd[5] - 1);
#line 2700
        ssize >>= 1;
      }
#line 2702
      raw_cmd->cmd[4] = (unsigned char )((int )raw_cmd->cmd[4] + 1);
#line 2703
      raw_cmd->cmd[6] = (unsigned char )((int )raw_cmd->cmd[6] + 1);
#line 2704
      tracksize += ssize;
    }
#line 2706
    max_sector = (int )((unsigned int )raw_cmd->cmd[3] * _floppy->sect + (unsigned int )tracksize);
  } else
#line 2707
  if (! raw_cmd->cmd[2]) {
#line 2707
    if (! raw_cmd->cmd[3]) {
#line 2707
      if (! ((int )_floppy->rate & 4)) {
#line 2707
        if (probing) {
#line 2708
          max_sector = (int )_floppy->sect;
        } else {
#line 2707
          goto _L___3;
        }
      } else {
#line 2707
        goto _L___3;
      }
    } else {
#line 2707
      goto _L___3;
    }
  } else
  _L___3: /* CIL Label */ 
#line 2709
  if (! raw_cmd->cmd[3]) {
#line 2709
    if (((int )raw_cmd->cmd[0] | 192) == 197) {
#line 2711
      max_sector = (int )_floppy->sect;
    }
  }
#line 2714
  in_sector_offset = (unsigned char )(((unsigned int )fsector_t % _floppy->sect) % (unsigned int )ssize);
#line 2715
  aligned_sector_t = (int )fsector_t - (int )in_sector_offset;
#line 2716
  max_size = (int )current_req->nr_sectors;
#line 2717
  if (raw_cmd->track == buffer_track) {
#line 2717
    if ((int )current_drive == buffer_drive) {
#line 2717
      if ((int )fsector_t >= buffer_min) {
#line 2717
        if ((int )fsector_t < buffer_max) {
#line 2721
          if (((int )raw_cmd->cmd[0] | 192) == 230) {
#line 2722
            copy_buffer(1, max_sector, buffer_max);
#line 2723
            return (1);
          }
        } else {
#line 2717
          goto _L___9;
        }
      } else {
#line 2717
        goto _L___9;
      }
    } else {
#line 2717
      goto _L___9;
    }
  } else
  _L___9: /* CIL Label */ 
#line 2725
  if (in_sector_offset) {
#line 2725
    goto _L___6;
  } else
#line 2725
  if (current_req->nr_sectors < (unsigned long )ssize) {
    _L___6: /* CIL Label */ 
#line 2726
    if (((int )raw_cmd->cmd[0] | 192) == 197) {
#line 2727
      if ((unsigned long )fsector_t + current_req->nr_sectors > (unsigned long )ssize) {
#line 2727
        if ((unsigned long )fsector_t + current_req->nr_sectors < (unsigned long )(ssize + ssize)) {
#line 2729
          max_size = ssize + ssize;
        } else {
#line 2731
          max_size = ssize;
        }
      } else {
#line 2731
        max_size = ssize;
      }
    }
#line 2733
    raw_cmd->flags &= 4294967293U;
#line 2734
    raw_cmd->flags |= 1U;
#line 2735
    raw_cmd->cmd[0] = (unsigned char )(230 & ~ (((int )_floppy->rate & 128) >> 1));
  } else
#line 2736
  if ((unsigned long )current_req->buffer < 3238002688UL) {
#line 2740
    tmp___2 = transfer_size(ssize, max_sector, max_buffer_sectors * 2);
#line 2740
    indirect = tmp___2 - (int )fsector_t;
#line 2748
    max_size = buffer_chain_size();
#line 2749
    dma_limit = (3238002688UL - (unsigned long )current_req->buffer) >> 9;
#line 2752
    if ((unsigned long )max_size > dma_limit) {
#line 2753
      max_size = (int )dma_limit;
    }
#line 2756
    tmp___3 = CROSS_64KB(current_req->buffer, max_size << 9);
#line 2756
    if (tmp___3) {
#line 2757
      max_size = (int )((65536UL - (unsigned long )current_req->buffer % 65536UL) >> 9);
    }
#line 2760
    tmp___4 = transfer_size(ssize, max_sector, max_size);
#line 2760
    direct = tmp___4 - (int )fsector_t;
#line 2768
    if (! direct) {
#line 2774
      max_size = (int )current_req->nr_sectors;
    } else
#line 2768
    if (indirect * 2 > direct * 3) {
#line 2768
      if ((unsigned int )*errors < drive_params[current_drive].max_errors.read_track) {
#line 2768
        if (! probing) {
#line 2774
          max_size = (int )current_req->nr_sectors;
        } else
#line 2768
        if ((int )drive_params[current_drive].read_track & (1 << (int )drive_state[current_drive].probed_format)) {
#line 2774
          max_size = (int )current_req->nr_sectors;
        } else {
#line 2768
          goto _L___5;
        }
      } else {
#line 2768
        goto _L___5;
      }
    } else {
      _L___5: /* CIL Label */ 
#line 2776
      raw_cmd->kernel_data = current_req->buffer;
#line 2777
      raw_cmd->length = current_count_sectors << 9;
#line 2778
      if (raw_cmd->length == 0L) {
#line 2779
        printk("floppy%d: zero dma transfer attempted from make_raw_request\n", (int )current_drive);
#line 2781
        printk("floppy%d: indirect=%d direct=%d fsector_t=%d", (int )current_drive,
               indirect, direct, (int )fsector_t);
#line 2783
        return (0);
      }
#line 2789
      virtualdmabug_workaround();
#line 2790
      return (2);
    }
  }
#line 2794
  if (((int )raw_cmd->cmd[0] | 192) == 230) {
#line 2795
    max_size = max_sector;
  }
#line 2798
  if (buffer_track != raw_cmd->track) {
#line 2808
    buffer_track = -1;
#line 2809
    buffer_drive = (int )current_drive;
#line 2810
    buffer_min = aligned_sector_t;
#line 2810
    buffer_max = buffer_min;
  } else
#line 2798
  if (buffer_drive != (int )current_drive) {
#line 2808
    buffer_track = -1;
#line 2809
    buffer_drive = (int )current_drive;
#line 2810
    buffer_min = aligned_sector_t;
#line 2810
    buffer_max = buffer_min;
  } else
#line 2798
  if ((int )fsector_t > buffer_max) {
#line 2808
    buffer_track = -1;
#line 2809
    buffer_drive = (int )current_drive;
#line 2810
    buffer_min = aligned_sector_t;
#line 2810
    buffer_max = buffer_min;
  } else
#line 2798
  if ((int )fsector_t < buffer_min) {
#line 2808
    buffer_track = -1;
#line 2809
    buffer_drive = (int )current_drive;
#line 2810
    buffer_min = aligned_sector_t;
#line 2810
    buffer_max = buffer_min;
  } else
#line 2798
  if (((int )raw_cmd->cmd[0] | 192) == 230) {
#line 2798
    goto _L___10;
  } else
#line 2798
  if (! in_sector_offset) {
#line 2798
    if (current_req->nr_sectors >= (unsigned long )ssize) {
      _L___10: /* CIL Label */ 
#line 2798
      if (max_sector > 2 * max_buffer_sectors + buffer_min) {
#line 2798
        if (max_size + (int )fsector_t > 2 * max_buffer_sectors + buffer_min) {
#line 2808
          buffer_track = -1;
#line 2809
          buffer_drive = (int )current_drive;
#line 2810
          buffer_min = aligned_sector_t;
#line 2810
          buffer_max = buffer_min;
        }
      }
    }
  }
#line 2812
  raw_cmd->kernel_data = floppy_track_buffer + ((aligned_sector_t - buffer_min) << 9);
#line 2815
  if (((int )raw_cmd->cmd[0] | 192) == 197) {
#line 2821
    if (in_sector_offset) {
#line 2821
      if (buffer_track == -1) {
#line 2822
        printk("floppy%d: internal error offset !=0 on write\n", (int )current_drive);
      }
    }
#line 2824
    buffer_track = raw_cmd->track;
#line 2825
    buffer_drive = (int )current_drive;
#line 2826
    copy_buffer(ssize, max_sector, 2 * max_buffer_sectors + buffer_min);
  } else {
#line 2829
    transfer_size(ssize, max_sector, (2 * max_buffer_sectors + buffer_min) - aligned_sector_t);
  }
#line 2834
  raw_cmd->length = (long )in_sector_offset + current_count_sectors;
#line 2835
  raw_cmd->length = ((raw_cmd->length - 1L) | (long )(ssize - 1)) + 1L;
#line 2836
  raw_cmd->length <<= 9;
#line 2840
  if (raw_cmd->length < current_count_sectors << 9) {
#line 2840
    goto _L___11;
  } else
#line 2840
  if ((unsigned long )raw_cmd->kernel_data != (unsigned long )current_req->buffer) {
#line 2840
    if (((int )raw_cmd->cmd[0] | 192) == 197) {
#line 2840
      if ((long )aligned_sector_t + (raw_cmd->length >> 9) > (long )buffer_max) {
#line 2840
        goto _L___11;
      } else
#line 2840
      if (aligned_sector_t < buffer_min) {
#line 2840
        goto _L___11;
      } else {
#line 2840
        goto _L___13;
      }
    } else {
#line 2840
      goto _L___13;
    }
  } else
  _L___13: /* CIL Label */ 
#line 2840
  if (raw_cmd->length % (long )(128 << (int )raw_cmd->cmd[5])) {
#line 2840
    goto _L___11;
  } else
#line 2840
  if (raw_cmd->length <= 0L) {
#line 2840
    goto _L___11;
  } else
#line 2840
  if (current_count_sectors <= 0L) {
    _L___11: /* CIL Label */ 
#line 2847
    printk("floppy%d: fractionary current count b=%lx s=%lx\n", (int )current_drive,
           raw_cmd->length, current_count_sectors);
#line 2849
    if ((unsigned long )raw_cmd->kernel_data != (unsigned long )current_req->buffer) {
#line 2850
      printk("addr=%d, length=%ld\n", (int )((raw_cmd->kernel_data - floppy_track_buffer) >> 9),
             current_count_sectors);
    }
#line 2854
    printk("st=%d ast=%d mse=%d msi=%d\n", (int )fsector_t, aligned_sector_t, max_sector,
           max_size);
#line 2856
    printk("ssize=%x SIZECODE=%d\n", ssize, (int )raw_cmd->cmd[5]);
#line 2857
    printk("command=%x SECTOR=%d HEAD=%d, TRACK=%d\n", (int )raw_cmd->cmd[0], (int )raw_cmd->cmd[4],
           (int )raw_cmd->cmd[3], (int )raw_cmd->cmd[2]);
#line 2859
    printk("buffer drive=%d\n", buffer_drive);
#line 2860
    printk("buffer track=%d\n", buffer_track);
#line 2861
    printk("buffer_min=%d\n", buffer_min);
#line 2862
    printk("buffer_max=%d\n", buffer_max);
#line 2863
    return (0);
  }
#line 2866
  if ((unsigned long )raw_cmd->kernel_data != (unsigned long )current_req->buffer) {
#line 2867
    if ((unsigned long )raw_cmd->kernel_data < (unsigned long )floppy_track_buffer) {
#line 2867
      goto _L___14;
    } else
#line 2867
    if (current_count_sectors < 0L) {
#line 2867
      goto _L___14;
    } else
#line 2867
    if (raw_cmd->length < 0L) {
#line 2867
      goto _L___14;
    } else
#line 2867
    if ((unsigned long )(raw_cmd->kernel_data + raw_cmd->length) > (unsigned long )(floppy_track_buffer + (max_buffer_sectors << 10))) {
      _L___14: /* CIL Label */ 
#line 2872
      printk("floppy%d: buffer overrun in schedule dma\n", (int )current_drive);
#line 2873
      printk("fsector_t=%d buffer_min=%d current_count=%ld\n", (int )fsector_t, buffer_min,
             raw_cmd->length >> 9);
#line 2875
      printk("current_count_sectors=%ld\n", current_count_sectors);
#line 2877
      if (((int )raw_cmd->cmd[0] | 192) == 230) {
#line 2878
        printk("read\n");
      }
#line 2879
      if (((int )raw_cmd->cmd[0] | 192) == 197) {
#line 2880
        printk("write\n");
      }
#line 2881
      return (0);
    }
  } else
#line 2883
  if ((unsigned long )raw_cmd->length > current_req->nr_sectors << 9) {
#line 2885
    printk("floppy%d: buffer overrun in direct transfer\n", (int )current_drive);
#line 2886
    return (0);
  } else
#line 2883
  if ((unsigned long )current_count_sectors > current_req->nr_sectors) {
#line 2885
    printk("floppy%d: buffer overrun in direct transfer\n", (int )current_drive);
#line 2886
    return (0);
  } else
#line 2887
  if (raw_cmd->length < current_count_sectors << 9) {
#line 2888
    printk("floppy%d: more sectors than bytes\n", (int )current_drive);
#line 2889
    printk("bytes=%ld\n", raw_cmd->length >> 9);
#line 2890
    printk("sectors=%ld\n", current_count_sectors);
  }
#line 2892
  if (raw_cmd->length == 0L) {
#line 2893
    printk("floppy%d: zero dma transfer attempted from make_raw_request\n", (int )current_drive);
#line 2894
    return (0);
  }
#line 2898
  virtualdmabug_workaround();
#line 2899
  return (2);
}
}
#line 2902 "floppy.c"
static void redo_fd_request(void) 
{ 
  int drive ;
  int tmp ;
  struct request *req ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 2908
  lastredo = jiffies;
#line 2909
  if ((int )current_drive < 8) {
#line 2910
    floppy_off((unsigned int )current_drive);
  }
#line 2912
  while (1) {
#line 2913
    if (! current_req) {
#line 2916
      spin_lock_irq(floppy_queue->queue_lock);
#line 2917
      req = elv_next_request(floppy_queue);
#line 2918
      spin_unlock_irq(floppy_queue->queue_lock);
#line 2919
      if (! req) {
#line 2920
        do_floppy = (void (*)(void))((void *)0);
#line 2921
        unlock_fdc();
#line 2922
        return;
      }
#line 2924
      current_req = req;
    }
#line 2926
    drive = (int )((long )(current_req->rq_disk)->private_data);
#line 2927
    set_fdc(drive);
#line 2928
    reschedule_timeout(-1, "redo fd request", 0);
#line 2930
    set_floppy(drive);
#line 2931
    raw_cmd = & default_raw_cmd;
#line 2932
    raw_cmd->flags = 0U;
#line 2933
    tmp___0 = start_motor(& redo_fd_request);
#line 2933
    if (tmp___0) {
#line 2934
      return;
    }
#line 2935
    disk_change((int )current_drive);
#line 2936
    tmp___1 = test_bit((int )current_drive, (void const   *)(& fake_change));
#line 2936
    if (tmp___1) {
#line 2938
      printk("floppy%d: disk absent or changed during operation\n", (int )current_drive);
#line 2939
      request_done(0);
#line 2939
      goto __Cont;
    } else {
#line 2936
      tmp___2 = test_bit(4, (void const   *)(& drive_state[current_drive].flags));
#line 2936
      if (tmp___2) {
#line 2938
        printk("floppy%d: disk absent or changed during operation\n", (int )current_drive);
#line 2939
        request_done(0);
#line 2939
        goto __Cont;
      }
    }
#line 2941
    if (! _floppy) {
#line 2942
      if (! probing) {
#line 2943
        drive_state[current_drive].probed_format = (short)0;
#line 2944
        tmp___3 = next_valid_format();
#line 2944
        if (tmp___3) {
#line 2945
          printk("floppy%d: no autodetectable formats\n", (int )current_drive);
#line 2946
          _floppy = (struct floppy_struct *)((void *)0);
#line 2947
          request_done(0);
#line 2947
          goto __Cont;
        }
      }
#line 2950
      probing = 1;
#line 2951
      _floppy = floppy_type + (int )drive_params[current_drive].autodetect[drive_state[current_drive].probed_format];
    } else {
#line 2954
      probing = 0;
    }
#line 2955
    errors = & current_req->errors;
#line 2956
    tmp = make_raw_rw_request();
#line 2957
    if (tmp < 2) {
#line 2958
      request_done(tmp);
#line 2959
      goto __Cont;
    }
#line 2962
    tmp___4 = test_bit(0, (void const   *)(& drive_state[current_drive].flags));
#line 2962
    if (tmp___4) {
#line 2963
      twaddle();
    }
#line 2964
    schedule_bh(& floppy_start);
#line 2965
    debugt("queue fd request");
#line 2966
    return;
    __Cont: /* CIL Label */ ;
  }
}
}
#line 2971 "floppy.c"
static struct cont_t rw_cont  =    {& rw_interrupt, & redo_fd_request, & bad_flp_intr, & request_done};
#line 2978 "floppy.c"
static void process_fd_request(void) 
{ 


  {
#line 2980
  cont = & rw_cont;
#line 2981
  schedule_bh(& redo_fd_request);
#line 2982
  return;
}
}
#line 2984 "floppy.c"
static void do_fd_request(request_queue_t *q ) 
{ 
  int tmp ;

  {
#line 2986
  if (max_buffer_sectors == 0) {
#line 2987
    printk("VFS: do_fd_request called on non-open device\n");
#line 2988
    return;
  }
#line 2991
  if (usage_count == 0) {
#line 2992
    printk("warning: usage count=0, current_req=%p exiting\n", current_req);
#line 2994
    printk("sect=%ld type=%x flags=%x\n", (long )current_req->sector, (unsigned int )current_req->cmd_type,
           current_req->cmd_flags);
#line 2996
    return;
  }
#line 2998
  tmp = test_bit(0, (void const   *)(& fdc_busy));
#line 2998
  if (tmp) {
#line 3001
    is_alive("do fd request, old request running");
#line 3002
    return;
  }
#line 3004
  _lock_fdc(-2, 0, 3004);
#line 3005
  process_fd_request();
#line 3006
  is_alive("do fd request");
#line 3007
  return;
}
}
#line 3009 "floppy.c"
static struct cont_t poll_cont  =    {& success_and_wakeup, & floppy_ready, & generic_failure, & generic_done};
#line 3016 "floppy.c"
static int poll_drive(int interruptible , int flag ) 
{ 
  int ret ;

  {
#line 3020
  raw_cmd = & default_raw_cmd;
#line 3021
  raw_cmd->flags = (unsigned int )flag;
#line 3022
  raw_cmd->track = 0;
#line 3023
  raw_cmd->cmd_count = (unsigned char)0;
#line 3024
  cont = & poll_cont;
#line 3026
  if ((int )drive_params[current_drive].flags & 2) {
#line 3027
    printk("floppy%d: setting NEWCHANGE in poll_drive\n", (int )current_drive);
  }
#line 3030
  set_bit(2, & drive_state[current_drive].flags);
#line 3031
  ret = wait_til_done(& floppy_ready, interruptible);
#line 3031
  if (ret == -4) {
#line 3031
    return (-4);
  }
#line 3032
  return (ret);
}
}
#line 3040 "floppy.c"
static void reset_intr(void) 
{ 


  {
#line 3042
  printk("weird, reset interrupt called\n");
#line 3043
  return;
}
}
#line 3045 "floppy.c"
static struct cont_t reset_cont  =    {& reset_intr, & success_and_wakeup, & generic_failure, & generic_done};
#line 3052 "floppy.c"
static int user_reset_fdc(int drive , int arg , int interruptible ) 
{ 
  int ret ;
  int tmp ;

  {
#line 3056
  ret = 0;
#line 3057
  tmp = _lock_fdc(drive, interruptible, 3057);
#line 3057
  if (tmp) {
#line 3057
    return (-4);
  }
#line 3058
  if (arg == 2) {
#line 3059
    fdc_state[fdc].reset = 1U;
  }
#line 3060
  if (fdc_state[fdc].reset) {
#line 3061
    cont = & reset_cont;
#line 3062
    ret = wait_til_done(& reset_fdc, interruptible);
#line 3062
    if (ret == -4) {
#line 3062
      return (-4);
    }
  }
#line 3064
  process_fd_request();
#line 3065
  return (ret);
}
}
#line 3072 "floppy.c"
__inline static int fd_copyout(void *param , void const   *address , unsigned long size ) 
{ 
  int tmp___0 ;
  unsigned long tmp___1 ;

  {
#line 3075
  tmp___1 = copy_to_user(param, address, size);
#line 3075
  if (tmp___1) {
#line 3075
    tmp___0 = -14;
  } else {
#line 3075
    tmp___0 = 0;
  }
#line 3075
  return (tmp___0);
}
}
#line 3078 "floppy.c"
__inline static int fd_copyin(void *param , void *address , unsigned long size ) 
{ 
  int tmp___0 ;
  unsigned long tmp___1 ;

  {
#line 3080
  tmp___1 = copy_from_user(address, param, size);
#line 3080
  if (tmp___1) {
#line 3080
    tmp___0 = -14;
  } else {
#line 3080
    tmp___0 = 0;
  }
#line 3080
  return (tmp___0);
}
}
#line 3089 "floppy.c"
__inline static char const   *drive_name(int type , int drive ) 
{ 
  struct floppy_struct *floppy___0 ;

  {
#line 3093
  if (type) {
#line 3094
    floppy___0 = floppy_type + type;
  } else
#line 3096
  if (drive_params[drive].native_format) {
#line 3097
    floppy___0 = floppy_type + drive_params[drive].native_format;
  } else {
#line 3099
    return ("(null)");
  }
#line 3101
  if (floppy___0->name) {
#line 3102
    return (floppy___0->name);
  } else {
#line 3104
    return ("(null)");
  }
}
}
#line 3125
extern int ( /* missing proto */  get_dma_residue)() ;
#line 3108 "floppy.c"
static void raw_cmd_done(int flag ) 
{ 
  int i ;
  unsigned long flags ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 3112
  if (! flag) {
#line 3113
    raw_cmd->flags |= 65536U;
#line 3114
    raw_cmd->flags |= 131072U;
  } else {
#line 3116
    raw_cmd->reply_count = (unsigned char )inr;
#line 3117
    if ((int )raw_cmd->reply_count > 16) {
#line 3118
      raw_cmd->reply_count = (unsigned char)0;
    }
#line 3119
    i = 0;
#line 3119
    while (i < (int )raw_cmd->reply_count) {
#line 3120
      raw_cmd->reply[i] = reply_buffer[i];
#line 3119
      i ++;
    }
#line 3122
    if (raw_cmd->flags & 3U) {
#line 3124
      tmp = claim_dma_lock();
#line 3124
      flags = (unsigned long )tmp;
#line 3125
      tmp___0 = get_dma_residue(FLOPPY_DMA);
#line 3125
      raw_cmd->length = (long )tmp___0;
#line 3126
      release_dma_lock(flags);
    }
#line 3129
    if (raw_cmd->flags & 2048U) {
#line 3129
      if (! raw_cmd->reply_count) {
#line 3131
        raw_cmd->flags |= 65536U;
      } else
#line 3129
      if ((int )raw_cmd->reply[0] & 192) {
#line 3131
        raw_cmd->flags |= 65536U;
      }
    }
#line 3133
    tmp___1 = disk_change((int )current_drive);
#line 3133
    if (tmp___1) {
#line 3134
      raw_cmd->flags |= 4U;
    } else {
#line 3136
      raw_cmd->flags &= 4294967291U;
    }
#line 3137
    if (raw_cmd->flags & 32U) {
#line 3138
      motor_off_callback((unsigned long )current_drive);
    }
#line 3140
    if (raw_cmd->next) {
#line 3140
      if (! (raw_cmd->flags & 65536U)) {
#line 3140
        goto _L;
      } else
#line 3140
      if (! (raw_cmd->flags & 512U)) {
        _L: /* CIL Label */ 
#line 3140
        if (raw_cmd->flags & 65536U) {
#line 3145
          raw_cmd = raw_cmd->next;
#line 3146
          return;
        } else
#line 3140
        if (! (raw_cmd->flags & 1024U)) {
#line 3145
          raw_cmd = raw_cmd->next;
#line 3146
          return;
        }
      }
    }
  }
#line 3149
  generic_done(flag);
#line 3150
  return;
}
}
#line 3152 "floppy.c"
static struct cont_t raw_cmd_cont  =    {& success_and_wakeup, & floppy_start, & generic_failure, & raw_cmd_done};
#line 3159 "floppy.c"
__inline static int raw_cmd_copyout(int cmd , char *param , struct floppy_raw_cmd *ptr ) 
{ 
  int ret ;
  unsigned long tmp___0 ;

  {
#line 3164
  while (ptr) {
#line 3165
    tmp___0 = copy_to_user((void *)param, (void const   *)ptr, sizeof(*ptr));
#line 3165
    if (tmp___0) {
#line 3165
      ret = -14;
    } else {
#line 3165
      ret = 0;
    }
#line 3165
    if (ret) {
#line 3165
      return (ret);
    }
#line 3166
    param += sizeof(struct floppy_raw_cmd );
#line 3167
    if (ptr->flags & 1U) {
#line 3167
      if (ptr->buffer_length) {
#line 3168
        if (ptr->length >= 0L) {
#line 3168
          if (ptr->length <= (long )ptr->buffer_length) {
#line 3170
            ret = fd_copyout(ptr->data, (void const   *)ptr->kernel_data, (unsigned long )((long )ptr->buffer_length - ptr->length));
#line 3170
            if (ret) {
#line 3170
              return (ret);
            }
          }
        }
      }
    }
#line 3174
    ptr = ptr->next;
  }
#line 3176
  return (0);
}
}
#line 3187
extern int ( /* missing proto */  get_order)() ;
#line 3179 "floppy.c"
static void raw_cmd_free(struct floppy_raw_cmd **ptr ) 
{ 
  struct floppy_raw_cmd *next ;
  struct floppy_raw_cmd *this ;
  int tmp ;

  {
#line 3183
  this = *ptr;
#line 3184
  *ptr = (struct floppy_raw_cmd *)((void *)0);
#line 3185
  while (this) {
#line 3186
    if (this->buffer_length) {
#line 3187
      tmp = get_order(this->buffer_length);
#line 3187
      free_pages((unsigned long )this->kernel_data, (unsigned int )tmp);
#line 3189
      this->buffer_length = 0;
    }
#line 3191
    next = this->next;
#line 3192
    kfree((void const   *)this);
#line 3193
    this = next;
  }
#line 3195
  return;
}
}
#line 3234
extern int ( /* missing proto */  __get_dma_pages)() ;
#line 3197 "floppy.c"
__inline static int raw_cmd_copyin(int cmd , char *param , struct floppy_raw_cmd **rcmd ) 
{ 
  struct floppy_raw_cmd *ptr ;
  int ret ;
  int i ;
  void *tmp ;
  unsigned long tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 3204
  *rcmd = (struct floppy_raw_cmd *)((void *)0);
#line 3205
  while (1) {
#line 3206
    tmp = kmalloc((size_t )sizeof(struct floppy_raw_cmd ), 131280U);
#line 3206
    ptr = (struct floppy_raw_cmd *)tmp;
#line 3208
    if (! ptr) {
#line 3209
      return (-12);
    }
#line 3210
    *rcmd = ptr;
#line 3211
    tmp___1 = copy_from_user((void *)ptr, (void *)param, sizeof(*ptr));
#line 3211
    if (tmp___1) {
#line 3211
      ret = -14;
    } else {
#line 3211
      ret = 0;
    }
#line 3211
    if (ret) {
#line 3211
      return (ret);
    }
#line 3212
    ptr->next = (struct floppy_raw_cmd *)((void *)0);
#line 3213
    ptr->buffer_length = 0;
#line 3214
    param += sizeof(struct floppy_raw_cmd );
#line 3215
    if ((int )ptr->cmd_count > 33) {
#line 3224
      return (-22);
    }
#line 3226
    i = 0;
#line 3226
    while (i < 16) {
#line 3227
      ptr->reply[i] = (unsigned char)0;
#line 3226
      i ++;
    }
#line 3228
    ptr->resultcode = 0;
#line 3229
    ptr->kernel_data = (char *)((void *)0);
#line 3231
    if (ptr->flags & 3U) {
#line 3232
      if (ptr->length <= 0L) {
#line 3233
        return (-22);
      }
#line 3234
      tmp___2 = get_order(ptr->length);
#line 3234
      tmp___3 = __get_dma_pages(208U, tmp___2);
#line 3234
      ptr->kernel_data = (char *)tmp___3;
#line 3236
      fallback_on_nodma_alloc(& ptr->kernel_data, (size_t )ptr->length);
#line 3237
      if (! ptr->kernel_data) {
#line 3238
        return (-12);
      }
#line 3239
      ptr->buffer_length = (int )ptr->length;
    }
#line 3241
    if (ptr->flags & 2U) {
#line 3242
      ret = fd_copyin(ptr->data, (void *)ptr->kernel_data, (unsigned long )ptr->length);
#line 3242
      if (ret) {
#line 3242
        return (ret);
      }
    }
#line 3244
    rcmd = & ptr->next;
#line 3245
    if (! (ptr->flags & 256U)) {
#line 3246
      return (0);
    }
#line 3247
    ptr->rate = (unsigned char )((int )ptr->rate & 67);
  }
}
}
#line 3251 "floppy.c"
static int raw_cmd_ioctl(int cmd , void *param ) 
{ 
  int drive ;
  int ret ;
  int ret2 ;
  struct floppy_raw_cmd *my_raw_cmd ;

  {
#line 3256
  if (fdc_state[fdc].rawcmd <= 1U) {
#line 3257
    fdc_state[fdc].rawcmd = 1U;
  }
#line 3258
  drive = 0;
#line 3258
  while (drive < 8) {
#line 3259
    if ((drive & 4) >> 2 != fdc) {
#line 3260
      goto __Cont;
    }
#line 3261
    if (drive == (int )current_drive) {
#line 3262
      if (drive_state[drive].fd_ref > 1) {
#line 3263
        fdc_state[fdc].rawcmd = 2U;
#line 3264
        break;
      }
    } else
#line 3266
    if (drive_state[drive].fd_ref) {
#line 3267
      fdc_state[fdc].rawcmd = 2U;
#line 3268
      break;
    }
    __Cont: /* CIL Label */ 
#line 3258
    drive ++;
  }
#line 3272
  if (fdc_state[fdc].reset) {
#line 3273
    return (-5);
  }
#line 3275
  ret = raw_cmd_copyin(cmd, (char *)param, & my_raw_cmd);
#line 3276
  if (ret) {
#line 3277
    raw_cmd_free(& my_raw_cmd);
#line 3278
    return (ret);
  }
#line 3281
  raw_cmd = my_raw_cmd;
#line 3282
  cont = & raw_cmd_cont;
#line 3283
  ret = wait_til_done(& floppy_start, 1);
#line 3285
  if ((int )drive_params[current_drive].flags & 2) {
#line 3286
    printk("floppy%d: calling disk change from raw_cmd ioctl\n", (int )current_drive);
  }
#line 3290
  if (ret != -4) {
#line 3290
    if (fdc_state[fdc].reset) {
#line 3291
      ret = -5;
    }
  }
#line 3293
  drive_state[current_drive].track = (short)-1;
#line 3295
  ret2 = raw_cmd_copyout(cmd, (char *)param, my_raw_cmd);
#line 3296
  if (! ret) {
#line 3297
    ret = ret2;
  }
#line 3298
  raw_cmd_free(& my_raw_cmd);
#line 3299
  return (ret);
}
}
#line 3302 "floppy.c"
static int invalidate_drive(struct block_device *bdev ) 
{ 


  {
#line 3305
  set_bit((int )((long )(bdev->bd_disk)->private_data), & fake_change);
#line 3306
  process_fd_request();
#line 3307
  check_disk_change(bdev);
#line 3308
  return (0);
}
}
#line 3338
extern int ( /* missing proto */  __invalidate_device)() ;
#line 3311 "floppy.c"
__inline static int set_geometry(unsigned int cmd , struct floppy_struct *g , int drive ,
                                 int type , struct block_device *bdev ) 
{ 
  int cnt ;
  int tmp ;
  int tmp___0 ;
  sector_t tmp___1 ;
  struct block_device *bdev___0 ;
  int oldStretch ;
  int tmp___2 ;
  int tmp___3 ;
  unsigned long tmp___4 ;
  int __x ;
  int __y ;
  int tmp___5 ;
  unsigned long tmp___6 ;

  {
#line 3317
  if (g->sect <= 0U) {
#line 3322
    return (-22);
  } else
#line 3317
  if (g->head <= 0U) {
#line 3322
    return (-22);
  } else
#line 3317
  if (g->track <= 0U) {
#line 3322
    return (-22);
  } else
#line 3317
  if (g->track > (unsigned int )((int )drive_params[drive].tracks >> (g->stretch & 1U))) {
#line 3322
    return (-22);
  } else
#line 3317
  if ((g->stretch & 4294967288U) != 0U) {
#line 3322
    return (-22);
  }
#line 3323
  if (type) {
#line 3324
    tmp = capable(21);
#line 3324
    if (! tmp) {
#line 3325
      return (-1);
    }
#line 3326
    mutex_lock(& open_lock);
#line 3327
    tmp___0 = _lock_fdc(drive, 1, 3327);
#line 3327
    if (tmp___0) {
#line 3327
      return (-4);
    }
#line 3328
    floppy_type[type] = *g;
#line 3329
    floppy_type[type].name = "user format";
#line 3330
    cnt = type << 2;
#line 3330
    while (cnt < (type << 2) + 4) {
#line 3331
      tmp___1 = (sector_t )(floppy_type[type].size + 1U);
#line 3331
      floppy_sizes[cnt + 128] = tmp___1;
#line 3331
      floppy_sizes[cnt] = tmp___1;
#line 3330
      cnt ++;
    }
#line 3333
    process_fd_request();
#line 3334
    cnt = 0;
#line 3334
    while (cnt < 8) {
#line 3335
      bdev___0 = opened_bdev[cnt];
#line 3336
      if (! bdev___0) {
#line 3337
        goto __Cont;
      } else
#line 3336
      if (((drive_state[cnt].fd_device >> 2) & 31) != type) {
#line 3337
        goto __Cont;
      }
#line 3338
      __invalidate_device(bdev___0);
      __Cont: /* CIL Label */ 
#line 3334
      cnt ++;
    }
#line 3340
    mutex_unlock(& open_lock);
  } else {
#line 3343
    tmp___2 = _lock_fdc(drive, 1, 3343);
#line 3343
    if (tmp___2) {
#line 3343
      return (-4);
    }
#line 3344
    if (sizeof(struct floppy_struct ) == sizeof(struct floppy_struct [1])) {
#line 3344
      if (sizeof(struct floppy_struct ) < (unsigned long )(1 << 14)) {
#line 3344
        tmp___4 = sizeof(struct floppy_struct );
      } else {
#line 3344
        tmp___4 = (unsigned long )__invalid_size_argument_for_IOC;
      }
    } else {
#line 3344
      tmp___4 = (unsigned long )__invalid_size_argument_for_IOC;
    }
#line 3344
    if ((unsigned long )cmd != ((unsigned long )(((1U << 30) | (unsigned int )(2 << 8)) | 67U) | (tmp___4 << 16))) {
#line 3347
      tmp___3 = poll_drive(1, 64);
#line 3347
      if (tmp___3 == -4) {
#line 3347
        return (-4);
      }
    }
#line 3348
    oldStretch = (int )g->stretch;
#line 3349
    user_params[drive] = *g;
#line 3350
    if (buffer_drive == drive) {
#line 3351
      __x = buffer_max;
#line 3351
      __y = (int )user_params[drive].sect;
#line 3351
      if (__x < __y) {
#line 3351
        tmp___5 = __x;
      } else {
#line 3351
        tmp___5 = __y;
      }
#line 3351
      buffer_max = tmp___5;
    }
#line 3352
    current_type[drive] = & user_params[drive];
#line 3353
    floppy_sizes[drive] = (sector_t )user_params[drive].size;
#line 3354
    if (sizeof(struct floppy_struct ) == sizeof(struct floppy_struct [1])) {
#line 3354
      if (sizeof(struct floppy_struct ) < (unsigned long )(1 << 14)) {
#line 3354
        tmp___6 = sizeof(struct floppy_struct );
      } else {
#line 3354
        tmp___6 = (unsigned long )__invalid_size_argument_for_IOC;
      }
    } else {
#line 3354
      tmp___6 = (unsigned long )__invalid_size_argument_for_IOC;
    }
#line 3354
    if ((unsigned long )cmd == ((unsigned long )(((1U << 30) | (unsigned int )(2 << 8)) | 67U) | (tmp___6 << 16))) {
#line 3355
      drive_state[current_drive].keep_data = -1;
    } else {
#line 3357
      drive_state[current_drive].keep_data = 1;
    }
#line 3363
    if ((unsigned int )drive_state[current_drive].maxblock > user_params[drive].sect) {
#line 3367
      invalidate_drive(bdev);
    } else
#line 3363
    if (drive_state[current_drive].maxtrack) {
#line 3367
      invalidate_drive(bdev);
    } else
#line 3363
    if ((user_params[drive].sect ^ (unsigned int )oldStretch) & 6U) {
#line 3367
      invalidate_drive(bdev);
    } else {
#line 3369
      process_fd_request();
    }
  }
#line 3371
  return (0);
}
}
#line 3375 "floppy.c"
static int ioctl_table[25]  = 
#line 3375
  {      (int )((unsigned int )(2 << 8) | 65U),      (int )((unsigned long )(((1U << 30) | (unsigned int )(2 << 8)) | 66U) | (sizeof(struct floppy_struct ) << 16)),      (int )((unsigned long )(((1U << 30) | (unsigned int )(2 << 8)) | 67U) | (sizeof(struct floppy_struct ) << 16)),      (int )((unsigned long )(((2U << 30) | (unsigned int )(2 << 8)) | 4U) | (sizeof(struct floppy_struct ) << 16)), 
        (int )((unsigned int )(2 << 8) | 69U),      (int )((unsigned int )(2 << 8) | 70U),      (int )((unsigned int )(2 << 8) | 71U),      (int )((unsigned long )(((1U << 30) | (unsigned int )(2 << 8)) | 72U) | (sizeof(struct format_descr ) << 16)), 
        (int )((unsigned int )(2 << 8) | 73U),      (int )((unsigned int )(2 << 8) | 74U),      (int )((unsigned int )(2 << 8) | 75U),      (int )((unsigned long )(((1U << 30) | (unsigned int )(2 << 8)) | 76U) | (sizeof(struct floppy_max_errors ) << 16)), 
        (int )((unsigned long )(((2U << 30) | (unsigned int )(2 << 8)) | 14U) | (sizeof(struct floppy_max_errors ) << 16)),      (int )((unsigned long )(((2U << 30) | (unsigned int )(2 << 8)) | 15U) | (sizeof(floppy_drive_name ) << 16)),      (int )((unsigned long )(((1U << 30) | (unsigned int )(2 << 8)) | 144U) | (sizeof(struct floppy_drive_params ) << 16)),      (int )((unsigned long )(((2U << 30) | (unsigned int )(2 << 8)) | 17U) | (sizeof(struct floppy_drive_params ) << 16)), 
        (int )((unsigned long )(((2U << 30) | (unsigned int )(2 << 8)) | 18U) | (sizeof(struct floppy_drive_struct ) << 16)),      (int )((unsigned long )(((2U << 30) | (unsigned int )(2 << 8)) | 19U) | (sizeof(struct floppy_drive_struct ) << 16)),      (int )((unsigned int )(2 << 8) | 84U),      (int )((unsigned long )(((2U << 30) | (unsigned int )(2 << 8)) | 21U) | (sizeof(struct floppy_fdc_state ) << 16)), 
        (int )((unsigned int )(2 << 8) | 86U),      (int )((unsigned long )(((2U << 30) | (unsigned int )(2 << 8)) | 23U) | (sizeof(struct floppy_write_errors ) << 16)),      (int )((unsigned int )(2 << 8) | 88U),      (int )((unsigned int )(2 << 8) | 90U), 
        (int )((unsigned int )(2 << 8) | 89U)};
#line 3403 "floppy.c"
__inline static int normalize_ioctl(int *cmd , int *size ) 
{ 
  int i ;

  {
#line 3407
  i = 0;
#line 3407
  while ((unsigned long )i < sizeof(ioctl_table) / sizeof(ioctl_table[0])) {
#line 3408
    if ((*cmd & 65535) == (ioctl_table[i] & 65535)) {
#line 3409
      *size = (*cmd >> 16) & ((1 << 14) - 1);
#line 3410
      *cmd = ioctl_table[i];
#line 3411
      if (*size > ((*cmd >> 16) & ((1 << 14) - 1))) {
#line 3412
        printk("ioctl not yet supported\n");
#line 3413
        return (-14);
      }
#line 3415
      return (0);
    }
#line 3407
    i ++;
  }
#line 3418
  return (-22);
}
}
#line 3421 "floppy.c"
static int get_floppy_geometry(int drive , int type , struct floppy_struct **g ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 3423
  if (type) {
#line 3424
    *g = & floppy_type[type];
  } else {
#line 3426
    tmp = _lock_fdc(drive, 0, 3426);
#line 3426
    if (tmp) {
#line 3426
      return (-4);
    }
#line 3427
    tmp___0 = poll_drive(0, 0);
#line 3427
    if (tmp___0 == -4) {
#line 3427
      return (-4);
    }
#line 3428
    process_fd_request();
#line 3429
    *g = current_type[drive];
  }
#line 3431
  if (! *g) {
#line 3432
    return (-19);
  }
#line 3433
  return (0);
}
}
#line 3436 "floppy.c"
static int fd_getgeo(struct block_device *bdev , struct hd_geometry *geo ) 
{ 
  int drive ;
  int type ;
  struct floppy_struct *g ;
  int ret ;

  {
#line 3438
  drive = (int )((long )(bdev->bd_disk)->private_data);
#line 3439
  type = (drive_state[drive].fd_device >> 2) & 31;
#line 3443
  ret = get_floppy_geometry(drive, type, & g);
#line 3444
  if (ret) {
#line 3445
    return (ret);
  }
#line 3447
  geo->heads = (unsigned char )g->head;
#line 3448
  geo->sectors = (unsigned char )g->sect;
#line 3449
  geo->cylinders = (unsigned short )g->track;
#line 3450
  return (0);
}
}
#line 3453 "floppy.c"
static int fd_ioctl(struct inode *inode , struct file *filp , unsigned int cmd , unsigned long param ) 
{ 
  int drive ;
  int i ;
  int type ;
  int ret ;
  int size ;
  union inparam inparam ;
  char const   *outparam ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int __x ;
  int __y ;
  __kernel_size_t tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;

  {
#line 3460
  drive = (int )((long )((inode->i_bdev)->bd_disk)->private_data);
#line 3461
  type = (drive_state[drive].fd_device >> 2) & 31;
#line 3475
  if (cmd == 21257U) {
#line 3477
    printk("floppy%d: obsolete eject ioctl\n", (int )current_drive);
#line 3478
    printk("floppy%d: please use floppycontrol --eject\n", (int )current_drive);
#line 3479
    cmd = (unsigned int )(2 << 8) | 90U;
  } else
#line 3475
  if (cmd == 25712U) {
#line 3477
    printk("floppy%d: obsolete eject ioctl\n", (int )current_drive);
#line 3478
    printk("floppy%d: please use floppycontrol --eject\n", (int )current_drive);
#line 3479
    cmd = (unsigned int )(2 << 8) | 90U;
  }
#line 3483
  if ((cmd & 65280U) == 512U) {
#line 3484
    ret = normalize_ioctl((int *)(& cmd), & size);
#line 3484
    if (ret) {
#line 3484
      return (ret);
    }
  } else {
#line 3486
    return (-22);
  }
#line 3489
  if (cmd & 64U) {
#line 3489
    if (filp) {
#line 3489
      if (filp->private_data) {
#line 3489
        goto _L;
      } else {
#line 3491
        return (-1);
      }
    } else {
#line 3491
      return (-1);
    }
  } else
  _L: /* CIL Label */ 
#line 3489
  if (cmd & 128U) {
#line 3489
    tmp = capable(21);
#line 3489
    if (! tmp) {
#line 3491
      return (-1);
    }
  }
#line 3494
  memset((void *)(& inparam), 0, (unsigned int )sizeof(inparam));
#line 3495
  if (((cmd >> 30) & (unsigned int )((1 << 2) - 1)) & 1U) {
#line 3496
    ret = fd_copyin((void *)param, (void *)(& inparam), (unsigned long )size);
#line 3496
    if (ret) {
#line 3496
      return (ret);
    }
  }
#line 3498
  switch (cmd) {
  case (unsigned int )(2 << 8) | 90U: 
#line 3500
  if (drive_state[drive].fd_ref != 1) {
#line 3502
    return (-16);
  }
#line 3503
  tmp___0 = _lock_fdc(drive, 1, 3503);
#line 3503
  if (tmp___0) {
#line 3503
    return (-4);
  }
#line 3507
  ret = fd_eject(drive & 3);
#line 3509
  set_bit(4, & drive_state[drive].flags);
#line 3510
  set_bit(1, & drive_state[drive].flags);
#line 3511
  process_fd_request();
#line 3512
  return (ret);
  case (unsigned int )(2 << 8) | 65U: 
#line 3514
  tmp___1 = _lock_fdc(drive, 1, 3514);
#line 3514
  if (tmp___1) {
#line 3514
    return (-4);
  }
#line 3515
  current_type[drive] = (struct floppy_struct *)((void *)0);
#line 3516
  floppy_sizes[drive] = (sector_t )(4 << 1);
#line 3517
  drive_state[drive].keep_data = 0;
#line 3518
  tmp___2 = invalidate_drive(inode->i_bdev);
#line 3518
  return (tmp___2);
  case (unsigned int )((unsigned long )(((1U << 30) | (unsigned int )(2 << 8)) | 67U) | (sizeof(struct floppy_struct ) << 16)): 
  case (unsigned int )((unsigned long )(((1U << 30) | (unsigned int )(2 << 8)) | 66U) | (sizeof(struct floppy_struct ) << 16)): 
#line 3521
  tmp___3 = set_geometry(cmd, & inparam.g, drive, type, inode->i_bdev);
#line 3521
  return (tmp___3);
  case (unsigned int )((unsigned long )(((2U << 30) | (unsigned int )(2 << 8)) | 4U) | (sizeof(struct floppy_struct ) << 16)): 
#line 3524
  ret = get_floppy_geometry(drive, type, (struct floppy_struct **)(& outparam));
#line 3524
  if (ret) {
#line 3524
    return (ret);
  }
#line 3527
  break;
  case (unsigned int )(2 << 8) | 69U: 
#line 3530
  drive_params[drive].flags = (char )((int )drive_params[drive].flags | 16);
#line 3531
  return (0);
  case (unsigned int )(2 << 8) | 70U: 
#line 3533
  drive_params[drive].flags = (char )((int )drive_params[drive].flags & -17);
#line 3534
  return (0);
  case (unsigned int )(2 << 8) | 71U: 
#line 3537
  tmp___4 = _lock_fdc(drive, 1, 3537);
#line 3537
  if (tmp___4) {
#line 3537
    return (-4);
  }
#line 3538
  tmp___5 = poll_drive(1, 64);
#line 3538
  if (tmp___5 == -4) {
#line 3538
    return (-4);
  }
#line 3539
  ret = (int )drive_state[drive].flags;
#line 3540
  process_fd_request();
#line 3545
  return (0);
  case (unsigned int )((unsigned long )(((1U << 30) | (unsigned int )(2 << 8)) | 72U) | (sizeof(struct format_descr ) << 16)): 
#line 3547
  if (drive_state[drive].fd_ref != 1) {
#line 3548
    return (-16);
  }
#line 3549
  tmp___6 = do_format(drive, & inparam.f);
#line 3549
  return (tmp___6);
  case (unsigned int )(2 << 8) | 75U: 
  case (unsigned int )(2 << 8) | 73U: 
#line 3552
  tmp___7 = _lock_fdc(drive, 1, 3552);
#line 3552
  if (tmp___7) {
#line 3552
    return (-4);
  }
#line 3553
  tmp___8 = invalidate_drive(inode->i_bdev);
#line 3553
  return (tmp___8);
  case (unsigned int )(2 << 8) | 74U: 
#line 3556
  drive_params[drive].max_errors.reporting = (unsigned int )((unsigned short )(param & 15UL));
#line 3558
  return (0);
  case (unsigned int )((unsigned long )(((2U << 30) | (unsigned int )(2 << 8)) | 14U) | (sizeof(struct floppy_max_errors ) << 16)): 
#line 3559
  outparam = (char const   *)(& drive_params[drive].max_errors);
#line 3559
  break;
  case (unsigned int )((unsigned long )(((1U << 30) | (unsigned int )(2 << 8)) | 76U) | (sizeof(struct floppy_max_errors ) << 16)): 
#line 3560
  drive_params[drive].max_errors = inparam.max_errors;
#line 3560
  return (0);
  case (unsigned int )((unsigned long )(((2U << 30) | (unsigned int )(2 << 8)) | 15U) | (sizeof(floppy_drive_name ) << 16)): 
#line 3563
  outparam = drive_name(type, drive);
#line 3564
  __x = size;
#line 3564
  tmp___9 = strlen(outparam);
#line 3564
  __y = (int )(tmp___9 + 1U);
#line 3564
  if (__x < __y) {
#line 3564
    tmp___10 = __x;
  } else {
#line 3564
    tmp___10 = __y;
  }
#line 3564
  size = tmp___10;
#line 3565
  break;
  case (unsigned int )((unsigned long )(((1U << 30) | (unsigned int )(2 << 8)) | 144U) | (sizeof(struct floppy_drive_params ) << 16)): 
#line 3567
  drive_params[drive] = inparam.dp;
#line 3567
  return (0);
  case (unsigned int )((unsigned long )(((2U << 30) | (unsigned int )(2 << 8)) | 17U) | (sizeof(struct floppy_drive_params ) << 16)): 
#line 3568
  outparam = (char const   *)(& drive_params[drive]);
#line 3568
  break;
  case (unsigned int )((unsigned long )(((2U << 30) | (unsigned int )(2 << 8)) | 19U) | (sizeof(struct floppy_drive_struct ) << 16)): 
#line 3571
  tmp___11 = _lock_fdc(drive, 1, 3571);
#line 3571
  if (tmp___11) {
#line 3571
    return (-4);
  }
#line 3572
  tmp___12 = poll_drive(1, 64);
#line 3572
  if (tmp___12 == -4) {
#line 3572
    return (-4);
  }
#line 3573
  process_fd_request();
  case (unsigned int )((unsigned long )(((2U << 30) | (unsigned int )(2 << 8)) | 18U) | (sizeof(struct floppy_drive_struct ) << 16)): 
#line 3575
  outparam = (char const   *)(& drive_state[drive]);
#line 3575
  break;
  case (unsigned int )(2 << 8) | 84U: 
#line 3578
  tmp___13 = user_reset_fdc(drive, (int )param, 1);
#line 3578
  return (tmp___13);
  case (unsigned int )((unsigned long )(((2U << 30) | (unsigned int )(2 << 8)) | 21U) | (sizeof(struct floppy_fdc_state ) << 16)): 
#line 3580
  outparam = (char const   *)(& fdc_state[(drive & 4) >> 2]);
#line 3580
  break;
  case (unsigned int )(2 << 8) | 86U: 
#line 3583
  memset((void *)(& write_errors[drive]), 0, (unsigned int )sizeof(write_errors[drive]));
#line 3584
  return (0);
  case (unsigned int )((unsigned long )(((2U << 30) | (unsigned int )(2 << 8)) | 23U) | (sizeof(struct floppy_write_errors ) << 16)): 
#line 3585
  outparam = (char const   *)(& write_errors[drive]);
#line 3585
  break;
  case (unsigned int )(2 << 8) | 88U: 
#line 3588
  if (type) {
#line 3589
    return (-22);
  }
#line 3590
  tmp___14 = _lock_fdc(drive, 1, 3590);
#line 3590
  if (tmp___14) {
#line 3590
    return (-4);
  }
#line 3591
  set_floppy(drive);
#line 3592
  i = raw_cmd_ioctl((int )cmd, (void *)param);
#line 3592
  if (i == -4) {
#line 3592
    return (-4);
  }
#line 3593
  process_fd_request();
#line 3594
  return (i);
  case (unsigned int )(2 << 8) | 89U: 
#line 3597
  tmp___15 = _lock_fdc(drive, 1, 3597);
#line 3597
  if (tmp___15) {
#line 3597
    return (-4);
  }
#line 3598
  twaddle();
#line 3599
  process_fd_request();
#line 3600
  return (0);
  default: 
#line 3603
  return (-22);
  }
#line 3606
  if (((cmd >> 30) & (unsigned int )((1 << 2) - 1)) & 2U) {
#line 3607
    tmp___16 = fd_copyout((void *)param, (void const   *)outparam, (unsigned long )size);
#line 3607
    return (tmp___16);
  } else {
#line 3609
    return (0);
  }
}
}
#line 3634 "floppy.c"
static char temparea[32]  ;
#line 3614 "floppy.c"
static void config_types(void) 
{ 
  int first ;
  int drive ;
  unsigned char tmp ;
  unsigned char tmp___0 ;
  unsigned char tmp___1 ;
  unsigned int type ;
  struct floppy_drive_params *params ;
  char const   *name ;
  char const   *prepend ;

  {
#line 3616
  first = 1;
#line 3620
  drive = 0;
#line 3621
  if (! drive_params[drive].cmos) {
#line 3622
    tmp = rtc_cmos_read((unsigned char)16);
#line 3622
    drive_params[drive].cmos = (signed char )(((int )tmp >> 4) & 15);
  }
#line 3623
  drive = 1;
#line 3624
  if (! drive_params[drive].cmos) {
#line 3624
    tmp___1 = rtc_cmos_read((unsigned char)16);
#line 3624
    if ((int )tmp___1 & 15) {
#line 3625
      tmp___0 = rtc_cmos_read((unsigned char)16);
#line 3625
      drive_params[drive].cmos = (signed char )((int )tmp___0 & 15);
    }
  }
#line 3630
  drive = 0;
#line 3630
  while (drive < 8) {
#line 3631
    type = (unsigned int )drive_params[drive].cmos;
#line 3633
    name = (char const   *)((void *)0);
#line 3636
    if ((unsigned long )type < sizeof(default_drive_params) / sizeof(default_drive_params[0])) {
#line 3637
      params = & default_drive_params[type].params;
#line 3638
      if (type) {
#line 3639
        name = default_drive_params[type].name;
#line 3640
        allowed_drive_mask |= 1 << drive;
      } else {
#line 3642
        allowed_drive_mask &= ~ (1 << drive);
      }
    } else {
#line 3644
      params = & default_drive_params[0].params;
#line 3645
      sprintf(temparea, "unknown type %d (usb?)", type);
#line 3646
      name = (char const   *)(temparea);
    }
#line 3648
    if (name) {
#line 3649
      prepend = ",";
#line 3650
      if (first) {
#line 3651
        prepend = "<6>Floppy drive(s):";
#line 3652
        first = 0;
      }
#line 3654
      printk("%s fd%d is %s", prepend, drive, name);
    }
#line 3656
    drive_params[drive] = *params;
#line 3630
    drive ++;
  }
#line 3658
  if (! first) {
#line 3659
    printk("\n");
  }
#line 3660
  return;
}
}
#line 3662 "floppy.c"
static int floppy_release(struct inode *inode , struct file *filp ) 
{ 
  int drive ;
  int tmp ;

  {
#line 3664
  drive = (int )((long )((inode->i_bdev)->bd_disk)->private_data);
#line 3666
  mutex_lock(& open_lock);
#line 3667
  if (drive_state[drive].fd_ref < 0) {
#line 3668
    drive_state[drive].fd_ref = 0;
  } else {
#line 3669
    tmp = drive_state[drive].fd_ref;
#line 3669
    (drive_state[drive].fd_ref) --;
#line 3669
    if (! tmp) {
#line 3670
      printk("floppy%d: floppy_release with fd_ref == 0", (int )current_drive);
#line 3671
      drive_state[drive].fd_ref = 0;
    }
  }
#line 3673
  if (! drive_state[drive].fd_ref) {
#line 3674
    opened_bdev[drive] = (struct block_device *)((void *)0);
  }
#line 3675
  mutex_unlock(& open_lock);
#line 3677
  return (0);
}
}
#line 3757
extern int ( /* missing proto */  file_permission)() ;
#line 3685 "floppy.c"
static int floppy_open(struct inode *inode , struct file *filp ) 
{ 
  int drive ;
  int old_dev ;
  int try ;
  int res ;
  char *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int __x ;
  int __y ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  unsigned int tmp___6 ;
  unsigned int tmp___7 ;
  unsigned int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;

  {
#line 3687
  drive = (int )((long )((inode->i_bdev)->bd_disk)->private_data);
#line 3690
  res = -16;
#line 3693
  filp->private_data = (void *)0;
#line 3694
  mutex_lock(& open_lock);
#line 3695
  old_dev = drive_state[drive].fd_device;
#line 3696
  if (opened_bdev[drive]) {
#line 3696
    if ((unsigned long )opened_bdev[drive] != (unsigned long )inode->i_bdev) {
#line 3697
      goto out2;
    }
  }
#line 3699
  if (! drive_state[drive].fd_ref) {
#line 3699
    if ((int )drive_params[drive].flags & 32) {
#line 3700
      set_bit(4, & drive_state[drive].flags);
#line 3701
      set_bit(1, & drive_state[drive].flags);
    }
  }
#line 3704
  if (drive_state[drive].fd_ref == -1) {
#line 3705
    goto out2;
  } else
#line 3704
  if (drive_state[drive].fd_ref) {
#line 3704
    if (filp->f_flags & 128U) {
#line 3705
      goto out2;
    }
  }
#line 3707
  if (filp->f_flags & 128U) {
#line 3708
    drive_state[drive].fd_ref = -1;
  } else {
#line 3710
    (drive_state[drive].fd_ref) ++;
  }
#line 3712
  opened_bdev[drive] = inode->i_bdev;
#line 3714
  res = -6;
#line 3716
  if (! floppy_track_buffer) {
#line 3719
    if ((int )drive_params[drive].cmos == 6) {
#line 3720
      try = 64;
    } else
#line 3719
    if ((int )drive_params[drive].cmos == 5) {
#line 3720
      try = 64;
    } else {
#line 3722
      try = 32;
    }
#line 3724
    tmp___0 = get_order(1024 * try);
#line 3724
    tmp___1 = __get_dma_pages(208U, tmp___0);
#line 3724
    tmp = (char *)tmp___1;
#line 3725
    if (! tmp) {
#line 3725
      if (! floppy_track_buffer) {
#line 3726
        try >>= 1;
#line 3727
        __x = try;
#line 3727
        __y = 16;
#line 3727
        if (__x > __y) {
#line 3727
          tmp___2 = __x;
        } else {
#line 3727
          tmp___2 = __y;
        }
#line 3727
        try = tmp___2;
#line 3728
        tmp___3 = get_order(1024 * try);
#line 3728
        tmp___4 = __get_dma_pages(208U, tmp___3);
#line 3728
        tmp = (char *)tmp___4;
      }
    }
#line 3730
    if (! tmp) {
#line 3730
      if (! floppy_track_buffer) {
#line 3731
        fallback_on_nodma_alloc(& tmp, (size_t )(2048 * try));
      }
    }
#line 3733
    if (! tmp) {
#line 3733
      if (! floppy_track_buffer) {
#line 3734
        printk("floppy%d: Unable to allocate DMA memory\n", (int )current_drive);
#line 3735
        goto out;
      }
    }
#line 3737
    if (floppy_track_buffer) {
#line 3738
      if (tmp) {
#line 3739
        tmp___5 = get_order(try * 1024);
#line 3739
        free_pages((unsigned long )tmp, (unsigned int )tmp___5);
      }
    } else {
#line 3741
      buffer_max = -1;
#line 3741
      buffer_min = buffer_max;
#line 3742
      floppy_track_buffer = tmp;
#line 3743
      max_buffer_sectors = try;
    }
  }
#line 3747
  tmp___6 = iminor(inode);
#line 3747
  drive_state[drive].fd_device = (int )tmp___6;
#line 3748
  tmp___7 = iminor(inode);
#line 3748
  set_capacity(disks[drive], floppy_sizes[tmp___7]);
#line 3749
  if (old_dev != -1) {
#line 3749
    tmp___8 = iminor(inode);
#line 3749
    if ((unsigned int )old_dev != tmp___8) {
#line 3750
      if (buffer_drive == drive) {
#line 3751
        buffer_track = -1;
      }
    }
  }
#line 3757
  if ((int )filp->f_mode & 2) {
#line 3758
    filp->private_data = (void *)8;
  } else {
#line 3757
    tmp___9 = file_permission(filp, 2);
#line 3757
    if (! tmp___9) {
#line 3758
      filp->private_data = (void *)8;
    }
  }
#line 3760
  if (fdc_state[(drive & 4) >> 2].rawcmd == 1U) {
#line 3761
    fdc_state[(drive & 4) >> 2].rawcmd = 2U;
  }
#line 3763
  if (! (filp->f_flags & 2048U)) {
#line 3764
    if ((int )filp->f_mode & 3) {
#line 3765
      drive_state[drive].last_checked = 0UL;
#line 3766
      check_disk_change(inode->i_bdev);
#line 3767
      tmp___10 = test_bit(4, (void const   *)(& drive_state[drive].flags));
#line 3767
      if (tmp___10) {
#line 3768
        goto out;
      }
    }
#line 3770
    res = -30;
#line 3771
    if ((int )filp->f_mode & 2) {
#line 3771
      tmp___11 = test_bit(5, (void const   *)(& drive_state[drive].flags));
#line 3771
      if (! tmp___11) {
#line 3772
        goto out;
      }
    }
  }
#line 3774
  mutex_unlock(& open_lock);
#line 3775
  return (0);
  out: 
#line 3777
  if (drive_state[drive].fd_ref < 0) {
#line 3778
    drive_state[drive].fd_ref = 0;
  } else {
#line 3780
    (drive_state[drive].fd_ref) --;
  }
#line 3781
  if (! drive_state[drive].fd_ref) {
#line 3782
    opened_bdev[drive] = (struct block_device *)((void *)0);
  }
  out2: 
#line 3784
  mutex_unlock(& open_lock);
#line 3785
  return (res);
}
}
#line 3791 "floppy.c"
static int check_floppy_change(struct gendisk *disk ) 
{ 
  int drive ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 3793
  drive = (int )((long )disk->private_data);
#line 3795
  tmp = test_bit(4, (void const   *)(& drive_state[drive].flags));
#line 3795
  if (tmp) {
#line 3796
    return (1);
  } else {
#line 3795
    tmp___0 = test_bit(1, (void const   *)(& drive_state[drive].flags));
#line 3795
    if (tmp___0) {
#line 3796
      return (1);
    }
  }
#line 3798
  if ((long )(drive_state[drive].last_checked + (unsigned long )drive_params[drive].checkfreq) - (long )jiffies < 0L) {
#line 3799
    _lock_fdc(drive, 0, 3799);
#line 3800
    poll_drive(0, 0);
#line 3801
    process_fd_request();
  }
#line 3804
  tmp___1 = test_bit(4, (void const   *)(& drive_state[drive].flags));
#line 3804
  if (tmp___1) {
#line 3808
    return (1);
  } else {
#line 3804
    tmp___2 = test_bit(1, (void const   *)(& drive_state[drive].flags));
#line 3804
    if (tmp___2) {
#line 3808
      return (1);
    } else {
#line 3804
      tmp___3 = test_bit(drive, (void const   *)(& fake_change));
#line 3804
      if (tmp___3) {
#line 3808
        return (1);
      } else
#line 3804
      if (! ((drive_state[drive].fd_device >> 2) & 31)) {
#line 3804
        if (! current_type[drive]) {
#line 3808
          return (1);
        }
      }
    }
  }
#line 3809
  return (0);
}
}
#line 3824
extern int ( /* missing proto */  complete)() ;
#line 3818 "floppy.c"
static int floppy_rb0_complete(struct bio *bio , unsigned int bytes_done , int err ) 
{ 


  {
#line 3821
  if (bio->bi_size) {
#line 3822
    return (1);
  }
#line 3824
  complete((struct completion *)bio->bi_private);
#line 3825
  return (0);
}
}
#line 3846
extern int ( /* missing proto */  bio_init)() ;
#line 3856
extern int ( /* missing proto */  init_completion)() ;
#line 3860
extern int ( /* missing proto */  submit_bio)() ;
#line 3861
extern int ( /* missing proto */  generic_unplug_device)() ;
#line 3861
extern int ( /* missing proto */  bdev_get_queue)() ;
#line 3863
extern int ( /* missing proto */  wait_for_completion)() ;
#line 3865
extern int ( /* missing proto */  __free_page)() ;
#line 3828 "floppy.c"
static int __floppy_read_block_0(struct block_device *bdev ) 
{ 
  struct bio bio ;
  struct bio_vec bio_vec ;
  struct completion complete___0 ;
  struct page *page ;
  size_t size ;
  int tmp ;

  {
#line 3836
  page = alloc_page(16U);
#line 3837
  if (! page) {
#line 3838
    process_fd_request();
#line 3839
    return (-12);
  }
#line 3842
  size = bdev->bd_block_size;
#line 3843
  if (! size) {
#line 3844
    size = (size_t )1024;
  }
#line 3846
  bio_init(& bio);
#line 3847
  bio.bi_io_vec = & bio_vec;
#line 3848
  bio_vec.bv_page = page;
#line 3849
  bio_vec.bv_len = size;
#line 3850
  bio_vec.bv_offset = 0U;
#line 3851
  bio.bi_vcnt = (unsigned short)1;
#line 3852
  bio.bi_idx = (unsigned short)0;
#line 3853
  bio.bi_size = size;
#line 3854
  bio.bi_bdev = bdev;
#line 3855
  bio.bi_sector = (sector_t )0;
#line 3856
  init_completion(& complete___0);
#line 3857
  bio.bi_private = (void *)(& complete___0);
#line 3858
  bio.bi_end_io = & floppy_rb0_complete;
#line 3860
  submit_bio(0, & bio);
#line 3861
  tmp = bdev_get_queue(bdev);
#line 3861
  generic_unplug_device(tmp);
#line 3862
  process_fd_request();
#line 3863
  wait_for_completion(& complete___0);
#line 3865
  __free_page(page);
#line 3867
  return (0);
}
}
#line 3874 "floppy.c"
static int floppy_revalidate(struct gendisk *disk ) 
{ 
  int drive ;
  int cf ;
  int res ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
#line 3876
  drive = (int )((long )disk->private_data);
#line 3879
  res = 0;
#line 3881
  tmp___3 = test_bit(4, (void const   *)(& drive_state[drive].flags));
#line 3881
  if (tmp___3) {
#line 3881
    goto _L___0;
  } else {
#line 3881
    tmp___4 = test_bit(1, (void const   *)(& drive_state[drive].flags));
#line 3881
    if (tmp___4) {
#line 3881
      goto _L___0;
    } else {
#line 3881
      tmp___5 = test_bit(drive, (void const   *)(& fake_change));
#line 3881
      if (tmp___5) {
#line 3881
        goto _L___0;
      } else
#line 3881
      if (! current_type[drive]) {
#line 3881
        if (! ((drive_state[drive].fd_device >> 2) & 31)) {
          _L___0: /* CIL Label */ 
#line 3883
          if (usage_count == 0) {
#line 3884
            printk("VFS: revalidate called on non-open device.\n");
#line 3885
            return (-14);
          }
#line 3887
          _lock_fdc(drive, 0, 3887);
#line 3888
          tmp = test_bit(4, (void const   *)(& drive_state[drive].flags));
#line 3888
          if (tmp) {
#line 3888
            tmp___1 = 1;
          } else {
#line 3888
            tmp___0 = test_bit(1, (void const   *)(& drive_state[drive].flags));
#line 3888
            if (tmp___0) {
#line 3888
              tmp___1 = 1;
            } else {
#line 3888
              tmp___1 = 0;
            }
          }
#line 3888
          cf = tmp___1;
#line 3889
          if (! cf) {
#line 3889
            tmp___2 = test_bit(drive, (void const   *)(& fake_change));
#line 3889
            if (! tmp___2) {
#line 3889
              if (! current_type[drive]) {
#line 3889
                if (! (! ((drive_state[drive].fd_device >> 2) & 31))) {
#line 3890
                  process_fd_request();
#line 3891
                  return (0);
                }
              } else {
#line 3890
                process_fd_request();
#line 3891
                return (0);
              }
            }
          }
#line 3893
          drive_state[drive].maxblock = (short)0;
#line 3894
          drive_state[drive].maxtrack = (short)0;
#line 3895
          if (buffer_drive == drive) {
#line 3896
            buffer_track = -1;
          }
#line 3897
          clear_bit(drive, (unsigned long volatile   *)(& fake_change));
#line 3898
          clear_bit(4, (unsigned long volatile   *)(& drive_state[drive].flags));
#line 3899
          if (cf) {
#line 3900
            (drive_state[drive].generation) ++;
          }
#line 3901
          if (! current_type[drive]) {
#line 3901
            if (! ((drive_state[drive].fd_device >> 2) & 31)) {
#line 3903
              res = __floppy_read_block_0(opened_bdev[drive]);
            } else {
#line 3901
              goto _L;
            }
          } else {
            _L: /* CIL Label */ 
#line 3905
            if (cf) {
#line 3906
              poll_drive(0, 64);
            }
#line 3907
            process_fd_request();
          }
        }
      }
    }
  }
#line 3910
  set_capacity(disk, floppy_sizes[drive_state[drive].fd_device]);
#line 3911
  return (res);
}
}
#line 3914 "floppy.c"
static struct block_device_operations floppy_fops  = 
#line 3914
     {& floppy_open, & floppy_release, & fd_ioctl, (long (*)(struct file * , unsigned int  ,
                                                           unsigned long  ))0, (long (*)(struct file * ,
                                                                                         unsigned int  ,
                                                                                         unsigned long  ))0,
    (int (*)(struct block_device * , sector_t  , unsigned long * ))0, & check_floppy_change,
    & floppy_revalidate, & fd_getgeo, (struct module *)0};
#line 3931 "floppy.c"
static char get_fdc_version(void) 
{ 
  int r ;
  int tmp ;
  int tmp___0 ;

  {
#line 3935
  output_byte((char)14);
#line 3936
  if (fdc_state[fdc].reset) {
#line 3937
    return ((char)0);
  }
#line 3938
  r = result();
#line 3938
  if (r <= 0) {
#line 3939
    return ((char)0);
  }
#line 3940
  if (r == 1) {
#line 3940
    if ((int )reply_buffer[0] == 128) {
#line 3941
      printk("<6>FDC %d is an 8272A\n", fdc);
#line 3942
      return ((char)32);
    }
  }
#line 3944
  if (r != 10) {
#line 3945
    printk("FDC %d init: DUMPREGS: unexpected return of %d bytes.\n", fdc, r);
#line 3948
    return ((char)16);
  }
#line 3951
  tmp = fdc_configure();
#line 3951
  if (! tmp) {
#line 3952
    printk("<6>FDC %d is an 82072\n", fdc);
#line 3953
    return ((char)64);
  }
#line 3956
  output_byte((char)18);
#line 3957
  tmp___0 = need_more_output();
#line 3957
  if (tmp___0 == -2) {
#line 3958
    output_byte((char)0);
  } else {
#line 3960
    printk("<6>FDC %d is an 82072A\n", fdc);
#line 3961
    return ((char)69);
  }
#line 3964
  output_byte((char)20);
#line 3965
  r = result();
#line 3966
  if (r == 1) {
#line 3966
    if ((int )reply_buffer[0] == 128) {
#line 3967
      printk("<6>FDC %d is a pre-1991 82077\n", fdc);
#line 3968
      return ((char)81);
    }
  }
#line 3971
  if (r != 1) {
#line 3972
    printk("FDC %d init: UNLOCK: unexpected return of %d bytes.\n", fdc, r);
#line 3974
    return ((char)16);
  } else
#line 3971
  if ((int )reply_buffer[0] != 0) {
#line 3972
    printk("FDC %d init: UNLOCK: unexpected return of %d bytes.\n", fdc, r);
#line 3974
    return ((char)16);
  }
#line 3976
  output_byte((char)24);
#line 3977
  r = result();
#line 3978
  if (r != 1) {
#line 3979
    printk("FDC %d init: PARTID: unexpected return of %d bytes.\n", fdc, r);
#line 3981
    return ((char)16);
  }
#line 3983
  if ((int )reply_buffer[0] == 128) {
#line 3984
    printk("<6>FDC %d is a post-1991 82077\n", fdc);
#line 3985
    return ((char)82);
  }
#line 3987
  switch ((int )reply_buffer[0] >> 5) {
  case 0: 
#line 3990
  printk("<6>FDC %d is an 82078.\n", fdc);
#line 3991
  return ((char)96);
  case 1: 
#line 3993
  printk("<6>FDC %d is a 44pin 82078\n", fdc);
#line 3994
  return ((char)96);
  case 2: 
#line 3996
  printk("<6>FDC %d is a S82078B\n", fdc);
#line 3997
  return ((char)98);
  case 3: 
#line 3999
  printk("<6>FDC %d is a National Semiconductor PC87306\n", fdc);
#line 4001
  return ((char)99);
  default: 
#line 4003
  printk("<6>FDC %d init: 82078 variant with unknown PARTID=%d.\n", fdc, (int )reply_buffer[0] >> 5);
#line 4006
  return ((char)95);
  }
}
}
#line 4012 "floppy.c"
static void floppy_set_flags(int *ints , int param , int param2 ) 
{ 
  int i ;
  char const   *tmp ;

  {
#line 4016
  i = 0;
#line 4016
  while ((unsigned long )i < sizeof(default_drive_params) / sizeof(default_drive_params[0])) {
#line 4017
    if (param) {
#line 4018
      default_drive_params[i].params.flags = (char )((int )default_drive_params[i].params.flags | param2);
    } else {
#line 4020
      default_drive_params[i].params.flags = (char )((int )default_drive_params[i].params.flags & ~ param2);
    }
#line 4016
    i ++;
  }
#line 4022
  if (param2) {
#line 4022
    tmp = "Setting";
  } else {
#line 4022
    tmp = "Clearing";
  }
#line 4022
  printk("floppy%d: %s flag 0x%x\n", (int )current_drive, tmp, param);
#line 4023
  return;
}
}
#line 4025 "floppy.c"
static void daring(int *ints , int param , int param2 ) 
{ 
  int i ;
  char const   *tmp ;

  {
#line 4029
  i = 0;
#line 4029
  while ((unsigned long )i < sizeof(default_drive_params) / sizeof(default_drive_params[0])) {
#line 4030
    if (param) {
#line 4031
      default_drive_params[i].params.select_delay = (unsigned char)0;
#line 4032
      default_drive_params[i].params.flags = (char )((int )default_drive_params[i].params.flags | 4);
    } else {
#line 4035
      default_drive_params[i].params.select_delay = (unsigned char)2;
#line 4037
      default_drive_params[i].params.flags = (char )((int )default_drive_params[i].params.flags & -5);
    }
#line 4029
    i ++;
  }
#line 4041
  if (param) {
#line 4041
    tmp = "standard";
  } else {
#line 4041
    tmp = "broken";
  }
#line 4041
  printk("floppy%d: Assuming %s floppy hardware\n", (int )current_drive, tmp);
#line 4042
  return;
}
}
#line 4044 "floppy.c"
static void set_cmos(int *ints , int dummy , int dummy2 ) 
{ 
  int current_drive___0 ;

  {
#line 4046
  current_drive___0 = 0;
#line 4048
  if (*(ints + 0) != 2) {
#line 4049
    printk("floppy%d: wrong number of parameters for CMOS\n", current_drive___0);
#line 4050
    return;
  }
#line 4052
  current_drive___0 = *(ints + 1);
#line 4053
  if (current_drive___0 < 0) {
#line 4054
    printk("floppy%d: bad drive for set_cmos\n", current_drive___0);
#line 4055
    return;
  } else
#line 4053
  if (current_drive___0 >= 8) {
#line 4054
    printk("floppy%d: bad drive for set_cmos\n", current_drive___0);
#line 4055
    return;
  }
#line 4058
  if (current_drive___0 >= 4) {
#line 4058
    if (! FDC2) {
#line 4059
      FDC2 = 880;
    }
  }
#line 4061
  drive_params[current_drive___0].cmos = (signed char )*(ints + 2);
#line 4062
  printk("floppy%d: setting CMOS code to %d\n", current_drive___0, *(ints + 2));
#line 4063
  return;
}
}
#line 4065 "floppy.c"
static struct param_table config_params[24]  = 
#line 4065
  {      {"allowed_drive_mask", (void (*)(int *ints , int param , int param2 ))((void *)0),
      & allowed_drive_mask, 255, 0}, 
        {"all_drives", (void (*)(int *ints , int param , int param2 ))((void *)0), & allowed_drive_mask,
      255, 0}, 
        {"asus_pci", (void (*)(int *ints , int param , int param2 ))((void *)0), & allowed_drive_mask,
      51, 0}, 
        {"irq", (void (*)(int *ints , int param , int param2 ))((void *)0), & FLOPPY_IRQ,
      6, 0}, 
        {"dma", (void (*)(int *ints , int param , int param2 ))((void *)0), & FLOPPY_DMA,
      2, 0}, 
        {"daring", & daring, (int *)((void *)0), 1, 0}, 
        {"two_fdc", (void (*)(int *ints , int param , int param2 ))((void *)0), & FDC2,
      880, 0}, 
        {"one_fdc", (void (*)(int *ints , int param , int param2 ))((void *)0), & FDC2,
      0, 0}, 
        {"thinkpad", & floppy_set_flags, (int *)((void *)0), 1, 128}, 
        {"broken_dcl", & floppy_set_flags, (int *)((void *)0), 1, 32}, 
        {"messages", & floppy_set_flags, (int *)((void *)0), 1, 16}, 
        {"silent_dcl_clear", & floppy_set_flags, (int *)((void *)0), 1, 4}, 
        {"debug", & floppy_set_flags, (int *)((void *)0), 1, 2}, 
        {"nodma", (void (*)(int *ints , int param , int param2 ))((void *)0), & can_use_virtual_dma,
      1, 0}, 
        {"omnibook", (void (*)(int *ints , int param , int param2 ))((void *)0), & can_use_virtual_dma,
      1, 0}, 
        {"yesdma", (void (*)(int *ints , int param , int param2 ))((void *)0), & can_use_virtual_dma,
      0, 0}, 
        {"fifo_depth", (void (*)(int *ints , int param , int param2 ))((void *)0), & fifo_depth,
      10, 0}, 
        {"nofifo", (void (*)(int *ints , int param , int param2 ))((void *)0), & no_fifo,
      32, 0}, 
        {"usefifo", (void (*)(int *ints , int param , int param2 ))((void *)0), & no_fifo,
      0, 0}, 
        {"cmos", & set_cmos, (int *)((void *)0), 0, 0}, 
        {"slow", (void (*)(int *ints , int param , int param2 ))((void *)0), & slow_floppy,
      1, 0}, 
        {"unexpected_interrupts", (void (*)(int *ints , int param , int param2 ))((void *)0),
      & print_unex, 1, 0}, 
        {"no_unexpected_interrupts", (void (*)(int *ints , int param , int param2 ))((void *)0),
      & print_unex, 0, 0}, 
        {"L40SX", (void (*)(int *ints , int param , int param2 ))((void *)0), & print_unex,
      0, 0}};
#line 4102 "floppy.c"
static int floppy_setup(char *str ) 
{ 
  int i ;
  int param ;
  int ints[11] ;
  int tmp ;

  {
#line 4108
  str = get_options((char const   *)str, (int )(sizeof(ints) / sizeof(ints[0])), ints);
#line 4109
  if (str) {
#line 4110
    i = 0;
#line 4110
    while ((unsigned long )i < sizeof(config_params) / sizeof(config_params[0])) {
#line 4111
      tmp = strcmp((char const   *)str, config_params[i].name);
#line 4111
      if (tmp == 0) {
#line 4112
        if (ints[0]) {
#line 4113
          param = ints[1];
        } else {
#line 4115
          param = config_params[i].def_param;
        }
#line 4116
        if (config_params[i].fn) {
#line 4117
          (*(config_params[i].fn))(ints, param, config_params[i].param2);
        }
#line 4120
        if (config_params[i].var) {
#line 4121
          printk("floppy%d: %s=%d\n", (int )current_drive, str, param);
#line 4122
          *(config_params[i].var) = param;
        }
#line 4124
        return (1);
      }
#line 4110
      i ++;
    }
  }
#line 4128
  if (str) {
#line 4129
    printk("floppy%d: unknown floppy option [%s]\n", (int )current_drive, str);
#line 4131
    printk("floppy%d: allowed options are:", (int )current_drive);
#line 4132
    i = 0;
#line 4132
    while ((unsigned long )i < sizeof(config_params) / sizeof(config_params[0])) {
#line 4133
      printk(" %s", config_params[i].name);
#line 4132
      i ++;
    }
#line 4134
    printk("\n");
  } else {
#line 4136
    printk("floppy%d: botched floppy option\n", (int )current_drive);
  }
#line 4137
  printk("floppy%d: Read Documentation/floppy.txt\n", (int )current_drive);
#line 4138
  return (0);
}
}
#line 4141 "floppy.c"
static int have_no_fdc  =    -19;
#line 4143 "floppy.c"
static ssize_t floppy_cmos_show(struct device *dev , struct device_attribute *attr ,
                                char *buf ) 
{ 
  struct platform_device *p ;
  int drive ;
  struct device *__mptr ;
  int tmp ;

  {
#line 4149
  __mptr = dev;
#line 4149
  p = (struct platform_device *)((char *)__mptr - (size_t )(& ((struct platform_device *)0)->dev));
#line 4150
  drive = (int )p->id;
#line 4151
  tmp = sprintf(buf, "%X\n", (int )drive_params[drive].cmos);
#line 4151
  return (tmp);
}
}
#line 4153 "floppy.c"
struct device_attribute dev_attr_cmos  =    {{"cmos", (struct module *)0, (mode_t )292}, & floppy_cmos_show, (ssize_t (*)(struct device *dev ,
                                                                                 struct device_attribute *attr ,
                                                                                 char const   *buf ,
                                                                                 size_t count ))((void *)0)};
#line 4155 "floppy.c"
static void floppy_device_release(struct device *dev ) 
{ 


  {
#line 4157
  complete(& device_release);
#line 4158
  return;
}
}
#line 4160 "floppy.c"
static struct platform_device floppy_device[8]  ;
#line 4162 "floppy.c"
static struct kobject *floppy_find(dev_t dev , int *part , void *data ) 
{ 
  int drive ;
  struct kobject *tmp ;

  {
#line 4164
  drive = (*part & 3) | ((*part & 128) >> 5);
#line 4165
  if (drive >= 8) {
#line 4168
    return ((struct kobject *)((void *)0));
  } else
#line 4165
  if (! (allowed_drive_mask & (1 << drive))) {
#line 4168
    return ((struct kobject *)((void *)0));
  } else
#line 4165
  if ((int )fdc_state[(drive & 4) >> 2].version == 0) {
#line 4168
    return ((struct kobject *)((void *)0));
  }
#line 4169
  if ((unsigned long )((*part >> 2) & 31) >= sizeof(floppy_type) / sizeof(floppy_type[0])) {
#line 4170
    return ((struct kobject *)((void *)0));
  }
#line 4171
  *part = 0;
#line 4172
  tmp = get_disk(disks[drive]);
#line 4172
  return (tmp);
}
}
#line 4213
extern int ( /* missing proto */  blk_queue_max_sectors)() ;
#line 4215
extern int ( /* missing proto */  blk_register_region)() ;
#line 4333
extern int ( /* missing proto */  platform_device_register)() ;
#line 4337
extern int ( /* missing proto */  device_create_file)() ;
#line 4353
extern int ( /* missing proto */  blk_unregister_region)() ;
#line 4175 "floppy.c"
static int floppy_init(void) 
{ 
  int i ;
  int unit ;
  int drive ;
  int err ;
  int dr ;
  int tmp ;
  char tmp___0 ;
  int tmp___1 ;

  {
#line 4185
  raw_cmd = (struct floppy_raw_cmd *)((void *)0);
#line 4187
  dr = 0;
#line 4187
  while (dr < 8) {
#line 4188
    disks[dr] = alloc_disk(1);
#line 4189
    if (! disks[dr]) {
#line 4190
      err = -12;
#line 4191
      goto out_put_disk;
    }
#line 4194
    (disks[dr])->major = 2;
#line 4195
    (disks[dr])->first_minor = (dr & 3) | ((dr & 4) << 5);
#line 4196
    (disks[dr])->fops = & floppy_fops;
#line 4197
    sprintf((disks[dr])->disk_name, "fd%d", dr);
#line 4199
    init_timer(& motor_off_timer[dr]);
#line 4200
    motor_off_timer[dr].data = (unsigned long )dr;
#line 4201
    motor_off_timer[dr].function = & motor_off_callback;
#line 4187
    dr ++;
  }
#line 4204
  err = register_blkdev(2U, "fd");
#line 4205
  if (err) {
#line 4206
    goto out_put_disk;
  }
#line 4208
  floppy_queue = blk_init_queue(& do_fd_request, & floppy_lock);
#line 4209
  if (! floppy_queue) {
#line 4210
    err = -12;
#line 4211
    goto out_unreg_blkdev;
  }
#line 4213
  blk_queue_max_sectors(floppy_queue, 64);
#line 4215
  blk_register_region(2 << 20, 256, (struct module *)0, & floppy_find, (void *)0,
                      (void *)0);
#line 4218
  i = 0;
#line 4218
  while (i < 256) {
#line 4219
    if ((i >> 2) & 31) {
#line 4220
      floppy_sizes[i] = (sector_t )floppy_type[(i >> 2) & 31].size;
    } else {
#line 4222
      floppy_sizes[i] = (sector_t )(4 << 1);
    }
#line 4218
    i ++;
  }
#line 4224
  reschedule_timeout(-2, "floppy init", -2);
#line 4225
  config_types();
#line 4227
  i = 0;
#line 4227
  while (i < 2) {
#line 4228
    fdc = i;
#line 4229
    memset((void *)(& fdc_state[fdc]), 0, (unsigned int )sizeof(fdc_state[fdc]));
#line 4230
    fdc_state[fdc].dtr = -1;
#line 4231
    fdc_state[fdc].dor = (unsigned char)4;
#line 4227
    i ++;
  }
#line 4241
  use_virtual_dma = can_use_virtual_dma & 1;
#line 4242
  fdc_state[0].address = (unsigned long )FDC1;
#line 4243
  if (fdc_state[0].address == 0xffffffffffffffffUL) {
#line 4244
    del_timer(& fd_timeout);
#line 4245
    err = -19;
#line 4246
    goto out_unreg_region;
  }
#line 4249
  fdc_state[1].address = (unsigned long )FDC2;
#line 4252
  fdc = 0;
#line 4253
  err = floppy_grab_irq_and_dma();
#line 4254
  if (err) {
#line 4255
    del_timer(& fd_timeout);
#line 4256
    err = -16;
#line 4257
    goto out_unreg_region;
  }
#line 4261
  drive = 0;
#line 4261
  while (drive < 8) {
#line 4262
    memset((void *)(& drive_state[drive]), 0, (unsigned int )sizeof(drive_state[drive]));
#line 4263
    memset((void *)(& write_errors[drive]), 0, (unsigned int )sizeof(write_errors[drive]));
#line 4264
    set_bit(2, & drive_state[drive].flags);
#line 4265
    set_bit(4, & drive_state[drive].flags);
#line 4266
    set_bit(1, & drive_state[drive].flags);
#line 4267
    drive_state[drive].fd_device = -1;
#line 4268
    floppy_track_buffer = (char *)((void *)0);
#line 4269
    max_buffer_sectors = 0;
#line 4261
    drive ++;
  }
#line 4276
  msleep(10U);
#line 4278
  i = 0;
#line 4278
  while (i < 2) {
#line 4279
    fdc = i;
#line 4280
    fdc_state[fdc].driver_version = 256U;
#line 4281
    unit = 0;
#line 4281
    while (unit < 4) {
#line 4282
      fdc_state[fdc].track[unit] = (unsigned char)0;
#line 4281
      unit ++;
    }
#line 4283
    if (fdc_state[fdc].address == 0xffffffffffffffffUL) {
#line 4284
      goto __Cont;
    }
#line 4285
    fdc_state[fdc].rawcmd = 2U;
#line 4286
    tmp = user_reset_fdc(-1, 2, 0);
#line 4286
    if (tmp) {
#line 4288
      release_region(fdc_state[fdc].address + 2UL, 4UL);
#line 4289
      release_region(fdc_state[fdc].address + 7UL, 1UL);
#line 4290
      fdc_state[fdc].address = 0xffffffffffffffffUL;
#line 4291
      fdc_state[fdc].version = (unsigned char)0;
#line 4292
      goto __Cont;
    }
#line 4295
    tmp___0 = get_fdc_version();
#line 4295
    fdc_state[fdc].version = (unsigned char )tmp___0;
#line 4296
    if ((int )fdc_state[fdc].version == 0) {
#line 4298
      release_region(fdc_state[fdc].address + 2UL, 4UL);
#line 4299
      release_region(fdc_state[fdc].address + 7UL, 1UL);
#line 4300
      fdc_state[fdc].address = 0xffffffffffffffffUL;
#line 4301
      goto __Cont;
    }
#line 4303
    if (can_use_virtual_dma == 2) {
#line 4303
      if ((int )fdc_state[fdc].version < 69) {
#line 4304
        can_use_virtual_dma = 0;
      }
    }
#line 4306
    have_no_fdc = 0;
#line 4311
    user_reset_fdc(-1, 2, 0);
    __Cont: /* CIL Label */ 
#line 4278
    i ++;
  }
#line 4313
  fdc = 0;
#line 4314
  del_timer(& fd_timeout);
#line 4315
  current_drive = (unsigned char)0;
#line 4316
  initialising = 0;
#line 4317
  if (have_no_fdc) {
#line 4318
    printk("floppy%d: no floppy controllers found\n", (int )current_drive);
#line 4319
    err = have_no_fdc;
#line 4320
    goto out_flush_work;
  }
#line 4323
  drive = 0;
#line 4323
  while (drive < 8) {
#line 4324
    if (! (allowed_drive_mask & (1 << drive))) {
#line 4325
      goto __Cont___0;
    }
#line 4326
    if ((int )fdc_state[(drive & 4) >> 2].version == 0) {
#line 4327
      goto __Cont___0;
    }
#line 4329
    floppy_device[drive].name = (char const   *)(floppy_device_name);
#line 4330
    floppy_device[drive].id = (u32 )drive;
#line 4331
    floppy_device[drive].dev.release = & floppy_device_release;
#line 4333
    err = platform_device_register(& floppy_device[drive]);
#line 4334
    if (err) {
#line 4335
      goto out_flush_work;
    }
#line 4337
    device_create_file(& floppy_device[drive].dev, & dev_attr_cmos);
#line 4339
    (disks[drive])->private_data = (void *)((long )drive);
#line 4340
    (disks[drive])->queue = floppy_queue;
#line 4341
    (disks[drive])->flags |= 1;
#line 4342
    (disks[drive])->driverfs_dev = & floppy_device[drive].dev;
#line 4343
    add_disk(disks[drive]);
    __Cont___0: /* CIL Label */ 
#line 4323
    drive ++;
  }
#line 4346
  return (0);
  out_flush_work: 
#line 4349
  flush_scheduled_work();
#line 4350
  if (usage_count) {
#line 4351
    floppy_release_irq_and_dma();
  }
  out_unreg_region: 
#line 4353
  blk_unregister_region(2 << 20, 256);
#line 4354
  blk_cleanup_queue(floppy_queue);
  out_unreg_blkdev: 
#line 4356
  unregister_blkdev(2U, "fd");
  out_put_disk: 
#line 4358
  while (1) {
#line 4358
    tmp___1 = dr;
#line 4358
    dr --;
#line 4358
    if (! tmp___1) {
#line 4358
      break;
    }
#line 4359
    del_timer(& motor_off_timer[dr]);
#line 4360
    put_disk(disks[dr]);
  }
#line 4362
  return (err);
}
}
#line 4365 "floppy.c"
static spinlock_t floppy_usage_lock  =    {1, 0};
#line 4384
extern int ( /* missing proto */  fd_request_irq)() ;
#line 4395
extern int ( /* missing proto */  fd_free_irq)() ;
#line 4392
extern int ( /* missing proto */  fd_request_dma)() ;
#line 4441
extern int ( /* missing proto */  fd_free_dma)() ;
#line 4367 "floppy.c"
static int floppy_grab_irq_and_dma(void) 
{ 
  unsigned long flags ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  struct resource *tmp___2 ;
  struct resource *tmp___3 ;

  {
#line 4371
  spin_lock_irqsave(& floppy_usage_lock, flags);
#line 4372
  tmp = usage_count;
#line 4372
  usage_count ++;
#line 4372
  if (tmp) {
#line 4373
    spin_unlock_irqrestore(& floppy_usage_lock, flags);
#line 4374
    return (0);
  }
#line 4376
  spin_unlock_irqrestore(& floppy_usage_lock, flags);
#line 4382
  flush_scheduled_work();
#line 4384
  tmp___0 = fd_request_irq();
#line 4384
  if (tmp___0) {
#line 4385
    printk("floppy%d: Unable to grab IRQ%d for the floppy driver\n", (int )current_drive,
           FLOPPY_IRQ);
#line 4387
    spin_lock_irqsave(& floppy_usage_lock, flags);
#line 4388
    usage_count --;
#line 4389
    spin_unlock_irqrestore(& floppy_usage_lock, flags);
#line 4390
    return (-1);
  }
#line 4392
  tmp___1 = fd_request_dma();
#line 4392
  if (tmp___1) {
#line 4393
    printk("floppy%d: Unable to grab DMA%d for the floppy driver\n", (int )current_drive,
           FLOPPY_DMA);
#line 4395
    fd_free_irq();
#line 4396
    spin_lock_irqsave(& floppy_usage_lock, flags);
#line 4397
    usage_count --;
#line 4398
    spin_unlock_irqrestore(& floppy_usage_lock, flags);
#line 4399
    return (-1);
  }
#line 4402
  fdc = 0;
#line 4402
  while (fdc < 2) {
#line 4403
    if (fdc_state[fdc].address != 0xffffffffffffffffUL) {
#line 4404
      tmp___2 = request_region(fdc_state[fdc].address + 2UL, 4UL, "floppy");
#line 4404
      if (! tmp___2) {
#line 4405
        printk("floppy%d: Floppy io-port 0x%04lx in use\n", (int )current_drive, fdc_state[fdc].address + 2UL);
#line 4407
        goto cleanup1;
      }
#line 4409
      tmp___3 = request_region(fdc_state[fdc].address + 7UL, 1UL, "floppy DIR");
#line 4409
      if (! tmp___3) {
#line 4410
        printk("floppy%d: Floppy io-port 0x%04lx in use\n", (int )current_drive, fdc_state[fdc].address + 7UL);
#line 4412
        goto cleanup2;
      }
    }
#line 4402
    fdc ++;
  }
#line 4418
  fdc = 0;
#line 4418
  while (fdc < 2) {
#line 4419
    if (fdc_state[fdc].address != 0xffffffffffffffffUL) {
#line 4420
      reset_fdc_info(1);
#line 4421
      fd_outb((int )fdc_state[fdc].dor, 2UL + fdc_state[fdc].address);
    }
#line 4418
    fdc ++;
  }
#line 4424
  fdc = 0;
#line 4425
  set_dor(0, (char )(~ 0), (char)8);
#line 4427
  fdc = 0;
#line 4427
  while (fdc < 2) {
#line 4428
    if (fdc_state[fdc].address != 0xffffffffffffffffUL) {
#line 4429
      fd_outb((int )fdc_state[fdc].dor, 2UL + fdc_state[fdc].address);
    }
#line 4427
    fdc ++;
  }
#line 4434
  fdc = 0;
#line 4435
  irqdma_allocated = 1;
#line 4436
  return (0);
  cleanup2: 
#line 4438
  release_region(fdc_state[fdc].address + 2UL, 4UL);
  cleanup1: 
#line 4440
  fd_free_irq();
#line 4441
  fd_free_dma();
#line 4442
  while (1) {
#line 4442
    fdc --;
#line 4442
    if (! (fdc >= 0)) {
#line 4442
      break;
    }
#line 4443
    release_region(fdc_state[fdc].address + 2UL, 4UL);
#line 4444
    release_region(fdc_state[fdc].address + 7UL, 1UL);
  }
#line 4446
  spin_lock_irqsave(& floppy_usage_lock, flags);
#line 4447
  usage_count --;
#line 4448
  spin_unlock_irqrestore(& floppy_usage_lock, flags);
#line 4449
  return (-1);
}
}
#line 4452 "floppy.c"
static void floppy_release_irq_and_dma(void) 
{ 
  int old_fdc ;
  int drive ;
  long tmpsize ;
  unsigned long tmpaddr ;
  unsigned long flags ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 4464
  spin_lock_irqsave(& floppy_usage_lock, flags);
#line 4465
  usage_count --;
#line 4465
  if (usage_count) {
#line 4466
    spin_unlock_irqrestore(& floppy_usage_lock, flags);
#line 4467
    return;
  }
#line 4469
  spin_unlock_irqrestore(& floppy_usage_lock, flags);
#line 4470
  if (irqdma_allocated) {
#line 4471
    fd_disable_dma();
#line 4472
    fd_free_dma();
#line 4473
    fd_free_irq();
#line 4474
    irqdma_allocated = 0;
  }
#line 4476
  set_dor(0, (char )(~ 0), (char)8);
#line 4478
  set_dor(1, (char )(~ 8), (char)0);
#line 4480
  floppy_enable_hlt();
#line 4482
  if (floppy_track_buffer) {
#line 4482
    if (max_buffer_sectors) {
#line 4483
      tmpsize = (long )(max_buffer_sectors * 1024);
#line 4484
      tmpaddr = (unsigned long )floppy_track_buffer;
#line 4485
      floppy_track_buffer = (char *)((void *)0);
#line 4486
      max_buffer_sectors = 0;
#line 4487
      buffer_max = -1;
#line 4487
      buffer_min = buffer_max;
#line 4488
      tmp = get_order(tmpsize);
#line 4488
      free_pages(tmpaddr, (unsigned int )tmp);
    }
  }
#line 4492
  drive = 0;
#line 4492
  while (drive < 8) {
#line 4493
    tmp___0 = timer_pending(motor_off_timer + drive);
#line 4493
    if (tmp___0) {
#line 4494
      printk("motor off timer %d still active\n", drive);
    }
#line 4492
    drive ++;
  }
#line 4497
  tmp___1 = timer_pending(& fd_timeout);
#line 4497
  if (tmp___1) {
#line 4498
    printk("floppy timer still active:%s\n", timeout_message);
  }
#line 4499
  tmp___2 = timer_pending(& fd_timer);
#line 4499
  if (tmp___2) {
#line 4500
    printk("auxiliary floppy timer still active\n");
  }
#line 4501
  if (floppy_work.pending) {
#line 4502
    printk("work still pending\n");
  }
#line 4504
  old_fdc = fdc;
#line 4505
  fdc = 0;
#line 4505
  while (fdc < 2) {
#line 4506
    if (fdc_state[fdc].address != 0xffffffffffffffffUL) {
#line 4507
      release_region(fdc_state[fdc].address + 2UL, 4UL);
#line 4508
      release_region(fdc_state[fdc].address + 7UL, 1UL);
    }
#line 4505
    fdc ++;
  }
#line 4510
  fdc = old_fdc;
#line 4511
  return;
}
}
#line 4515 "floppy.c"
static char *floppy  ;
#line 4517 "floppy.c"
static void parse_floppy_cfg_string(char *cfg ) 
{ 
  char *ptr ;

  {
#line 4521
  while (*cfg) {
#line 4522
    ptr = cfg;
#line 4522
    while (1) {
#line 4522
      if (*cfg) {
#line 4522
        if ((int )*cfg != 32) {
#line 4522
          if (! ((int )*cfg != 9)) {
#line 4522
            break;
          }
        } else {
#line 4522
          break;
        }
      } else {
#line 4522
        break;
      }
#line 4522
      cfg ++;
    }
#line 4523
    if (*cfg) {
#line 4524
      *cfg = (char )'\000';
#line 4525
      cfg ++;
    }
#line 4527
    if (*ptr) {
#line 4528
      floppy_setup(ptr);
    }
  }
#line 4530
  return;
}
}
#line 4532 "floppy.c"
int init_module(void) 
{ 
  int tmp ;

  {
#line 4534
  if (floppy) {
#line 4535
    parse_floppy_cfg_string(floppy);
  }
#line 4536
  tmp = floppy_init();
#line 4536
  return (tmp);
}
}
#line 4553
extern int ( /* missing proto */  device_remove_file)() ;
#line 4554
extern int ( /* missing proto */  platform_device_unregister)() ;
#line 4539 "floppy.c"
void cleanup_module(void) 
{ 
  int drive ;

  {
#line 4543
  init_completion(& device_release);
#line 4544
  blk_unregister_region(2 << 20, 256);
#line 4545
  unregister_blkdev(2U, "fd");
#line 4547
  drive = 0;
#line 4547
  while (drive < 8) {
#line 4548
    del_timer(& motor_off_timer[drive]);
#line 4550
    if (allowed_drive_mask & (1 << drive)) {
#line 4550
      if ((int )fdc_state[(drive & 4) >> 2].version != 0) {
#line 4552
        del_gendisk(disks[drive]);
#line 4553
        device_remove_file(& floppy_device[drive].dev, & dev_attr_cmos);
#line 4554
        platform_device_unregister(& floppy_device[drive]);
      }
    }
#line 4556
    put_disk(disks[drive]);
#line 4547
    drive ++;
  }
#line 4559
  del_timer(& fd_timeout);
#line 4560
  del_timer(& fd_timer);
#line 4561
  blk_cleanup_queue(floppy_queue);
#line 4563
  if (usage_count) {
#line 4564
    floppy_release_irq_and_dma();
  }
#line 4567
  fd_eject(0);
#line 4569
  wait_for_completion(& device_release);
#line 4570
  return;
}
}
#line 4575 "floppy.c"
char _ddv_module_author[15]  = 
#line 4575
  {      (char )'A',      (char )'l',      (char )'a',      (char )'i', 
        (char )'n',      (char )' ',      (char )'L',      (char )'.', 
        (char )' ',      (char )'K',      (char )'n',      (char )'a', 
        (char )'f',      (char )'f',      (char )'\000'};
#line 4576 "floppy.c"
char _ddv_module_supported_device[3]  = {      (char )'f',      (char )'d',      (char )'\000'};
#line 4577 "floppy.c"
char _ddv_module_license[4]  = {      (char )'G',      (char )'P',      (char )'L',      (char )'\000'};
#line 4586 "floppy.c"
int _ddv_module_param_major  =    2;
#line 4 "__main.c"
int main(void) 
{ 


  {
#line 6
  _ddv_module_init = & floppy_init;
#line 7
  _ddv_module_exit = & cleanup_module;
#line 8
  call_ddv();
#line 10
  return (0);
}
}
#line 1 "manage.o"
#pragma merger("0","/tmp/cil-XarEFu1t.i","")
#line 75 "/usr/local/ddv/models/con2/include/linux/interrupt.h"
int request_irq(unsigned int irq , irqreturn_t (*handler)(int  , void * , struct pt_regs * ) ,
                unsigned long irqflags , char const   *devname , void *dev_id ) ;
#line 78
void free_irq(unsigned int irq , void *dev_id ) ;
#line 4 "/usr/local/ddv/models/con2/src/linux/kernel/irq/manage.c"
int request_irq(unsigned int irq , irqreturn_t (*handler)(int  , void * , struct pt_regs * ) ,
                unsigned long irqflags , char const   *devname , void *dev_id ) 
{ 
  int tmp ;

  {
#line 7
  tmp = nondet_int();
#line 7
  if (tmp) {
#line 8
    registered_irq[irq].handler = handler;
#line 9
    registered_irq[irq].dev_id = dev_id;
#line 11
    return (0);
  } else {
#line 13
    return (-1);
  }
}
}
#line 17 "/usr/local/ddv/models/con2/src/linux/kernel/irq/manage.c"
void free_irq(unsigned int irq , void *dev_id ) 
{ 


  {
#line 19
  registered_irq[irq].handler = (irqreturn_t (*)(int  , void * , struct pt_regs * ))((void *)0);
#line 20
  registered_irq[irq].dev_id = (void *)0;
#line 21
  return;
}
}
#line 1 "misc.o"
#pragma merger("0","/tmp/cil-1bfbKsPh.i","")
#line 40 "/usr/local/ddv/models/con2/include/linux/miscdevice.h"
int misc_register(struct miscdevice *misc ) ;
#line 11 "/usr/local/ddv/models/con2/include/linux/proc_fs.h"
struct proc_dir_entry *proc_root_driver  ;
#line 18 "/usr/local/ddv/models/con2/src/linux/drivers/char/misc.c"
int misc_register(struct miscdevice *misc ) 
{ 
  int i ;
  dev_t dev ;
  int tmp ;

  {
#line 23
  if (fixed_cdev_used < 10) {
#line 24
    i = fixed_cdev_used;
#line 25
    fixed_cdev_used ++;
#line 27
    fixed_cdev[i].owner = (struct module *)0;
#line 28
    fixed_cdev[i].ops = misc->fops;
#line 30
    dev = (dev_t )((10 << 20) | misc->minor);
#line 32
    tmp = cdev_add(& fixed_cdev[i], dev, 0U);
#line 32
    return (tmp);
  } else {
#line 34
    return (-1);
  }
}
}
#line 1 "mutex.o"
#pragma merger("0","/tmp/cil-WeE4Yw5T.i","")
#line 32 "/usr/local/ddv/models/con2/include/ddverify/ddverify.h"
__inline static int assert_context_process(void) 
{ 


  {
#line 34
  return (0);
}
}
#line 32 "/usr/local/ddv/models/con2/include/linux/mutex.h"
__inline void mutex_init(struct mutex *lock ) ;
#line 4 "/usr/local/ddv/models/con2/src/linux/kernel/mutex.c"
__inline void mutex_init(struct mutex *lock ) 
{ 


  {
#line 7
  __CPROVER_atomic_begin();
#line 11
  lock->locked = 0;
#line 12
  lock->init = 1;
#line 13
  __CPROVER_atomic_end();
#line 14
  return;
}
}
#line 16 "/usr/local/ddv/models/con2/src/linux/kernel/mutex.c"
void mutex_lock(struct mutex *lock ) 
{ 


  {
#line 27
  while (1) {
#line 29
    __CPROVER_atomic_begin();
#line 30
    if (lock->locked == 0) {
#line 32
      lock->locked = 1;
#line 33
      __CPROVER_atomic_end();
#line 34
      return;
    }
#line 36
    __CPROVER_atomic_end();
  }
}
}
#line 41 "/usr/local/ddv/models/con2/src/linux/kernel/mutex.c"
void mutex_unlock(struct mutex *lock ) 
{ 


  {
#line 44
  __CPROVER_atomic_begin();
#line 45
  assert_context_process();
#line 49
  lock->locked = 0;
#line 50
  __CPROVER_atomic_end();
#line 51
  return;
}
}
#line 1 "page_alloc.o"
#pragma merger("0","/tmp/cil-6fJuJiL2.i","")
#line 55 "/usr/local/ddv/models/con2/include/linux/gfp.h"
__inline unsigned long __get_free_pages(gfp_t gfp_mask , unsigned int order ) ;
#line 57
__inline unsigned long __get_free_page(gfp_t gfp_mask ) ;
#line 59
__inline unsigned long get_zeroed_page(gfp_t gfp_mask ) ;
#line 70
__inline struct page *alloc_pages(gfp_t gfp_mask , unsigned int order ) ;
#line 5 "/usr/local/ddv/models/con2/src/linux/mm/page_alloc.c"
__inline unsigned long __get_free_pages(gfp_t gfp_mask , unsigned int order ) 
{ 


  {
#line 8
  if (gfp_mask & 16U) {
#line 9
    assert_context_process();
  }
#line 11
  return (0UL);
}
}
#line 13 "/usr/local/ddv/models/con2/src/linux/mm/page_alloc.c"
__inline unsigned long __get_free_page(gfp_t gfp_mask ) 
{ 


  {
#line 16
  if (gfp_mask & 16U) {
#line 17
    assert_context_process();
  }
#line 19
  return (0UL);
}
}
#line 38 "/usr/local/ddv/models/con2/src/linux/mm/page_alloc.c"
__inline struct page *alloc_pages(gfp_t gfp_mask , unsigned int order ) 
{ 


  {
#line 41
  if (gfp_mask & 16U) {
#line 42
    assert_context_process();
  }
#line 44
  return ((struct page *)0);
}
}
#line 46 "/usr/local/ddv/models/con2/src/linux/mm/page_alloc.c"
struct page *alloc_page(gfp_t gfp_mask ) 
{ 


  {
#line 49
  if (gfp_mask & 16U) {
#line 50
    assert_context_process();
  }
#line 52
  return ((struct page *)0);
}
}
#line 1 "pci.o"
#pragma merger("0","/tmp/cil-szFIsymA.i","")
#line 96 "/usr/local/ddv/models/con2/include/linux/ioport.h"
extern struct resource *request_mem_region(unsigned long start , unsigned long len ,
                                           char const   *name ) ;
#line 98
extern void release_mem_region(unsigned long start , unsigned long len ) ;
#line 87 "/usr/local/ddv/models/con2/include/linux/pci.h"
__inline struct pci_dev *pci_get_class(unsigned int class , struct pci_dev *from ) ;
#line 141
__inline int pci_register_driver(struct pci_driver *driver ) ;
#line 143
__inline void pci_unregister_driver(struct pci_driver *driver ) ;
#line 145
__inline int pci_enable_device(struct pci_dev *dev ) ;
#line 152
__inline int pci_request_regions(struct pci_dev *pdev , char const   *res_name ) ;
#line 154
__inline void pci_release_regions(struct pci_dev *pdev ) ;
#line 156
__inline int pci_request_region(struct pci_dev *pdev , int bar , char const   *res_name ) ;
#line 158
__inline void pci_release_region(struct pci_dev *pdev , int bar ) ;
#line 8 "/usr/local/ddv/models/con2/src/linux/pci.c"
__inline int pci_enable_device(struct pci_dev *dev ) 
{ 
  int i ;
  unsigned int tmp ;
  unsigned short tmp___0 ;

  {
#line 12
  i = 0;
#line 12
  while (i < 12) {
#line 13
    dev->resource[i].flags = 256UL;
#line 14
    tmp = nondet_uint();
#line 14
    dev->resource[i].start = (unsigned long )tmp;
#line 15
    tmp___0 = nondet_ushort();
#line 15
    dev->resource[i].end = dev->resource[i].start + (unsigned long )tmp___0;
#line 12
    i ++;
  }
#line 17
  return (0);
}
}
#line 19 "/usr/local/ddv/models/con2/src/linux/pci.c"
__inline struct pci_dev *pci_get_class(unsigned int class , struct pci_dev *from ) 
{ 
  void *tmp ;
  int tmp___0 ;

  {
#line 21
  if ((unsigned long )from == (unsigned long )((void *)0)) {
#line 22
    tmp = malloc((size_t )sizeof(struct pci_dev ));
#line 22
    from = (struct pci_dev *)tmp;
  }
#line 25
  tmp___0 = nondet_int();
#line 25
  if (tmp___0) {
#line 26
    from->vendor = nondet_ushort();
#line 27
    from->device = nondet_ushort();
#line 28
    from->irq = nondet_uint();
#line 29
    __CPROVER_assume(from->irq < 16U);
#line 31
    return (from);
  } else {
#line 33
    return ((struct pci_dev *)((void *)0));
  }
}
}
#line 37 "/usr/local/ddv/models/con2/src/linux/pci.c"
__inline int pci_register_driver(struct pci_driver *driver ) 
{ 
  int tmp ;

  {
#line 39
  tmp = nondet_int();
#line 39
  if (tmp) {
#line 40
    registered_pci_driver.pci_driver = driver;
#line 41
    registered_pci_driver.no_pci_device_id = (unsigned int )(sizeof(driver->id_table) / sizeof(struct pci_device_id ));
#line 42
    registered_pci_driver.dev_initialized = 0;
#line 44
    return (0);
  } else {
#line 46
    return (-1);
  }
}
}
#line 50 "/usr/local/ddv/models/con2/src/linux/pci.c"
__inline void pci_unregister_driver(struct pci_driver *driver ) 
{ 


  {
#line 52
  registered_pci_driver.pci_driver = (struct pci_driver *)((void *)0);
#line 53
  registered_pci_driver.no_pci_device_id = 0U;
#line 54
  return;
}
}
#line 56 "/usr/local/ddv/models/con2/src/linux/pci.c"
__inline void pci_release_region(struct pci_dev *pdev , int bar ) 
{ 
  unsigned long tmp ;
  unsigned long tmp___0 ;
  unsigned long tmp___1 ;

  {
#line 58
  if (pdev->resource[bar].start == 0UL) {
#line 58
    if (pdev->resource[bar].end == pdev->resource[bar].start) {
#line 58
      tmp = 0UL;
    } else {
#line 58
      tmp = (pdev->resource[bar].end - pdev->resource[bar].start) + 1UL;
    }
  } else {
#line 58
    tmp = (pdev->resource[bar].end - pdev->resource[bar].start) + 1UL;
  }
#line 58
  if (tmp == 0UL) {
#line 59
    return;
  }
#line 60
  if (pdev->resource[bar].flags & 256UL) {
#line 61
    if (pdev->resource[bar].start == 0UL) {
#line 61
      if (pdev->resource[bar].end == pdev->resource[bar].start) {
#line 61
        tmp___0 = 0UL;
      } else {
#line 61
        tmp___0 = (pdev->resource[bar].end - pdev->resource[bar].start) + 1UL;
      }
    } else {
#line 61
      tmp___0 = (pdev->resource[bar].end - pdev->resource[bar].start) + 1UL;
    }
#line 61
    release_region(pdev->resource[bar].start, tmp___0);
  } else
#line 63
  if (pdev->resource[bar].flags & 512UL) {
#line 64
    if (pdev->resource[bar].start == 0UL) {
#line 64
      if (pdev->resource[bar].end == pdev->resource[bar].start) {
#line 64
        tmp___1 = 0UL;
      } else {
#line 64
        tmp___1 = (pdev->resource[bar].end - pdev->resource[bar].start) + 1UL;
      }
    } else {
#line 64
      tmp___1 = (pdev->resource[bar].end - pdev->resource[bar].start) + 1UL;
    }
#line 64
    release_mem_region(pdev->resource[bar].start, tmp___1);
  }
#line 66
  return;
}
}
#line 68 "/usr/local/ddv/models/con2/src/linux/pci.c"
__inline int pci_request_region(struct pci_dev *pdev , int bar , char const   *res_name ) 
{ 
  unsigned long tmp ;
  unsigned long tmp___0 ;
  struct resource *tmp___1 ;
  unsigned long tmp___2 ;
  struct resource *tmp___3 ;

  {
#line 70
  if (pdev->resource[bar].start == 0UL) {
#line 70
    if (pdev->resource[bar].end == pdev->resource[bar].start) {
#line 70
      tmp = 0UL;
    } else {
#line 70
      tmp = (pdev->resource[bar].end - pdev->resource[bar].start) + 1UL;
    }
  } else {
#line 70
    tmp = (pdev->resource[bar].end - pdev->resource[bar].start) + 1UL;
  }
#line 70
  if (tmp == 0UL) {
#line 71
    return (0);
  }
#line 73
  if (pdev->resource[bar].flags & 256UL) {
#line 74
    if (pdev->resource[bar].start == 0UL) {
#line 74
      if (pdev->resource[bar].end == pdev->resource[bar].start) {
#line 74
        tmp___0 = 0UL;
      } else {
#line 74
        tmp___0 = (pdev->resource[bar].end - pdev->resource[bar].start) + 1UL;
      }
    } else {
#line 74
      tmp___0 = (pdev->resource[bar].end - pdev->resource[bar].start) + 1UL;
    }
#line 74
    tmp___1 = request_region(pdev->resource[bar].start, tmp___0, res_name);
#line 74
    if (! tmp___1) {
#line 76
      return (-16);
    }
  } else
#line 78
  if (pdev->resource[bar].flags & 512UL) {
#line 79
    if (pdev->resource[bar].start == 0UL) {
#line 79
      if (pdev->resource[bar].end == pdev->resource[bar].start) {
#line 79
        tmp___2 = 0UL;
      } else {
#line 79
        tmp___2 = (pdev->resource[bar].end - pdev->resource[bar].start) + 1UL;
      }
    } else {
#line 79
      tmp___2 = (pdev->resource[bar].end - pdev->resource[bar].start) + 1UL;
    }
#line 79
    tmp___3 = request_mem_region(pdev->resource[bar].start, tmp___2, res_name);
#line 79
    if (! tmp___3) {
#line 81
      return (-16);
    }
  }
#line 84
  return (0);
}
}
#line 87 "/usr/local/ddv/models/con2/src/linux/pci.c"
__inline void pci_release_regions(struct pci_dev *pdev ) 
{ 
  int i ;

  {
#line 91
  i = 0;
#line 91
  while (i < 6) {
#line 92
    pci_release_region(pdev, i);
#line 91
    i ++;
  }
#line 93
  return;
}
}
#line 95 "/usr/local/ddv/models/con2/src/linux/pci.c"
__inline int pci_request_regions(struct pci_dev *pdev , char const   *res_name ) 
{ 
  int i ;
  int tmp ;

  {
#line 99
  i = 0;
#line 99
  while (i < 6) {
#line 100
    tmp = pci_request_region(pdev, i, res_name);
#line 100
    if (tmp) {
#line 101
      goto err_out;
    }
#line 99
    i ++;
  }
#line 102
  return (0);
  err_out: 
#line 105
  while (1) {
#line 105
    i --;
#line 105
    if (! (i >= 0)) {
#line 105
      break;
    }
#line 106
    pci_release_region(pdev, i);
  }
#line 108
  return (-16);
}
}
#line 1 "resource.o"
#pragma merger("0","/tmp/cil-Zjzx09zn.i","")
#line 21 "/usr/local/ddv/models/con2/include/ddverify/satabs.h"
extern unsigned char nondet_uchar() ;
#line 22
extern unsigned int nondet_unsigned() ;
#line 10 "/usr/local/ddv/models/con2/include/ddverify/ioport.h"
int ddv_ioport_request_start  ;
#line 11 "/usr/local/ddv/models/con2/include/ddverify/ioport.h"
int ddv_ioport_request_len  ;
#line 6 "/usr/local/ddv/models/con2/src/linux/kernel/resource.c"
struct resource *request_region(unsigned long start , unsigned long len , char const   *name ) 
{ 
  struct resource *resource ;
  void *tmp ;

  {
#line 9
  tmp = malloc((size_t )sizeof(struct resource ));
#line 9
  resource = (struct resource *)tmp;
#line 14
  ddv_ioport_request_start = (int )start;
#line 15
  ddv_ioport_request_len = (int )len;
#line 17
  return (resource);
}
}
#line 20 "/usr/local/ddv/models/con2/src/linux/kernel/resource.c"
void release_region(unsigned long start , unsigned long len ) 
{ 
  unsigned int i ;

  {
#line 22
  i = 0U;
#line 28
  ddv_ioport_request_start = 0;
#line 29
  ddv_ioport_request_len = 0;
#line 30
  return;
}
}
#line 32 "/usr/local/ddv/models/con2/src/linux/kernel/resource.c"
__inline unsigned char inb(unsigned int port ) 
{ 
  int tmp ;
  unsigned char tmp___0 ;

  {
#line 35
  if (port >= (unsigned int )ddv_ioport_request_start) {
#line 35
    if (port < (unsigned int )(ddv_ioport_request_start + ddv_ioport_request_len)) {
#line 35
      tmp = 1;
    } else {
#line 35
      tmp = 0;
    }
  } else {
#line 35
    tmp = 0;
  }
#line 35
  __CPROVER_assert(tmp, "I/O port is requested");
#line 37
  tmp___0 = nondet_uchar();
#line 37
  return (tmp___0);
}
}
#line 40 "/usr/local/ddv/models/con2/src/linux/kernel/resource.c"
__inline void outb(unsigned char byte , unsigned int port ) 
{ 
  int tmp ;

  {
#line 43
  if (port >= (unsigned int )ddv_ioport_request_start) {
#line 43
    if (port < (unsigned int )(ddv_ioport_request_start + ddv_ioport_request_len)) {
#line 43
      tmp = 1;
    } else {
#line 43
      tmp = 0;
    }
  } else {
#line 43
    tmp = 0;
  }
#line 43
  __CPROVER_assert(tmp, "I/O port is requested");
#line 44
  return;
}
}
#line 46 "/usr/local/ddv/models/con2/src/linux/kernel/resource.c"
__inline unsigned short inw(unsigned int port ) 
{ 
  int tmp ;
  unsigned short tmp___0 ;

  {
#line 49
  if (port >= (unsigned int )ddv_ioport_request_start) {
#line 49
    if (port < (unsigned int )(ddv_ioport_request_start + ddv_ioport_request_len)) {
#line 49
      tmp = 1;
    } else {
#line 49
      tmp = 0;
    }
  } else {
#line 49
    tmp = 0;
  }
#line 49
  __CPROVER_assert(tmp, "I/O port is requested");
#line 51
  tmp___0 = nondet_ushort();
#line 51
  return (tmp___0);
}
}
#line 54 "/usr/local/ddv/models/con2/src/linux/kernel/resource.c"
__inline void outw(unsigned short word , unsigned int port ) 
{ 
  int tmp ;

  {
#line 57
  if (port >= (unsigned int )ddv_ioport_request_start) {
#line 57
    if (port < (unsigned int )(ddv_ioport_request_start + ddv_ioport_request_len)) {
#line 57
      tmp = 1;
    } else {
#line 57
      tmp = 0;
    }
  } else {
#line 57
    tmp = 0;
  }
#line 57
  __CPROVER_assert(tmp, "I/O port is requested");
#line 58
  return;
}
}
#line 60 "/usr/local/ddv/models/con2/src/linux/kernel/resource.c"
__inline unsigned int inl(unsigned int port ) 
{ 
  int tmp ;
  unsigned int tmp___0 ;

  {
#line 63
  if (port >= (unsigned int )ddv_ioport_request_start) {
#line 63
    if (port < (unsigned int )(ddv_ioport_request_start + ddv_ioport_request_len)) {
#line 63
      tmp = 1;
    } else {
#line 63
      tmp = 0;
    }
  } else {
#line 63
    tmp = 0;
  }
#line 63
  __CPROVER_assert(tmp, "I/O port is requested");
#line 65
  tmp___0 = nondet_unsigned();
#line 65
  return (tmp___0);
}
}
#line 68 "/usr/local/ddv/models/con2/src/linux/kernel/resource.c"
__inline void outl(unsigned int doubleword , unsigned int port ) 
{ 
  int tmp ;

  {
#line 71
  if (port >= (unsigned int )ddv_ioport_request_start) {
#line 71
    if (port < (unsigned int )(ddv_ioport_request_start + ddv_ioport_request_len)) {
#line 71
      tmp = 1;
    } else {
#line 71
      tmp = 0;
    }
  } else {
#line 71
    tmp = 0;
  }
#line 71
  __CPROVER_assert(tmp, "I/O port is requested");
#line 72
  return;
}
}
#line 1 "sched.o"
#pragma merger("0","/tmp/cil-tf7Onpvp.i","")
#line 18 "/usr/local/ddv/models/con2/include/ddverify/satabs.h"
extern long nondet_long() ;
#line 45 "/usr/local/ddv/models/con2/include/linux/sched.h"
long schedule_timeout(long timeout ) ;
#line 8 "/usr/local/ddv/models/con2/src/linux/kernel/sched.c"
void schedule(void) 
{ 


  {
#line 10
  assert_context_process();
#line 11
  return;
}
}
#line 13 "/usr/local/ddv/models/con2/src/linux/kernel/sched.c"
long schedule_timeout(long timeout ) 
{ 
  long tmp ;

  {
#line 15
  assert_context_process();
#line 17
  tmp = nondet_long();
#line 17
  return (tmp);
}
}
#line 1 "semaphore.o"
#pragma merger("0","/tmp/cil-AK3EdslJ.i","")
#line 23 "/usr/local/ddv/models/con2/include/asm/semaphore.h"
__inline void sema_init(struct semaphore *sem , int val ) ;
#line 25
__inline void init_MUTEX(struct semaphore *sem ) ;
#line 27
__inline void init_MUTEX_LOCKED(struct semaphore *sem ) ;
#line 29
__inline void down(struct semaphore *sem ) ;
#line 31
__inline int down_interruptible(struct semaphore *sem ) ;
#line 33
__inline int down_trylock(struct semaphore *sem ) ;
#line 35
__inline void up(struct semaphore *sem ) ;
#line 6 "/usr/local/ddv/models/con2/src/linux/kernel/semaphore.c"
__inline void sema_init(struct semaphore *sem , int val ) 
{ 


  {
#line 9
  __CPROVER_atomic_begin();
#line 10
  sem->init = 1;
#line 11
  sem->locked = 0;
#line 12
  __CPROVER_atomic_end();
#line 13
  return;
}
}
#line 15 "/usr/local/ddv/models/con2/src/linux/kernel/semaphore.c"
__inline void init_MUTEX(struct semaphore *sem ) 
{ 


  {
#line 18
  __CPROVER_atomic_begin();
#line 19
  sem->init = 1;
#line 20
  sem->locked = 0;
#line 21
  __CPROVER_atomic_end();
#line 22
  return;
}
}
#line 24 "/usr/local/ddv/models/con2/src/linux/kernel/semaphore.c"
__inline void init_MUTEX_LOCKED(struct semaphore *sem ) 
{ 


  {
#line 27
  __CPROVER_atomic_begin();
#line 28
  sem->init = 1;
#line 29
  sem->locked = 1;
#line 30
  __CPROVER_atomic_end();
#line 31
  return;
}
}
#line 33 "/usr/local/ddv/models/con2/src/linux/kernel/semaphore.c"
__inline void down(struct semaphore *sem ) 
{ 


  {
#line 44
  while (1) {
#line 46
    __CPROVER_atomic_begin();
#line 47
    if (sem->locked == 0) {
#line 49
      sem->locked = 1;
#line 50
      __CPROVER_atomic_end();
#line 51
      return;
    }
#line 53
    __CPROVER_atomic_end();
  }
}
}
#line 58 "/usr/local/ddv/models/con2/src/linux/kernel/semaphore.c"
__inline int down_interruptible(struct semaphore *sem ) 
{ 
  int tmp ;

  {
#line 69
  while (1) {
#line 71
    __CPROVER_atomic_begin();
#line 72
    if (sem->locked == 0) {
#line 74
      sem->locked = 1;
#line 75
      __CPROVER_atomic_end();
#line 76
      return (0);
    }
#line 78
    tmp = nondet_int();
#line 78
    if (tmp) {
#line 79
      __CPROVER_atomic_end();
#line 80
      return (-1);
    }
#line 83
    __CPROVER_atomic_end();
  }
}
}
#line 88 "/usr/local/ddv/models/con2/src/linux/kernel/semaphore.c"
__inline int down_trylock(struct semaphore *sem ) 
{ 


  {
#line 91
  __CPROVER_atomic_begin();
#line 97
  if (sem->locked == 0) {
#line 98
    sem->locked = 1;
#line 99
    __CPROVER_atomic_end();
#line 100
    return (-1);
  }
#line 102
  __CPROVER_atomic_end();
#line 103
  return (0);
}
}
#line 106 "/usr/local/ddv/models/con2/src/linux/kernel/semaphore.c"
__inline void up(struct semaphore *sem ) 
{ 


  {
#line 109
  __CPROVER_atomic_begin();
#line 110
  assert_context_process();
#line 114
  sem->locked = 0;
#line 115
  __CPROVER_atomic_end();
#line 116
  return;
}
}
#line 1 "slab.o"
#pragma merger("0","/tmp/cil-teYoir5Y.i","")
#line 12 "/usr/local/ddv/models/con2/include/linux/slab.h"
void *kzalloc(size_t size , gfp_t flags ) ;
#line 6 "/usr/local/ddv/models/con2/src/linux/mm/slab.c"
void *kmalloc(size_t size , gfp_t flags ) 
{ 
  void *tmp ;

  {
#line 8
  if (flags & 16U) {
#line 9
    assert_context_process();
  }
#line 12
  tmp = malloc(size);
#line 12
  return (tmp);
}
}
#line 15 "/usr/local/ddv/models/con2/src/linux/mm/slab.c"
void *kzalloc(size_t size , gfp_t flags ) 
{ 
  void *tmp ;

  {
#line 17
  if (flags & 16U) {
#line 18
    assert_context_process();
  }
#line 21
  tmp = malloc(size);
#line 21
  return (tmp);
}
}
#line 1 "softirq.o"
#pragma merger("0","/tmp/cil-4BcE1DpB.i","")
#line 50 "/usr/local/ddv/models/con2/include/linux/interrupt.h"
__inline void tasklet_schedule(struct tasklet_struct *t ) ;
#line 65
__inline void tasklet_init(struct tasklet_struct *t , void (*func)(unsigned long  ) ,
                           unsigned long data ) ;
#line 4 "/usr/local/ddv/models/con2/src/linux/kernel/softirq.c"
__inline void tasklet_schedule(struct tasklet_struct *t ) 
{ 
  int i ;
  int next_free ;

  {
#line 7
  next_free = -1;
#line 13
  i = 0;
#line 13
  while (i < 10) {
#line 14
    if ((unsigned long )tasklet_registered[i].tasklet == (unsigned long )((void *)0)) {
#line 15
      next_free = i;
    }
#line 17
    if ((unsigned long )tasklet_registered[i].tasklet == (unsigned long )t) {
#line 17
      if ((int )tasklet_registered[i].is_running == 0) {
#line 19
        return;
      }
    }
#line 13
    i ++;
  }
#line 28
  tasklet_registered[next_free].tasklet = t;
#line 29
  tasklet_registered[next_free].is_running = (unsigned short)0;
#line 30
  return;
}
}
#line 32 "/usr/local/ddv/models/con2/src/linux/kernel/softirq.c"
__inline void tasklet_init(struct tasklet_struct *t , void (*func)(unsigned long  ) ,
                           unsigned long data ) 
{ 


  {
#line 36
  t->count = 0;
#line 37
  t->init = 0;
#line 38
  t->func = func;
#line 39
  t->data = data;
#line 40
  return;
}
}
#line 1 "spinlock.o"
#pragma merger("0","/tmp/cil-xFO0HbCD.i","")
#line 10 "/usr/local/ddv/models/con2/include/linux/spinlock.h"
__inline void spin_lock(spinlock_t *lock ) ;
#line 13
__inline void spin_lock_bh(spinlock_t *lock ) ;
#line 15
__inline void spin_unlock(spinlock_t *lock ) ;
#line 18
__inline void spin_unlock_bh(spinlock_t *lock ) ;
#line 4 "/usr/local/ddv/models/con2/src/linux/kernel/spinlock.c"
void spin_lock_init(spinlock_t *lock ) 
{ 


  {
#line 6
  lock->init = 1;
#line 7
  lock->locked = 0;
#line 8
  return;
}
}
#line 10 "/usr/local/ddv/models/con2/src/linux/kernel/spinlock.c"
__inline void spin_lock(spinlock_t *lock ) 
{ 


  {
#line 20
  while (1) {
#line 22
    __CPROVER_atomic_begin();
#line 23
    if (lock->locked == 0) {
#line 25
      lock->locked = 1;
#line 26
      __CPROVER_atomic_end();
#line 27
      return;
    }
#line 29
    __CPROVER_atomic_end();
  }
}
}
#line 34 "/usr/local/ddv/models/con2/src/linux/kernel/spinlock.c"
void spin_lock_irqsave(spinlock_t *lock , unsigned long flags ) 
{ 


  {
#line 44
  while (1) {
#line 46
    __CPROVER_atomic_begin();
#line 47
    if (lock->locked == 0) {
#line 49
      lock->locked = 1;
#line 50
      __CPROVER_atomic_end();
#line 51
      return;
    }
#line 53
    __CPROVER_atomic_end();
  }
}
}
#line 58 "/usr/local/ddv/models/con2/src/linux/kernel/spinlock.c"
void spin_lock_irq(spinlock_t *lock ) 
{ 


  {
#line 68
  while (1) {
#line 70
    __CPROVER_atomic_begin();
#line 71
    if (lock->locked == 0) {
#line 73
      lock->locked = 1;
#line 74
      __CPROVER_atomic_end();
#line 75
      return;
    }
#line 77
    __CPROVER_atomic_end();
  }
}
}
#line 106 "/usr/local/ddv/models/con2/src/linux/kernel/spinlock.c"
__inline void spin_unlock(spinlock_t *lock ) 
{ 


  {
#line 109
  __CPROVER_atomic_begin();
#line 113
  lock->locked = 0;
#line 114
  __CPROVER_atomic_end();
#line 115
  return;
}
}
#line 117 "/usr/local/ddv/models/con2/src/linux/kernel/spinlock.c"
void spin_unlock_irqrestore(spinlock_t *lock , unsigned long flags ) 
{ 


  {
#line 120
  __CPROVER_atomic_begin();
#line 124
  lock->locked = 0;
#line 125
  __CPROVER_atomic_end();
#line 126
  return;
}
}
#line 128 "/usr/local/ddv/models/con2/src/linux/kernel/spinlock.c"
void spin_unlock_irq(spinlock_t *lock ) 
{ 


  {
#line 131
  __CPROVER_atomic_begin();
#line 135
  lock->locked = 0;
#line 136
  __CPROVER_atomic_end();
#line 137
  return;
}
}
#line 1 "tasklet.o"
#pragma merger("0","/tmp/cil-zlX7hWfS.i","")
#line 3 "/usr/local/ddv/models/con2/src/ddverify/tasklet.c"
void call_tasklet_functions(void) 
{ 
  unsigned int i ;

  {
#line 6
  __CPROVER_assume(i < 10U);
#line 8
  if ((unsigned long )tasklet_registered[i].tasklet != (unsigned long )((void *)0)) {
#line 8
    if ((tasklet_registered[i].tasklet)->count == 0) {
#line 10
      tasklet_registered[i].is_running = (unsigned short)1;
#line 11
      (*((tasklet_registered[i].tasklet)->func))((tasklet_registered[i].tasklet)->data);
#line 12
      tasklet_registered[i].is_running = (unsigned short)0;
#line 13
      tasklet_registered[i].tasklet = (struct tasklet_struct *)((void *)0);
    }
  }
#line 15
  return;
}
}
#line 1 "timer.o"
#pragma merger("0","/tmp/cil-ZcDe0y8E.i","")
#line 27 "/usr/local/ddv/models/con2/include/linux/timer.h"
__inline void add_timer_on(struct timer_list *timer , int cpu ) ;
#line 30
__inline int mod_timer(struct timer_list *timer , unsigned long expires ) ;
#line 4 "/usr/local/ddv/models/con2/src/linux/kernel/timer.c"
void init_timer(struct timer_list *timer ) 
{ 


  {
#line 6
  if ((int )number_timer_registered < 5) {
#line 7
    timer->__ddv_active = (short)0;
#line 8
    timer->__ddv_init = (short)1;
#line 9
    timer_registered[number_timer_registered].timer = timer;
#line 11
    number_timer_registered = (short )((int )number_timer_registered + 1);
  }
#line 13
  return;
}
}
#line 15 "/usr/local/ddv/models/con2/src/linux/kernel/timer.c"
void add_timer(struct timer_list *timer ) 
{ 


  {
#line 21
  timer->__ddv_active = (short)1;
#line 22
  return;
}
}
#line 24 "/usr/local/ddv/models/con2/src/linux/kernel/timer.c"
__inline void add_timer_on(struct timer_list *timer , int cpu ) 
{ 


  {
#line 27
  add_timer(timer);
#line 28
  return;
}
}
#line 30 "/usr/local/ddv/models/con2/src/linux/kernel/timer.c"
int del_timer(struct timer_list *timer ) 
{ 


  {
#line 32
  timer->__ddv_active = (short)0;
#line 33
  return (0);
}
}
#line 35 "/usr/local/ddv/models/con2/src/linux/kernel/timer.c"
__inline int mod_timer(struct timer_list *timer , unsigned long expires ) 
{ 


  {
#line 41
  timer->expires = expires;
#line 42
  timer->__ddv_active = (short)1;
#line 43
  return (0);
}
}
#line 1 "tty_io.o"
#pragma merger("0","/tmp/cil-Gz3rLlA8.i","")
#line 97 "/usr/local/ddv/models/con2/include/linux/tty_driver.h"
struct tty_driver *alloc_tty_driver(int lines ) ;
#line 101
void tty_set_operations(struct tty_driver *driver , struct tty_operations  const  *op ) ;
#line 13 "/usr/local/ddv/models/con2/include/ddverify/tty.h"
struct ddv_tty_driver global_tty_driver  ;
#line 4 "/usr/local/ddv/models/con2/src/linux/drivers/char/tty_io.c"
struct tty_driver *alloc_tty_driver(int lines ) 
{ 


  {
#line 6
  if (! global_tty_driver.allocated) {
#line 7
    global_tty_driver.driver.magic = 21506;
#line 8
    global_tty_driver.driver.num = lines;
  } else {
#line 10
    return ((struct tty_driver *)((void *)0));
  }
#line 12
  return ((struct tty_driver *)0);
}
}
#line 14 "/usr/local/ddv/models/con2/src/linux/drivers/char/tty_io.c"
void tty_set_operations(struct tty_driver *driver , struct tty_operations  const  *op ) 
{ 


  {
#line 17
  driver->open = (int (*)(struct tty_struct *tty , struct file *filp ))op->open;
#line 18
  driver->close = (void (*)(struct tty_struct *tty , struct file *filp ))op->close;
#line 19
  driver->write = (int (*)(struct tty_struct *tty , unsigned char const   *buf , int count ))op->write;
#line 20
  driver->put_char = (void (*)(struct tty_struct *tty , unsigned char ch ))op->put_char;
#line 21
  driver->flush_chars = (void (*)(struct tty_struct *tty ))op->flush_chars;
#line 22
  driver->write_room = (int (*)(struct tty_struct *tty ))op->write_room;
#line 23
  driver->chars_in_buffer = (int (*)(struct tty_struct *tty ))op->chars_in_buffer;
#line 24
  driver->ioctl = (int (*)(struct tty_struct *tty , struct file *file , unsigned int cmd ,
                           unsigned long arg ))op->ioctl;
#line 25
  driver->set_termios = (void (*)(struct tty_struct *tty , struct termios *old ))op->set_termios;
#line 26
  driver->throttle = (void (*)(struct tty_struct *tty ))op->throttle;
#line 27
  driver->unthrottle = (void (*)(struct tty_struct *tty ))op->unthrottle;
#line 28
  driver->stop = (void (*)(struct tty_struct *tty ))op->stop;
#line 29
  driver->start = (void (*)(struct tty_struct *tty ))op->start;
#line 30
  driver->hangup = (void (*)(struct tty_struct *tty ))op->hangup;
#line 31
  driver->break_ctl = (void (*)(struct tty_struct *tty , int state ))op->break_ctl;
#line 32
  driver->flush_buffer = (void (*)(struct tty_struct *tty ))op->flush_buffer;
#line 33
  driver->set_ldisc = (void (*)(struct tty_struct *tty ))op->set_ldisc;
#line 34
  driver->wait_until_sent = (void (*)(struct tty_struct *tty , int timeout ))op->wait_until_sent;
#line 35
  driver->send_xchar = (void (*)(struct tty_struct *tty , char ch ))op->send_xchar;
#line 36
  driver->read_proc = (int (*)(char *page , char **start , off_t off , int count ,
                               int *eof , void *data ))op->read_proc;
#line 37
  driver->write_proc = (int (*)(struct file *file , char const   *buffer , unsigned long count ,
                                void *data ))op->write_proc;
#line 38
  driver->tiocmget = (int (*)(struct tty_struct *tty , struct file *file ))op->tiocmget;
#line 39
  driver->tiocmset = (int (*)(struct tty_struct *tty , struct file *file , unsigned int set ,
                              unsigned int clear ))op->tiocmset;
#line 40
  return;
}
}
#line 1 "usercopy.o"
#pragma merger("0","/tmp/cil-RBacJ1jG.i","")
#line 41 "/usr/local/ddv/models/con2/include/asm/uaccess.h"
__inline int __get_user(int size , void *ptr ) ;
#line 43
__inline int get_user(int size , void *ptr ) ;
#line 46
__inline int __put_user(int size , void *ptr ) ;
#line 48
__inline int put_user(int size , void *ptr ) ;
#line 5 "/usr/local/ddv/models/con2/src/linux/arch/i386/lib/usercopy.c"
__inline int __get_user(int size , void *ptr ) 
{ 
  int tmp ;

  {
#line 8
  assert_context_process();
#line 10
  tmp = nondet_int();
#line 10
  return (tmp);
}
}
#line 37 "/usr/local/ddv/models/con2/src/linux/arch/i386/lib/usercopy.c"
unsigned long copy_to_user(void *to , void const   *from , unsigned long n ) 
{ 
  unsigned long tmp ;

  {
#line 40
  assert_context_process();
#line 42
  tmp = nondet_ulong();
#line 42
  return (tmp);
}
}
#line 45 "/usr/local/ddv/models/con2/src/linux/arch/i386/lib/usercopy.c"
unsigned long copy_from_user(void *to , void *from , unsigned long n ) 
{ 
  unsigned long tmp ;

  {
#line 48
  assert_context_process();
#line 50
  tmp = nondet_ulong();
#line 50
  return (tmp);
}
}
#line 1 "vmalloc.o"
#pragma merger("0","/tmp/cil-G1MwYXCL.i","")
#line 6 "/usr/local/ddv/models/con2/include/linux/vmalloc.h"
void *vmalloc(unsigned long size ) ;
#line 6 "/usr/local/ddv/models/con2/src/linux/mm/vmalloc.c"
void *vmalloc(unsigned long size ) 
{ 
  void *tmp ;

  {
#line 8
  tmp = malloc((size_t )size);
#line 8
  return (tmp);
}
}
#line 1 "wait.o"
#pragma merger("0","/tmp/cil-H49kQh7F.i","")
#line 64 "/usr/local/ddv/models/con2/include/linux/wait.h"
__inline void init_waitqueue_head(wait_queue_head_t *q ) ;
#line 73
__inline void wake_up_all(wait_queue_head_t *q ) ;
#line 75
__inline void wake_up_interruptible(wait_queue_head_t *q ) ;
#line 88
__inline void sleep_on(wait_queue_head_t *q ) ;
#line 90
__inline void interruptible_sleep_on(wait_queue_head_t *q ) ;
#line 3 "/usr/local/ddv/models/con2/src/linux/kernel/wait.c"
__inline void init_waitqueue_head(wait_queue_head_t *q ) 
{ 


  {
#line 5
  q->init = 1;
#line 6
  return;
}
}
#line 8 "/usr/local/ddv/models/con2/src/linux/kernel/wait.c"
void wake_up(wait_queue_head_t *q ) 
{ 


  {
#line 14
  return;
}
}
#line 16 "/usr/local/ddv/models/con2/src/linux/kernel/wait.c"
__inline void wake_up_all(wait_queue_head_t *q ) 
{ 


  {
#line 22
  return;
}
}
#line 1 "workqueue.o"
#pragma merger("0","/tmp/cil-4LiFI7XR.i","")
#line 5 "/usr/local/ddv/models/con2/src/linux/kernel/workqueue.c"
int schedule_work(struct work_struct *work ) 
{ 
  int i ;

  {
#line 14
  i = 0;
#line 14
  while (i < 10) {
#line 15
    if ((unsigned long )shared_workqueue[i] == (unsigned long )work) {
#line 16
      return (0);
    }
#line 19
    if ((unsigned long )shared_workqueue[i] == (unsigned long )((void *)0)) {
#line 20
      shared_workqueue[i] = work;
#line 22
      return (1);
    }
#line 14
    i ++;
  }
#line 27
  return (-1);
}
}
#line 30 "/usr/local/ddv/models/con2/src/linux/kernel/workqueue.c"
void call_shared_workqueue_functions(void) 
{ 
  unsigned short i ;
  unsigned short tmp ;

  {
#line 32
  tmp = nondet_ushort();
#line 32
  i = tmp;
#line 33
  __CPROVER_assume((int )i < 10);
#line 35
  if ((unsigned long )shared_workqueue[i] != (unsigned long )((void *)0)) {
#line 36
    (*((shared_workqueue[i])->func))((shared_workqueue[i])->data);
#line 37
    shared_workqueue[i] = (struct work_struct *)((void *)0);
  }
#line 39
  return;
}
}
