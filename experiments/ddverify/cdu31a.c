/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is true */

#line 4 "/usr/local/ddv/models/con2/include/asm/posix_types.h"
typedef unsigned long __kernel_ino_t;
#line 5 "/usr/local/ddv/models/con2/include/asm/posix_types.h"
typedef unsigned short __kernel_mode_t;
#line 12 "/usr/local/ddv/models/con2/include/asm/posix_types.h"
typedef unsigned int __kernel_size_t;
#line 13 "/usr/local/ddv/models/con2/include/asm/posix_types.h"
typedef int __kernel_ssize_t;
#line 4 "/usr/local/ddv/models/con2/include/asm/types.h"
typedef unsigned short umode_t;
#line 13 "/usr/local/ddv/models/con2/include/asm/types.h"
typedef unsigned int __u32;
#line 9 "/usr/local/ddv/models/con2/include/linux/types.h"
typedef __u32 __kernel_dev_t;
#line 11 "/usr/local/ddv/models/con2/include/linux/types.h"
typedef __kernel_dev_t dev_t;
#line 12 "/usr/local/ddv/models/con2/include/linux/types.h"
typedef __kernel_ino_t ino_t;
#line 13 "/usr/local/ddv/models/con2/include/linux/types.h"
typedef __kernel_mode_t mode_t;
#line 30 "/usr/local/ddv/models/con2/include/linux/types.h"
typedef long long loff_t;
#line 38 "/usr/local/ddv/models/con2/include/linux/types.h"
typedef __kernel_size_t size_t;
#line 43 "/usr/local/ddv/models/con2/include/linux/types.h"
typedef __kernel_ssize_t ssize_t;
#line 44 "/usr/local/ddv/models/con2/include/ddverify/satabs.h"
struct __pthread_t_struct {
   int id ;
};
#line 49 "/usr/local/ddv/models/con2/include/ddverify/satabs.h"
struct __pthread_attr_t_struct {
   int dummy ;
};
#line 54 "/usr/local/ddv/models/con2/include/ddverify/satabs.h"
typedef struct __pthread_t_struct pthread_t;
#line 55 "/usr/local/ddv/models/con2/include/ddverify/satabs.h"
typedef struct __pthread_attr_t_struct pthread_attr_t;
#line 6 "/usr/local/ddv/models/con2/include/asm/atomic.h"
typedef int atomic_t;
#line 67 "/usr/local/ddv/models/con2/include/linux/gfp.h"
struct page;
#line 4 "/usr/local/ddv/models/con2/include/linux/dcache.h"
struct inode;
#line 4 "/usr/local/ddv/models/con2/include/linux/dcache.h"
struct dentry {
   struct inode *d_inode ;
};
#line 83 "/usr/local/ddv/models/con2/include/linux/fs.h"
struct iovec;
#line 84
struct poll_table_struct;
#line 85
struct vm_area_struct;
#line 90 "/usr/local/ddv/models/con2/include/linux/fs.h"
struct address_space {
   struct inode *host ;
};
#line 94
struct file_operations;
#line 94 "/usr/local/ddv/models/con2/include/linux/fs.h"
struct file {
   struct dentry *f_dentry ;
   struct file_operations *f_op ;
   atomic_t f_count ;
   unsigned int f_flags ;
   mode_t f_mode ;
   loff_t f_pos ;
   void *private_data ;
   struct address_space *f_mapping ;
};
#line 105
struct gendisk;
#line 105 "/usr/local/ddv/models/con2/include/linux/fs.h"
struct block_device {
   struct inode *bd_inode ;
   struct gendisk *bd_disk ;
   struct block_device *bd_contains ;
   unsigned int bd_block_size ;
};
#line 113
struct cdev;
#line 113 "/usr/local/ddv/models/con2/include/linux/fs.h"
struct inode {
   umode_t i_mode ;
   struct block_device *i_bdev ;
   dev_t i_rdev ;
   loff_t i_size ;
   struct cdev *i_cdev ;
};
#line 122 "/usr/local/ddv/models/con2/include/linux/fs.h"
struct __anonstruct_read_descriptor_t_4 {
   size_t written ;
   size_t count ;
};
#line 122 "/usr/local/ddv/models/con2/include/linux/fs.h"
typedef struct __anonstruct_read_descriptor_t_4 read_descriptor_t;
#line 130 "/usr/local/ddv/models/con2/include/linux/fs.h"
struct file_lock {
   int something ;
};
#line 134
struct module;
#line 134 "/usr/local/ddv/models/con2/include/linux/fs.h"
struct file_operations {
   struct module *owner ;
   loff_t (*llseek)(struct file * , loff_t  , int  ) ;
   ssize_t (*read)(struct file * , char * , size_t  , loff_t * ) ;
   ssize_t (*write)(struct file * , char const   * , size_t  , loff_t * ) ;
   int (*readdir)(struct file * , void * , int (*)(void * , char const   * , int  ,
                                                   loff_t  , ino_t  , unsigned int  ) ) ;
   unsigned int (*poll)(struct file * , struct poll_table_struct * ) ;
   int (*ioctl)(struct inode * , struct file * , unsigned int  , unsigned long  ) ;
   long (*unlocked_ioctl)(struct file * , unsigned int  , unsigned long  ) ;
   long (*compat_ioctl)(struct file * , unsigned int  , unsigned long  ) ;
   int (*mmap)(struct file * , struct vm_area_struct * ) ;
   int (*open)(struct inode * , struct file * ) ;
   int (*flush)(struct file * ) ;
   int (*release)(struct inode * , struct file * ) ;
   int (*fsync)(struct file * , struct dentry * , int datasync ) ;
   int (*fasync)(int  , struct file * , int  ) ;
   int (*lock)(struct file * , int  , struct file_lock * ) ;
   ssize_t (*readv)(struct file * , struct iovec  const  * , unsigned long  , loff_t * ) ;
   ssize_t (*writev)(struct file * , struct iovec  const  * , unsigned long  , loff_t * ) ;
   ssize_t (*sendfile)(struct file * , loff_t * , size_t  , int (*)(read_descriptor_t * ,
                                                                    struct page * ,
                                                                    unsigned long  ,
                                                                    unsigned long  ) ,
                       void * ) ;
   ssize_t (*sendpage)(struct file * , struct page * , int  , size_t  , loff_t * ,
                       int  ) ;
   unsigned long (*get_unmapped_area)(struct file * , unsigned long  , unsigned long  ,
                                      unsigned long  , unsigned long  ) ;
   int (*check_flags)(int  ) ;
   int (*dir_notify)(struct file *filp , unsigned long arg ) ;
   int (*flock)(struct file * , int  , struct file_lock * ) ;
   int (*open_exec)(struct inode * ) ;
};
#line 4 "/usr/local/ddv/models/con2/include/linux/cdev.h"
struct cdev {
   struct module *owner ;
   struct file_operations *ops ;
   dev_t dev ;
   unsigned int count ;
};
#line 13 "/usr/local/ddv/models/con2/include/ddverify/cdev.h"
struct ddv_cdev {
   struct cdev *cdevp ;
   struct file filp ;
   struct inode inode ;
   int open ;
};
#line 30 "/usr/local/ddv/models/con2/include/asm/types.h"
typedef unsigned long long u64;
#line 91 "/usr/local/ddv/models/con2/include/linux/types.h"
typedef unsigned long sector_t;
#line 15 "/usr/local/ddv/models/con2/include/ddverify/pthread.h"
struct __pthread_t_struct___0 {
   int id ;
};
#line 25 "/usr/local/ddv/models/con2/include/ddverify/pthread.h"
struct __pthread_mutex_t_struct {
   _Bool locked ;
};
#line 30 "/usr/local/ddv/models/con2/include/ddverify/pthread.h"
struct __pthread_mutexattr_t_struct {
   int dummy ;
};
#line 50 "/usr/local/ddv/models/con2/include/ddverify/pthread.h"
typedef struct __pthread_t_struct___0 pthread_t___0;
#line 52 "/usr/local/ddv/models/con2/include/ddverify/pthread.h"
typedef struct __pthread_mutex_t_struct pthread_mutex_t;
#line 53 "/usr/local/ddv/models/con2/include/ddverify/pthread.h"
typedef struct __pthread_mutexattr_t_struct pthread_mutexattr_t;
#line 9 "/usr/local/ddv/models/con2/include/linux/list.h"
struct list_head {
   struct list_head *next ;
   struct list_head *prev ;
};
#line 4 "/usr/local/ddv/models/con2/include/linux/spinlock_types.h"
struct __anonstruct_spinlock_t_9 {
   int init ;
   int locked ;
};
#line 4 "/usr/local/ddv/models/con2/include/linux/spinlock_types.h"
typedef struct __anonstruct_spinlock_t_9 spinlock_t;
#line 4 "/usr/local/ddv/models/con2/include/linux/timer.h"
struct timer_list {
   unsigned long expires ;
   void (*function)(unsigned long  ) ;
   unsigned long data ;
   short __ddv_active ;
   short __ddv_init ;
};
#line 82 "/usr/local/ddv/models/con2/include/linux/fs.h"
struct hd_geometry;
#line 168 "/usr/local/ddv/models/con2/include/linux/fs.h"
struct block_device_operations {
   int (*open)(struct inode * , struct file * ) ;
   int (*release)(struct inode * , struct file * ) ;
   int (*ioctl)(struct inode * , struct file * , unsigned int  , unsigned long  ) ;
   long (*unlocked_ioctl)(struct file * , unsigned int  , unsigned long  ) ;
   long (*compat_ioctl)(struct file * , unsigned int  , unsigned long  ) ;
   int (*direct_access)(struct block_device * , sector_t  , unsigned long * ) ;
   int (*media_changed)(struct gendisk * ) ;
   int (*revalidate_disk)(struct gendisk * ) ;
   int (*getgeo)(struct block_device * , struct hd_geometry * ) ;
   struct module *owner ;
};
#line 18 "/usr/local/ddv/models/con2/include/linux/ioport.h"
struct resource {
   char const   *name ;
   unsigned long start ;
   unsigned long end ;
   unsigned long flags ;
};
#line 24 "/usr/local/ddv/models/con2/include/linux/module.h"
struct module {
   int something ;
};
#line 8 "/usr/local/ddv/models/con2/include/linux/pm.h"
struct pm_message {
   int event ;
};
#line 8 "/usr/local/ddv/models/con2/include/linux/pm.h"
typedef struct pm_message pm_message_t;
#line 25 "/usr/local/ddv/models/con2/include/linux/device.h"
struct device {
   void *driver_data ;
   void (*release)(struct device *dev ) ;
};
#line 17 "/usr/local/ddv/models/con2/include/linux/genhd.h"
struct request_queue;
#line 17 "/usr/local/ddv/models/con2/include/linux/genhd.h"
struct gendisk {
   int major ;
   int first_minor ;
   int minors ;
   char disk_name[32] ;
   struct block_device_operations *fops ;
   struct request_queue *queue ;
   void *private_data ;
   int flags ;
   struct device *driverfs_dev ;
   char devfs_name[64] ;
};
#line 12 "/usr/local/ddv/models/con2/include/linux/workqueue.h"
struct work_struct {
   unsigned long pending ;
   void (*func)(void * ) ;
   void *data ;
   int init ;
};
#line 9 "/usr/local/ddv/models/con2/include/linux/mm_types.h"
struct page {
   int something ;
};
#line 4 "/usr/local/ddv/models/con2/include/asm/ptrace.h"
struct pt_regs {
   int something ;
};
#line 28 "/usr/local/ddv/models/con2/include/linux/interrupt.h"
typedef int irqreturn_t;
#line 34 "/usr/local/ddv/models/con2/include/linux/interrupt.h"
struct tasklet_struct {
   atomic_t count ;
   void (*func)(unsigned long  ) ;
   unsigned long data ;
   int init ;
};
#line 11 "/usr/local/ddv/models/con2/include/linux/backing-dev.h"
struct backing_dev_info {
   unsigned long ra_pages ;
   unsigned long state ;
   unsigned int capabilities ;
};
#line 6 "/usr/local/ddv/models/con2/include/linux/bio.h"
struct bio_vec {
   struct page *bv_page ;
   unsigned int bv_len ;
   unsigned int bv_offset ;
};
#line 13
struct bio;
#line 14 "/usr/local/ddv/models/con2/include/linux/bio.h"
typedef int bio_end_io_t(struct bio * , unsigned int  , int  );
#line 17 "/usr/local/ddv/models/con2/include/linux/bio.h"
struct bio {
   sector_t bi_sector ;
   struct bio *bi_next ;
   struct block_device *bi_bdev ;
   unsigned long bi_flags ;
   unsigned long bi_rw ;
   unsigned short bi_vcnt ;
   unsigned short bi_idx ;
   unsigned short bi_phys_segments ;
   unsigned int bi_size ;
   struct bio_vec *bi_io_vec ;
   bio_end_io_t *bi_end_io ;
   void *bi_private ;
};
#line 4 "/usr/local/ddv/models/con2/include/linux/elevator.h"
struct request;
#line 23 "/usr/local/ddv/models/con2/include/linux/blkdev.h"
typedef struct request_queue request_queue_t;
#line 25 "/usr/local/ddv/models/con2/include/linux/blkdev.h"
typedef void request_fn_proc(request_queue_t *q );
#line 26 "/usr/local/ddv/models/con2/include/linux/blkdev.h"
typedef int make_request_fn(request_queue_t *q , struct bio *bio );
#line 27 "/usr/local/ddv/models/con2/include/linux/blkdev.h"
typedef void unplug_fn(request_queue_t * );
#line 32
enum rq_cmd_type_bits {
    REQ_TYPE_FS = 1,
    REQ_TYPE_BLOCK_PC = 2,
    REQ_TYPE_SENSE = 3,
    REQ_TYPE_PM_SUSPEND = 4,
    REQ_TYPE_PM_RESUME = 5,
    REQ_TYPE_PM_SHUTDOWN = 6,
    REQ_TYPE_FLUSH = 7,
    REQ_TYPE_SPECIAL = 8,
    REQ_TYPE_LINUX_BLOCK = 9,
    REQ_TYPE_ATA_CMD = 10,
    REQ_TYPE_ATA_TASK = 11,
    REQ_TYPE_ATA_TASKFILE = 12,
    REQ_TYPE_ATA_PC = 13
} ;
#line 54 "/usr/local/ddv/models/con2/include/linux/blkdev.h"
struct request_queue {
   request_fn_proc *request_fn ;
   make_request_fn *make_request_fn ;
   unplug_fn *unplug_fn ;
   struct backing_dev_info backing_dev_info ;
   void *queuedata ;
   unsigned long queue_flags ;
   spinlock_t *queue_lock ;
   unsigned short hardsect_size ;
   int __ddv_genhd_no ;
   int __ddv_queue_alive ;
};
#line 90 "/usr/local/ddv/models/con2/include/linux/blkdev.h"
struct request {
   struct list_head queuelist ;
   struct list_head donelist ;
   request_queue_t *q ;
   unsigned long flags ;
   unsigned int cmd_flags ;
   enum rq_cmd_type_bits cmd_type ;
   struct bio *bio ;
   void *completion_data ;
   struct gendisk *rq_disk ;
   sector_t sector ;
   unsigned long nr_sectors ;
   unsigned int current_nr_sectors ;
   char *buffer ;
   int errors ;
   unsigned short nr_phys_segments ;
   unsigned char cmd[16] ;
};
#line 15 "/usr/local/ddv/models/con2/include/ddverify/genhd.h"
struct ddv_genhd {
   struct gendisk *gd ;
   struct inode inode ;
   struct file file ;
   struct request current_request ;
   int requests_open ;
};
#line 6 "/usr/local/ddv/models/con2/include/linux/mod_devicetable.h"
typedef unsigned long kernel_ulong_t;
#line 10 "/usr/local/ddv/models/con2/include/linux/mod_devicetable.h"
struct pci_device_id {
   __u32 vendor ;
   __u32 device ;
   __u32 subvendor ;
   __u32 subdevice ;
   __u32 class ;
   __u32 class_mask ;
   kernel_ulong_t driver_data ;
};
#line 40 "/usr/local/ddv/models/con2/include/linux/pci.h"
typedef int pci_power_t;
#line 43
struct pci_bus;
#line 43 "/usr/local/ddv/models/con2/include/linux/pci.h"
struct pci_dev {
   struct pci_bus *bus ;
   unsigned int devfn ;
   unsigned short vendor ;
   unsigned short device ;
   u64 dma_mask ;
   struct device dev ;
   unsigned int irq ;
   struct resource resource[12] ;
};
#line 62 "/usr/local/ddv/models/con2/include/linux/pci.h"
struct pci_bus {
   unsigned char number ;
};
#line 67 "/usr/local/ddv/models/con2/include/linux/pci.h"
struct pci_driver {
   char *name ;
   struct pci_device_id  const  *id_table ;
   int (*probe)(struct pci_dev *dev , struct pci_device_id  const  *id ) ;
   void (*remove)(struct pci_dev *dev ) ;
   int (*suspend)(struct pci_dev *dev , pm_message_t state ) ;
   int (*resume)(struct pci_dev *dev ) ;
   int (*enable_wake)(struct pci_dev *dev , pci_power_t state , int enable ) ;
   void (*shutdown)(struct pci_dev *dev ) ;
};
#line 6 "/usr/local/ddv/models/con2/include/ddverify/pci.h"
struct ddv_pci_driver {
   struct pci_driver *pci_driver ;
   struct pci_dev pci_dev ;
   unsigned int no_pci_device_id ;
   int dev_initialized ;
};
#line 9 "/usr/local/ddv/models/con2/include/ddverify/interrupt.h"
struct registered_irq {
   irqreturn_t (*handler)(int  , void * , struct pt_regs * ) ;
   void *dev_id ;
};
#line 10 "/usr/local/ddv/models/con2/include/ddverify/tasklet.h"
struct ddv_tasklet {
   struct tasklet_struct *tasklet ;
   unsigned short is_running ;
};
#line 10 "/usr/local/ddv/models/con2/include/ddverify/timer.h"
struct ddv_timer {
   struct timer_list *timer ;
};
#line 88 "/usr/local/ddv/models/con2/include/linux/types.h"
typedef unsigned int gfp_t;
#line 8 "/usr/local/ddv/models/con2/include/asm/posix_types.h"
typedef int __kernel_pid_t;
#line 7 "/usr/local/ddv/models/con2/include/asm/types.h"
typedef unsigned char __u8;
#line 16 "/usr/local/ddv/models/con2/include/linux/types.h"
typedef __kernel_pid_t pid_t;
#line 7 "/usr/local/ddv/models/con2/include/asm/current.h"
struct task_struct;
#line 11 "/usr/local/ddv/models/con2/include/linux/wait.h"
struct __wait_queue {
   int something ;
};
#line 14 "/usr/local/ddv/models/con2/include/linux/wait.h"
typedef struct __wait_queue wait_queue_t;
#line 16 "/usr/local/ddv/models/con2/include/linux/wait.h"
struct __wait_queue_head {
   int number_process_waiting ;
   int wakeup ;
   int init ;
};
#line 22 "/usr/local/ddv/models/con2/include/linux/wait.h"
typedef struct __wait_queue_head wait_queue_head_t;
#line 10 "/usr/local/ddv/models/con2/include/asm/signal.h"
struct __anonstruct_sigset_t_3 {
   unsigned long sig[2] ;
};
#line 10 "/usr/local/ddv/models/con2/include/asm/signal.h"
typedef struct __anonstruct_sigset_t_3 sigset_t;
#line 24 "/usr/local/ddv/models/con2/include/linux/sched.h"
struct sighand_struct {
   spinlock_t siglock ;
};
#line 28 "/usr/local/ddv/models/con2/include/linux/sched.h"
struct task_struct {
   long state ;
   pid_t pid ;
   char comm[16] ;
   sigset_t blocked ;
   sigset_t real_blocked ;
   struct sighand_struct *sighand ;
};
#line 4 "/usr/local/ddv/models/con2/include/asm/semaphore.h"
struct semaphore {
   int init ;
   int locked ;
};
#line 4 "/usr/local/ddv/models/con2/include/linux/hdreg.h"
struct hd_geometry {
   unsigned char heads ;
   unsigned char sectors ;
   unsigned short cylinders ;
   unsigned long start ;
};
#line 153 "/usr/local/ddv/models/con2/include/linux/cdrom.h"
struct cdrom_msf0 {
   __u8 minute ;
   __u8 second ;
   __u8 frame ;
};
#line 161 "/usr/local/ddv/models/con2/include/linux/cdrom.h"
union cdrom_addr {
   struct cdrom_msf0 msf ;
   int lba ;
};
#line 179 "/usr/local/ddv/models/con2/include/linux/cdrom.h"
struct cdrom_ti {
   __u8 cdti_trk0 ;
   __u8 cdti_ind0 ;
   __u8 cdti_trk1 ;
   __u8 cdti_ind1 ;
};
#line 188 "/usr/local/ddv/models/con2/include/linux/cdrom.h"
struct cdrom_tochdr {
   __u8 cdth_trk0 ;
   __u8 cdth_trk1 ;
};
#line 195 "/usr/local/ddv/models/con2/include/linux/cdrom.h"
struct cdrom_volctrl {
   __u8 channel0 ;
   __u8 channel1 ;
   __u8 channel2 ;
   __u8 channel3 ;
};
#line 204 "/usr/local/ddv/models/con2/include/linux/cdrom.h"
struct cdrom_subchnl {
   __u8 cdsc_format ;
   __u8 cdsc_audiostatus ;
   __u8 cdsc_adr : 4 ;
   __u8 cdsc_ctrl : 4 ;
   __u8 cdsc_trk ;
   __u8 cdsc_ind ;
   union cdrom_addr cdsc_absaddr ;
   union cdrom_addr cdsc_reladdr ;
};
#line 218 "/usr/local/ddv/models/con2/include/linux/cdrom.h"
struct cdrom_tocentry {
   __u8 cdte_track ;
   __u8 cdte_adr : 4 ;
   __u8 cdte_ctrl : 4 ;
   __u8 cdte_format ;
   union cdrom_addr cdte_addr ;
   __u8 cdte_datamode ;
};
#line 237 "/usr/local/ddv/models/con2/include/linux/cdrom.h"
struct cdrom_read_audio {
   union cdrom_addr addr ;
   __u8 addr_format ;
   int nframes ;
   __u8 *buf ;
};
#line 246 "/usr/local/ddv/models/con2/include/linux/cdrom.h"
struct cdrom_multisession {
   union cdrom_addr addr ;
   __u8 xa_flag ;
   __u8 addr_format ;
};
#line 260 "/usr/local/ddv/models/con2/include/linux/cdrom.h"
struct cdrom_mcn {
   __u8 medium_catalog_number[14] ;
};
#line 280
struct request_sense;
#line 694 "/usr/local/ddv/models/con2/include/linux/cdrom.h"
struct request_sense {
   __u8 error_code : 7 ;
   __u8 valid : 1 ;
   __u8 segment_number ;
   __u8 sense_key : 4 ;
   __u8 reserved2 : 1 ;
   __u8 ili : 1 ;
   __u8 reserved1 : 2 ;
   __u8 information[4] ;
   __u8 add_sense_len ;
   __u8 command_info[4] ;
   __u8 asc ;
   __u8 ascq ;
   __u8 fruc ;
   __u8 sks[3] ;
   __u8 asb[46] ;
};
#line 912 "/usr/local/ddv/models/con2/include/linux/cdrom.h"
struct packet_command {
   unsigned char cmd[12] ;
   unsigned char *buffer ;
   unsigned int buflen ;
   int stat ;
   struct request_sense *sense ;
   unsigned char data_direction ;
   int quiet ;
   int timeout ;
   void *reserved[1] ;
};
#line 933
struct cdrom_device_ops;
#line 933 "/usr/local/ddv/models/con2/include/linux/cdrom.h"
struct cdrom_device_info {
   struct cdrom_device_ops *ops ;
   struct cdrom_device_info *next ;
   struct gendisk *disk ;
   void *handle ;
   int mask ;
   int speed ;
   int capacity ;
   int options : 30 ;
   unsigned int mc_flags : 2 ;
   int use_count ;
   char name[20] ;
   __u8 sanyo_slot : 2 ;
   __u8 reserved : 6 ;
   int cdda_method ;
   __u8 last_sense ;
   __u8 media_written ;
   unsigned short mmc3_profile ;
   int for_data ;
   int (*exit)(struct cdrom_device_info * ) ;
   int mrw_mode_page ;
};
#line 959 "/usr/local/ddv/models/con2/include/linux/cdrom.h"
struct cdrom_device_ops {
   int (*open)(struct cdrom_device_info * , int  ) ;
   void (*release)(struct cdrom_device_info * ) ;
   int (*drive_status)(struct cdrom_device_info * , int  ) ;
   int (*media_changed)(struct cdrom_device_info * , int  ) ;
   int (*tray_move)(struct cdrom_device_info * , int  ) ;
   int (*lock_door)(struct cdrom_device_info * , int  ) ;
   int (*select_speed)(struct cdrom_device_info * , int  ) ;
   int (*select_disc)(struct cdrom_device_info * , int  ) ;
   int (*get_last_session)(struct cdrom_device_info * , struct cdrom_multisession * ) ;
   int (*get_mcn)(struct cdrom_device_info * , struct cdrom_mcn * ) ;
   int (*reset)(struct cdrom_device_info * ) ;
   int (*audio_ioctl)(struct cdrom_device_info * , unsigned int  , void * ) ;
   int (*dev_ioctl)(struct cdrom_device_info * , unsigned int  , unsigned long  ) ;
   int const   capability ;
   int n_minors ;
   int (*generic_packet)(struct cdrom_device_info * , struct packet_command * ) ;
};
#line 170 "cdu31a.h"
struct s_sony_drive_config {
   unsigned char exec_status[2] ;
   char vendor_id[8] ;
   char product_id[16] ;
   char product_rev_level[8] ;
   unsigned char hw_config[2] ;
};
#line 180 "cdu31a.h"
struct s_sony_subcode {
   unsigned char exec_status[2] ;
   unsigned char address : 4 ;
   unsigned char control : 4 ;
   unsigned char track_num ;
   unsigned char index_num ;
   unsigned char rel_msf[3] ;
   unsigned char reserved1 ;
   unsigned char abs_msf[3] ;
};
#line 227 "cdu31a.h"
struct __anonstruct_tracks_14 {
   unsigned char address : 4 ;
   unsigned char control : 4 ;
   unsigned char track ;
   unsigned char track_start_msf[3] ;
};
#line 227 "cdu31a.h"
struct s_sony_session_toc {
   unsigned char exec_status[2] ;
   unsigned char session_number ;
   unsigned char address0 : 4 ;
   unsigned char control0 : 4 ;
   unsigned char point0 ;
   unsigned char first_track_num ;
   unsigned char disk_type ;
   unsigned char dummy0 ;
   unsigned char address1 : 4 ;
   unsigned char control1 : 4 ;
   unsigned char point1 ;
   unsigned char last_track_num ;
   unsigned char dummy1 ;
   unsigned char dummy2 ;
   unsigned char address2 : 4 ;
   unsigned char control2 : 4 ;
   unsigned char point2 ;
   unsigned char lead_out_start_msf[3] ;
   unsigned char addressb0 : 4 ;
   unsigned char controlb0 : 4 ;
   unsigned char pointb0 ;
   unsigned char next_poss_prog_area_msf[3] ;
   unsigned char num_mode_5_pointers ;
   unsigned char max_start_outer_leadout_msf[3] ;
   unsigned char addressb1 : 4 ;
   unsigned char controlb1 : 4 ;
   unsigned char pointb1 ;
   unsigned char dummyb0_1[4] ;
   unsigned char num_skip_interval_pointers ;
   unsigned char num_skip_track_assignments ;
   unsigned char dummyb0_2 ;
   unsigned char addressb2 : 4 ;
   unsigned char controlb2 : 4 ;
   unsigned char pointb2 ;
   unsigned char tracksb2[7] ;
   unsigned char addressb3 : 4 ;
   unsigned char controlb3 : 4 ;
   unsigned char pointb3 ;
   unsigned char tracksb3[7] ;
   unsigned char addressb4 : 4 ;
   unsigned char controlb4 : 4 ;
   unsigned char pointb4 ;
   unsigned char tracksb4[7] ;
   unsigned char addressc0 : 4 ;
   unsigned char controlc0 : 4 ;
   unsigned char pointc0 ;
   unsigned char dummyc0[7] ;
   struct __anonstruct_tracks_14 tracks[100] ;
   unsigned int start_track_lba ;
   unsigned int lead_out_start_lba ;
   unsigned int mint ;
   unsigned int maxt ;
};
#line 290 "cdu31a.h"
struct __anonstruct_tracks_15 {
   unsigned char address : 4 ;
   unsigned char control : 4 ;
   unsigned char track ;
   unsigned char track_start_msf[3] ;
};
#line 290 "cdu31a.h"
struct s_all_sessions_toc {
   unsigned char sessions ;
   unsigned int track_entries ;
   unsigned char first_track_num ;
   unsigned char last_track_num ;
   unsigned char disk_type ;
   unsigned char lead_out_start_msf[3] ;
   struct __anonstruct_tracks_15 tracks[100] ;
   unsigned int start_track_lba ;
   unsigned int lead_out_start_lba ;
};
#line 190 "cdu31a.c"
struct __anonstruct_cdu31a_addresses_16 {
   unsigned short base ;
   short int_num ;
};
#line 34 "/usr/local/ddv/models/con2/include/linux/miscdevice.h"
struct miscdevice {
   int minor ;
   char const   *name ;
   struct file_operations *fops ;
};
#line 7 "/usr/local/ddv/models/con2/include/linux/proc_fs.h"
struct proc_dir_entry {
   int something ;
};
#line 20 "/usr/local/ddv/models/con2/include/linux/mutex.h"
struct mutex {
   int locked ;
   int init ;
};
#line 7 "/usr/local/ddv/models/con2/include/asm/posix_types.h"
typedef long __kernel_off_t;
#line 15 "/usr/local/ddv/models/con2/include/linux/types.h"
typedef __kernel_off_t off_t;
#line 6 "/usr/local/ddv/models/con2/include/asm/termbits.h"
typedef unsigned char cc_t;
#line 8 "/usr/local/ddv/models/con2/include/asm/termbits.h"
typedef unsigned int tcflag_t;
#line 11 "/usr/local/ddv/models/con2/include/asm/termbits.h"
struct termios {
   tcflag_t c_iflag ;
   tcflag_t c_oflag ;
   tcflag_t c_cflag ;
   tcflag_t c_lflag ;
   cc_t c_line ;
   cc_t c_cc[19] ;
};
#line 9 "/usr/local/ddv/models/con2/include/linux/tty_driver.h"
struct tty_struct;
#line 12 "/usr/local/ddv/models/con2/include/linux/tty_driver.h"
struct tty_operations {
   int (*open)(struct tty_struct *tty , struct file *filp ) ;
   void (*close)(struct tty_struct *tty , struct file *filp ) ;
   int (*write)(struct tty_struct *tty , unsigned char const   *buf , int count ) ;
   void (*put_char)(struct tty_struct *tty , unsigned char ch ) ;
   void (*flush_chars)(struct tty_struct *tty ) ;
   int (*write_room)(struct tty_struct *tty ) ;
   int (*chars_in_buffer)(struct tty_struct *tty ) ;
   int (*ioctl)(struct tty_struct *tty , struct file *file , unsigned int cmd , unsigned long arg ) ;
   void (*set_termios)(struct tty_struct *tty , struct termios *old ) ;
   void (*throttle)(struct tty_struct *tty ) ;
   void (*unthrottle)(struct tty_struct *tty ) ;
   void (*stop)(struct tty_struct *tty ) ;
   void (*start)(struct tty_struct *tty ) ;
   void (*hangup)(struct tty_struct *tty ) ;
   void (*break_ctl)(struct tty_struct *tty , int state ) ;
   void (*flush_buffer)(struct tty_struct *tty ) ;
   void (*set_ldisc)(struct tty_struct *tty ) ;
   void (*wait_until_sent)(struct tty_struct *tty , int timeout ) ;
   void (*send_xchar)(struct tty_struct *tty , char ch ) ;
   int (*read_proc)(char *page , char **start , off_t off , int count , int *eof ,
                    void *data ) ;
   int (*write_proc)(struct file *file , char const   *buffer , unsigned long count ,
                     void *data ) ;
   int (*tiocmget)(struct tty_struct *tty , struct file *file ) ;
   int (*tiocmset)(struct tty_struct *tty , struct file *file , unsigned int set ,
                   unsigned int clear ) ;
};
#line 43 "/usr/local/ddv/models/con2/include/linux/tty_driver.h"
struct tty_driver {
   int magic ;
   struct cdev cdev ;
   struct module *owner ;
   char const   *driver_name ;
   char const   *name ;
   int name_base ;
   int major ;
   int minor_start ;
   int minor_num ;
   int num ;
   short type ;
   short subtype ;
   struct termios init_termios ;
   int flags ;
   int refcount ;
   struct proc_dir_entry *proc_entry ;
   int (*open)(struct tty_struct *tty , struct file *filp ) ;
   void (*close)(struct tty_struct *tty , struct file *filp ) ;
   int (*write)(struct tty_struct *tty , unsigned char const   *buf , int count ) ;
   void (*put_char)(struct tty_struct *tty , unsigned char ch ) ;
   void (*flush_chars)(struct tty_struct *tty ) ;
   int (*write_room)(struct tty_struct *tty ) ;
   int (*chars_in_buffer)(struct tty_struct *tty ) ;
   int (*ioctl)(struct tty_struct *tty , struct file *file , unsigned int cmd , unsigned long arg ) ;
   void (*set_termios)(struct tty_struct *tty , struct termios *old ) ;
   void (*throttle)(struct tty_struct *tty ) ;
   void (*unthrottle)(struct tty_struct *tty ) ;
   void (*stop)(struct tty_struct *tty ) ;
   void (*start)(struct tty_struct *tty ) ;
   void (*hangup)(struct tty_struct *tty ) ;
   void (*break_ctl)(struct tty_struct *tty , int state ) ;
   void (*flush_buffer)(struct tty_struct *tty ) ;
   void (*set_ldisc)(struct tty_struct *tty ) ;
   void (*wait_until_sent)(struct tty_struct *tty , int timeout ) ;
   void (*send_xchar)(struct tty_struct *tty , char ch ) ;
   int (*read_proc)(char *page , char **start , off_t off , int count , int *eof ,
                    void *data ) ;
   int (*write_proc)(struct file *file , char const   *buffer , unsigned long count ,
                     void *data ) ;
   int (*tiocmget)(struct tty_struct *tty , struct file *file ) ;
   int (*tiocmset)(struct tty_struct *tty , struct file *file , unsigned int set ,
                   unsigned int clear ) ;
};
#line 113 "/usr/local/ddv/models/con2/include/linux/tty.h"
struct tty_struct {
   int magic ;
   struct tty_driver *driver ;
   int index ;
   struct termios *termios ;
   struct termios *termios_locked ;
   char name[64] ;
   unsigned long flags ;
   int count ;
   unsigned char stopped : 1 ;
   unsigned char hw_stopped : 1 ;
   unsigned char flow_stopped : 1 ;
   unsigned char packet : 1 ;
   unsigned int receive_room ;
   wait_queue_head_t write_wait ;
   wait_queue_head_t read_wait ;
   void *disc_data ;
   void *driver_data ;
   unsigned char closing : 1 ;
};
#line 7 "/usr/local/ddv/models/con2/include/ddverify/tty.h"
struct ddv_tty_driver {
   struct tty_driver driver ;
   unsigned short allocated ;
   unsigned short registered ;
};
#line 1 "cdev.o"
#pragma merger("0","/tmp/cil-_7nNmTmA.i","")
#line 11 "/usr/local/ddv/models/con2/include/ddverify/ddverify.h"
int current_execution_context  ;
#line 42 "/usr/local/ddv/models/con2/include/ddverify/ddverify.h"
int (*_ddv_module_init)(void)  ;
#line 43 "/usr/local/ddv/models/con2/include/ddverify/ddverify.h"
void (*_ddv_module_exit)(void)  ;
#line 15 "/usr/local/ddv/models/con2/include/ddverify/satabs.h"
extern unsigned short nondet_ushort() ;
#line 16
extern int nondet_int() ;
#line 17
extern unsigned int nondet_uint() ;
#line 19
extern unsigned long nondet_ulong() ;
#line 20
extern char nondet_char() ;
#line 23
extern loff_t nondet_loff_t() ;
#line 24
extern size_t nondet_size_t() ;
#line 57
extern pthread_t nondet_pthread_t() ;
#line 59 "/usr/local/ddv/models/con2/include/ddverify/satabs.h"
__inline extern int pthread_create(pthread_t *__threadp , pthread_attr_t const   *__attr ,
                                   void *(*__start_routine)(void * ) , void *__arg ) 
{ 


  {
#line 65
  *__threadp = nondet_pthread_t();
#line 66
  (*__start_routine)(__arg);
#line 67
  return (0);
}
}
#line 7 "/usr/local/ddv/models/con2/include/linux/jiffies.h"
unsigned long jiffies  ;
#line 12 "/usr/local/ddv/models/con2/include/ddverify/fixed_cdev.h"
struct cdev fixed_cdev[10]  ;
#line 13 "/usr/local/ddv/models/con2/include/ddverify/fixed_cdev.h"
int fixed_cdev_used  =    0;
#line 11 "/usr/local/ddv/models/con2/include/ddverify/cdev.h"
short number_cdev_registered  =    (short)0;
#line 22 "/usr/local/ddv/models/con2/include/ddverify/cdev.h"
struct ddv_cdev cdev_registered[10]  ;
#line 24
void call_cdev_functions(void) ;
#line 21 "/usr/local/ddv/models/con2/src/ddverify/cdev.c"
extern int ( /* missing proto */  __CPROVER_assume)() ;
#line 5 "/usr/local/ddv/models/con2/src/ddverify/cdev.c"
void call_cdev_functions(void) 
{ 
  int cdev_no ;
  int result ;
  loff_t loff_t_value ;
  int int_value ;
  unsigned int uint_value ;
  unsigned long ulong_value ;
  char char_value ;
  size_t size_t_value ;
  unsigned short tmp ;
  int tmp___0 ;
  unsigned short tmp___1 ;

  {
#line 16
  if ((int )number_cdev_registered == 0) {
#line 17
    return;
  }
#line 20
  tmp = nondet_ushort();
#line 20
  cdev_no = (int )tmp;
#line 21
  if (0 <= cdev_no) {
#line 21
    if (cdev_no < (int )number_cdev_registered) {
#line 21
      tmp___0 = 1;
    } else {
#line 21
      tmp___0 = 0;
    }
  } else {
#line 21
    tmp___0 = 0;
  }
#line 21
  __CPROVER_assume(tmp___0);
#line 23
  tmp___1 = nondet_ushort();
#line 23
  switch ((int )tmp___1) {
  case 0: 
#line 25
  if (((cdev_registered[cdev_no].cdevp)->ops)->llseek) {
#line 26
    loff_t_value = nondet_loff_t();
#line 27
    int_value = nondet_int();
#line 29
    (*(((cdev_registered[cdev_no].cdevp)->ops)->llseek))(& cdev_registered[cdev_no].filp,
                                                         loff_t_value, int_value);
  }
#line 33
  break;
  case 1: 
#line 35
  if (((cdev_registered[cdev_no].cdevp)->ops)->read) {
#line 36
    char_value = nondet_char();
#line 37
    size_t_value = nondet_size_t();
#line 39
    (*(((cdev_registered[cdev_no].cdevp)->ops)->read))(& cdev_registered[cdev_no].filp,
                                                       & char_value, size_t_value,
                                                       & loff_t_value);
  }
#line 44
  break;
  case 2: 
#line 47
  break;
  case 3: 
#line 49
  if (((cdev_registered[cdev_no].cdevp)->ops)->write) {
#line 50
    char_value = nondet_char();
#line 51
    size_t_value = nondet_size_t();
#line 53
    (*(((cdev_registered[cdev_no].cdevp)->ops)->write))(& cdev_registered[cdev_no].filp,
                                                        (char const   *)(& char_value),
                                                        size_t_value, & loff_t_value);
  }
#line 58
  break;
  case 4: 
#line 61
  break;
  case 5: 
#line 64
  break;
  case 6: 
#line 67
  break;
  case 7: 
#line 69
  if (((cdev_registered[cdev_no].cdevp)->ops)->ioctl) {
#line 70
    uint_value = nondet_uint();
#line 71
    ulong_value = nondet_ulong();
#line 73
    (*(((cdev_registered[cdev_no].cdevp)->ops)->ioctl))(& cdev_registered[cdev_no].inode,
                                                        & cdev_registered[cdev_no].filp,
                                                        uint_value, ulong_value);
  }
#line 79
  break;
  case 8: 
#line 82
  break;
  case 9: 
#line 85
  break;
  case 10: 
#line 88
  break;
  case 11: 
#line 90
  if (((cdev_registered[cdev_no].cdevp)->ops)->open) {
#line 90
    if (! cdev_registered[cdev_no].open) {
#line 92
      result = (*(((cdev_registered[cdev_no].cdevp)->ops)->open))(& cdev_registered[cdev_no].inode,
                                                                  & cdev_registered[cdev_no].filp);
#line 95
      if (! result) {
#line 96
        cdev_registered[cdev_no].open = 1;
      }
    }
  }
#line 99
  break;
  case 12: 
#line 102
  break;
  case 13: 
#line 104
  if (((cdev_registered[cdev_no].cdevp)->ops)->release) {
#line 104
    if (cdev_registered[cdev_no].open) {
#line 106
      result = (*(((cdev_registered[cdev_no].cdevp)->ops)->release))(& cdev_registered[cdev_no].inode,
                                                                     & cdev_registered[cdev_no].filp);
#line 109
      if (! result) {
#line 110
        cdev_registered[cdev_no].open = 0;
      }
    }
  }
#line 113
  break;
  case 14: 
#line 116
  break;
  case 15: 
#line 119
  break;
  case 16: 
#line 122
  break;
  case 17: 
#line 125
  break;
  case 18: 
#line 128
  break;
  case 19: 
#line 131
  break;
  case 20: 
#line 134
  break;
  case 21: 
#line 137
  break;
  case 22: 
#line 140
  break;
  case 23: 
#line 143
  break;
  case 24: 
#line 146
  break;
  case 25: 
#line 149
  break;
  case 26: 
#line 152
  break;
  default: 
#line 154
  break;
  }
#line 156
  return;
}
}
#line 1 "char_dev.o"
#pragma merger("0","/tmp/cil-ly8eCo8J.i","")
#line 8 "/usr/local/ddv/models/con2/include/linux/slab.h"
extern void kfree(void const   * ) ;
#line 195 "/usr/local/ddv/models/con2/include/linux/fs.h"
__inline int alloc_chrdev_region(dev_t *dev , unsigned int baseminor , unsigned int count ,
                                 char const   *name ) ;
#line 196
__inline int register_chrdev_region(dev_t from , unsigned int count , char const   *name ) ;
#line 199
__inline int register_chrdev(unsigned int major , char const   *name , struct file_operations *fops ) ;
#line 200
__inline int unregister_chrdev(unsigned int major , char const   *name ) ;
#line 11 "/usr/local/ddv/models/con2/include/linux/cdev.h"
__inline void cdev_init(struct cdev *cdev , struct file_operations *fops ) ;
#line 13
__inline struct cdev *cdev_alloc(void) ;
#line 17
__inline int cdev_add(struct cdev *p , dev_t dev , unsigned int count ) ;
#line 19
__inline void cdev_del(struct cdev *p ) ;
#line 9 "/usr/local/ddv/models/con2/src/linux/fs/char_dev.c"
__inline int alloc_chrdev_region(dev_t *dev , unsigned int baseminor , unsigned int count ,
                                 char const   *name ) 
{ 
  int major ;
  int return_value ;
  int tmp ;
  int tmp___0 ;
  unsigned int tmp___1 ;

  {
#line 12
  tmp = nondet_int();
#line 12
  return_value = tmp;
#line 13
  if (return_value == 0) {
#line 13
    tmp___0 = 1;
  } else
#line 13
  if (return_value == -1) {
#line 13
    tmp___0 = 1;
  } else {
#line 13
    tmp___0 = 0;
  }
#line 13
  __CPROVER_assume(tmp___0);
#line 15
  if (return_value == 0) {
#line 16
    tmp___1 = nondet_uint();
#line 16
    major = (int )tmp___1;
#line 17
    *dev = (unsigned int )(major << 20) | baseminor;
  }
#line 20
  return (return_value);
}
}
#line 23 "/usr/local/ddv/models/con2/src/linux/fs/char_dev.c"
__inline int register_chrdev_region(dev_t from , unsigned int count , char const   *name ) 
{ 
  int return_value ;
  int tmp ;
  int tmp___0 ;

  {
#line 25
  tmp = nondet_int();
#line 25
  return_value = tmp;
#line 26
  if (return_value == 0) {
#line 26
    tmp___0 = 1;
  } else
#line 26
  if (return_value == -1) {
#line 26
    tmp___0 = 1;
  } else {
#line 26
    tmp___0 = 0;
  }
#line 26
  __CPROVER_assume(tmp___0);
#line 28
  return (return_value);
}
}
#line 33 "/usr/local/ddv/models/con2/src/linux/fs/char_dev.c"
__inline int register_chrdev(unsigned int major , char const   *name , struct file_operations *fops ) 
{ 
  struct cdev *cdev ;
  int err ;
  int tmp ;

  {
#line 39
  tmp = register_chrdev_region((dev_t )0, 256U, name);
#line 39
  major = (unsigned int )tmp;
#line 41
  cdev = cdev_alloc();
#line 42
  cdev->owner = fops->owner;
#line 43
  cdev->ops = fops;
#line 45
  err = cdev_add(cdev, major << 20, 256U);
#line 47
  if (err) {
#line 48
    kfree((void const   *)cdev);
#line 49
    return (err);
  }
#line 52
  return ((int )major);
}
}
#line 55 "/usr/local/ddv/models/con2/src/linux/fs/char_dev.c"
__inline int unregister_chrdev(unsigned int major , char const   *name ) 
{ 


  {
#line 57
  return (0);
}
}
#line 60 "/usr/local/ddv/models/con2/src/linux/fs/char_dev.c"
__inline struct cdev *cdev_alloc(void) 
{ 
  int tmp ;

  {
#line 62
  if (fixed_cdev_used < 10) {
#line 63
    tmp = fixed_cdev_used;
#line 63
    fixed_cdev_used ++;
#line 63
    return (& fixed_cdev[tmp]);
  }
#line 65
  return ((struct cdev *)0);
}
}
#line 67 "/usr/local/ddv/models/con2/src/linux/fs/char_dev.c"
__inline void cdev_init(struct cdev *cdev , struct file_operations *fops ) 
{ 


  {
#line 69
  cdev->ops = fops;
#line 70
  return;
}
}
#line 72 "/usr/local/ddv/models/con2/src/linux/fs/char_dev.c"
__inline int cdev_add(struct cdev *p , dev_t dev , unsigned int count ) 
{ 
  int return_value ;
  int tmp ;
  int tmp___0 ;

  {
#line 74
  p->dev = dev;
#line 75
  p->count = count;
#line 77
  tmp = nondet_int();
#line 77
  return_value = tmp;
#line 78
  if (return_value == 0) {
#line 78
    tmp___0 = 1;
  } else
#line 78
  if (return_value == -1) {
#line 78
    tmp___0 = 1;
  } else {
#line 78
    tmp___0 = 0;
  }
#line 78
  __CPROVER_assume(tmp___0);
#line 80
  if (return_value == 0) {
#line 81
    if ((int )number_cdev_registered < 10) {
#line 83
      cdev_registered[number_cdev_registered].cdevp = p;
#line 84
      cdev_registered[number_cdev_registered].inode.i_rdev = dev;
#line 85
      cdev_registered[number_cdev_registered].inode.i_cdev = p;
#line 86
      cdev_registered[number_cdev_registered].open = 0;
#line 88
      number_cdev_registered = (short )((int )number_cdev_registered + 1);
    } else {
#line 90
      return (-1);
    }
  }
#line 94
  return (return_value);
}
}
#line 97 "/usr/local/ddv/models/con2/src/linux/fs/char_dev.c"
__inline void cdev_del(struct cdev *p ) 
{ 
  int i ;

  {
#line 101
  i = 0;
#line 101
  while (i < (int )number_cdev_registered) {
#line 102
    if ((unsigned long )cdev_registered[i].cdevp == (unsigned long )p) {
#line 103
      cdev_registered[i].cdevp = (struct cdev *)0;
#line 105
      return;
    }
#line 101
    i ++;
  }
#line 108
  return;
}
}
#line 1 "ddverify.o"
#pragma merger("0","/tmp/cil-bj2uambR.i","")
#line 45 "/usr/local/ddv/models/con2/include/ddverify/ddverify.h"
int call_ddv(void) ;
#line 39 "/usr/local/ddv/models/con2/include/ddverify/satabs.h"
extern void __CPROVER_atomic_begin() ;
#line 40
extern void __CPROVER_atomic_end() ;
#line 186 "/usr/local/ddv/models/con2/include/ddverify/pthread.h"
__inline extern int pthread_mutex_init(pthread_mutex_t *__mutex , pthread_mutexattr_t const   *__mutex_attr ) 
{ 
  pthread_mutex_t i ;

  {
#line 190
  i.locked = (_Bool)0;
#line 191
  *__mutex = i;
#line 192
  return (0);
}
}
#line 194 "/usr/local/ddv/models/con2/include/ddverify/pthread.h"
__inline extern int pthread_mutex_destroy(pthread_mutex_t *__mutex ) 
{ 


  {
#line 196
  return (0);
}
}
#line 203 "/usr/local/ddv/models/con2/include/ddverify/pthread.h"
__inline extern int pthread_mutex_lock(pthread_mutex_t *__mutex ) 
{ 


  {
#line 206
  __CPROVER_atomic_begin();
#line 207
  __CPROVER_assume(! __mutex->locked);
#line 208
  __mutex->locked = (_Bool)1;
#line 209
  __CPROVER_atomic_end();
#line 210
  return (0);
}
}
#line 216
extern int ( /* missing proto */  __CPROVER_assert)() ;
#line 213 "/usr/local/ddv/models/con2/include/ddverify/pthread.h"
__inline extern int pthread_mutex_unlock(pthread_mutex_t *__mutex ) 
{ 


  {
#line 216
  __CPROVER_assert((int )__mutex->locked, "pthread_mutex_unlock without lock");
#line 217
  __mutex->locked = (_Bool)0;
#line 218
  return (0);
}
}
#line 9 "/usr/local/ddv/models/con2/include/linux/spinlock.h"
void spin_lock_init(spinlock_t *lock ) ;
#line 12 "/usr/local/ddv/models/con2/include/ddverify/genhd.h"
short number_genhd_registered  =    (short)0;
#line 13 "/usr/local/ddv/models/con2/include/ddverify/genhd.h"
short number_fixed_genhd_used  =    (short)0;
#line 24 "/usr/local/ddv/models/con2/include/ddverify/genhd.h"
struct gendisk fixed_gendisk[10]  ;
#line 25 "/usr/local/ddv/models/con2/include/ddverify/genhd.h"
struct ddv_genhd genhd_registered[10]  ;
#line 14 "/usr/local/ddv/models/con2/include/ddverify/pci.h"
struct ddv_pci_driver registered_pci_driver  ;
#line 19
extern void call_pci_functions() ;
#line 14 "/usr/local/ddv/models/con2/include/ddverify/interrupt.h"
struct registered_irq registered_irq[16]  ;
#line 16
void call_interrupt_handler(void) ;
#line 8 "/usr/local/ddv/models/con2/include/ddverify/tasklet.h"
short number_tasklet_registered  =    (short)0;
#line 15 "/usr/local/ddv/models/con2/include/ddverify/tasklet.h"
struct ddv_tasklet tasklet_registered[10]  ;
#line 17
void call_tasklet_functions(void) ;
#line 8 "/usr/local/ddv/models/con2/include/ddverify/timer.h"
short number_timer_registered  =    (short)0;
#line 14 "/usr/local/ddv/models/con2/include/ddverify/timer.h"
struct ddv_timer timer_registered[5]  ;
#line 16
extern void call_timer_functions() ;
#line 8 "/usr/local/ddv/models/con2/include/ddverify/workqueue.h"
struct work_struct *shared_workqueue[10]  ;
#line 10
void call_shared_workqueue_functions(void) ;
#line 7 "/usr/local/ddv/models/con2/include/linux/smp_lock.h"
spinlock_t kernel_lock  ;
#line 15 "/usr/local/ddv/models/con2/src/ddverify/ddverify.c"
void init_kernel(void) 
{ 
  int i ;

  {
#line 19
  spin_lock_init(& kernel_lock);
#line 21
  i = 0;
#line 21
  while (i < 10) {
#line 22
    shared_workqueue[i] = (struct work_struct *)((void *)0);
#line 21
    i ++;
  }
#line 25
  i = 0;
#line 25
  while (i < 10) {
#line 26
    tasklet_registered[i].tasklet = (struct tasklet_struct *)((void *)0);
#line 27
    tasklet_registered[i].is_running = (unsigned short)0;
#line 25
    i ++;
  }
#line 29
  return;
}
}
#line 31 "/usr/local/ddv/models/con2/src/ddverify/ddverify.c"
static void *ddv_2(void *arg ) 
{ 
  unsigned short random ;

  {
#line 35
  while (1) {
#line 36
    random = nondet_ushort();
#line 38
    switch ((int )random) {
    case 1: 
#line 40
    current_execution_context = 2;
#line 41
    call_timer_functions();
#line 42
    current_execution_context = 1;
#line 43
    break;
    case 2: 
#line 46
    current_execution_context = 2;
#line 47
    call_interrupt_handler();
#line 48
    current_execution_context = 1;
#line 49
    break;
    case 3: 
#line 52
    current_execution_context = 1;
#line 53
    call_shared_workqueue_functions();
#line 54
    current_execution_context = 1;
#line 55
    break;
    case 4: 
#line 58
    current_execution_context = 2;
#line 59
    call_tasklet_functions();
#line 60
    current_execution_context = 1;
#line 61
    break;
    case 5: 
#line 64
    current_execution_context = 1;
#line 65
    call_pci_functions();
#line 66
    current_execution_context = 1;
#line 67
    break;
    default: 
#line 70
    break;
    }
#line 35
    if (! random) {
#line 35
      break;
    }
  }
#line 73
  return ((void *)0);
}
}
#line 75 "/usr/local/ddv/models/con2/src/ddverify/ddverify.c"
void ddv(void) 
{ 
  pthread_t___0 thread ;
  int tmp ;

  {
#line 81
  pthread_create((struct __pthread_t_struct *)(& thread), (struct __pthread_attr_t_struct  const  *)((void *)0),
                 & ddv_2, (void *)0);
#line 83
  while (1) {
#line 84
    current_execution_context = 1;
#line 86
    call_cdev_functions();
#line 83
    tmp = nondet_int();
#line 83
    if (! tmp) {
#line 83
      break;
    }
  }
#line 93
  return;
}
}
#line 95 "/usr/local/ddv/models/con2/src/ddverify/ddverify.c"
int call_ddv(void) 
{ 
  int err ;

  {
#line 99
  current_execution_context = 1;
#line 101
  init_kernel();
#line 103
  err = (*_ddv_module_init)();
#line 105
  if (err) {
#line 106
    return (-1);
  }
#line 110
  ddv();
#line 112
  current_execution_context = 1;
#line 113
  (*_ddv_module_exit)();
#line 115
  return (0);
}
}
#line 1 "genhd.o"
#pragma merger("0","/tmp/cil-rZZToN9n.i","")
#line 9 "/usr/local/ddv/models/con2/include/ddverify/satabs.h"
extern void *malloc(size_t size ) ;
#line 207 "/usr/local/ddv/models/con2/include/linux/fs.h"
int register_blkdev(unsigned int major , char const   *name ) ;
#line 208
int unregister_blkdev(unsigned int major , char const   *name ) ;
#line 33 "/usr/local/ddv/models/con2/include/linux/genhd.h"
void add_disk(struct gendisk *disk ) ;
#line 35
void del_gendisk(struct gendisk *gp ) ;
#line 37
struct gendisk *alloc_disk(int minors ) ;
#line 6 "/usr/local/ddv/models/con2/src/linux/block/genhd.c"
int register_blkdev(unsigned int major , char const   *name ) 
{ 
  int result ;
  int tmp ;

  {
#line 8
  tmp = nondet_int();
#line 8
  result = tmp;
#line 14
  return (result);
}
}
#line 17 "/usr/local/ddv/models/con2/src/linux/block/genhd.c"
int unregister_blkdev(unsigned int major , char const   *name ) 
{ 


  {
#line 19
  return (0);
}
}
#line 22 "/usr/local/ddv/models/con2/src/linux/block/genhd.c"
struct gendisk *alloc_disk(int minors ) 
{ 
  struct gendisk *gd ;

  {
#line 26
  if ((int )number_fixed_genhd_used < 10) {
#line 27
    gd = & fixed_gendisk[number_fixed_genhd_used];
#line 28
    gd->minors = minors;
#line 30
    number_fixed_genhd_used = (short )((int )number_fixed_genhd_used + 1);
#line 32
    return (gd);
  } else {
#line 34
    return ((struct gendisk *)((void *)0));
  }
}
}
#line 38 "/usr/local/ddv/models/con2/src/linux/block/genhd.c"
void add_disk(struct gendisk *disk ) 
{ 
  void *tmp ;

  {
#line 40
  if ((int )number_genhd_registered < 10) {
#line 41
    genhd_registered[number_genhd_registered].gd = disk;
#line 42
    tmp = malloc((size_t )sizeof(struct block_device ));
#line 42
    genhd_registered[number_genhd_registered].inode.i_bdev = (struct block_device *)tmp;
#line 43
    (genhd_registered[number_genhd_registered].inode.i_bdev)->bd_disk = disk;
#line 45
    number_genhd_registered = (short )((int )number_genhd_registered + 1);
  }
#line 47
  return;
}
}
#line 49 "/usr/local/ddv/models/con2/src/linux/block/genhd.c"
void del_gendisk(struct gendisk *gp ) 
{ 
  int i ;

  {
#line 53
  i = 0;
#line 53
  while (i < (int )number_genhd_registered) {
#line 54
    if ((unsigned long )genhd_registered[i].gd == (unsigned long )gp) {
#line 55
      genhd_registered[i].gd = (struct gendisk *)((void *)0);
    }
#line 53
    i ++;
  }
#line 58
  return;
}
}
#line 1 "interrupt.o"
#pragma merger("0","/tmp/cil-hWfrjtlm.i","")
#line 10 "/usr/local/ddv/models/con2/src/ddverify/interrupt.c"
void call_interrupt_handler(void) 
{ 
  unsigned short i ;
  struct pt_regs regs ;
  int tmp ;

  {
#line 15
  tmp = nondet_int();
#line 15
  i = (unsigned short )tmp;
#line 16
  __CPROVER_assume((int )i < 16);
#line 18
  if (registered_irq[i].handler) {
#line 19
    (*(registered_irq[i].handler))((int )i, registered_irq[i].dev_id, & regs);
  }
#line 22
  return;
}
}
#line 1 "ioctl.o"
#pragma merger("0","/tmp/cil-a1MiuK_K.i","")
#line 1 "ll_rw_blk.o"
#pragma merger("0","/tmp/cil-mg60nJbW.i","")
#line 192 "/usr/local/ddv/models/con2/include/linux/blkdev.h"
request_queue_t *blk_alloc_queue(gfp_t gfp_mask ) ;
#line 194
request_queue_t *blk_init_queue(request_fn_proc *rfn , spinlock_t *lock ) ;
#line 196
void blk_queue_make_request(request_queue_t *q , make_request_fn *mfn ) ;
#line 198
void blk_queue_hardsect_size(request_queue_t *q , unsigned short size ) ;
#line 200
void blk_cleanup_queue(request_queue_t *q ) ;
#line 220
void end_request(struct request *req , int uptodate ) ;
#line 6 "/usr/local/ddv/models/con2/include/ddverify/blkdev.h"
request_queue_t fixed_request_queue[10]  ;
#line 8 "/usr/local/ddv/models/con2/include/ddverify/blkdev.h"
int number_request_queue_used  =    0;
#line 7 "/usr/local/ddv/models/con2/src/linux/block/ll_rw_blk.c"
request_queue_t *get_fixed_request_queue(void) 
{ 
  int tmp ;

  {
#line 9
  if (number_request_queue_used < 10) {
#line 10
    tmp = number_request_queue_used;
#line 10
    number_request_queue_used ++;
#line 10
    return (& fixed_request_queue[tmp]);
  } else {
#line 12
    return ((request_queue_t *)((void *)0));
  }
}
}
#line 16 "/usr/local/ddv/models/con2/src/linux/block/ll_rw_blk.c"
request_queue_t *blk_init_queue(request_fn_proc *rfn , spinlock_t *lock ) 
{ 
  request_queue_t *queue ;
  int tmp ;

  {
#line 20
  tmp = nondet_int();
#line 20
  if (tmp) {
#line 21
    queue = get_fixed_request_queue();
#line 23
    queue->queue_lock = lock;
#line 24
    queue->request_fn = rfn;
#line 25
    queue->make_request_fn = (make_request_fn *)((void *)0);
#line 26
    queue->__ddv_queue_alive = 1;
#line 28
    return (queue);
  } else {
#line 30
    return ((request_queue_t *)((void *)0));
  }
}
}
#line 34 "/usr/local/ddv/models/con2/src/linux/block/ll_rw_blk.c"
request_queue_t *blk_alloc_queue(gfp_t gfp_mask ) 
{ 
  request_queue_t *queue ;
  int tmp ;

  {
#line 38
  tmp = nondet_int();
#line 38
  if (tmp) {
#line 39
    queue = get_fixed_request_queue();
#line 41
    queue->request_fn = (request_fn_proc *)((void *)0);
#line 42
    queue->make_request_fn = (make_request_fn *)((void *)0);
#line 43
    queue->__ddv_queue_alive = 1;
#line 45
    return (queue);
  } else {
#line 47
    return ((request_queue_t *)((void *)0));
  }
}
}
#line 51 "/usr/local/ddv/models/con2/src/linux/block/ll_rw_blk.c"
void blk_queue_make_request(request_queue_t *q , make_request_fn *mfn ) 
{ 


  {
#line 53
  q->make_request_fn = mfn;
#line 54
  return;
}
}
#line 56 "/usr/local/ddv/models/con2/src/linux/block/ll_rw_blk.c"
void end_request(struct request *req , int uptodate ) 
{ 
  int genhd_no ;

  {
#line 58
  genhd_no = ((req->rq_disk)->queue)->__ddv_genhd_no;
#line 60
  genhd_registered[genhd_no].requests_open = 0;
#line 61
  return;
}
}
#line 64 "/usr/local/ddv/models/con2/src/linux/block/ll_rw_blk.c"
void blk_queue_hardsect_size(request_queue_t *q , unsigned short size ) 
{ 


  {
#line 66
  q->hardsect_size = size;
#line 67
  return;
}
}
#line 69 "/usr/local/ddv/models/con2/src/linux/block/ll_rw_blk.c"
void blk_cleanup_queue(request_queue_t *q ) 
{ 


  {
#line 71
  q->__ddv_queue_alive = 0;
#line 72
  return;
}
}
#line 1 "__main.o"
#pragma merger("0","/tmp/cil-DvHgsI24.i","")
#line 26 "/usr/local/ddv/models/con2/include/linux/timer.h"
void init_timer(struct timer_list *timer ) ;
#line 28
void add_timer(struct timer_list *timer ) ;
#line 29
int del_timer(struct timer_list *timer ) ;
#line 12 "/usr/local/ddv/models/con2/include/linux/spinlock.h"
void spin_lock_irq(spinlock_t *lock ) ;
#line 17
void spin_unlock_irq(spinlock_t *lock ) ;
#line 9 "/usr/local/ddv/models/con2/include/asm/current.h"
extern struct task_struct *get_current(void) ;
#line 66 "/usr/local/ddv/models/con2/include/linux/wait.h"
extern void prepare_to_wait(wait_queue_head_t *q , wait_queue_t *wait , int state ) ;
#line 68
extern void finish_wait(wait_queue_head_t *q , wait_queue_t *wait ) ;
#line 75
void wake_up_interruptible(wait_queue_head_t *q ) ;
#line 85
extern int waitqueue_active(wait_queue_head_t *q ) ;
#line 4 "/usr/local/ddv/models/con2/include/asm/string.h"
extern void *memset(void *s , int c , unsigned int n ) ;
#line 11 "/usr/local/ddv/models/con2/include/linux/string.h"
extern char *strcat(char * , char const   * ) ;
#line 31
extern void *memmove(void * , void const   * , __kernel_size_t  ) ;
#line 40 "/usr/local/ddv/models/con2/include/linux/sched.h"
extern int signal_pending(struct task_struct *p ) ;
#line 43
void schedule(void) ;
#line 53
extern void yield(void) ;
#line 34 "/usr/local/ddv/models/con2/include/linux/kernel.h"
extern int printk(char const   *fmt  , ...) ;
#line 35
extern int sprintf(char *buf , char const   *fmt  , ...) ;
#line 31 "/usr/local/ddv/models/con2/include/asm/semaphore.h"
int down_interruptible(struct semaphore *sem ) ;
#line 33
int down_trylock(struct semaphore *sem ) ;
#line 35
void up(struct semaphore *sem ) ;
#line 90 "/usr/local/ddv/models/con2/include/linux/ioport.h"
struct resource *request_region(unsigned long start , unsigned long len , char const   *name ) ;
#line 92
void release_region(unsigned long start , unsigned long len ) ;
#line 39 "/usr/local/ddv/models/con2/include/linux/genhd.h"
extern void put_disk(struct gendisk *disk ) ;
#line 75 "/usr/local/ddv/models/con2/include/linux/interrupt.h"
int request_irq(unsigned int irq , irqreturn_t (*handler)(int  , void * , struct pt_regs * ) ,
                unsigned long irqflags , char const   *devname , void *dev_id ) ;
#line 78
void free_irq(unsigned int irq , void *dev_id ) ;
#line 989 "/usr/local/ddv/models/con2/include/linux/cdrom.h"
extern int cdrom_open(struct cdrom_device_info *cdi , struct inode *ip , struct file *fp ) ;
#line 991
extern int cdrom_release(struct cdrom_device_info *cdi , struct file *fp ) ;
#line 992
extern int cdrom_ioctl(struct file *file , struct cdrom_device_info *cdi , struct inode *ip ,
                       unsigned int cmd , unsigned long arg ) ;
#line 994
extern int cdrom_media_changed(struct cdrom_device_info * ) ;
#line 996
extern int register_cdrom(struct cdrom_device_info *cdi ) ;
#line 997
extern int unregister_cdrom(struct cdrom_device_info *cdi ) ;
#line 14 "/usr/local/ddv/models/con2/include/asm/io.h"
unsigned char inb(unsigned int port ) ;
#line 15
void outb(unsigned char byte , unsigned int port ) ;
#line 32
extern unsigned int insb(unsigned int  , void *addr , unsigned long count ) ;
#line 35 "/usr/local/ddv/models/con2/include/asm/uaccess.h"
extern int access_ok(int type , void const   *addr , unsigned long size ) ;
#line 51
unsigned long copy_to_user(void *to , void const   *from , unsigned long n ) ;
#line 53
unsigned long copy_from_user(void *to , void *from , unsigned long n ) ;
#line 18 "/usr/local/ddv/models/con2/include/linux/delay.h"
extern void msleep(unsigned int msecs ) ;
#line 4 "/usr/local/ddv/models/con2/include/linux/elevator.h"
extern struct request *elv_next_request(struct request_queue *q ) ;
#line 211 "/usr/local/ddv/models/con2/include/linux/blkdev.h"
extern void blkdev_dequeue_request(struct request *req ) ;
#line 214
extern int end_that_request_first(struct request * , int  , int  ) ;
#line 218
extern void end_that_request_last(struct request * , int  ) ;
#line 190 "cdu31a.c"
static struct __anonstruct_cdu31a_addresses_16 cdu31a_addresses[1]  = {      {(unsigned short)0, (short)0}};
#line 198
static int handle_sony_cd_attention(void) ;
#line 199
static int read_subcode(void) ;
#line 200
static void sony_get_toc(void) ;
#line 201
static int scd_spinup(void) ;
#line 203
static int scd_open(struct cdrom_device_info *cdi , int purpose ) ;
#line 204
static void do_sony_cd_cmd(unsigned char cmd , unsigned char *params , unsigned int num_params ,
                           unsigned char *result_buffer , unsigned int *result_size ) ;
#line 209
static void size_to_buf(unsigned int size , unsigned char *buf ) ;
#line 212 "cdu31a.c"
static unsigned int sony_next_block  ;
#line 213 "cdu31a.c"
static unsigned int sony_blocks_left  =    0U;
#line 219 "cdu31a.c"
static unsigned int cdu31a_port  =    0U;
#line 226 "cdu31a.c"
static unsigned short volatile   sony_cd_cmd_reg  ;
#line 227 "cdu31a.c"
static unsigned short volatile   sony_cd_param_reg  ;
#line 228 "cdu31a.c"
static unsigned short volatile   sony_cd_write_reg  ;
#line 229 "cdu31a.c"
static unsigned short volatile   sony_cd_control_reg  ;
#line 230 "cdu31a.c"
static unsigned short volatile   sony_cd_status_reg  ;
#line 231 "cdu31a.c"
static unsigned short volatile   sony_cd_result_reg  ;
#line 232 "cdu31a.c"
static unsigned short volatile   sony_cd_read_reg  ;
#line 233 "cdu31a.c"
static unsigned short volatile   sony_cd_fifost_reg  ;
#line 235 "cdu31a.c"
static struct request_queue *cdu31a_queue  ;
#line 236 "cdu31a.c"
static spinlock_t cdu31a_lock  =    {1, 0};
#line 238 "cdu31a.c"
static int sony_spun_up  =    0;
#line 240 "cdu31a.c"
static int sony_speed  =    0;
#line 242 "cdu31a.c"
static int sony_xa_mode  =    0;
#line 245 "cdu31a.c"
static int sony_raw_data_mode  =    1;
#line 248 "cdu31a.c"
static unsigned int sony_usage  =    0U;
#line 251 "cdu31a.c"
static int sony_pas_init  =    0;
#line 254 "cdu31a.c"
static struct s_sony_session_toc single_toc  ;
#line 258 "cdu31a.c"
static struct s_all_sessions_toc sony_toc  ;
#line 261 "cdu31a.c"
static int sony_toc_read  =    0;
#line 264 "cdu31a.c"
static struct s_sony_subcode last_sony_subcode  ;
#line 267 "cdu31a.c"
static struct semaphore sony_sem  =    {1, 0};
#line 269 "cdu31a.c"
static int is_double_speed  =    0;
#line 271 "cdu31a.c"
static int is_auto_eject  =    1;
#line 277 "cdu31a.c"
static int volatile   sony_audio_status  =    (int volatile   )21;
#line 286 "cdu31a.c"
static unsigned char volatile   cur_pos_msf[3]  = {      (unsigned char volatile   )0,      (unsigned char volatile   )0,      (unsigned char volatile   )0};
#line 287 "cdu31a.c"
static unsigned char volatile   final_pos_msf[3]  = {      (unsigned char volatile   )0,      (unsigned char volatile   )0,      (unsigned char volatile   )0};
#line 290 "cdu31a.c"
static int cdu31a_irq  =    0;
#line 295 "cdu31a.c"
static wait_queue_head_t cdu31a_irq_wait  =    {0, 0, 1};
#line 296 "cdu31a.c"
static int irq_flag  =    0;
#line 298 "cdu31a.c"
static int curr_control_reg  =    0;
#line 303 "cdu31a.c"
static char disk_changed  ;
#line 306 "cdu31a.c"
static char audio_buffer[2352]  ;
#line 311 "cdu31a.c"
static struct timer_list cdu31a_abort_timer  ;
#line 316 "cdu31a.c"
static int abort_read_started  =    0;
#line 322 "cdu31a.c"
static int scd_media_changed(struct cdrom_device_info *cdi , int disc_nr ) 
{ 
  int retval ;

  {
#line 326
  retval = (int )disk_changed;
#line 327
  disk_changed = (char)0;
#line 329
  return (retval);
}
}
#line 336 "cdu31a.c"
static int scd_drive_status(struct cdrom_device_info *cdi , int slot_nr ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 338
  if ((int )(4294967295U >> 1) != slot_nr) {
#line 340
    return (-22);
  }
#line 341
  if (sony_spun_up) {
#line 342
    return (4);
  }
#line 343
  tmp = down_interruptible(& sony_sem);
#line 343
  if (tmp) {
#line 344
    return (-512);
  }
#line 345
  tmp___0 = scd_spinup();
#line 345
  if (tmp___0 == 0) {
#line 346
    sony_spun_up = 1;
  }
#line 347
  up(& sony_sem);
#line 348
  if (sony_spun_up) {
#line 348
    tmp___1 = 4;
  } else {
#line 348
    tmp___1 = 3;
  }
#line 348
  return (tmp___1);
}
}
#line 351 "cdu31a.c"
__inline static void enable_interrupts(void) 
{ 


  {
#line 353
  curr_control_reg |= 56;
#line 356
  outb((unsigned char )curr_control_reg, (unsigned int )sony_cd_control_reg);
#line 357
  return;
}
}
#line 359 "cdu31a.c"
__inline static void disable_interrupts(void) 
{ 


  {
#line 361
  curr_control_reg &= -57;
#line 364
  outb((unsigned char )curr_control_reg, (unsigned int )sony_cd_control_reg);
#line 365
  return;
}
}
#line 371 "cdu31a.c"
__inline static void sony_sleep(void) 
{ 
  wait_queue_t w ;
  int first ;
  struct task_struct *tmp ;
  int tmp___0 ;

  {
#line 373
  if (cdu31a_irq <= 0) {
#line 374
    yield();
  } else {
#line 377
    first = 1;
#line 379
    while (1) {
#line 380
      prepare_to_wait(& cdu31a_irq_wait, & w, 1);
#line 382
      if (first) {
#line 383
        enable_interrupts();
#line 384
        first = 0;
      }
#line 387
      if (irq_flag != 0) {
#line 388
        break;
      }
#line 389
      tmp = get_current();
#line 389
      tmp___0 = signal_pending(tmp);
#line 389
      if (tmp___0) {
#line 393
        disable_interrupts();
      } else {
#line 390
        schedule();
#line 391
        continue;
      }
#line 394
      break;
    }
#line 396
    finish_wait(& cdu31a_irq_wait, & w);
#line 397
    irq_flag = 0;
  }
#line 399
  return;
}
}
#line 406 "cdu31a.c"
__inline static int is_attention(void) 
{ 
  unsigned char tmp ;

  {
#line 408
  tmp = inb((unsigned int )sony_cd_status_reg);
#line 408
  return (((int )tmp & 1) != 0);
}
}
#line 411 "cdu31a.c"
__inline static int is_busy(void) 
{ 
  unsigned char tmp ;

  {
#line 413
  tmp = inb((unsigned int )sony_cd_status_reg);
#line 413
  return (((int )tmp & 128) != 0);
}
}
#line 416 "cdu31a.c"
__inline static int is_data_ready(void) 
{ 
  unsigned char tmp ;

  {
#line 418
  tmp = inb((unsigned int )sony_cd_status_reg);
#line 418
  return (((int )tmp & 4) != 0);
}
}
#line 421 "cdu31a.c"
__inline static int is_data_requested(void) 
{ 
  unsigned char tmp ;

  {
#line 423
  tmp = inb((unsigned int )sony_cd_status_reg);
#line 423
  return (((int )tmp & 64) != 0);
}
}
#line 426 "cdu31a.c"
__inline static int is_result_ready(void) 
{ 
  unsigned char tmp ;

  {
#line 428
  tmp = inb((unsigned int )sony_cd_status_reg);
#line 428
  return (((int )tmp & 2) != 0);
}
}
#line 431 "cdu31a.c"
__inline static int is_param_write_rdy(void) 
{ 
  unsigned char tmp ;

  {
#line 433
  tmp = inb((unsigned int )sony_cd_fifost_reg);
#line 433
  return (((int )tmp & 1) != 0);
}
}
#line 436 "cdu31a.c"
__inline static int is_result_reg_not_empty(void) 
{ 
  unsigned char tmp ;

  {
#line 438
  tmp = inb((unsigned int )sony_cd_fifost_reg);
#line 438
  return (((int )tmp & 4) != 0);
}
}
#line 441 "cdu31a.c"
__inline static void reset_drive(void) 
{ 


  {
#line 443
  curr_control_reg = 0;
#line 444
  sony_toc_read = 0;
#line 445
  outb((unsigned char)128, (unsigned int )sony_cd_control_reg);
#line 446
  return;
}
}
#line 452 "cdu31a.c"
static int scd_reset(struct cdrom_device_info *cdi ) 
{ 
  unsigned long retry_count ;
  int tmp ;
  int tmp___0 ;

  {
#line 456
  tmp = down_interruptible(& sony_sem);
#line 456
  if (tmp) {
#line 457
    return (-512);
  }
#line 458
  reset_drive();
#line 460
  retry_count = jiffies + 100UL;
#line 461
  while (1) {
#line 461
    if ((long )jiffies - (long )retry_count < 0L) {
#line 461
      tmp___0 = is_attention();
#line 461
      if (tmp___0) {
#line 461
        break;
      }
    } else {
#line 461
      break;
    }
#line 462
    sony_sleep();
  }
#line 465
  up(& sony_sem);
#line 466
  return (0);
}
}
#line 469 "cdu31a.c"
__inline static void clear_attention(void) 
{ 


  {
#line 471
  outb((unsigned char )(curr_control_reg | 1), (unsigned int )sony_cd_control_reg);
#line 472
  return;
}
}
#line 474 "cdu31a.c"
__inline static void clear_result_ready(void) 
{ 


  {
#line 476
  outb((unsigned char )(curr_control_reg | 2), (unsigned int )sony_cd_control_reg);
#line 477
  return;
}
}
#line 479 "cdu31a.c"
__inline static void clear_data_ready(void) 
{ 


  {
#line 481
  outb((unsigned char )(curr_control_reg | 4), (unsigned int )sony_cd_control_reg);
#line 483
  return;
}
}
#line 485 "cdu31a.c"
__inline static void clear_param_reg(void) 
{ 


  {
#line 487
  outb((unsigned char )(curr_control_reg | 64), (unsigned int )sony_cd_control_reg);
#line 488
  return;
}
}
#line 490 "cdu31a.c"
__inline static unsigned char read_status_register(void) 
{ 
  unsigned char tmp ;

  {
#line 492
  tmp = inb((unsigned int )sony_cd_status_reg);
#line 492
  return (tmp);
}
}
#line 495 "cdu31a.c"
__inline static unsigned char read_result_register(void) 
{ 
  unsigned char tmp ;

  {
#line 497
  tmp = inb((unsigned int )sony_cd_result_reg);
#line 497
  return (tmp);
}
}
#line 500 "cdu31a.c"
__inline static unsigned char read_data_register(void) 
{ 
  unsigned char tmp ;

  {
#line 502
  tmp = inb((unsigned int )sony_cd_read_reg);
#line 502
  return (tmp);
}
}
#line 505 "cdu31a.c"
__inline static void write_param(unsigned char param ) 
{ 


  {
#line 507
  outb(param, (unsigned int )sony_cd_param_reg);
#line 508
  return;
}
}
#line 510 "cdu31a.c"
__inline static void write_cmd(unsigned char cmd ) 
{ 


  {
#line 512
  outb((unsigned char )(curr_control_reg | 16), (unsigned int )sony_cd_control_reg);
#line 514
  outb(cmd, (unsigned int )sony_cd_cmd_reg);
#line 515
  return;
}
}
#line 517 "cdu31a.c"
static irqreturn_t cdu31a_interrupt(int irq , void *dev_id , struct pt_regs *regs ) 
{ 
  unsigned char val ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 521
  if (abort_read_started) {
#line 526
    while (1) {
#line 526
      tmp = is_result_reg_not_empty();
#line 526
      if (! tmp) {
#line 526
        break;
      }
#line 527
      val = read_result_register();
    }
#line 529
    clear_data_ready();
#line 530
    clear_result_ready();
#line 533
    while (1) {
#line 533
      tmp___0 = is_data_requested();
#line 533
      if (! tmp___0) {
#line 533
        break;
      }
#line 534
      val = read_data_register();
    }
#line 536
    abort_read_started = 0;
#line 539
    tmp___1 = waitqueue_active(& cdu31a_irq_wait);
#line 539
    if (tmp___1) {
#line 540
      disable_interrupts();
#line 541
      irq_flag = 1;
#line 542
      wake_up_interruptible(& cdu31a_irq_wait);
    }
  } else {
#line 544
    tmp___2 = waitqueue_active(& cdu31a_irq_wait);
#line 544
    if (tmp___2) {
#line 545
      disable_interrupts();
#line 546
      irq_flag = 1;
#line 547
      wake_up_interruptible(& cdu31a_irq_wait);
    } else {
#line 549
      disable_interrupts();
#line 550
      printk("<5>CDU31A: Got an interrupt but nothing was waiting\n");
    }
  }
#line 553
  return (1);
}
}
#line 561 "cdu31a.c"
static unsigned char errbuf[80]  ;
#line 559 "cdu31a.c"
static unsigned char *translate_error(unsigned char err_code ) 
{ 


  {
#line 563
  switch ((int )err_code) {
  case 16: 
#line 564
  return ((unsigned char *)"illegal command ");
  case 17: 
#line 565
  return ((unsigned char *)"illegal parameter ");
  case 32: 
#line 567
  return ((unsigned char *)"not loaded ");
  case 33: 
#line 568
  return ((unsigned char *)"no disc ");
  case 34: 
#line 569
  return ((unsigned char *)"not spinning ");
  case 35: 
#line 570
  return ((unsigned char *)"spinning ");
  case 37: 
#line 571
  return ((unsigned char *)"spindle servo ");
  case 38: 
#line 572
  return ((unsigned char *)"focus servo ");
  case 41: 
#line 573
  return ((unsigned char *)"eject mechanism ");
  case 42: 
#line 574
  return ((unsigned char *)"audio playing ");
  case 44: 
#line 575
  return ((unsigned char *)"emergency eject ");
  case 48: 
#line 577
  return ((unsigned char *)"focus ");
  case 49: 
#line 578
  return ((unsigned char *)"frame sync ");
  case 50: 
#line 579
  return ((unsigned char *)"subcode address ");
  case 51: 
#line 580
  return ((unsigned char *)"block sync ");
  case 52: 
#line 581
  return ((unsigned char *)"header address ");
  case 64: 
#line 583
  return ((unsigned char *)"illegal track read ");
  case 65: 
#line 584
  return ((unsigned char *)"mode 0 read ");
  case 66: 
#line 585
  return ((unsigned char *)"illegal mode read ");
  case 67: 
#line 586
  return ((unsigned char *)"illegal block size read ");
  case 68: 
#line 587
  return ((unsigned char *)"mode read ");
  case 69: 
#line 588
  return ((unsigned char *)"form read ");
  case 70: 
#line 589
  return ((unsigned char *)"leadout read ");
  case 71: 
#line 590
  return ((unsigned char *)"buffer overrun ");
  case 83: 
#line 592
  return ((unsigned char *)"unrecoverable CIRC ");
  case 87: 
#line 593
  return ((unsigned char *)"unrecoverable LECC ");
  case 96: 
#line 595
  return ((unsigned char *)"no TOC ");
  case 97: 
#line 596
  return ((unsigned char *)"invalid subcode data ");
  case 99: 
#line 597
  return ((unsigned char *)"focus on TOC read ");
  case 100: 
#line 598
  return ((unsigned char *)"frame sync on TOC read ");
  case 101: 
#line 599
  return ((unsigned char *)"TOC data ");
  case 112: 
#line 601
  return ((unsigned char *)"hardware failure ");
  case 145: 
#line 602
  return ((unsigned char *)"leadin ");
  case 146: 
#line 603
  return ((unsigned char *)"leadout ");
  case 147: 
#line 604
  return ((unsigned char *)"data track ");
  }
#line 606
  sprintf((char *)(errbuf), "unknown 0x%02x ", (int )err_code);
#line 607
  return (errbuf);
}
}
#line 614 "cdu31a.c"
static void set_drive_params(int want_doublespeed ) 
{ 
  unsigned char res_reg[12] ;
  unsigned int res_size ;
  unsigned char params[3] ;

  {
#line 621
  params[0] = (unsigned char)6;
#line 622
  params[1] = (unsigned char)0;
#line 623
  do_sony_cd_cmd((unsigned char)16, params, 2U, res_reg, & res_size);
#line 625
  if (res_size < 2U) {
#line 626
    printk("<5>CDU31A: Unable to set spin-down time: 0x%2.2x\n", (int )res_reg[1]);
  } else
#line 625
  if (((int )res_reg[0] & 240) == 32) {
#line 626
    printk("<5>CDU31A: Unable to set spin-down time: 0x%2.2x\n", (int )res_reg[1]);
  }
#line 630
  params[0] = (unsigned char)5;
#line 631
  params[1] = (unsigned char)1;
#line 633
  if (is_auto_eject) {
#line 634
    params[1] = (unsigned char )((int )params[1] | 2);
  }
#line 636
  if (is_double_speed) {
#line 636
    if (want_doublespeed) {
#line 637
      params[1] = (unsigned char )((int )params[1] | 4);
    }
  }
#line 640
  do_sony_cd_cmd((unsigned char)16, params, 2U, res_reg, & res_size);
#line 642
  if (res_size < 2U) {
#line 643
    printk("<5>CDU31A: Unable to set mechanical parameters: 0x%2.2x\n", (int )res_reg[1]);
  } else
#line 642
  if (((int )res_reg[0] & 240) == 32) {
#line 643
    printk("<5>CDU31A: Unable to set mechanical parameters: 0x%2.2x\n", (int )res_reg[1]);
  }
#line 646
  return;
}
}
#line 652 "cdu31a.c"
static int scd_select_speed(struct cdrom_device_info *cdi , int speed ) 
{ 
  int tmp ;

  {
#line 654
  if (speed == 0) {
#line 655
    sony_speed = 1;
  } else {
#line 657
    sony_speed = speed - 1;
  }
#line 659
  tmp = down_interruptible(& sony_sem);
#line 659
  if (tmp) {
#line 660
    return (-512);
  }
#line 661
  set_drive_params(sony_speed);
#line 662
  up(& sony_sem);
#line 663
  return (0);
}
}
#line 670 "cdu31a.c"
static int scd_lock_door(struct cdrom_device_info *cdi , int lock ) 
{ 
  int tmp ;

  {
#line 672
  if (lock == 0) {
#line 673
    is_auto_eject = 1;
  } else {
#line 675
    is_auto_eject = 0;
  }
#line 677
  tmp = down_interruptible(& sony_sem);
#line 677
  if (tmp) {
#line 678
    return (-512);
  }
#line 679
  set_drive_params(sony_speed);
#line 680
  up(& sony_sem);
#line 681
  return (0);
}
}
#line 687 "cdu31a.c"
static void restart_on_error(void) 
{ 
  unsigned char res_reg[12] ;
  unsigned int res_size ;
  unsigned long retry_count ;
  int tmp ;

  {
#line 694
  printk("<5>CDU31A: Resetting drive on error\n");
#line 695
  reset_drive();
#line 696
  retry_count = jiffies + 100UL;
#line 697
  while (1) {
#line 697
    if ((long )jiffies - (long )retry_count < 0L) {
#line 697
      tmp = is_attention();
#line 697
      if (tmp) {
#line 697
        break;
      }
    } else {
#line 697
      break;
    }
#line 698
    sony_sleep();
  }
#line 700
  set_drive_params(sony_speed);
#line 701
  do_sony_cd_cmd((unsigned char)81, (unsigned char *)((void *)0), 0U, res_reg, & res_size);
#line 702
  if (res_size < 2U) {
#line 703
    printk("<5>CDU31A: Unable to spin up drive: 0x%2.2x\n", (int )res_reg[1]);
  } else
#line 702
  if (((int )res_reg[0] & 240) == 32) {
#line 703
    printk("<5>CDU31A: Unable to spin up drive: 0x%2.2x\n", (int )res_reg[1]);
  }
#line 707
  msleep(2000U);
#line 709
  sony_get_toc();
#line 710
  return;
}
}
#line 716 "cdu31a.c"
static int write_params(unsigned char *params , int num_params ) 
{ 
  unsigned int retry_count ;
  int tmp ;
  int tmp___0 ;

  {
#line 721
  retry_count = 20000U;
#line 722
  while (1) {
#line 722
    if (retry_count > 0U) {
#line 722
      tmp = is_param_write_rdy();
#line 722
      if (tmp) {
#line 722
        break;
      }
    } else {
#line 722
      break;
    }
#line 723
    retry_count --;
  }
#line 725
  tmp___0 = is_param_write_rdy();
#line 725
  if (! tmp___0) {
#line 726
    return (-5);
  }
#line 729
  while (num_params > 0) {
#line 730
    write_param(*params);
#line 731
    params ++;
#line 732
    num_params --;
  }
#line 735
  return (0);
}
}
#line 745 "cdu31a.c"
static void get_result(unsigned char *result_buffer , unsigned int *result_size ) 
{ 
  unsigned char a ;
  unsigned char b ;
  int i ;
  unsigned long retry_count ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;

  {
#line 753
  while (1) {
#line 753
    tmp = handle_sony_cd_attention();
#line 753
    if (! tmp) {
#line 753
      break;
    }
  }
#line 755
  retry_count = jiffies + 1000UL;
#line 756
  while (1) {
#line 756
    if ((long )jiffies - (long )retry_count < 0L) {
#line 756
      tmp___1 = is_busy();
#line 756
      if (! tmp___1) {
#line 756
        tmp___2 = is_result_ready();
#line 756
        if (tmp___2) {
#line 756
          break;
        }
      }
    } else {
#line 756
      break;
    }
#line 758
    sony_sleep();
#line 760
    while (1) {
#line 760
      tmp___0 = handle_sony_cd_attention();
#line 760
      if (! tmp___0) {
#line 760
        break;
      }
    }
  }
#line 762
  tmp___3 = is_busy();
#line 762
  if (tmp___3) {
#line 762
    goto _L;
  } else {
#line 762
    tmp___4 = is_result_ready();
#line 762
    if (! tmp___4) {
      _L: /* CIL Label */ 
#line 763
      while (1) {
#line 763
        break;
      }
#line 764
      *(result_buffer + 0) = (unsigned char)32;
#line 765
      *(result_buffer + 1) = (unsigned char)1;
#line 766
      *result_size = 2U;
#line 767
      return;
    }
  }
#line 774
  clear_result_ready();
#line 775
  a = read_result_register();
#line 776
  *result_buffer = a;
#line 777
  result_buffer ++;
#line 780
  if (((int )a & 240) == 80) {
#line 781
    *result_size = 1U;
#line 782
    return;
  }
#line 785
  b = read_result_register();
#line 786
  *result_buffer = b;
#line 787
  result_buffer ++;
#line 788
  *result_size = 2U;
#line 798
  if (((int )a & 240) != 32) {
#line 799
    if ((int )b > 8) {
#line 800
      i = 0;
#line 800
      while (i < 8) {
#line 801
        *result_buffer = read_result_register();
#line 802
        result_buffer ++;
#line 803
        (*result_size) ++;
#line 800
        i ++;
      }
#line 805
      b = (unsigned char )((int )b - 8);
#line 807
      while ((int )b > 10) {
#line 808
        retry_count = 20000UL;
#line 809
        while (1) {
#line 809
          if (retry_count > 0UL) {
#line 809
            tmp___5 = is_result_ready();
#line 809
            if (tmp___5) {
#line 809
              break;
            }
          } else {
#line 809
            break;
          }
#line 811
          retry_count --;
        }
#line 813
        tmp___6 = is_result_ready();
#line 813
        if (! tmp___6) {
#line 814
          while (1) {
#line 814
            break;
          }
#line 816
          *(result_buffer + 0) = (unsigned char)32;
#line 817
          *(result_buffer + 1) = (unsigned char)1;
#line 819
          *result_size = 2U;
#line 820
          return;
        }
#line 823
        clear_result_ready();
#line 825
        i = 0;
#line 825
        while (i < 10) {
#line 826
          *result_buffer = read_result_register();
#line 828
          result_buffer ++;
#line 829
          (*result_size) ++;
#line 825
          i ++;
        }
#line 831
        b = (unsigned char )((int )b - 10);
      }
#line 834
      if ((int )b > 0) {
#line 835
        retry_count = 20000UL;
#line 836
        while (1) {
#line 836
          if (retry_count > 0UL) {
#line 836
            tmp___7 = is_result_ready();
#line 836
            if (tmp___7) {
#line 836
              break;
            }
          } else {
#line 836
            break;
          }
#line 838
          retry_count --;
        }
#line 840
        tmp___8 = is_result_ready();
#line 840
        if (! tmp___8) {
#line 841
          while (1) {
#line 841
            break;
          }
#line 843
          *(result_buffer + 0) = (unsigned char)32;
#line 844
          *(result_buffer + 1) = (unsigned char)1;
#line 846
          *result_size = 2U;
#line 847
          return;
        }
      }
    }
#line 852
    while ((int )b > 0) {
#line 853
      *result_buffer = read_result_register();
#line 854
      result_buffer ++;
#line 855
      (*result_size) ++;
#line 856
      b = (unsigned char )((int )b - 1);
    }
  }
#line 859
  return;
}
}
#line 866 "cdu31a.c"
static void do_sony_cd_cmd(unsigned char cmd , unsigned char *params , unsigned int num_params ,
                           unsigned char *result_buffer , unsigned int *result_size ) 
{ 
  unsigned long retry_count ;
  int num_retries ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 873
  num_retries = 0;
  retry_cd_operation: 
#line 877
  while (1) {
#line 877
    tmp = handle_sony_cd_attention();
#line 877
    if (! tmp) {
#line 877
      break;
    }
  }
#line 879
  retry_count = jiffies + 1000UL;
#line 880
  while (1) {
#line 880
    if ((long )jiffies - (long )retry_count < 0L) {
#line 880
      tmp___1 = is_busy();
#line 880
      if (! tmp___1) {
#line 880
        break;
      }
    } else {
#line 880
      break;
    }
#line 881
    sony_sleep();
#line 883
    while (1) {
#line 883
      tmp___0 = handle_sony_cd_attention();
#line 883
      if (! tmp___0) {
#line 883
        break;
      }
    }
  }
#line 885
  tmp___2 = is_busy();
#line 885
  if (tmp___2) {
#line 886
    while (1) {
#line 886
      break;
    }
#line 887
    *(result_buffer + 0) = (unsigned char)32;
#line 888
    *(result_buffer + 1) = (unsigned char)1;
#line 889
    *result_size = 2U;
  } else {
#line 891
    clear_result_ready();
#line 892
    clear_param_reg();
#line 894
    write_params(params, (int )num_params);
#line 895
    write_cmd(cmd);
#line 897
    get_result(result_buffer, result_size);
  }
#line 900
  if (((int )*(result_buffer + 0) & 240) == 32) {
#line 900
    if (num_retries < 3) {
#line 902
      num_retries ++;
#line 903
      msleep(100U);
#line 904
      goto retry_cd_operation;
    }
  }
#line 906
  return;
}
}
#line 921 "cdu31a.c"
static int num_consecutive_attentions  =    0;
#line 918 "cdu31a.c"
static int handle_sony_cd_attention(void) 
{ 
  unsigned char atten_code ;
  int volatile   val ;
  unsigned char tmp ;
  int tmp___0 ;
  unsigned char tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 928
  tmp___3 = is_attention();
#line 928
  if (tmp___3) {
#line 929
    if (num_consecutive_attentions > 10) {
#line 931
      printk("<5>CDU31A: Too many consecutive attentions: %d\n", num_consecutive_attentions);
#line 933
      num_consecutive_attentions = 0;
#line 934
      while (1) {
#line 934
        break;
      }
#line 936
      return (0);
    }
#line 939
    clear_attention();
#line 940
    atten_code = read_result_register();
#line 942
    switch ((int )atten_code) {
    case 128: 
#line 945
    disk_changed = (char)1;
#line 946
    sony_toc_read = 0;
#line 947
    sony_audio_status = (int volatile   )21;
#line 948
    sony_blocks_left = 0U;
#line 949
    break;
    case 39: 
#line 953
    sony_spun_up = 0;
#line 954
    break;
    case 144: 
#line 957
    sony_audio_status = (int volatile   )19;
#line 958
    read_subcode();
#line 959
    break;
    case 129: 
#line 962
    if (is_auto_eject) {
#line 963
      sony_audio_status = (int volatile   )0;
    }
#line 965
    break;
    case 148: 
    case 147: 
    case 146: 
    case 145: 
#line 971
    sony_audio_status = (int volatile   )20;
#line 972
    break;
    }
#line 975
    num_consecutive_attentions ++;
#line 976
    while (1) {
#line 976
      break;
    }
#line 977
    return (1);
  } else
#line 978
  if (abort_read_started) {
#line 979
    while (1) {
#line 979
      tmp___0 = is_result_reg_not_empty();
#line 979
      if (! tmp___0) {
#line 979
        break;
      }
#line 980
      tmp = read_result_register();
#line 980
      val = (int volatile   )tmp;
    }
#line 982
    clear_data_ready();
#line 983
    clear_result_ready();
#line 985
    while (1) {
#line 985
      tmp___2 = is_data_requested();
#line 985
      if (! tmp___2) {
#line 985
        break;
      }
#line 986
      tmp___1 = read_data_register();
#line 986
      val = (int volatile   )tmp___1;
    }
#line 988
    abort_read_started = 0;
#line 989
    while (1) {
#line 989
      break;
    }
#line 990
    return (1);
  }
#line 993
  num_consecutive_attentions = 0;
#line 997
  return (0);
}
}
#line 1002 "cdu31a.c"
__inline static unsigned int int_to_bcd(unsigned int val ) 
{ 
  int retval ;

  {
#line 1007
  retval = (int )(val / 10U << 4);
#line 1008
  retval = (int )((unsigned int )retval | val % 10U);
#line 1009
  return ((unsigned int )retval);
}
}
#line 1014 "cdu31a.c"
static unsigned int bcd_to_int(unsigned int bcd ) 
{ 


  {
#line 1016
  return (((bcd >> 4) & 15U) * 10U + (bcd & 15U));
}
}
#line 1024 "cdu31a.c"
static void log_to_msf(unsigned int log , unsigned char *msf ) 
{ 
  unsigned int tmp ;
  unsigned int tmp___0 ;
  unsigned int tmp___1 ;

  {
#line 1026
  log += 150U;
#line 1027
  tmp = int_to_bcd(log / 4500U);
#line 1027
  *(msf + 0) = (unsigned char )tmp;
#line 1028
  log %= 4500U;
#line 1029
  tmp___0 = int_to_bcd(log / 75U);
#line 1029
  *(msf + 1) = (unsigned char )tmp___0;
#line 1030
  tmp___1 = int_to_bcd(log % 75U);
#line 1030
  *(msf + 2) = (unsigned char )tmp___1;
#line 1031
  return;
}
}
#line 1037 "cdu31a.c"
static unsigned int msf_to_log(unsigned char *msf ) 
{ 
  unsigned int log ;

  {
#line 1042
  log = (unsigned int )*(msf + 2);
#line 1043
  log += (unsigned int )((int )*(msf + 1) * 75);
#line 1044
  log += (unsigned int )((int )*(msf + 0) * 4500);
#line 1045
  log -= 150U;
#line 1047
  return (log);
}
}
#line 1055 "cdu31a.c"
static void size_to_buf(unsigned int size , unsigned char *buf ) 
{ 


  {
#line 1057
  *(buf + 0) = (unsigned char )(size / 65536U);
#line 1058
  size %= 65536U;
#line 1059
  *(buf + 1) = (unsigned char )(size / 256U);
#line 1060
  *(buf + 2) = (unsigned char )(size % 256U);
#line 1061
  return;
}
}
#line 1069 "cdu31a.c"
static int start_request(unsigned int sector , unsigned int nsect ) 
{ 
  unsigned char params[6] ;
  unsigned long retry_count ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 1076
  while (1) {
#line 1076
    break;
  }
#line 1077
  log_to_msf(sector, params);
#line 1078
  size_to_buf(nsect, & params[3]);
#line 1084
  while (1) {
#line 1084
    tmp = handle_sony_cd_attention();
#line 1084
    if (! tmp) {
#line 1084
      break;
    }
  }
#line 1086
  retry_count = jiffies + 1000UL;
#line 1087
  while (1) {
#line 1087
    if ((long )jiffies - (long )retry_count < 0L) {
#line 1087
      tmp___1 = is_busy();
#line 1087
      if (! tmp___1) {
#line 1087
        break;
      }
    } else {
#line 1087
      break;
    }
#line 1088
    sony_sleep();
#line 1090
    while (1) {
#line 1090
      tmp___0 = handle_sony_cd_attention();
#line 1090
      if (! tmp___0) {
#line 1090
        break;
      }
    }
  }
#line 1093
  tmp___2 = is_busy();
#line 1093
  if (tmp___2) {
#line 1094
    printk("<5>CDU31A: Timeout while waiting to issue command\n");
#line 1096
    while (1) {
#line 1096
      break;
    }
#line 1097
    return (1);
  } else {
#line 1100
    clear_result_ready();
#line 1101
    clear_param_reg();
#line 1103
    write_params(params, 6);
#line 1104
    write_cmd((unsigned char)52);
#line 1106
    sony_blocks_left = nsect * 4U;
#line 1107
    sony_next_block = sector * 4U;
#line 1108
    while (1) {
#line 1108
      break;
    }
#line 1109
    return (0);
  }
#line 1111
  while (1) {
#line 1111
    break;
  }
}
}
#line 1115 "cdu31a.c"
static void abort_read(void) 
{ 
  unsigned char result_reg[2] ;
  int result_size ;
  int volatile   val ;
  unsigned char *tmp ;
  unsigned char tmp___0 ;
  int tmp___1 ;
  unsigned char tmp___2 ;
  int tmp___3 ;

  {
#line 1122
  do_sony_cd_cmd((unsigned char)53, (unsigned char *)((void *)0), 0U, result_reg,
                 (unsigned int *)(& result_size));
#line 1123
  if (((int )result_reg[0] & 240) == 32) {
#line 1124
    tmp = translate_error(result_reg[1]);
#line 1124
    printk("<3>CDU31A: Aborting read, %s error\n", tmp);
  }
#line 1128
  while (1) {
#line 1128
    tmp___1 = is_result_reg_not_empty();
#line 1128
    if (! tmp___1) {
#line 1128
      break;
    }
#line 1129
    tmp___0 = read_result_register();
#line 1129
    val = (int volatile   )tmp___0;
  }
#line 1131
  clear_data_ready();
#line 1132
  clear_result_ready();
#line 1134
  while (1) {
#line 1134
    tmp___3 = is_data_requested();
#line 1134
    if (! tmp___3) {
#line 1134
      break;
    }
#line 1135
    tmp___2 = read_data_register();
#line 1135
    val = (int volatile   )tmp___2;
  }
#line 1138
  sony_blocks_left = 0U;
#line 1139
  return;
}
}
#line 1143 "cdu31a.c"
static void handle_abort_timeout(unsigned long data ) 
{ 
  int tmp ;

  {
#line 1145
  while (1) {
#line 1145
    break;
  }
#line 1147
  tmp = down_trylock(& sony_sem);
#line 1147
  if (tmp == 0) {
#line 1152
    clear_result_ready();
#line 1153
    clear_param_reg();
#line 1154
    write_cmd((unsigned char)53);
#line 1156
    sony_blocks_left = 0U;
#line 1157
    abort_read_started = 1;
#line 1158
    up(& sony_sem);
  }
#line 1160
  while (1) {
#line 1160
    break;
  }
#line 1161
  return;
}
}
#line 1164 "cdu31a.c"
static void input_data_sector(char *buffer ) 
{ 


  {
#line 1167
  while (1) {
#line 1167
    break;
  }
#line 1171
  if (sony_xa_mode) {
#line 1172
    insb((unsigned int )sony_cd_read_reg, (void *)(audio_buffer), 12UL);
  }
#line 1174
  clear_data_ready();
#line 1176
  insb((unsigned int )sony_cd_read_reg, (void *)buffer, 2048UL);
#line 1180
  if (sony_xa_mode) {
#line 1181
    insb((unsigned int )sony_cd_read_reg, (void *)(audio_buffer), 280UL);
  }
#line 1183
  while (1) {
#line 1183
    break;
  }
#line 1184
  return;
}
}
#line 1187 "cdu31a.c"
static void read_data_block(char *buffer , unsigned int block , unsigned int nblocks ,
                            unsigned char *res_reg , int *res_size ) 
{ 
  unsigned long retry_count ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
#line 1195
  while (1) {
#line 1195
    break;
  }
#line 1197
  *(res_reg + 0) = (unsigned char)0;
#line 1198
  *(res_reg + 1) = (unsigned char)0;
#line 1199
  *res_size = 0;
#line 1202
  retry_count = jiffies + 1000UL;
#line 1203
  while (1) {
#line 1203
    if ((long )jiffies - (long )retry_count < 0L) {
#line 1203
      tmp___0 = is_data_ready();
#line 1203
      if (tmp___0) {
#line 1203
        break;
      }
    } else {
#line 1203
      break;
    }
#line 1204
    while (1) {
#line 1204
      tmp = handle_sony_cd_attention();
#line 1204
      if (! tmp) {
#line 1204
        break;
      }
    }
#line 1206
    sony_sleep();
  }
#line 1208
  tmp___5 = is_data_ready();
#line 1208
  if (tmp___5) {
#line 1227
    input_data_sector(buffer);
#line 1228
    sony_blocks_left -= nblocks;
#line 1229
    sony_next_block += nblocks;
#line 1232
    retry_count = jiffies + 1000UL;
#line 1233
    while (1) {
#line 1233
      if ((long )jiffies - (long )retry_count < 0L) {
#line 1233
        tmp___3 = is_result_ready();
#line 1233
        if (tmp___3) {
#line 1233
          break;
        }
      } else {
#line 1233
        break;
      }
#line 1235
      while (1) {
#line 1235
        tmp___2 = handle_sony_cd_attention();
#line 1235
        if (! tmp___2) {
#line 1235
          break;
        }
      }
#line 1237
      sony_sleep();
    }
#line 1240
    tmp___4 = is_result_ready();
#line 1240
    if (tmp___4) {
#line 1247
      get_result(res_reg, (unsigned int *)res_size);
#line 1250
      if (((int )*(res_reg + 0) & 240) == 80) {
#line 1252
        if (! ((int )*(res_reg + 0) == 80)) {
#line 1252
          if (! ((int )*(res_reg + 0) == 84)) {
#line 1252
            if (! ((int )*(res_reg + 0) == 85)) {
#line 1260
              printk("<3>CDU31A: Data block error: 0x%x\n", (int )*(res_reg + 0));
#line 1262
              *(res_reg + 0) = (unsigned char)32;
#line 1263
              *(res_reg + 1) = (unsigned char)3;
#line 1264
              *res_size = 2;
            }
          }
        }
#line 1268
        if (sony_blocks_left == 0U) {
#line 1269
          get_result(res_reg, (unsigned int *)res_size);
        }
      } else
#line 1271
      if (((int )*(res_reg + 0) & 240) != 32) {
#line 1274
        printk("<3>CDU31A: Invalid block status: 0x%x\n", (int )*(res_reg + 0));
#line 1276
        restart_on_error();
#line 1277
        *(res_reg + 0) = (unsigned char)32;
#line 1278
        *(res_reg + 1) = (unsigned char)3;
#line 1279
        *res_size = 2;
      }
    } else {
#line 1241
      while (1) {
#line 1241
        break;
      }
#line 1242
      *(res_reg + 0) = (unsigned char)32;
#line 1243
      *(res_reg + 1) = (unsigned char)1;
#line 1244
      *res_size = 2;
#line 1245
      abort_read();
    }
  } else {
#line 1209
    tmp___1 = is_result_ready();
#line 1209
    if (tmp___1) {
#line 1210
      get_result(res_reg, (unsigned int *)res_size);
#line 1211
      if (((int )*(res_reg + 0) & 240) != 32) {
#line 1212
        printk("<5>CDU31A: Got result that should have been error: %d\n", (int )*(res_reg + 0));
#line 1214
        *(res_reg + 0) = (unsigned char)32;
#line 1215
        *(res_reg + 1) = (unsigned char)3;
#line 1216
        *res_size = 2;
      }
#line 1218
      abort_read();
    } else {
#line 1220
      while (1) {
#line 1220
        break;
      }
#line 1221
      *(res_reg + 0) = (unsigned char)32;
#line 1222
      *(res_reg + 1) = (unsigned char)1;
#line 1223
      *res_size = 2;
#line 1224
      abort_read();
    }
  }
#line 1283
  while (1) {
#line 1283
    break;
  }
#line 1284
  return;
}
}
#line 1294 "cdu31a.c"
static void do_cdu31a_request(request_queue_t *q ) 
{ 
  struct request *req ;
  int block ;
  int nblock ;
  int num_retries ;
  unsigned char res_reg[12] ;
  unsigned int res_size ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  unsigned char *tmp___5 ;

  {
#line 1301
  while (1) {
#line 1301
    break;
  }
#line 1303
  spin_unlock_irq(q->queue_lock);
#line 1304
  tmp = down_interruptible(& sony_sem);
#line 1304
  if (tmp) {
#line 1305
    spin_lock_irq(q->queue_lock);
#line 1306
    return;
  }
#line 1310
  while (1) {
#line 1310
    tmp___0 = handle_sony_cd_attention();
#line 1310
    if (! tmp___0) {
#line 1310
      break;
    }
  }
#line 1313
  sony_get_toc();
#line 1317
  del_timer(& cdu31a_abort_timer);
#line 1319
  while (1) {
#line 1324
    req = elv_next_request(q);
#line 1325
    if (! req) {
#line 1326
      goto end_do_cdu31a_request;
    }
#line 1328
    if (! sony_spun_up) {
#line 1329
      scd_spinup();
    }
#line 1331
    block = (int )req->sector;
#line 1332
    nblock = (int )req->nr_sectors;
#line 1333
    while (1) {
#line 1333
      break;
    }
#line 1335
    if (! sony_toc_read) {
#line 1336
      printk("<5>CDU31A: TOC not read\n");
#line 1337
      end_request(req, 0);
#line 1338
      continue;
    }
#line 1344
    if ((req->cmd_flags & 1U) == 1U) {
#line 1345
      end_request(req, 0);
#line 1346
      continue;
    }
#line 1353
    if ((unsigned int )((block + nblock) / 4) >= sony_toc.lead_out_start_lba) {
#line 1354
      printk("<5>CDU31A: Request past end of media\n");
#line 1355
      end_request(req, 0);
#line 1356
      continue;
    }
#line 1359
    if (nblock > 4) {
#line 1360
      nblock = 4;
    }
#line 1361
    num_retries = 0;
    try_read_again: 
#line 1364
    while (1) {
#line 1364
      tmp___1 = handle_sony_cd_attention();
#line 1364
      if (! tmp___1) {
#line 1364
        break;
      }
    }
#line 1366
    if (! sony_toc_read) {
#line 1367
      printk("<5>CDU31A: TOC not read\n");
#line 1368
      end_request(req, 0);
#line 1369
      continue;
    }
#line 1374
    if (sony_blocks_left == 0U) {
#line 1375
      tmp___2 = start_request((unsigned int )(block / 4), (unsigned int )(nblock / 4));
#line 1375
      if (tmp___2) {
#line 1376
        end_request(req, 0);
#line 1377
        continue;
      }
    } else
#line 1383
    if ((unsigned int )block != sony_next_block) {
#line 1384
      while (1) {
#line 1384
        break;
      }
#line 1386
      abort_read();
#line 1387
      if (! sony_toc_read) {
#line 1388
        printk("<5>CDU31A: TOC not read\n");
#line 1389
        end_request(req, 0);
#line 1390
        continue;
      }
#line 1392
      tmp___3 = start_request((unsigned int )(block / 4), (unsigned int )(nblock / 4));
#line 1392
      if (tmp___3) {
#line 1393
        printk("<5>CDU31A: start request failed\n");
#line 1394
        end_request(req, 0);
#line 1395
        continue;
      }
    }
#line 1399
    read_data_block(req->buffer, (unsigned int )block, (unsigned int )nblock, res_reg,
                    (int *)(& res_size));
#line 1401
    if ((int )res_reg[0] != 32) {
#line 1402
      tmp___4 = end_that_request_first(req, 1, nblock);
#line 1402
      if (! tmp___4) {
#line 1403
        spin_lock_irq(q->queue_lock);
#line 1404
        blkdev_dequeue_request(req);
#line 1405
        end_that_request_last(req, 1);
#line 1406
        spin_unlock_irq(q->queue_lock);
      }
#line 1408
      continue;
    }
#line 1411
    if (num_retries > 3) {
#line 1412
      end_request(req, 0);
#line 1413
      continue;
    }
#line 1416
    num_retries ++;
#line 1417
    if ((int )res_reg[1] == 34) {
#line 1418
      do_sony_cd_cmd((unsigned char)81, (unsigned char *)((void *)0), 0U, res_reg,
                     & res_size);
    } else {
#line 1421
      tmp___5 = translate_error(res_reg[1]);
#line 1421
      printk("<5>CDU31A: %s error for block %d, nblock %d\n", tmp___5, block, nblock);
    }
#line 1424
    goto try_read_again;
  }
  end_do_cdu31a_request: 
#line 1433
  cdu31a_abort_timer.expires = jiffies + 200UL;
#line 1434
  add_timer(& cdu31a_abort_timer);
#line 1437
  up(& sony_sem);
#line 1438
  spin_lock_irq(q->queue_lock);
#line 1439
  while (1) {
#line 1439
    break;
  }
#line 1440
  return;
}
}
#line 1447 "cdu31a.c"
static void sony_get_toc(void) 
{ 
  unsigned char res_reg[2] ;
  unsigned int res_size ;
  unsigned char parms[1] ;
  int session ;
  int num_spin_ups ;
  int totaltracks ;
  int mint ;
  int maxt ;
  unsigned char *tmp ;
  unsigned char *tmp___0 ;
  unsigned int tmp___1 ;
  unsigned int tmp___2 ;
  unsigned int tmp___3 ;
  unsigned int tmp___4 ;
  unsigned int tmp___5 ;
  unsigned int tmp___6 ;
  int i ;
  unsigned int tmp___7 ;
  unsigned int tmp___8 ;
  unsigned int tmp___9 ;
  unsigned int tmp___10 ;
  unsigned int tmp___11 ;
  unsigned int tmp___12 ;

  {
#line 1454
  totaltracks = 0;
#line 1455
  mint = 99;
#line 1456
  maxt = 0;
#line 1458
  while (1) {
#line 1458
    break;
  }
#line 1460
  num_spin_ups = 0;
#line 1461
  if (! sony_toc_read) {
    respinup_on_gettoc: 
#line 1464
    do_sony_cd_cmd((unsigned char)81, (unsigned char *)((void *)0), 0U, res_reg, & res_size);
#line 1467
    do_sony_cd_cmd((unsigned char)48, (unsigned char *)((void *)0), 0U, res_reg, & res_size);
#line 1472
    if (res_size < 2U) {
#line 1472
      goto _L;
    } else
#line 1472
    if ((int )res_reg[0] != 0) {
#line 1472
      if ((int )res_reg[1] != 0) {
        _L: /* CIL Label */ 
#line 1475
        if ((int )res_reg[1] == 42) {
#line 1477
          goto gettoc_drive_spinning;
        } else
#line 1475
        if ((int )res_reg[1] == 0) {
#line 1477
          goto gettoc_drive_spinning;
        }
#line 1482
        if ((int )res_reg[1] == 34) {
#line 1482
          if (num_spin_ups < 3) {
#line 1484
            num_spin_ups ++;
#line 1485
            goto respinup_on_gettoc;
          }
        }
#line 1488
        tmp = translate_error(res_reg[1]);
#line 1488
        printk("cdu31a: Error reading TOC: %x %s\n", (int )res_reg[0], tmp);
#line 1490
        return;
      }
    }
    gettoc_drive_spinning: 
#line 1501
    memset((void *)(& sony_toc), 14, (unsigned int )sizeof(sony_toc));
#line 1502
    memset((void *)(& single_toc), 15, (unsigned int )sizeof(single_toc));
#line 1504
    session = 1;
#line 1505
    while (1) {
#line 1509
      while (1) {
#line 1509
        break;
      }
#line 1510
      parms[0] = (unsigned char )session;
#line 1511
      do_sony_cd_cmd((unsigned char)54, parms, 1U, res_reg, & res_size);
#line 1514
      while (1) {
#line 1514
        break;
      }
#line 1516
      if (res_size < 2U) {
#line 1516
        goto _L___0;
      } else
#line 1516
      if (((int )res_reg[0] & 240) == 32) {
        _L___0: /* CIL Label */ 
#line 1519
        if (session == 1) {
#line 1520
          printk("Yikes! Couldn\'t read any sessions!");
        }
#line 1522
        break;
      }
#line 1524
      while (1) {
#line 1524
        break;
      }
#line 1526
      parms[0] = (unsigned char )session;
#line 1527
      do_sony_cd_cmd((unsigned char)36, parms, 1U, (unsigned char *)(& single_toc),
                     & res_size);
#line 1532
      if (res_size < 2U) {
#line 1535
        tmp___0 = translate_error(single_toc.exec_status[1]);
#line 1535
        printk("<3>CDU31A: Error reading session %d: %x %s\n", session, (int )single_toc.exec_status[0],
               tmp___0);
#line 1542
        return;
      } else
#line 1532
      if (((int )single_toc.exec_status[0] & 240) == 32) {
#line 1535
        tmp___0 = translate_error(single_toc.exec_status[1]);
#line 1535
        printk("<3>CDU31A: Error reading session %d: %x %s\n", session, (int )single_toc.exec_status[0],
               tmp___0);
#line 1542
        return;
      }
#line 1544
      while (1) {
#line 1544
        break;
      }
#line 1550
      while (1) {
#line 1550
        break;
      }
#line 1556
      while (1) {
#line 1556
        break;
      }
#line 1563
      if (res_size > 18U) {
#line 1563
        if ((int )single_toc.pointb0 > 175) {
#line 1564
          while (1) {
#line 1564
            break;
          }
        }
      }
#line 1588
      if (res_size > 27U) {
#line 1588
        if ((int )single_toc.pointb1 > 175) {
#line 1589
          while (1) {
#line 1589
            break;
          }
        }
      }
#line 1600
      if (res_size > 36U) {
#line 1600
        if ((int )single_toc.pointb2 > 175) {
#line 1601
          while (1) {
#line 1601
            break;
          }
        }
      }
#line 1612
      if (res_size > 45U) {
#line 1612
        if ((int )single_toc.pointb3 > 175) {
#line 1613
          while (1) {
#line 1613
            break;
          }
        }
      }
#line 1624
      if (res_size > 54U) {
#line 1624
        if ((int )single_toc.pointb4 > 175) {
#line 1625
          while (1) {
#line 1625
            break;
          }
        }
      }
#line 1636
      if (res_size > 63U) {
#line 1636
        if ((int )single_toc.pointc0 > 175) {
#line 1637
          while (1) {
#line 1637
            break;
          }
        }
      }
#line 1651
      tmp___1 = bcd_to_int((unsigned int )single_toc.lead_out_start_msf[0]);
#line 1651
      sony_toc.lead_out_start_msf[0] = (unsigned char )tmp___1;
#line 1653
      tmp___2 = bcd_to_int((unsigned int )single_toc.lead_out_start_msf[1]);
#line 1653
      sony_toc.lead_out_start_msf[1] = (unsigned char )tmp___2;
#line 1655
      tmp___3 = bcd_to_int((unsigned int )single_toc.lead_out_start_msf[2]);
#line 1655
      sony_toc.lead_out_start_msf[2] = (unsigned char )tmp___3;
#line 1657
      single_toc.lead_out_start_lba = msf_to_log(sony_toc.lead_out_start_msf);
#line 1657
      sony_toc.lead_out_start_lba = single_toc.lead_out_start_lba;
#line 1663
      if ((int )single_toc.pointb0 != 176) {
#line 1664
        memmove((void *)((char *)(& single_toc) + 27), (void const   *)((char *)(& single_toc) + 18),
                res_size - 18U);
#line 1667
        res_size += 9U;
      } else
#line 1668
      if (res_size > 18U) {
#line 1669
        tmp___4 = bcd_to_int((unsigned int )single_toc.max_start_outer_leadout_msf[0]);
#line 1669
        sony_toc.lead_out_start_msf[0] = (unsigned char )tmp___4;
#line 1673
        tmp___5 = bcd_to_int((unsigned int )single_toc.max_start_outer_leadout_msf[1]);
#line 1673
        sony_toc.lead_out_start_msf[1] = (unsigned char )tmp___5;
#line 1677
        tmp___6 = bcd_to_int((unsigned int )single_toc.max_start_outer_leadout_msf[2]);
#line 1677
        sony_toc.lead_out_start_msf[2] = (unsigned char )tmp___6;
#line 1681
        sony_toc.lead_out_start_lba = msf_to_log(sony_toc.lead_out_start_msf);
      }
#line 1685
      if ((int )single_toc.pointb1 != 177) {
#line 1686
        memmove((void *)((char *)(& single_toc) + 36), (void const   *)((char *)(& single_toc) + 27),
                res_size - 27U);
#line 1689
        res_size += 9U;
      }
#line 1691
      if ((int )single_toc.pointb2 != 178) {
#line 1692
        memmove((void *)((char *)(& single_toc) + 45), (void const   *)((char *)(& single_toc) + 36),
                res_size - 36U);
#line 1695
        res_size += 9U;
      }
#line 1697
      if ((int )single_toc.pointb3 != 179) {
#line 1698
        memmove((void *)((char *)(& single_toc) + 54), (void const   *)((char *)(& single_toc) + 45),
                res_size - 45U);
#line 1701
        res_size += 9U;
      }
#line 1703
      if ((int )single_toc.pointb4 != 180) {
#line 1704
        memmove((void *)((char *)(& single_toc) + 63), (void const   *)((char *)(& single_toc) + 54),
                res_size - 54U);
#line 1707
        res_size += 9U;
      }
#line 1709
      if ((int )single_toc.pointc0 != 192) {
#line 1710
        memmove((void *)((char *)(& single_toc) + 72), (void const   *)((char *)(& single_toc) + 63),
                res_size - 63U);
#line 1713
        res_size += 9U;
      }
#line 1769
      if ((int )single_toc.disk_type == 16) {
#line 1769
        if ((int )single_toc.first_track_num == 2) {
#line 1769
          if ((int )single_toc.last_track_num == 2) {
#line 1772
            sony_toc.tracks[totaltracks].address = (unsigned char)1;
#line 1773
            sony_toc.tracks[totaltracks].control = (unsigned char)4;
#line 1774
            sony_toc.tracks[totaltracks].track = (unsigned char)1;
#line 1775
            sony_toc.tracks[totaltracks].track_start_msf[0] = (unsigned char)0;
#line 1777
            sony_toc.tracks[totaltracks].track_start_msf[1] = (unsigned char)2;
#line 1779
            sony_toc.tracks[totaltracks].track_start_msf[2] = (unsigned char)0;
#line 1781
            maxt = 1;
#line 1781
            mint = maxt;
#line 1782
            totaltracks ++;
          } else {
#line 1769
            goto _L___2;
          }
        } else {
#line 1769
          goto _L___2;
        }
      } else {
        _L___2: /* CIL Label */ 
#line 1787
        i = 0;
#line 1787
        while (1) {
#line 1787
          tmp___11 = bcd_to_int((unsigned int )single_toc.last_track_num);
#line 1787
          tmp___12 = bcd_to_int((unsigned int )single_toc.first_track_num);
#line 1787
          if (! ((unsigned int )i < (1U + tmp___11) - tmp___12)) {
#line 1787
            break;
          }
#line 1795
          sony_toc.tracks[totaltracks].address = single_toc.tracks[i].address;
#line 1798
          sony_toc.tracks[totaltracks].control = single_toc.tracks[i].control;
#line 1801
          tmp___7 = bcd_to_int((unsigned int )single_toc.tracks[i].track);
#line 1801
          sony_toc.tracks[totaltracks].track = (unsigned char )tmp___7;
#line 1805
          tmp___8 = bcd_to_int((unsigned int )single_toc.tracks[i].track_start_msf[0]);
#line 1805
          sony_toc.tracks[totaltracks].track_start_msf[0] = (unsigned char )tmp___8;
#line 1810
          tmp___9 = bcd_to_int((unsigned int )single_toc.tracks[i].track_start_msf[1]);
#line 1810
          sony_toc.tracks[totaltracks].track_start_msf[1] = (unsigned char )tmp___9;
#line 1815
          tmp___10 = bcd_to_int((unsigned int )single_toc.tracks[i].track_start_msf[2]);
#line 1815
          sony_toc.tracks[totaltracks].track_start_msf[2] = (unsigned char )tmp___10;
#line 1820
          if (i == 0) {
#line 1821
            single_toc.start_track_lba = msf_to_log(sony_toc.tracks[totaltracks].track_start_msf);
          }
#line 1827
          if (mint > (int )sony_toc.tracks[totaltracks].track) {
#line 1830
            mint = (int )sony_toc.tracks[totaltracks].track;
          }
#line 1834
          if (maxt < (int )sony_toc.tracks[totaltracks].track) {
#line 1837
            maxt = (int )sony_toc.tracks[totaltracks].track;
          }
#line 1787
          i ++;
#line 1787
          totaltracks ++;
        }
      }
#line 1843
      sony_toc.first_track_num = (unsigned char )mint;
#line 1844
      sony_toc.last_track_num = (unsigned char )maxt;
#line 1851
      sony_toc.disk_type = single_toc.disk_type;
#line 1852
      sony_toc.sessions = (unsigned char )session;
#line 1855
      if (session == 1) {
#line 1856
        single_toc.start_track_lba = 0U;
      }
#line 1857
      sony_toc.start_track_lba = single_toc.start_track_lba;
#line 1860
      if (session > 1) {
#line 1860
        if ((int )single_toc.pointb0 == 176) {
#line 1860
          if (sony_toc.lead_out_start_lba == single_toc.lead_out_start_lba) {
#line 1863
            break;
          }
        }
      }
#line 1867
      if (session > 40) {
#line 1868
        printk("<5>CDU31A: too many sessions: %d\n", session);
#line 1870
        break;
      }
#line 1872
      session ++;
    }
#line 1874
    sony_toc.track_entries = (unsigned int )totaltracks;
#line 1876
    sony_toc.tracks[totaltracks].address = single_toc.address2;
#line 1877
    sony_toc.tracks[totaltracks].control = single_toc.control2;
#line 1878
    sony_toc.tracks[totaltracks].track = (unsigned char)170;
#line 1879
    sony_toc.tracks[totaltracks].track_start_msf[0] = sony_toc.lead_out_start_msf[0];
#line 1881
    sony_toc.tracks[totaltracks].track_start_msf[1] = sony_toc.lead_out_start_msf[1];
#line 1883
    sony_toc.tracks[totaltracks].track_start_msf[2] = sony_toc.lead_out_start_msf[2];
#line 1886
    sony_toc_read = 1;
#line 1888
    while (1) {
#line 1888
      break;
    }
  }
#line 1893
  while (1) {
#line 1893
    break;
  }
#line 1894
  return;
}
}
#line 1901 "cdu31a.c"
static int scd_get_last_session(struct cdrom_device_info *cdi , struct cdrom_multisession *ms_info ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 1904
  if ((unsigned long )ms_info == (unsigned long )((void *)0)) {
#line 1905
    return (1);
  }
#line 1907
  if (! sony_toc_read) {
#line 1908
    tmp = down_interruptible(& sony_sem);
#line 1908
    if (tmp) {
#line 1909
      return (-512);
    }
#line 1910
    sony_get_toc();
#line 1911
    up(& sony_sem);
  }
#line 1914
  ms_info->addr_format = (__u8 )1;
#line 1915
  ms_info->addr.lba = (int )sony_toc.start_track_lba;
#line 1916
  if ((int )sony_toc.disk_type == 32) {
#line 1916
    tmp___0 = 1;
  } else
#line 1916
  if ((int )sony_toc.disk_type == 16) {
#line 1916
    tmp___0 = 1;
  } else {
#line 1916
    tmp___0 = 0;
  }
#line 1916
  ms_info->xa_flag = (__u8 )tmp___0;
#line 1919
  return (0);
}
}
#line 1925 "cdu31a.c"
static int find_track(int track ) 
{ 
  int i ;

  {
#line 1929
  i = 0;
#line 1929
  while ((unsigned int )i <= sony_toc.track_entries) {
#line 1930
    if ((int )sony_toc.tracks[i].track == track) {
#line 1931
      return (i);
    }
#line 1929
    i ++;
  }
#line 1935
  return (-1);
}
}
#line 1942 "cdu31a.c"
static int read_subcode(void) 
{ 
  unsigned int res_size ;
  unsigned char *tmp ;
  unsigned int tmp___0 ;
  unsigned int tmp___1 ;
  unsigned int tmp___2 ;
  unsigned int tmp___3 ;
  unsigned int tmp___4 ;
  unsigned int tmp___5 ;
  unsigned int tmp___6 ;
  unsigned int tmp___7 ;

  {
#line 1947
  do_sony_cd_cmd((unsigned char)33, (unsigned char *)((void *)0), 0U, (unsigned char *)(& last_sony_subcode),
                 & res_size);
#line 1950
  if (res_size < 2U) {
#line 1952
    tmp = translate_error(last_sony_subcode.exec_status[1]);
#line 1952
    printk("<3>CDU31A: Sony CDROM error %s (read_subcode)\n", tmp);
#line 1954
    return (-5);
  } else
#line 1950
  if (((int )last_sony_subcode.exec_status[0] & 240) == 32) {
#line 1952
    tmp = translate_error(last_sony_subcode.exec_status[1]);
#line 1952
    printk("<3>CDU31A: Sony CDROM error %s (read_subcode)\n", tmp);
#line 1954
    return (-5);
  }
#line 1957
  tmp___0 = bcd_to_int((unsigned int )last_sony_subcode.track_num);
#line 1957
  last_sony_subcode.track_num = (unsigned char )tmp___0;
#line 1959
  tmp___1 = bcd_to_int((unsigned int )last_sony_subcode.index_num);
#line 1959
  last_sony_subcode.index_num = (unsigned char )tmp___1;
#line 1961
  tmp___2 = bcd_to_int((unsigned int )last_sony_subcode.abs_msf[0]);
#line 1961
  last_sony_subcode.abs_msf[0] = (unsigned char )tmp___2;
#line 1963
  tmp___3 = bcd_to_int((unsigned int )last_sony_subcode.abs_msf[1]);
#line 1963
  last_sony_subcode.abs_msf[1] = (unsigned char )tmp___3;
#line 1965
  tmp___4 = bcd_to_int((unsigned int )last_sony_subcode.abs_msf[2]);
#line 1965
  last_sony_subcode.abs_msf[2] = (unsigned char )tmp___4;
#line 1968
  tmp___5 = bcd_to_int((unsigned int )last_sony_subcode.rel_msf[0]);
#line 1968
  last_sony_subcode.rel_msf[0] = (unsigned char )tmp___5;
#line 1970
  tmp___6 = bcd_to_int((unsigned int )last_sony_subcode.rel_msf[1]);
#line 1970
  last_sony_subcode.rel_msf[1] = (unsigned char )tmp___6;
#line 1972
  tmp___7 = bcd_to_int((unsigned int )last_sony_subcode.rel_msf[2]);
#line 1972
  last_sony_subcode.rel_msf[2] = (unsigned char )tmp___7;
#line 1974
  return (0);
}
}
#line 1981 "cdu31a.c"
static int scd_get_mcn(struct cdrom_device_info *cdi , struct cdrom_mcn *mcn ) 
{ 
  unsigned char resbuffer[16] ;
  unsigned char *mcnp ;
  unsigned char *resp ;
  unsigned int res_size ;
  int tmp ;
  unsigned char *tmp___0 ;
  unsigned char *tmp___1 ;
  unsigned char *tmp___2 ;
  unsigned char *tmp___3 ;
  unsigned char *tmp___4 ;
  unsigned char *tmp___5 ;
  unsigned char *tmp___6 ;
  unsigned char *tmp___7 ;
  unsigned char *tmp___8 ;
  unsigned char *tmp___9 ;
  unsigned char *tmp___10 ;
  unsigned char *tmp___11 ;
  unsigned char *tmp___12 ;
  unsigned char *tmp___13 ;
  unsigned char *tmp___14 ;
  unsigned char *tmp___15 ;
  unsigned char *tmp___16 ;
  unsigned char *tmp___17 ;
  unsigned char *tmp___18 ;

  {
#line 1985
  mcnp = mcn->medium_catalog_number;
#line 1986
  resp = resbuffer + 3;
#line 1989
  memset((void *)(mcn->medium_catalog_number), 0, 14U);
#line 1990
  tmp = down_interruptible(& sony_sem);
#line 1990
  if (tmp) {
#line 1991
    return (-512);
  }
#line 1992
  do_sony_cd_cmd((unsigned char)34, (unsigned char *)((void *)0), 0U, resbuffer, & res_size);
#line 1994
  up(& sony_sem);
#line 1995
  if (! (res_size < 2U)) {
#line 1995
    if (! (((int )resbuffer[0] & 240) == 32)) {
#line 1998
      tmp___0 = mcnp;
#line 1998
      mcnp ++;
#line 1998
      *tmp___0 = (unsigned char )(((int )*resp >> 4) + 48);
#line 1999
      tmp___1 = mcnp;
#line 1999
      mcnp ++;
#line 1999
      tmp___2 = resp;
#line 1999
      resp ++;
#line 1999
      *tmp___1 = (unsigned char )(((int )*tmp___2 & 15) + 48);
#line 2000
      tmp___3 = mcnp;
#line 2000
      mcnp ++;
#line 2000
      *tmp___3 = (unsigned char )(((int )*resp >> 4) + 48);
#line 2001
      tmp___4 = mcnp;
#line 2001
      mcnp ++;
#line 2001
      tmp___5 = resp;
#line 2001
      resp ++;
#line 2001
      *tmp___4 = (unsigned char )(((int )*tmp___5 & 15) + 48);
#line 2002
      tmp___6 = mcnp;
#line 2002
      mcnp ++;
#line 2002
      *tmp___6 = (unsigned char )(((int )*resp >> 4) + 48);
#line 2003
      tmp___7 = mcnp;
#line 2003
      mcnp ++;
#line 2003
      tmp___8 = resp;
#line 2003
      resp ++;
#line 2003
      *tmp___7 = (unsigned char )(((int )*tmp___8 & 15) + 48);
#line 2004
      tmp___9 = mcnp;
#line 2004
      mcnp ++;
#line 2004
      *tmp___9 = (unsigned char )(((int )*resp >> 4) + 48);
#line 2005
      tmp___10 = mcnp;
#line 2005
      mcnp ++;
#line 2005
      tmp___11 = resp;
#line 2005
      resp ++;
#line 2005
      *tmp___10 = (unsigned char )(((int )*tmp___11 & 15) + 48);
#line 2006
      tmp___12 = mcnp;
#line 2006
      mcnp ++;
#line 2006
      *tmp___12 = (unsigned char )(((int )*resp >> 4) + 48);
#line 2007
      tmp___13 = mcnp;
#line 2007
      mcnp ++;
#line 2007
      tmp___14 = resp;
#line 2007
      resp ++;
#line 2007
      *tmp___13 = (unsigned char )(((int )*tmp___14 & 15) + 48);
#line 2008
      tmp___15 = mcnp;
#line 2008
      mcnp ++;
#line 2008
      *tmp___15 = (unsigned char )(((int )*resp >> 4) + 48);
#line 2009
      tmp___16 = mcnp;
#line 2009
      mcnp ++;
#line 2009
      tmp___17 = resp;
#line 2009
      resp ++;
#line 2009
      *tmp___16 = (unsigned char )(((int )*tmp___17 & 15) + 48);
#line 2010
      tmp___18 = mcnp;
#line 2010
      mcnp ++;
#line 2010
      *tmp___18 = (unsigned char )(((int )*resp >> 4) + 48);
    }
  }
#line 2012
  *mcnp = (unsigned char )'\000';
#line 2013
  return (0);
}
}
#line 2024 "cdu31a.c"
static int sony_get_subchnl_info(struct cdrom_subchnl *schi ) 
{ 
  int tmp ;
  int tmp___0 ;
  unsigned int tmp___1 ;
  unsigned int tmp___2 ;

  {
#line 2027
  while (1) {
#line 2027
    tmp = handle_sony_cd_attention();
#line 2027
    if (! tmp) {
#line 2027
      break;
    }
  }
#line 2029
  sony_get_toc();
#line 2030
  if (! sony_toc_read) {
#line 2031
    return (-5);
  }
#line 2034
  switch (sony_audio_status) {
  case (int volatile   )17: 
  case (int volatile   )21: 
#line 2037
  tmp___0 = read_subcode();
#line 2037
  if (tmp___0 < 0) {
#line 2038
    return (-5);
  }
#line 2040
  break;
  case (int volatile   )19: 
  case (int volatile   )18: 
#line 2044
  break;
  default: 
#line 2055
  return (-5);
  }
#line 2058
  schi->cdsc_audiostatus = (__u8 )sony_audio_status;
#line 2059
  schi->cdsc_adr = last_sony_subcode.address;
#line 2060
  schi->cdsc_ctrl = last_sony_subcode.control;
#line 2061
  schi->cdsc_trk = last_sony_subcode.track_num;
#line 2062
  schi->cdsc_ind = last_sony_subcode.index_num;
#line 2063
  if ((int )schi->cdsc_format == 2) {
#line 2064
    schi->cdsc_absaddr.msf.minute = last_sony_subcode.abs_msf[0];
#line 2066
    schi->cdsc_absaddr.msf.second = last_sony_subcode.abs_msf[1];
#line 2068
    schi->cdsc_absaddr.msf.frame = last_sony_subcode.abs_msf[2];
#line 2071
    schi->cdsc_reladdr.msf.minute = last_sony_subcode.rel_msf[0];
#line 2073
    schi->cdsc_reladdr.msf.second = last_sony_subcode.rel_msf[1];
#line 2075
    schi->cdsc_reladdr.msf.frame = last_sony_subcode.rel_msf[2];
  } else
#line 2077
  if ((int )schi->cdsc_format == 1) {
#line 2078
    tmp___1 = msf_to_log(last_sony_subcode.abs_msf);
#line 2078
    schi->cdsc_absaddr.lba = (int )tmp___1;
#line 2080
    tmp___2 = msf_to_log(last_sony_subcode.rel_msf);
#line 2080
    schi->cdsc_reladdr.lba = (int )tmp___2;
  }
#line 2084
  return (0);
}
}
#line 2091 "cdu31a.c"
static void read_audio_data(char *buffer , unsigned char *res_reg , int *res_size ) 
{ 
  unsigned long retry_count ;
  int result_read ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
#line 2098
  *(res_reg + 0) = (unsigned char)0;
#line 2099
  *(res_reg + 1) = (unsigned char)0;
#line 2100
  *res_size = 0;
#line 2101
  result_read = 0;
#line 2104
  retry_count = jiffies + 1000UL;
  continue_read_audio_wait: 
#line 2106
  while (1) {
#line 2106
    if ((long )jiffies - (long )retry_count < 0L) {
#line 2106
      tmp___0 = is_data_ready();
#line 2106
      if (tmp___0) {
#line 2106
        break;
      } else {
#line 2106
        tmp___1 = is_result_ready();
#line 2106
        if (tmp___1) {
#line 2106
          break;
        } else
#line 2106
        if (result_read) {
#line 2106
          break;
        }
      }
    } else {
#line 2106
      break;
    }
#line 2108
    while (1) {
#line 2108
      tmp = handle_sony_cd_attention();
#line 2108
      if (! tmp) {
#line 2108
        break;
      }
    }
#line 2110
    sony_sleep();
  }
#line 2112
  tmp___6 = is_data_ready();
#line 2112
  if (tmp___6) {
#line 2139
    clear_data_ready();
#line 2142
    if (sony_raw_data_mode) {
#line 2143
      insb((unsigned int )sony_cd_read_reg, (void *)(buffer + 12), 2340UL);
    } else {
#line 2147
      insb((unsigned int )sony_cd_read_reg, (void *)buffer, 2352UL);
    }
#line 2151
    if (! result_read) {
#line 2153
      retry_count = jiffies + 1000UL;
#line 2154
      while (1) {
#line 2154
        if ((long )jiffies - (long )retry_count < 0L) {
#line 2154
          tmp___4 = is_result_ready();
#line 2154
          if (tmp___4) {
#line 2154
            break;
          }
        } else {
#line 2154
          break;
        }
#line 2156
        while (1) {
#line 2156
          tmp___3 = handle_sony_cd_attention();
#line 2156
          if (! tmp___3) {
#line 2156
            break;
          }
        }
#line 2158
        sony_sleep();
      }
#line 2161
      tmp___5 = is_result_ready();
#line 2161
      if (tmp___5) {
#line 2169
        get_result(res_reg, (unsigned int *)res_size);
      } else {
#line 2162
        while (1) {
#line 2162
          break;
        }
#line 2163
        *(res_reg + 0) = (unsigned char)32;
#line 2164
        *(res_reg + 1) = (unsigned char)1;
#line 2165
        *res_size = 2;
#line 2166
        abort_read();
#line 2167
        return;
      }
    }
#line 2173
    if (((int )*(res_reg + 0) & 240) == 80) {
#line 2174
      if (! ((int )*(res_reg + 0) == 80)) {
#line 2174
        if (! ((int )*(res_reg + 0) == 84)) {
#line 2174
          if (! ((int )*(res_reg + 0) == 85)) {
#line 2174
            if (! ((int )*(res_reg + 0) == 89)) {
#line 2180
              printk("<3>CDU31A: Data block error: 0x%x\n", (int )*(res_reg + 0));
#line 2182
              *(res_reg + 0) = (unsigned char)32;
#line 2183
              *(res_reg + 1) = (unsigned char)3;
#line 2184
              *res_size = 2;
            }
          }
        }
      }
    } else
#line 2186
    if (((int )*(res_reg + 0) & 240) != 32) {
#line 2189
      printk("<5>CDU31A: Invalid block status: 0x%x\n", (int )*(res_reg + 0));
#line 2191
      restart_on_error();
#line 2192
      *(res_reg + 0) = (unsigned char)32;
#line 2193
      *(res_reg + 1) = (unsigned char)3;
#line 2194
      *res_size = 2;
    }
  } else {
#line 2113
    tmp___2 = is_result_ready();
#line 2113
    if (tmp___2) {
#line 2113
      if (! result_read) {
#line 2114
        get_result(res_reg, (unsigned int *)res_size);
#line 2117
        if (((int )*(res_reg + 0) & 240) == 80) {
#line 2118
          result_read = 1;
#line 2119
          goto continue_read_audio_wait;
        } else
#line 2122
        if (((int )*(res_reg + 0) & 240) != 32) {
#line 2123
          printk("<4>CDU31A: Got result that should have been error: %d\n", (int )*(res_reg + 0));
#line 2126
          *(res_reg + 0) = (unsigned char)32;
#line 2127
          *(res_reg + 1) = (unsigned char)3;
#line 2128
          *res_size = 2;
        }
#line 2130
        abort_read();
      } else {
#line 2113
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
#line 2132
      while (1) {
#line 2132
        break;
      }
#line 2133
      *(res_reg + 0) = (unsigned char)32;
#line 2134
      *(res_reg + 1) = (unsigned char)1;
#line 2135
      *res_size = 2;
#line 2136
      abort_read();
    }
  }
#line 2197
  return;
}
}
#line 2201 "cdu31a.c"
static int read_audio(struct cdrom_read_audio *ra ) 
{ 
  int retval ;
  unsigned char params[2] ;
  unsigned char res_reg[12] ;
  unsigned int res_size ;
  unsigned int cframe ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  unsigned char *tmp___2 ;
  unsigned long tmp___3 ;
  unsigned char *tmp___4 ;
  unsigned long tmp___5 ;
  unsigned char *tmp___6 ;

  {
#line 2209
  tmp = down_interruptible(& sony_sem);
#line 2209
  if (tmp) {
#line 2210
    return (-512);
  }
#line 2211
  if (! sony_spun_up) {
#line 2212
    scd_spinup();
  }
#line 2215
  params[0] = (unsigned char)0;
#line 2216
  params[1] = (unsigned char )(6 | sony_raw_data_mode);
#line 2217
  do_sony_cd_cmd((unsigned char)16, params, 2U, res_reg, & res_size);
#line 2219
  if (res_size < 2U) {
#line 2220
    printk("<3>CDU31A: Unable to set decode params: 0x%2.2x\n", (int )res_reg[1]);
#line 2222
    retval = -5;
#line 2223
    goto out_up;
  } else
#line 2219
  if (((int )res_reg[0] & 240) == 32) {
#line 2220
    printk("<3>CDU31A: Unable to set decode params: 0x%2.2x\n", (int )res_reg[1]);
#line 2222
    retval = -5;
#line 2223
    goto out_up;
  }
#line 2230
  retval = 0;
#line 2231
  tmp___0 = start_request((unsigned int )ra->addr.lba, (unsigned int )ra->nframes);
#line 2231
  if (tmp___0) {
#line 2232
    retval = -5;
#line 2233
    goto exit_read_audio;
  }
#line 2237
  cframe = 0U;
#line 2238
  while (cframe < (unsigned int )ra->nframes) {
#line 2239
    read_audio_data(audio_buffer, res_reg, (int *)(& res_size));
#line 2240
    if (((int )res_reg[0] & 240) == 32) {
#line 2241
      if ((int )res_reg[1] == 3) {
#line 2242
        printk("<3>CDU31A: Data error on audio sector %d\n", (unsigned int )ra->addr.lba + cframe);
      } else
#line 2245
      if ((int )res_reg[1] == 64) {
#line 2247
        if (sony_raw_data_mode) {
#line 2247
          sony_raw_data_mode = 0;
        } else {
#line 2247
          sony_raw_data_mode = 1;
        }
#line 2251
        params[0] = (unsigned char)0;
#line 2252
        params[1] = (unsigned char )(6 | sony_raw_data_mode);
#line 2253
        do_sony_cd_cmd((unsigned char)16, params, 2U, res_reg, & res_size);
#line 2256
        if (res_size < 2U) {
#line 2258
          printk("<3>CDU31A: Unable to set decode params: 0x%2.2x\n", (int )res_reg[1]);
#line 2261
          retval = -5;
#line 2262
          goto exit_read_audio;
        } else
#line 2256
        if (((int )res_reg[0] & 240) == 32) {
#line 2258
          printk("<3>CDU31A: Unable to set decode params: 0x%2.2x\n", (int )res_reg[1]);
#line 2261
          retval = -5;
#line 2262
          goto exit_read_audio;
        }
#line 2266
        tmp___1 = start_request((unsigned int )ra->addr.lba + cframe, (unsigned int )ra->nframes - cframe);
#line 2266
        if (tmp___1) {
#line 2269
          retval = -5;
#line 2270
          goto exit_read_audio;
        }
#line 2276
        read_audio_data(audio_buffer, res_reg, (int *)(& res_size));
#line 2278
        if (((int )res_reg[0] & 240) == 32) {
#line 2279
          if ((int )res_reg[1] == 3) {
#line 2281
            printk("<3>CDU31A: Data error on audio sector %d\n", (unsigned int )ra->addr.lba + cframe);
          } else {
#line 2286
            tmp___2 = translate_error(res_reg[1]);
#line 2286
            printk("<3>CDU31A: Error reading audio data on sector %d: %s\n", (unsigned int )ra->addr.lba + cframe,
                   tmp___2);
#line 2290
            retval = -5;
#line 2291
            goto exit_read_audio;
          }
        } else {
#line 2293
          tmp___3 = copy_to_user((void *)(ra->buf + 2352U * cframe), (void const   *)(audio_buffer),
                                 2352UL);
#line 2293
          if (tmp___3) {
#line 2298
            retval = -14;
#line 2299
            goto exit_read_audio;
          }
        }
      } else {
#line 2302
        tmp___4 = translate_error(res_reg[1]);
#line 2302
        printk("<3>CDU31A: Error reading audio data on sector %d: %s\n", (unsigned int )ra->addr.lba + cframe,
               tmp___4);
#line 2306
        retval = -5;
#line 2307
        goto exit_read_audio;
      }
    } else {
#line 2309
      tmp___5 = copy_to_user((void *)(ra->buf + 2352U * cframe), (void const   *)(audio_buffer),
                             2352UL);
#line 2309
      if (tmp___5) {
#line 2312
        retval = -14;
#line 2313
        goto exit_read_audio;
      }
    }
#line 2316
    cframe ++;
  }
#line 2319
  get_result(res_reg, & res_size);
#line 2320
  if (((int )res_reg[0] & 240) == 32) {
#line 2321
    tmp___6 = translate_error(res_reg[1]);
#line 2321
    printk("<3>CDU31A: Error return from audio read: %s\n", tmp___6);
#line 2323
    retval = -5;
#line 2324
    goto exit_read_audio;
  }
  exit_read_audio: 
#line 2330
  params[0] = (unsigned char)0;
#line 2331
  if (! sony_xa_mode) {
#line 2332
    params[1] = (unsigned char)15;
  } else {
#line 2334
    params[1] = (unsigned char)7;
  }
#line 2336
  do_sony_cd_cmd((unsigned char)16, params, 2U, res_reg, & res_size);
#line 2338
  if (res_size < 2U) {
#line 2339
    printk("<3>CDU31A: Unable to reset decode params: 0x%2.2x\n", (int )res_reg[1]);
#line 2341
    retval = -5;
  } else
#line 2338
  if (((int )res_reg[0] & 240) == 32) {
#line 2339
    printk("<3>CDU31A: Unable to reset decode params: 0x%2.2x\n", (int )res_reg[1]);
#line 2341
    retval = -5;
  }
  out_up: 
#line 2345
  up(& sony_sem);
#line 2347
  return (retval);
}
}
#line 2350 "cdu31a.c"
static int do_sony_cd_cmd_chk(char const   *name , unsigned char cmd , unsigned char *params ,
                              unsigned int num_params , unsigned char *result_buffer ,
                              unsigned int *result_size ) 
{ 
  unsigned char *tmp ;

  {
#line 2357
  do_sony_cd_cmd(cmd, params, num_params, result_buffer, result_size);
#line 2359
  if (*result_size < 2U) {
#line 2360
    tmp = translate_error(*(result_buffer + 1));
#line 2360
    printk("<3>CDU31A: Error %s (CDROM%s)\n", tmp, name);
#line 2362
    return (-5);
  } else
#line 2359
  if (((int )*(result_buffer + 0) & 240) == 32) {
#line 2360
    tmp = translate_error(*(result_buffer + 1));
#line 2360
    printk("<3>CDU31A: Error %s (CDROM%s)\n", tmp, name);
#line 2362
    return (-5);
  }
#line 2364
  return (0);
}
}
#line 2371 "cdu31a.c"
static int scd_tray_move(struct cdrom_device_info *cdi , int position ) 
{ 
  int retval ;
  int tmp ;
  unsigned char res_reg[12] ;
  unsigned int res_size ;
  int tmp___0 ;

  {
#line 2375
  tmp = down_interruptible(& sony_sem);
#line 2375
  if (tmp) {
#line 2376
    return (-512);
  }
#line 2377
  if (position == 1) {
#line 2381
    do_sony_cd_cmd((unsigned char)65, (unsigned char *)((void *)0), 0U, res_reg, & res_size);
#line 2383
    do_sony_cd_cmd((unsigned char)82, (unsigned char *)((void *)0), 0U, res_reg, & res_size);
#line 2386
    sony_audio_status = (int volatile   )0;
#line 2387
    retval = do_sony_cd_cmd_chk("EJECT", (unsigned char)80, (unsigned char *)((void *)0),
                                0U, res_reg, & res_size);
  } else {
#line 2390
    tmp___0 = scd_spinup();
#line 2390
    if (0 == tmp___0) {
#line 2391
      sony_spun_up = 1;
    }
#line 2392
    retval = 0;
  }
#line 2394
  up(& sony_sem);
#line 2395
  return (retval);
}
}
#line 2401 "cdu31a.c"
static int scd_audio_ioctl(struct cdrom_device_info *cdi , unsigned int cmd , void *arg ) 
{ 
  unsigned char res_reg[12] ;
  unsigned int res_size ;
  unsigned char params[7] ;
  int i ;
  int retval ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  unsigned int tmp___2 ;
  unsigned int tmp___3 ;
  unsigned int tmp___4 ;
  unsigned int tmp___5 ;
  unsigned int tmp___6 ;
  unsigned int tmp___7 ;
  int tmp___8 ;
  unsigned int tmp___9 ;
  int tmp___10 ;
  unsigned int tmp___11 ;
  unsigned int tmp___12 ;
  unsigned int tmp___13 ;
  struct cdrom_tochdr *hdr ;
  struct cdrom_tocentry *entry ;
  int track_idx ;
  unsigned char *msf_val ;
  unsigned int tmp___14 ;
  struct cdrom_ti *ti ;
  int track_idx___0 ;
  unsigned int tmp___15 ;
  unsigned int tmp___16 ;
  unsigned int tmp___17 ;
  unsigned int tmp___18 ;
  unsigned int tmp___19 ;
  unsigned int tmp___20 ;
  unsigned char *tmp___21 ;
  unsigned int tmp___22 ;
  unsigned int tmp___23 ;
  unsigned int tmp___24 ;
  struct cdrom_volctrl *volctrl ;

  {
#line 2409
  tmp = down_interruptible(& sony_sem);
#line 2409
  if (tmp) {
#line 2410
    return (-512);
  }
#line 2411
  switch (cmd) {
  case 21256U: 
#line 2413
  retval = do_sony_cd_cmd_chk("START", (unsigned char)81, (unsigned char *)((void *)0),
                              0U, res_reg, & res_size);
#line 2415
  break;
  case 21255U: 
#line 2418
  do_sony_cd_cmd((unsigned char)65, (unsigned char *)((void *)0), 0U, res_reg, & res_size);
#line 2425
  sony_audio_status = (int volatile   )21;
#line 2426
  retval = do_sony_cd_cmd_chk("STOP", (unsigned char)82, (unsigned char *)((void *)0),
                              0U, res_reg, & res_size);
#line 2428
  break;
  case 21249U: 
#line 2431
  tmp___0 = do_sony_cd_cmd_chk("PAUSE", (unsigned char)65, (unsigned char *)((void *)0),
                               0U, res_reg, & res_size);
#line 2431
  if (tmp___0) {
#line 2434
    retval = -5;
#line 2435
    break;
  }
#line 2438
  tmp___1 = read_subcode();
#line 2438
  if (tmp___1 < 0) {
#line 2439
    retval = -5;
#line 2440
    break;
  }
#line 2442
  cur_pos_msf[0] = (unsigned char volatile   )last_sony_subcode.abs_msf[0];
#line 2443
  cur_pos_msf[1] = (unsigned char volatile   )last_sony_subcode.abs_msf[1];
#line 2444
  cur_pos_msf[2] = (unsigned char volatile   )last_sony_subcode.abs_msf[2];
#line 2445
  sony_audio_status = (int volatile   )18;
#line 2446
  retval = 0;
#line 2447
  break;
  case 21250U: 
#line 2450
  if (sony_audio_status != (int volatile   )18) {
#line 2451
    retval = -22;
#line 2452
    break;
  }
#line 2455
  do_sony_cd_cmd((unsigned char)81, (unsigned char *)((void *)0), 0U, res_reg, & res_size);
#line 2459
  tmp___2 = int_to_bcd((unsigned int )cur_pos_msf[0]);
#line 2459
  params[1] = (unsigned char )tmp___2;
#line 2460
  tmp___3 = int_to_bcd((unsigned int )cur_pos_msf[1]);
#line 2460
  params[2] = (unsigned char )tmp___3;
#line 2461
  tmp___4 = int_to_bcd((unsigned int )cur_pos_msf[2]);
#line 2461
  params[3] = (unsigned char )tmp___4;
#line 2462
  tmp___5 = int_to_bcd((unsigned int )final_pos_msf[0]);
#line 2462
  params[4] = (unsigned char )tmp___5;
#line 2463
  tmp___6 = int_to_bcd((unsigned int )final_pos_msf[1]);
#line 2463
  params[5] = (unsigned char )tmp___6;
#line 2464
  tmp___7 = int_to_bcd((unsigned int )final_pos_msf[2]);
#line 2464
  params[6] = (unsigned char )tmp___7;
#line 2465
  params[0] = (unsigned char)3;
#line 2466
  tmp___8 = do_sony_cd_cmd_chk("RESUME", (unsigned char)64, params, 7U, res_reg, & res_size);
#line 2466
  if (tmp___8 < 0) {
#line 2469
    retval = -5;
#line 2470
    break;
  }
#line 2472
  sony_audio_status = (int volatile   )17;
#line 2473
  retval = 0;
#line 2474
  break;
  case 21251U: 
#line 2477
  do_sony_cd_cmd((unsigned char)81, (unsigned char *)((void *)0), 0U, res_reg, & res_size);
#line 2481
  i = 1;
#line 2481
  while (i < 7) {
#line 2482
    tmp___9 = int_to_bcd((unsigned int )*((unsigned char *)arg + (i - 1)));
#line 2482
    params[i] = (unsigned char )tmp___9;
#line 2481
    i ++;
  }
#line 2485
  params[0] = (unsigned char)3;
#line 2486
  tmp___10 = do_sony_cd_cmd_chk("PLAYMSF", (unsigned char)64, params, 7U, res_reg,
                                & res_size);
#line 2486
  if (tmp___10 < 0) {
#line 2489
    retval = -5;
#line 2490
    break;
  }
#line 2494
  tmp___11 = bcd_to_int((unsigned int )params[4]);
#line 2494
  final_pos_msf[0] = (unsigned char volatile   )tmp___11;
#line 2495
  tmp___12 = bcd_to_int((unsigned int )params[5]);
#line 2495
  final_pos_msf[1] = (unsigned char volatile   )tmp___12;
#line 2496
  tmp___13 = bcd_to_int((unsigned int )params[6]);
#line 2496
  final_pos_msf[2] = (unsigned char volatile   )tmp___13;
#line 2497
  sony_audio_status = (int volatile   )17;
#line 2498
  retval = 0;
#line 2499
  break;
  case 21253U: 
#line 2505
  sony_get_toc();
#line 2506
  if (! sony_toc_read) {
#line 2507
    retval = -5;
#line 2508
    break;
  }
#line 2511
  hdr = (struct cdrom_tochdr *)arg;
#line 2512
  hdr->cdth_trk0 = sony_toc.first_track_num;
#line 2513
  hdr->cdth_trk1 = sony_toc.last_track_num;
#line 2515
  retval = 0;
#line 2516
  break;
  case 21254U: 
#line 2522
  msf_val = (unsigned char *)((void *)0);
#line 2524
  sony_get_toc();
#line 2525
  if (! sony_toc_read) {
#line 2526
    retval = -5;
#line 2527
    break;
  }
#line 2530
  entry = (struct cdrom_tocentry *)arg;
#line 2532
  track_idx = find_track((int )entry->cdte_track);
#line 2533
  if (track_idx < 0) {
#line 2534
    retval = -22;
#line 2535
    break;
  }
#line 2538
  entry->cdte_adr = sony_toc.tracks[track_idx].address;
#line 2540
  entry->cdte_ctrl = sony_toc.tracks[track_idx].control;
#line 2542
  msf_val = sony_toc.tracks[track_idx].track_start_msf;
#line 2546
  if ((int )entry->cdte_format == 1) {
#line 2547
    tmp___14 = msf_to_log(msf_val);
#line 2547
    entry->cdte_addr.lba = (int )tmp___14;
  } else
#line 2548
  if ((int )entry->cdte_format == 2) {
#line 2549
    entry->cdte_addr.msf.minute = *msf_val;
#line 2550
    entry->cdte_addr.msf.second = *(msf_val + 1);
#line 2552
    entry->cdte_addr.msf.frame = *(msf_val + 2);
  }
#line 2556
  retval = 0;
#line 2557
  break;
  case 21252U: 
#line 2561
  ti = (struct cdrom_ti *)arg;
#line 2564
  sony_get_toc();
#line 2565
  if (! sony_toc_read) {
#line 2566
    retval = -5;
#line 2567
    break;
  }
#line 2570
  if ((int )ti->cdti_trk0 < (int )sony_toc.first_track_num) {
#line 2573
    retval = -22;
#line 2574
    break;
  } else
#line 2570
  if ((int )ti->cdti_trk0 > (int )sony_toc.last_track_num) {
#line 2573
    retval = -22;
#line 2574
    break;
  } else
#line 2570
  if ((int )ti->cdti_trk1 < (int )ti->cdti_trk0) {
#line 2573
    retval = -22;
#line 2574
    break;
  }
#line 2577
  track_idx___0 = find_track((int )ti->cdti_trk0);
#line 2578
  if (track_idx___0 < 0) {
#line 2579
    retval = -22;
#line 2580
    break;
  }
#line 2582
  tmp___15 = int_to_bcd((unsigned int )sony_toc.tracks[track_idx___0].track_start_msf[0]);
#line 2582
  params[1] = (unsigned char )tmp___15;
#line 2585
  tmp___16 = int_to_bcd((unsigned int )sony_toc.tracks[track_idx___0].track_start_msf[1]);
#line 2585
  params[2] = (unsigned char )tmp___16;
#line 2588
  tmp___17 = int_to_bcd((unsigned int )sony_toc.tracks[track_idx___0].track_start_msf[2]);
#line 2588
  params[3] = (unsigned char )tmp___17;
#line 2596
  if ((int )ti->cdti_trk1 >= (int )sony_toc.last_track_num) {
#line 2597
    track_idx___0 = find_track(170);
  } else {
#line 2599
    track_idx___0 = find_track((int )ti->cdti_trk1 + 1);
  }
#line 2601
  if (track_idx___0 < 0) {
#line 2602
    retval = -22;
#line 2603
    break;
  }
#line 2605
  tmp___18 = int_to_bcd((unsigned int )sony_toc.tracks[track_idx___0].track_start_msf[0]);
#line 2605
  params[4] = (unsigned char )tmp___18;
#line 2608
  tmp___19 = int_to_bcd((unsigned int )sony_toc.tracks[track_idx___0].track_start_msf[1]);
#line 2608
  params[5] = (unsigned char )tmp___19;
#line 2611
  tmp___20 = int_to_bcd((unsigned int )sony_toc.tracks[track_idx___0].track_start_msf[2]);
#line 2611
  params[6] = (unsigned char )tmp___20;
#line 2614
  params[0] = (unsigned char)3;
#line 2616
  do_sony_cd_cmd((unsigned char)81, (unsigned char *)((void *)0), 0U, res_reg, & res_size);
#line 2619
  do_sony_cd_cmd((unsigned char)64, params, 7U, res_reg, & res_size);
#line 2622
  if (res_size < 2U) {
#line 2624
    printk("<3>CDU31A: Params: %x %x %x %x %x %x %x\n", (int )params[0], (int )params[1],
           (int )params[2], (int )params[3], (int )params[4], (int )params[5], (int )params[6]);
#line 2629
    tmp___21 = translate_error(res_reg[1]);
#line 2629
    printk("<3>CDU31A: Error %s (CDROMPLAYTRKIND)\n", tmp___21);
#line 2632
    retval = -5;
#line 2633
    break;
  } else
#line 2622
  if (((int )res_reg[0] & 240) == 32) {
#line 2624
    printk("<3>CDU31A: Params: %x %x %x %x %x %x %x\n", (int )params[0], (int )params[1],
           (int )params[2], (int )params[3], (int )params[4], (int )params[5], (int )params[6]);
#line 2629
    tmp___21 = translate_error(res_reg[1]);
#line 2629
    printk("<3>CDU31A: Error %s (CDROMPLAYTRKIND)\n", tmp___21);
#line 2632
    retval = -5;
#line 2633
    break;
  }
#line 2637
  tmp___22 = bcd_to_int((unsigned int )params[4]);
#line 2637
  final_pos_msf[0] = (unsigned char volatile   )tmp___22;
#line 2638
  tmp___23 = bcd_to_int((unsigned int )params[5]);
#line 2638
  final_pos_msf[1] = (unsigned char volatile   )tmp___23;
#line 2639
  tmp___24 = bcd_to_int((unsigned int )params[6]);
#line 2639
  final_pos_msf[2] = (unsigned char volatile   )tmp___24;
#line 2640
  sony_audio_status = (int volatile   )17;
#line 2641
  retval = 0;
#line 2642
  break;
  case 21258U: 
#line 2647
  volctrl = (struct cdrom_volctrl *)arg;
#line 2650
  params[0] = (unsigned char)4;
#line 2651
  params[1] = volctrl->channel0;
#line 2652
  params[2] = volctrl->channel1;
#line 2653
  retval = do_sony_cd_cmd_chk("VOLCTRL", (unsigned char)16, params, 3U, res_reg, & res_size);
#line 2657
  break;
  case 21259U: 
#line 2660
  retval = sony_get_subchnl_info((struct cdrom_subchnl *)arg);
#line 2661
  break;
  default: 
#line 2664
  retval = -22;
#line 2665
  break;
  }
#line 2667
  up(& sony_sem);
#line 2668
  return (retval);
}
}
#line 2671 "cdu31a.c"
static int scd_dev_ioctl(struct cdrom_device_info *cdi , unsigned int cmd , unsigned long arg ) 
{ 
  void *argp ;
  int retval ;
  int tmp ;
  struct cdrom_read_audio ra ;
  unsigned long tmp___0 ;
  int tmp___1 ;

  {
#line 2674
  argp = (void *)arg;
#line 2677
  tmp = down_interruptible(& sony_sem);
#line 2677
  if (tmp) {
#line 2678
    return (-512);
  }
#line 2679
  switch (cmd) {
  case 21262U: 
#line 2686
  sony_get_toc();
#line 2687
  if (! sony_toc_read) {
#line 2688
    retval = -5;
#line 2689
    break;
  }
#line 2692
  tmp___0 = copy_from_user((void *)(& ra), argp, sizeof(ra));
#line 2692
  if (tmp___0) {
#line 2693
    retval = -14;
#line 2694
    break;
  }
#line 2697
  if (ra.nframes == 0) {
#line 2698
    retval = 0;
#line 2699
    break;
  }
#line 2702
  tmp___1 = access_ok(1, (void const   *)ra.buf, (unsigned long )(2352 * ra.nframes));
#line 2702
  if (! tmp___1) {
#line 2704
    return (-14);
  }
#line 2706
  if ((int )ra.addr_format == 1) {
#line 2707
    if ((unsigned int )ra.addr.lba >= sony_toc.lead_out_start_lba) {
#line 2711
      retval = -22;
#line 2712
      break;
    } else
#line 2707
    if ((unsigned int )(ra.addr.lba + ra.nframes) >= sony_toc.lead_out_start_lba) {
#line 2711
      retval = -22;
#line 2712
      break;
    }
  } else
#line 2714
  if ((int )ra.addr_format == 2) {
#line 2715
    if ((int )ra.addr.msf.minute >= 75) {
#line 2718
      retval = -22;
#line 2719
      break;
    } else
#line 2715
    if ((int )ra.addr.msf.second >= 60) {
#line 2718
      retval = -22;
#line 2719
      break;
    } else
#line 2715
    if ((int )ra.addr.msf.frame >= 75) {
#line 2718
      retval = -22;
#line 2719
      break;
    }
#line 2722
    ra.addr.lba = ((int )ra.addr.msf.minute * 4500 + (int )ra.addr.msf.second * 75) + (int )ra.addr.msf.frame;
#line 2725
    if ((unsigned int )ra.addr.lba >= sony_toc.lead_out_start_lba) {
#line 2729
      retval = -22;
#line 2730
      break;
    } else
#line 2725
    if ((unsigned int )(ra.addr.lba + ra.nframes) >= sony_toc.lead_out_start_lba) {
#line 2729
      retval = -22;
#line 2730
      break;
    }
#line 2736
    ra.addr.lba -= 150;
  } else {
#line 2738
    retval = -22;
#line 2739
    break;
  }
#line 2742
  retval = read_audio(& ra);
#line 2743
  break;
#line 2745
  retval = 0;
#line 2746
  break;
  default: 
#line 2749
  retval = -22;
  }
#line 2751
  up(& sony_sem);
#line 2752
  return (retval);
}
}
#line 2755 "cdu31a.c"
static int scd_spinup(void) 
{ 
  unsigned char res_reg[12] ;
  unsigned int res_size ;
  int num_spin_ups ;
  unsigned char *tmp ;
  unsigned char *tmp___0 ;

  {
#line 2761
  num_spin_ups = 0;
  respinup_on_open: 
#line 2764
  do_sony_cd_cmd((unsigned char)81, (unsigned char *)((void *)0), 0U, res_reg, & res_size);
#line 2768
  if (res_size < 2U) {
#line 2769
    tmp = translate_error(res_reg[1]);
#line 2769
    printk("<3>CDU31A: %s error (scd_open, spin up)\n", tmp);
#line 2771
    return (1);
  } else
#line 2768
  if ((int )res_reg[0] != 0) {
#line 2768
    if ((int )res_reg[1] != 0) {
#line 2769
      tmp = translate_error(res_reg[1]);
#line 2769
      printk("<3>CDU31A: %s error (scd_open, spin up)\n", tmp);
#line 2771
      return (1);
    }
  }
#line 2774
  do_sony_cd_cmd((unsigned char)48, (unsigned char *)((void *)0), 0U, res_reg, & res_size);
#line 2778
  if (res_size < 2U) {
#line 2778
    goto _L;
  } else
#line 2778
  if ((int )res_reg[0] != 0) {
#line 2778
    if ((int )res_reg[1] != 0) {
      _L: /* CIL Label */ 
#line 2780
      if ((int )res_reg[1] == 42) {
#line 2782
        return (0);
      } else
#line 2780
      if ((int )res_reg[1] == 0) {
#line 2782
        return (0);
      }
#line 2787
      if ((int )res_reg[1] == 34) {
#line 2787
        if (num_spin_ups < 3) {
#line 2789
          num_spin_ups ++;
#line 2790
          goto respinup_on_open;
        }
      }
#line 2793
      tmp___0 = translate_error(res_reg[1]);
#line 2793
      printk("<3>CDU31A: Error %s (scd_open, read toc)\n", tmp___0);
#line 2795
      do_sony_cd_cmd((unsigned char)82, (unsigned char *)((void *)0), 0U, res_reg,
                     & res_size);
#line 2797
      return (1);
    }
  }
#line 2799
  return (0);
}
}
#line 2806 "cdu31a.c"
static int scd_open(struct cdrom_device_info *cdi , int purpose ) 
{ 
  unsigned char res_reg[12] ;
  unsigned int res_size ;
  unsigned char params[2] ;
  int tmp ;

  {
#line 2812
  if (purpose == 1) {
#line 2814
    sony_usage ++;
#line 2815
    return (0);
  }
#line 2818
  if (sony_usage == 0U) {
#line 2819
    tmp = scd_spinup();
#line 2819
    if (tmp != 0) {
#line 2820
      return (-5);
    }
#line 2821
    sony_get_toc();
#line 2822
    if (! sony_toc_read) {
#line 2823
      do_sony_cd_cmd((unsigned char)82, (unsigned char *)((void *)0), 0U, res_reg,
                     & res_size);
#line 2825
      return (-5);
    }
#line 2831
    if ((int )sony_toc.disk_type != 0) {
#line 2831
      if (! is_double_speed) {
#line 2833
        params[0] = (unsigned char)0;
#line 2834
        params[1] = (unsigned char)7;
#line 2835
        do_sony_cd_cmd((unsigned char)16, params, 2U, res_reg, & res_size);
#line 2837
        if (res_size < 2U) {
#line 2839
          printk("<4>CDU31A: Unable to set XA params: 0x%2.2x\n", (int )res_reg[1]);
        } else
#line 2837
        if (((int )res_reg[0] & 240) == 32) {
#line 2839
          printk("<4>CDU31A: Unable to set XA params: 0x%2.2x\n", (int )res_reg[1]);
        }
#line 2842
        sony_xa_mode = 1;
      } else {
#line 2831
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 2845
    if (sony_xa_mode) {
#line 2846
      params[0] = (unsigned char)0;
#line 2847
      params[1] = (unsigned char)15;
#line 2848
      do_sony_cd_cmd((unsigned char)16, params, 2U, res_reg, & res_size);
#line 2850
      if (res_size < 2U) {
#line 2852
        printk("<4>CDU31A: Unable to reset XA params: 0x%2.2x\n", (int )res_reg[1]);
      } else
#line 2850
      if (((int )res_reg[0] & 240) == 32) {
#line 2852
        printk("<4>CDU31A: Unable to reset XA params: 0x%2.2x\n", (int )res_reg[1]);
      }
#line 2855
      sony_xa_mode = 0;
    }
#line 2858
    sony_spun_up = 1;
  }
#line 2861
  sony_usage ++;
#line 2863
  return (0);
}
}
#line 2871 "cdu31a.c"
static void scd_release(struct cdrom_device_info *cdi ) 
{ 
  unsigned char res_reg[12] ;
  unsigned int res_size ;

  {
#line 2873
  if (sony_usage == 1U) {
#line 2877
    do_sony_cd_cmd((unsigned char)82, (unsigned char *)((void *)0), 0U, res_reg, & res_size);
#line 2880
    sony_spun_up = 0;
  }
#line 2882
  sony_usage --;
#line 2883
  return;
}
}
#line 2885 "cdu31a.c"
static struct cdrom_device_ops scd_dops  = 
#line 2885
     {& scd_open, & scd_release, & scd_drive_status, & scd_media_changed, & scd_tray_move,
    & scd_lock_door, & scd_select_speed, (int (*)(struct cdrom_device_info * , int  ))0,
    & scd_get_last_session, & scd_get_mcn, & scd_reset, & scd_audio_ioctl, & scd_dev_ioctl,
    (int const   )4079, 1, (int (*)(struct cdrom_device_info * , struct packet_command * ))0};
#line 2905 "cdu31a.c"
static struct cdrom_device_info scd_info  = 
#line 2905
     {& scd_dops, (struct cdrom_device_info *)0, (struct gendisk *)0, (void *)0, 0,
    2, 1, 0, 0U, 0, {(char )'c', (char )'d', (char )'u', (char )'3', (char )'1', (char )'a',
                     (char )'\000'}, (unsigned char)0, (unsigned char)0, 0, (unsigned char)0,
    (unsigned char)0, (unsigned short)0, 0, (int (*)(struct cdrom_device_info * ))0,
    0};
#line 2912 "cdu31a.c"
static int scd_block_open(struct inode *inode , struct file *file ) 
{ 
  int tmp ;

  {
#line 2914
  tmp = cdrom_open(& scd_info, inode, file);
#line 2914
  return (tmp);
}
}
#line 2917 "cdu31a.c"
static int scd_block_release(struct inode *inode , struct file *file ) 
{ 
  int tmp ;

  {
#line 2919
  tmp = cdrom_release(& scd_info, file);
#line 2919
  return (tmp);
}
}
#line 2922 "cdu31a.c"
static int scd_block_ioctl(struct inode *inode , struct file *file , unsigned int cmd ,
                           unsigned long arg ) 
{ 
  int retval ;

  {
#line 2931
  switch (cmd) {
  case 21257U: 
#line 2933
  scd_lock_door(& scd_info, 0);
#line 2934
  retval = scd_tray_move(& scd_info, 1);
#line 2935
  break;
  case 21273U: 
#line 2937
  retval = scd_tray_move(& scd_info, 0);
#line 2938
  break;
  default: 
#line 2940
  retval = cdrom_ioctl(file, & scd_info, inode, cmd, arg);
  }
#line 2942
  return (retval);
}
}
#line 2945 "cdu31a.c"
static int scd_block_media_changed(struct gendisk *disk ) 
{ 
  int tmp ;

  {
#line 2947
  tmp = cdrom_media_changed(& scd_info);
#line 2947
  return (tmp);
}
}
#line 2950 "cdu31a.c"
static struct block_device_operations scd_bdops  = 
#line 2950
     {& scd_block_open, & scd_block_release, & scd_block_ioctl, (long (*)(struct file * ,
                                                                        unsigned int  ,
                                                                        unsigned long  ))0,
    (long (*)(struct file * , unsigned int  , unsigned long  ))0, (int (*)(struct block_device * ,
                                                                           sector_t  ,
                                                                           unsigned long * ))0,
    & scd_block_media_changed, (int (*)(struct gendisk * ))0, (int (*)(struct block_device * ,
                                                                       struct hd_geometry * ))0,
    (struct module *)0};
#line 2959 "cdu31a.c"
static struct gendisk *scd_gendisk  ;
#line 2962 "cdu31a.c"
static char *load_mech[4]  = {      (char *)"caddy",      (char *)"tray",      (char *)"pop-up",      (char *)"unknown"};
#line 2965 "cdu31a.c"
static int get_drive_configuration(unsigned short base_io , unsigned char *res_reg ,
                                   unsigned int *res_size ) 
{ 
  unsigned long retry_count ;
  struct resource *tmp ;
  int tmp___0 ;
  unsigned char tmp___1 ;

  {
#line 2972
  tmp = request_region((unsigned long )base_io, 4UL, "cdu31a");
#line 2972
  if (! tmp) {
#line 2973
    return (0);
  }
#line 2976
  cdu31a_port = (unsigned int )base_io;
#line 2979
  sony_cd_cmd_reg = (unsigned short volatile   )cdu31a_port;
#line 2980
  sony_cd_param_reg = (unsigned short volatile   )(cdu31a_port + 1U);
#line 2981
  sony_cd_write_reg = (unsigned short volatile   )(cdu31a_port + 2U);
#line 2982
  sony_cd_control_reg = (unsigned short volatile   )(cdu31a_port + 3U);
#line 2983
  sony_cd_status_reg = (unsigned short volatile   )cdu31a_port;
#line 2984
  sony_cd_result_reg = (unsigned short volatile   )(cdu31a_port + 1U);
#line 2985
  sony_cd_read_reg = (unsigned short volatile   )(cdu31a_port + 2U);
#line 2986
  sony_cd_fifost_reg = (unsigned short volatile   )(cdu31a_port + 3U);
#line 2993
  tmp___1 = read_status_register();
#line 2993
  if ((int )tmp___1 != 255) {
#line 2998
    reset_drive();
#line 2999
    retry_count = jiffies + 100UL;
#line 3000
    while (1) {
#line 3000
      if ((long )jiffies - (long )retry_count < 0L) {
#line 3000
        tmp___0 = is_attention();
#line 3000
        if (tmp___0) {
#line 3000
          break;
        }
      } else {
#line 3000
        break;
      }
#line 3002
      sony_sleep();
    }
#line 3016
    do_sony_cd_cmd((unsigned char)0, (unsigned char *)((void *)0), 0U, res_reg, res_size);
#line 3019
    if (*res_size <= 2U) {
#line 3020
      goto out_err;
    } else
#line 3019
    if (((int )*(res_reg + 0) & 240) != 0) {
#line 3020
      goto out_err;
    }
#line 3021
    return (1);
  }
#line 3025
  *(res_reg + 0) = (unsigned char)32;
  out_err: 
#line 3027
  release_region((unsigned long )cdu31a_port, 4UL);
#line 3028
  cdu31a_port = 0U;
#line 3029
  return (0);
}
}
#line 3068 "cdu31a.c"
int cdu31a_init(void) 
{ 
  struct s_sony_drive_config drive_config ;
  struct gendisk *disk ;
  int deficiency ;
  unsigned int res_size ;
  char msg[255] ;
  char buf[40] ;
  int i ;
  int tmp_irq ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 3072
  deficiency = 0;
#line 3086
  if (sony_pas_init) {
#line 3087
    outb((unsigned char)188, 39425U);
#line 3088
    outb((unsigned char)226, 39425U);
  }
#line 3092
  if (cdu31a_port == 65535U) {
#line 3093
    goto errout3;
  }
#line 3095
  if (cdu31a_port != 0U) {
#line 3097
    tmp_irq = cdu31a_irq;
#line 3098
    cdu31a_irq = 0;
#line 3099
    tmp = get_drive_configuration((unsigned short )cdu31a_port, drive_config.exec_status,
                                  & res_size);
#line 3099
    if (! tmp) {
#line 3102
      goto errout3;
    }
#line 3103
    cdu31a_irq = tmp_irq;
  } else {
#line 3105
    cdu31a_irq = 0;
#line 3106
    i = 0;
#line 3106
    while (cdu31a_addresses[i].base) {
#line 3107
      tmp___0 = get_drive_configuration(cdu31a_addresses[i].base, drive_config.exec_status,
                                        & res_size);
#line 3107
      if (tmp___0) {
#line 3110
        cdu31a_irq = (int )cdu31a_addresses[i].int_num;
#line 3111
        break;
      }
#line 3106
      i ++;
    }
#line 3114
    if (! cdu31a_port) {
#line 3115
      goto errout3;
    }
  }
#line 3118
  tmp___1 = register_blkdev(15U, "cdu31a");
#line 3118
  if (tmp___1) {
#line 3119
    goto errout2;
  }
#line 3121
  disk = alloc_disk(1);
#line 3122
  if (! disk) {
#line 3123
    goto errout1;
  }
#line 3124
  disk->major = 15;
#line 3125
  disk->first_minor = 0;
#line 3126
  sprintf(disk->disk_name, "cdu31a");
#line 3127
  disk->fops = & scd_bdops;
#line 3128
  disk->flags = 8;
#line 3130
  if ((int )drive_config.hw_config[0] & 16) {
#line 3131
    is_double_speed = 1;
  }
#line 3133
  tmp_irq = cdu31a_irq;
#line 3134
  cdu31a_irq = 0;
#line 3136
  sony_speed = is_double_speed;
#line 3137
  set_drive_params(sony_speed);
#line 3139
  cdu31a_irq = tmp_irq;
#line 3141
  if (cdu31a_irq > 0) {
#line 3142
    tmp___2 = request_irq((unsigned int )cdu31a_irq, & cdu31a_interrupt, 536870912UL,
                          "cdu31a", (void *)0);
#line 3142
    if (tmp___2) {
#line 3145
      printk("<4>CDU31A: Unable to grab IRQ%d for the CDU31A driver\n", cdu31a_irq);
#line 3147
      cdu31a_irq = 0;
    }
  }
#line 3151
  sprintf(msg, "Sony I/F CDROM : %8.8s %16.16s %8.8s\n", drive_config.vendor_id, drive_config.product_id,
          drive_config.product_rev_level);
#line 3155
  sprintf(buf, "  Capabilities: %s", load_mech[(int )drive_config.hw_config[0] & 3]);
#line 3157
  strcat(msg, (char const   *)(buf));
#line 3158
  if ((int )drive_config.hw_config[1] & 1) {
#line 3159
    strcat(msg, ", audio");
  } else {
#line 3161
    deficiency |= 256;
  }
#line 3162
  if ((int )drive_config.hw_config[0] & 4) {
#line 3163
    strcat(msg, ", eject");
  } else {
#line 3165
    deficiency |= 2;
  }
#line 3166
  if ((int )drive_config.hw_config[0] & 8) {
#line 3167
    strcat(msg, ", LED");
  }
#line 3168
  if ((int )drive_config.hw_config[1] & 2) {
#line 3169
    strcat(msg, ", elec. Vol");
  }
#line 3170
  if ((int )drive_config.hw_config[1] & 4) {
#line 3171
    strcat(msg, ", sep. Vol");
  }
#line 3172
  if (is_double_speed) {
#line 3173
    strcat(msg, ", double speed");
  } else {
#line 3175
    deficiency |= 8;
  }
#line 3176
  if (cdu31a_irq > 0) {
#line 3177
    sprintf(buf, ", irq %d", cdu31a_irq);
#line 3178
    strcat(msg, (char const   *)(buf));
  }
#line 3180
  strcat(msg, "\n");
#line 3181
  printk("<6>CDU31A: %s", msg);
#line 3183
  cdu31a_queue = blk_init_queue(& do_cdu31a_request, & cdu31a_lock);
#line 3184
  if (! cdu31a_queue) {
#line 3185
    goto errout0;
  }
#line 3186
  blk_queue_hardsect_size(cdu31a_queue, (unsigned short)2048);
#line 3188
  init_timer(& cdu31a_abort_timer);
#line 3189
  cdu31a_abort_timer.function = & handle_abort_timeout;
#line 3191
  scd_info.mask = deficiency;
#line 3192
  scd_gendisk = disk;
#line 3193
  tmp___3 = register_cdrom(& scd_info);
#line 3193
  if (tmp___3) {
#line 3194
    goto err;
  }
#line 3195
  disk->queue = cdu31a_queue;
#line 3196
  add_disk(disk);
#line 3198
  disk_changed = (char)1;
#line 3199
  return (0);
  err: 
#line 3202
  blk_cleanup_queue(cdu31a_queue);
  errout0: 
#line 3204
  if (cdu31a_irq) {
#line 3205
    free_irq((unsigned int )cdu31a_irq, (void *)0);
  }
#line 3206
  printk("<3>CDU31A: Unable to register with Uniform cdrom driver\n");
#line 3207
  put_disk(disk);
  errout1: 
#line 3209
  tmp___4 = unregister_blkdev(15U, "cdu31a");
#line 3209
  if (tmp___4) {
#line 3210
    printk("<4>CDU31A: Can\'t unregister block device\n");
  }
  errout2: 
#line 3213
  release_region((unsigned long )cdu31a_port, 4UL);
  errout3: 
#line 3215
  return (-5);
}
}
#line 3219 "cdu31a.c"
static void cdu31a_exit(void) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 3221
  del_gendisk(scd_gendisk);
#line 3222
  put_disk(scd_gendisk);
#line 3223
  tmp = unregister_cdrom(& scd_info);
#line 3223
  if (tmp) {
#line 3224
    printk("<4>CDU31A: Can\'t unregister from Uniform cdrom driver\n");
#line 3226
    return;
  }
#line 3228
  tmp___0 = unregister_blkdev(15U, "cdu31a");
#line 3228
  if (tmp___0 == -22) {
#line 3229
    printk("<4>CDU31A: Can\'t unregister\n");
#line 3230
    return;
  }
#line 3233
  blk_cleanup_queue(cdu31a_queue);
#line 3235
  if (cdu31a_irq > 0) {
#line 3236
    free_irq((unsigned int )cdu31a_irq, (void *)0);
  }
#line 3238
  release_region((unsigned long )cdu31a_port, 4UL);
#line 3239
  printk("<6>CDU31A: module released.\n");
#line 3240
  return;
}
}
#line 3243 "cdu31a.c"
int (*_ddv_tmp_init)(void)  =    & cdu31a_init;
#line 3245 "cdu31a.c"
void (*_ddv_tmp_exit)(void)  =    & cdu31a_exit;
#line 3247 "cdu31a.c"
char _ddv_module_license[4]  = {      (char )'G',      (char )'P',      (char )'L',      (char )'\000'};
#line 3248 "cdu31a.c"
int _ddv_module_param_major  =    15;
#line 4 "__main.c"
int main(void) 
{ 


  {
#line 6
  _ddv_module_init = & cdu31a_init;
#line 7
  _ddv_module_exit = & cdu31a_exit;
#line 8
  call_ddv();
#line 10
  return (0);
}
}
#line 1 "manage.o"
#pragma merger("0","/tmp/cil-6AH8C_XZ.i","")
#line 4 "/usr/local/ddv/models/con2/src/linux/kernel/irq/manage.c"
int request_irq(unsigned int irq , irqreturn_t (*handler)(int  , void * , struct pt_regs * ) ,
                unsigned long irqflags , char const   *devname , void *dev_id ) 
{ 
  int tmp ;

  {
#line 7
  tmp = nondet_int();
#line 7
  if (tmp) {
#line 8
    registered_irq[irq].handler = handler;
#line 9
    registered_irq[irq].dev_id = dev_id;
#line 11
    return (0);
  } else {
#line 13
    return (-1);
  }
}
}
#line 17 "/usr/local/ddv/models/con2/src/linux/kernel/irq/manage.c"
void free_irq(unsigned int irq , void *dev_id ) 
{ 


  {
#line 19
  registered_irq[irq].handler = (irqreturn_t (*)(int  , void * , struct pt_regs * ))((void *)0);
#line 20
  registered_irq[irq].dev_id = (void *)0;
#line 21
  return;
}
}
#line 1 "misc.o"
#pragma merger("0","/tmp/cil-XqqdI_Me.i","")
#line 40 "/usr/local/ddv/models/con2/include/linux/miscdevice.h"
int misc_register(struct miscdevice *misc ) ;
#line 11 "/usr/local/ddv/models/con2/include/linux/proc_fs.h"
struct proc_dir_entry *proc_root_driver  ;
#line 18 "/usr/local/ddv/models/con2/src/linux/drivers/char/misc.c"
int misc_register(struct miscdevice *misc ) 
{ 
  int i ;
  dev_t dev ;
  int tmp ;

  {
#line 23
  if (fixed_cdev_used < 10) {
#line 24
    i = fixed_cdev_used;
#line 25
    fixed_cdev_used ++;
#line 27
    fixed_cdev[i].owner = (struct module *)0;
#line 28
    fixed_cdev[i].ops = misc->fops;
#line 30
    dev = (dev_t )((10 << 20) | misc->minor);
#line 32
    tmp = cdev_add(& fixed_cdev[i], dev, 0U);
#line 32
    return (tmp);
  } else {
#line 34
    return (-1);
  }
}
}
#line 1 "mutex.o"
#pragma merger("0","/tmp/cil-sXp5trps.i","")
#line 32 "/usr/local/ddv/models/con2/include/ddverify/ddverify.h"
__inline static int assert_context_process(void) 
{ 


  {
#line 34
  return (0);
}
}
#line 32 "/usr/local/ddv/models/con2/include/linux/mutex.h"
__inline void mutex_init(struct mutex *lock ) ;
#line 34
__inline void mutex_lock(struct mutex *lock ) ;
#line 36
__inline void mutex_unlock(struct mutex *lock ) ;
#line 4 "/usr/local/ddv/models/con2/src/linux/kernel/mutex.c"
__inline void mutex_init(struct mutex *lock ) 
{ 


  {
#line 7
  __CPROVER_atomic_begin();
#line 11
  lock->locked = 0;
#line 12
  lock->init = 1;
#line 13
  __CPROVER_atomic_end();
#line 14
  return;
}
}
#line 16 "/usr/local/ddv/models/con2/src/linux/kernel/mutex.c"
__inline void mutex_lock(struct mutex *lock ) 
{ 


  {
#line 27
  while (1) {
#line 29
    __CPROVER_atomic_begin();
#line 30
    if (lock->locked == 0) {
#line 32
      lock->locked = 1;
#line 33
      __CPROVER_atomic_end();
#line 34
      return;
    }
#line 36
    __CPROVER_atomic_end();
  }
}
}
#line 41 "/usr/local/ddv/models/con2/src/linux/kernel/mutex.c"
__inline void mutex_unlock(struct mutex *lock ) 
{ 


  {
#line 44
  __CPROVER_atomic_begin();
#line 45
  assert_context_process();
#line 49
  lock->locked = 0;
#line 50
  __CPROVER_atomic_end();
#line 51
  return;
}
}
#line 1 "page_alloc.o"
#pragma merger("0","/tmp/cil-tj9rpXJ9.i","")
#line 55 "/usr/local/ddv/models/con2/include/linux/gfp.h"
__inline unsigned long __get_free_pages(gfp_t gfp_mask , unsigned int order ) ;
#line 57
__inline unsigned long __get_free_page(gfp_t gfp_mask ) ;
#line 59
__inline unsigned long get_zeroed_page(gfp_t gfp_mask ) ;
#line 70
__inline struct page *alloc_pages(gfp_t gfp_mask , unsigned int order ) ;
#line 72
__inline struct page *alloc_page(gfp_t gfp_mask ) ;
#line 5 "/usr/local/ddv/models/con2/src/linux/mm/page_alloc.c"
__inline unsigned long __get_free_pages(gfp_t gfp_mask , unsigned int order ) 
{ 


  {
#line 8
  if (gfp_mask & 16U) {
#line 9
    assert_context_process();
  }
#line 11
  return (0UL);
}
}
#line 13 "/usr/local/ddv/models/con2/src/linux/mm/page_alloc.c"
__inline unsigned long __get_free_page(gfp_t gfp_mask ) 
{ 


  {
#line 16
  if (gfp_mask & 16U) {
#line 17
    assert_context_process();
  }
#line 19
  return (0UL);
}
}
#line 38 "/usr/local/ddv/models/con2/src/linux/mm/page_alloc.c"
__inline struct page *alloc_pages(gfp_t gfp_mask , unsigned int order ) 
{ 


  {
#line 41
  if (gfp_mask & 16U) {
#line 42
    assert_context_process();
  }
#line 44
  return ((struct page *)0);
}
}
#line 46 "/usr/local/ddv/models/con2/src/linux/mm/page_alloc.c"
__inline struct page *alloc_page(gfp_t gfp_mask ) 
{ 


  {
#line 49
  if (gfp_mask & 16U) {
#line 50
    assert_context_process();
  }
#line 52
  return ((struct page *)0);
}
}
#line 1 "pci.o"
#pragma merger("0","/tmp/cil-KA7ONeAL.i","")
#line 96 "/usr/local/ddv/models/con2/include/linux/ioport.h"
extern struct resource *request_mem_region(unsigned long start , unsigned long len ,
                                           char const   *name ) ;
#line 98
extern void release_mem_region(unsigned long start , unsigned long len ) ;
#line 87 "/usr/local/ddv/models/con2/include/linux/pci.h"
__inline struct pci_dev *pci_get_class(unsigned int class , struct pci_dev *from ) ;
#line 141
__inline int pci_register_driver(struct pci_driver *driver ) ;
#line 143
__inline void pci_unregister_driver(struct pci_driver *driver ) ;
#line 145
__inline int pci_enable_device(struct pci_dev *dev ) ;
#line 152
__inline int pci_request_regions(struct pci_dev *pdev , char const   *res_name ) ;
#line 154
__inline void pci_release_regions(struct pci_dev *pdev ) ;
#line 156
__inline int pci_request_region(struct pci_dev *pdev , int bar , char const   *res_name ) ;
#line 158
__inline void pci_release_region(struct pci_dev *pdev , int bar ) ;
#line 8 "/usr/local/ddv/models/con2/src/linux/pci.c"
__inline int pci_enable_device(struct pci_dev *dev ) 
{ 
  int i ;
  unsigned int tmp ;
  unsigned short tmp___0 ;

  {
#line 12
  i = 0;
#line 12
  while (i < 12) {
#line 13
    dev->resource[i].flags = 256UL;
#line 14
    tmp = nondet_uint();
#line 14
    dev->resource[i].start = (unsigned long )tmp;
#line 15
    tmp___0 = nondet_ushort();
#line 15
    dev->resource[i].end = dev->resource[i].start + (unsigned long )tmp___0;
#line 12
    i ++;
  }
#line 17
  return (0);
}
}
#line 19 "/usr/local/ddv/models/con2/src/linux/pci.c"
__inline struct pci_dev *pci_get_class(unsigned int class , struct pci_dev *from ) 
{ 
  void *tmp ;
  int tmp___0 ;

  {
#line 21
  if ((unsigned long )from == (unsigned long )((void *)0)) {
#line 22
    tmp = malloc((size_t )sizeof(struct pci_dev ));
#line 22
    from = (struct pci_dev *)tmp;
  }
#line 25
  tmp___0 = nondet_int();
#line 25
  if (tmp___0) {
#line 26
    from->vendor = nondet_ushort();
#line 27
    from->device = nondet_ushort();
#line 28
    from->irq = nondet_uint();
#line 29
    __CPROVER_assume(from->irq < 16U);
#line 31
    return (from);
  } else {
#line 33
    return ((struct pci_dev *)((void *)0));
  }
}
}
#line 37 "/usr/local/ddv/models/con2/src/linux/pci.c"
__inline int pci_register_driver(struct pci_driver *driver ) 
{ 
  int tmp ;

  {
#line 39
  tmp = nondet_int();
#line 39
  if (tmp) {
#line 40
    registered_pci_driver.pci_driver = driver;
#line 41
    registered_pci_driver.no_pci_device_id = (unsigned int )(sizeof(driver->id_table) / sizeof(struct pci_device_id ));
#line 42
    registered_pci_driver.dev_initialized = 0;
#line 44
    return (0);
  } else {
#line 46
    return (-1);
  }
}
}
#line 50 "/usr/local/ddv/models/con2/src/linux/pci.c"
__inline void pci_unregister_driver(struct pci_driver *driver ) 
{ 


  {
#line 52
  registered_pci_driver.pci_driver = (struct pci_driver *)((void *)0);
#line 53
  registered_pci_driver.no_pci_device_id = 0U;
#line 54
  return;
}
}
#line 56 "/usr/local/ddv/models/con2/src/linux/pci.c"
__inline void pci_release_region(struct pci_dev *pdev , int bar ) 
{ 
  unsigned long tmp ;
  unsigned long tmp___0 ;
  unsigned long tmp___1 ;

  {
#line 58
  if (pdev->resource[bar].start == 0UL) {
#line 58
    if (pdev->resource[bar].end == pdev->resource[bar].start) {
#line 58
      tmp = 0UL;
    } else {
#line 58
      tmp = (pdev->resource[bar].end - pdev->resource[bar].start) + 1UL;
    }
  } else {
#line 58
    tmp = (pdev->resource[bar].end - pdev->resource[bar].start) + 1UL;
  }
#line 58
  if (tmp == 0UL) {
#line 59
    return;
  }
#line 60
  if (pdev->resource[bar].flags & 256UL) {
#line 61
    if (pdev->resource[bar].start == 0UL) {
#line 61
      if (pdev->resource[bar].end == pdev->resource[bar].start) {
#line 61
        tmp___0 = 0UL;
      } else {
#line 61
        tmp___0 = (pdev->resource[bar].end - pdev->resource[bar].start) + 1UL;
      }
    } else {
#line 61
      tmp___0 = (pdev->resource[bar].end - pdev->resource[bar].start) + 1UL;
    }
#line 61
    release_region(pdev->resource[bar].start, tmp___0);
  } else
#line 63
  if (pdev->resource[bar].flags & 512UL) {
#line 64
    if (pdev->resource[bar].start == 0UL) {
#line 64
      if (pdev->resource[bar].end == pdev->resource[bar].start) {
#line 64
        tmp___1 = 0UL;
      } else {
#line 64
        tmp___1 = (pdev->resource[bar].end - pdev->resource[bar].start) + 1UL;
      }
    } else {
#line 64
      tmp___1 = (pdev->resource[bar].end - pdev->resource[bar].start) + 1UL;
    }
#line 64
    release_mem_region(pdev->resource[bar].start, tmp___1);
  }
#line 66
  return;
}
}
#line 68 "/usr/local/ddv/models/con2/src/linux/pci.c"
__inline int pci_request_region(struct pci_dev *pdev , int bar , char const   *res_name ) 
{ 
  unsigned long tmp ;
  unsigned long tmp___0 ;
  struct resource *tmp___1 ;
  unsigned long tmp___2 ;
  struct resource *tmp___3 ;

  {
#line 70
  if (pdev->resource[bar].start == 0UL) {
#line 70
    if (pdev->resource[bar].end == pdev->resource[bar].start) {
#line 70
      tmp = 0UL;
    } else {
#line 70
      tmp = (pdev->resource[bar].end - pdev->resource[bar].start) + 1UL;
    }
  } else {
#line 70
    tmp = (pdev->resource[bar].end - pdev->resource[bar].start) + 1UL;
  }
#line 70
  if (tmp == 0UL) {
#line 71
    return (0);
  }
#line 73
  if (pdev->resource[bar].flags & 256UL) {
#line 74
    if (pdev->resource[bar].start == 0UL) {
#line 74
      if (pdev->resource[bar].end == pdev->resource[bar].start) {
#line 74
        tmp___0 = 0UL;
      } else {
#line 74
        tmp___0 = (pdev->resource[bar].end - pdev->resource[bar].start) + 1UL;
      }
    } else {
#line 74
      tmp___0 = (pdev->resource[bar].end - pdev->resource[bar].start) + 1UL;
    }
#line 74
    tmp___1 = request_region(pdev->resource[bar].start, tmp___0, res_name);
#line 74
    if (! tmp___1) {
#line 76
      return (-16);
    }
  } else
#line 78
  if (pdev->resource[bar].flags & 512UL) {
#line 79
    if (pdev->resource[bar].start == 0UL) {
#line 79
      if (pdev->resource[bar].end == pdev->resource[bar].start) {
#line 79
        tmp___2 = 0UL;
      } else {
#line 79
        tmp___2 = (pdev->resource[bar].end - pdev->resource[bar].start) + 1UL;
      }
    } else {
#line 79
      tmp___2 = (pdev->resource[bar].end - pdev->resource[bar].start) + 1UL;
    }
#line 79
    tmp___3 = request_mem_region(pdev->resource[bar].start, tmp___2, res_name);
#line 79
    if (! tmp___3) {
#line 81
      return (-16);
    }
  }
#line 84
  return (0);
}
}
#line 87 "/usr/local/ddv/models/con2/src/linux/pci.c"
__inline void pci_release_regions(struct pci_dev *pdev ) 
{ 
  int i ;

  {
#line 91
  i = 0;
#line 91
  while (i < 6) {
#line 92
    pci_release_region(pdev, i);
#line 91
    i ++;
  }
#line 93
  return;
}
}
#line 95 "/usr/local/ddv/models/con2/src/linux/pci.c"
__inline int pci_request_regions(struct pci_dev *pdev , char const   *res_name ) 
{ 
  int i ;
  int tmp ;

  {
#line 99
  i = 0;
#line 99
  while (i < 6) {
#line 100
    tmp = pci_request_region(pdev, i, res_name);
#line 100
    if (tmp) {
#line 101
      goto err_out;
    }
#line 99
    i ++;
  }
#line 102
  return (0);
  err_out: 
#line 105
  while (1) {
#line 105
    i --;
#line 105
    if (! (i >= 0)) {
#line 105
      break;
    }
#line 106
    pci_release_region(pdev, i);
  }
#line 108
  return (-16);
}
}
#line 1 "resource.o"
#pragma merger("0","/tmp/cil-_bb963FQ.i","")
#line 21 "/usr/local/ddv/models/con2/include/ddverify/satabs.h"
extern unsigned char nondet_uchar() ;
#line 22
extern unsigned int nondet_unsigned() ;
#line 10 "/usr/local/ddv/models/con2/include/ddverify/ioport.h"
int ddv_ioport_request_start  ;
#line 11 "/usr/local/ddv/models/con2/include/ddverify/ioport.h"
int ddv_ioport_request_len  ;
#line 6 "/usr/local/ddv/models/con2/src/linux/kernel/resource.c"
struct resource *request_region(unsigned long start , unsigned long len , char const   *name ) 
{ 
  struct resource *resource ;
  void *tmp ;

  {
#line 9
  tmp = malloc((size_t )sizeof(struct resource ));
#line 9
  resource = (struct resource *)tmp;
#line 14
  ddv_ioport_request_start = (int )start;
#line 15
  ddv_ioport_request_len = (int )len;
#line 17
  return (resource);
}
}
#line 20 "/usr/local/ddv/models/con2/src/linux/kernel/resource.c"
void release_region(unsigned long start , unsigned long len ) 
{ 
  unsigned int i ;

  {
#line 22
  i = 0U;
#line 28
  ddv_ioport_request_start = 0;
#line 29
  ddv_ioport_request_len = 0;
#line 30
  return;
}
}
#line 32 "/usr/local/ddv/models/con2/src/linux/kernel/resource.c"
unsigned char inb(unsigned int port ) 
{ 
  int tmp ;
  unsigned char tmp___0 ;

  {
#line 35
  if (port >= (unsigned int )ddv_ioport_request_start) {
#line 35
    if (port < (unsigned int )(ddv_ioport_request_start + ddv_ioport_request_len)) {
#line 35
      tmp = 1;
    } else {
#line 35
      tmp = 0;
    }
  } else {
#line 35
    tmp = 0;
  }
#line 35
  __CPROVER_assert(tmp, "I/O port is requested");
#line 37
  tmp___0 = nondet_uchar();
#line 37
  return (tmp___0);
}
}
#line 40 "/usr/local/ddv/models/con2/src/linux/kernel/resource.c"
void outb(unsigned char byte , unsigned int port ) 
{ 
  int tmp ;

  {
#line 43
  if (port >= (unsigned int )ddv_ioport_request_start) {
#line 43
    if (port < (unsigned int )(ddv_ioport_request_start + ddv_ioport_request_len)) {
#line 43
      tmp = 1;
    } else {
#line 43
      tmp = 0;
    }
  } else {
#line 43
    tmp = 0;
  }
#line 43
  __CPROVER_assert(tmp, "I/O port is requested");
#line 44
  return;
}
}
#line 46 "/usr/local/ddv/models/con2/src/linux/kernel/resource.c"
__inline unsigned short inw(unsigned int port ) 
{ 
  int tmp ;
  unsigned short tmp___0 ;

  {
#line 49
  if (port >= (unsigned int )ddv_ioport_request_start) {
#line 49
    if (port < (unsigned int )(ddv_ioport_request_start + ddv_ioport_request_len)) {
#line 49
      tmp = 1;
    } else {
#line 49
      tmp = 0;
    }
  } else {
#line 49
    tmp = 0;
  }
#line 49
  __CPROVER_assert(tmp, "I/O port is requested");
#line 51
  tmp___0 = nondet_ushort();
#line 51
  return (tmp___0);
}
}
#line 54 "/usr/local/ddv/models/con2/src/linux/kernel/resource.c"
__inline void outw(unsigned short word , unsigned int port ) 
{ 
  int tmp ;

  {
#line 57
  if (port >= (unsigned int )ddv_ioport_request_start) {
#line 57
    if (port < (unsigned int )(ddv_ioport_request_start + ddv_ioport_request_len)) {
#line 57
      tmp = 1;
    } else {
#line 57
      tmp = 0;
    }
  } else {
#line 57
    tmp = 0;
  }
#line 57
  __CPROVER_assert(tmp, "I/O port is requested");
#line 58
  return;
}
}
#line 60 "/usr/local/ddv/models/con2/src/linux/kernel/resource.c"
__inline unsigned int inl(unsigned int port ) 
{ 
  int tmp ;
  unsigned int tmp___0 ;

  {
#line 63
  if (port >= (unsigned int )ddv_ioport_request_start) {
#line 63
    if (port < (unsigned int )(ddv_ioport_request_start + ddv_ioport_request_len)) {
#line 63
      tmp = 1;
    } else {
#line 63
      tmp = 0;
    }
  } else {
#line 63
    tmp = 0;
  }
#line 63
  __CPROVER_assert(tmp, "I/O port is requested");
#line 65
  tmp___0 = nondet_unsigned();
#line 65
  return (tmp___0);
}
}
#line 68 "/usr/local/ddv/models/con2/src/linux/kernel/resource.c"
__inline void outl(unsigned int doubleword , unsigned int port ) 
{ 
  int tmp ;

  {
#line 71
  if (port >= (unsigned int )ddv_ioport_request_start) {
#line 71
    if (port < (unsigned int )(ddv_ioport_request_start + ddv_ioport_request_len)) {
#line 71
      tmp = 1;
    } else {
#line 71
      tmp = 0;
    }
  } else {
#line 71
    tmp = 0;
  }
#line 71
  __CPROVER_assert(tmp, "I/O port is requested");
#line 72
  return;
}
}
#line 74 "/usr/local/ddv/models/con2/src/linux/kernel/resource.c"
__inline unsigned char inb_p(unsigned int port ) 
{ 
  int tmp ;
  unsigned char tmp___0 ;

  {
#line 77
  if (port >= (unsigned int )ddv_ioport_request_start) {
#line 77
    if (port < (unsigned int )(ddv_ioport_request_start + ddv_ioport_request_len)) {
#line 77
      tmp = 1;
    } else {
#line 77
      tmp = 0;
    }
  } else {
#line 77
    tmp = 0;
  }
#line 77
  __CPROVER_assert(tmp, "I/O port is requested");
#line 79
  tmp___0 = nondet_uchar();
#line 79
  return (tmp___0);
}
}
#line 82 "/usr/local/ddv/models/con2/src/linux/kernel/resource.c"
__inline void outb_p(unsigned char byte , unsigned int port ) 
{ 
  int tmp ;

  {
#line 85
  if (port >= (unsigned int )ddv_ioport_request_start) {
#line 85
    if (port < (unsigned int )(ddv_ioport_request_start + ddv_ioport_request_len)) {
#line 85
      tmp = 1;
    } else {
#line 85
      tmp = 0;
    }
  } else {
#line 85
    tmp = 0;
  }
#line 85
  __CPROVER_assert(tmp, "I/O port is requested");
#line 86
  return;
}
}
#line 1 "sched.o"
#pragma merger("0","/tmp/cil-HAF20JpW.i","")
#line 18 "/usr/local/ddv/models/con2/include/ddverify/satabs.h"
extern long nondet_long() ;
#line 45 "/usr/local/ddv/models/con2/include/linux/sched.h"
long schedule_timeout(long timeout ) ;
#line 8 "/usr/local/ddv/models/con2/src/linux/kernel/sched.c"
void schedule(void) 
{ 


  {
#line 10
  assert_context_process();
#line 11
  return;
}
}
#line 13 "/usr/local/ddv/models/con2/src/linux/kernel/sched.c"
long schedule_timeout(long timeout ) 
{ 
  long tmp ;

  {
#line 15
  assert_context_process();
#line 17
  tmp = nondet_long();
#line 17
  return (tmp);
}
}
#line 1 "semaphore.o"
#pragma merger("0","/tmp/cil-5eb7QHdw.i","")
#line 23 "/usr/local/ddv/models/con2/include/asm/semaphore.h"
__inline void sema_init(struct semaphore *sem , int val ) ;
#line 25
__inline void init_MUTEX(struct semaphore *sem ) ;
#line 27
__inline void init_MUTEX_LOCKED(struct semaphore *sem ) ;
#line 29
__inline void down(struct semaphore *sem ) ;
#line 6 "/usr/local/ddv/models/con2/src/linux/kernel/semaphore.c"
__inline void sema_init(struct semaphore *sem , int val ) 
{ 


  {
#line 9
  __CPROVER_atomic_begin();
#line 10
  sem->init = 1;
#line 11
  sem->locked = 0;
#line 12
  __CPROVER_atomic_end();
#line 13
  return;
}
}
#line 15 "/usr/local/ddv/models/con2/src/linux/kernel/semaphore.c"
__inline void init_MUTEX(struct semaphore *sem ) 
{ 


  {
#line 18
  __CPROVER_atomic_begin();
#line 19
  sem->init = 1;
#line 20
  sem->locked = 0;
#line 21
  __CPROVER_atomic_end();
#line 22
  return;
}
}
#line 24 "/usr/local/ddv/models/con2/src/linux/kernel/semaphore.c"
__inline void init_MUTEX_LOCKED(struct semaphore *sem ) 
{ 


  {
#line 27
  __CPROVER_atomic_begin();
#line 28
  sem->init = 1;
#line 29
  sem->locked = 1;
#line 30
  __CPROVER_atomic_end();
#line 31
  return;
}
}
#line 33 "/usr/local/ddv/models/con2/src/linux/kernel/semaphore.c"
__inline void down(struct semaphore *sem ) 
{ 


  {
#line 44
  while (1) {
#line 46
    __CPROVER_atomic_begin();
#line 47
    if (sem->locked == 0) {
#line 49
      sem->locked = 1;
#line 50
      __CPROVER_atomic_end();
#line 51
      return;
    }
#line 53
    __CPROVER_atomic_end();
  }
}
}
#line 58 "/usr/local/ddv/models/con2/src/linux/kernel/semaphore.c"
int down_interruptible(struct semaphore *sem ) 
{ 
  int tmp ;

  {
#line 69
  while (1) {
#line 71
    __CPROVER_atomic_begin();
#line 72
    if (sem->locked == 0) {
#line 74
      sem->locked = 1;
#line 75
      __CPROVER_atomic_end();
#line 76
      return (0);
    }
#line 78
    tmp = nondet_int();
#line 78
    if (tmp) {
#line 79
      __CPROVER_atomic_end();
#line 80
      return (-1);
    }
#line 83
    __CPROVER_atomic_end();
  }
}
}
#line 88 "/usr/local/ddv/models/con2/src/linux/kernel/semaphore.c"
int down_trylock(struct semaphore *sem ) 
{ 


  {
#line 91
  __CPROVER_atomic_begin();
#line 97
  if (sem->locked == 0) {
#line 98
    sem->locked = 1;
#line 99
    __CPROVER_atomic_end();
#line 100
    return (-1);
  }
#line 102
  __CPROVER_atomic_end();
#line 103
  return (0);
}
}
#line 106 "/usr/local/ddv/models/con2/src/linux/kernel/semaphore.c"
void up(struct semaphore *sem ) 
{ 


  {
#line 109
  __CPROVER_atomic_begin();
#line 110
  assert_context_process();
#line 114
  sem->locked = 0;
#line 115
  __CPROVER_atomic_end();
#line 116
  return;
}
}
#line 1 "slab.o"
#pragma merger("0","/tmp/cil-VoE7MPwK.i","")
#line 10 "/usr/local/ddv/models/con2/include/linux/slab.h"
void *kmalloc(size_t size , gfp_t flags ) ;
#line 12
void *kzalloc(size_t size , gfp_t flags ) ;
#line 6 "/usr/local/ddv/models/con2/src/linux/mm/slab.c"
void *kmalloc(size_t size , gfp_t flags ) 
{ 
  void *tmp ;

  {
#line 8
  if (flags & 16U) {
#line 9
    assert_context_process();
  }
#line 12
  tmp = malloc(size);
#line 12
  return (tmp);
}
}
#line 15 "/usr/local/ddv/models/con2/src/linux/mm/slab.c"
void *kzalloc(size_t size , gfp_t flags ) 
{ 
  void *tmp ;

  {
#line 17
  if (flags & 16U) {
#line 18
    assert_context_process();
  }
#line 21
  tmp = malloc(size);
#line 21
  return (tmp);
}
}
#line 1 "softirq.o"
#pragma merger("0","/tmp/cil-xUyerbuy.i","")
#line 50 "/usr/local/ddv/models/con2/include/linux/interrupt.h"
__inline void tasklet_schedule(struct tasklet_struct *t ) ;
#line 65
__inline void tasklet_init(struct tasklet_struct *t , void (*func)(unsigned long  ) ,
                           unsigned long data ) ;
#line 4 "/usr/local/ddv/models/con2/src/linux/kernel/softirq.c"
__inline void tasklet_schedule(struct tasklet_struct *t ) 
{ 
  int i ;
  int next_free ;

  {
#line 7
  next_free = -1;
#line 13
  i = 0;
#line 13
  while (i < 10) {
#line 14
    if ((unsigned long )tasklet_registered[i].tasklet == (unsigned long )((void *)0)) {
#line 15
      next_free = i;
    }
#line 17
    if ((unsigned long )tasklet_registered[i].tasklet == (unsigned long )t) {
#line 17
      if ((int )tasklet_registered[i].is_running == 0) {
#line 19
        return;
      }
    }
#line 13
    i ++;
  }
#line 28
  tasklet_registered[next_free].tasklet = t;
#line 29
  tasklet_registered[next_free].is_running = (unsigned short)0;
#line 30
  return;
}
}
#line 32 "/usr/local/ddv/models/con2/src/linux/kernel/softirq.c"
__inline void tasklet_init(struct tasklet_struct *t , void (*func)(unsigned long  ) ,
                           unsigned long data ) 
{ 


  {
#line 36
  t->count = 0;
#line 37
  t->init = 0;
#line 38
  t->func = func;
#line 39
  t->data = data;
#line 40
  return;
}
}
#line 1 "spinlock.o"
#pragma merger("0","/tmp/cil-t4HK8DhF.i","")
#line 10 "/usr/local/ddv/models/con2/include/linux/spinlock.h"
__inline void spin_lock(spinlock_t *lock ) ;
#line 11
__inline void spin_lock_irqsave(spinlock_t *lock , unsigned long flags ) ;
#line 13
__inline void spin_lock_bh(spinlock_t *lock ) ;
#line 15
__inline void spin_unlock(spinlock_t *lock ) ;
#line 16
__inline void spin_unlock_irqrestore(spinlock_t *lock , unsigned long flags ) ;
#line 18
__inline void spin_unlock_bh(spinlock_t *lock ) ;
#line 4 "/usr/local/ddv/models/con2/src/linux/kernel/spinlock.c"
void spin_lock_init(spinlock_t *lock ) 
{ 


  {
#line 6
  lock->init = 1;
#line 7
  lock->locked = 0;
#line 8
  return;
}
}
#line 10 "/usr/local/ddv/models/con2/src/linux/kernel/spinlock.c"
__inline void spin_lock(spinlock_t *lock ) 
{ 


  {
#line 20
  while (1) {
#line 22
    __CPROVER_atomic_begin();
#line 23
    if (lock->locked == 0) {
#line 25
      lock->locked = 1;
#line 26
      __CPROVER_atomic_end();
#line 27
      return;
    }
#line 29
    __CPROVER_atomic_end();
  }
}
}
#line 34 "/usr/local/ddv/models/con2/src/linux/kernel/spinlock.c"
__inline void spin_lock_irqsave(spinlock_t *lock , unsigned long flags ) 
{ 


  {
#line 44
  while (1) {
#line 46
    __CPROVER_atomic_begin();
#line 47
    if (lock->locked == 0) {
#line 49
      lock->locked = 1;
#line 50
      __CPROVER_atomic_end();
#line 51
      return;
    }
#line 53
    __CPROVER_atomic_end();
  }
}
}
#line 58 "/usr/local/ddv/models/con2/src/linux/kernel/spinlock.c"
void spin_lock_irq(spinlock_t *lock ) 
{ 


  {
#line 68
  while (1) {
#line 70
    __CPROVER_atomic_begin();
#line 71
    if (lock->locked == 0) {
#line 73
      lock->locked = 1;
#line 74
      __CPROVER_atomic_end();
#line 75
      return;
    }
#line 77
    __CPROVER_atomic_end();
  }
}
}
#line 106 "/usr/local/ddv/models/con2/src/linux/kernel/spinlock.c"
__inline void spin_unlock(spinlock_t *lock ) 
{ 


  {
#line 109
  __CPROVER_atomic_begin();
#line 113
  lock->locked = 0;
#line 114
  __CPROVER_atomic_end();
#line 115
  return;
}
}
#line 117 "/usr/local/ddv/models/con2/src/linux/kernel/spinlock.c"
__inline void spin_unlock_irqrestore(spinlock_t *lock , unsigned long flags ) 
{ 


  {
#line 120
  __CPROVER_atomic_begin();
#line 124
  lock->locked = 0;
#line 125
  __CPROVER_atomic_end();
#line 126
  return;
}
}
#line 128 "/usr/local/ddv/models/con2/src/linux/kernel/spinlock.c"
void spin_unlock_irq(spinlock_t *lock ) 
{ 


  {
#line 131
  __CPROVER_atomic_begin();
#line 135
  lock->locked = 0;
#line 136
  __CPROVER_atomic_end();
#line 137
  return;
}
}
#line 1 "tasklet.o"
#pragma merger("0","/tmp/cil-CirswWBL.i","")
#line 3 "/usr/local/ddv/models/con2/src/ddverify/tasklet.c"
void call_tasklet_functions(void) 
{ 
  unsigned int i ;

  {
#line 6
  __CPROVER_assume(i < 10U);
#line 8
  if ((unsigned long )tasklet_registered[i].tasklet != (unsigned long )((void *)0)) {
#line 8
    if ((tasklet_registered[i].tasklet)->count == 0) {
#line 10
      tasklet_registered[i].is_running = (unsigned short)1;
#line 11
      (*((tasklet_registered[i].tasklet)->func))((tasklet_registered[i].tasklet)->data);
#line 12
      tasklet_registered[i].is_running = (unsigned short)0;
#line 13
      tasklet_registered[i].tasklet = (struct tasklet_struct *)((void *)0);
    }
  }
#line 15
  return;
}
}
#line 1 "timer.o"
#pragma merger("0","/tmp/cil-H4pRe0m2.i","")
#line 27 "/usr/local/ddv/models/con2/include/linux/timer.h"
__inline void add_timer_on(struct timer_list *timer , int cpu ) ;
#line 30
__inline int mod_timer(struct timer_list *timer , unsigned long expires ) ;
#line 4 "/usr/local/ddv/models/con2/src/linux/kernel/timer.c"
void init_timer(struct timer_list *timer ) 
{ 


  {
#line 6
  if ((int )number_timer_registered < 5) {
#line 7
    timer->__ddv_active = (short)0;
#line 8
    timer->__ddv_init = (short)1;
#line 9
    timer_registered[number_timer_registered].timer = timer;
#line 11
    number_timer_registered = (short )((int )number_timer_registered + 1);
  }
#line 13
  return;
}
}
#line 15 "/usr/local/ddv/models/con2/src/linux/kernel/timer.c"
void add_timer(struct timer_list *timer ) 
{ 


  {
#line 21
  timer->__ddv_active = (short)1;
#line 22
  return;
}
}
#line 24 "/usr/local/ddv/models/con2/src/linux/kernel/timer.c"
__inline void add_timer_on(struct timer_list *timer , int cpu ) 
{ 


  {
#line 27
  add_timer(timer);
#line 28
  return;
}
}
#line 30 "/usr/local/ddv/models/con2/src/linux/kernel/timer.c"
int del_timer(struct timer_list *timer ) 
{ 


  {
#line 32
  timer->__ddv_active = (short)0;
#line 33
  return (0);
}
}
#line 35 "/usr/local/ddv/models/con2/src/linux/kernel/timer.c"
__inline int mod_timer(struct timer_list *timer , unsigned long expires ) 
{ 


  {
#line 41
  timer->expires = expires;
#line 42
  timer->__ddv_active = (short)1;
#line 43
  return (0);
}
}
#line 1 "tty_io.o"
#pragma merger("0","/tmp/cil-_Yc9pxXh.i","")
#line 97 "/usr/local/ddv/models/con2/include/linux/tty_driver.h"
struct tty_driver *alloc_tty_driver(int lines ) ;
#line 101
void tty_set_operations(struct tty_driver *driver , struct tty_operations  const  *op ) ;
#line 13 "/usr/local/ddv/models/con2/include/ddverify/tty.h"
struct ddv_tty_driver global_tty_driver  ;
#line 4 "/usr/local/ddv/models/con2/src/linux/drivers/char/tty_io.c"
struct tty_driver *alloc_tty_driver(int lines ) 
{ 


  {
#line 6
  if (! global_tty_driver.allocated) {
#line 7
    global_tty_driver.driver.magic = 21506;
#line 8
    global_tty_driver.driver.num = lines;
  } else {
#line 10
    return ((struct tty_driver *)((void *)0));
  }
#line 12
  return ((struct tty_driver *)0);
}
}
#line 14 "/usr/local/ddv/models/con2/src/linux/drivers/char/tty_io.c"
void tty_set_operations(struct tty_driver *driver , struct tty_operations  const  *op ) 
{ 


  {
#line 17
  driver->open = (int (*)(struct tty_struct *tty , struct file *filp ))op->open;
#line 18
  driver->close = (void (*)(struct tty_struct *tty , struct file *filp ))op->close;
#line 19
  driver->write = (int (*)(struct tty_struct *tty , unsigned char const   *buf , int count ))op->write;
#line 20
  driver->put_char = (void (*)(struct tty_struct *tty , unsigned char ch ))op->put_char;
#line 21
  driver->flush_chars = (void (*)(struct tty_struct *tty ))op->flush_chars;
#line 22
  driver->write_room = (int (*)(struct tty_struct *tty ))op->write_room;
#line 23
  driver->chars_in_buffer = (int (*)(struct tty_struct *tty ))op->chars_in_buffer;
#line 24
  driver->ioctl = (int (*)(struct tty_struct *tty , struct file *file , unsigned int cmd ,
                           unsigned long arg ))op->ioctl;
#line 25
  driver->set_termios = (void (*)(struct tty_struct *tty , struct termios *old ))op->set_termios;
#line 26
  driver->throttle = (void (*)(struct tty_struct *tty ))op->throttle;
#line 27
  driver->unthrottle = (void (*)(struct tty_struct *tty ))op->unthrottle;
#line 28
  driver->stop = (void (*)(struct tty_struct *tty ))op->stop;
#line 29
  driver->start = (void (*)(struct tty_struct *tty ))op->start;
#line 30
  driver->hangup = (void (*)(struct tty_struct *tty ))op->hangup;
#line 31
  driver->break_ctl = (void (*)(struct tty_struct *tty , int state ))op->break_ctl;
#line 32
  driver->flush_buffer = (void (*)(struct tty_struct *tty ))op->flush_buffer;
#line 33
  driver->set_ldisc = (void (*)(struct tty_struct *tty ))op->set_ldisc;
#line 34
  driver->wait_until_sent = (void (*)(struct tty_struct *tty , int timeout ))op->wait_until_sent;
#line 35
  driver->send_xchar = (void (*)(struct tty_struct *tty , char ch ))op->send_xchar;
#line 36
  driver->read_proc = (int (*)(char *page , char **start , off_t off , int count ,
                               int *eof , void *data ))op->read_proc;
#line 37
  driver->write_proc = (int (*)(struct file *file , char const   *buffer , unsigned long count ,
                                void *data ))op->write_proc;
#line 38
  driver->tiocmget = (int (*)(struct tty_struct *tty , struct file *file ))op->tiocmget;
#line 39
  driver->tiocmset = (int (*)(struct tty_struct *tty , struct file *file , unsigned int set ,
                              unsigned int clear ))op->tiocmset;
#line 40
  return;
}
}
#line 1 "usercopy.o"
#pragma merger("0","/tmp/cil-PtMzrsBA.i","")
#line 41 "/usr/local/ddv/models/con2/include/asm/uaccess.h"
__inline int __get_user(int size , void *ptr ) ;
#line 43
__inline int get_user(int size , void *ptr ) ;
#line 46
__inline int __put_user(int size , void *ptr ) ;
#line 48
__inline int put_user(int size , void *ptr ) ;
#line 5 "/usr/local/ddv/models/con2/src/linux/arch/i386/lib/usercopy.c"
__inline int __get_user(int size , void *ptr ) 
{ 
  int tmp ;

  {
#line 8
  assert_context_process();
#line 10
  tmp = nondet_int();
#line 10
  return (tmp);
}
}
#line 37 "/usr/local/ddv/models/con2/src/linux/arch/i386/lib/usercopy.c"
unsigned long copy_to_user(void *to , void const   *from , unsigned long n ) 
{ 
  unsigned long tmp ;

  {
#line 40
  assert_context_process();
#line 42
  tmp = nondet_ulong();
#line 42
  return (tmp);
}
}
#line 45 "/usr/local/ddv/models/con2/src/linux/arch/i386/lib/usercopy.c"
unsigned long copy_from_user(void *to , void *from , unsigned long n ) 
{ 
  unsigned long tmp ;

  {
#line 48
  assert_context_process();
#line 50
  tmp = nondet_ulong();
#line 50
  return (tmp);
}
}
#line 1 "vmalloc.o"
#pragma merger("0","/tmp/cil-yOpNggBm.i","")
#line 6 "/usr/local/ddv/models/con2/include/linux/vmalloc.h"
void *vmalloc(unsigned long size ) ;
#line 6 "/usr/local/ddv/models/con2/src/linux/mm/vmalloc.c"
void *vmalloc(unsigned long size ) 
{ 
  void *tmp ;

  {
#line 8
  tmp = malloc((size_t )size);
#line 8
  return (tmp);
}
}
#line 1 "wait.o"
#pragma merger("0","/tmp/cil-RsxTaMGP.i","")
#line 64 "/usr/local/ddv/models/con2/include/linux/wait.h"
__inline void init_waitqueue_head(wait_queue_head_t *q ) ;
#line 71
__inline void wake_up(wait_queue_head_t *q ) ;
#line 73
__inline void wake_up_all(wait_queue_head_t *q ) ;
#line 88
__inline void sleep_on(wait_queue_head_t *q ) ;
#line 90
__inline void interruptible_sleep_on(wait_queue_head_t *q ) ;
#line 3 "/usr/local/ddv/models/con2/src/linux/kernel/wait.c"
__inline void init_waitqueue_head(wait_queue_head_t *q ) 
{ 


  {
#line 5
  q->init = 1;
#line 6
  return;
}
}
#line 8 "/usr/local/ddv/models/con2/src/linux/kernel/wait.c"
__inline void wake_up(wait_queue_head_t *q ) 
{ 


  {
#line 14
  return;
}
}
#line 24 "/usr/local/ddv/models/con2/src/linux/kernel/wait.c"
void wake_up_interruptible(wait_queue_head_t *q ) 
{ 


  {
#line 30
  return;
}
}
#line 1 "workqueue.o"
#pragma merger("0","/tmp/cil-nmRdD6dK.i","")
#line 46 "/usr/local/ddv/models/con2/include/linux/workqueue.h"
__inline int schedule_work(struct work_struct *work ) ;
#line 5 "/usr/local/ddv/models/con2/src/linux/kernel/workqueue.c"
__inline int schedule_work(struct work_struct *work ) 
{ 
  int i ;

  {
#line 14
  i = 0;
#line 14
  while (i < 10) {
#line 15
    if ((unsigned long )shared_workqueue[i] == (unsigned long )work) {
#line 16
      return (0);
    }
#line 19
    if ((unsigned long )shared_workqueue[i] == (unsigned long )((void *)0)) {
#line 20
      shared_workqueue[i] = work;
#line 22
      return (1);
    }
#line 14
    i ++;
  }
#line 27
  return (-1);
}
}
#line 30 "/usr/local/ddv/models/con2/src/linux/kernel/workqueue.c"
void call_shared_workqueue_functions(void) 
{ 
  unsigned short i ;
  unsigned short tmp ;

  {
#line 32
  tmp = nondet_ushort();
#line 32
  i = tmp;
#line 33
  __CPROVER_assume((int )i < 10);
#line 35
  if ((unsigned long )shared_workqueue[i] != (unsigned long )((void *)0)) {
#line 36
    (*((shared_workqueue[i])->func))((shared_workqueue[i])->data);
#line 37
    shared_workqueue[i] = (struct work_struct *)((void *)0);
  }
#line 39
  return;
}
}
