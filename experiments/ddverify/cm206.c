/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is true */

#line 4 "/usr/local/ddv/models/con2/include/asm/posix_types.h"
typedef unsigned long __kernel_ino_t;
#line 5 "/usr/local/ddv/models/con2/include/asm/posix_types.h"
typedef unsigned short __kernel_mode_t;
#line 12 "/usr/local/ddv/models/con2/include/asm/posix_types.h"
typedef unsigned int __kernel_size_t;
#line 13 "/usr/local/ddv/models/con2/include/asm/posix_types.h"
typedef int __kernel_ssize_t;
#line 4 "/usr/local/ddv/models/con2/include/asm/types.h"
typedef unsigned short umode_t;
#line 13 "/usr/local/ddv/models/con2/include/asm/types.h"
typedef unsigned int __u32;
#line 9 "/usr/local/ddv/models/con2/include/linux/types.h"
typedef __u32 __kernel_dev_t;
#line 11 "/usr/local/ddv/models/con2/include/linux/types.h"
typedef __kernel_dev_t dev_t;
#line 12 "/usr/local/ddv/models/con2/include/linux/types.h"
typedef __kernel_ino_t ino_t;
#line 13 "/usr/local/ddv/models/con2/include/linux/types.h"
typedef __kernel_mode_t mode_t;
#line 30 "/usr/local/ddv/models/con2/include/linux/types.h"
typedef long long loff_t;
#line 38 "/usr/local/ddv/models/con2/include/linux/types.h"
typedef __kernel_size_t size_t;
#line 43 "/usr/local/ddv/models/con2/include/linux/types.h"
typedef __kernel_ssize_t ssize_t;
#line 44 "/usr/local/ddv/models/con2/include/ddverify/satabs.h"
struct __pthread_t_struct {
   int id ;
};
#line 49 "/usr/local/ddv/models/con2/include/ddverify/satabs.h"
struct __pthread_attr_t_struct {
   int dummy ;
};
#line 54 "/usr/local/ddv/models/con2/include/ddverify/satabs.h"
typedef struct __pthread_t_struct pthread_t;
#line 55 "/usr/local/ddv/models/con2/include/ddverify/satabs.h"
typedef struct __pthread_attr_t_struct pthread_attr_t;
#line 6 "/usr/local/ddv/models/con2/include/asm/atomic.h"
typedef int atomic_t;
#line 67 "/usr/local/ddv/models/con2/include/linux/gfp.h"
struct page;
#line 4 "/usr/local/ddv/models/con2/include/linux/dcache.h"
struct inode;
#line 4 "/usr/local/ddv/models/con2/include/linux/dcache.h"
struct dentry {
   struct inode *d_inode ;
};
#line 83 "/usr/local/ddv/models/con2/include/linux/fs.h"
struct iovec;
#line 84
struct poll_table_struct;
#line 85
struct vm_area_struct;
#line 90 "/usr/local/ddv/models/con2/include/linux/fs.h"
struct address_space {
   struct inode *host ;
};
#line 94
struct file_operations;
#line 94 "/usr/local/ddv/models/con2/include/linux/fs.h"
struct file {
   struct dentry *f_dentry ;
   struct file_operations *f_op ;
   atomic_t f_count ;
   unsigned int f_flags ;
   mode_t f_mode ;
   loff_t f_pos ;
   void *private_data ;
   struct address_space *f_mapping ;
};
#line 105
struct gendisk;
#line 105 "/usr/local/ddv/models/con2/include/linux/fs.h"
struct block_device {
   struct inode *bd_inode ;
   struct gendisk *bd_disk ;
   struct block_device *bd_contains ;
   unsigned int bd_block_size ;
};
#line 113
struct cdev;
#line 113 "/usr/local/ddv/models/con2/include/linux/fs.h"
struct inode {
   umode_t i_mode ;
   struct block_device *i_bdev ;
   dev_t i_rdev ;
   loff_t i_size ;
   struct cdev *i_cdev ;
};
#line 122 "/usr/local/ddv/models/con2/include/linux/fs.h"
struct __anonstruct_read_descriptor_t_4 {
   size_t written ;
   size_t count ;
};
#line 122 "/usr/local/ddv/models/con2/include/linux/fs.h"
typedef struct __anonstruct_read_descriptor_t_4 read_descriptor_t;
#line 130 "/usr/local/ddv/models/con2/include/linux/fs.h"
struct file_lock {
   int something ;
};
#line 134
struct module;
#line 134 "/usr/local/ddv/models/con2/include/linux/fs.h"
struct file_operations {
   struct module *owner ;
   loff_t (*llseek)(struct file * , loff_t  , int  ) ;
   ssize_t (*read)(struct file * , char * , size_t  , loff_t * ) ;
   ssize_t (*write)(struct file * , char const   * , size_t  , loff_t * ) ;
   int (*readdir)(struct file * , void * , int (*)(void * , char const   * , int  ,
                                                   loff_t  , ino_t  , unsigned int  ) ) ;
   unsigned int (*poll)(struct file * , struct poll_table_struct * ) ;
   int (*ioctl)(struct inode * , struct file * , unsigned int  , unsigned long  ) ;
   long (*unlocked_ioctl)(struct file * , unsigned int  , unsigned long  ) ;
   long (*compat_ioctl)(struct file * , unsigned int  , unsigned long  ) ;
   int (*mmap)(struct file * , struct vm_area_struct * ) ;
   int (*open)(struct inode * , struct file * ) ;
   int (*flush)(struct file * ) ;
   int (*release)(struct inode * , struct file * ) ;
   int (*fsync)(struct file * , struct dentry * , int datasync ) ;
   int (*fasync)(int  , struct file * , int  ) ;
   int (*lock)(struct file * , int  , struct file_lock * ) ;
   ssize_t (*readv)(struct file * , struct iovec  const  * , unsigned long  , loff_t * ) ;
   ssize_t (*writev)(struct file * , struct iovec  const  * , unsigned long  , loff_t * ) ;
   ssize_t (*sendfile)(struct file * , loff_t * , size_t  , int (*)(read_descriptor_t * ,
                                                                    struct page * ,
                                                                    unsigned long  ,
                                                                    unsigned long  ) ,
                       void * ) ;
   ssize_t (*sendpage)(struct file * , struct page * , int  , size_t  , loff_t * ,
                       int  ) ;
   unsigned long (*get_unmapped_area)(struct file * , unsigned long  , unsigned long  ,
                                      unsigned long  , unsigned long  ) ;
   int (*check_flags)(int  ) ;
   int (*dir_notify)(struct file *filp , unsigned long arg ) ;
   int (*flock)(struct file * , int  , struct file_lock * ) ;
   int (*open_exec)(struct inode * ) ;
};
#line 4 "/usr/local/ddv/models/con2/include/linux/cdev.h"
struct cdev {
   struct module *owner ;
   struct file_operations *ops ;
   dev_t dev ;
   unsigned int count ;
};
#line 13 "/usr/local/ddv/models/con2/include/ddverify/cdev.h"
struct ddv_cdev {
   struct cdev *cdevp ;
   struct file filp ;
   struct inode inode ;
   int open ;
};
#line 30 "/usr/local/ddv/models/con2/include/asm/types.h"
typedef unsigned long long u64;
#line 91 "/usr/local/ddv/models/con2/include/linux/types.h"
typedef unsigned long sector_t;
#line 15 "/usr/local/ddv/models/con2/include/ddverify/pthread.h"
struct __pthread_t_struct___0 {
   int id ;
};
#line 25 "/usr/local/ddv/models/con2/include/ddverify/pthread.h"
struct __pthread_mutex_t_struct {
   _Bool locked ;
};
#line 30 "/usr/local/ddv/models/con2/include/ddverify/pthread.h"
struct __pthread_mutexattr_t_struct {
   int dummy ;
};
#line 50 "/usr/local/ddv/models/con2/include/ddverify/pthread.h"
typedef struct __pthread_t_struct___0 pthread_t___0;
#line 52 "/usr/local/ddv/models/con2/include/ddverify/pthread.h"
typedef struct __pthread_mutex_t_struct pthread_mutex_t;
#line 53 "/usr/local/ddv/models/con2/include/ddverify/pthread.h"
typedef struct __pthread_mutexattr_t_struct pthread_mutexattr_t;
#line 9 "/usr/local/ddv/models/con2/include/linux/list.h"
struct list_head {
   struct list_head *next ;
   struct list_head *prev ;
};
#line 4 "/usr/local/ddv/models/con2/include/linux/spinlock_types.h"
struct __anonstruct_spinlock_t_9 {
   int init ;
   int locked ;
};
#line 4 "/usr/local/ddv/models/con2/include/linux/spinlock_types.h"
typedef struct __anonstruct_spinlock_t_9 spinlock_t;
#line 4 "/usr/local/ddv/models/con2/include/linux/timer.h"
struct timer_list {
   unsigned long expires ;
   void (*function)(unsigned long  ) ;
   unsigned long data ;
   short __ddv_active ;
   short __ddv_init ;
};
#line 82 "/usr/local/ddv/models/con2/include/linux/fs.h"
struct hd_geometry;
#line 168 "/usr/local/ddv/models/con2/include/linux/fs.h"
struct block_device_operations {
   int (*open)(struct inode * , struct file * ) ;
   int (*release)(struct inode * , struct file * ) ;
   int (*ioctl)(struct inode * , struct file * , unsigned int  , unsigned long  ) ;
   long (*unlocked_ioctl)(struct file * , unsigned int  , unsigned long  ) ;
   long (*compat_ioctl)(struct file * , unsigned int  , unsigned long  ) ;
   int (*direct_access)(struct block_device * , sector_t  , unsigned long * ) ;
   int (*media_changed)(struct gendisk * ) ;
   int (*revalidate_disk)(struct gendisk * ) ;
   int (*getgeo)(struct block_device * , struct hd_geometry * ) ;
   struct module *owner ;
};
#line 18 "/usr/local/ddv/models/con2/include/linux/ioport.h"
struct resource {
   char const   *name ;
   unsigned long start ;
   unsigned long end ;
   unsigned long flags ;
};
#line 24 "/usr/local/ddv/models/con2/include/linux/module.h"
struct module {
   int something ;
};
#line 8 "/usr/local/ddv/models/con2/include/linux/pm.h"
struct pm_message {
   int event ;
};
#line 8 "/usr/local/ddv/models/con2/include/linux/pm.h"
typedef struct pm_message pm_message_t;
#line 25 "/usr/local/ddv/models/con2/include/linux/device.h"
struct device {
   void *driver_data ;
   void (*release)(struct device *dev ) ;
};
#line 17 "/usr/local/ddv/models/con2/include/linux/genhd.h"
struct request_queue;
#line 17 "/usr/local/ddv/models/con2/include/linux/genhd.h"
struct gendisk {
   int major ;
   int first_minor ;
   int minors ;
   char disk_name[32] ;
   struct block_device_operations *fops ;
   struct request_queue *queue ;
   void *private_data ;
   int flags ;
   struct device *driverfs_dev ;
   char devfs_name[64] ;
};
#line 12 "/usr/local/ddv/models/con2/include/linux/workqueue.h"
struct work_struct {
   unsigned long pending ;
   void (*func)(void * ) ;
   void *data ;
   int init ;
};
#line 9 "/usr/local/ddv/models/con2/include/linux/mm_types.h"
struct page {
   int something ;
};
#line 4 "/usr/local/ddv/models/con2/include/asm/ptrace.h"
struct pt_regs {
   int something ;
};
#line 28 "/usr/local/ddv/models/con2/include/linux/interrupt.h"
typedef int irqreturn_t;
#line 34 "/usr/local/ddv/models/con2/include/linux/interrupt.h"
struct tasklet_struct {
   atomic_t count ;
   void (*func)(unsigned long  ) ;
   unsigned long data ;
   int init ;
};
#line 11 "/usr/local/ddv/models/con2/include/linux/backing-dev.h"
struct backing_dev_info {
   unsigned long ra_pages ;
   unsigned long state ;
   unsigned int capabilities ;
};
#line 6 "/usr/local/ddv/models/con2/include/linux/bio.h"
struct bio_vec {
   struct page *bv_page ;
   unsigned int bv_len ;
   unsigned int bv_offset ;
};
#line 13
struct bio;
#line 14 "/usr/local/ddv/models/con2/include/linux/bio.h"
typedef int bio_end_io_t(struct bio * , unsigned int  , int  );
#line 17 "/usr/local/ddv/models/con2/include/linux/bio.h"
struct bio {
   sector_t bi_sector ;
   struct bio *bi_next ;
   struct block_device *bi_bdev ;
   unsigned long bi_flags ;
   unsigned long bi_rw ;
   unsigned short bi_vcnt ;
   unsigned short bi_idx ;
   unsigned short bi_phys_segments ;
   unsigned int bi_size ;
   struct bio_vec *bi_io_vec ;
   bio_end_io_t *bi_end_io ;
   void *bi_private ;
};
#line 4 "/usr/local/ddv/models/con2/include/linux/elevator.h"
struct request;
#line 23 "/usr/local/ddv/models/con2/include/linux/blkdev.h"
typedef struct request_queue request_queue_t;
#line 25 "/usr/local/ddv/models/con2/include/linux/blkdev.h"
typedef void request_fn_proc(request_queue_t *q );
#line 26 "/usr/local/ddv/models/con2/include/linux/blkdev.h"
typedef int make_request_fn(request_queue_t *q , struct bio *bio );
#line 27 "/usr/local/ddv/models/con2/include/linux/blkdev.h"
typedef void unplug_fn(request_queue_t * );
#line 32
enum rq_cmd_type_bits {
    REQ_TYPE_FS = 1,
    REQ_TYPE_BLOCK_PC = 2,
    REQ_TYPE_SENSE = 3,
    REQ_TYPE_PM_SUSPEND = 4,
    REQ_TYPE_PM_RESUME = 5,
    REQ_TYPE_PM_SHUTDOWN = 6,
    REQ_TYPE_FLUSH = 7,
    REQ_TYPE_SPECIAL = 8,
    REQ_TYPE_LINUX_BLOCK = 9,
    REQ_TYPE_ATA_CMD = 10,
    REQ_TYPE_ATA_TASK = 11,
    REQ_TYPE_ATA_TASKFILE = 12,
    REQ_TYPE_ATA_PC = 13
} ;
#line 54 "/usr/local/ddv/models/con2/include/linux/blkdev.h"
struct request_queue {
   request_fn_proc *request_fn ;
   make_request_fn *make_request_fn ;
   unplug_fn *unplug_fn ;
   struct backing_dev_info backing_dev_info ;
   void *queuedata ;
   unsigned long queue_flags ;
   spinlock_t *queue_lock ;
   unsigned short hardsect_size ;
   int __ddv_genhd_no ;
   int __ddv_queue_alive ;
};
#line 90 "/usr/local/ddv/models/con2/include/linux/blkdev.h"
struct request {
   struct list_head queuelist ;
   struct list_head donelist ;
   request_queue_t *q ;
   unsigned long flags ;
   unsigned int cmd_flags ;
   enum rq_cmd_type_bits cmd_type ;
   struct bio *bio ;
   void *completion_data ;
   struct gendisk *rq_disk ;
   sector_t sector ;
   unsigned long nr_sectors ;
   unsigned int current_nr_sectors ;
   char *buffer ;
   int errors ;
   unsigned short nr_phys_segments ;
   unsigned char cmd[16] ;
};
#line 15 "/usr/local/ddv/models/con2/include/ddverify/genhd.h"
struct ddv_genhd {
   struct gendisk *gd ;
   struct inode inode ;
   struct file file ;
   struct request current_request ;
   int requests_open ;
};
#line 6 "/usr/local/ddv/models/con2/include/linux/mod_devicetable.h"
typedef unsigned long kernel_ulong_t;
#line 10 "/usr/local/ddv/models/con2/include/linux/mod_devicetable.h"
struct pci_device_id {
   __u32 vendor ;
   __u32 device ;
   __u32 subvendor ;
   __u32 subdevice ;
   __u32 class ;
   __u32 class_mask ;
   kernel_ulong_t driver_data ;
};
#line 40 "/usr/local/ddv/models/con2/include/linux/pci.h"
typedef int pci_power_t;
#line 43
struct pci_bus;
#line 43 "/usr/local/ddv/models/con2/include/linux/pci.h"
struct pci_dev {
   struct pci_bus *bus ;
   unsigned int devfn ;
   unsigned short vendor ;
   unsigned short device ;
   u64 dma_mask ;
   struct device dev ;
   unsigned int irq ;
   struct resource resource[12] ;
};
#line 62 "/usr/local/ddv/models/con2/include/linux/pci.h"
struct pci_bus {
   unsigned char number ;
};
#line 67 "/usr/local/ddv/models/con2/include/linux/pci.h"
struct pci_driver {
   char *name ;
   struct pci_device_id  const  *id_table ;
   int (*probe)(struct pci_dev *dev , struct pci_device_id  const  *id ) ;
   void (*remove)(struct pci_dev *dev ) ;
   int (*suspend)(struct pci_dev *dev , pm_message_t state ) ;
   int (*resume)(struct pci_dev *dev ) ;
   int (*enable_wake)(struct pci_dev *dev , pci_power_t state , int enable ) ;
   void (*shutdown)(struct pci_dev *dev ) ;
};
#line 6 "/usr/local/ddv/models/con2/include/ddverify/pci.h"
struct ddv_pci_driver {
   struct pci_driver *pci_driver ;
   struct pci_dev pci_dev ;
   unsigned int no_pci_device_id ;
   int dev_initialized ;
};
#line 9 "/usr/local/ddv/models/con2/include/ddverify/interrupt.h"
struct registered_irq {
   irqreturn_t (*handler)(int  , void * , struct pt_regs * ) ;
   void *dev_id ;
};
#line 10 "/usr/local/ddv/models/con2/include/ddverify/tasklet.h"
struct ddv_tasklet {
   struct tasklet_struct *tasklet ;
   unsigned short is_running ;
};
#line 10 "/usr/local/ddv/models/con2/include/ddverify/timer.h"
struct ddv_timer {
   struct timer_list *timer ;
};
#line 88 "/usr/local/ddv/models/con2/include/linux/types.h"
typedef unsigned int gfp_t;
#line 7 "/usr/local/ddv/models/con2/include/asm/types.h"
typedef unsigned char __u8;
#line 16 "/usr/local/ddv/models/con2/include/linux/wait.h"
struct __wait_queue_head {
   int number_process_waiting ;
   int wakeup ;
   int init ;
};
#line 22 "/usr/local/ddv/models/con2/include/linux/wait.h"
typedef struct __wait_queue_head wait_queue_head_t;
#line 153 "/usr/local/ddv/models/con2/include/linux/cdrom.h"
struct cdrom_msf0 {
   __u8 minute ;
   __u8 second ;
   __u8 frame ;
};
#line 161 "/usr/local/ddv/models/con2/include/linux/cdrom.h"
union cdrom_addr {
   struct cdrom_msf0 msf ;
   int lba ;
};
#line 168 "/usr/local/ddv/models/con2/include/linux/cdrom.h"
struct cdrom_msf {
   __u8 cdmsf_min0 ;
   __u8 cdmsf_sec0 ;
   __u8 cdmsf_frame0 ;
   __u8 cdmsf_min1 ;
   __u8 cdmsf_sec1 ;
   __u8 cdmsf_frame1 ;
};
#line 179 "/usr/local/ddv/models/con2/include/linux/cdrom.h"
struct cdrom_ti {
   __u8 cdti_trk0 ;
   __u8 cdti_ind0 ;
   __u8 cdti_trk1 ;
   __u8 cdti_ind1 ;
};
#line 188 "/usr/local/ddv/models/con2/include/linux/cdrom.h"
struct cdrom_tochdr {
   __u8 cdth_trk0 ;
   __u8 cdth_trk1 ;
};
#line 204 "/usr/local/ddv/models/con2/include/linux/cdrom.h"
struct cdrom_subchnl {
   __u8 cdsc_format ;
   __u8 cdsc_audiostatus ;
   __u8 cdsc_adr : 4 ;
   __u8 cdsc_ctrl : 4 ;
   __u8 cdsc_trk ;
   __u8 cdsc_ind ;
   union cdrom_addr cdsc_absaddr ;
   union cdrom_addr cdsc_reladdr ;
};
#line 218 "/usr/local/ddv/models/con2/include/linux/cdrom.h"
struct cdrom_tocentry {
   __u8 cdte_track ;
   __u8 cdte_adr : 4 ;
   __u8 cdte_ctrl : 4 ;
   __u8 cdte_format ;
   union cdrom_addr cdte_addr ;
   __u8 cdte_datamode ;
};
#line 246 "/usr/local/ddv/models/con2/include/linux/cdrom.h"
struct cdrom_multisession {
   union cdrom_addr addr ;
   __u8 xa_flag ;
   __u8 addr_format ;
};
#line 260 "/usr/local/ddv/models/con2/include/linux/cdrom.h"
struct cdrom_mcn {
   __u8 medium_catalog_number[14] ;
};
#line 280
struct request_sense;
#line 694 "/usr/local/ddv/models/con2/include/linux/cdrom.h"
struct request_sense {
   __u8 error_code : 7 ;
   __u8 valid : 1 ;
   __u8 segment_number ;
   __u8 sense_key : 4 ;
   __u8 reserved2 : 1 ;
   __u8 ili : 1 ;
   __u8 reserved1 : 2 ;
   __u8 information[4] ;
   __u8 add_sense_len ;
   __u8 command_info[4] ;
   __u8 asc ;
   __u8 ascq ;
   __u8 fruc ;
   __u8 sks[3] ;
   __u8 asb[46] ;
};
#line 912 "/usr/local/ddv/models/con2/include/linux/cdrom.h"
struct packet_command {
   unsigned char cmd[12] ;
   unsigned char *buffer ;
   unsigned int buflen ;
   int stat ;
   struct request_sense *sense ;
   unsigned char data_direction ;
   int quiet ;
   int timeout ;
   void *reserved[1] ;
};
#line 933
struct cdrom_device_ops;
#line 933 "/usr/local/ddv/models/con2/include/linux/cdrom.h"
struct cdrom_device_info {
   struct cdrom_device_ops *ops ;
   struct cdrom_device_info *next ;
   struct gendisk *disk ;
   void *handle ;
   int mask ;
   int speed ;
   int capacity ;
   int options : 30 ;
   unsigned int mc_flags : 2 ;
   int use_count ;
   char name[20] ;
   __u8 sanyo_slot : 2 ;
   __u8 reserved : 6 ;
   int cdda_method ;
   __u8 last_sense ;
   __u8 media_written ;
   unsigned short mmc3_profile ;
   int for_data ;
   int (*exit)(struct cdrom_device_info * ) ;
   int mrw_mode_page ;
};
#line 959 "/usr/local/ddv/models/con2/include/linux/cdrom.h"
struct cdrom_device_ops {
   int (*open)(struct cdrom_device_info * , int  ) ;
   void (*release)(struct cdrom_device_info * ) ;
   int (*drive_status)(struct cdrom_device_info * , int  ) ;
   int (*media_changed)(struct cdrom_device_info * , int  ) ;
   int (*tray_move)(struct cdrom_device_info * , int  ) ;
   int (*lock_door)(struct cdrom_device_info * , int  ) ;
   int (*select_speed)(struct cdrom_device_info * , int  ) ;
   int (*select_disc)(struct cdrom_device_info * , int  ) ;
   int (*get_last_session)(struct cdrom_device_info * , struct cdrom_multisession * ) ;
   int (*get_mcn)(struct cdrom_device_info * , struct cdrom_mcn * ) ;
   int (*reset)(struct cdrom_device_info * ) ;
   int (*audio_ioctl)(struct cdrom_device_info * , unsigned int  , void * ) ;
   int (*dev_ioctl)(struct cdrom_device_info * , unsigned int  , unsigned long  ) ;
   int const   capability ;
   int n_minors ;
   int (*generic_packet)(struct cdrom_device_info * , struct packet_command * ) ;
};
#line 257 "cm206.c"
typedef unsigned char uch;
#line 258 "cm206.c"
typedef unsigned short ush;
#line 260 "cm206.c"
struct toc_struct {
   uch track ;
   uch fsm[3] ;
   uch q0 ;
};
#line 264 "cm206.c"
struct cm206_struct {
   ush volatile   intr_ds ;
   ush volatile   intr_ls ;
   uch volatile   ur[4] ;
   uch volatile   ur_w ;
   uch volatile   ur_r ;
   uch volatile   dsb ;
   uch volatile   cc ;
   int command ;
   int openfiles ;
   ush sector[1176] ;
   int sector_first ;
   int sector_last ;
   wait_queue_head_t uart ;
   wait_queue_head_t data ;
   struct timer_list timer ;
   char timed_out ;
   signed char max_sectors ;
   char wait_back ;
   char background ;
   int adapter_first ;
   int adapter_last ;
   char fifo_overflowed ;
   uch disc_status[7] ;
   int stats[21] ;
   int last_stat[21] ;
   int stat_counter ;
   struct toc_struct toc[101] ;
   uch q[10] ;
   uch audio_status[5] ;
   uch media_changed ;
};
#line 34 "/usr/local/ddv/models/con2/include/linux/miscdevice.h"
struct miscdevice {
   int minor ;
   char const   *name ;
   struct file_operations *fops ;
};
#line 7 "/usr/local/ddv/models/con2/include/linux/proc_fs.h"
struct proc_dir_entry {
   int something ;
};
#line 20 "/usr/local/ddv/models/con2/include/linux/mutex.h"
struct mutex {
   int locked ;
   int init ;
};
#line 4 "/usr/local/ddv/models/con2/include/asm/semaphore.h"
struct semaphore {
   int init ;
   int locked ;
};
#line 7 "/usr/local/ddv/models/con2/include/asm/posix_types.h"
typedef long __kernel_off_t;
#line 15 "/usr/local/ddv/models/con2/include/linux/types.h"
typedef __kernel_off_t off_t;
#line 6 "/usr/local/ddv/models/con2/include/asm/termbits.h"
typedef unsigned char cc_t;
#line 8 "/usr/local/ddv/models/con2/include/asm/termbits.h"
typedef unsigned int tcflag_t;
#line 11 "/usr/local/ddv/models/con2/include/asm/termbits.h"
struct termios {
   tcflag_t c_iflag ;
   tcflag_t c_oflag ;
   tcflag_t c_cflag ;
   tcflag_t c_lflag ;
   cc_t c_line ;
   cc_t c_cc[19] ;
};
#line 9 "/usr/local/ddv/models/con2/include/linux/tty_driver.h"
struct tty_struct;
#line 12 "/usr/local/ddv/models/con2/include/linux/tty_driver.h"
struct tty_operations {
   int (*open)(struct tty_struct *tty , struct file *filp ) ;
   void (*close)(struct tty_struct *tty , struct file *filp ) ;
   int (*write)(struct tty_struct *tty , unsigned char const   *buf , int count ) ;
   void (*put_char)(struct tty_struct *tty , unsigned char ch ) ;
   void (*flush_chars)(struct tty_struct *tty ) ;
   int (*write_room)(struct tty_struct *tty ) ;
   int (*chars_in_buffer)(struct tty_struct *tty ) ;
   int (*ioctl)(struct tty_struct *tty , struct file *file , unsigned int cmd , unsigned long arg ) ;
   void (*set_termios)(struct tty_struct *tty , struct termios *old ) ;
   void (*throttle)(struct tty_struct *tty ) ;
   void (*unthrottle)(struct tty_struct *tty ) ;
   void (*stop)(struct tty_struct *tty ) ;
   void (*start)(struct tty_struct *tty ) ;
   void (*hangup)(struct tty_struct *tty ) ;
   void (*break_ctl)(struct tty_struct *tty , int state ) ;
   void (*flush_buffer)(struct tty_struct *tty ) ;
   void (*set_ldisc)(struct tty_struct *tty ) ;
   void (*wait_until_sent)(struct tty_struct *tty , int timeout ) ;
   void (*send_xchar)(struct tty_struct *tty , char ch ) ;
   int (*read_proc)(char *page , char **start , off_t off , int count , int *eof ,
                    void *data ) ;
   int (*write_proc)(struct file *file , char const   *buffer , unsigned long count ,
                     void *data ) ;
   int (*tiocmget)(struct tty_struct *tty , struct file *file ) ;
   int (*tiocmset)(struct tty_struct *tty , struct file *file , unsigned int set ,
                   unsigned int clear ) ;
};
#line 43 "/usr/local/ddv/models/con2/include/linux/tty_driver.h"
struct tty_driver {
   int magic ;
   struct cdev cdev ;
   struct module *owner ;
   char const   *driver_name ;
   char const   *name ;
   int name_base ;
   int major ;
   int minor_start ;
   int minor_num ;
   int num ;
   short type ;
   short subtype ;
   struct termios init_termios ;
   int flags ;
   int refcount ;
   struct proc_dir_entry *proc_entry ;
   int (*open)(struct tty_struct *tty , struct file *filp ) ;
   void (*close)(struct tty_struct *tty , struct file *filp ) ;
   int (*write)(struct tty_struct *tty , unsigned char const   *buf , int count ) ;
   void (*put_char)(struct tty_struct *tty , unsigned char ch ) ;
   void (*flush_chars)(struct tty_struct *tty ) ;
   int (*write_room)(struct tty_struct *tty ) ;
   int (*chars_in_buffer)(struct tty_struct *tty ) ;
   int (*ioctl)(struct tty_struct *tty , struct file *file , unsigned int cmd , unsigned long arg ) ;
   void (*set_termios)(struct tty_struct *tty , struct termios *old ) ;
   void (*throttle)(struct tty_struct *tty ) ;
   void (*unthrottle)(struct tty_struct *tty ) ;
   void (*stop)(struct tty_struct *tty ) ;
   void (*start)(struct tty_struct *tty ) ;
   void (*hangup)(struct tty_struct *tty ) ;
   void (*break_ctl)(struct tty_struct *tty , int state ) ;
   void (*flush_buffer)(struct tty_struct *tty ) ;
   void (*set_ldisc)(struct tty_struct *tty ) ;
   void (*wait_until_sent)(struct tty_struct *tty , int timeout ) ;
   void (*send_xchar)(struct tty_struct *tty , char ch ) ;
   int (*read_proc)(char *page , char **start , off_t off , int count , int *eof ,
                    void *data ) ;
   int (*write_proc)(struct file *file , char const   *buffer , unsigned long count ,
                     void *data ) ;
   int (*tiocmget)(struct tty_struct *tty , struct file *file ) ;
   int (*tiocmset)(struct tty_struct *tty , struct file *file , unsigned int set ,
                   unsigned int clear ) ;
};
#line 113 "/usr/local/ddv/models/con2/include/linux/tty.h"
struct tty_struct {
   int magic ;
   struct tty_driver *driver ;
   int index ;
   struct termios *termios ;
   struct termios *termios_locked ;
   char name[64] ;
   unsigned long flags ;
   int count ;
   unsigned char stopped : 1 ;
   unsigned char hw_stopped : 1 ;
   unsigned char flow_stopped : 1 ;
   unsigned char packet : 1 ;
   unsigned int receive_room ;
   wait_queue_head_t write_wait ;
   wait_queue_head_t read_wait ;
   void *disc_data ;
   void *driver_data ;
   unsigned char closing : 1 ;
};
#line 7 "/usr/local/ddv/models/con2/include/ddverify/tty.h"
struct ddv_tty_driver {
   struct tty_driver driver ;
   unsigned short allocated ;
   unsigned short registered ;
};
#line 1 "cdev.o"
#pragma merger("0","/tmp/cil-rHzQ57tU.i","")
#line 11 "/usr/local/ddv/models/con2/include/ddverify/ddverify.h"
int current_execution_context  ;
#line 42 "/usr/local/ddv/models/con2/include/ddverify/ddverify.h"
int (*_ddv_module_init)(void)  ;
#line 43 "/usr/local/ddv/models/con2/include/ddverify/ddverify.h"
void (*_ddv_module_exit)(void)  ;
#line 15 "/usr/local/ddv/models/con2/include/ddverify/satabs.h"
extern unsigned short nondet_ushort() ;
#line 16
extern int nondet_int() ;
#line 17
extern unsigned int nondet_uint() ;
#line 19
extern unsigned long nondet_ulong() ;
#line 20
extern char nondet_char() ;
#line 23
extern loff_t nondet_loff_t() ;
#line 24
extern size_t nondet_size_t() ;
#line 57
extern pthread_t nondet_pthread_t() ;
#line 59 "/usr/local/ddv/models/con2/include/ddverify/satabs.h"
__inline extern int pthread_create(pthread_t *__threadp , pthread_attr_t const   *__attr ,
                                   void *(*__start_routine)(void * ) , void *__arg ) 
{ 


  {
#line 65
  *__threadp = nondet_pthread_t();
#line 66
  (*__start_routine)(__arg);
#line 67
  return (0);
}
}
#line 7 "/usr/local/ddv/models/con2/include/linux/jiffies.h"
unsigned long jiffies  ;
#line 12 "/usr/local/ddv/models/con2/include/ddverify/fixed_cdev.h"
struct cdev fixed_cdev[10]  ;
#line 13 "/usr/local/ddv/models/con2/include/ddverify/fixed_cdev.h"
int fixed_cdev_used  =    0;
#line 11 "/usr/local/ddv/models/con2/include/ddverify/cdev.h"
short number_cdev_registered  =    (short)0;
#line 22 "/usr/local/ddv/models/con2/include/ddverify/cdev.h"
struct ddv_cdev cdev_registered[10]  ;
#line 24
void call_cdev_functions(void) ;
#line 21 "/usr/local/ddv/models/con2/src/ddverify/cdev.c"
extern int ( /* missing proto */  __CPROVER_assume)() ;
#line 5 "/usr/local/ddv/models/con2/src/ddverify/cdev.c"
void call_cdev_functions(void) 
{ 
  int cdev_no ;
  int result ;
  loff_t loff_t_value ;
  int int_value ;
  unsigned int uint_value ;
  unsigned long ulong_value ;
  char char_value ;
  size_t size_t_value ;
  unsigned short tmp ;
  int tmp___0 ;
  unsigned short tmp___1 ;

  {
#line 16
  if ((int )number_cdev_registered == 0) {
#line 17
    return;
  }
#line 20
  tmp = nondet_ushort();
#line 20
  cdev_no = (int )tmp;
#line 21
  if (0 <= cdev_no) {
#line 21
    if (cdev_no < (int )number_cdev_registered) {
#line 21
      tmp___0 = 1;
    } else {
#line 21
      tmp___0 = 0;
    }
  } else {
#line 21
    tmp___0 = 0;
  }
#line 21
  __CPROVER_assume(tmp___0);
#line 23
  tmp___1 = nondet_ushort();
#line 23
  switch ((int )tmp___1) {
  case 0: 
#line 25
  if (((cdev_registered[cdev_no].cdevp)->ops)->llseek) {
#line 26
    loff_t_value = nondet_loff_t();
#line 27
    int_value = nondet_int();
#line 29
    (*(((cdev_registered[cdev_no].cdevp)->ops)->llseek))(& cdev_registered[cdev_no].filp,
                                                         loff_t_value, int_value);
  }
#line 33
  break;
  case 1: 
#line 35
  if (((cdev_registered[cdev_no].cdevp)->ops)->read) {
#line 36
    char_value = nondet_char();
#line 37
    size_t_value = nondet_size_t();
#line 39
    (*(((cdev_registered[cdev_no].cdevp)->ops)->read))(& cdev_registered[cdev_no].filp,
                                                       & char_value, size_t_value,
                                                       & loff_t_value);
  }
#line 44
  break;
  case 2: 
#line 47
  break;
  case 3: 
#line 49
  if (((cdev_registered[cdev_no].cdevp)->ops)->write) {
#line 50
    char_value = nondet_char();
#line 51
    size_t_value = nondet_size_t();
#line 53
    (*(((cdev_registered[cdev_no].cdevp)->ops)->write))(& cdev_registered[cdev_no].filp,
                                                        (char const   *)(& char_value),
                                                        size_t_value, & loff_t_value);
  }
#line 58
  break;
  case 4: 
#line 61
  break;
  case 5: 
#line 64
  break;
  case 6: 
#line 67
  break;
  case 7: 
#line 69
  if (((cdev_registered[cdev_no].cdevp)->ops)->ioctl) {
#line 70
    uint_value = nondet_uint();
#line 71
    ulong_value = nondet_ulong();
#line 73
    (*(((cdev_registered[cdev_no].cdevp)->ops)->ioctl))(& cdev_registered[cdev_no].inode,
                                                        & cdev_registered[cdev_no].filp,
                                                        uint_value, ulong_value);
  }
#line 79
  break;
  case 8: 
#line 82
  break;
  case 9: 
#line 85
  break;
  case 10: 
#line 88
  break;
  case 11: 
#line 90
  if (((cdev_registered[cdev_no].cdevp)->ops)->open) {
#line 90
    if (! cdev_registered[cdev_no].open) {
#line 92
      result = (*(((cdev_registered[cdev_no].cdevp)->ops)->open))(& cdev_registered[cdev_no].inode,
                                                                  & cdev_registered[cdev_no].filp);
#line 95
      if (! result) {
#line 96
        cdev_registered[cdev_no].open = 1;
      }
    }
  }
#line 99
  break;
  case 12: 
#line 102
  break;
  case 13: 
#line 104
  if (((cdev_registered[cdev_no].cdevp)->ops)->release) {
#line 104
    if (cdev_registered[cdev_no].open) {
#line 106
      result = (*(((cdev_registered[cdev_no].cdevp)->ops)->release))(& cdev_registered[cdev_no].inode,
                                                                     & cdev_registered[cdev_no].filp);
#line 109
      if (! result) {
#line 110
        cdev_registered[cdev_no].open = 0;
      }
    }
  }
#line 113
  break;
  case 14: 
#line 116
  break;
  case 15: 
#line 119
  break;
  case 16: 
#line 122
  break;
  case 17: 
#line 125
  break;
  case 18: 
#line 128
  break;
  case 19: 
#line 131
  break;
  case 20: 
#line 134
  break;
  case 21: 
#line 137
  break;
  case 22: 
#line 140
  break;
  case 23: 
#line 143
  break;
  case 24: 
#line 146
  break;
  case 25: 
#line 149
  break;
  case 26: 
#line 152
  break;
  default: 
#line 154
  break;
  }
#line 156
  return;
}
}
#line 1 "char_dev.o"
#pragma merger("0","/tmp/cil-vjBHo4br.i","")
#line 8 "/usr/local/ddv/models/con2/include/linux/slab.h"
extern void kfree(void const   * ) ;
#line 195 "/usr/local/ddv/models/con2/include/linux/fs.h"
__inline int alloc_chrdev_region(dev_t *dev , unsigned int baseminor , unsigned int count ,
                                 char const   *name ) ;
#line 196
__inline int register_chrdev_region(dev_t from , unsigned int count , char const   *name ) ;
#line 199
__inline int register_chrdev(unsigned int major , char const   *name , struct file_operations *fops ) ;
#line 200
__inline int unregister_chrdev(unsigned int major , char const   *name ) ;
#line 11 "/usr/local/ddv/models/con2/include/linux/cdev.h"
__inline void cdev_init(struct cdev *cdev , struct file_operations *fops ) ;
#line 13
__inline struct cdev *cdev_alloc(void) ;
#line 17
__inline int cdev_add(struct cdev *p , dev_t dev , unsigned int count ) ;
#line 19
__inline void cdev_del(struct cdev *p ) ;
#line 9 "/usr/local/ddv/models/con2/src/linux/fs/char_dev.c"
__inline int alloc_chrdev_region(dev_t *dev , unsigned int baseminor , unsigned int count ,
                                 char const   *name ) 
{ 
  int major ;
  int return_value ;
  int tmp ;
  int tmp___0 ;
  unsigned int tmp___1 ;

  {
#line 12
  tmp = nondet_int();
#line 12
  return_value = tmp;
#line 13
  if (return_value == 0) {
#line 13
    tmp___0 = 1;
  } else
#line 13
  if (return_value == -1) {
#line 13
    tmp___0 = 1;
  } else {
#line 13
    tmp___0 = 0;
  }
#line 13
  __CPROVER_assume(tmp___0);
#line 15
  if (return_value == 0) {
#line 16
    tmp___1 = nondet_uint();
#line 16
    major = (int )tmp___1;
#line 17
    *dev = (unsigned int )(major << 20) | baseminor;
  }
#line 20
  return (return_value);
}
}
#line 23 "/usr/local/ddv/models/con2/src/linux/fs/char_dev.c"
__inline int register_chrdev_region(dev_t from , unsigned int count , char const   *name ) 
{ 
  int return_value ;
  int tmp ;
  int tmp___0 ;

  {
#line 25
  tmp = nondet_int();
#line 25
  return_value = tmp;
#line 26
  if (return_value == 0) {
#line 26
    tmp___0 = 1;
  } else
#line 26
  if (return_value == -1) {
#line 26
    tmp___0 = 1;
  } else {
#line 26
    tmp___0 = 0;
  }
#line 26
  __CPROVER_assume(tmp___0);
#line 28
  return (return_value);
}
}
#line 33 "/usr/local/ddv/models/con2/src/linux/fs/char_dev.c"
__inline int register_chrdev(unsigned int major , char const   *name , struct file_operations *fops ) 
{ 
  struct cdev *cdev ;
  int err ;
  int tmp ;

  {
#line 39
  tmp = register_chrdev_region((dev_t )0, 256U, name);
#line 39
  major = (unsigned int )tmp;
#line 41
  cdev = cdev_alloc();
#line 42
  cdev->owner = fops->owner;
#line 43
  cdev->ops = fops;
#line 45
  err = cdev_add(cdev, major << 20, 256U);
#line 47
  if (err) {
#line 48
    kfree((void const   *)cdev);
#line 49
    return (err);
  }
#line 52
  return ((int )major);
}
}
#line 55 "/usr/local/ddv/models/con2/src/linux/fs/char_dev.c"
__inline int unregister_chrdev(unsigned int major , char const   *name ) 
{ 


  {
#line 57
  return (0);
}
}
#line 60 "/usr/local/ddv/models/con2/src/linux/fs/char_dev.c"
__inline struct cdev *cdev_alloc(void) 
{ 
  int tmp ;

  {
#line 62
  if (fixed_cdev_used < 10) {
#line 63
    tmp = fixed_cdev_used;
#line 63
    fixed_cdev_used ++;
#line 63
    return (& fixed_cdev[tmp]);
  }
#line 65
  return ((struct cdev *)0);
}
}
#line 67 "/usr/local/ddv/models/con2/src/linux/fs/char_dev.c"
__inline void cdev_init(struct cdev *cdev , struct file_operations *fops ) 
{ 


  {
#line 69
  cdev->ops = fops;
#line 70
  return;
}
}
#line 72 "/usr/local/ddv/models/con2/src/linux/fs/char_dev.c"
__inline int cdev_add(struct cdev *p , dev_t dev , unsigned int count ) 
{ 
  int return_value ;
  int tmp ;
  int tmp___0 ;

  {
#line 74
  p->dev = dev;
#line 75
  p->count = count;
#line 77
  tmp = nondet_int();
#line 77
  return_value = tmp;
#line 78
  if (return_value == 0) {
#line 78
    tmp___0 = 1;
  } else
#line 78
  if (return_value == -1) {
#line 78
    tmp___0 = 1;
  } else {
#line 78
    tmp___0 = 0;
  }
#line 78
  __CPROVER_assume(tmp___0);
#line 80
  if (return_value == 0) {
#line 81
    if ((int )number_cdev_registered < 10) {
#line 83
      cdev_registered[number_cdev_registered].cdevp = p;
#line 84
      cdev_registered[number_cdev_registered].inode.i_rdev = dev;
#line 85
      cdev_registered[number_cdev_registered].inode.i_cdev = p;
#line 86
      cdev_registered[number_cdev_registered].open = 0;
#line 88
      number_cdev_registered = (short )((int )number_cdev_registered + 1);
    } else {
#line 90
      return (-1);
    }
  }
#line 94
  return (return_value);
}
}
#line 97 "/usr/local/ddv/models/con2/src/linux/fs/char_dev.c"
__inline void cdev_del(struct cdev *p ) 
{ 
  int i ;

  {
#line 101
  i = 0;
#line 101
  while (i < (int )number_cdev_registered) {
#line 102
    if ((unsigned long )cdev_registered[i].cdevp == (unsigned long )p) {
#line 103
      cdev_registered[i].cdevp = (struct cdev *)0;
#line 105
      return;
    }
#line 101
    i ++;
  }
#line 108
  return;
}
}
#line 1 "ddverify.o"
#pragma merger("0","/tmp/cil-ke6obPlE.i","")
#line 45 "/usr/local/ddv/models/con2/include/ddverify/ddverify.h"
int call_ddv(void) ;
#line 39 "/usr/local/ddv/models/con2/include/ddverify/satabs.h"
extern void __CPROVER_atomic_begin() ;
#line 40
extern void __CPROVER_atomic_end() ;
#line 186 "/usr/local/ddv/models/con2/include/ddverify/pthread.h"
__inline extern int pthread_mutex_init(pthread_mutex_t *__mutex , pthread_mutexattr_t const   *__mutex_attr ) 
{ 
  pthread_mutex_t i ;

  {
#line 190
  i.locked = (_Bool)0;
#line 191
  *__mutex = i;
#line 192
  return (0);
}
}
#line 194 "/usr/local/ddv/models/con2/include/ddverify/pthread.h"
__inline extern int pthread_mutex_destroy(pthread_mutex_t *__mutex ) 
{ 


  {
#line 196
  return (0);
}
}
#line 203 "/usr/local/ddv/models/con2/include/ddverify/pthread.h"
__inline extern int pthread_mutex_lock(pthread_mutex_t *__mutex ) 
{ 


  {
#line 206
  __CPROVER_atomic_begin();
#line 207
  __CPROVER_assume(! __mutex->locked);
#line 208
  __mutex->locked = (_Bool)1;
#line 209
  __CPROVER_atomic_end();
#line 210
  return (0);
}
}
#line 216
extern int ( /* missing proto */  __CPROVER_assert)() ;
#line 213 "/usr/local/ddv/models/con2/include/ddverify/pthread.h"
__inline extern int pthread_mutex_unlock(pthread_mutex_t *__mutex ) 
{ 


  {
#line 216
  __CPROVER_assert((int )__mutex->locked, "pthread_mutex_unlock without lock");
#line 217
  __mutex->locked = (_Bool)0;
#line 218
  return (0);
}
}
#line 9 "/usr/local/ddv/models/con2/include/linux/spinlock.h"
void spin_lock_init(spinlock_t *lock ) ;
#line 12 "/usr/local/ddv/models/con2/include/ddverify/genhd.h"
short number_genhd_registered  =    (short)0;
#line 13 "/usr/local/ddv/models/con2/include/ddverify/genhd.h"
short number_fixed_genhd_used  =    (short)0;
#line 24 "/usr/local/ddv/models/con2/include/ddverify/genhd.h"
struct gendisk fixed_gendisk[10]  ;
#line 25 "/usr/local/ddv/models/con2/include/ddverify/genhd.h"
struct ddv_genhd genhd_registered[10]  ;
#line 14 "/usr/local/ddv/models/con2/include/ddverify/pci.h"
struct ddv_pci_driver registered_pci_driver  ;
#line 19
extern void call_pci_functions() ;
#line 14 "/usr/local/ddv/models/con2/include/ddverify/interrupt.h"
struct registered_irq registered_irq[16]  ;
#line 16
void call_interrupt_handler(void) ;
#line 8 "/usr/local/ddv/models/con2/include/ddverify/tasklet.h"
short number_tasklet_registered  =    (short)0;
#line 15 "/usr/local/ddv/models/con2/include/ddverify/tasklet.h"
struct ddv_tasklet tasklet_registered[10]  ;
#line 17
void call_tasklet_functions(void) ;
#line 8 "/usr/local/ddv/models/con2/include/ddverify/timer.h"
short number_timer_registered  =    (short)0;
#line 14 "/usr/local/ddv/models/con2/include/ddverify/timer.h"
struct ddv_timer timer_registered[5]  ;
#line 16
extern void call_timer_functions() ;
#line 8 "/usr/local/ddv/models/con2/include/ddverify/workqueue.h"
struct work_struct *shared_workqueue[10]  ;
#line 10
void call_shared_workqueue_functions(void) ;
#line 7 "/usr/local/ddv/models/con2/include/linux/smp_lock.h"
spinlock_t kernel_lock  ;
#line 15 "/usr/local/ddv/models/con2/src/ddverify/ddverify.c"
void init_kernel(void) 
{ 
  int i ;

  {
#line 19
  spin_lock_init(& kernel_lock);
#line 21
  i = 0;
#line 21
  while (i < 10) {
#line 22
    shared_workqueue[i] = (struct work_struct *)((void *)0);
#line 21
    i ++;
  }
#line 25
  i = 0;
#line 25
  while (i < 10) {
#line 26
    tasklet_registered[i].tasklet = (struct tasklet_struct *)((void *)0);
#line 27
    tasklet_registered[i].is_running = (unsigned short)0;
#line 25
    i ++;
  }
#line 29
  return;
}
}
#line 31 "/usr/local/ddv/models/con2/src/ddverify/ddverify.c"
static void *ddv_2(void *arg ) 
{ 
  unsigned short random ;

  {
#line 35
  while (1) {
#line 36
    random = nondet_ushort();
#line 38
    switch ((int )random) {
    case 1: 
#line 40
    current_execution_context = 2;
#line 41
    call_timer_functions();
#line 42
    current_execution_context = 1;
#line 43
    break;
    case 2: 
#line 46
    current_execution_context = 2;
#line 47
    call_interrupt_handler();
#line 48
    current_execution_context = 1;
#line 49
    break;
    case 3: 
#line 52
    current_execution_context = 1;
#line 53
    call_shared_workqueue_functions();
#line 54
    current_execution_context = 1;
#line 55
    break;
    case 4: 
#line 58
    current_execution_context = 2;
#line 59
    call_tasklet_functions();
#line 60
    current_execution_context = 1;
#line 61
    break;
    case 5: 
#line 64
    current_execution_context = 1;
#line 65
    call_pci_functions();
#line 66
    current_execution_context = 1;
#line 67
    break;
    default: 
#line 70
    break;
    }
#line 35
    if (! random) {
#line 35
      break;
    }
  }
#line 73
  return ((void *)0);
}
}
#line 75 "/usr/local/ddv/models/con2/src/ddverify/ddverify.c"
void ddv(void) 
{ 
  pthread_t___0 thread ;
  int tmp ;

  {
#line 81
  pthread_create((struct __pthread_t_struct *)(& thread), (struct __pthread_attr_t_struct  const  *)((void *)0),
                 & ddv_2, (void *)0);
#line 83
  while (1) {
#line 84
    current_execution_context = 1;
#line 86
    call_cdev_functions();
#line 83
    tmp = nondet_int();
#line 83
    if (! tmp) {
#line 83
      break;
    }
  }
#line 93
  return;
}
}
#line 95 "/usr/local/ddv/models/con2/src/ddverify/ddverify.c"
int call_ddv(void) 
{ 
  int err ;

  {
#line 99
  current_execution_context = 1;
#line 101
  init_kernel();
#line 103
  err = (*_ddv_module_init)();
#line 105
  if (err) {
#line 106
    return (-1);
  }
#line 110
  ddv();
#line 112
  current_execution_context = 1;
#line 113
  (*_ddv_module_exit)();
#line 115
  return (0);
}
}
#line 1 "genhd.o"
#pragma merger("0","/tmp/cil-5h1xR7X2.i","")
#line 9 "/usr/local/ddv/models/con2/include/ddverify/satabs.h"
extern void *malloc(size_t size ) ;
#line 207 "/usr/local/ddv/models/con2/include/linux/fs.h"
int register_blkdev(unsigned int major , char const   *name ) ;
#line 208
int unregister_blkdev(unsigned int major , char const   *name ) ;
#line 33 "/usr/local/ddv/models/con2/include/linux/genhd.h"
void add_disk(struct gendisk *disk ) ;
#line 35
void del_gendisk(struct gendisk *gp ) ;
#line 37
struct gendisk *alloc_disk(int minors ) ;
#line 6 "/usr/local/ddv/models/con2/src/linux/block/genhd.c"
int register_blkdev(unsigned int major , char const   *name ) 
{ 
  int result ;
  int tmp ;

  {
#line 8
  tmp = nondet_int();
#line 8
  result = tmp;
#line 14
  return (result);
}
}
#line 17 "/usr/local/ddv/models/con2/src/linux/block/genhd.c"
int unregister_blkdev(unsigned int major , char const   *name ) 
{ 


  {
#line 19
  return (0);
}
}
#line 22 "/usr/local/ddv/models/con2/src/linux/block/genhd.c"
struct gendisk *alloc_disk(int minors ) 
{ 
  struct gendisk *gd ;

  {
#line 26
  if ((int )number_fixed_genhd_used < 10) {
#line 27
    gd = & fixed_gendisk[number_fixed_genhd_used];
#line 28
    gd->minors = minors;
#line 30
    number_fixed_genhd_used = (short )((int )number_fixed_genhd_used + 1);
#line 32
    return (gd);
  } else {
#line 34
    return ((struct gendisk *)((void *)0));
  }
}
}
#line 38 "/usr/local/ddv/models/con2/src/linux/block/genhd.c"
void add_disk(struct gendisk *disk ) 
{ 
  void *tmp ;

  {
#line 40
  if ((int )number_genhd_registered < 10) {
#line 41
    genhd_registered[number_genhd_registered].gd = disk;
#line 42
    tmp = malloc((size_t )sizeof(struct block_device ));
#line 42
    genhd_registered[number_genhd_registered].inode.i_bdev = (struct block_device *)tmp;
#line 43
    (genhd_registered[number_genhd_registered].inode.i_bdev)->bd_disk = disk;
#line 45
    number_genhd_registered = (short )((int )number_genhd_registered + 1);
  }
#line 47
  return;
}
}
#line 49 "/usr/local/ddv/models/con2/src/linux/block/genhd.c"
void del_gendisk(struct gendisk *gp ) 
{ 
  int i ;

  {
#line 53
  i = 0;
#line 53
  while (i < (int )number_genhd_registered) {
#line 54
    if ((unsigned long )genhd_registered[i].gd == (unsigned long )gp) {
#line 55
      genhd_registered[i].gd = (struct gendisk *)((void *)0);
    }
#line 53
    i ++;
  }
#line 58
  return;
}
}
#line 1 "interrupt.o"
#pragma merger("0","/tmp/cil-61xvfhoU.i","")
#line 10 "/usr/local/ddv/models/con2/src/ddverify/interrupt.c"
void call_interrupt_handler(void) 
{ 
  unsigned short i ;
  struct pt_regs regs ;
  int tmp ;

  {
#line 15
  tmp = nondet_int();
#line 15
  i = (unsigned short )tmp;
#line 16
  __CPROVER_assume((int )i < 16);
#line 18
  if (registered_irq[i].handler) {
#line 19
    (*(registered_irq[i].handler))((int )i, registered_irq[i].dev_id, & regs);
  }
#line 22
  return;
}
}
#line 1 "ioctl.o"
#pragma merger("0","/tmp/cil-AIrRUcYx.i","")
#line 1 "ll_rw_blk.o"
#pragma merger("0","/tmp/cil-5yrrhUFS.i","")
#line 192 "/usr/local/ddv/models/con2/include/linux/blkdev.h"
request_queue_t *blk_alloc_queue(gfp_t gfp_mask ) ;
#line 194
request_queue_t *blk_init_queue(request_fn_proc *rfn , spinlock_t *lock ) ;
#line 196
void blk_queue_make_request(request_queue_t *q , make_request_fn *mfn ) ;
#line 198
void blk_queue_hardsect_size(request_queue_t *q , unsigned short size ) ;
#line 200
void blk_cleanup_queue(request_queue_t *q ) ;
#line 220
void end_request(struct request *req , int uptodate ) ;
#line 6 "/usr/local/ddv/models/con2/include/ddverify/blkdev.h"
request_queue_t fixed_request_queue[10]  ;
#line 8 "/usr/local/ddv/models/con2/include/ddverify/blkdev.h"
int number_request_queue_used  =    0;
#line 7 "/usr/local/ddv/models/con2/src/linux/block/ll_rw_blk.c"
request_queue_t *get_fixed_request_queue(void) 
{ 
  int tmp ;

  {
#line 9
  if (number_request_queue_used < 10) {
#line 10
    tmp = number_request_queue_used;
#line 10
    number_request_queue_used ++;
#line 10
    return (& fixed_request_queue[tmp]);
  } else {
#line 12
    return ((request_queue_t *)((void *)0));
  }
}
}
#line 16 "/usr/local/ddv/models/con2/src/linux/block/ll_rw_blk.c"
request_queue_t *blk_init_queue(request_fn_proc *rfn , spinlock_t *lock ) 
{ 
  request_queue_t *queue ;
  int tmp ;

  {
#line 20
  tmp = nondet_int();
#line 20
  if (tmp) {
#line 21
    queue = get_fixed_request_queue();
#line 23
    queue->queue_lock = lock;
#line 24
    queue->request_fn = rfn;
#line 25
    queue->make_request_fn = (make_request_fn *)((void *)0);
#line 26
    queue->__ddv_queue_alive = 1;
#line 28
    return (queue);
  } else {
#line 30
    return ((request_queue_t *)((void *)0));
  }
}
}
#line 34 "/usr/local/ddv/models/con2/src/linux/block/ll_rw_blk.c"
request_queue_t *blk_alloc_queue(gfp_t gfp_mask ) 
{ 
  request_queue_t *queue ;
  int tmp ;

  {
#line 38
  tmp = nondet_int();
#line 38
  if (tmp) {
#line 39
    queue = get_fixed_request_queue();
#line 41
    queue->request_fn = (request_fn_proc *)((void *)0);
#line 42
    queue->make_request_fn = (make_request_fn *)((void *)0);
#line 43
    queue->__ddv_queue_alive = 1;
#line 45
    return (queue);
  } else {
#line 47
    return ((request_queue_t *)((void *)0));
  }
}
}
#line 51 "/usr/local/ddv/models/con2/src/linux/block/ll_rw_blk.c"
void blk_queue_make_request(request_queue_t *q , make_request_fn *mfn ) 
{ 


  {
#line 53
  q->make_request_fn = mfn;
#line 54
  return;
}
}
#line 56 "/usr/local/ddv/models/con2/src/linux/block/ll_rw_blk.c"
void end_request(struct request *req , int uptodate ) 
{ 
  int genhd_no ;

  {
#line 58
  genhd_no = ((req->rq_disk)->queue)->__ddv_genhd_no;
#line 60
  genhd_registered[genhd_no].requests_open = 0;
#line 61
  return;
}
}
#line 64 "/usr/local/ddv/models/con2/src/linux/block/ll_rw_blk.c"
void blk_queue_hardsect_size(request_queue_t *q , unsigned short size ) 
{ 


  {
#line 66
  q->hardsect_size = size;
#line 67
  return;
}
}
#line 69 "/usr/local/ddv/models/con2/src/linux/block/ll_rw_blk.c"
void blk_cleanup_queue(request_queue_t *q ) 
{ 


  {
#line 71
  q->__ddv_queue_alive = 0;
#line 72
  return;
}
}
#line 1 "__main.o"
#pragma merger("0","/tmp/cil-iTBHC4Nb.i","")
#line 26 "/usr/local/ddv/models/con2/include/linux/timer.h"
void init_timer(struct timer_list *timer ) ;
#line 28
void add_timer(struct timer_list *timer ) ;
#line 29
int del_timer(struct timer_list *timer ) ;
#line 12 "/usr/local/ddv/models/con2/include/linux/spinlock.h"
void spin_lock_irq(spinlock_t *lock ) ;
#line 17
void spin_unlock_irq(spinlock_t *lock ) ;
#line 75 "/usr/local/ddv/models/con2/include/linux/wait.h"
void wake_up_interruptible(wait_queue_head_t *q ) ;
#line 85
extern int waitqueue_active(wait_queue_head_t *q ) ;
#line 90
void interruptible_sleep_on(wait_queue_head_t *q ) ;
#line 10 "/usr/local/ddv/models/con2/include/linux/slab.h"
void *kmalloc(size_t size , gfp_t flags ) ;
#line 4 "/usr/local/ddv/models/con2/include/asm/string.h"
extern void *memset(void *s , int c , unsigned int n ) ;
#line 30 "/usr/local/ddv/models/con2/include/linux/string.h"
extern void *memcpy(void * , void const   * , __kernel_size_t  ) ;
#line 34 "/usr/local/ddv/models/con2/include/linux/kernel.h"
extern int printk(char const   *fmt  , ...) ;
#line 35
extern int sprintf(char *buf , char const   *fmt  , ...) ;
#line 4 "/usr/local/ddv/models/con2/include/asm/delay.h"
extern void udelay(int  ) ;
#line 50 "/usr/local/ddv/models/con2/include/linux/interrupt.h"
void tasklet_schedule(struct tasklet_struct *t ) ;
#line 75
int request_irq(unsigned int irq , irqreturn_t (*handler)(int  , void * , struct pt_regs * ) ,
                unsigned long irqflags , char const   *devname , void *dev_id ) ;
#line 78
void free_irq(unsigned int irq , void *dev_id ) ;
#line 81
extern unsigned long probe_irq_on(void) ;
#line 83
extern int probe_irq_off(unsigned long  ) ;
#line 88
extern void cli(void) ;
#line 90
extern void sti(void) ;
#line 90 "/usr/local/ddv/models/con2/include/linux/ioport.h"
struct resource *request_region(unsigned long start , unsigned long len , char const   *name ) ;
#line 92
void release_region(unsigned long start , unsigned long len ) ;
#line 989 "/usr/local/ddv/models/con2/include/linux/cdrom.h"
extern int cdrom_open(struct cdrom_device_info *cdi , struct inode *ip , struct file *fp ) ;
#line 991
extern int cdrom_release(struct cdrom_device_info *cdi , struct file *fp ) ;
#line 992
extern int cdrom_ioctl(struct file *file , struct cdrom_device_info *cdi , struct inode *ip ,
                       unsigned int cmd , unsigned long arg ) ;
#line 994
extern int cdrom_media_changed(struct cdrom_device_info * ) ;
#line 996
extern int register_cdrom(struct cdrom_device_info *cdi ) ;
#line 997
extern int unregister_cdrom(struct cdrom_device_info *cdi ) ;
#line 14 "/usr/local/ddv/models/con2/include/asm/io.h"
unsigned char inb(unsigned int port ) ;
#line 16
unsigned short inw(unsigned int port ) ;
#line 17
void outw(unsigned short word , unsigned int port ) ;
#line 35
extern unsigned int insw(unsigned int  , void *addr , unsigned long count ) ;
#line 39 "/usr/local/ddv/models/con2/include/linux/genhd.h"
extern void put_disk(struct gendisk *disk ) ;
#line 4 "/usr/local/ddv/models/con2/include/linux/elevator.h"
extern struct request *elv_next_request(struct request_queue *q ) ;
#line 214 "cm206.c"
static int auto_probe  =    1;
#line 216 "cm206.c"
static int cm206_base  =    832;
#line 217 "cm206.c"
static int cm206_irq  =    11;
#line 219 "cm206.c"
static int cm206[2]  = {      0,      0};
#line 226 "cm206.c"
char _ddv_module_license[4]  = {      (char )'G',      (char )'P',      (char )'L',      (char )'\000'};
#line 302 "cm206.c"
static struct cm206_struct *cd  ;
#line 303 "cm206.c"
static struct request_queue *cm206_queue  ;
#line 304 "cm206.c"
static spinlock_t cm206_lock  =    {1, 0};
#line 309 "cm206.c"
static void send_command_polled(int command ) 
{ 
  int loop ;
  unsigned short tmp ;

  {
#line 311
  loop = 100;
#line 312
  while (1) {
#line 312
    tmp = inw((unsigned int )(cm206_base + 6));
#line 312
    if ((int )tmp & 1) {
#line 312
      break;
    } else
#line 312
    if (! (loop > 0)) {
#line 312
      break;
    }
#line 314
    while (1) {
#line 314
      break;
    }
#line 315
    loop --;
  }
#line 317
  outw((unsigned short )command, (unsigned int )(cm206_base + 10));
#line 318
  return;
}
}
#line 320 "cm206.c"
static uch receive_echo_polled(void) 
{ 
  int loop ;
  unsigned short tmp ;
  unsigned short tmp___0 ;

  {
#line 322
  loop = 100;
#line 323
  while (1) {
#line 323
    tmp = inw((unsigned int )(cm206_base + 6));
#line 323
    if ((int )tmp & 2) {
#line 323
      break;
    } else
#line 323
    if (! (loop > 0)) {
#line 323
      break;
    }
#line 324
    while (1) {
#line 324
      break;
    }
#line 325
    loop --;
  }
#line 327
  tmp___0 = inw((unsigned int )(cm206_base + 2));
#line 327
  return ((uch )tmp___0);
}
}
#line 330 "cm206.c"
static uch send_receive_polled(int command ) 
{ 
  uch tmp ;

  {
#line 332
  send_command_polled(command);
#line 333
  tmp = receive_echo_polled();
#line 333
  return (tmp);
}
}
#line 336 "cm206.c"
__inline static void clear_ur(void) 
{ 


  {
#line 338
  if ((int volatile   )cd->ur_r != (int volatile   )cd->ur_w) {
#line 340
    while ((int volatile   )cd->ur_r != (int volatile   )cd->ur_w) {
#line 340
      cd->ur_r = (uch volatile   )((int volatile   )cd->ur_r + (int volatile   )1);
#line 340
      cd->ur_r = (uch volatile   )((int volatile   )cd->ur_r % (int volatile   )4);
    }
  }
#line 345
  return;
}
}
#line 347
static struct tasklet_struct cm206_tasklet ;
#line 362 "cm206.c"
static irqreturn_t cm206_interrupt(int sig , void *dev_id ) 
{ 
  ush volatile   fool ;
  unsigned short tmp ;
  unsigned short tmp___0 ;
  int tmp___1 ;
  unsigned char tmp___2 ;
  unsigned short tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  unsigned short tmp___7 ;
  unsigned short tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;

  {
#line 365
  tmp = inw((unsigned int )cm206_base);
#line 365
  cd->intr_ds = (ush volatile   )tmp;
#line 368
  tmp___0 = inw((unsigned int )(cm206_base + 6));
#line 368
  cd->intr_ls = (ush volatile   )tmp___0;
#line 371
  if ((int volatile   )cd->intr_ls & (int volatile   )16) {
#line 372
    (cd->stats[20]) ++;
#line 372
    tmp___1 = cd->stat_counter;
#line 372
    (cd->stat_counter) ++;
#line 372
    cd->last_stat[20] = tmp___1;
  }
#line 374
  if ((int volatile   )cd->intr_ls & (int volatile   )2) {
#line 375
    tmp___2 = inb((unsigned int )(cm206_base + 2));
#line 375
    cd->ur[cd->ur_w] = (uch volatile   )tmp___2;
#line 376
    tmp___3 = inw((unsigned int )(cm206_base + 6));
#line 376
    cd->intr_ls = (ush volatile   )tmp___3;
#line 379
    cd->ur_w = (uch volatile   )((int volatile   )cd->ur_w + (int volatile   )1);
#line 380
    cd->ur_w = (uch volatile   )((int volatile   )cd->ur_w % (int volatile   )4);
#line 383
    tmp___4 = waitqueue_active(& cd->uart);
#line 383
    if (tmp___4) {
#line 383
      if ((int )cd->background < 2) {
#line 384
        del_timer(& cd->timer);
#line 385
        wake_up_interruptible(& cd->uart);
      }
    }
  } else
#line 389
  if ((int volatile   )cd->intr_ds & (int volatile   )128) {
#line 390
    if (cd->background) {
#line 391
      (cd->adapter_last) ++;
    }
#line 392
    tmp___5 = waitqueue_active(& cd->data);
#line 392
    if (tmp___5) {
#line 392
      if (cd->wait_back) {
#line 394
        del_timer(& cd->timer);
#line 395
        wake_up_interruptible(& cd->data);
      } else
#line 392
      if (! cd->background) {
#line 394
        del_timer(& cd->timer);
#line 395
        wake_up_interruptible(& cd->data);
      }
    }
#line 397
    (cd->stats[1]) ++;
#line 397
    tmp___6 = cd->stat_counter;
#line 397
    (cd->stat_counter) ++;
#line 397
    cd->last_stat[1] = tmp___6;
  } else
#line 400
  if (cd->command) {
#line 400
    if ((int volatile   )cd->intr_ls & (int volatile   )1) {
#line 401
      tmp___7 = inw((unsigned int )cm206_base);
#line 401
      outw((unsigned short )(10496 | ((int )tmp___7 & 127)), (unsigned int )(cm206_base + 8));
#line 403
      outw((unsigned short )cd->command, (unsigned int )(cm206_base + 10));
#line 404
      cd->command = 0;
#line 405
      if (! cd->background) {
#line 406
        wake_up_interruptible(& cd->uart);
      }
    } else {
#line 400
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 409
  if ((int volatile   )cd->intr_ds & (int volatile   )256) {
#line 412
    tmp___8 = inw((unsigned int )(cm206_base + 4));
#line 412
    fool = (ush volatile   )tmp___8;
#line 413
    cd->fifo_overflowed = (char)1;
#line 414
    (cd->stats[2]) ++;
#line 414
    tmp___9 = cd->stat_counter;
#line 414
    (cd->stat_counter) ++;
#line 414
    cd->last_stat[2] = tmp___9;
  } else
#line 415
  if ((int volatile   )cd->intr_ds & (int volatile   )512) {
#line 417
    (cd->stats[3]) ++;
#line 417
    tmp___10 = cd->stat_counter;
#line 417
    (cd->stat_counter) ++;
#line 417
    cd->last_stat[3] = tmp___10;
  } else
#line 418
  if ((int volatile   )cd->intr_ds & (int volatile   )1024) {
#line 420
    (cd->stats[4]) ++;
#line 420
    tmp___11 = cd->stat_counter;
#line 420
    (cd->stat_counter) ++;
#line 420
    cd->last_stat[4] = tmp___11;
  } else
#line 421
  if ((int volatile   )cd->intr_ds & (int volatile   )2048) {
#line 423
    (cd->stats[5]) ++;
#line 423
    tmp___12 = cd->stat_counter;
#line 423
    (cd->stat_counter) ++;
#line 423
    cd->last_stat[5] = tmp___12;
  } else
#line 424
  if (! ((int volatile   )cd->intr_ds & (int volatile   )8192)) {
#line 429
    outw((unsigned short)10497, (unsigned int )(cm206_base + 8));
#line 430
    (cd->stats[6]) ++;
#line 430
    tmp___13 = cd->stat_counter;
#line 430
    (cd->stat_counter) ++;
#line 430
    cd->last_stat[6] = tmp___13;
  }
#line 432
  if (cd->background) {
#line 432
    if (cd->adapter_last - cd->adapter_first == (int )cd->max_sectors) {
#line 435
      tasklet_schedule(& cm206_tasklet);
    } else
#line 432
    if (cd->fifo_overflowed) {
#line 435
      tasklet_schedule(& cm206_tasklet);
    }
  }
#line 436
  (cd->stats[0]) ++;
#line 436
  tmp___14 = cd->stat_counter;
#line 436
  (cd->stat_counter) ++;
#line 436
  cd->last_stat[0] = tmp___14;
#line 437
  return (1);
}
}
#line 441 "cm206.c"
static void cm206_timeout(unsigned long who ) 
{ 


  {
#line 443
  cd->timed_out = (char)1;
#line 445
  wake_up_interruptible((wait_queue_head_t *)who);
#line 446
  return;
}
}
#line 450 "cm206.c"
static int sleep_or_timeout(wait_queue_head_t *wait , int timeout ) 
{ 


  {
#line 452
  cd->timed_out = (char)0;
#line 453
  init_timer(& cd->timer);
#line 454
  cd->timer.data = (unsigned long )wait;
#line 455
  cd->timer.expires = jiffies + (unsigned long )timeout;
#line 456
  add_timer(& cd->timer);
#line 458
  interruptible_sleep_on(wait);
#line 459
  del_timer(& cd->timer);
#line 460
  if (cd->timed_out) {
#line 461
    cd->timed_out = (char)0;
#line 462
    return (1);
  } else {
#line 464
    return (0);
  }
}
}
#line 467 "cm206.c"
static void send_command(int command ) 
{ 
  unsigned short tmp ;
  int tmp___0 ;
  int tmp___1 ;
  unsigned short tmp___2 ;

  {
#line 470
  tmp___2 = inw((unsigned int )(cm206_base + 6));
#line 470
  if ((int )tmp___2 & 1) {
#line 483
    outw((unsigned short )command, (unsigned int )(cm206_base + 10));
  } else {
#line 471
    cd->command = command;
#line 472
    cli();
#line 473
    tmp = inw((unsigned int )cm206_base);
#line 473
    outw((unsigned short )(10240 | ((int )tmp & 127)), (unsigned int )(cm206_base + 8));
#line 476
    tmp___1 = sleep_or_timeout(& cd->uart, 5);
#line 476
    if (tmp___1) {
#line 478
      (cd->stats[8]) ++;
#line 478
      tmp___0 = cd->stat_counter;
#line 478
      (cd->stat_counter) ++;
#line 478
      cd->last_stat[8] = tmp___0;
#line 479
      outw((unsigned short )command, (unsigned int )(cm206_base + 10));
    }
  }
#line 484
  return;
}
}
#line 486 "cm206.c"
static uch receive_byte(int timeout ) 
{ 
  uch ret ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 489
  cli();
#line 491
  ret = (uch )cd->ur[cd->ur_r];
#line 492
  if ((int volatile   )cd->ur_r != (int volatile   )cd->ur_w) {
#line 493
    sti();
#line 496
    cd->ur_r = (uch volatile   )((int volatile   )cd->ur_r + (int volatile   )1);
#line 497
    cd->ur_r = (uch volatile   )((int volatile   )cd->ur_r % (int volatile   )4);
#line 498
    return (ret);
  } else {
#line 499
    tmp___1 = sleep_or_timeout(& cd->uart, timeout);
#line 499
    if (tmp___1) {
#line 502
      if (timeout == 5) {
#line 503
        (cd->stats[9]) ++;
#line 503
        tmp = cd->stat_counter;
#line 503
        (cd->stat_counter) ++;
#line 503
        cd->last_stat[9] = tmp;
      } else {
#line 505
        (cd->stats[11]) ++;
#line 505
        tmp___0 = cd->stat_counter;
#line 505
        (cd->stat_counter) ++;
#line 505
        cd->last_stat[11] = tmp___0;
      }
#line 507
      return ((uch )218);
    }
  }
#line 509
  ret = (uch )cd->ur[cd->ur_r];
#line 512
  cd->ur_r = (uch volatile   )((int volatile   )cd->ur_r + (int volatile   )1);
#line 513
  cd->ur_r = (uch volatile   )((int volatile   )cd->ur_r % (int volatile   )4);
#line 514
  return (ret);
}
}
#line 517 "cm206.c"
__inline static uch receive_echo(void) 
{ 
  uch tmp ;

  {
#line 519
  tmp = receive_byte(5);
#line 519
  return (tmp);
}
}
#line 522 "cm206.c"
__inline static uch send_receive(int command ) 
{ 
  uch tmp ;

  {
#line 524
  send_command(command);
#line 525
  tmp = receive_echo();
#line 525
  return (tmp);
}
}
#line 528 "cm206.c"
__inline static uch wait_dsb(void) 
{ 
  uch tmp ;

  {
#line 530
  tmp = receive_byte(700);
#line 530
  return (tmp);
}
}
#line 533 "cm206.c"
static int type_0_command(int command , int expect_dsb ) 
{ 
  int e ;
  int tmp ;
  uch tmp___0 ;
  uch tmp___1 ;

  {
#line 536
  clear_ur();
#line 537
  tmp___0 = send_receive(command);
#line 537
  e = (int )tmp___0;
#line 537
  if (command != e) {
#line 539
    (cd->stats[7]) ++;
#line 539
    tmp = cd->stat_counter;
#line 539
    (cd->stat_counter) ++;
#line 539
    cd->last_stat[7] = tmp;
#line 540
    return (-1);
  }
#line 542
  if (expect_dsb) {
#line 543
    tmp___1 = wait_dsb();
#line 543
    cd->dsb = (uch volatile   )tmp___1;
  }
#line 545
  return (0);
}
}
#line 548 "cm206.c"
static int type_1_command(int command , int bytes , uch *status ) 
{ 
  int i ;
  int tmp ;

  {
#line 551
  tmp = type_0_command(command, 0);
#line 551
  if (tmp) {
#line 552
    return (-1);
  }
#line 553
  i = 0;
#line 553
  while (i < bytes) {
#line 554
    *(status + i) = send_receive(248);
#line 553
    i ++;
  }
#line 555
  return (0);
}
}
#line 560 "cm206.c"
static void reset_cm260(void) 
{ 


  {
#line 562
  outw((unsigned short)11009, (unsigned int )(cm206_base + 8));
#line 563
  udelay(10);
#line 564
  outw((unsigned short)10497, (unsigned int )(cm206_base + 8));
#line 565
  return;
}
}
#line 568 "cm206.c"
static void fsm(int lba , uch *fsm___0 ) 
{ 


  {
#line 570
  *(fsm___0 + 0) = (uch )(lba % 75);
#line 571
  lba /= 75;
#line 572
  lba += 2;
#line 573
  *(fsm___0 + 1) = (uch )(lba % 60);
#line 574
  *(fsm___0 + 2) = (uch )(lba / 60);
#line 575
  return;
}
}
#line 577 "cm206.c"
__inline static int fsm2lba(uch *fsm___0 ) 
{ 


  {
#line 579
  return ((int )*(fsm___0 + 0) + 75 * (((int )*(fsm___0 + 1) - 2) + 60 * (int )*(fsm___0 + 2)));
}
}
#line 582 "cm206.c"
__inline static int f_s_m2lba(uch f , uch s , uch m ) 
{ 


  {
#line 584
  return ((int )f + 75 * (((int )s - 2) + 60 * (int )m));
}
}
#line 587 "cm206.c"
static int start_read(int start ) 
{ 
  uch read_sector___0[4] ;
  unsigned int tmp ;
  int i ;
  int e ;
  int tmp___0 ;
  uch tmp___1 ;
  uch tmp___2 ;

  {
#line 589
  read_sector___0[0] = (uch )32;
#line 589
  tmp = 1U;
#line 589
  while (! (tmp >= 4U)) {
#line 589
    read_sector___0[tmp] = (unsigned char)0;
#line 589
    tmp ++;
  }
#line 592
  fsm(start, & read_sector___0[1]);
#line 593
  clear_ur();
#line 594
  i = 0;
#line 594
  while (i < 4) {
#line 595
    tmp___2 = send_receive((int )read_sector___0[i]);
#line 595
    e = (int )tmp___2;
#line 595
    if ((int )read_sector___0[i] != e) {
#line 598
      (cd->stats[7]) ++;
#line 598
      tmp___0 = cd->stat_counter;
#line 598
      (cd->stat_counter) ++;
#line 598
      cd->last_stat[7] = tmp___0;
#line 599
      if (e == 255) {
#line 600
        tmp___1 = receive_echo();
#line 600
        e = (int )tmp___1;
#line 602
        if (e != (int )read_sector___0[i]) {
#line 603
          return (-1);
        }
      }
    }
#line 594
    i ++;
  }
#line 606
  return (0);
}
}
#line 609 "cm206.c"
static int stop_read(void) 
{ 
  int e ;
  int tmp ;
  uch tmp___0 ;

  {
#line 612
  type_0_command(112, 0);
#line 613
  tmp___0 = receive_echo();
#line 613
  e = (int )tmp___0;
#line 613
  if (e != 255) {
#line 615
    (cd->stats[12]) ++;
#line 615
    tmp = cd->stat_counter;
#line 615
    (cd->stat_counter) ++;
#line 615
    cd->last_stat[12] = tmp;
#line 616
    return (-1);
  }
#line 618
  return (0);
}
}
#line 626 "cm206.c"
static int read_background(int start , int reading ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 628
  if (cd->background) {
#line 629
    return (-1);
  }
#line 630
  outw((unsigned short)10497, (unsigned int )(cm206_base + 8));
#line 631
  if (! reading) {
#line 631
    tmp = start_read(start);
#line 631
    if (tmp) {
#line 632
      return (-2);
    }
  }
#line 633
  tmp___0 = start;
#line 633
  cd->adapter_last = tmp___0;
#line 633
  cd->adapter_first = tmp___0;
#line 634
  cd->background = (char)1;
#line 635
  return (0);
}
}
#line 654 "cm206.c"
static int read_sector(int start ) 
{ 
  int tries ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 656
  tries = 0;
#line 657
  if (cd->background) {
#line 658
    cd->background = (char)0;
#line 659
    cd->adapter_last = -1;
#line 660
    stop_read();
  }
#line 662
  cd->fifo_overflowed = (char)0;
#line 663
  reset_cm260();
#line 664
  tmp = start_read(start);
#line 664
  if (tmp) {
#line 665
    return (-1);
  }
#line 666
  while (1) {
#line 667
    tmp___1 = sleep_or_timeout(& cd->data, 300);
#line 667
    if (tmp___1) {
#line 669
      (cd->stats[10]) ++;
#line 669
      tmp___0 = cd->stat_counter;
#line 669
      (cd->stat_counter) ++;
#line 669
      cd->last_stat[10] = tmp___0;
#line 670
      stop_read();
#line 671
      return (-3);
    }
#line 673
    tries ++;
#line 666
    if ((int volatile   )cd->intr_ds & (int volatile   )4096) {
#line 666
      if (! (tries < 100)) {
#line 666
        break;
      }
    } else {
#line 666
      break;
    }
  }
#line 680
  insw((unsigned int )(cm206_base + 4), (void *)(cd->sector), 1176UL);
#line 682
  tmp___3 = read_background(start + 1, 1);
#line 682
  if (tmp___3) {
#line 683
    (cd->stats[16]) ++;
#line 683
    tmp___2 = cd->stat_counter;
#line 683
    (cd->stat_counter) ++;
#line 683
    cd->last_stat[16] = tmp___2;
  }
#line 684
  cd->sector_first = start;
#line 685
  cd->sector_last = start + 1;
#line 686
  (cd->stats[15]) ++;
#line 686
  tmp___4 = cd->stat_counter;
#line 686
  (cd->stat_counter) ++;
#line 686
  cd->last_stat[15] = tmp___4;
#line 687
  return (0);
}
}
#line 700 "cm206.c"
static void cm206_tasklet_func(unsigned long ignore ) 
{ 
  int tmp ;
  unsigned short tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 703
  switch ((int )cd->background) {
  case 1: 
#line 705
  (cd->stats[17]) ++;
#line 705
  tmp = cd->stat_counter;
#line 705
  (cd->stat_counter) ++;
#line 705
  cd->last_stat[17] = tmp;
#line 706
  if (! ((int volatile   )cd->intr_ls & (int volatile   )1)) {
#line 707
    cd->command = 112;
#line 708
    tmp___0 = inw((unsigned int )cm206_base);
#line 708
    outw((unsigned short )(10240 | ((int )tmp___0 & 127)), (unsigned int )(cm206_base + 8));
#line 710
    cd->background = (char)2;
#line 711
    break;
  } else {
#line 713
    outw((unsigned short)112, (unsigned int )(cm206_base + 10));
  }
  case 2: 
#line 717
  cd->background = (char)3;
#line 718
  break;
  case 3: 
#line 720
  if ((int volatile   )cd->ur_r != (int volatile   )cd->ur_w) {
#line 721
    if ((int volatile   )cd->ur[cd->ur_r] != (int volatile   )112) {
#line 724
      (cd->stats[7]) ++;
#line 724
      tmp___1 = cd->stat_counter;
#line 724
      (cd->stat_counter) ++;
#line 724
      cd->last_stat[7] = tmp___1;
    }
#line 726
    cd->ur_r = (uch volatile   )((int volatile   )cd->ur_r + (int volatile   )1);
#line 727
    cd->ur_r = (uch volatile   )((int volatile   )cd->ur_r % (int volatile   )4);
  }
#line 729
  cd->background = (char )((int )cd->background + 1);
#line 730
  break;
  case 4: 
#line 732
  if ((int volatile   )cd->ur_r != (int volatile   )cd->ur_w) {
#line 733
    if ((int volatile   )cd->ur[cd->ur_r] != (int volatile   )255) {
#line 735
      (cd->stats[12]) ++;
#line 735
      tmp___2 = cd->stat_counter;
#line 735
      (cd->stat_counter) ++;
#line 735
      cd->last_stat[12] = tmp___2;
    }
#line 737
    cd->ur_r = (uch volatile   )((int volatile   )cd->ur_r + (int volatile   )1);
#line 738
    cd->ur_r = (uch volatile   )((int volatile   )cd->ur_r % (int volatile   )4);
  }
#line 740
  cd->background = (char)0;
  }
#line 742
  return;
}
}
#line 744 "cm206.c"
static struct tasklet_struct cm206_tasklet  =    {0, & cm206_tasklet_func, 0UL, 1};
#line 749 "cm206.c"
static void get_drive_status(void) 
{ 
  uch status[2] ;

  {
#line 752
  type_1_command(80, 2, status);
#line 753
  cd->dsb = (uch volatile   )status[0];
#line 754
  cd->cc = (uch volatile   )status[1];
#line 755
  cd->media_changed = (uch )((int )cd->media_changed | ! (! ((int volatile   )cd->dsb & (int volatile   )168)));
#line 758
  return;
}
}
#line 760 "cm206.c"
static void get_disc_status(void) 
{ 


  {
#line 762
  type_1_command(81, 7, cd->disc_status);
#line 765
  return;
}
}
#line 769 "cm206.c"
static int cm206_open(struct cdrom_device_info *cdi , int purpose ) 
{ 
  int tmp ;

  {
#line 771
  if (! cd->openfiles) {
#line 772
    cd->background = (char)0;
#line 773
    reset_cm260();
#line 774
    cd->adapter_last = -1;
#line 775
    cd->sector_last = -1;
  }
#line 777
  (cd->openfiles) ++;
#line 778
  (cd->stats[18]) ++;
#line 778
  tmp = cd->stat_counter;
#line 778
  (cd->stat_counter) ++;
#line 778
  cd->last_stat[18] = tmp;
#line 779
  return (0);
}
}
#line 782 "cm206.c"
static void cm206_release(struct cdrom_device_info *cdi ) 
{ 


  {
#line 784
  if (cd->openfiles == 1) {
#line 785
    if (cd->background) {
#line 786
      cd->background = (char)0;
#line 787
      stop_read();
    }
#line 789
    cd->sector_last = -1;
#line 790
    cd->disc_status[1] = (uch )0;
  }
#line 792
  (cd->openfiles) --;
#line 793
  return;
}
}
#line 797 "cm206.c"
static void empty_buffer(int sectors ) 
{ 
  int tmp ;

  {
#line 799
  while (sectors >= 0) {
#line 800
    insw((unsigned int )(cm206_base + 4), (void *)(cd->sector + (int )cd->fifo_overflowed),
         (unsigned long )(1176 - (int )cd->fifo_overflowed));
#line 803
    sectors --;
#line 804
    (cd->adapter_first) ++;
#line 805
    cd->fifo_overflowed = (char)0;
#line 806
    (cd->stats[14]) ++;
#line 806
    tmp = cd->stat_counter;
#line 806
    (cd->stat_counter) ++;
#line 806
    cd->last_stat[14] = tmp;
  }
#line 808
  cd->sector_first = cd->adapter_first - 1;
#line 809
  cd->sector_last = cd->adapter_first;
#line 810
  return;
}
}
#line 815 "cm206.c"
static int try_adapter(int sector ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 817
  if (cd->adapter_first <= sector) {
#line 817
    if (sector < cd->adapter_last) {
#line 819
      empty_buffer(sector - cd->adapter_first);
#line 820
      return (0);
    } else {
#line 817
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 821
  if ((int )cd->background == 1) {
#line 821
    if (cd->adapter_first <= sector) {
#line 821
      if (sector < cd->adapter_first + (int )cd->max_sectors) {
#line 824
        cd->wait_back = (char)1;
#line 825
        while (sector >= cd->adapter_last) {
#line 826
          tmp___0 = sleep_or_timeout(& cd->data, 300);
#line 826
          if (tmp___0) {
#line 828
            (cd->stats[13]) ++;
#line 828
            tmp = cd->stat_counter;
#line 828
            (cd->stat_counter) ++;
#line 828
            cd->last_stat[13] = tmp;
#line 829
            cd->wait_back = (char)0;
#line 830
            return (-1);
          }
        }
#line 833
        cd->wait_back = (char)0;
#line 834
        empty_buffer(sector - cd->adapter_first);
#line 835
        return (0);
      } else {
#line 837
        return (-2);
      }
    } else {
#line 837
      return (-2);
    }
  } else {
#line 837
    return (-2);
  }
}
}
#line 843 "cm206.c"
static void do_cm206_request(request_queue_t *q ) 
{ 
  long i ;
  long cd_sec_no ;
  int quarter ;
  int error ;
  uch *source ;
  uch *dest ;
  struct request *req ;
  int e1 ;
  int e2 ;

  {
#line 850
  while (1) {
#line 851
    req = elv_next_request(q);
#line 852
    if (! req) {
#line 853
      return;
    }
#line 855
    if ((unsigned long )(req->cmd) != (unsigned long )((unsigned char *)0)) {
#line 857
      end_request(req, 0);
#line 858
      continue;
    }
#line 860
    spin_unlock_irq(q->queue_lock);
#line 861
    error = 0;
#line 862
    i = 0L;
#line 862
    while ((unsigned long )i < req->nr_sectors) {
#line 864
      cd_sec_no = (long )((req->sector + (sector_t )i) / 4UL);
#line 865
      quarter = (int )((req->sector + (sector_t )i) % 4UL);
#line 866
      dest = (uch *)(req->buffer + i * 512L);
#line 868
      if ((long )cd->sector_first <= cd_sec_no) {
#line 868
        if (cd_sec_no < (long )cd->sector_last) {
#line 870
          source = (((uch *)(cd->sector) + 16) + quarter * 512) + (cd_sec_no - (long )cd->sector_first) * 2352L;
#line 875
          memcpy((void *)dest, (void const   *)source, (__kernel_size_t )512);
        } else {
#line 868
          goto _L;
        }
      } else {
        _L: /* CIL Label */ 
#line 876
        e1 = try_adapter((int )cd_sec_no);
#line 876
        if (e1) {
#line 876
          e2 = read_sector((int )cd_sec_no);
#line 876
          if (e2) {
#line 883
            error = 1;
          } else {
#line 878
            source = ((uch *)(cd->sector) + 16) + quarter * 512;
#line 881
            memcpy((void *)dest, (void const   *)source, (__kernel_size_t )512);
          }
        } else {
#line 878
          source = ((uch *)(cd->sector) + 16) + quarter * 512;
#line 881
          memcpy((void *)dest, (void const   *)source, (__kernel_size_t )512);
        }
      }
#line 862
      i ++;
    }
#line 887
    spin_lock_irq(q->queue_lock);
#line 888
    end_request(req, ! error);
  }
}
}
#line 906 "cm206.c"
static void seek(int lba ) 
{ 
  int i ;
  uch seek_command[4] ;
  unsigned int tmp ;
  uch tmp___0 ;

  {
#line 909
  seek_command[0] = (uch )16;
#line 909
  tmp = 1U;
#line 909
  while (! (tmp >= 4U)) {
#line 909
    seek_command[tmp] = (unsigned char)0;
#line 909
    tmp ++;
  }
#line 911
  fsm(lba, & seek_command[1]);
#line 912
  i = 0;
#line 912
  while (i < 4) {
#line 913
    type_0_command((int )seek_command[i], 0);
#line 912
    i ++;
  }
#line 914
  tmp___0 = wait_dsb();
#line 914
  cd->dsb = (uch volatile   )tmp___0;
#line 915
  return;
}
}
#line 917 "cm206.c"
static uch bcdbin(unsigned char bcd ) 
{ 


  {
#line 919
  return ((uch )(((int )bcd >> 4) * 10 + ((int )bcd & 15)));
}
}
#line 922 "cm206.c"
__inline static uch normalize_track(uch track ) 
{ 


  {
#line 924
  if ((int )track < 1) {
#line 925
    return ((uch )1);
  }
#line 926
  if ((int )track > (int )cd->disc_status[2]) {
#line 927
    return ((uch )((int )cd->disc_status[2] + 1));
  }
#line 928
  return (track);
}
}
#line 935 "cm206.c"
static int get_toc_lba(uch track ) 
{ 
  int max ;
  int min ;
  int tmp ;
  int i ;
  int lba ;
  int l ;
  int old_lba ;
  uch *q ;
  uch ct ;
  int binary ;
  int skip ;
  uch tmp___0 ;
  uch tmp___1 ;
  uch tmp___2 ;

  {
#line 937
  max = 332850;
#line 937
  tmp = fsm2lba(cd->toc[1].fsm);
#line 937
  min = tmp;
#line 938
  old_lba = 0;
#line 939
  q = cd->q;
#line 941
  binary = 0;
#line 942
  skip = 13500;
#line 944
  i = (int )track;
#line 944
  while (i > 0) {
#line 945
    if (cd->toc[i].track) {
#line 946
      min = fsm2lba(cd->toc[i].fsm);
#line 947
      break;
    }
#line 944
    i --;
  }
#line 949
  lba = min + skip;
#line 950
  while (1) {
#line 951
    seek(lba);
#line 952
    type_1_command(65, 10, q);
#line 953
    ct = normalize_track(*(q + 1));
#line 954
    if (! cd->toc[ct].track) {
#line 955
      tmp___0 = bcdbin(*(q + 5));
#line 955
      tmp___1 = bcdbin(*(q + 4));
#line 955
      tmp___2 = bcdbin(*(q + 3));
#line 955
      l = ((int )*(q + 9) - (int )tmp___0) + 75 * ((((int )*(q + 8) - (int )tmp___1) - 2) + 60 * ((int )*(q + 7) - (int )tmp___2));
#line 960
      cd->toc[ct].track = *(q + 1);
#line 961
      fsm(l, cd->toc[ct].fsm);
#line 962
      cd->toc[ct].q0 = *(q + 0);
#line 963
      if ((int )ct == (int )track) {
#line 964
        return (l);
      }
    }
#line 966
    old_lba = lba;
#line 967
    if (binary) {
#line 968
      if ((int )ct < (int )track) {
#line 969
        min = lba;
      } else {
#line 971
        max = lba;
      }
#line 972
      lba = (min + max) / 2;
    } else
#line 974
    if ((int )ct < (int )track) {
#line 975
      lba += skip;
    } else {
#line 977
      binary = 1;
#line 978
      max = lba;
#line 979
      min = lba - skip;
#line 980
      lba = (min + max) / 2;
    }
#line 950
    if (! (lba != old_lba)) {
#line 950
      break;
    }
  }
#line 984
  return (lba);
}
}
#line 987 "cm206.c"
static void update_toc_entry(uch track ) 
{ 


  {
#line 989
  track = normalize_track(track);
#line 990
  if (! cd->toc[track].track) {
#line 991
    get_toc_lba(track);
  }
#line 992
  return;
}
}
#line 995 "cm206.c"
static int read_toc_header(struct cdrom_tochdr *hp ) 
{ 
  int i ;

  {
#line 997
  if (! cd->disc_status[1]) {
#line 998
    get_disc_status();
  }
#line 999
  if (hp) {
#line 1001
    hp->cdth_trk0 = cd->disc_status[1];
#line 1002
    hp->cdth_trk1 = cd->disc_status[2];
#line 1004
    i = 0;
#line 1004
    while (i < 3) {
#line 1005
      cd->toc[1].fsm[i] = cd->disc_status[3 + i];
#line 1004
      i ++;
    }
#line 1006
    update_toc_entry((uch )((int )cd->disc_status[2] + 1));
#line 1007
    return (0);
  }
#line 1009
  return (-1);
}
}
#line 1012 "cm206.c"
static void play_from_to_msf(struct cdrom_msf *msfp ) 
{ 
  uch play_command[9] ;
  int i ;
  uch tmp ;

  {
#line 1014
  play_command[0] = (uch )48;
#line 1014
  play_command[1] = msfp->cdmsf_frame0;
#line 1014
  play_command[2] = msfp->cdmsf_sec0;
#line 1014
  play_command[3] = msfp->cdmsf_min0;
#line 1014
  play_command[4] = msfp->cdmsf_frame1;
#line 1014
  play_command[5] = msfp->cdmsf_sec1;
#line 1014
  play_command[6] = msfp->cdmsf_min1;
#line 1014
  play_command[7] = (uch )2;
#line 1014
  play_command[8] = (uch )2;
#line 1020
  i = 0;
#line 1020
  while (i < 9) {
#line 1021
    type_0_command((int )play_command[i], 0);
#line 1020
    i ++;
  }
#line 1022
  i = 0;
#line 1022
  while (i < 3) {
#line 1023
    cd->toc[0].fsm[i] = play_command[i + 4];
#line 1022
    i ++;
  }
#line 1024
  cd->toc[0].track = (uch )0;
#line 1025
  tmp = wait_dsb();
#line 1025
  cd->dsb = (uch volatile   )tmp;
#line 1026
  return;
}
}
#line 1028 "cm206.c"
static void play_from_to_track(int from , int to ) 
{ 
  uch play_command[8] ;
  unsigned int tmp ;
  int i ;
  uch tmp___0 ;
  uch tmp___1 ;

  {
#line 1030
  play_command[0] = (uch )48;
#line 1030
  tmp = 1U;
#line 1030
  while (! (tmp >= 8U)) {
#line 1030
    play_command[tmp] = (unsigned char)0;
#line 1030
    tmp ++;
  }
#line 1033
  if (from == 0) {
#line 1034
    i = 0;
#line 1034
    while (i < 3) {
#line 1035
      play_command[i + 1] = cd->audio_status[i + 2];
#line 1036
      play_command[i + 4] = cd->toc[0].fsm[i];
#line 1034
      i ++;
    }
  } else {
#line 1039
    update_toc_entry((uch )from);
#line 1040
    update_toc_entry((uch )(to + 1));
#line 1041
    i = 0;
#line 1041
    while (i < 3) {
#line 1042
      play_command[i + 1] = cd->toc[from].fsm[i];
#line 1043
      tmp___0 = cd->toc[to + 1].fsm[i];
#line 1043
      play_command[i + 4] = tmp___0;
#line 1043
      cd->toc[0].fsm[i] = tmp___0;
#line 1041
      i ++;
    }
#line 1046
    cd->toc[0].track = (uch )to;
  }
#line 1048
  i = 0;
#line 1048
  while (i < 7) {
#line 1049
    type_0_command((int )play_command[i], 0);
#line 1048
    i ++;
  }
#line 1050
  i = 0;
#line 1050
  while (i < 2) {
#line 1051
    type_0_command(2, 0);
#line 1050
    i ++;
  }
#line 1052
  tmp___1 = wait_dsb();
#line 1052
  cd->dsb = (uch volatile   )tmp___1;
#line 1053
  return;
}
}
#line 1055 "cm206.c"
static int get_current_q(struct cdrom_subchnl *qp ) 
{ 
  int i ;
  uch *q ;
  int tmp ;

  {
#line 1058
  q = cd->q;
#line 1059
  tmp = type_1_command(65, 10, q);
#line 1059
  if (tmp) {
#line 1060
    return (0);
  }
#line 1062
  i = 2;
#line 1062
  while (i < 6) {
#line 1063
    *(q + i) = bcdbin(*(q + i));
#line 1062
    i ++;
  }
#line 1064
  qp->cdsc_adr = (__u8 )((int )*(q + 0) & 15);
#line 1065
  qp->cdsc_ctrl = (__u8 )((int )*(q + 0) >> 4);
#line 1066
  qp->cdsc_trk = *(q + 1);
#line 1067
  qp->cdsc_ind = *(q + 2);
#line 1068
  if ((int )qp->cdsc_format == 2) {
#line 1069
    qp->cdsc_reladdr.msf.minute = *(q + 3);
#line 1070
    qp->cdsc_reladdr.msf.second = *(q + 4);
#line 1071
    qp->cdsc_reladdr.msf.frame = *(q + 5);
#line 1072
    qp->cdsc_absaddr.msf.minute = *(q + 7);
#line 1073
    qp->cdsc_absaddr.msf.second = *(q + 8);
#line 1074
    qp->cdsc_absaddr.msf.frame = *(q + 9);
  } else {
#line 1076
    qp->cdsc_reladdr.lba = f_s_m2lba(*(q + 5), *(q + 4), *(q + 3));
#line 1077
    qp->cdsc_absaddr.lba = f_s_m2lba(*(q + 9), *(q + 8), *(q + 7));
  }
#line 1079
  get_drive_status();
#line 1080
  if ((int volatile   )cd->dsb & (int volatile   )4) {
#line 1081
    qp->cdsc_audiostatus = (__u8 )17;
  } else
#line 1082
  if (cd->audio_status[0]) {
#line 1083
    qp->cdsc_audiostatus = (__u8 )18;
  } else {
#line 1085
    qp->cdsc_audiostatus = (__u8 )21;
  }
#line 1086
  return (0);
}
}
#line 1089 "cm206.c"
static void invalidate_toc(void) 
{ 


  {
#line 1091
  memset((void *)(cd->toc), 0, (unsigned int )sizeof(cd->toc));
#line 1092
  memset((void *)(cd->disc_status), 0, (unsigned int )sizeof(cd->disc_status));
#line 1093
  return;
}
}
#line 1096 "cm206.c"
static void get_toc_entry(struct cdrom_tocentry *ep ) 
{ 
  uch track ;
  uch tmp ;

  {
#line 1098
  tmp = normalize_track(ep->cdte_track);
#line 1098
  track = tmp;
#line 1099
  update_toc_entry(track);
#line 1100
  ep->cdte_addr.msf.frame = cd->toc[track].fsm[0];
#line 1101
  ep->cdte_addr.msf.second = cd->toc[track].fsm[1];
#line 1102
  ep->cdte_addr.msf.minute = cd->toc[track].fsm[2];
#line 1103
  ep->cdte_adr = (__u8 )((int )cd->toc[track].q0 & 15);
#line 1104
  ep->cdte_ctrl = (__u8 )((int )cd->toc[track].q0 >> 4);
#line 1105
  ep->cdte_datamode = (__u8 )0;
#line 1106
  return;
}
}
#line 1113 "cm206.c"
static int cm206_audio_ioctl(struct cdrom_device_info *cdi , unsigned int cmd , void *arg ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 1116
  switch (cmd) {
  case 21253U: 
#line 1118
  tmp = read_toc_header((struct cdrom_tochdr *)arg);
#line 1118
  return (tmp);
  case 21254U: 
#line 1120
  get_toc_entry((struct cdrom_tocentry *)arg);
#line 1121
  return (0);
  case 21251U: 
#line 1123
  play_from_to_msf((struct cdrom_msf *)arg);
#line 1124
  return (0);
  case 21252U: 
#line 1126
  play_from_to_track((int )((struct cdrom_ti *)arg)->cdti_trk0, (int )((struct cdrom_ti *)arg)->cdti_trk1);
#line 1128
  return (0);
  case 21255U: 
#line 1130
  cd->audio_status[0] = (uch )0;
#line 1131
  if ((int volatile   )cd->dsb & (int volatile   )4) {
#line 1132
    tmp___0 = type_0_command(112, 1);
#line 1132
    return (tmp___0);
  } else {
#line 1134
    return (0);
  }
  case 21249U: 
#line 1136
  get_drive_status();
#line 1137
  if ((int volatile   )cd->dsb & (int volatile   )4) {
#line 1138
    type_0_command(112, 1);
#line 1139
    type_1_command(82, 5, cd->audio_status);
#line 1141
    cd->audio_status[0] = (uch )1;
  }
#line 1143
  return (0);
  case 21250U: 
#line 1145
  if (cd->audio_status[0]) {
#line 1146
    play_from_to_track(0, 0);
  }
#line 1147
  cd->audio_status[0] = (uch )0;
#line 1148
  return (0);
  case 21258U: 
  case 21256U: 
#line 1151
  return (0);
  case 21259U: 
#line 1153
  tmp___1 = get_current_q((struct cdrom_subchnl *)arg);
#line 1153
  return (tmp___1);
  default: 
#line 1155
  return (-22);
  }
}
}
#line 1159 "cm206.c"
static int cm206_media_changed(struct cdrom_device_info *cdi , int disc_nr ) 
{ 
  int r ;

  {
#line 1161
  if ((unsigned long )cd != (unsigned long )((void *)0)) {
#line 1163
    get_drive_status();
#line 1164
    r = (int )cd->media_changed;
#line 1165
    cd->media_changed = (uch )0;
#line 1166
    return (r);
  } else {
#line 1168
    return (-5);
  }
}
}
#line 1176 "cm206.c"
static int cm206_tray_move(struct cdrom_device_info *cdi , int position ) 
{ 


  {
#line 1178
  if (position) {
#line 1179
    type_0_command(5, 1);
#line 1180
    invalidate_toc();
  } else {
#line 1182
    type_0_command(0, 1);
  }
#line 1183
  return (0);
}
}
#line 1187 "cm206.c"
static int cm206_drive_status(struct cdrom_device_info *cdi , int slot_nr ) 
{ 


  {
#line 1189
  get_drive_status();
#line 1190
  if ((int volatile   )cd->dsb & (int volatile   )128) {
#line 1191
    return (2);
  }
#line 1192
  if (! ((int volatile   )cd->dsb & (int volatile   )16)) {
#line 1193
    return (1);
  }
#line 1194
  if ((int volatile   )cd->dsb & (int volatile   )32) {
#line 1195
    return (3);
  }
#line 1196
  return (4);
}
}
#line 1200 "cm206.c"
static int cm206_lock_door(struct cdrom_device_info *cdi , int lock ) 
{ 
  uch command ;
  int tmp ;

  {
#line 1202
  if (lock) {
#line 1202
    tmp = 1;
  } else {
#line 1202
    tmp = 4;
  }
#line 1202
  command = (uch )tmp;
#line 1203
  type_0_command((int )command, 1);
#line 1205
  return (lock ^ (((int volatile   )cd->dsb & (int volatile   )64) != (int volatile   )0));
}
}
#line 1211 "cm206.c"
static int cm206_get_last_session(struct cdrom_device_info *cdi , struct cdrom_multisession *mssp ) 
{ 


  {
#line 1214
  if (! cd->disc_status[1]) {
#line 1215
    get_disc_status();
  }
#line 1216
  if ((unsigned long )mssp != (unsigned long )((void *)0)) {
#line 1217
    if ((int )cd->disc_status[0] & 2) {
#line 1218
      mssp->addr.msf.frame = cd->disc_status[3];
#line 1219
      mssp->addr.msf.second = cd->disc_status[4];
#line 1220
      mssp->addr.msf.minute = cd->disc_status[5];
#line 1221
      mssp->addr_format = (__u8 )2;
#line 1222
      mssp->xa_flag = (__u8 )1;
    } else {
#line 1224
      mssp->xa_flag = (__u8 )0;
    }
#line 1226
    return (1);
  }
#line 1228
  return (0);
}
}
#line 1231 "cm206.c"
static int cm206_get_upc(struct cdrom_device_info *cdi , struct cdrom_mcn *mcn ) 
{ 
  uch upc[10] ;
  char *ret ;
  int i ;
  int tmp ;
  int w ;
  int r ;

  {
#line 1234
  ret = (char *)(mcn->medium_catalog_number);
#line 1237
  tmp = type_1_command(96, 10, upc);
#line 1237
  if (tmp) {
#line 1238
    return (-5);
  }
#line 1239
  i = 0;
#line 1239
  while (i < 13) {
#line 1240
    w = i / 2 + 1;
#line 1240
    r = i % 2;
#line 1241
    if (r) {
#line 1242
      *(ret + i) = (char )(48 | ((int )upc[w] & 15));
    } else {
#line 1244
      *(ret + i) = (char )(48 | (((int )upc[w] >> 4) & 15));
    }
#line 1239
    i ++;
  }
#line 1246
  *(ret + 13) = (char )'\000';
#line 1247
  return (0);
}
}
#line 1250 "cm206.c"
static int cm206_reset(struct cdrom_device_info *cdi ) 
{ 


  {
#line 1252
  stop_read();
#line 1253
  reset_cm260();
#line 1254
  outw((unsigned short)11521, (unsigned int )(cm206_base + 8));
#line 1255
  while (1) {
#line 1255
    break;
  }
#line 1256
  outw((unsigned short)10497, (unsigned int )(cm206_base + 8));
#line 1257
  cd->sector_last = -1;
#line 1258
  cd->adapter_last = -1;
#line 1259
  invalidate_toc();
#line 1260
  return (0);
}
}
#line 1263 "cm206.c"
static int cm206_select_speed(struct cdrom_device_info *cdi , int speed ) 
{ 
  int r ;

  {
#line 1266
  switch (speed) {
  case 0: 
#line 1268
  r = type_0_command(35, 1);
#line 1269
  break;
  case 1: 
#line 1271
  r = type_0_command(33, 1);
#line 1272
  break;
  case 2: 
#line 1274
  r = type_0_command(34, 1);
#line 1275
  break;
  default: 
#line 1277
  return (-1);
  }
#line 1279
  if (r < 0) {
#line 1280
    return (r);
  } else {
#line 1282
    return (1);
  }
}
}
#line 1285 "cm206.c"
static struct cdrom_device_ops cm206_dops  = 
#line 1285
     {& cm206_open, & cm206_release, & cm206_drive_status, & cm206_media_changed, & cm206_tray_move,
    & cm206_lock_door, & cm206_select_speed, (int (*)(struct cdrom_device_info * ,
                                                      int  ))0, & cm206_get_last_session,
    & cm206_get_upc, & cm206_reset, & cm206_audio_ioctl, (int (*)(struct cdrom_device_info * ,
                                                                  unsigned int  ,
                                                                  unsigned long  ))0,
    (int const   )2543, 1, (int (*)(struct cdrom_device_info * , struct packet_command * ))0};
#line 1305 "cm206.c"
static struct cdrom_device_info cm206_info  = 
#line 1305
     {& cm206_dops, (struct cdrom_device_info *)0, (struct gendisk *)0, (void *)0, 0,
    2, 1, 0, 0U, 0, {(char )'c', (char )'m', (char )'2', (char )'0', (char )'6', (char )'\000'},
    (unsigned char)0, (unsigned char)0, 0, (unsigned char)0, (unsigned char)0, (unsigned short)0,
    0, (int (*)(struct cdrom_device_info * ))0, 0};
#line 1312 "cm206.c"
static int cm206_block_open(struct inode *inode , struct file *file ) 
{ 
  int tmp ;

  {
#line 1314
  tmp = cdrom_open(& cm206_info, inode, file);
#line 1314
  return (tmp);
}
}
#line 1317 "cm206.c"
static int cm206_block_release(struct inode *inode , struct file *file ) 
{ 
  int tmp ;

  {
#line 1319
  tmp = cdrom_release(& cm206_info, file);
#line 1319
  return (tmp);
}
}
#line 1322 "cm206.c"
static int cm206_block_ioctl(struct inode *inode , struct file *file , unsigned int cmd ,
                             unsigned long arg ) 
{ 
  int tmp ;

  {
#line 1325
  switch (cmd) {
  case (unsigned int )(32 << 8): 
#line 1328
  if (arg >= 21UL) {
#line 1329
    return (-22);
  }
#line 1330
  return (cd->stats[arg]);
  case (unsigned int )(32 << 8) | 1U: 
#line 1332
  if (arg >= 21UL) {
#line 1333
    return (-22);
  }
#line 1334
  return (cd->last_stat[arg]);
  default: 
#line 1337
  break;
  }
#line 1340
  tmp = cdrom_ioctl(file, & cm206_info, inode, cmd, arg);
#line 1340
  return (tmp);
}
}
#line 1343 "cm206.c"
static int cm206_block_media_changed(struct gendisk *disk ) 
{ 
  int tmp ;

  {
#line 1345
  tmp = cdrom_media_changed(& cm206_info);
#line 1345
  return (tmp);
}
}
#line 1348 "cm206.c"
static struct block_device_operations cm206_bdops  = 
#line 1348
     {& cm206_block_open, & cm206_block_release, & cm206_block_ioctl, (long (*)(struct file * ,
                                                                              unsigned int  ,
                                                                              unsigned long  ))0,
    (long (*)(struct file * , unsigned int  , unsigned long  ))0, (int (*)(struct block_device * ,
                                                                           sector_t  ,
                                                                           unsigned long * ))0,
    & cm206_block_media_changed, (int (*)(struct gendisk * ))0, (int (*)(struct block_device * ,
                                                                         struct hd_geometry * ))0,
    (struct module *)0};
#line 1357 "cm206.c"
static struct gendisk *cm206_gendisk  ;
#line 1369 "cm206.c"
static int probe_base_port(int base ) 
{ 
  int b ;
  int e ;
  int volatile   fool ;
  int volatile   i ;
  struct resource *tmp ;
  unsigned short tmp___0 ;
  unsigned short tmp___1 ;
  unsigned short tmp___2 ;

  {
#line 1371
  b = 768;
#line 1371
  e = 880;
#line 1374
  if (base) {
#line 1375
    e = base;
#line 1375
    b = e;
  }
#line 1376
  base = b;
#line 1376
  while (base <= e) {
#line 1377
    tmp = request_region((unsigned long )base, 16UL, "cm206");
#line 1377
    if (! tmp) {
#line 1378
      goto __Cont;
    }
#line 1379
    i = (int volatile   )0;
#line 1379
    while (i < (int volatile   )3) {
#line 1380
      tmp___0 = inw((unsigned int )(base + 2));
#line 1380
      fool = (int volatile   )tmp___0;
#line 1379
      i += (int volatile   )1;
    }
#line 1381
    tmp___1 = inw((unsigned int )(base + 6));
#line 1381
    if (((int )tmp___1 & 65519) != 1) {
#line 1383
      release_region((unsigned long )base, 16UL);
#line 1384
      goto __Cont;
    } else {
#line 1381
      tmp___2 = inw((unsigned int )base);
#line 1381
      if (((int )tmp___2 & 44288) != 0) {
#line 1383
        release_region((unsigned long )base, 16UL);
#line 1384
        goto __Cont;
      }
    }
#line 1386
    return (base);
    __Cont: /* CIL Label */ 
#line 1376
    base += 16;
  }
#line 1388
  return (0);
}
}
#line 1393 "cm206.c"
static int probe_irq(int nr ) 
{ 
  int irqs ;
  int irq ;
  unsigned long tmp ;

  {
#line 1396
  outw((unsigned short)10497, (unsigned int )(cm206_base + 8));
#line 1397
  sti();
#line 1398
  tmp = probe_irq_on();
#line 1398
  irqs = (int )tmp;
#line 1399
  reset_cm260();
#line 1400
  udelay(100);
#line 1401
  irq = probe_irq_off((unsigned long )irqs);
#line 1402
  outw((unsigned short)10497, (unsigned int )(cm206_base + 8));
#line 1403
  if (nr) {
#line 1403
    if (irq != nr) {
#line 1403
      if (irq > 0) {
#line 1404
        return (0);
      } else {
#line 1406
        return (irq);
      }
    } else {
#line 1406
      return (irq);
    }
  } else {
#line 1406
    return (irq);
  }
}
}
#line 1410 "cm206.c"
int cm206_init(void) 
{ 
  uch e ;
  long size ;
  struct gendisk *disk ;
  int tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  uch tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  unsigned short tmp___7 ;

  {
#line 1412
  e = (uch )0;
#line 1413
  size = (long )sizeof(struct cm206_struct );
#line 1416
  printk("<6>cm206 cdrom driver $Revision: 1.5 $");
#line 1417
  if (auto_probe) {
#line 1417
    tmp = 0;
  } else {
#line 1417
    tmp = cm206_base;
  }
#line 1417
  cm206_base = probe_base_port(tmp);
#line 1418
  if (! cm206_base) {
#line 1419
    printk(" can\'t find adapter!\n");
#line 1420
    return (-5);
  }
#line 1422
  printk(" adapter at 0x%x", cm206_base);
#line 1423
  tmp___0 = kmalloc((size_t )size, 208U);
#line 1423
  cd = (struct cm206_struct *)tmp___0;
#line 1424
  if (! cd) {
#line 1425
    goto out_base;
  }
#line 1430
  if (auto_probe) {
#line 1430
    tmp___1 = 0;
  } else {
#line 1430
    tmp___1 = cm206_irq;
  }
#line 1430
  cm206_irq = probe_irq(tmp___1);
#line 1431
  if (cm206_irq <= 0) {
#line 1432
    printk("can\'t find IRQ!\n");
#line 1433
    goto out_probe;
  } else {
#line 1435
    printk(" IRQ %d found\n", cm206_irq);
  }
#line 1447
  tmp___2 = send_receive_polled(83);
#line 1447
  if ((int )tmp___2 != 83) {
#line 1449
    printk("<6> drive not there\n");
#line 1450
    goto out_probe;
  }
#line 1452
  e = send_receive_polled(248);
#line 1453
  printk("<6>Firmware revision %d", (int )e & 7);
#line 1454
  if ((int )e & 96) {
#line 1455
    printk(" double");
  } else {
#line 1457
    printk(" single");
  }
#line 1458
  printk(" speed drive");
#line 1459
  if ((int )e & 128) {
#line 1460
    printk(", motorized tray");
  }
#line 1461
  tmp___3 = request_irq((unsigned int )cm206_irq, (irqreturn_t (*)(int  , void * ,
                                                                   struct pt_regs * ))(& cm206_interrupt),
                        0UL, "cm206", (void *)0);
#line 1461
  if (tmp___3) {
#line 1462
    printk("\nUnable to reserve IRQ---aborted\n");
#line 1463
    goto out_probe;
  }
#line 1465
  printk(".\n");
#line 1467
  tmp___4 = register_blkdev(32U, "cm206");
#line 1467
  if (tmp___4) {
#line 1468
    goto out_blkdev;
  }
#line 1470
  disk = alloc_disk(1);
#line 1471
  if (! disk) {
#line 1472
    goto out_disk;
  }
#line 1473
  disk->major = 32;
#line 1474
  disk->first_minor = 0;
#line 1475
  sprintf(disk->disk_name, "cm206cd");
#line 1476
  disk->fops = & cm206_bdops;
#line 1477
  disk->flags = 8;
#line 1478
  cm206_gendisk = disk;
#line 1479
  tmp___5 = register_cdrom(& cm206_info);
#line 1479
  if (tmp___5 != 0) {
#line 1480
    printk("<6>Cannot register for cdrom %d!\n", 32);
#line 1481
    goto out_cdrom;
  }
#line 1483
  cm206_queue = blk_init_queue(& do_cm206_request, & cm206_lock);
#line 1484
  if (! cm206_queue) {
#line 1485
    goto out_queue;
  }
#line 1487
  blk_queue_hardsect_size(cm206_queue, (unsigned short)2048);
#line 1488
  disk->queue = cm206_queue;
#line 1489
  add_disk(disk);
#line 1491
  memset((void *)cd, 0, (unsigned int )sizeof(*cd));
#line 1492
  cd->sector_last = -1;
#line 1493
  cd->adapter_last = -1;
#line 1494
  init_timer(& cd->timer);
#line 1495
  cd->timer.function = & cm206_timeout;
#line 1496
  tmp___7 = inw((unsigned int )cm206_base);
#line 1496
  if ((int )tmp___7 & 16384) {
#line 1496
    cd->max_sectors = (signed char)24;
  } else {
#line 1496
    cd->max_sectors = (signed char)97;
  }
#line 1497
  printk("<6>%d kB adapter memory available,  %ld bytes kernel memory used.\n", (int )cd->max_sectors * 2,
         size);
#line 1500
  return (0);
  out_queue: 
#line 1503
  unregister_cdrom(& cm206_info);
  out_cdrom: 
#line 1505
  put_disk(disk);
  out_disk: 
#line 1507
  unregister_blkdev(32U, "cm206");
  out_blkdev: 
#line 1509
  free_irq((unsigned int )cm206_irq, (void *)0);
  out_probe: 
#line 1511
  kfree((void const   *)cd);
  out_base: 
#line 1513
  release_region((unsigned long )cm206_base, 16UL);
#line 1514
  return (-5);
}
}
#line 1520 "cm206.c"
static void parse_options(void) 
{ 
  int i ;

  {
#line 1523
  i = 0;
#line 1523
  while (i < 2) {
#line 1524
    if (768 <= cm206[i]) {
#line 1524
      if (i <= 880) {
#line 1524
        if (cm206[i] % 16 == 0) {
#line 1526
          cm206_base = cm206[i];
#line 1527
          auto_probe = 0;
        } else {
#line 1524
          goto _L___0;
        }
      } else {
#line 1524
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 1528
    if (3 <= cm206[i]) {
#line 1528
      if (cm206[i] <= 15) {
#line 1529
        cm206_irq = cm206[i];
#line 1530
        auto_probe = 0;
      }
    }
#line 1523
    i ++;
  }
#line 1533
  return;
}
}
#line 1535 "cm206.c"
static int __cm206_init(void) 
{ 
  int tmp ;

  {
#line 1537
  parse_options();
#line 1541
  tmp = cm206_init();
#line 1541
  return (tmp);
}
}
#line 1544 "cm206.c"
static void cm206_exit(void) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 1546
  del_gendisk(cm206_gendisk);
#line 1547
  put_disk(cm206_gendisk);
#line 1548
  tmp = unregister_cdrom(& cm206_info);
#line 1548
  if (tmp) {
#line 1549
    printk("Can\'t unregister cdrom cm206\n");
#line 1550
    return;
  }
#line 1552
  tmp___0 = unregister_blkdev(32U, "cm206");
#line 1552
  if (tmp___0) {
#line 1553
    printk("Can\'t unregister major cm206\n");
#line 1554
    return;
  }
#line 1556
  blk_cleanup_queue(cm206_queue);
#line 1557
  free_irq((unsigned int )cm206_irq, (void *)0);
#line 1558
  kfree((void const   *)cd);
#line 1559
  release_region((unsigned long )cm206_base, 16UL);
#line 1560
  printk("<6>cm206 removed\n");
#line 1561
  return;
}
}
#line 1563 "cm206.c"
int (*_ddv_tmp_init)(void)  =    & __cm206_init;
#line 1564 "cm206.c"
void (*_ddv_tmp_exit)(void)  =    & cm206_exit;
#line 1594 "cm206.c"
int _ddv_module_param_major  =    32;
#line 4 "__main.c"
int main(void) 
{ 


  {
#line 6
  _ddv_module_init = & __cm206_init;
#line 7
  _ddv_module_exit = & cm206_exit;
#line 8
  call_ddv();
#line 10
  return (0);
}
}
#line 1 "manage.o"
#pragma merger("0","/tmp/cil-xQ_B9RTz.i","")
#line 4 "/usr/local/ddv/models/con2/src/linux/kernel/irq/manage.c"
int request_irq(unsigned int irq , irqreturn_t (*handler)(int  , void * , struct pt_regs * ) ,
                unsigned long irqflags , char const   *devname , void *dev_id ) 
{ 
  int tmp ;

  {
#line 7
  tmp = nondet_int();
#line 7
  if (tmp) {
#line 8
    registered_irq[irq].handler = handler;
#line 9
    registered_irq[irq].dev_id = dev_id;
#line 11
    return (0);
  } else {
#line 13
    return (-1);
  }
}
}
#line 17 "/usr/local/ddv/models/con2/src/linux/kernel/irq/manage.c"
void free_irq(unsigned int irq , void *dev_id ) 
{ 


  {
#line 19
  registered_irq[irq].handler = (irqreturn_t (*)(int  , void * , struct pt_regs * ))((void *)0);
#line 20
  registered_irq[irq].dev_id = (void *)0;
#line 21
  return;
}
}
#line 1 "misc.o"
#pragma merger("0","/tmp/cil-O2BEJHiH.i","")
#line 40 "/usr/local/ddv/models/con2/include/linux/miscdevice.h"
int misc_register(struct miscdevice *misc ) ;
#line 11 "/usr/local/ddv/models/con2/include/linux/proc_fs.h"
struct proc_dir_entry *proc_root_driver  ;
#line 18 "/usr/local/ddv/models/con2/src/linux/drivers/char/misc.c"
int misc_register(struct miscdevice *misc ) 
{ 
  int i ;
  dev_t dev ;
  int tmp ;

  {
#line 23
  if (fixed_cdev_used < 10) {
#line 24
    i = fixed_cdev_used;
#line 25
    fixed_cdev_used ++;
#line 27
    fixed_cdev[i].owner = (struct module *)0;
#line 28
    fixed_cdev[i].ops = misc->fops;
#line 30
    dev = (dev_t )((10 << 20) | misc->minor);
#line 32
    tmp = cdev_add(& fixed_cdev[i], dev, 0U);
#line 32
    return (tmp);
  } else {
#line 34
    return (-1);
  }
}
}
#line 1 "mutex.o"
#pragma merger("0","/tmp/cil-oa73EN3R.i","")
#line 32 "/usr/local/ddv/models/con2/include/ddverify/ddverify.h"
__inline static int assert_context_process(void) 
{ 


  {
#line 34
  return (0);
}
}
#line 32 "/usr/local/ddv/models/con2/include/linux/mutex.h"
__inline void mutex_init(struct mutex *lock ) ;
#line 34
__inline void mutex_lock(struct mutex *lock ) ;
#line 36
__inline void mutex_unlock(struct mutex *lock ) ;
#line 4 "/usr/local/ddv/models/con2/src/linux/kernel/mutex.c"
__inline void mutex_init(struct mutex *lock ) 
{ 


  {
#line 7
  __CPROVER_atomic_begin();
#line 11
  lock->locked = 0;
#line 12
  lock->init = 1;
#line 13
  __CPROVER_atomic_end();
#line 14
  return;
}
}
#line 16 "/usr/local/ddv/models/con2/src/linux/kernel/mutex.c"
__inline void mutex_lock(struct mutex *lock ) 
{ 


  {
#line 27
  while (1) {
#line 29
    __CPROVER_atomic_begin();
#line 30
    if (lock->locked == 0) {
#line 32
      lock->locked = 1;
#line 33
      __CPROVER_atomic_end();
#line 34
      return;
    }
#line 36
    __CPROVER_atomic_end();
  }
}
}
#line 41 "/usr/local/ddv/models/con2/src/linux/kernel/mutex.c"
__inline void mutex_unlock(struct mutex *lock ) 
{ 


  {
#line 44
  __CPROVER_atomic_begin();
#line 45
  assert_context_process();
#line 49
  lock->locked = 0;
#line 50
  __CPROVER_atomic_end();
#line 51
  return;
}
}
#line 1 "page_alloc.o"
#pragma merger("0","/tmp/cil-_JIu_APR.i","")
#line 55 "/usr/local/ddv/models/con2/include/linux/gfp.h"
__inline unsigned long __get_free_pages(gfp_t gfp_mask , unsigned int order ) ;
#line 57
__inline unsigned long __get_free_page(gfp_t gfp_mask ) ;
#line 59
__inline unsigned long get_zeroed_page(gfp_t gfp_mask ) ;
#line 70
__inline struct page *alloc_pages(gfp_t gfp_mask , unsigned int order ) ;
#line 72
__inline struct page *alloc_page(gfp_t gfp_mask ) ;
#line 5 "/usr/local/ddv/models/con2/src/linux/mm/page_alloc.c"
__inline unsigned long __get_free_pages(gfp_t gfp_mask , unsigned int order ) 
{ 


  {
#line 8
  if (gfp_mask & 16U) {
#line 9
    assert_context_process();
  }
#line 11
  return (0UL);
}
}
#line 13 "/usr/local/ddv/models/con2/src/linux/mm/page_alloc.c"
__inline unsigned long __get_free_page(gfp_t gfp_mask ) 
{ 


  {
#line 16
  if (gfp_mask & 16U) {
#line 17
    assert_context_process();
  }
#line 19
  return (0UL);
}
}
#line 38 "/usr/local/ddv/models/con2/src/linux/mm/page_alloc.c"
__inline struct page *alloc_pages(gfp_t gfp_mask , unsigned int order ) 
{ 


  {
#line 41
  if (gfp_mask & 16U) {
#line 42
    assert_context_process();
  }
#line 44
  return ((struct page *)0);
}
}
#line 46 "/usr/local/ddv/models/con2/src/linux/mm/page_alloc.c"
__inline struct page *alloc_page(gfp_t gfp_mask ) 
{ 


  {
#line 49
  if (gfp_mask & 16U) {
#line 50
    assert_context_process();
  }
#line 52
  return ((struct page *)0);
}
}
#line 1 "pci.o"
#pragma merger("0","/tmp/cil-HA8GB31A.i","")
#line 96 "/usr/local/ddv/models/con2/include/linux/ioport.h"
extern struct resource *request_mem_region(unsigned long start , unsigned long len ,
                                           char const   *name ) ;
#line 98
extern void release_mem_region(unsigned long start , unsigned long len ) ;
#line 87 "/usr/local/ddv/models/con2/include/linux/pci.h"
__inline struct pci_dev *pci_get_class(unsigned int class , struct pci_dev *from ) ;
#line 141
__inline int pci_register_driver(struct pci_driver *driver ) ;
#line 143
__inline void pci_unregister_driver(struct pci_driver *driver ) ;
#line 145
__inline int pci_enable_device(struct pci_dev *dev ) ;
#line 152
__inline int pci_request_regions(struct pci_dev *pdev , char const   *res_name ) ;
#line 154
__inline void pci_release_regions(struct pci_dev *pdev ) ;
#line 156
__inline int pci_request_region(struct pci_dev *pdev , int bar , char const   *res_name ) ;
#line 158
__inline void pci_release_region(struct pci_dev *pdev , int bar ) ;
#line 8 "/usr/local/ddv/models/con2/src/linux/pci.c"
__inline int pci_enable_device(struct pci_dev *dev ) 
{ 
  int i ;
  unsigned int tmp ;
  unsigned short tmp___0 ;

  {
#line 12
  i = 0;
#line 12
  while (i < 12) {
#line 13
    dev->resource[i].flags = 256UL;
#line 14
    tmp = nondet_uint();
#line 14
    dev->resource[i].start = (unsigned long )tmp;
#line 15
    tmp___0 = nondet_ushort();
#line 15
    dev->resource[i].end = dev->resource[i].start + (unsigned long )tmp___0;
#line 12
    i ++;
  }
#line 17
  return (0);
}
}
#line 19 "/usr/local/ddv/models/con2/src/linux/pci.c"
__inline struct pci_dev *pci_get_class(unsigned int class , struct pci_dev *from ) 
{ 
  void *tmp ;
  int tmp___0 ;

  {
#line 21
  if ((unsigned long )from == (unsigned long )((void *)0)) {
#line 22
    tmp = malloc((size_t )sizeof(struct pci_dev ));
#line 22
    from = (struct pci_dev *)tmp;
  }
#line 25
  tmp___0 = nondet_int();
#line 25
  if (tmp___0) {
#line 26
    from->vendor = nondet_ushort();
#line 27
    from->device = nondet_ushort();
#line 28
    from->irq = nondet_uint();
#line 29
    __CPROVER_assume(from->irq < 16U);
#line 31
    return (from);
  } else {
#line 33
    return ((struct pci_dev *)((void *)0));
  }
}
}
#line 37 "/usr/local/ddv/models/con2/src/linux/pci.c"
__inline int pci_register_driver(struct pci_driver *driver ) 
{ 
  int tmp ;

  {
#line 39
  tmp = nondet_int();
#line 39
  if (tmp) {
#line 40
    registered_pci_driver.pci_driver = driver;
#line 41
    registered_pci_driver.no_pci_device_id = (unsigned int )(sizeof(driver->id_table) / sizeof(struct pci_device_id ));
#line 42
    registered_pci_driver.dev_initialized = 0;
#line 44
    return (0);
  } else {
#line 46
    return (-1);
  }
}
}
#line 50 "/usr/local/ddv/models/con2/src/linux/pci.c"
__inline void pci_unregister_driver(struct pci_driver *driver ) 
{ 


  {
#line 52
  registered_pci_driver.pci_driver = (struct pci_driver *)((void *)0);
#line 53
  registered_pci_driver.no_pci_device_id = 0U;
#line 54
  return;
}
}
#line 56 "/usr/local/ddv/models/con2/src/linux/pci.c"
__inline void pci_release_region(struct pci_dev *pdev , int bar ) 
{ 
  unsigned long tmp ;
  unsigned long tmp___0 ;
  unsigned long tmp___1 ;

  {
#line 58
  if (pdev->resource[bar].start == 0UL) {
#line 58
    if (pdev->resource[bar].end == pdev->resource[bar].start) {
#line 58
      tmp = 0UL;
    } else {
#line 58
      tmp = (pdev->resource[bar].end - pdev->resource[bar].start) + 1UL;
    }
  } else {
#line 58
    tmp = (pdev->resource[bar].end - pdev->resource[bar].start) + 1UL;
  }
#line 58
  if (tmp == 0UL) {
#line 59
    return;
  }
#line 60
  if (pdev->resource[bar].flags & 256UL) {
#line 61
    if (pdev->resource[bar].start == 0UL) {
#line 61
      if (pdev->resource[bar].end == pdev->resource[bar].start) {
#line 61
        tmp___0 = 0UL;
      } else {
#line 61
        tmp___0 = (pdev->resource[bar].end - pdev->resource[bar].start) + 1UL;
      }
    } else {
#line 61
      tmp___0 = (pdev->resource[bar].end - pdev->resource[bar].start) + 1UL;
    }
#line 61
    release_region(pdev->resource[bar].start, tmp___0);
  } else
#line 63
  if (pdev->resource[bar].flags & 512UL) {
#line 64
    if (pdev->resource[bar].start == 0UL) {
#line 64
      if (pdev->resource[bar].end == pdev->resource[bar].start) {
#line 64
        tmp___1 = 0UL;
      } else {
#line 64
        tmp___1 = (pdev->resource[bar].end - pdev->resource[bar].start) + 1UL;
      }
    } else {
#line 64
      tmp___1 = (pdev->resource[bar].end - pdev->resource[bar].start) + 1UL;
    }
#line 64
    release_mem_region(pdev->resource[bar].start, tmp___1);
  }
#line 66
  return;
}
}
#line 68 "/usr/local/ddv/models/con2/src/linux/pci.c"
__inline int pci_request_region(struct pci_dev *pdev , int bar , char const   *res_name ) 
{ 
  unsigned long tmp ;
  unsigned long tmp___0 ;
  struct resource *tmp___1 ;
  unsigned long tmp___2 ;
  struct resource *tmp___3 ;

  {
#line 70
  if (pdev->resource[bar].start == 0UL) {
#line 70
    if (pdev->resource[bar].end == pdev->resource[bar].start) {
#line 70
      tmp = 0UL;
    } else {
#line 70
      tmp = (pdev->resource[bar].end - pdev->resource[bar].start) + 1UL;
    }
  } else {
#line 70
    tmp = (pdev->resource[bar].end - pdev->resource[bar].start) + 1UL;
  }
#line 70
  if (tmp == 0UL) {
#line 71
    return (0);
  }
#line 73
  if (pdev->resource[bar].flags & 256UL) {
#line 74
    if (pdev->resource[bar].start == 0UL) {
#line 74
      if (pdev->resource[bar].end == pdev->resource[bar].start) {
#line 74
        tmp___0 = 0UL;
      } else {
#line 74
        tmp___0 = (pdev->resource[bar].end - pdev->resource[bar].start) + 1UL;
      }
    } else {
#line 74
      tmp___0 = (pdev->resource[bar].end - pdev->resource[bar].start) + 1UL;
    }
#line 74
    tmp___1 = request_region(pdev->resource[bar].start, tmp___0, res_name);
#line 74
    if (! tmp___1) {
#line 76
      return (-16);
    }
  } else
#line 78
  if (pdev->resource[bar].flags & 512UL) {
#line 79
    if (pdev->resource[bar].start == 0UL) {
#line 79
      if (pdev->resource[bar].end == pdev->resource[bar].start) {
#line 79
        tmp___2 = 0UL;
      } else {
#line 79
        tmp___2 = (pdev->resource[bar].end - pdev->resource[bar].start) + 1UL;
      }
    } else {
#line 79
      tmp___2 = (pdev->resource[bar].end - pdev->resource[bar].start) + 1UL;
    }
#line 79
    tmp___3 = request_mem_region(pdev->resource[bar].start, tmp___2, res_name);
#line 79
    if (! tmp___3) {
#line 81
      return (-16);
    }
  }
#line 84
  return (0);
}
}
#line 87 "/usr/local/ddv/models/con2/src/linux/pci.c"
__inline void pci_release_regions(struct pci_dev *pdev ) 
{ 
  int i ;

  {
#line 91
  i = 0;
#line 91
  while (i < 6) {
#line 92
    pci_release_region(pdev, i);
#line 91
    i ++;
  }
#line 93
  return;
}
}
#line 95 "/usr/local/ddv/models/con2/src/linux/pci.c"
__inline int pci_request_regions(struct pci_dev *pdev , char const   *res_name ) 
{ 
  int i ;
  int tmp ;

  {
#line 99
  i = 0;
#line 99
  while (i < 6) {
#line 100
    tmp = pci_request_region(pdev, i, res_name);
#line 100
    if (tmp) {
#line 101
      goto err_out;
    }
#line 99
    i ++;
  }
#line 102
  return (0);
  err_out: 
#line 105
  while (1) {
#line 105
    i --;
#line 105
    if (! (i >= 0)) {
#line 105
      break;
    }
#line 106
    pci_release_region(pdev, i);
  }
#line 108
  return (-16);
}
}
#line 1 "resource.o"
#pragma merger("0","/tmp/cil-wvkmU4u3.i","")
#line 21 "/usr/local/ddv/models/con2/include/ddverify/satabs.h"
extern unsigned char nondet_uchar() ;
#line 22
extern unsigned int nondet_unsigned() ;
#line 10 "/usr/local/ddv/models/con2/include/ddverify/ioport.h"
int ddv_ioport_request_start  ;
#line 11 "/usr/local/ddv/models/con2/include/ddverify/ioport.h"
int ddv_ioport_request_len  ;
#line 6 "/usr/local/ddv/models/con2/src/linux/kernel/resource.c"
struct resource *request_region(unsigned long start , unsigned long len , char const   *name ) 
{ 
  struct resource *resource ;
  void *tmp ;

  {
#line 9
  tmp = malloc((size_t )sizeof(struct resource ));
#line 9
  resource = (struct resource *)tmp;
#line 14
  ddv_ioport_request_start = (int )start;
#line 15
  ddv_ioport_request_len = (int )len;
#line 17
  return (resource);
}
}
#line 20 "/usr/local/ddv/models/con2/src/linux/kernel/resource.c"
void release_region(unsigned long start , unsigned long len ) 
{ 
  unsigned int i ;

  {
#line 22
  i = 0U;
#line 28
  ddv_ioport_request_start = 0;
#line 29
  ddv_ioport_request_len = 0;
#line 30
  return;
}
}
#line 32 "/usr/local/ddv/models/con2/src/linux/kernel/resource.c"
unsigned char inb(unsigned int port ) 
{ 
  int tmp ;
  unsigned char tmp___0 ;

  {
#line 35
  if (port >= (unsigned int )ddv_ioport_request_start) {
#line 35
    if (port < (unsigned int )(ddv_ioport_request_start + ddv_ioport_request_len)) {
#line 35
      tmp = 1;
    } else {
#line 35
      tmp = 0;
    }
  } else {
#line 35
    tmp = 0;
  }
#line 35
  __CPROVER_assert(tmp, "I/O port is requested");
#line 37
  tmp___0 = nondet_uchar();
#line 37
  return (tmp___0);
}
}
#line 40 "/usr/local/ddv/models/con2/src/linux/kernel/resource.c"
__inline void outb(unsigned char byte , unsigned int port ) 
{ 
  int tmp ;

  {
#line 43
  if (port >= (unsigned int )ddv_ioport_request_start) {
#line 43
    if (port < (unsigned int )(ddv_ioport_request_start + ddv_ioport_request_len)) {
#line 43
      tmp = 1;
    } else {
#line 43
      tmp = 0;
    }
  } else {
#line 43
    tmp = 0;
  }
#line 43
  __CPROVER_assert(tmp, "I/O port is requested");
#line 44
  return;
}
}
#line 46 "/usr/local/ddv/models/con2/src/linux/kernel/resource.c"
unsigned short inw(unsigned int port ) 
{ 
  int tmp ;
  unsigned short tmp___0 ;

  {
#line 49
  if (port >= (unsigned int )ddv_ioport_request_start) {
#line 49
    if (port < (unsigned int )(ddv_ioport_request_start + ddv_ioport_request_len)) {
#line 49
      tmp = 1;
    } else {
#line 49
      tmp = 0;
    }
  } else {
#line 49
    tmp = 0;
  }
#line 49
  __CPROVER_assert(tmp, "I/O port is requested");
#line 51
  tmp___0 = nondet_ushort();
#line 51
  return (tmp___0);
}
}
#line 54 "/usr/local/ddv/models/con2/src/linux/kernel/resource.c"
void outw(unsigned short word , unsigned int port ) 
{ 
  int tmp ;

  {
#line 57
  if (port >= (unsigned int )ddv_ioport_request_start) {
#line 57
    if (port < (unsigned int )(ddv_ioport_request_start + ddv_ioport_request_len)) {
#line 57
      tmp = 1;
    } else {
#line 57
      tmp = 0;
    }
  } else {
#line 57
    tmp = 0;
  }
#line 57
  __CPROVER_assert(tmp, "I/O port is requested");
#line 58
  return;
}
}
#line 60 "/usr/local/ddv/models/con2/src/linux/kernel/resource.c"
__inline unsigned int inl(unsigned int port ) 
{ 
  int tmp ;
  unsigned int tmp___0 ;

  {
#line 63
  if (port >= (unsigned int )ddv_ioport_request_start) {
#line 63
    if (port < (unsigned int )(ddv_ioport_request_start + ddv_ioport_request_len)) {
#line 63
      tmp = 1;
    } else {
#line 63
      tmp = 0;
    }
  } else {
#line 63
    tmp = 0;
  }
#line 63
  __CPROVER_assert(tmp, "I/O port is requested");
#line 65
  tmp___0 = nondet_unsigned();
#line 65
  return (tmp___0);
}
}
#line 68 "/usr/local/ddv/models/con2/src/linux/kernel/resource.c"
__inline void outl(unsigned int doubleword , unsigned int port ) 
{ 
  int tmp ;

  {
#line 71
  if (port >= (unsigned int )ddv_ioport_request_start) {
#line 71
    if (port < (unsigned int )(ddv_ioport_request_start + ddv_ioport_request_len)) {
#line 71
      tmp = 1;
    } else {
#line 71
      tmp = 0;
    }
  } else {
#line 71
    tmp = 0;
  }
#line 71
  __CPROVER_assert(tmp, "I/O port is requested");
#line 72
  return;
}
}
#line 74 "/usr/local/ddv/models/con2/src/linux/kernel/resource.c"
__inline unsigned char inb_p(unsigned int port ) 
{ 
  int tmp ;
  unsigned char tmp___0 ;

  {
#line 77
  if (port >= (unsigned int )ddv_ioport_request_start) {
#line 77
    if (port < (unsigned int )(ddv_ioport_request_start + ddv_ioport_request_len)) {
#line 77
      tmp = 1;
    } else {
#line 77
      tmp = 0;
    }
  } else {
#line 77
    tmp = 0;
  }
#line 77
  __CPROVER_assert(tmp, "I/O port is requested");
#line 79
  tmp___0 = nondet_uchar();
#line 79
  return (tmp___0);
}
}
#line 88 "/usr/local/ddv/models/con2/src/linux/kernel/resource.c"
__inline unsigned short inw_p(unsigned int port ) 
{ 
  int tmp ;
  unsigned short tmp___0 ;

  {
#line 91
  if (port >= (unsigned int )ddv_ioport_request_start) {
#line 91
    if (port < (unsigned int )(ddv_ioport_request_start + ddv_ioport_request_len)) {
#line 91
      tmp = 1;
    } else {
#line 91
      tmp = 0;
    }
  } else {
#line 91
    tmp = 0;
  }
#line 91
  __CPROVER_assert(tmp, "I/O port is requested");
#line 93
  tmp___0 = nondet_ushort();
#line 93
  return (tmp___0);
}
}
#line 96 "/usr/local/ddv/models/con2/src/linux/kernel/resource.c"
__inline void outw_p(unsigned short word , unsigned int port ) 
{ 
  int tmp ;

  {
#line 99
  if (port >= (unsigned int )ddv_ioport_request_start) {
#line 99
    if (port < (unsigned int )(ddv_ioport_request_start + ddv_ioport_request_len)) {
#line 99
      tmp = 1;
    } else {
#line 99
      tmp = 0;
    }
  } else {
#line 99
    tmp = 0;
  }
#line 99
  __CPROVER_assert(tmp, "I/O port is requested");
#line 100
  return;
}
}
#line 1 "sched.o"
#pragma merger("0","/tmp/cil-eehL5yot.i","")
#line 18 "/usr/local/ddv/models/con2/include/ddverify/satabs.h"
extern long nondet_long() ;
#line 43 "/usr/local/ddv/models/con2/include/linux/sched.h"
void schedule(void) ;
#line 45
long schedule_timeout(long timeout ) ;
#line 8 "/usr/local/ddv/models/con2/src/linux/kernel/sched.c"
void schedule(void) 
{ 


  {
#line 10
  assert_context_process();
#line 11
  return;
}
}
#line 13 "/usr/local/ddv/models/con2/src/linux/kernel/sched.c"
long schedule_timeout(long timeout ) 
{ 
  long tmp ;

  {
#line 15
  assert_context_process();
#line 17
  tmp = nondet_long();
#line 17
  return (tmp);
}
}
#line 1 "semaphore.o"
#pragma merger("0","/tmp/cil-SGF9cGo9.i","")
#line 23 "/usr/local/ddv/models/con2/include/asm/semaphore.h"
__inline void sema_init(struct semaphore *sem , int val ) ;
#line 25
__inline void init_MUTEX(struct semaphore *sem ) ;
#line 27
__inline void init_MUTEX_LOCKED(struct semaphore *sem ) ;
#line 29
__inline void down(struct semaphore *sem ) ;
#line 31
__inline int down_interruptible(struct semaphore *sem ) ;
#line 33
__inline int down_trylock(struct semaphore *sem ) ;
#line 35
__inline void up(struct semaphore *sem ) ;
#line 6 "/usr/local/ddv/models/con2/src/linux/kernel/semaphore.c"
__inline void sema_init(struct semaphore *sem , int val ) 
{ 


  {
#line 9
  __CPROVER_atomic_begin();
#line 10
  sem->init = 1;
#line 11
  sem->locked = 0;
#line 12
  __CPROVER_atomic_end();
#line 13
  return;
}
}
#line 15 "/usr/local/ddv/models/con2/src/linux/kernel/semaphore.c"
__inline void init_MUTEX(struct semaphore *sem ) 
{ 


  {
#line 18
  __CPROVER_atomic_begin();
#line 19
  sem->init = 1;
#line 20
  sem->locked = 0;
#line 21
  __CPROVER_atomic_end();
#line 22
  return;
}
}
#line 24 "/usr/local/ddv/models/con2/src/linux/kernel/semaphore.c"
__inline void init_MUTEX_LOCKED(struct semaphore *sem ) 
{ 


  {
#line 27
  __CPROVER_atomic_begin();
#line 28
  sem->init = 1;
#line 29
  sem->locked = 1;
#line 30
  __CPROVER_atomic_end();
#line 31
  return;
}
}
#line 33 "/usr/local/ddv/models/con2/src/linux/kernel/semaphore.c"
__inline void down(struct semaphore *sem ) 
{ 


  {
#line 44
  while (1) {
#line 46
    __CPROVER_atomic_begin();
#line 47
    if (sem->locked == 0) {
#line 49
      sem->locked = 1;
#line 50
      __CPROVER_atomic_end();
#line 51
      return;
    }
#line 53
    __CPROVER_atomic_end();
  }
}
}
#line 58 "/usr/local/ddv/models/con2/src/linux/kernel/semaphore.c"
__inline int down_interruptible(struct semaphore *sem ) 
{ 
  int tmp ;

  {
#line 69
  while (1) {
#line 71
    __CPROVER_atomic_begin();
#line 72
    if (sem->locked == 0) {
#line 74
      sem->locked = 1;
#line 75
      __CPROVER_atomic_end();
#line 76
      return (0);
    }
#line 78
    tmp = nondet_int();
#line 78
    if (tmp) {
#line 79
      __CPROVER_atomic_end();
#line 80
      return (-1);
    }
#line 83
    __CPROVER_atomic_end();
  }
}
}
#line 88 "/usr/local/ddv/models/con2/src/linux/kernel/semaphore.c"
__inline int down_trylock(struct semaphore *sem ) 
{ 


  {
#line 91
  __CPROVER_atomic_begin();
#line 97
  if (sem->locked == 0) {
#line 98
    sem->locked = 1;
#line 99
    __CPROVER_atomic_end();
#line 100
    return (-1);
  }
#line 102
  __CPROVER_atomic_end();
#line 103
  return (0);
}
}
#line 106 "/usr/local/ddv/models/con2/src/linux/kernel/semaphore.c"
__inline void up(struct semaphore *sem ) 
{ 


  {
#line 109
  __CPROVER_atomic_begin();
#line 110
  assert_context_process();
#line 114
  sem->locked = 0;
#line 115
  __CPROVER_atomic_end();
#line 116
  return;
}
}
#line 1 "slab.o"
#pragma merger("0","/tmp/cil-IKU1UBLz.i","")
#line 12 "/usr/local/ddv/models/con2/include/linux/slab.h"
void *kzalloc(size_t size , gfp_t flags ) ;
#line 6 "/usr/local/ddv/models/con2/src/linux/mm/slab.c"
void *kmalloc(size_t size , gfp_t flags ) 
{ 
  void *tmp ;

  {
#line 8
  if (flags & 16U) {
#line 9
    assert_context_process();
  }
#line 12
  tmp = malloc(size);
#line 12
  return (tmp);
}
}
#line 15 "/usr/local/ddv/models/con2/src/linux/mm/slab.c"
void *kzalloc(size_t size , gfp_t flags ) 
{ 
  void *tmp ;

  {
#line 17
  if (flags & 16U) {
#line 18
    assert_context_process();
  }
#line 21
  tmp = malloc(size);
#line 21
  return (tmp);
}
}
#line 1 "softirq.o"
#pragma merger("0","/tmp/cil-Ul2zos3E.i","")
#line 65 "/usr/local/ddv/models/con2/include/linux/interrupt.h"
__inline void tasklet_init(struct tasklet_struct *t , void (*func)(unsigned long  ) ,
                           unsigned long data ) ;
#line 4 "/usr/local/ddv/models/con2/src/linux/kernel/softirq.c"
void tasklet_schedule(struct tasklet_struct *t ) 
{ 
  int i ;
  int next_free ;

  {
#line 7
  next_free = -1;
#line 13
  i = 0;
#line 13
  while (i < 10) {
#line 14
    if ((unsigned long )tasklet_registered[i].tasklet == (unsigned long )((void *)0)) {
#line 15
      next_free = i;
    }
#line 17
    if ((unsigned long )tasklet_registered[i].tasklet == (unsigned long )t) {
#line 17
      if ((int )tasklet_registered[i].is_running == 0) {
#line 19
        return;
      }
    }
#line 13
    i ++;
  }
#line 28
  tasklet_registered[next_free].tasklet = t;
#line 29
  tasklet_registered[next_free].is_running = (unsigned short)0;
#line 30
  return;
}
}
#line 32 "/usr/local/ddv/models/con2/src/linux/kernel/softirq.c"
__inline void tasklet_init(struct tasklet_struct *t , void (*func)(unsigned long  ) ,
                           unsigned long data ) 
{ 


  {
#line 36
  t->count = 0;
#line 37
  t->init = 0;
#line 38
  t->func = func;
#line 39
  t->data = data;
#line 40
  return;
}
}
#line 1 "spinlock.o"
#pragma merger("0","/tmp/cil-vK9JBB31.i","")
#line 10 "/usr/local/ddv/models/con2/include/linux/spinlock.h"
__inline void spin_lock(spinlock_t *lock ) ;
#line 11
__inline void spin_lock_irqsave(spinlock_t *lock , unsigned long flags ) ;
#line 13
__inline void spin_lock_bh(spinlock_t *lock ) ;
#line 15
__inline void spin_unlock(spinlock_t *lock ) ;
#line 16
__inline void spin_unlock_irqrestore(spinlock_t *lock , unsigned long flags ) ;
#line 18
__inline void spin_unlock_bh(spinlock_t *lock ) ;
#line 4 "/usr/local/ddv/models/con2/src/linux/kernel/spinlock.c"
void spin_lock_init(spinlock_t *lock ) 
{ 


  {
#line 6
  lock->init = 1;
#line 7
  lock->locked = 0;
#line 8
  return;
}
}
#line 10 "/usr/local/ddv/models/con2/src/linux/kernel/spinlock.c"
__inline void spin_lock(spinlock_t *lock ) 
{ 


  {
#line 20
  while (1) {
#line 22
    __CPROVER_atomic_begin();
#line 23
    if (lock->locked == 0) {
#line 25
      lock->locked = 1;
#line 26
      __CPROVER_atomic_end();
#line 27
      return;
    }
#line 29
    __CPROVER_atomic_end();
  }
}
}
#line 34 "/usr/local/ddv/models/con2/src/linux/kernel/spinlock.c"
__inline void spin_lock_irqsave(spinlock_t *lock , unsigned long flags ) 
{ 


  {
#line 44
  while (1) {
#line 46
    __CPROVER_atomic_begin();
#line 47
    if (lock->locked == 0) {
#line 49
      lock->locked = 1;
#line 50
      __CPROVER_atomic_end();
#line 51
      return;
    }
#line 53
    __CPROVER_atomic_end();
  }
}
}
#line 58 "/usr/local/ddv/models/con2/src/linux/kernel/spinlock.c"
void spin_lock_irq(spinlock_t *lock ) 
{ 


  {
#line 68
  while (1) {
#line 70
    __CPROVER_atomic_begin();
#line 71
    if (lock->locked == 0) {
#line 73
      lock->locked = 1;
#line 74
      __CPROVER_atomic_end();
#line 75
      return;
    }
#line 77
    __CPROVER_atomic_end();
  }
}
}
#line 106 "/usr/local/ddv/models/con2/src/linux/kernel/spinlock.c"
__inline void spin_unlock(spinlock_t *lock ) 
{ 


  {
#line 109
  __CPROVER_atomic_begin();
#line 113
  lock->locked = 0;
#line 114
  __CPROVER_atomic_end();
#line 115
  return;
}
}
#line 117 "/usr/local/ddv/models/con2/src/linux/kernel/spinlock.c"
__inline void spin_unlock_irqrestore(spinlock_t *lock , unsigned long flags ) 
{ 


  {
#line 120
  __CPROVER_atomic_begin();
#line 124
  lock->locked = 0;
#line 125
  __CPROVER_atomic_end();
#line 126
  return;
}
}
#line 128 "/usr/local/ddv/models/con2/src/linux/kernel/spinlock.c"
void spin_unlock_irq(spinlock_t *lock ) 
{ 


  {
#line 131
  __CPROVER_atomic_begin();
#line 135
  lock->locked = 0;
#line 136
  __CPROVER_atomic_end();
#line 137
  return;
}
}
#line 1 "tasklet.o"
#pragma merger("0","/tmp/cil-vE5ZagTt.i","")
#line 3 "/usr/local/ddv/models/con2/src/ddverify/tasklet.c"
void call_tasklet_functions(void) 
{ 
  unsigned int i ;

  {
#line 6
  __CPROVER_assume(i < 10U);
#line 8
  if ((unsigned long )tasklet_registered[i].tasklet != (unsigned long )((void *)0)) {
#line 8
    if ((tasklet_registered[i].tasklet)->count == 0) {
#line 10
      tasklet_registered[i].is_running = (unsigned short)1;
#line 11
      (*((tasklet_registered[i].tasklet)->func))((tasklet_registered[i].tasklet)->data);
#line 12
      tasklet_registered[i].is_running = (unsigned short)0;
#line 13
      tasklet_registered[i].tasklet = (struct tasklet_struct *)((void *)0);
    }
  }
#line 15
  return;
}
}
#line 1 "timer.o"
#pragma merger("0","/tmp/cil-p47YBrdx.i","")
#line 27 "/usr/local/ddv/models/con2/include/linux/timer.h"
__inline void add_timer_on(struct timer_list *timer , int cpu ) ;
#line 30
__inline int mod_timer(struct timer_list *timer , unsigned long expires ) ;
#line 4 "/usr/local/ddv/models/con2/src/linux/kernel/timer.c"
void init_timer(struct timer_list *timer ) 
{ 


  {
#line 6
  if ((int )number_timer_registered < 5) {
#line 7
    timer->__ddv_active = (short)0;
#line 8
    timer->__ddv_init = (short)1;
#line 9
    timer_registered[number_timer_registered].timer = timer;
#line 11
    number_timer_registered = (short )((int )number_timer_registered + 1);
  }
#line 13
  return;
}
}
#line 15 "/usr/local/ddv/models/con2/src/linux/kernel/timer.c"
void add_timer(struct timer_list *timer ) 
{ 


  {
#line 21
  timer->__ddv_active = (short)1;
#line 22
  return;
}
}
#line 24 "/usr/local/ddv/models/con2/src/linux/kernel/timer.c"
__inline void add_timer_on(struct timer_list *timer , int cpu ) 
{ 


  {
#line 27
  add_timer(timer);
#line 28
  return;
}
}
#line 30 "/usr/local/ddv/models/con2/src/linux/kernel/timer.c"
int del_timer(struct timer_list *timer ) 
{ 


  {
#line 32
  timer->__ddv_active = (short)0;
#line 33
  return (0);
}
}
#line 35 "/usr/local/ddv/models/con2/src/linux/kernel/timer.c"
__inline int mod_timer(struct timer_list *timer , unsigned long expires ) 
{ 


  {
#line 41
  timer->expires = expires;
#line 42
  timer->__ddv_active = (short)1;
#line 43
  return (0);
}
}
#line 1 "tty_io.o"
#pragma merger("0","/tmp/cil-TWyo6L2t.i","")
#line 97 "/usr/local/ddv/models/con2/include/linux/tty_driver.h"
struct tty_driver *alloc_tty_driver(int lines ) ;
#line 101
void tty_set_operations(struct tty_driver *driver , struct tty_operations  const  *op ) ;
#line 13 "/usr/local/ddv/models/con2/include/ddverify/tty.h"
struct ddv_tty_driver global_tty_driver  ;
#line 4 "/usr/local/ddv/models/con2/src/linux/drivers/char/tty_io.c"
struct tty_driver *alloc_tty_driver(int lines ) 
{ 


  {
#line 6
  if (! global_tty_driver.allocated) {
#line 7
    global_tty_driver.driver.magic = 21506;
#line 8
    global_tty_driver.driver.num = lines;
  } else {
#line 10
    return ((struct tty_driver *)((void *)0));
  }
#line 12
  return ((struct tty_driver *)0);
}
}
#line 14 "/usr/local/ddv/models/con2/src/linux/drivers/char/tty_io.c"
void tty_set_operations(struct tty_driver *driver , struct tty_operations  const  *op ) 
{ 


  {
#line 17
  driver->open = (int (*)(struct tty_struct *tty , struct file *filp ))op->open;
#line 18
  driver->close = (void (*)(struct tty_struct *tty , struct file *filp ))op->close;
#line 19
  driver->write = (int (*)(struct tty_struct *tty , unsigned char const   *buf , int count ))op->write;
#line 20
  driver->put_char = (void (*)(struct tty_struct *tty , unsigned char ch ))op->put_char;
#line 21
  driver->flush_chars = (void (*)(struct tty_struct *tty ))op->flush_chars;
#line 22
  driver->write_room = (int (*)(struct tty_struct *tty ))op->write_room;
#line 23
  driver->chars_in_buffer = (int (*)(struct tty_struct *tty ))op->chars_in_buffer;
#line 24
  driver->ioctl = (int (*)(struct tty_struct *tty , struct file *file , unsigned int cmd ,
                           unsigned long arg ))op->ioctl;
#line 25
  driver->set_termios = (void (*)(struct tty_struct *tty , struct termios *old ))op->set_termios;
#line 26
  driver->throttle = (void (*)(struct tty_struct *tty ))op->throttle;
#line 27
  driver->unthrottle = (void (*)(struct tty_struct *tty ))op->unthrottle;
#line 28
  driver->stop = (void (*)(struct tty_struct *tty ))op->stop;
#line 29
  driver->start = (void (*)(struct tty_struct *tty ))op->start;
#line 30
  driver->hangup = (void (*)(struct tty_struct *tty ))op->hangup;
#line 31
  driver->break_ctl = (void (*)(struct tty_struct *tty , int state ))op->break_ctl;
#line 32
  driver->flush_buffer = (void (*)(struct tty_struct *tty ))op->flush_buffer;
#line 33
  driver->set_ldisc = (void (*)(struct tty_struct *tty ))op->set_ldisc;
#line 34
  driver->wait_until_sent = (void (*)(struct tty_struct *tty , int timeout ))op->wait_until_sent;
#line 35
  driver->send_xchar = (void (*)(struct tty_struct *tty , char ch ))op->send_xchar;
#line 36
  driver->read_proc = (int (*)(char *page , char **start , off_t off , int count ,
                               int *eof , void *data ))op->read_proc;
#line 37
  driver->write_proc = (int (*)(struct file *file , char const   *buffer , unsigned long count ,
                                void *data ))op->write_proc;
#line 38
  driver->tiocmget = (int (*)(struct tty_struct *tty , struct file *file ))op->tiocmget;
#line 39
  driver->tiocmset = (int (*)(struct tty_struct *tty , struct file *file , unsigned int set ,
                              unsigned int clear ))op->tiocmset;
#line 40
  return;
}
}
#line 1 "usercopy.o"
#pragma merger("0","/tmp/cil-EbtUCgWX.i","")
#line 41 "/usr/local/ddv/models/con2/include/asm/uaccess.h"
__inline int __get_user(int size , void *ptr ) ;
#line 43
__inline int get_user(int size , void *ptr ) ;
#line 46
__inline int __put_user(int size , void *ptr ) ;
#line 48
__inline int put_user(int size , void *ptr ) ;
#line 51
__inline unsigned long copy_to_user(void *to , void const   *from , unsigned long n ) ;
#line 53
__inline unsigned long copy_from_user(void *to , void *from , unsigned long n ) ;
#line 5 "/usr/local/ddv/models/con2/src/linux/arch/i386/lib/usercopy.c"
__inline int __get_user(int size , void *ptr ) 
{ 
  int tmp ;

  {
#line 8
  assert_context_process();
#line 10
  tmp = nondet_int();
#line 10
  return (tmp);
}
}
#line 37 "/usr/local/ddv/models/con2/src/linux/arch/i386/lib/usercopy.c"
__inline unsigned long copy_to_user(void *to , void const   *from , unsigned long n ) 
{ 
  unsigned long tmp ;

  {
#line 40
  assert_context_process();
#line 42
  tmp = nondet_ulong();
#line 42
  return (tmp);
}
}
#line 45 "/usr/local/ddv/models/con2/src/linux/arch/i386/lib/usercopy.c"
__inline unsigned long copy_from_user(void *to , void *from , unsigned long n ) 
{ 
  unsigned long tmp ;

  {
#line 48
  assert_context_process();
#line 50
  tmp = nondet_ulong();
#line 50
  return (tmp);
}
}
#line 1 "vmalloc.o"
#pragma merger("0","/tmp/cil-ZSjx7mG0.i","")
#line 6 "/usr/local/ddv/models/con2/include/linux/vmalloc.h"
void *vmalloc(unsigned long size ) ;
#line 6 "/usr/local/ddv/models/con2/src/linux/mm/vmalloc.c"
void *vmalloc(unsigned long size ) 
{ 
  void *tmp ;

  {
#line 8
  tmp = malloc((size_t )size);
#line 8
  return (tmp);
}
}
#line 1 "wait.o"
#pragma merger("0","/tmp/cil-_6YOUrHp.i","")
#line 64 "/usr/local/ddv/models/con2/include/linux/wait.h"
__inline void init_waitqueue_head(wait_queue_head_t *q ) ;
#line 71
__inline void wake_up(wait_queue_head_t *q ) ;
#line 73
__inline void wake_up_all(wait_queue_head_t *q ) ;
#line 88
__inline void sleep_on(wait_queue_head_t *q ) ;
#line 3 "/usr/local/ddv/models/con2/src/linux/kernel/wait.c"
__inline void init_waitqueue_head(wait_queue_head_t *q ) 
{ 


  {
#line 5
  q->init = 1;
#line 6
  return;
}
}
#line 8 "/usr/local/ddv/models/con2/src/linux/kernel/wait.c"
__inline void wake_up(wait_queue_head_t *q ) 
{ 


  {
#line 14
  return;
}
}
#line 24 "/usr/local/ddv/models/con2/src/linux/kernel/wait.c"
void wake_up_interruptible(wait_queue_head_t *q ) 
{ 


  {
#line 30
  return;
}
}
#line 40 "/usr/local/ddv/models/con2/src/linux/kernel/wait.c"
void interruptible_sleep_on(wait_queue_head_t *q ) 
{ 


  {
#line 46
  return;
}
}
#line 1 "workqueue.o"
#pragma merger("0","/tmp/cil-v8xQ_R7d.i","")
#line 46 "/usr/local/ddv/models/con2/include/linux/workqueue.h"
__inline int schedule_work(struct work_struct *work ) ;
#line 5 "/usr/local/ddv/models/con2/src/linux/kernel/workqueue.c"
__inline int schedule_work(struct work_struct *work ) 
{ 
  int i ;

  {
#line 14
  i = 0;
#line 14
  while (i < 10) {
#line 15
    if ((unsigned long )shared_workqueue[i] == (unsigned long )work) {
#line 16
      return (0);
    }
#line 19
    if ((unsigned long )shared_workqueue[i] == (unsigned long )((void *)0)) {
#line 20
      shared_workqueue[i] = work;
#line 22
      return (1);
    }
#line 14
    i ++;
  }
#line 27
  return (-1);
}
}
#line 30 "/usr/local/ddv/models/con2/src/linux/kernel/workqueue.c"
void call_shared_workqueue_functions(void) 
{ 
  unsigned short i ;
  unsigned short tmp ;

  {
#line 32
  tmp = nondet_ushort();
#line 32
  i = tmp;
#line 33
  __CPROVER_assume((int )i < 10);
#line 35
  if ((unsigned long )shared_workqueue[i] != (unsigned long )((void *)0)) {
#line 36
    (*((shared_workqueue[i])->func))((shared_workqueue[i])->data);
#line 37
    shared_workqueue[i] = (struct work_struct *)((void *)0);
  }
#line 39
  return;
}
}
