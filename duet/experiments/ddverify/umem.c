/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is true */

#line 4 "/usr/local/ddv/models/con2/include/asm/posix_types.h"
typedef unsigned long __kernel_ino_t;
#line 5 "/usr/local/ddv/models/con2/include/asm/posix_types.h"
typedef unsigned short __kernel_mode_t;
#line 12 "/usr/local/ddv/models/con2/include/asm/posix_types.h"
typedef unsigned int __kernel_size_t;
#line 13 "/usr/local/ddv/models/con2/include/asm/posix_types.h"
typedef int __kernel_ssize_t;
#line 4 "/usr/local/ddv/models/con2/include/asm/types.h"
typedef unsigned short umode_t;
#line 13 "/usr/local/ddv/models/con2/include/asm/types.h"
typedef unsigned int __u32;
#line 9 "/usr/local/ddv/models/con2/include/linux/types.h"
typedef __u32 __kernel_dev_t;
#line 11 "/usr/local/ddv/models/con2/include/linux/types.h"
typedef __kernel_dev_t dev_t;
#line 12 "/usr/local/ddv/models/con2/include/linux/types.h"
typedef __kernel_ino_t ino_t;
#line 13 "/usr/local/ddv/models/con2/include/linux/types.h"
typedef __kernel_mode_t mode_t;
#line 30 "/usr/local/ddv/models/con2/include/linux/types.h"
typedef long long loff_t;
#line 38 "/usr/local/ddv/models/con2/include/linux/types.h"
typedef __kernel_size_t size_t;
#line 43 "/usr/local/ddv/models/con2/include/linux/types.h"
typedef __kernel_ssize_t ssize_t;
#line 44 "/usr/local/ddv/models/con2/include/ddverify/satabs.h"
struct __pthread_t_struct {
   int id ;
};
#line 49 "/usr/local/ddv/models/con2/include/ddverify/satabs.h"
struct __pthread_attr_t_struct {
   int dummy ;
};
#line 54 "/usr/local/ddv/models/con2/include/ddverify/satabs.h"
typedef struct __pthread_t_struct pthread_t;
#line 55 "/usr/local/ddv/models/con2/include/ddverify/satabs.h"
typedef struct __pthread_attr_t_struct pthread_attr_t;
#line 6 "/usr/local/ddv/models/con2/include/asm/atomic.h"
typedef int atomic_t;
#line 67 "/usr/local/ddv/models/con2/include/linux/gfp.h"
struct page;
#line 4 "/usr/local/ddv/models/con2/include/linux/dcache.h"
struct inode;
#line 4 "/usr/local/ddv/models/con2/include/linux/dcache.h"
struct dentry {
   struct inode *d_inode ;
};
#line 83 "/usr/local/ddv/models/con2/include/linux/fs.h"
struct iovec;
#line 84
struct poll_table_struct;
#line 85
struct vm_area_struct;
#line 90 "/usr/local/ddv/models/con2/include/linux/fs.h"
struct address_space {
   struct inode *host ;
};
#line 94
struct file_operations;
#line 94 "/usr/local/ddv/models/con2/include/linux/fs.h"
struct file {
   struct dentry *f_dentry ;
   struct file_operations *f_op ;
   atomic_t f_count ;
   unsigned int f_flags ;
   mode_t f_mode ;
   loff_t f_pos ;
   void *private_data ;
   struct address_space *f_mapping ;
};
#line 105
struct gendisk;
#line 105 "/usr/local/ddv/models/con2/include/linux/fs.h"
struct block_device {
   struct inode *bd_inode ;
   struct gendisk *bd_disk ;
   struct block_device *bd_contains ;
   unsigned int bd_block_size ;
};
#line 113
struct cdev;
#line 113 "/usr/local/ddv/models/con2/include/linux/fs.h"
struct inode {
   umode_t i_mode ;
   struct block_device *i_bdev ;
   dev_t i_rdev ;
   loff_t i_size ;
   struct cdev *i_cdev ;
};
#line 122 "/usr/local/ddv/models/con2/include/linux/fs.h"
struct __anonstruct_read_descriptor_t_4 {
   size_t written ;
   size_t count ;
};
#line 122 "/usr/local/ddv/models/con2/include/linux/fs.h"
typedef struct __anonstruct_read_descriptor_t_4 read_descriptor_t;
#line 130 "/usr/local/ddv/models/con2/include/linux/fs.h"
struct file_lock {
   int something ;
};
#line 134
struct module;
#line 134 "/usr/local/ddv/models/con2/include/linux/fs.h"
struct file_operations {
   struct module *owner ;
   loff_t (*llseek)(struct file * , loff_t  , int  ) ;
   ssize_t (*read)(struct file * , char * , size_t  , loff_t * ) ;
   ssize_t (*write)(struct file * , char const   * , size_t  , loff_t * ) ;
   int (*readdir)(struct file * , void * , int (*)(void * , char const   * , int  ,
                                                   loff_t  , ino_t  , unsigned int  ) ) ;
   unsigned int (*poll)(struct file * , struct poll_table_struct * ) ;
   int (*ioctl)(struct inode * , struct file * , unsigned int  , unsigned long  ) ;
   long (*unlocked_ioctl)(struct file * , unsigned int  , unsigned long  ) ;
   long (*compat_ioctl)(struct file * , unsigned int  , unsigned long  ) ;
   int (*mmap)(struct file * , struct vm_area_struct * ) ;
   int (*open)(struct inode * , struct file * ) ;
   int (*flush)(struct file * ) ;
   int (*release)(struct inode * , struct file * ) ;
   int (*fsync)(struct file * , struct dentry * , int datasync ) ;
   int (*fasync)(int  , struct file * , int  ) ;
   int (*lock)(struct file * , int  , struct file_lock * ) ;
   ssize_t (*readv)(struct file * , struct iovec  const  * , unsigned long  , loff_t * ) ;
   ssize_t (*writev)(struct file * , struct iovec  const  * , unsigned long  , loff_t * ) ;
   ssize_t (*sendfile)(struct file * , loff_t * , size_t  , int (*)(read_descriptor_t * ,
                                                                    struct page * ,
                                                                    unsigned long  ,
                                                                    unsigned long  ) ,
                       void * ) ;
   ssize_t (*sendpage)(struct file * , struct page * , int  , size_t  , loff_t * ,
                       int  ) ;
   unsigned long (*get_unmapped_area)(struct file * , unsigned long  , unsigned long  ,
                                      unsigned long  , unsigned long  ) ;
   int (*check_flags)(int  ) ;
   int (*dir_notify)(struct file *filp , unsigned long arg ) ;
   int (*flock)(struct file * , int  , struct file_lock * ) ;
   int (*open_exec)(struct inode * ) ;
};
#line 4 "/usr/local/ddv/models/con2/include/linux/cdev.h"
struct cdev {
   struct module *owner ;
   struct file_operations *ops ;
   dev_t dev ;
   unsigned int count ;
};
#line 13 "/usr/local/ddv/models/con2/include/ddverify/cdev.h"
struct ddv_cdev {
   struct cdev *cdevp ;
   struct file filp ;
   struct inode inode ;
   int open ;
};
#line 30 "/usr/local/ddv/models/con2/include/asm/types.h"
typedef unsigned long long u64;
#line 91 "/usr/local/ddv/models/con2/include/linux/types.h"
typedef unsigned long sector_t;
#line 15 "/usr/local/ddv/models/con2/include/ddverify/pthread.h"
struct __pthread_t_struct___0 {
   int id ;
};
#line 25 "/usr/local/ddv/models/con2/include/ddverify/pthread.h"
struct __pthread_mutex_t_struct {
   _Bool locked ;
};
#line 30 "/usr/local/ddv/models/con2/include/ddverify/pthread.h"
struct __pthread_mutexattr_t_struct {
   int dummy ;
};
#line 50 "/usr/local/ddv/models/con2/include/ddverify/pthread.h"
typedef struct __pthread_t_struct___0 pthread_t___0;
#line 52 "/usr/local/ddv/models/con2/include/ddverify/pthread.h"
typedef struct __pthread_mutex_t_struct pthread_mutex_t;
#line 53 "/usr/local/ddv/models/con2/include/ddverify/pthread.h"
typedef struct __pthread_mutexattr_t_struct pthread_mutexattr_t;
#line 9 "/usr/local/ddv/models/con2/include/linux/list.h"
struct list_head {
   struct list_head *next ;
   struct list_head *prev ;
};
#line 4 "/usr/local/ddv/models/con2/include/linux/spinlock_types.h"
struct __anonstruct_spinlock_t_9 {
   int init ;
   int locked ;
};
#line 4 "/usr/local/ddv/models/con2/include/linux/spinlock_types.h"
typedef struct __anonstruct_spinlock_t_9 spinlock_t;
#line 4 "/usr/local/ddv/models/con2/include/linux/timer.h"
struct timer_list {
   unsigned long expires ;
   void (*function)(unsigned long  ) ;
   unsigned long data ;
   short __ddv_active ;
   short __ddv_init ;
};
#line 82 "/usr/local/ddv/models/con2/include/linux/fs.h"
struct hd_geometry;
#line 168 "/usr/local/ddv/models/con2/include/linux/fs.h"
struct block_device_operations {
   int (*open)(struct inode * , struct file * ) ;
   int (*release)(struct inode * , struct file * ) ;
   int (*ioctl)(struct inode * , struct file * , unsigned int  , unsigned long  ) ;
   long (*unlocked_ioctl)(struct file * , unsigned int  , unsigned long  ) ;
   long (*compat_ioctl)(struct file * , unsigned int  , unsigned long  ) ;
   int (*direct_access)(struct block_device * , sector_t  , unsigned long * ) ;
   int (*media_changed)(struct gendisk * ) ;
   int (*revalidate_disk)(struct gendisk * ) ;
   int (*getgeo)(struct block_device * , struct hd_geometry * ) ;
   struct module *owner ;
};
#line 18 "/usr/local/ddv/models/con2/include/linux/ioport.h"
struct resource {
   char const   *name ;
   unsigned long start ;
   unsigned long end ;
   unsigned long flags ;
};
#line 24 "/usr/local/ddv/models/con2/include/linux/module.h"
struct module {
   int something ;
};
#line 8 "/usr/local/ddv/models/con2/include/linux/pm.h"
struct pm_message {
   int event ;
};
#line 8 "/usr/local/ddv/models/con2/include/linux/pm.h"
typedef struct pm_message pm_message_t;
#line 25 "/usr/local/ddv/models/con2/include/linux/device.h"
struct device {
   void *driver_data ;
   void (*release)(struct device *dev ) ;
};
#line 17 "/usr/local/ddv/models/con2/include/linux/genhd.h"
struct request_queue;
#line 17 "/usr/local/ddv/models/con2/include/linux/genhd.h"
struct gendisk {
   int major ;
   int first_minor ;
   int minors ;
   char disk_name[32] ;
   struct block_device_operations *fops ;
   struct request_queue *queue ;
   void *private_data ;
   int flags ;
   struct device *driverfs_dev ;
   char devfs_name[64] ;
};
#line 12 "/usr/local/ddv/models/con2/include/linux/workqueue.h"
struct work_struct {
   unsigned long pending ;
   void (*func)(void * ) ;
   void *data ;
   int init ;
};
#line 9 "/usr/local/ddv/models/con2/include/linux/mm_types.h"
struct page {
   int something ;
};
#line 4 "/usr/local/ddv/models/con2/include/asm/ptrace.h"
struct pt_regs {
   int something ;
};
#line 28 "/usr/local/ddv/models/con2/include/linux/interrupt.h"
typedef int irqreturn_t;
#line 34 "/usr/local/ddv/models/con2/include/linux/interrupt.h"
struct tasklet_struct {
   atomic_t count ;
   void (*func)(unsigned long  ) ;
   unsigned long data ;
   int init ;
};
#line 11 "/usr/local/ddv/models/con2/include/linux/backing-dev.h"
struct backing_dev_info {
   unsigned long ra_pages ;
   unsigned long state ;
   unsigned int capabilities ;
};
#line 6 "/usr/local/ddv/models/con2/include/linux/bio.h"
struct bio_vec {
   struct page *bv_page ;
   unsigned int bv_len ;
   unsigned int bv_offset ;
};
#line 13
struct bio;
#line 14 "/usr/local/ddv/models/con2/include/linux/bio.h"
typedef int bio_end_io_t(struct bio * , unsigned int  , int  );
#line 17 "/usr/local/ddv/models/con2/include/linux/bio.h"
struct bio {
   sector_t bi_sector ;
   struct bio *bi_next ;
   struct block_device *bi_bdev ;
   unsigned long bi_flags ;
   unsigned long bi_rw ;
   unsigned short bi_vcnt ;
   unsigned short bi_idx ;
   unsigned short bi_phys_segments ;
   unsigned int bi_size ;
   struct bio_vec *bi_io_vec ;
   bio_end_io_t *bi_end_io ;
   void *bi_private ;
};
#line 4 "/usr/local/ddv/models/con2/include/linux/elevator.h"
struct request;
#line 23 "/usr/local/ddv/models/con2/include/linux/blkdev.h"
typedef struct request_queue request_queue_t;
#line 25 "/usr/local/ddv/models/con2/include/linux/blkdev.h"
typedef void request_fn_proc(request_queue_t *q );
#line 26 "/usr/local/ddv/models/con2/include/linux/blkdev.h"
typedef int make_request_fn(request_queue_t *q , struct bio *bio );
#line 27 "/usr/local/ddv/models/con2/include/linux/blkdev.h"
typedef void unplug_fn(request_queue_t * );
#line 32
enum rq_cmd_type_bits {
    REQ_TYPE_FS = 1,
    REQ_TYPE_BLOCK_PC = 2,
    REQ_TYPE_SENSE = 3,
    REQ_TYPE_PM_SUSPEND = 4,
    REQ_TYPE_PM_RESUME = 5,
    REQ_TYPE_PM_SHUTDOWN = 6,
    REQ_TYPE_FLUSH = 7,
    REQ_TYPE_SPECIAL = 8,
    REQ_TYPE_LINUX_BLOCK = 9,
    REQ_TYPE_ATA_CMD = 10,
    REQ_TYPE_ATA_TASK = 11,
    REQ_TYPE_ATA_TASKFILE = 12,
    REQ_TYPE_ATA_PC = 13
} ;
#line 54 "/usr/local/ddv/models/con2/include/linux/blkdev.h"
struct request_queue {
   request_fn_proc *request_fn ;
   make_request_fn *make_request_fn ;
   unplug_fn *unplug_fn ;
   struct backing_dev_info backing_dev_info ;
   void *queuedata ;
   unsigned long queue_flags ;
   spinlock_t *queue_lock ;
   unsigned short hardsect_size ;
   int __ddv_genhd_no ;
   int __ddv_queue_alive ;
};
#line 90 "/usr/local/ddv/models/con2/include/linux/blkdev.h"
struct request {
   struct list_head queuelist ;
   struct list_head donelist ;
   request_queue_t *q ;
   unsigned long flags ;
   unsigned int cmd_flags ;
   enum rq_cmd_type_bits cmd_type ;
   struct bio *bio ;
   void *completion_data ;
   struct gendisk *rq_disk ;
   sector_t sector ;
   unsigned long nr_sectors ;
   unsigned int current_nr_sectors ;
   char *buffer ;
   int errors ;
   unsigned short nr_phys_segments ;
   unsigned char cmd[16] ;
};
#line 15 "/usr/local/ddv/models/con2/include/ddverify/genhd.h"
struct ddv_genhd {
   struct gendisk *gd ;
   struct inode inode ;
   struct file file ;
   struct request current_request ;
   int requests_open ;
};
#line 6 "/usr/local/ddv/models/con2/include/linux/mod_devicetable.h"
typedef unsigned long kernel_ulong_t;
#line 10 "/usr/local/ddv/models/con2/include/linux/mod_devicetable.h"
struct pci_device_id {
   __u32 vendor ;
   __u32 device ;
   __u32 subvendor ;
   __u32 subdevice ;
   __u32 class ;
   __u32 class_mask ;
   kernel_ulong_t driver_data ;
};
#line 40 "/usr/local/ddv/models/con2/include/linux/pci.h"
typedef int pci_power_t;
#line 43
struct pci_bus;
#line 43 "/usr/local/ddv/models/con2/include/linux/pci.h"
struct pci_dev {
   struct pci_bus *bus ;
   unsigned int devfn ;
   unsigned short vendor ;
   unsigned short device ;
   u64 dma_mask ;
   struct device dev ;
   unsigned int irq ;
   struct resource resource[12] ;
};
#line 62 "/usr/local/ddv/models/con2/include/linux/pci.h"
struct pci_bus {
   unsigned char number ;
};
#line 67 "/usr/local/ddv/models/con2/include/linux/pci.h"
struct pci_driver {
   char *name ;
   struct pci_device_id  const  *id_table ;
   int (*probe)(struct pci_dev *dev , struct pci_device_id  const  *id ) ;
   void (*remove)(struct pci_dev *dev ) ;
   int (*suspend)(struct pci_dev *dev , pm_message_t state ) ;
   int (*resume)(struct pci_dev *dev ) ;
   int (*enable_wake)(struct pci_dev *dev , pci_power_t state , int enable ) ;
   void (*shutdown)(struct pci_dev *dev ) ;
};
#line 6 "/usr/local/ddv/models/con2/include/ddverify/pci.h"
struct ddv_pci_driver {
   struct pci_driver *pci_driver ;
   struct pci_dev pci_dev ;
   unsigned int no_pci_device_id ;
   int dev_initialized ;
};
#line 9 "/usr/local/ddv/models/con2/include/ddverify/interrupt.h"
struct registered_irq {
   irqreturn_t (*handler)(int  , void * , struct pt_regs * ) ;
   void *dev_id ;
};
#line 10 "/usr/local/ddv/models/con2/include/ddverify/tasklet.h"
struct ddv_tasklet {
   struct tasklet_struct *tasklet ;
   unsigned short is_running ;
};
#line 10 "/usr/local/ddv/models/con2/include/ddverify/timer.h"
struct ddv_timer {
   struct timer_list *timer ;
};
#line 88 "/usr/local/ddv/models/con2/include/linux/types.h"
typedef unsigned int gfp_t;
#line 16 "/usr/local/ddv/models/con2/include/asm/types.h"
typedef unsigned long long __u64;
#line 21 "/usr/local/ddv/models/con2/include/asm/types.h"
typedef unsigned char u8;
#line 24 "/usr/local/ddv/models/con2/include/asm/types.h"
typedef unsigned short u16;
#line 27 "/usr/local/ddv/models/con2/include/asm/types.h"
typedef unsigned int u32;
#line 32 "/usr/local/ddv/models/con2/include/asm/types.h"
typedef u32 dma_addr_t;
#line 100 "/usr/local/ddv/models/con2/include/linux/types.h"
typedef __u32 __le32;
#line 102 "/usr/local/ddv/models/con2/include/linux/types.h"
typedef __u64 __le64;
#line 4 "/usr/local/ddv/models/con2/include/linux/hdreg.h"
struct hd_geometry {
   unsigned char heads ;
   unsigned char sectors ;
   unsigned short cylinders ;
   unsigned long start ;
};
#line 112 "umem.h"
struct mm_dma_desc {
   __le64 pci_addr ;
   __le64 local_addr ;
   __le32 transfer_size ;
   u32 zero1 ;
   __le64 next_desc_addr ;
   __le64 sem_addr ;
   __le32 control_bits ;
   u32 zero2 ;
   dma_addr_t data_dma_handle ;
   __le64 sem_control_bits ;
} __attribute__((__aligned__(8))) ;
#line 101 "umem.c"
struct mm_page {
   dma_addr_t page_dma ;
   struct mm_dma_desc *desc ;
   int cnt ;
   int headcnt ;
   struct bio *bio ;
   struct bio **biotail ;
};
#line 101 "umem.c"
struct __anonstruct_battery_5 {
   int good ;
   int warned ;
   unsigned long last_change ;
};
#line 101 "umem.c"
struct cardinfo {
   int card_number ;
   struct pci_dev *dev ;
   int irq ;
   unsigned long csr_base ;
   unsigned char *csr_remap ;
   unsigned long csr_len ;
   unsigned int win_size ;
   unsigned int mm_size ;
   unsigned int init_size ;
   struct bio *bio ;
   struct bio *currentbio ;
   struct bio **biotail ;
   request_queue_t *queue ;
   struct mm_page mm_pages[2] ;
   int Active ;
   int Ready ;
   struct tasklet_struct tasklet ;
   unsigned int dma_status ;
   struct __anonstruct_battery_5 battery[2] ;
   spinlock_t lock ;
   int check_batteries ;
   int flags ;
};
#line 34 "/usr/local/ddv/models/con2/include/linux/miscdevice.h"
struct miscdevice {
   int minor ;
   char const   *name ;
   struct file_operations *fops ;
};
#line 7 "/usr/local/ddv/models/con2/include/linux/proc_fs.h"
struct proc_dir_entry {
   int something ;
};
#line 20 "/usr/local/ddv/models/con2/include/linux/mutex.h"
struct mutex {
   int locked ;
   int init ;
};
#line 4 "/usr/local/ddv/models/con2/include/asm/semaphore.h"
struct semaphore {
   int init ;
   int locked ;
};
#line 7 "/usr/local/ddv/models/con2/include/asm/posix_types.h"
typedef long __kernel_off_t;
#line 15 "/usr/local/ddv/models/con2/include/linux/types.h"
typedef __kernel_off_t off_t;
#line 16 "/usr/local/ddv/models/con2/include/linux/wait.h"
struct __wait_queue_head {
   int number_process_waiting ;
   int wakeup ;
   int init ;
};
#line 22 "/usr/local/ddv/models/con2/include/linux/wait.h"
typedef struct __wait_queue_head wait_queue_head_t;
#line 6 "/usr/local/ddv/models/con2/include/asm/termbits.h"
typedef unsigned char cc_t;
#line 8 "/usr/local/ddv/models/con2/include/asm/termbits.h"
typedef unsigned int tcflag_t;
#line 11 "/usr/local/ddv/models/con2/include/asm/termbits.h"
struct termios {
   tcflag_t c_iflag ;
   tcflag_t c_oflag ;
   tcflag_t c_cflag ;
   tcflag_t c_lflag ;
   cc_t c_line ;
   cc_t c_cc[19] ;
};
#line 9 "/usr/local/ddv/models/con2/include/linux/tty_driver.h"
struct tty_struct;
#line 12 "/usr/local/ddv/models/con2/include/linux/tty_driver.h"
struct tty_operations {
   int (*open)(struct tty_struct *tty , struct file *filp ) ;
   void (*close)(struct tty_struct *tty , struct file *filp ) ;
   int (*write)(struct tty_struct *tty , unsigned char const   *buf , int count ) ;
   void (*put_char)(struct tty_struct *tty , unsigned char ch ) ;
   void (*flush_chars)(struct tty_struct *tty ) ;
   int (*write_room)(struct tty_struct *tty ) ;
   int (*chars_in_buffer)(struct tty_struct *tty ) ;
   int (*ioctl)(struct tty_struct *tty , struct file *file , unsigned int cmd , unsigned long arg ) ;
   void (*set_termios)(struct tty_struct *tty , struct termios *old ) ;
   void (*throttle)(struct tty_struct *tty ) ;
   void (*unthrottle)(struct tty_struct *tty ) ;
   void (*stop)(struct tty_struct *tty ) ;
   void (*start)(struct tty_struct *tty ) ;
   void (*hangup)(struct tty_struct *tty ) ;
   void (*break_ctl)(struct tty_struct *tty , int state ) ;
   void (*flush_buffer)(struct tty_struct *tty ) ;
   void (*set_ldisc)(struct tty_struct *tty ) ;
   void (*wait_until_sent)(struct tty_struct *tty , int timeout ) ;
   void (*send_xchar)(struct tty_struct *tty , char ch ) ;
   int (*read_proc)(char *page , char **start , off_t off , int count , int *eof ,
                    void *data ) ;
   int (*write_proc)(struct file *file , char const   *buffer , unsigned long count ,
                     void *data ) ;
   int (*tiocmget)(struct tty_struct *tty , struct file *file ) ;
   int (*tiocmset)(struct tty_struct *tty , struct file *file , unsigned int set ,
                   unsigned int clear ) ;
};
#line 43 "/usr/local/ddv/models/con2/include/linux/tty_driver.h"
struct tty_driver {
   int magic ;
   struct cdev cdev ;
   struct module *owner ;
   char const   *driver_name ;
   char const   *name ;
   int name_base ;
   int major ;
   int minor_start ;
   int minor_num ;
   int num ;
   short type ;
   short subtype ;
   struct termios init_termios ;
   int flags ;
   int refcount ;
   struct proc_dir_entry *proc_entry ;
   int (*open)(struct tty_struct *tty , struct file *filp ) ;
   void (*close)(struct tty_struct *tty , struct file *filp ) ;
   int (*write)(struct tty_struct *tty , unsigned char const   *buf , int count ) ;
   void (*put_char)(struct tty_struct *tty , unsigned char ch ) ;
   void (*flush_chars)(struct tty_struct *tty ) ;
   int (*write_room)(struct tty_struct *tty ) ;
   int (*chars_in_buffer)(struct tty_struct *tty ) ;
   int (*ioctl)(struct tty_struct *tty , struct file *file , unsigned int cmd , unsigned long arg ) ;
   void (*set_termios)(struct tty_struct *tty , struct termios *old ) ;
   void (*throttle)(struct tty_struct *tty ) ;
   void (*unthrottle)(struct tty_struct *tty ) ;
   void (*stop)(struct tty_struct *tty ) ;
   void (*start)(struct tty_struct *tty ) ;
   void (*hangup)(struct tty_struct *tty ) ;
   void (*break_ctl)(struct tty_struct *tty , int state ) ;
   void (*flush_buffer)(struct tty_struct *tty ) ;
   void (*set_ldisc)(struct tty_struct *tty ) ;
   void (*wait_until_sent)(struct tty_struct *tty , int timeout ) ;
   void (*send_xchar)(struct tty_struct *tty , char ch ) ;
   int (*read_proc)(char *page , char **start , off_t off , int count , int *eof ,
                    void *data ) ;
   int (*write_proc)(struct file *file , char const   *buffer , unsigned long count ,
                     void *data ) ;
   int (*tiocmget)(struct tty_struct *tty , struct file *file ) ;
   int (*tiocmset)(struct tty_struct *tty , struct file *file , unsigned int set ,
                   unsigned int clear ) ;
};
#line 113 "/usr/local/ddv/models/con2/include/linux/tty.h"
struct tty_struct {
   int magic ;
   struct tty_driver *driver ;
   int index ;
   struct termios *termios ;
   struct termios *termios_locked ;
   char name[64] ;
   unsigned long flags ;
   int count ;
   unsigned char stopped : 1 ;
   unsigned char hw_stopped : 1 ;
   unsigned char flow_stopped : 1 ;
   unsigned char packet : 1 ;
   unsigned int receive_room ;
   wait_queue_head_t write_wait ;
   wait_queue_head_t read_wait ;
   void *disc_data ;
   void *driver_data ;
   unsigned char closing : 1 ;
};
#line 7 "/usr/local/ddv/models/con2/include/ddverify/tty.h"
struct ddv_tty_driver {
   struct tty_driver driver ;
   unsigned short allocated ;
   unsigned short registered ;
};
#line 1 "cdev.o"
#pragma merger("0","/tmp/cil-xM3Xwg3u.i","")
#line 11 "/usr/local/ddv/models/con2/include/ddverify/ddverify.h"
int current_execution_context  ;
#line 42 "/usr/local/ddv/models/con2/include/ddverify/ddverify.h"
int (*_ddv_module_init)(void)  ;
#line 43 "/usr/local/ddv/models/con2/include/ddverify/ddverify.h"
void (*_ddv_module_exit)(void)  ;
#line 15 "/usr/local/ddv/models/con2/include/ddverify/satabs.h"
extern unsigned short nondet_ushort() ;
#line 16
extern int nondet_int() ;
#line 17
extern unsigned int nondet_uint() ;
#line 19
extern unsigned long nondet_ulong() ;
#line 20
extern char nondet_char() ;
#line 23
extern loff_t nondet_loff_t() ;
#line 24
extern size_t nondet_size_t() ;
#line 57
extern pthread_t nondet_pthread_t() ;
#line 59 "/usr/local/ddv/models/con2/include/ddverify/satabs.h"
__inline extern int pthread_create(pthread_t *__threadp , pthread_attr_t const   *__attr ,
                                   void *(*__start_routine)(void * ) , void *__arg ) 
{ 


  {
#line 65
  *__threadp = nondet_pthread_t();
#line 66
  (*__start_routine)(__arg);
#line 67
  return (0);
}
}
#line 7 "/usr/local/ddv/models/con2/include/linux/jiffies.h"
unsigned long jiffies  ;
#line 12 "/usr/local/ddv/models/con2/include/ddverify/fixed_cdev.h"
struct cdev fixed_cdev[10]  ;
#line 13 "/usr/local/ddv/models/con2/include/ddverify/fixed_cdev.h"
int fixed_cdev_used  =    0;
#line 11 "/usr/local/ddv/models/con2/include/ddverify/cdev.h"
short number_cdev_registered  =    (short)0;
#line 22 "/usr/local/ddv/models/con2/include/ddverify/cdev.h"
struct ddv_cdev cdev_registered[10]  ;
#line 24
void call_cdev_functions(void) ;
#line 21 "/usr/local/ddv/models/con2/src/ddverify/cdev.c"
extern int ( /* missing proto */  __CPROVER_assume)() ;
#line 5 "/usr/local/ddv/models/con2/src/ddverify/cdev.c"
void call_cdev_functions(void) 
{ 
  int cdev_no ;
  int result ;
  loff_t loff_t_value ;
  int int_value ;
  unsigned int uint_value ;
  unsigned long ulong_value ;
  char char_value ;
  size_t size_t_value ;
  unsigned short tmp ;
  int tmp___0 ;
  unsigned short tmp___1 ;

  {
#line 16
  if ((int )number_cdev_registered == 0) {
#line 17
    return;
  }
#line 20
  tmp = nondet_ushort();
#line 20
  cdev_no = (int )tmp;
#line 21
  if (0 <= cdev_no) {
#line 21
    if (cdev_no < (int )number_cdev_registered) {
#line 21
      tmp___0 = 1;
    } else {
#line 21
      tmp___0 = 0;
    }
  } else {
#line 21
    tmp___0 = 0;
  }
#line 21
  __CPROVER_assume(tmp___0);
#line 23
  tmp___1 = nondet_ushort();
#line 23
  switch ((int )tmp___1) {
  case 0: 
#line 25
  if (((cdev_registered[cdev_no].cdevp)->ops)->llseek) {
#line 26
    loff_t_value = nondet_loff_t();
#line 27
    int_value = nondet_int();
#line 29
    (*(((cdev_registered[cdev_no].cdevp)->ops)->llseek))(& cdev_registered[cdev_no].filp,
                                                         loff_t_value, int_value);
  }
#line 33
  break;
  case 1: 
#line 35
  if (((cdev_registered[cdev_no].cdevp)->ops)->read) {
#line 36
    char_value = nondet_char();
#line 37
    size_t_value = nondet_size_t();
#line 39
    (*(((cdev_registered[cdev_no].cdevp)->ops)->read))(& cdev_registered[cdev_no].filp,
                                                       & char_value, size_t_value,
                                                       & loff_t_value);
  }
#line 44
  break;
  case 2: 
#line 47
  break;
  case 3: 
#line 49
  if (((cdev_registered[cdev_no].cdevp)->ops)->write) {
#line 50
    char_value = nondet_char();
#line 51
    size_t_value = nondet_size_t();
#line 53
    (*(((cdev_registered[cdev_no].cdevp)->ops)->write))(& cdev_registered[cdev_no].filp,
                                                        (char const   *)(& char_value),
                                                        size_t_value, & loff_t_value);
  }
#line 58
  break;
  case 4: 
#line 61
  break;
  case 5: 
#line 64
  break;
  case 6: 
#line 67
  break;
  case 7: 
#line 69
  if (((cdev_registered[cdev_no].cdevp)->ops)->ioctl) {
#line 70
    uint_value = nondet_uint();
#line 71
    ulong_value = nondet_ulong();
#line 73
    (*(((cdev_registered[cdev_no].cdevp)->ops)->ioctl))(& cdev_registered[cdev_no].inode,
                                                        & cdev_registered[cdev_no].filp,
                                                        uint_value, ulong_value);
  }
#line 79
  break;
  case 8: 
#line 82
  break;
  case 9: 
#line 85
  break;
  case 10: 
#line 88
  break;
  case 11: 
#line 90
  if (((cdev_registered[cdev_no].cdevp)->ops)->open) {
#line 90
    if (! cdev_registered[cdev_no].open) {
#line 92
      result = (*(((cdev_registered[cdev_no].cdevp)->ops)->open))(& cdev_registered[cdev_no].inode,
                                                                  & cdev_registered[cdev_no].filp);
#line 95
      if (! result) {
#line 96
        cdev_registered[cdev_no].open = 1;
      }
    }
  }
#line 99
  break;
  case 12: 
#line 102
  break;
  case 13: 
#line 104
  if (((cdev_registered[cdev_no].cdevp)->ops)->release) {
#line 104
    if (cdev_registered[cdev_no].open) {
#line 106
      result = (*(((cdev_registered[cdev_no].cdevp)->ops)->release))(& cdev_registered[cdev_no].inode,
                                                                     & cdev_registered[cdev_no].filp);
#line 109
      if (! result) {
#line 110
        cdev_registered[cdev_no].open = 0;
      }
    }
  }
#line 113
  break;
  case 14: 
#line 116
  break;
  case 15: 
#line 119
  break;
  case 16: 
#line 122
  break;
  case 17: 
#line 125
  break;
  case 18: 
#line 128
  break;
  case 19: 
#line 131
  break;
  case 20: 
#line 134
  break;
  case 21: 
#line 137
  break;
  case 22: 
#line 140
  break;
  case 23: 
#line 143
  break;
  case 24: 
#line 146
  break;
  case 25: 
#line 149
  break;
  case 26: 
#line 152
  break;
  default: 
#line 154
  break;
  }
#line 156
  return;
}
}
#line 1 "char_dev.o"
#pragma merger("0","/tmp/cil-LQVeGRW9.i","")
#line 8 "/usr/local/ddv/models/con2/include/linux/slab.h"
extern void kfree(void const   * ) ;
#line 195 "/usr/local/ddv/models/con2/include/linux/fs.h"
__inline int alloc_chrdev_region(dev_t *dev , unsigned int baseminor , unsigned int count ,
                                 char const   *name ) ;
#line 196
__inline int register_chrdev_region(dev_t from , unsigned int count , char const   *name ) ;
#line 199
__inline int register_chrdev(unsigned int major , char const   *name , struct file_operations *fops ) ;
#line 200
__inline int unregister_chrdev(unsigned int major , char const   *name ) ;
#line 11 "/usr/local/ddv/models/con2/include/linux/cdev.h"
__inline void cdev_init(struct cdev *cdev , struct file_operations *fops ) ;
#line 13
__inline struct cdev *cdev_alloc(void) ;
#line 17
__inline int cdev_add(struct cdev *p , dev_t dev , unsigned int count ) ;
#line 19
__inline void cdev_del(struct cdev *p ) ;
#line 9 "/usr/local/ddv/models/con2/src/linux/fs/char_dev.c"
__inline int alloc_chrdev_region(dev_t *dev , unsigned int baseminor , unsigned int count ,
                                 char const   *name ) 
{ 
  int major ;
  int return_value ;
  int tmp ;
  int tmp___0 ;
  unsigned int tmp___1 ;

  {
#line 12
  tmp = nondet_int();
#line 12
  return_value = tmp;
#line 13
  if (return_value == 0) {
#line 13
    tmp___0 = 1;
  } else
#line 13
  if (return_value == -1) {
#line 13
    tmp___0 = 1;
  } else {
#line 13
    tmp___0 = 0;
  }
#line 13
  __CPROVER_assume(tmp___0);
#line 15
  if (return_value == 0) {
#line 16
    tmp___1 = nondet_uint();
#line 16
    major = (int )tmp___1;
#line 17
    *dev = (unsigned int )(major << 20) | baseminor;
  }
#line 20
  return (return_value);
}
}
#line 23 "/usr/local/ddv/models/con2/src/linux/fs/char_dev.c"
__inline int register_chrdev_region(dev_t from , unsigned int count , char const   *name ) 
{ 
  int return_value ;
  int tmp ;
  int tmp___0 ;

  {
#line 25
  tmp = nondet_int();
#line 25
  return_value = tmp;
#line 26
  if (return_value == 0) {
#line 26
    tmp___0 = 1;
  } else
#line 26
  if (return_value == -1) {
#line 26
    tmp___0 = 1;
  } else {
#line 26
    tmp___0 = 0;
  }
#line 26
  __CPROVER_assume(tmp___0);
#line 28
  return (return_value);
}
}
#line 33 "/usr/local/ddv/models/con2/src/linux/fs/char_dev.c"
__inline int register_chrdev(unsigned int major , char const   *name , struct file_operations *fops ) 
{ 
  struct cdev *cdev ;
  int err ;
  int tmp ;

  {
#line 39
  tmp = register_chrdev_region((dev_t )0, 256U, name);
#line 39
  major = (unsigned int )tmp;
#line 41
  cdev = cdev_alloc();
#line 42
  cdev->owner = fops->owner;
#line 43
  cdev->ops = fops;
#line 45
  err = cdev_add(cdev, major << 20, 256U);
#line 47
  if (err) {
#line 48
    kfree((void const   *)cdev);
#line 49
    return (err);
  }
#line 52
  return ((int )major);
}
}
#line 55 "/usr/local/ddv/models/con2/src/linux/fs/char_dev.c"
__inline int unregister_chrdev(unsigned int major , char const   *name ) 
{ 


  {
#line 57
  return (0);
}
}
#line 60 "/usr/local/ddv/models/con2/src/linux/fs/char_dev.c"
__inline struct cdev *cdev_alloc(void) 
{ 
  int tmp ;

  {
#line 62
  if (fixed_cdev_used < 10) {
#line 63
    tmp = fixed_cdev_used;
#line 63
    fixed_cdev_used ++;
#line 63
    return (& fixed_cdev[tmp]);
  }
#line 65
  return ((struct cdev *)0);
}
}
#line 67 "/usr/local/ddv/models/con2/src/linux/fs/char_dev.c"
__inline void cdev_init(struct cdev *cdev , struct file_operations *fops ) 
{ 


  {
#line 69
  cdev->ops = fops;
#line 70
  return;
}
}
#line 72 "/usr/local/ddv/models/con2/src/linux/fs/char_dev.c"
__inline int cdev_add(struct cdev *p , dev_t dev , unsigned int count ) 
{ 
  int return_value ;
  int tmp ;
  int tmp___0 ;

  {
#line 74
  p->dev = dev;
#line 75
  p->count = count;
#line 77
  tmp = nondet_int();
#line 77
  return_value = tmp;
#line 78
  if (return_value == 0) {
#line 78
    tmp___0 = 1;
  } else
#line 78
  if (return_value == -1) {
#line 78
    tmp___0 = 1;
  } else {
#line 78
    tmp___0 = 0;
  }
#line 78
  __CPROVER_assume(tmp___0);
#line 80
  if (return_value == 0) {
#line 81
    if ((int )number_cdev_registered < 10) {
#line 83
      cdev_registered[number_cdev_registered].cdevp = p;
#line 84
      cdev_registered[number_cdev_registered].inode.i_rdev = dev;
#line 85
      cdev_registered[number_cdev_registered].inode.i_cdev = p;
#line 86
      cdev_registered[number_cdev_registered].open = 0;
#line 88
      number_cdev_registered = (short )((int )number_cdev_registered + 1);
    } else {
#line 90
      return (-1);
    }
  }
#line 94
  return (return_value);
}
}
#line 97 "/usr/local/ddv/models/con2/src/linux/fs/char_dev.c"
__inline void cdev_del(struct cdev *p ) 
{ 
  int i ;

  {
#line 101
  i = 0;
#line 101
  while (i < (int )number_cdev_registered) {
#line 102
    if ((unsigned long )cdev_registered[i].cdevp == (unsigned long )p) {
#line 103
      cdev_registered[i].cdevp = (struct cdev *)0;
#line 105
      return;
    }
#line 101
    i ++;
  }
#line 108
  return;
}
}
#line 1 "ddverify.o"
#pragma merger("0","/tmp/cil-jC2nOGMh.i","")
#line 45 "/usr/local/ddv/models/con2/include/ddverify/ddverify.h"
int call_ddv(void) ;
#line 39 "/usr/local/ddv/models/con2/include/ddverify/satabs.h"
extern void __CPROVER_atomic_begin() ;
#line 40
extern void __CPROVER_atomic_end() ;
#line 186 "/usr/local/ddv/models/con2/include/ddverify/pthread.h"
__inline extern int pthread_mutex_init(pthread_mutex_t *__mutex , pthread_mutexattr_t const   *__mutex_attr ) 
{ 
  pthread_mutex_t i ;

  {
#line 190
  i.locked = (_Bool)0;
#line 191
  *__mutex = i;
#line 192
  return (0);
}
}
#line 194 "/usr/local/ddv/models/con2/include/ddverify/pthread.h"
__inline extern int pthread_mutex_destroy(pthread_mutex_t *__mutex ) 
{ 


  {
#line 196
  return (0);
}
}
#line 203 "/usr/local/ddv/models/con2/include/ddverify/pthread.h"
__inline extern int pthread_mutex_lock(pthread_mutex_t *__mutex ) 
{ 


  {
#line 206
  __CPROVER_atomic_begin();
#line 207
  __CPROVER_assume(! __mutex->locked);
#line 208
  __mutex->locked = (_Bool)1;
#line 209
  __CPROVER_atomic_end();
#line 210
  return (0);
}
}
#line 216
extern int ( /* missing proto */  __CPROVER_assert)() ;
#line 213 "/usr/local/ddv/models/con2/include/ddverify/pthread.h"
__inline extern int pthread_mutex_unlock(pthread_mutex_t *__mutex ) 
{ 


  {
#line 216
  __CPROVER_assert((int )__mutex->locked, "pthread_mutex_unlock without lock");
#line 217
  __mutex->locked = (_Bool)0;
#line 218
  return (0);
}
}
#line 9 "/usr/local/ddv/models/con2/include/linux/spinlock.h"
void spin_lock_init(spinlock_t *lock ) ;
#line 12 "/usr/local/ddv/models/con2/include/ddverify/genhd.h"
short number_genhd_registered  =    (short)0;
#line 13 "/usr/local/ddv/models/con2/include/ddverify/genhd.h"
short number_fixed_genhd_used  =    (short)0;
#line 24 "/usr/local/ddv/models/con2/include/ddverify/genhd.h"
struct gendisk fixed_gendisk[10]  ;
#line 25 "/usr/local/ddv/models/con2/include/ddverify/genhd.h"
struct ddv_genhd genhd_registered[10]  ;
#line 14 "/usr/local/ddv/models/con2/include/ddverify/pci.h"
struct ddv_pci_driver registered_pci_driver  ;
#line 19
extern void call_pci_functions() ;
#line 14 "/usr/local/ddv/models/con2/include/ddverify/interrupt.h"
struct registered_irq registered_irq[16]  ;
#line 16
void call_interrupt_handler(void) ;
#line 8 "/usr/local/ddv/models/con2/include/ddverify/tasklet.h"
short number_tasklet_registered  =    (short)0;
#line 15 "/usr/local/ddv/models/con2/include/ddverify/tasklet.h"
struct ddv_tasklet tasklet_registered[10]  ;
#line 17
void call_tasklet_functions(void) ;
#line 8 "/usr/local/ddv/models/con2/include/ddverify/timer.h"
short number_timer_registered  =    (short)0;
#line 14 "/usr/local/ddv/models/con2/include/ddverify/timer.h"
struct ddv_timer timer_registered[5]  ;
#line 16
extern void call_timer_functions() ;
#line 8 "/usr/local/ddv/models/con2/include/ddverify/workqueue.h"
struct work_struct *shared_workqueue[10]  ;
#line 10
void call_shared_workqueue_functions(void) ;
#line 7 "/usr/local/ddv/models/con2/include/linux/smp_lock.h"
spinlock_t kernel_lock  ;
#line 15 "/usr/local/ddv/models/con2/src/ddverify/ddverify.c"
void init_kernel(void) 
{ 
  int i ;

  {
#line 19
  spin_lock_init(& kernel_lock);
#line 21
  i = 0;
#line 21
  while (i < 10) {
#line 22
    shared_workqueue[i] = (struct work_struct *)((void *)0);
#line 21
    i ++;
  }
#line 25
  i = 0;
#line 25
  while (i < 10) {
#line 26
    tasklet_registered[i].tasklet = (struct tasklet_struct *)((void *)0);
#line 27
    tasklet_registered[i].is_running = (unsigned short)0;
#line 25
    i ++;
  }
#line 29
  return;
}
}
#line 31 "/usr/local/ddv/models/con2/src/ddverify/ddverify.c"
static void *ddv_2(void *arg ) 
{ 
  unsigned short random ;

  {
#line 35
  while (1) {
#line 36
    random = nondet_ushort();
#line 38
    switch ((int )random) {
    case 1: 
#line 40
    current_execution_context = 2;
#line 41
    call_timer_functions();
#line 42
    current_execution_context = 1;
#line 43
    break;
    case 2: 
#line 46
    current_execution_context = 2;
#line 47
    call_interrupt_handler();
#line 48
    current_execution_context = 1;
#line 49
    break;
    case 3: 
#line 52
    current_execution_context = 1;
#line 53
    call_shared_workqueue_functions();
#line 54
    current_execution_context = 1;
#line 55
    break;
    case 4: 
#line 58
    current_execution_context = 2;
#line 59
    call_tasklet_functions();
#line 60
    current_execution_context = 1;
#line 61
    break;
    case 5: 
#line 64
    current_execution_context = 1;
#line 65
    call_pci_functions();
#line 66
    current_execution_context = 1;
#line 67
    break;
    default: 
#line 70
    break;
    }
#line 35
    if (! random) {
#line 35
      break;
    }
  }
#line 73
  return ((void *)0);
}
}
#line 75 "/usr/local/ddv/models/con2/src/ddverify/ddverify.c"
void ddv(void) 
{ 
  pthread_t___0 thread ;
  int tmp ;

  {
#line 81
  pthread_create((struct __pthread_t_struct *)(& thread), (struct __pthread_attr_t_struct  const  *)((void *)0),
                 & ddv_2, (void *)0);
#line 83
  while (1) {
#line 84
    current_execution_context = 1;
#line 86
    call_cdev_functions();
#line 83
    tmp = nondet_int();
#line 83
    if (! tmp) {
#line 83
      break;
    }
  }
#line 93
  return;
}
}
#line 95 "/usr/local/ddv/models/con2/src/ddverify/ddverify.c"
int call_ddv(void) 
{ 
  int err ;

  {
#line 99
  current_execution_context = 1;
#line 101
  init_kernel();
#line 103
  err = (*_ddv_module_init)();
#line 105
  if (err) {
#line 106
    return (-1);
  }
#line 110
  ddv();
#line 112
  current_execution_context = 1;
#line 113
  (*_ddv_module_exit)();
#line 115
  return (0);
}
}
#line 1 "genhd.o"
#pragma merger("0","/tmp/cil-GHMwZCgC.i","")
#line 9 "/usr/local/ddv/models/con2/include/ddverify/satabs.h"
extern void *malloc(size_t size ) ;
#line 207 "/usr/local/ddv/models/con2/include/linux/fs.h"
int register_blkdev(unsigned int major , char const   *name ) ;
#line 208
int unregister_blkdev(unsigned int major , char const   *name ) ;
#line 33 "/usr/local/ddv/models/con2/include/linux/genhd.h"
void add_disk(struct gendisk *disk ) ;
#line 35
void del_gendisk(struct gendisk *gp ) ;
#line 37
struct gendisk *alloc_disk(int minors ) ;
#line 6 "/usr/local/ddv/models/con2/src/linux/block/genhd.c"
int register_blkdev(unsigned int major , char const   *name ) 
{ 
  int result ;
  int tmp ;

  {
#line 8
  tmp = nondet_int();
#line 8
  result = tmp;
#line 14
  return (result);
}
}
#line 17 "/usr/local/ddv/models/con2/src/linux/block/genhd.c"
int unregister_blkdev(unsigned int major , char const   *name ) 
{ 


  {
#line 19
  return (0);
}
}
#line 22 "/usr/local/ddv/models/con2/src/linux/block/genhd.c"
struct gendisk *alloc_disk(int minors ) 
{ 
  struct gendisk *gd ;

  {
#line 26
  if ((int )number_fixed_genhd_used < 10) {
#line 27
    gd = & fixed_gendisk[number_fixed_genhd_used];
#line 28
    gd->minors = minors;
#line 30
    number_fixed_genhd_used = (short )((int )number_fixed_genhd_used + 1);
#line 32
    return (gd);
  } else {
#line 34
    return ((struct gendisk *)((void *)0));
  }
}
}
#line 38 "/usr/local/ddv/models/con2/src/linux/block/genhd.c"
void add_disk(struct gendisk *disk ) 
{ 
  void *tmp ;

  {
#line 40
  if ((int )number_genhd_registered < 10) {
#line 41
    genhd_registered[number_genhd_registered].gd = disk;
#line 42
    tmp = malloc((size_t )sizeof(struct block_device ));
#line 42
    genhd_registered[number_genhd_registered].inode.i_bdev = (struct block_device *)tmp;
#line 43
    (genhd_registered[number_genhd_registered].inode.i_bdev)->bd_disk = disk;
#line 45
    number_genhd_registered = (short )((int )number_genhd_registered + 1);
  }
#line 47
  return;
}
}
#line 49 "/usr/local/ddv/models/con2/src/linux/block/genhd.c"
void del_gendisk(struct gendisk *gp ) 
{ 
  int i ;

  {
#line 53
  i = 0;
#line 53
  while (i < (int )number_genhd_registered) {
#line 54
    if ((unsigned long )genhd_registered[i].gd == (unsigned long )gp) {
#line 55
      genhd_registered[i].gd = (struct gendisk *)((void *)0);
    }
#line 53
    i ++;
  }
#line 58
  return;
}
}
#line 1 "interrupt.o"
#pragma merger("0","/tmp/cil-EAS4KKqt.i","")
#line 10 "/usr/local/ddv/models/con2/src/ddverify/interrupt.c"
void call_interrupt_handler(void) 
{ 
  unsigned short i ;
  struct pt_regs regs ;
  int tmp ;

  {
#line 15
  tmp = nondet_int();
#line 15
  i = (unsigned short )tmp;
#line 16
  __CPROVER_assume((int )i < 16);
#line 18
  if (registered_irq[i].handler) {
#line 19
    (*(registered_irq[i].handler))((int )i, registered_irq[i].dev_id, & regs);
  }
#line 22
  return;
}
}
#line 1 "ioctl.o"
#pragma merger("0","/tmp/cil-c84HNub4.i","")
#line 1 "ll_rw_blk.o"
#pragma merger("0","/tmp/cil-GXDuQTXG.i","")
#line 192 "/usr/local/ddv/models/con2/include/linux/blkdev.h"
request_queue_t *blk_alloc_queue(gfp_t gfp_mask ) ;
#line 194
request_queue_t *blk_init_queue(request_fn_proc *rfn , spinlock_t *lock ) ;
#line 196
void blk_queue_make_request(request_queue_t *q , make_request_fn *mfn ) ;
#line 198
void blk_queue_hardsect_size(request_queue_t *q , unsigned short size ) ;
#line 200
void blk_cleanup_queue(request_queue_t *q ) ;
#line 220
void end_request(struct request *req , int uptodate ) ;
#line 6 "/usr/local/ddv/models/con2/include/ddverify/blkdev.h"
request_queue_t fixed_request_queue[10]  ;
#line 8 "/usr/local/ddv/models/con2/include/ddverify/blkdev.h"
int number_request_queue_used  =    0;
#line 7 "/usr/local/ddv/models/con2/src/linux/block/ll_rw_blk.c"
request_queue_t *get_fixed_request_queue(void) 
{ 
  int tmp ;

  {
#line 9
  if (number_request_queue_used < 10) {
#line 10
    tmp = number_request_queue_used;
#line 10
    number_request_queue_used ++;
#line 10
    return (& fixed_request_queue[tmp]);
  } else {
#line 12
    return ((request_queue_t *)((void *)0));
  }
}
}
#line 16 "/usr/local/ddv/models/con2/src/linux/block/ll_rw_blk.c"
request_queue_t *blk_init_queue(request_fn_proc *rfn , spinlock_t *lock ) 
{ 
  request_queue_t *queue ;
  int tmp ;

  {
#line 20
  tmp = nondet_int();
#line 20
  if (tmp) {
#line 21
    queue = get_fixed_request_queue();
#line 23
    queue->queue_lock = lock;
#line 24
    queue->request_fn = rfn;
#line 25
    queue->make_request_fn = (make_request_fn *)((void *)0);
#line 26
    queue->__ddv_queue_alive = 1;
#line 28
    return (queue);
  } else {
#line 30
    return ((request_queue_t *)((void *)0));
  }
}
}
#line 34 "/usr/local/ddv/models/con2/src/linux/block/ll_rw_blk.c"
request_queue_t *blk_alloc_queue(gfp_t gfp_mask ) 
{ 
  request_queue_t *queue ;
  int tmp ;

  {
#line 38
  tmp = nondet_int();
#line 38
  if (tmp) {
#line 39
    queue = get_fixed_request_queue();
#line 41
    queue->request_fn = (request_fn_proc *)((void *)0);
#line 42
    queue->make_request_fn = (make_request_fn *)((void *)0);
#line 43
    queue->__ddv_queue_alive = 1;
#line 45
    return (queue);
  } else {
#line 47
    return ((request_queue_t *)((void *)0));
  }
}
}
#line 51 "/usr/local/ddv/models/con2/src/linux/block/ll_rw_blk.c"
void blk_queue_make_request(request_queue_t *q , make_request_fn *mfn ) 
{ 


  {
#line 53
  q->make_request_fn = mfn;
#line 54
  return;
}
}
#line 56 "/usr/local/ddv/models/con2/src/linux/block/ll_rw_blk.c"
void end_request(struct request *req , int uptodate ) 
{ 
  int genhd_no ;

  {
#line 58
  genhd_no = ((req->rq_disk)->queue)->__ddv_genhd_no;
#line 60
  genhd_registered[genhd_no].requests_open = 0;
#line 61
  return;
}
}
#line 64 "/usr/local/ddv/models/con2/src/linux/block/ll_rw_blk.c"
void blk_queue_hardsect_size(request_queue_t *q , unsigned short size ) 
{ 


  {
#line 66
  q->hardsect_size = size;
#line 67
  return;
}
}
#line 69 "/usr/local/ddv/models/con2/src/linux/block/ll_rw_blk.c"
void blk_cleanup_queue(request_queue_t *q ) 
{ 


  {
#line 71
  q->__ddv_queue_alive = 0;
#line 72
  return;
}
}
#line 1 "__main.o"
#pragma merger("0","/tmp/cil-TuoyTfWx.i","")
#line 26 "/usr/local/ddv/models/con2/include/linux/timer.h"
void init_timer(struct timer_list *timer ) ;
#line 28
void add_timer(struct timer_list *timer ) ;
#line 29
int del_timer(struct timer_list *timer ) ;
#line 11 "/usr/local/ddv/models/con2/include/linux/spinlock.h"
void spin_lock_irqsave(spinlock_t *lock , unsigned long flags ) ;
#line 12
void spin_lock_irq(spinlock_t *lock ) ;
#line 13
void spin_lock_bh(spinlock_t *lock ) ;
#line 16
void spin_unlock_irqrestore(spinlock_t *lock , unsigned long flags ) ;
#line 17
void spin_unlock_irq(spinlock_t *lock ) ;
#line 18
void spin_unlock_bh(spinlock_t *lock ) ;
#line 9 "/usr/local/ddv/models/con2/include/asm/bitops.h"
extern int test_bit(int nr , void const   *addr ) ;
#line 10
extern void clear_bit(int nr , unsigned long volatile   *addr ) ;
#line 34 "/usr/local/ddv/models/con2/include/linux/kernel.h"
extern int printk(char const   *fmt  , ...) ;
#line 35
extern int sprintf(char *buf , char const   *fmt  , ...) ;
#line 50 "/usr/local/ddv/models/con2/include/linux/interrupt.h"
void tasklet_schedule(struct tasklet_struct *t ) ;
#line 63
extern void tasklet_kill(struct tasklet_struct *t ) ;
#line 65
void tasklet_init(struct tasklet_struct *t , void (*func)(unsigned long  ) , unsigned long data ) ;
#line 75
int request_irq(unsigned int irq , irqreturn_t (*handler)(int  , void * , struct pt_regs * ) ,
                unsigned long irqflags , char const   *devname , void *dev_id ) ;
#line 78
void free_irq(unsigned int irq , void *dev_id ) ;
#line 106 "/usr/local/ddv/models/con2/include/linux/bio.h"
extern void bio_endio(struct bio * , unsigned int  , int  ) ;
#line 96 "/usr/local/ddv/models/con2/include/linux/ioport.h"
extern struct resource *request_mem_region(unsigned long start , unsigned long len ,
                                           char const   *name ) ;
#line 98
extern void release_mem_region(unsigned long start , unsigned long len ) ;
#line 80 "/usr/local/ddv/models/con2/include/linux/device.h"
__inline static void *dev_get_drvdata(struct device *dev ) 
{ 


  {
#line 82
  return (dev->driver_data);
}
}
#line 85 "/usr/local/ddv/models/con2/include/linux/device.h"
__inline static void dev_set_drvdata(struct device *dev , void *data ) 
{ 


  {
#line 87
  dev->driver_data = data;
#line 88
  return;
}
}
#line 94 "/usr/local/ddv/models/con2/include/linux/pci.h"
__inline static void *pci_get_drvdata(struct pci_dev *pdev ) 
{ 
  void *tmp ;

  {
#line 96
  tmp = dev_get_drvdata(& pdev->dev);
#line 96
  return (tmp);
}
}
#line 99 "/usr/local/ddv/models/con2/include/linux/pci.h"
__inline static void pci_set_drvdata(struct pci_dev *pdev , void *data ) 
{ 


  {
#line 101
  dev_set_drvdata(& pdev->dev, data);
#line 102
  return;
}
}
#line 105
extern int pci_bus_read_config_word(struct pci_bus *bus , unsigned int devfn , int where ,
                                    u16 *val ) ;
#line 106
extern int pci_bus_read_config_dword(struct pci_bus *bus , unsigned int devfn , int where ,
                                     u32 *val ) ;
#line 107
extern int pci_bus_write_config_byte(struct pci_bus *bus , unsigned int devfn , int where ,
                                     u8 val ) ;
#line 108
extern int pci_bus_write_config_word(struct pci_bus *bus , unsigned int devfn , int where ,
                                     u16 val ) ;
#line 109
extern int pci_bus_write_config_dword(struct pci_bus *bus , unsigned int devfn , int where ,
                                      u32 val ) ;
#line 115 "/usr/local/ddv/models/con2/include/linux/pci.h"
__inline static int pci_read_config_word(struct pci_dev *dev , int where , u16 *val ) 
{ 
  int tmp ;

  {
#line 117
  tmp = pci_bus_read_config_word(dev->bus, dev->devfn, where, val);
#line 117
  return (tmp);
}
}
#line 119 "/usr/local/ddv/models/con2/include/linux/pci.h"
__inline static int pci_read_config_dword(struct pci_dev *dev , int where , u32 *val ) 
{ 
  int tmp ;

  {
#line 121
  tmp = pci_bus_read_config_dword(dev->bus, dev->devfn, where, val);
#line 121
  return (tmp);
}
}
#line 123 "/usr/local/ddv/models/con2/include/linux/pci.h"
__inline static int pci_write_config_byte(struct pci_dev *dev , int where , u8 val ) 
{ 
  int tmp ;

  {
#line 125
  tmp = pci_bus_write_config_byte(dev->bus, dev->devfn, where, val);
#line 125
  return (tmp);
}
}
#line 127 "/usr/local/ddv/models/con2/include/linux/pci.h"
__inline static int pci_write_config_word(struct pci_dev *dev , int where , u16 val ) 
{ 
  int tmp ;

  {
#line 129
  tmp = pci_bus_write_config_word(dev->bus, dev->devfn, where, val);
#line 129
  return (tmp);
}
}
#line 131 "/usr/local/ddv/models/con2/include/linux/pci.h"
__inline static int pci_write_config_dword(struct pci_dev *dev , int where , u32 val ) 
{ 
  int tmp ;

  {
#line 133
  tmp = pci_bus_write_config_dword(dev->bus, dev->devfn, where, val);
#line 133
  return (tmp);
}
}
#line 136
extern int pci_set_dma_mask(struct pci_dev *dev , u64 mask ) ;
#line 137
extern void pci_set_master(struct pci_dev *dev ) ;
#line 141
int pci_register_driver(struct pci_driver *driver ) ;
#line 143
void pci_unregister_driver(struct pci_driver *driver ) ;
#line 145
int pci_enable_device(struct pci_dev *dev ) ;
#line 9 "/usr/local/ddv/models/con2/include/asm/io.h"
extern void *ioremap_nocache(unsigned long offset , unsigned long size ) ;
#line 10
extern void iounmap(void *addr ) ;
#line 60
extern unsigned char readb(void const   * ) ;
#line 62
extern unsigned int readl(void const   * ) ;
#line 65
extern void writeb(unsigned char  , void * ) ;
#line 67
extern void writel(unsigned int  , void * ) ;
#line 7 "/usr/local/ddv/models/con2/include/asm-generic/pci-dma-compat.h"
extern void *pci_alloc_consistent(struct pci_dev *hwdev , size_t size , dma_addr_t *dma_handle ) ;
#line 10
extern void pci_free_consistent(struct pci_dev *hwdev , size_t size , void *vaddr ,
                                dma_addr_t dma_handle ) ;
#line 16
extern dma_addr_t pci_map_page(struct pci_dev *hwdev , struct page *page , unsigned long offset ,
                               size_t size , int direction ) ;
#line 18
extern void pci_unmap_page(struct pci_dev *hwdev , dma_addr_t dma_address , size_t size ,
                           int direction ) ;
#line 76 "umem.c"
int debug  ;
#line 84 "umem.c"
char _ddv_module_param_debug[14]  = 
#line 84
  {      (char )'D',      (char )'e',      (char )'b',      (char )'u', 
        (char )'g',      (char )' ',      (char )'b',      (char )'i', 
        (char )'t',      (char )'m',      (char )'a',      (char )'s', 
        (char )'k',      (char )'\000'};
#line 86 "umem.c"
int pci_read_cmd  =    12;
#line 88 "umem.c"
char _ddv_module_param_pci_read_cmd[17]  = 
#line 88
  {      (char )'P',      (char )'C',      (char )'I',      (char )' ', 
        (char )'r',      (char )'e',      (char )'a',      (char )'d', 
        (char )' ',      (char )'c',      (char )'o',      (char )'m', 
        (char )'m',      (char )'a',      (char )'n',      (char )'d', 
        (char )'\000'};
#line 90 "umem.c"
int pci_write_cmd  =    15;
#line 92 "umem.c"
char _ddv_module_param_pci_write_cmd[18]  = 
#line 92
  {      (char )'P',      (char )'C',      (char )'I',      (char )' ', 
        (char )'w',      (char )'r',      (char )'i',      (char )'t', 
        (char )'e',      (char )' ',      (char )'c',      (char )'o', 
        (char )'m',      (char )'m',      (char )'a',      (char )'n', 
        (char )'d',      (char )'\000'};
#line 94 "umem.c"
int pci_cmds  ;
#line 96 "umem.c"
int major_nr  ;
#line 39 "/usr/local/ddv/models/con2/include/linux/genhd.h"
extern void put_disk(struct gendisk *disk ) ;
#line 44
extern void set_capacity(struct gendisk *disk , sector_t size ) ;
#line 206 "/usr/local/ddv/models/con2/include/linux/blkdev.h"
extern void blk_plug_device(request_queue_t * ) ;
#line 208
extern int blk_remove_plug(request_queue_t * ) ;
#line 152 "umem.c"
struct cardinfo cards[4]  ;
#line 153
struct block_device_operations mm_fops ;
#line 154 "umem.c"
struct timer_list battery_timer  ;
#line 156 "umem.c"
int num_cards  =    0;
#line 158 "umem.c"
struct gendisk *mm_gendisk[4]  ;
#line 160
void check_batteries(struct cardinfo *card ) ;
#line 167 "umem.c"
int get_userbit(struct cardinfo *card , int bit ) 
{ 
  unsigned char led ;

  {
#line 171
  led = readb((void const   *)(card->csr_remap + 8));
#line 172
  return ((int )led & bit);
}
}
#line 179 "umem.c"
int set_userbit(struct cardinfo *card , int bit , unsigned char state ) 
{ 
  unsigned char led ;

  {
#line 183
  led = readb((void const   *)(card->csr_remap + 8));
#line 184
  if (state) {
#line 185
    led = (unsigned char )((int )led | bit);
  } else {
#line 187
    led = (unsigned char )((int )led & ~ bit);
  }
#line 188
  writeb(led, (void *)(card->csr_remap + 8));
#line 190
  return (0);
}
}
#line 200 "umem.c"
void set_led(struct cardinfo *card , int shift , unsigned char state ) 
{ 
  unsigned char led ;

  {
#line 204
  led = readb((void const   *)(card->csr_remap + 8));
#line 205
  if ((int )state == 255) {
#line 206
    led = (unsigned char )((int )led ^ (1 << shift));
  } else {
#line 208
    led = (unsigned char )((int )led & ~ (3 << shift));
#line 209
    led = (unsigned char )((int )led | ((int )state << shift));
  }
#line 211
  writeb(led, (void *)(card->csr_remap + 8));
#line 213
  return;
}
}
#line 242 "umem.c"
void dump_dmastat(struct cardinfo *card , unsigned int dmastat ) 
{ 


  {
#line 244
  printk("<7>MM%d*: DMAstat - ", card->card_number);
#line 245
  if (dmastat & 2048U) {
#line 246
    printk("ANY_ERR ");
  }
#line 247
  if (dmastat & 4096U) {
#line 248
    printk("MBE_ERR ");
  }
#line 249
  if (dmastat & 8192U) {
#line 250
    printk("PARITY_ERR_REP ");
  }
#line 251
  if (dmastat & 16384U) {
#line 252
    printk("PARITY_ERR_DET ");
  }
#line 253
  if (dmastat & 32768U) {
#line 254
    printk("SYSTEM_ERR_SIG ");
  }
#line 255
  if (dmastat & 65536U) {
#line 256
    printk("TARGET_ABT ");
  }
#line 257
  if (dmastat & 131072U) {
#line 258
    printk("MASTER_ABT ");
  }
#line 259
  if (dmastat & 524288U) {
#line 260
    printk("CHAIN_COMPLETE ");
  }
#line 261
  if (dmastat & 262144U) {
#line 262
    printk("DMA_COMPLETE ");
  }
#line 263
  printk("\n");
#line 264
  return;
}
}
#line 287 "umem.c"
void mm_start_io(struct cardinfo *card ) 
{ 
  struct mm_dma_desc *desc ;
  struct mm_page *page ;
  int offset ;

  {
#line 298
  page = & card->mm_pages[card->Active];
#line 299
  while (1) {
#line 299
    break;
  }
#line 300
  desc = page->desc + (page->cnt - 1);
#line 302
  desc->control_bits |= 64U;
#line 303
  desc->control_bits &= 4294967291U;
#line 304
  desc->sem_control_bits = (__le64 )desc->control_bits;
#line 307
  if (debug & 1) {
#line 308
    set_led(card, 2, (unsigned char)1);
  }
#line 310
  desc = page->desc + page->headcnt;
#line 311
  writel(0U, (void *)(card->csr_remap + 64));
#line 312
  writel(0U, (void *)((card->csr_remap + 64) + 4));
#line 314
  writel(0U, (void *)(card->csr_remap + 72));
#line 315
  writel(0U, (void *)((card->csr_remap + 72) + 4));
#line 317
  writel(0U, (void *)(card->csr_remap + 80));
#line 318
  writel(0U, (void *)((card->csr_remap + 80) + 4));
#line 320
  writel(0U, (void *)(card->csr_remap + 96));
#line 321
  writel(0U, (void *)((card->csr_remap + 96) + 4));
#line 323
  offset = (int )((char *)desc - (char *)page->desc);
#line 324
  writel((page->page_dma + (dma_addr_t )offset) & 4294967295U, (void *)(card->csr_remap + 88));
#line 328
  writel((unsigned int )((u64 )page->page_dma >> 32), (void *)((card->csr_remap + 88) + 4));
#line 332
  writel((unsigned int )(5 | pci_cmds), (void *)(card->csr_remap + 104));
#line 334
  return;
}
}
#line 336
int add_bio(struct cardinfo *card ) ;
#line 338 "umem.c"
void activate(struct cardinfo *card ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 346
  while (1) {
#line 347
    while (1) {
#line 347
      tmp = add_bio(card);
#line 347
      if (! tmp) {
#line 347
        break;
      }
    }
#line 350
    if (card->Active == -1) {
#line 350
      if (card->mm_pages[card->Ready].cnt > 0) {
#line 352
        card->Active = card->Ready;
#line 353
        card->Ready = 1 - card->Ready;
#line 354
        mm_start_io(card);
      }
    }
#line 346
    if (card->Active == -1) {
#line 346
      tmp___0 = add_bio(card);
#line 346
      if (! tmp___0) {
#line 346
        break;
      }
    } else {
#line 346
      break;
    }
  }
#line 358
  return;
}
}
#line 360 "umem.c"
__inline void reset_page(struct mm_page *page ) 
{ 


  {
#line 362
  page->cnt = 0;
#line 363
  page->headcnt = 0;
#line 364
  page->bio = (struct bio *)((void *)0);
#line 365
  page->biotail = & page->bio;
#line 366
  return;
}
}
#line 368 "umem.c"
void mm_unplug_device(request_queue_t *q ) 
{ 
  struct cardinfo *card ;
  unsigned long flags ;
  int tmp ;

  {
#line 370
  card = (struct cardinfo *)q->queuedata;
#line 373
  spin_lock_irqsave(& card->lock, flags);
#line 374
  tmp = blk_remove_plug(q);
#line 374
  if (tmp) {
#line 375
    activate(card);
  }
#line 376
  spin_unlock_irqrestore(& card->lock, flags);
#line 377
  return;
}
}
#line 384 "umem.c"
int add_bio(struct cardinfo *card ) 
{ 
  struct mm_page *p ;
  struct mm_dma_desc *desc ;
  dma_addr_t dma_handle ;
  int offset ;
  struct bio *bio ;
  int rw ;
  int len ;
  int tmp ;
  u32 tmp___0 ;

  {
#line 394
  bio = card->currentbio;
#line 395
  if (! bio) {
#line 395
    if (card->bio) {
#line 396
      card->currentbio = card->bio;
#line 397
      card->bio = (card->bio)->bi_next;
#line 398
      if ((unsigned long )card->bio == (unsigned long )((void *)0)) {
#line 399
        card->biotail = & card->bio;
      }
#line 400
      (card->currentbio)->bi_next = (struct bio *)((void *)0);
#line 401
      return (1);
    }
  }
#line 403
  if (! bio) {
#line 404
    return (0);
  }
#line 406
  rw = (int )(bio->bi_rw & 3UL);
#line 407
  if ((unsigned long )card->mm_pages[card->Ready].cnt >= ((1UL << 12) * 2UL) / sizeof(struct mm_dma_desc )) {
#line 408
    return (0);
  }
#line 410
  len = (int )(bio->bi_io_vec + bio->bi_idx)->bv_len;
#line 411
  if (rw == 0) {
#line 411
    tmp = 2;
  } else {
#line 411
    tmp = 1;
  }
#line 411
  dma_handle = pci_map_page(card->dev, (bio->bi_io_vec + bio->bi_idx)->bv_page, (unsigned long )(bio->bi_io_vec + bio->bi_idx)->bv_offset,
                            (size_t )len, tmp);
#line 418
  p = & card->mm_pages[card->Ready];
#line 419
  desc = p->desc + p->cnt;
#line 420
  (p->cnt) ++;
#line 421
  if ((unsigned long )p->biotail != (unsigned long )(& bio->bi_next)) {
#line 422
    *(p->biotail) = bio;
#line 423
    p->biotail = & bio->bi_next;
#line 424
    bio->bi_next = (struct bio *)((void *)0);
  }
#line 427
  desc->data_dma_handle = dma_handle;
#line 429
  desc->pci_addr = (u64 )desc->data_dma_handle;
#line 430
  desc->local_addr = (__le64 )(bio->bi_sector << 9);
#line 431
  desc->transfer_size = (__le32 )len;
#line 432
  offset = (int )((char *)(& desc->sem_control_bits) - (char *)p->desc);
#line 433
  desc->sem_addr = (u64 )(p->page_dma + (dma_addr_t )offset);
#line 434
  tmp___0 = (u32 )0;
#line 434
  desc->zero2 = tmp___0;
#line 434
  desc->zero1 = tmp___0;
#line 435
  offset = (int )((char *)(desc + 1) - (char *)p->desc);
#line 436
  desc->next_desc_addr = (__le64 )(p->page_dma + (dma_addr_t )offset);
#line 437
  desc->control_bits = (__le32 )(405 | pci_cmds);
#line 442
  if (rw == 1) {
#line 443
    desc->control_bits |= 2U;
  }
#line 444
  desc->sem_control_bits = (__le64 )desc->control_bits;
#line 446
  bio->bi_sector += (sector_t )(len >> 9);
#line 447
  bio->bi_size -= (unsigned int )len;
#line 448
  bio->bi_idx = (unsigned short )((int )bio->bi_idx + 1);
#line 449
  if ((int )bio->bi_idx >= (int )bio->bi_vcnt) {
#line 450
    card->currentbio = (struct bio *)((void *)0);
  }
#line 452
  return (1);
}
}
#line 455 "umem.c"
void process_page(unsigned long data ) 
{ 
  struct mm_page *page ;
  struct bio *return_bio ;
  struct cardinfo *card ;
  unsigned int dma_status ;
  struct bio *bio ;
  struct mm_dma_desc *desc ;
  int control ;
  int last ;
  int idx ;
  int tmp ;
  int tmp___0 ;
  struct bio *bio___0 ;

  {
#line 464
  return_bio = (struct bio *)((void *)0);
#line 465
  card = (struct cardinfo *)data;
#line 466
  dma_status = card->dma_status;
#line 468
  spin_lock_bh(& card->lock);
#line 469
  if (card->Active < 0) {
#line 470
    goto out_unlock;
  }
#line 471
  page = & card->mm_pages[card->Active];
#line 473
  while (page->headcnt < page->cnt) {
#line 474
    bio = page->bio;
#line 475
    desc = page->desc + page->headcnt;
#line 476
    control = (int )desc->sem_control_bits;
#line 477
    last = 0;
#line 480
    if (! (control & 262144)) {
#line 481
      control = (int )dma_status;
#line 482
      last = 1;
    }
#line 484
    (page->headcnt) ++;
#line 485
    idx = (int )bio->bi_phys_segments;
#line 486
    bio->bi_phys_segments = (unsigned short )((int )bio->bi_phys_segments + 1);
#line 487
    if ((int )bio->bi_phys_segments >= (int )bio->bi_vcnt) {
#line 488
      page->bio = bio->bi_next;
    }
#line 490
    if (control & 2) {
#line 490
      tmp = 1;
    } else {
#line 490
      tmp = 2;
    }
#line 490
    pci_unmap_page(card->dev, desc->data_dma_handle, (bio->bi_io_vec + idx)->bv_len,
                   tmp);
#line 494
    if (control & 249856) {
#line 496
      clear_bit(0, (unsigned long volatile   *)(& bio->bi_flags));
#line 497
      printk("<4>MM%d: I/O error on sector %d/%d\n", card->card_number, desc->local_addr >> 9,
             desc->transfer_size);
#line 501
      dump_dmastat(card, (unsigned int )control);
    } else {
#line 502
      tmp___0 = test_bit(0, (void const   *)(& bio->bi_rw));
#line 502
      if (tmp___0) {
#line 502
        if (desc->local_addr >> 9 == (__le64 )card->init_size) {
#line 504
          card->init_size += desc->transfer_size >> 9;
#line 505
          if (card->init_size >> 1 >= card->mm_size) {
#line 506
            printk("<6>MM%d: memory now initialised\n", card->card_number);
#line 508
            set_userbit(card, 1, (unsigned char)1);
          }
        }
      }
    }
#line 511
    if ((unsigned long )bio != (unsigned long )page->bio) {
#line 512
      bio->bi_next = return_bio;
#line 513
      return_bio = bio;
    }
#line 516
    if (last) {
#line 516
      break;
    }
  }
#line 519
  if (debug & 1) {
#line 520
    set_led(card, 2, (unsigned char)0);
  }
#line 522
  if (card->check_batteries) {
#line 523
    card->check_batteries = 0;
#line 524
    check_batteries(card);
  }
#line 526
  if (page->headcnt >= page->cnt) {
#line 527
    reset_page(page);
#line 528
    card->Active = -1;
#line 529
    activate(card);
  } else {
#line 532
    while (1) {
#line 532
      break;
    }
#line 533
    mm_start_io(card);
  }
  out_unlock: 
#line 536
  spin_unlock_bh(& card->lock);
#line 538
  while (return_bio) {
#line 539
    bio___0 = return_bio;
#line 541
    return_bio = bio___0->bi_next;
#line 542
    bio___0->bi_next = (struct bio *)((void *)0);
#line 543
    bio_endio(bio___0, bio___0->bi_size, 0);
  }
#line 545
  return;
}
}
#line 552 "umem.c"
int mm_make_request(request_queue_t *q , struct bio *bio ) 
{ 
  struct cardinfo *card ;

  {
#line 554
  card = (struct cardinfo *)q->queuedata;
#line 555
  while (1) {
#line 555
    break;
  }
#line 558
  bio->bi_phys_segments = bio->bi_idx;
#line 559
  spin_lock_irq(& card->lock);
#line 560
  *(card->biotail) = bio;
#line 561
  bio->bi_next = (struct bio *)((void *)0);
#line 562
  card->biotail = & bio->bi_next;
#line 563
  blk_plug_device(q);
#line 564
  spin_unlock_irq(& card->lock);
#line 566
  return (0);
}
}
#line 574 "umem.c"
irqreturn_t mm_interrupt(int irq , void *__card ) 
{ 
  struct cardinfo *card ;
  unsigned int dma_status ;
  unsigned short cfg_status ;
  unsigned int data_log1 ;
  unsigned int data_log2 ;
  unsigned int addr_log1 ;
  unsigned int addr_log2 ;
  unsigned char stat ;
  unsigned char count ;
  unsigned char syndrome ;
  unsigned char check ;
  unsigned char tmp ;

  {
#line 576
  card = (struct cardinfo *)__card;
#line 582
  dma_status = readl((void const   *)(card->csr_remap + 104));
#line 584
  if (! (dma_status & 776192U)) {
#line 586
    return (0);
  }
#line 590
  if (card->flags & 2) {
#line 591
    writel(786432U, (void *)(card->csr_remap + 104));
  } else {
#line 594
    writeb((unsigned char )(786432 >> 16), (void *)((card->csr_remap + 104) + 2));
  }
#line 598
  if (dma_status & 2048U) {
#line 603
    stat = readb((void const   *)(card->csr_remap + 14));
#line 605
    data_log1 = readl((void const   *)(card->csr_remap + 32));
#line 606
    data_log2 = readl((void const   *)((card->csr_remap + 32) + 4));
#line 607
    addr_log1 = readl((void const   *)(card->csr_remap + 40));
#line 608
    tmp = readb((void const   *)((card->csr_remap + 40) + 4));
#line 608
    addr_log2 = (unsigned int )tmp;
#line 610
    count = readb((void const   *)(card->csr_remap + 61));
#line 611
    syndrome = readb((void const   *)(card->csr_remap + 62));
#line 612
    check = readb((void const   *)(card->csr_remap + 63));
#line 614
    dump_dmastat(card, dma_status);
#line 616
    if ((int )stat & 1) {
#line 617
      printk("<3>MM%d*: Memory access error detected (err count %d)\n", card->card_number,
             (int )count);
    }
#line 619
    if ((int )stat & 2) {
#line 620
      printk("<3>MM%d*: Multi-bit EDC error\n", card->card_number);
    }
#line 623
    printk("<3>MM%d*: Fault Address 0x%02x%08x, Fault Data 0x%08x%08x\n", card->card_number,
           addr_log2, addr_log1, data_log2, data_log1);
#line 625
    printk("<3>MM%d*: Fault Check 0x%02x, Fault Syndrome 0x%02x\n", card->card_number,
           (int )check, (int )syndrome);
#line 628
    writeb((unsigned char)0, (void *)(card->csr_remap + 61));
  }
#line 631
  if (dma_status & 8192U) {
#line 632
    printk("<3>MM%d*: PARITY ERROR REPORTED\n", card->card_number);
#line 633
    pci_read_config_word(card->dev, 6, & cfg_status);
#line 634
    pci_write_config_word(card->dev, 6, cfg_status);
  }
#line 637
  if (dma_status & 16384U) {
#line 638
    printk("<3>MM%d*: PARITY ERROR DETECTED\n", card->card_number);
#line 639
    pci_read_config_word(card->dev, 6, & cfg_status);
#line 640
    pci_write_config_word(card->dev, 6, cfg_status);
  }
#line 643
  if (dma_status & 32768U) {
#line 644
    printk("<3>MM%d*: SYSTEM ERROR\n", card->card_number);
#line 645
    pci_read_config_word(card->dev, 6, & cfg_status);
#line 646
    pci_write_config_word(card->dev, 6, cfg_status);
  }
#line 649
  if (dma_status & 65536U) {
#line 650
    printk("<3>MM%d*: TARGET ABORT\n", card->card_number);
#line 651
    pci_read_config_word(card->dev, 6, & cfg_status);
#line 652
    pci_write_config_word(card->dev, 6, cfg_status);
  }
#line 655
  if (dma_status & 131072U) {
#line 656
    printk("<3>MM%d*: MASTER ABORT\n", card->card_number);
#line 657
    pci_read_config_word(card->dev, 6, & cfg_status);
#line 658
    pci_write_config_word(card->dev, 6, cfg_status);
  }
#line 662
  card->dma_status = dma_status;
#line 663
  tasklet_schedule(& card->tasklet);
#line 667
  return (1);
}
}
#line 680 "umem.c"
void set_fault_to_battery_status(struct cardinfo *card ) 
{ 


  {
#line 682
  if (card->battery[0].good) {
#line 682
    if (card->battery[1].good) {
#line 683
      set_led(card, 4, (unsigned char)0);
    } else {
#line 682
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 684
  if (card->battery[0].warned) {
#line 685
    set_led(card, 4, (unsigned char)1);
  } else
#line 684
  if (card->battery[1].warned) {
#line 685
    set_led(card, 4, (unsigned char)1);
  } else
#line 686
  if (! card->battery[0].good) {
#line 686
    if (! card->battery[1].good) {
#line 687
      set_led(card, 4, (unsigned char)3);
    } else {
#line 689
      set_led(card, 4, (unsigned char)2);
    }
  } else {
#line 689
    set_led(card, 4, (unsigned char)2);
  }
#line 690
  return;
}
}
#line 692
void init_battery_timer(void) ;
#line 700 "umem.c"
int check_battery(struct cardinfo *card , int battery , int status ) 
{ 


  {
#line 702
  if (status != card->battery[battery].good) {
#line 703
    card->battery[battery].good = ! card->battery[battery].good;
#line 704
    card->battery[battery].last_change = jiffies;
#line 706
    if (card->battery[battery].good) {
#line 707
      printk("<3>MM%d: Battery %d now good\n", card->card_number, battery + 1);
#line 709
      card->battery[battery].warned = 0;
    } else {
#line 711
      printk("<3>MM%d: Battery %d now FAILED\n", card->card_number, battery + 1);
    }
#line 714
    return (1);
  } else
#line 715
  if (! card->battery[battery].good) {
#line 715
    if (! card->battery[battery].warned) {
#line 715
      if ((long )jiffies - (long )(card->battery[battery].last_change + 1800000UL) >= 0L) {
#line 719
        printk("<3>MM%d: Battery %d still FAILED after 5 hours\n", card->card_number,
               battery + 1);
#line 721
        card->battery[battery].warned = 1;
#line 723
        return (1);
      }
    }
  }
#line 726
  return (0);
}
}
#line 733 "umem.c"
void check_batteries(struct cardinfo *card ) 
{ 
  unsigned char status ;
  int ret1 ;
  int ret2 ;
  char const   *tmp ;
  char const   *tmp___0 ;

  {
#line 742
  status = readb((void const   *)(card->csr_remap + 4));
#line 743
  if (debug & 2) {
#line 744
    if ((int )status & 8) {
#line 744
      tmp = "FAILURE";
    } else {
#line 744
      tmp = "OK";
    }
#line 744
    if ((int )status & 2) {
#line 744
      tmp___0 = "FAILURE";
    } else {
#line 744
      tmp___0 = "OK";
    }
#line 744
    printk("<7>MM%d: checking battery status, 1 = %s, 2 = %s\n", card->card_number,
           tmp___0, tmp);
  }
#line 749
  ret1 = check_battery(card, 0, ! ((int )status & 2));
#line 750
  ret2 = check_battery(card, 1, ! ((int )status & 8));
#line 752
  if (ret1) {
#line 753
    set_fault_to_battery_status(card);
  } else
#line 752
  if (ret2) {
#line 753
    set_fault_to_battery_status(card);
  }
#line 754
  return;
}
}
#line 756 "umem.c"
void check_all_batteries(unsigned long ptr ) 
{ 
  int i ;
  struct cardinfo *card ;

  {
#line 760
  i = 0;
#line 760
  while (i < num_cards) {
#line 761
    if (! (cards[i].flags & 8)) {
#line 762
      card = & cards[i];
#line 763
      spin_lock_bh(& card->lock);
#line 764
      if (card->Active >= 0) {
#line 765
        card->check_batteries = 1;
      } else {
#line 767
        check_batteries(card);
      }
#line 768
      spin_unlock_bh(& card->lock);
    }
#line 760
    i ++;
  }
#line 771
  init_battery_timer();
#line 772
  return;
}
}
#line 778 "umem.c"
void init_battery_timer(void) 
{ 


  {
#line 780
  init_timer(& battery_timer);
#line 781
  battery_timer.function = & check_all_batteries;
#line 782
  battery_timer.expires = jiffies + 6000UL;
#line 783
  add_timer(& battery_timer);
#line 784
  return;
}
}
#line 790 "umem.c"
void del_battery_timer(void) 
{ 


  {
#line 792
  del_timer(& battery_timer);
#line 793
  return;
}
}
#line 807 "umem.c"
int mm_revalidate(struct gendisk *disk ) 
{ 
  struct cardinfo *card ;

  {
#line 809
  card = (struct cardinfo *)disk->private_data;
#line 810
  set_capacity(disk, (sector_t )(card->mm_size << 1));
#line 812
  return (0);
}
}
#line 815 "umem.c"
int mm_getgeo(struct block_device *bdev , struct hd_geometry *geo ) 
{ 
  struct cardinfo *card ;
  int size ;

  {
#line 817
  card = (struct cardinfo *)(bdev->bd_disk)->private_data;
#line 818
  size = (int )(card->mm_size * 2U);
#line 825
  geo->heads = (unsigned char)64;
#line 826
  geo->sectors = (unsigned char)32;
#line 827
  geo->cylinders = (unsigned short )(size / ((int )geo->heads * (int )geo->sectors));
#line 828
  return (0);
}
}
#line 837 "umem.c"
int mm_check_change(struct gendisk *disk ) 
{ 


  {
#line 840
  return (0);
}
}
#line 847 "umem.c"
struct block_device_operations mm_fops  = 
#line 847
     {(int (*)(struct inode * , struct file * ))0, (int (*)(struct inode * , struct file * ))0,
    (int (*)(struct inode * , struct file * , unsigned int  , unsigned long  ))0,
    (long (*)(struct file * , unsigned int  , unsigned long  ))0, (long (*)(struct file * ,
                                                                            unsigned int  ,
                                                                            unsigned long  ))0,
    (int (*)(struct block_device * , sector_t  , unsigned long * ))0, & mm_check_change,
    & mm_revalidate, & mm_getgeo, (struct module *)0};
#line 858 "umem.c"
int mm_pci_probe(struct pci_dev *dev , struct pci_device_id  const  *id ) 
{ 
  int ret ;
  struct cardinfo *card ;
  unsigned char mem_present ;
  unsigned char batt_status ;
  unsigned int saved_bar ;
  unsigned int data ;
  int magic_number ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  struct resource *tmp___2 ;
  void *tmp___3 ;
  unsigned char tmp___4 ;
  void *tmp___5 ;
  void *tmp___6 ;
  unsigned long tmp___7 ;
  char const   *tmp___8 ;
  char const   *tmp___9 ;
  char const   *tmp___10 ;
  char const   *tmp___11 ;
  int tmp___12 ;
  unsigned short cfg_command ;
  int tmp___13 ;

  {
#line 860
  ret = -19;
#line 861
  card = & cards[num_cards];
#line 867
  tmp = pci_enable_device(dev);
#line 867
  if (tmp < 0) {
#line 868
    return (-19);
  }
#line 870
  pci_write_config_byte(dev, 13, (u8 )248);
#line 871
  pci_set_master(dev);
#line 873
  card->dev = dev;
#line 874
  card->card_number = num_cards;
#line 876
  card->csr_base = dev->resource[0].start;
#line 877
  if (dev->resource[0].start == 0UL) {
#line 877
    if (dev->resource[0].end == dev->resource[0].start) {
#line 877
      card->csr_len = 0UL;
    } else {
#line 877
      card->csr_len = (dev->resource[0].end - dev->resource[0].start) + 1UL;
    }
  } else {
#line 877
    card->csr_len = (dev->resource[0].end - dev->resource[0].start) + 1UL;
  }
#line 883
  printk("<6>Micro Memory(tm) controller #%d found at %02x:%02x (PCI Mem Module (Battery Backup))\n",
         card->card_number, (int )(dev->bus)->number, dev->devfn);
#line 886
  tmp___0 = pci_set_dma_mask(dev, 0xffffffffffffffffULL);
#line 886
  if (tmp___0) {
#line 886
    tmp___1 = pci_set_dma_mask(dev, 4294967295ULL);
#line 886
    if (tmp___1) {
#line 888
      printk("<4>MM%d: NO suitable DMA found\n", num_cards);
#line 889
      return (-12);
    }
  }
#line 891
  tmp___2 = request_mem_region(card->csr_base, card->csr_len, "Micro Memory");
#line 891
  if (! tmp___2) {
#line 892
    printk("<3>MM%d: Unable to request memory region\n", card->card_number);
#line 893
    ret = -12;
#line 895
    goto failed_req_csr;
  }
#line 898
  tmp___3 = ioremap_nocache(card->csr_base, card->csr_len);
#line 898
  card->csr_remap = (unsigned char *)tmp___3;
#line 899
  if (! card->csr_remap) {
#line 900
    printk("<3>MM%d: Unable to remap memory region\n", card->card_number);
#line 901
    ret = -12;
#line 903
    goto failed_remap_csr;
  }
#line 906
  printk("<6>MM%d: CSR 0x%08lx -> 0x%p (0x%lx)\n", card->card_number, card->csr_base,
         card->csr_remap, card->csr_len);
#line 927
  printk("<6>MM%d: MEM area not remapped (CONFIG_MM_MAP_MEMORY not set)\n", card->card_number);
#line 930
  switch ((int )(card->dev)->device) {
  case 21525: 
#line 932
  card->flags |= 6;
#line 933
  magic_number = 89;
#line 934
  break;
  case 21541: 
#line 937
  card->flags |= 2;
#line 938
  magic_number = 92;
#line 939
  break;
  case 24917: 
#line 942
  card->flags |= 14;
#line 943
  magic_number = 153;
#line 944
  break;
  default: 
#line 947
  magic_number = 256;
#line 948
  break;
  }
#line 951
  tmp___4 = readb((void const   *)(card->csr_remap + 0));
#line 951
  if ((int )tmp___4 != magic_number) {
#line 952
    printk("<3>MM%d: Magic number invalid\n", card->card_number);
#line 953
    ret = -12;
#line 954
    goto failed_magic;
  }
#line 957
  tmp___5 = pci_alloc_consistent(card->dev, (size_t )((1UL << 12) * 2UL), & card->mm_pages[0].page_dma);
#line 957
  card->mm_pages[0].desc = (struct mm_dma_desc *)tmp___5;
#line 960
  tmp___6 = pci_alloc_consistent(card->dev, (size_t )((1UL << 12) * 2UL), & card->mm_pages[1].page_dma);
#line 960
  card->mm_pages[1].desc = (struct mm_dma_desc *)tmp___6;
#line 963
  if ((unsigned long )card->mm_pages[0].desc == (unsigned long )((void *)0)) {
#line 965
    printk("<3>MM%d: alloc failed\n", card->card_number);
#line 966
    goto failed_req_irq;
  } else
#line 963
  if ((unsigned long )card->mm_pages[1].desc == (unsigned long )((void *)0)) {
#line 965
    printk("<3>MM%d: alloc failed\n", card->card_number);
#line 966
    goto failed_req_irq;
  }
#line 968
  reset_page(& card->mm_pages[0]);
#line 969
  reset_page(& card->mm_pages[1]);
#line 970
  card->Ready = 0;
#line 971
  card->Active = -1;
#line 972
  card->bio = (struct bio *)((void *)0);
#line 973
  card->biotail = & card->bio;
#line 975
  card->queue = blk_alloc_queue(208U);
#line 976
  if (! card->queue) {
#line 977
    goto failed_req_irq;
  }
#line 979
  blk_queue_make_request(card->queue, & mm_make_request);
#line 980
  (card->queue)->queuedata = (void *)card;
#line 981
  (card->queue)->unplug_fn = & mm_unplug_device;
#line 983
  tasklet_init(& card->tasklet, & process_page, (unsigned long )card);
#line 985
  card->check_batteries = 0;
#line 987
  mem_present = readb((void const   *)(card->csr_remap + 7));
#line 988
  switch ((int )mem_present) {
  case 254: 
#line 990
  card->mm_size = 131072U;
#line 991
  break;
  case 252: 
#line 993
  card->mm_size = 262144U;
#line 994
  break;
  case 248: 
#line 996
  card->mm_size = 524288U;
#line 997
  break;
  case 240: 
#line 999
  card->mm_size = 1048576U;
#line 1000
  break;
  case 224: 
#line 1002
  card->mm_size = 2097152U;
#line 1003
  break;
  default: 
#line 1005
  card->mm_size = 0U;
#line 1006
  break;
  }
#line 1010
  set_led(card, 2, (unsigned char)0);
#line 1011
  set_led(card, 4, (unsigned char)0);
#line 1013
  batt_status = readb((void const   *)(card->csr_remap + 4));
#line 1015
  card->battery[0].good = ! ((int )batt_status & 2);
#line 1016
  card->battery[1].good = ! ((int )batt_status & 8);
#line 1017
  tmp___7 = jiffies;
#line 1017
  card->battery[1].last_change = tmp___7;
#line 1017
  card->battery[0].last_change = tmp___7;
#line 1019
  if (card->flags & 8) {
#line 1020
    printk("<6>MM%d: Size %d KB\n", card->card_number, card->mm_size);
  } else {
#line 1023
    if (card->battery[1].good) {
#line 1023
      tmp___8 = "OK";
    } else {
#line 1023
      tmp___8 = "FAILURE";
    }
#line 1023
    if ((int )batt_status & 4) {
#line 1023
      tmp___9 = "Disabled";
    } else {
#line 1023
      tmp___9 = "Enabled";
    }
#line 1023
    if (card->battery[0].good) {
#line 1023
      tmp___10 = "OK";
    } else {
#line 1023
      tmp___10 = "FAILURE";
    }
#line 1023
    if ((int )batt_status & 1) {
#line 1023
      tmp___11 = "Disabled";
    } else {
#line 1023
      tmp___11 = "Enabled";
    }
#line 1023
    printk("<6>MM%d: Size %d KB, Battery 1 %s (%s), Battery 2 %s (%s)\n", card->card_number,
           card->mm_size, tmp___11, tmp___10, tmp___9, tmp___8);
#line 1030
    set_fault_to_battery_status(card);
  }
#line 1033
  pci_read_config_dword(dev, 20, & saved_bar);
#line 1034
  data = 4294967295U;
#line 1035
  pci_write_config_dword(dev, 20, data);
#line 1036
  pci_read_config_dword(dev, 20, & data);
#line 1037
  pci_write_config_dword(dev, 20, saved_bar);
#line 1038
  data &= 4294967280U;
#line 1039
  data = ~ data;
#line 1040
  data ++;
#line 1042
  card->win_size = data;
#line 1045
  tmp___12 = request_irq(dev->irq, (irqreturn_t (*)(int  , void * , struct pt_regs * ))(& mm_interrupt),
                         128UL, "pci-umem", (void *)card);
#line 1045
  if (tmp___12) {
#line 1046
    printk("<3>MM%d: Unable to allocate IRQ\n", card->card_number);
#line 1047
    ret = -19;
#line 1049
    goto failed_req_irq;
  }
#line 1052
  card->irq = (int )dev->irq;
#line 1053
  printk("<6>MM%d: Window size %d bytes, IRQ %d\n", card->card_number, card->win_size,
         card->irq);
#line 1056
  spin_lock_init(& card->lock);
#line 1058
  pci_set_drvdata(dev, (void *)card);
#line 1060
  if (pci_write_cmd != 15) {
#line 1061
    pci_write_cmd = 7;
  }
#line 1063
  if (pci_write_cmd & 8) {
#line 1065
    pci_read_config_word(dev, 4, & cfg_command);
#line 1066
    cfg_command = (unsigned short )((int )cfg_command | 16);
#line 1067
    pci_write_config_word(dev, 4, cfg_command);
  }
#line 1069
  pci_cmds = (pci_read_cmd << 28) | (pci_write_cmd << 24);
#line 1071
  num_cards ++;
#line 1073
  tmp___13 = get_userbit(card, 1);
#line 1073
  if (tmp___13) {
#line 1077
    printk("<6>MM%d: memory already initialized\n", card->card_number);
#line 1078
    card->init_size = card->mm_size;
  } else {
#line 1074
    printk("<6>MM%d: memory NOT initialized. Consider over-writing whole device.\n",
           card->card_number);
#line 1075
    card->init_size = 0U;
  }
#line 1082
  writeb((unsigned char)3, (void *)(card->csr_remap + 12));
#line 1084
  return (0);
  failed_req_irq: 
#line 1088
  if (card->mm_pages[0].desc) {
#line 1089
    pci_free_consistent(card->dev, (size_t )((1UL << 12) * 2UL), (void *)card->mm_pages[0].desc,
                        card->mm_pages[0].page_dma);
  }
#line 1092
  if (card->mm_pages[1].desc) {
#line 1093
    pci_free_consistent(card->dev, (size_t )((1UL << 12) * 2UL), (void *)card->mm_pages[1].desc,
                        card->mm_pages[1].page_dma);
  }
  failed_magic: 
#line 1104
  iounmap((void *)card->csr_remap);
  failed_remap_csr: 
#line 1106
  release_mem_region(card->csr_base, card->csr_len);
  failed_req_csr: 
#line 1109
  return (ret);
}
}
#line 1116 "umem.c"
void mm_pci_remove(struct pci_dev *dev ) 
{ 
  struct cardinfo *card ;
  void *tmp ;

  {
#line 1118
  tmp = pci_get_drvdata(dev);
#line 1118
  card = (struct cardinfo *)tmp;
#line 1120
  tasklet_kill(& card->tasklet);
#line 1121
  iounmap((void *)card->csr_remap);
#line 1122
  release_mem_region(card->csr_base, card->csr_len);
#line 1127
  free_irq((unsigned int )card->irq, (void *)card);
#line 1129
  if (card->mm_pages[0].desc) {
#line 1130
    pci_free_consistent(card->dev, (size_t )((1UL << 12) * 2UL), (void *)card->mm_pages[0].desc,
                        card->mm_pages[0].page_dma);
  }
#line 1133
  if (card->mm_pages[1].desc) {
#line 1134
    pci_free_consistent(card->dev, (size_t )((1UL << 12) * 2UL), (void *)card->mm_pages[1].desc,
                        card->mm_pages[1].page_dma);
  }
#line 1137
  blk_cleanup_queue(card->queue);
#line 1138
  return;
}
}
#line 1140 "umem.c"
struct pci_device_id  const  mm_pci_ids[5]  = {      {(__u32 )4914, (__u32 )21525, 0U, 0U, 0U, 0U, 0UL}, 
        {(__u32 )4914, (__u32 )21541, 0U, 0U, 0U, 0U, 0UL}, 
        {(__u32 )4914, (__u32 )24917, 0U, 0U, 0U, 0U, 0UL}, 
        {(__u32 )32902, (__u32 )46421, (__u32 )4914, (__u32 )21600, (__u32 )327680, (__u32 )0,
      0UL}, 
        {(__u32 )0, 0U, 0U, 0U, 0U, 0U, 0UL}};
#line 1161 "umem.c"
struct pci_driver mm_pci_driver  = 
#line 1161
     {(char *)"umem", mm_pci_ids, & mm_pci_probe, & mm_pci_remove, (int (*)(struct pci_dev *dev ,
                                                                          pm_message_t state ))0,
    (int (*)(struct pci_dev *dev ))0, (int (*)(struct pci_dev *dev , pci_power_t state ,
                                               int enable ))0, (void (*)(struct pci_dev *dev ))0};
#line 1173 "umem.c"
int mm_init(void) 
{ 
  int retval ;
  int i ;
  int err ;
  struct gendisk *disk ;
  int tmp ;

  {
#line 1178
  printk("<6>v2.3 : Micro Memory(tm) PCI memory board block driver\n");
#line 1180
  retval = pci_register_driver(& mm_pci_driver);
#line 1181
  if (retval) {
#line 1182
    return (-12);
  }
#line 1184
  major_nr = register_blkdev(0U, "umem");
#line 1184
  err = major_nr;
#line 1185
  if (err < 0) {
#line 1186
    return (-5);
  }
#line 1188
  i = 0;
#line 1188
  while (i < num_cards) {
#line 1189
    mm_gendisk[i] = alloc_disk(1 << 6);
#line 1190
    if (! mm_gendisk[i]) {
#line 1191
      goto out;
    }
#line 1188
    i ++;
  }
#line 1194
  i = 0;
#line 1194
  while (i < num_cards) {
#line 1195
    disk = mm_gendisk[i];
#line 1196
    sprintf(disk->disk_name, "umem%c", 97 + i);
#line 1197
    spin_lock_init(& cards[i].lock);
#line 1198
    disk->major = major_nr;
#line 1199
    disk->first_minor = i << 6;
#line 1200
    disk->fops = & mm_fops;
#line 1201
    disk->private_data = (void *)(& cards[i]);
#line 1202
    disk->queue = cards[i].queue;
#line 1203
    set_capacity(disk, (sector_t )(cards[i].mm_size << 1));
#line 1204
    add_disk(disk);
#line 1194
    i ++;
  }
#line 1207
  init_battery_timer();
#line 1208
  printk("MM: desc_per_page = %ld\n", ((1UL << 12) * 2UL) / sizeof(struct mm_dma_desc ));
#line 1210
  return (0);
  out: 
#line 1213
  unregister_blkdev((unsigned int )major_nr, "umem");
#line 1214
  while (1) {
#line 1214
    tmp = i;
#line 1214
    i --;
#line 1214
    if (! tmp) {
#line 1214
      break;
    }
#line 1215
    put_disk(mm_gendisk[i]);
  }
#line 1216
  return (-12);
}
}
#line 1223 "umem.c"
void mm_cleanup(void) 
{ 
  int i ;

  {
#line 1227
  del_battery_timer();
#line 1229
  i = 0;
#line 1229
  while (i < num_cards) {
#line 1230
    del_gendisk(mm_gendisk[i]);
#line 1231
    put_disk(mm_gendisk[i]);
#line 1229
    i ++;
  }
#line 1234
  pci_unregister_driver(& mm_pci_driver);
#line 1236
  unregister_blkdev((unsigned int )major_nr, "umem");
#line 1237
  return;
}
}
#line 1239 "umem.c"
int (*_ddv_tmp_init)(void)  =    & mm_init;
#line 1240 "umem.c"
void (*_ddv_tmp_exit)(void)  =    & mm_cleanup;
#line 1242 "umem.c"
char _ddv_module_author[39]  = 
#line 1242
  {      (char )'S',      (char )'a',      (char )'n',      (char )' ', 
        (char )'M',      (char )'e',      (char )'h',      (char )'a', 
        (char )'t',      (char )',',      (char )' ',      (char )'J', 
        (char )'o',      (char )'h',      (char )'a',      (char )'n', 
        (char )'n',      (char )'e',      (char )'s',      (char )' ', 
        (char )'E',      (char )'r',      (char )'d',      (char )'f', 
        (char )'e',      (char )'l',      (char )'t',      (char )',', 
        (char )' ',      (char )'N',      (char )'e',      (char )'i', 
        (char )'l',      (char )'B',      (char )'r',      (char )'o', 
        (char )'w',      (char )'n',      (char )'\000'};
#line 1243 "umem.c"
char _ddv_module_description[47]  = 
#line 1243
  {      (char )'M',      (char )'i',      (char )'c',      (char )'r', 
        (char )'o',      (char )' ',      (char )'M',      (char )'e', 
        (char )'m',      (char )'o',      (char )'r',      (char )'y', 
        (char )'(',      (char )'t',      (char )'m',      (char )')', 
        (char )' ',      (char )'P',      (char )'C',      (char )'I', 
        (char )' ',      (char )'m',      (char )'e',      (char )'m', 
        (char )'o',      (char )'r',      (char )'y',      (char )' ', 
        (char )'b',      (char )'o',      (char )'a',      (char )'r', 
        (char )'d',      (char )' ',      (char )'b',      (char )'l', 
        (char )'o',      (char )'c',      (char )'k',      (char )' ', 
        (char )'d',      (char )'r',      (char )'i',      (char )'v', 
        (char )'e',      (char )'r',      (char )'\000'};
#line 1244 "umem.c"
char _ddv_module_license[4]  = {      (char )'G',      (char )'P',      (char )'L',      (char )'\000'};
#line 4 "__main.c"
int main(void) 
{ 


  {
#line 6
  _ddv_module_init = & mm_init;
#line 7
  _ddv_module_exit = & mm_cleanup;
#line 8
  call_ddv();
#line 10
  return (0);
}
}
#line 1 "manage.o"
#pragma merger("0","/tmp/cil-u1vnAqX9.i","")
#line 4 "/usr/local/ddv/models/con2/src/linux/kernel/irq/manage.c"
int request_irq(unsigned int irq , irqreturn_t (*handler)(int  , void * , struct pt_regs * ) ,
                unsigned long irqflags , char const   *devname , void *dev_id ) 
{ 
  int tmp ;

  {
#line 7
  tmp = nondet_int();
#line 7
  if (tmp) {
#line 8
    registered_irq[irq].handler = handler;
#line 9
    registered_irq[irq].dev_id = dev_id;
#line 11
    return (0);
  } else {
#line 13
    return (-1);
  }
}
}
#line 17 "/usr/local/ddv/models/con2/src/linux/kernel/irq/manage.c"
void free_irq(unsigned int irq , void *dev_id ) 
{ 


  {
#line 19
  registered_irq[irq].handler = (irqreturn_t (*)(int  , void * , struct pt_regs * ))((void *)0);
#line 20
  registered_irq[irq].dev_id = (void *)0;
#line 21
  return;
}
}
#line 1 "misc.o"
#pragma merger("0","/tmp/cil-mSOLQ4EW.i","")
#line 40 "/usr/local/ddv/models/con2/include/linux/miscdevice.h"
int misc_register(struct miscdevice *misc ) ;
#line 11 "/usr/local/ddv/models/con2/include/linux/proc_fs.h"
struct proc_dir_entry *proc_root_driver  ;
#line 18 "/usr/local/ddv/models/con2/src/linux/drivers/char/misc.c"
int misc_register(struct miscdevice *misc ) 
{ 
  int i ;
  dev_t dev ;
  int tmp ;

  {
#line 23
  if (fixed_cdev_used < 10) {
#line 24
    i = fixed_cdev_used;
#line 25
    fixed_cdev_used ++;
#line 27
    fixed_cdev[i].owner = (struct module *)0;
#line 28
    fixed_cdev[i].ops = misc->fops;
#line 30
    dev = (dev_t )((10 << 20) | misc->minor);
#line 32
    tmp = cdev_add(& fixed_cdev[i], dev, 0U);
#line 32
    return (tmp);
  } else {
#line 34
    return (-1);
  }
}
}
#line 1 "mutex.o"
#pragma merger("0","/tmp/cil-HcpnPUS9.i","")
#line 32 "/usr/local/ddv/models/con2/include/ddverify/ddverify.h"
__inline static int assert_context_process(void) 
{ 


  {
#line 34
  return (0);
}
}
#line 32 "/usr/local/ddv/models/con2/include/linux/mutex.h"
__inline void mutex_init(struct mutex *lock ) ;
#line 34
__inline void mutex_lock(struct mutex *lock ) ;
#line 36
__inline void mutex_unlock(struct mutex *lock ) ;
#line 4 "/usr/local/ddv/models/con2/src/linux/kernel/mutex.c"
__inline void mutex_init(struct mutex *lock ) 
{ 


  {
#line 7
  __CPROVER_atomic_begin();
#line 11
  lock->locked = 0;
#line 12
  lock->init = 1;
#line 13
  __CPROVER_atomic_end();
#line 14
  return;
}
}
#line 16 "/usr/local/ddv/models/con2/src/linux/kernel/mutex.c"
__inline void mutex_lock(struct mutex *lock ) 
{ 


  {
#line 27
  while (1) {
#line 29
    __CPROVER_atomic_begin();
#line 30
    if (lock->locked == 0) {
#line 32
      lock->locked = 1;
#line 33
      __CPROVER_atomic_end();
#line 34
      return;
    }
#line 36
    __CPROVER_atomic_end();
  }
}
}
#line 41 "/usr/local/ddv/models/con2/src/linux/kernel/mutex.c"
__inline void mutex_unlock(struct mutex *lock ) 
{ 


  {
#line 44
  __CPROVER_atomic_begin();
#line 45
  assert_context_process();
#line 49
  lock->locked = 0;
#line 50
  __CPROVER_atomic_end();
#line 51
  return;
}
}
#line 1 "page_alloc.o"
#pragma merger("0","/tmp/cil-thPf510l.i","")
#line 55 "/usr/local/ddv/models/con2/include/linux/gfp.h"
__inline unsigned long __get_free_pages(gfp_t gfp_mask , unsigned int order ) ;
#line 57
__inline unsigned long __get_free_page(gfp_t gfp_mask ) ;
#line 59
__inline unsigned long get_zeroed_page(gfp_t gfp_mask ) ;
#line 70
__inline struct page *alloc_pages(gfp_t gfp_mask , unsigned int order ) ;
#line 72
__inline struct page *alloc_page(gfp_t gfp_mask ) ;
#line 5 "/usr/local/ddv/models/con2/src/linux/mm/page_alloc.c"
__inline unsigned long __get_free_pages(gfp_t gfp_mask , unsigned int order ) 
{ 


  {
#line 8
  if (gfp_mask & 16U) {
#line 9
    assert_context_process();
  }
#line 11
  return (0UL);
}
}
#line 13 "/usr/local/ddv/models/con2/src/linux/mm/page_alloc.c"
__inline unsigned long __get_free_page(gfp_t gfp_mask ) 
{ 


  {
#line 16
  if (gfp_mask & 16U) {
#line 17
    assert_context_process();
  }
#line 19
  return (0UL);
}
}
#line 38 "/usr/local/ddv/models/con2/src/linux/mm/page_alloc.c"
__inline struct page *alloc_pages(gfp_t gfp_mask , unsigned int order ) 
{ 


  {
#line 41
  if (gfp_mask & 16U) {
#line 42
    assert_context_process();
  }
#line 44
  return ((struct page *)0);
}
}
#line 46 "/usr/local/ddv/models/con2/src/linux/mm/page_alloc.c"
__inline struct page *alloc_page(gfp_t gfp_mask ) 
{ 


  {
#line 49
  if (gfp_mask & 16U) {
#line 50
    assert_context_process();
  }
#line 52
  return ((struct page *)0);
}
}
#line 1 "pci.o"
#pragma merger("0","/tmp/cil-5k5cMGIy.i","")
#line 90 "/usr/local/ddv/models/con2/include/linux/ioport.h"
struct resource *request_region(unsigned long start , unsigned long len , char const   *name ) ;
#line 92
void release_region(unsigned long start , unsigned long len ) ;
#line 87 "/usr/local/ddv/models/con2/include/linux/pci.h"
__inline struct pci_dev *pci_get_class(unsigned int class , struct pci_dev *from ) ;
#line 152
__inline int pci_request_regions(struct pci_dev *pdev , char const   *res_name ) ;
#line 154
__inline void pci_release_regions(struct pci_dev *pdev ) ;
#line 156
__inline int pci_request_region(struct pci_dev *pdev , int bar , char const   *res_name ) ;
#line 158
__inline void pci_release_region(struct pci_dev *pdev , int bar ) ;
#line 8 "/usr/local/ddv/models/con2/src/linux/pci.c"
int pci_enable_device(struct pci_dev *dev ) 
{ 
  int i ;
  unsigned int tmp ;
  unsigned short tmp___0 ;

  {
#line 12
  i = 0;
#line 12
  while (i < 12) {
#line 13
    dev->resource[i].flags = 256UL;
#line 14
    tmp = nondet_uint();
#line 14
    dev->resource[i].start = (unsigned long )tmp;
#line 15
    tmp___0 = nondet_ushort();
#line 15
    dev->resource[i].end = dev->resource[i].start + (unsigned long )tmp___0;
#line 12
    i ++;
  }
#line 17
  return (0);
}
}
#line 19 "/usr/local/ddv/models/con2/src/linux/pci.c"
__inline struct pci_dev *pci_get_class(unsigned int class , struct pci_dev *from ) 
{ 
  void *tmp ;
  int tmp___0 ;

  {
#line 21
  if ((unsigned long )from == (unsigned long )((void *)0)) {
#line 22
    tmp = malloc((size_t )sizeof(struct pci_dev ));
#line 22
    from = (struct pci_dev *)tmp;
  }
#line 25
  tmp___0 = nondet_int();
#line 25
  if (tmp___0) {
#line 26
    from->vendor = nondet_ushort();
#line 27
    from->device = nondet_ushort();
#line 28
    from->irq = nondet_uint();
#line 29
    __CPROVER_assume(from->irq < 16U);
#line 31
    return (from);
  } else {
#line 33
    return ((struct pci_dev *)((void *)0));
  }
}
}
#line 37 "/usr/local/ddv/models/con2/src/linux/pci.c"
int pci_register_driver(struct pci_driver *driver ) 
{ 
  int tmp ;

  {
#line 39
  tmp = nondet_int();
#line 39
  if (tmp) {
#line 40
    registered_pci_driver.pci_driver = driver;
#line 41
    registered_pci_driver.no_pci_device_id = (unsigned int )(sizeof(driver->id_table) / sizeof(struct pci_device_id ));
#line 42
    registered_pci_driver.dev_initialized = 0;
#line 44
    return (0);
  } else {
#line 46
    return (-1);
  }
}
}
#line 50 "/usr/local/ddv/models/con2/src/linux/pci.c"
void pci_unregister_driver(struct pci_driver *driver ) 
{ 


  {
#line 52
  registered_pci_driver.pci_driver = (struct pci_driver *)((void *)0);
#line 53
  registered_pci_driver.no_pci_device_id = 0U;
#line 54
  return;
}
}
#line 56 "/usr/local/ddv/models/con2/src/linux/pci.c"
__inline void pci_release_region(struct pci_dev *pdev , int bar ) 
{ 
  unsigned long tmp ;
  unsigned long tmp___0 ;
  unsigned long tmp___1 ;

  {
#line 58
  if (pdev->resource[bar].start == 0UL) {
#line 58
    if (pdev->resource[bar].end == pdev->resource[bar].start) {
#line 58
      tmp = 0UL;
    } else {
#line 58
      tmp = (pdev->resource[bar].end - pdev->resource[bar].start) + 1UL;
    }
  } else {
#line 58
    tmp = (pdev->resource[bar].end - pdev->resource[bar].start) + 1UL;
  }
#line 58
  if (tmp == 0UL) {
#line 59
    return;
  }
#line 60
  if (pdev->resource[bar].flags & 256UL) {
#line 61
    if (pdev->resource[bar].start == 0UL) {
#line 61
      if (pdev->resource[bar].end == pdev->resource[bar].start) {
#line 61
        tmp___0 = 0UL;
      } else {
#line 61
        tmp___0 = (pdev->resource[bar].end - pdev->resource[bar].start) + 1UL;
      }
    } else {
#line 61
      tmp___0 = (pdev->resource[bar].end - pdev->resource[bar].start) + 1UL;
    }
#line 61
    release_region(pdev->resource[bar].start, tmp___0);
  } else
#line 63
  if (pdev->resource[bar].flags & 512UL) {
#line 64
    if (pdev->resource[bar].start == 0UL) {
#line 64
      if (pdev->resource[bar].end == pdev->resource[bar].start) {
#line 64
        tmp___1 = 0UL;
      } else {
#line 64
        tmp___1 = (pdev->resource[bar].end - pdev->resource[bar].start) + 1UL;
      }
    } else {
#line 64
      tmp___1 = (pdev->resource[bar].end - pdev->resource[bar].start) + 1UL;
    }
#line 64
    release_mem_region(pdev->resource[bar].start, tmp___1);
  }
#line 66
  return;
}
}
#line 68 "/usr/local/ddv/models/con2/src/linux/pci.c"
__inline int pci_request_region(struct pci_dev *pdev , int bar , char const   *res_name ) 
{ 
  unsigned long tmp ;
  unsigned long tmp___0 ;
  struct resource *tmp___1 ;
  unsigned long tmp___2 ;
  struct resource *tmp___3 ;

  {
#line 70
  if (pdev->resource[bar].start == 0UL) {
#line 70
    if (pdev->resource[bar].end == pdev->resource[bar].start) {
#line 70
      tmp = 0UL;
    } else {
#line 70
      tmp = (pdev->resource[bar].end - pdev->resource[bar].start) + 1UL;
    }
  } else {
#line 70
    tmp = (pdev->resource[bar].end - pdev->resource[bar].start) + 1UL;
  }
#line 70
  if (tmp == 0UL) {
#line 71
    return (0);
  }
#line 73
  if (pdev->resource[bar].flags & 256UL) {
#line 74
    if (pdev->resource[bar].start == 0UL) {
#line 74
      if (pdev->resource[bar].end == pdev->resource[bar].start) {
#line 74
        tmp___0 = 0UL;
      } else {
#line 74
        tmp___0 = (pdev->resource[bar].end - pdev->resource[bar].start) + 1UL;
      }
    } else {
#line 74
      tmp___0 = (pdev->resource[bar].end - pdev->resource[bar].start) + 1UL;
    }
#line 74
    tmp___1 = request_region(pdev->resource[bar].start, tmp___0, res_name);
#line 74
    if (! tmp___1) {
#line 76
      return (-16);
    }
  } else
#line 78
  if (pdev->resource[bar].flags & 512UL) {
#line 79
    if (pdev->resource[bar].start == 0UL) {
#line 79
      if (pdev->resource[bar].end == pdev->resource[bar].start) {
#line 79
        tmp___2 = 0UL;
      } else {
#line 79
        tmp___2 = (pdev->resource[bar].end - pdev->resource[bar].start) + 1UL;
      }
    } else {
#line 79
      tmp___2 = (pdev->resource[bar].end - pdev->resource[bar].start) + 1UL;
    }
#line 79
    tmp___3 = request_mem_region(pdev->resource[bar].start, tmp___2, res_name);
#line 79
    if (! tmp___3) {
#line 81
      return (-16);
    }
  }
#line 84
  return (0);
}
}
#line 87 "/usr/local/ddv/models/con2/src/linux/pci.c"
__inline void pci_release_regions(struct pci_dev *pdev ) 
{ 
  int i ;

  {
#line 91
  i = 0;
#line 91
  while (i < 6) {
#line 92
    pci_release_region(pdev, i);
#line 91
    i ++;
  }
#line 93
  return;
}
}
#line 95 "/usr/local/ddv/models/con2/src/linux/pci.c"
__inline int pci_request_regions(struct pci_dev *pdev , char const   *res_name ) 
{ 
  int i ;
  int tmp ;

  {
#line 99
  i = 0;
#line 99
  while (i < 6) {
#line 100
    tmp = pci_request_region(pdev, i, res_name);
#line 100
    if (tmp) {
#line 101
      goto err_out;
    }
#line 99
    i ++;
  }
#line 102
  return (0);
  err_out: 
#line 105
  while (1) {
#line 105
    i --;
#line 105
    if (! (i >= 0)) {
#line 105
      break;
    }
#line 106
    pci_release_region(pdev, i);
  }
#line 108
  return (-16);
}
}
#line 1 "resource.o"
#pragma merger("0","/tmp/cil-_2ObJIYJ.i","")
#line 21 "/usr/local/ddv/models/con2/include/ddverify/satabs.h"
extern unsigned char nondet_uchar() ;
#line 22
extern unsigned int nondet_unsigned() ;
#line 10 "/usr/local/ddv/models/con2/include/ddverify/ioport.h"
int ddv_ioport_request_start  ;
#line 11 "/usr/local/ddv/models/con2/include/ddverify/ioport.h"
int ddv_ioport_request_len  ;
#line 6 "/usr/local/ddv/models/con2/src/linux/kernel/resource.c"
struct resource *request_region(unsigned long start , unsigned long len , char const   *name ) 
{ 
  struct resource *resource ;
  void *tmp ;

  {
#line 9
  tmp = malloc((size_t )sizeof(struct resource ));
#line 9
  resource = (struct resource *)tmp;
#line 14
  ddv_ioport_request_start = (int )start;
#line 15
  ddv_ioport_request_len = (int )len;
#line 17
  return (resource);
}
}
#line 20 "/usr/local/ddv/models/con2/src/linux/kernel/resource.c"
void release_region(unsigned long start , unsigned long len ) 
{ 
  unsigned int i ;

  {
#line 22
  i = 0U;
#line 28
  ddv_ioport_request_start = 0;
#line 29
  ddv_ioport_request_len = 0;
#line 30
  return;
}
}
#line 32 "/usr/local/ddv/models/con2/src/linux/kernel/resource.c"
__inline unsigned char inb(unsigned int port ) 
{ 
  int tmp ;
  unsigned char tmp___0 ;

  {
#line 35
  if (port >= (unsigned int )ddv_ioport_request_start) {
#line 35
    if (port < (unsigned int )(ddv_ioport_request_start + ddv_ioport_request_len)) {
#line 35
      tmp = 1;
    } else {
#line 35
      tmp = 0;
    }
  } else {
#line 35
    tmp = 0;
  }
#line 35
  __CPROVER_assert(tmp, "I/O port is requested");
#line 37
  tmp___0 = nondet_uchar();
#line 37
  return (tmp___0);
}
}
#line 40 "/usr/local/ddv/models/con2/src/linux/kernel/resource.c"
__inline void outb(unsigned char byte , unsigned int port ) 
{ 
  int tmp ;

  {
#line 43
  if (port >= (unsigned int )ddv_ioport_request_start) {
#line 43
    if (port < (unsigned int )(ddv_ioport_request_start + ddv_ioport_request_len)) {
#line 43
      tmp = 1;
    } else {
#line 43
      tmp = 0;
    }
  } else {
#line 43
    tmp = 0;
  }
#line 43
  __CPROVER_assert(tmp, "I/O port is requested");
#line 44
  return;
}
}
#line 46 "/usr/local/ddv/models/con2/src/linux/kernel/resource.c"
__inline unsigned short inw(unsigned int port ) 
{ 
  int tmp ;
  unsigned short tmp___0 ;

  {
#line 49
  if (port >= (unsigned int )ddv_ioport_request_start) {
#line 49
    if (port < (unsigned int )(ddv_ioport_request_start + ddv_ioport_request_len)) {
#line 49
      tmp = 1;
    } else {
#line 49
      tmp = 0;
    }
  } else {
#line 49
    tmp = 0;
  }
#line 49
  __CPROVER_assert(tmp, "I/O port is requested");
#line 51
  tmp___0 = nondet_ushort();
#line 51
  return (tmp___0);
}
}
#line 54 "/usr/local/ddv/models/con2/src/linux/kernel/resource.c"
__inline void outw(unsigned short word , unsigned int port ) 
{ 
  int tmp ;

  {
#line 57
  if (port >= (unsigned int )ddv_ioport_request_start) {
#line 57
    if (port < (unsigned int )(ddv_ioport_request_start + ddv_ioport_request_len)) {
#line 57
      tmp = 1;
    } else {
#line 57
      tmp = 0;
    }
  } else {
#line 57
    tmp = 0;
  }
#line 57
  __CPROVER_assert(tmp, "I/O port is requested");
#line 58
  return;
}
}
#line 60 "/usr/local/ddv/models/con2/src/linux/kernel/resource.c"
__inline unsigned int inl(unsigned int port ) 
{ 
  int tmp ;
  unsigned int tmp___0 ;

  {
#line 63
  if (port >= (unsigned int )ddv_ioport_request_start) {
#line 63
    if (port < (unsigned int )(ddv_ioport_request_start + ddv_ioport_request_len)) {
#line 63
      tmp = 1;
    } else {
#line 63
      tmp = 0;
    }
  } else {
#line 63
    tmp = 0;
  }
#line 63
  __CPROVER_assert(tmp, "I/O port is requested");
#line 65
  tmp___0 = nondet_unsigned();
#line 65
  return (tmp___0);
}
}
#line 68 "/usr/local/ddv/models/con2/src/linux/kernel/resource.c"
__inline void outl(unsigned int doubleword , unsigned int port ) 
{ 
  int tmp ;

  {
#line 71
  if (port >= (unsigned int )ddv_ioport_request_start) {
#line 71
    if (port < (unsigned int )(ddv_ioport_request_start + ddv_ioport_request_len)) {
#line 71
      tmp = 1;
    } else {
#line 71
      tmp = 0;
    }
  } else {
#line 71
    tmp = 0;
  }
#line 71
  __CPROVER_assert(tmp, "I/O port is requested");
#line 72
  return;
}
}
#line 1 "sched.o"
#pragma merger("0","/tmp/cil-lFNeqOdB.i","")
#line 18 "/usr/local/ddv/models/con2/include/ddverify/satabs.h"
extern long nondet_long() ;
#line 43 "/usr/local/ddv/models/con2/include/linux/sched.h"
void schedule(void) ;
#line 45
long schedule_timeout(long timeout ) ;
#line 8 "/usr/local/ddv/models/con2/src/linux/kernel/sched.c"
void schedule(void) 
{ 


  {
#line 10
  assert_context_process();
#line 11
  return;
}
}
#line 13 "/usr/local/ddv/models/con2/src/linux/kernel/sched.c"
long schedule_timeout(long timeout ) 
{ 
  long tmp ;

  {
#line 15
  assert_context_process();
#line 17
  tmp = nondet_long();
#line 17
  return (tmp);
}
}
#line 1 "semaphore.o"
#pragma merger("0","/tmp/cil-HRHlKqIM.i","")
#line 23 "/usr/local/ddv/models/con2/include/asm/semaphore.h"
__inline void sema_init(struct semaphore *sem , int val ) ;
#line 25
__inline void init_MUTEX(struct semaphore *sem ) ;
#line 27
__inline void init_MUTEX_LOCKED(struct semaphore *sem ) ;
#line 29
__inline void down(struct semaphore *sem ) ;
#line 31
__inline int down_interruptible(struct semaphore *sem ) ;
#line 33
__inline int down_trylock(struct semaphore *sem ) ;
#line 35
__inline void up(struct semaphore *sem ) ;
#line 6 "/usr/local/ddv/models/con2/src/linux/kernel/semaphore.c"
__inline void sema_init(struct semaphore *sem , int val ) 
{ 


  {
#line 9
  __CPROVER_atomic_begin();
#line 10
  sem->init = 1;
#line 11
  sem->locked = 0;
#line 12
  __CPROVER_atomic_end();
#line 13
  return;
}
}
#line 15 "/usr/local/ddv/models/con2/src/linux/kernel/semaphore.c"
__inline void init_MUTEX(struct semaphore *sem ) 
{ 


  {
#line 18
  __CPROVER_atomic_begin();
#line 19
  sem->init = 1;
#line 20
  sem->locked = 0;
#line 21
  __CPROVER_atomic_end();
#line 22
  return;
}
}
#line 24 "/usr/local/ddv/models/con2/src/linux/kernel/semaphore.c"
__inline void init_MUTEX_LOCKED(struct semaphore *sem ) 
{ 


  {
#line 27
  __CPROVER_atomic_begin();
#line 28
  sem->init = 1;
#line 29
  sem->locked = 1;
#line 30
  __CPROVER_atomic_end();
#line 31
  return;
}
}
#line 33 "/usr/local/ddv/models/con2/src/linux/kernel/semaphore.c"
__inline void down(struct semaphore *sem ) 
{ 


  {
#line 44
  while (1) {
#line 46
    __CPROVER_atomic_begin();
#line 47
    if (sem->locked == 0) {
#line 49
      sem->locked = 1;
#line 50
      __CPROVER_atomic_end();
#line 51
      return;
    }
#line 53
    __CPROVER_atomic_end();
  }
}
}
#line 58 "/usr/local/ddv/models/con2/src/linux/kernel/semaphore.c"
__inline int down_interruptible(struct semaphore *sem ) 
{ 
  int tmp ;

  {
#line 69
  while (1) {
#line 71
    __CPROVER_atomic_begin();
#line 72
    if (sem->locked == 0) {
#line 74
      sem->locked = 1;
#line 75
      __CPROVER_atomic_end();
#line 76
      return (0);
    }
#line 78
    tmp = nondet_int();
#line 78
    if (tmp) {
#line 79
      __CPROVER_atomic_end();
#line 80
      return (-1);
    }
#line 83
    __CPROVER_atomic_end();
  }
}
}
#line 88 "/usr/local/ddv/models/con2/src/linux/kernel/semaphore.c"
__inline int down_trylock(struct semaphore *sem ) 
{ 


  {
#line 91
  __CPROVER_atomic_begin();
#line 97
  if (sem->locked == 0) {
#line 98
    sem->locked = 1;
#line 99
    __CPROVER_atomic_end();
#line 100
    return (-1);
  }
#line 102
  __CPROVER_atomic_end();
#line 103
  return (0);
}
}
#line 106 "/usr/local/ddv/models/con2/src/linux/kernel/semaphore.c"
__inline void up(struct semaphore *sem ) 
{ 


  {
#line 109
  __CPROVER_atomic_begin();
#line 110
  assert_context_process();
#line 114
  sem->locked = 0;
#line 115
  __CPROVER_atomic_end();
#line 116
  return;
}
}
#line 1 "slab.o"
#pragma merger("0","/tmp/cil-lQ7PFr9r.i","")
#line 10 "/usr/local/ddv/models/con2/include/linux/slab.h"
void *kmalloc(size_t size , gfp_t flags ) ;
#line 12
void *kzalloc(size_t size , gfp_t flags ) ;
#line 6 "/usr/local/ddv/models/con2/src/linux/mm/slab.c"
void *kmalloc(size_t size , gfp_t flags ) 
{ 
  void *tmp ;

  {
#line 8
  if (flags & 16U) {
#line 9
    assert_context_process();
  }
#line 12
  tmp = malloc(size);
#line 12
  return (tmp);
}
}
#line 15 "/usr/local/ddv/models/con2/src/linux/mm/slab.c"
void *kzalloc(size_t size , gfp_t flags ) 
{ 
  void *tmp ;

  {
#line 17
  if (flags & 16U) {
#line 18
    assert_context_process();
  }
#line 21
  tmp = malloc(size);
#line 21
  return (tmp);
}
}
#line 1 "softirq.o"
#pragma merger("0","/tmp/cil-YnfdZAqr.i","")
#line 4 "/usr/local/ddv/models/con2/src/linux/kernel/softirq.c"
void tasklet_schedule(struct tasklet_struct *t ) 
{ 
  int i ;
  int next_free ;

  {
#line 7
  next_free = -1;
#line 13
  i = 0;
#line 13
  while (i < 10) {
#line 14
    if ((unsigned long )tasklet_registered[i].tasklet == (unsigned long )((void *)0)) {
#line 15
      next_free = i;
    }
#line 17
    if ((unsigned long )tasklet_registered[i].tasklet == (unsigned long )t) {
#line 17
      if ((int )tasklet_registered[i].is_running == 0) {
#line 19
        return;
      }
    }
#line 13
    i ++;
  }
#line 28
  tasklet_registered[next_free].tasklet = t;
#line 29
  tasklet_registered[next_free].is_running = (unsigned short)0;
#line 30
  return;
}
}
#line 32 "/usr/local/ddv/models/con2/src/linux/kernel/softirq.c"
void tasklet_init(struct tasklet_struct *t , void (*func)(unsigned long  ) , unsigned long data ) 
{ 


  {
#line 36
  t->count = 0;
#line 37
  t->init = 0;
#line 38
  t->func = func;
#line 39
  t->data = data;
#line 40
  return;
}
}
#line 1 "spinlock.o"
#pragma merger("0","/tmp/cil-vqgeC9At.i","")
#line 10 "/usr/local/ddv/models/con2/include/linux/spinlock.h"
__inline void spin_lock(spinlock_t *lock ) ;
#line 15
__inline void spin_unlock(spinlock_t *lock ) ;
#line 4 "/usr/local/ddv/models/con2/src/linux/kernel/spinlock.c"
void spin_lock_init(spinlock_t *lock ) 
{ 


  {
#line 6
  lock->init = 1;
#line 7
  lock->locked = 0;
#line 8
  return;
}
}
#line 10 "/usr/local/ddv/models/con2/src/linux/kernel/spinlock.c"
__inline void spin_lock(spinlock_t *lock ) 
{ 


  {
#line 20
  while (1) {
#line 22
    __CPROVER_atomic_begin();
#line 23
    if (lock->locked == 0) {
#line 25
      lock->locked = 1;
#line 26
      __CPROVER_atomic_end();
#line 27
      return;
    }
#line 29
    __CPROVER_atomic_end();
  }
}
}
#line 34 "/usr/local/ddv/models/con2/src/linux/kernel/spinlock.c"
void spin_lock_irqsave(spinlock_t *lock , unsigned long flags ) 
{ 


  {
#line 44
  while (1) {
#line 46
    __CPROVER_atomic_begin();
#line 47
    if (lock->locked == 0) {
#line 49
      lock->locked = 1;
#line 50
      __CPROVER_atomic_end();
#line 51
      return;
    }
#line 53
    __CPROVER_atomic_end();
  }
}
}
#line 58 "/usr/local/ddv/models/con2/src/linux/kernel/spinlock.c"
void spin_lock_irq(spinlock_t *lock ) 
{ 


  {
#line 68
  while (1) {
#line 70
    __CPROVER_atomic_begin();
#line 71
    if (lock->locked == 0) {
#line 73
      lock->locked = 1;
#line 74
      __CPROVER_atomic_end();
#line 75
      return;
    }
#line 77
    __CPROVER_atomic_end();
  }
}
}
#line 82 "/usr/local/ddv/models/con2/src/linux/kernel/spinlock.c"
void spin_lock_bh(spinlock_t *lock ) 
{ 


  {
#line 92
  while (1) {
#line 94
    __CPROVER_atomic_begin();
#line 95
    if (lock->locked == 0) {
#line 97
      lock->locked = 1;
#line 98
      __CPROVER_atomic_end();
#line 99
      return;
    }
#line 101
    __CPROVER_atomic_end();
  }
}
}
#line 106 "/usr/local/ddv/models/con2/src/linux/kernel/spinlock.c"
__inline void spin_unlock(spinlock_t *lock ) 
{ 


  {
#line 109
  __CPROVER_atomic_begin();
#line 113
  lock->locked = 0;
#line 114
  __CPROVER_atomic_end();
#line 115
  return;
}
}
#line 117 "/usr/local/ddv/models/con2/src/linux/kernel/spinlock.c"
void spin_unlock_irqrestore(spinlock_t *lock , unsigned long flags ) 
{ 


  {
#line 120
  __CPROVER_atomic_begin();
#line 124
  lock->locked = 0;
#line 125
  __CPROVER_atomic_end();
#line 126
  return;
}
}
#line 128 "/usr/local/ddv/models/con2/src/linux/kernel/spinlock.c"
void spin_unlock_irq(spinlock_t *lock ) 
{ 


  {
#line 131
  __CPROVER_atomic_begin();
#line 135
  lock->locked = 0;
#line 136
  __CPROVER_atomic_end();
#line 137
  return;
}
}
#line 139 "/usr/local/ddv/models/con2/src/linux/kernel/spinlock.c"
void spin_unlock_bh(spinlock_t *lock ) 
{ 


  {
#line 142
  __CPROVER_atomic_begin();
#line 146
  lock->locked = 0;
#line 147
  __CPROVER_atomic_end();
#line 149
  return;
}
}
#line 1 "tasklet.o"
#pragma merger("0","/tmp/cil-AnCFNcQq.i","")
#line 3 "/usr/local/ddv/models/con2/src/ddverify/tasklet.c"
void call_tasklet_functions(void) 
{ 
  unsigned int i ;

  {
#line 6
  __CPROVER_assume(i < 10U);
#line 8
  if ((unsigned long )tasklet_registered[i].tasklet != (unsigned long )((void *)0)) {
#line 8
    if ((tasklet_registered[i].tasklet)->count == 0) {
#line 10
      tasklet_registered[i].is_running = (unsigned short)1;
#line 11
      (*((tasklet_registered[i].tasklet)->func))((tasklet_registered[i].tasklet)->data);
#line 12
      tasklet_registered[i].is_running = (unsigned short)0;
#line 13
      tasklet_registered[i].tasklet = (struct tasklet_struct *)((void *)0);
    }
  }
#line 15
  return;
}
}
#line 1 "timer.o"
#pragma merger("0","/tmp/cil-lOuupy2I.i","")
#line 27 "/usr/local/ddv/models/con2/include/linux/timer.h"
__inline void add_timer_on(struct timer_list *timer , int cpu ) ;
#line 30
__inline int mod_timer(struct timer_list *timer , unsigned long expires ) ;
#line 4 "/usr/local/ddv/models/con2/src/linux/kernel/timer.c"
void init_timer(struct timer_list *timer ) 
{ 


  {
#line 6
  if ((int )number_timer_registered < 5) {
#line 7
    timer->__ddv_active = (short)0;
#line 8
    timer->__ddv_init = (short)1;
#line 9
    timer_registered[number_timer_registered].timer = timer;
#line 11
    number_timer_registered = (short )((int )number_timer_registered + 1);
  }
#line 13
  return;
}
}
#line 15 "/usr/local/ddv/models/con2/src/linux/kernel/timer.c"
void add_timer(struct timer_list *timer ) 
{ 


  {
#line 21
  timer->__ddv_active = (short)1;
#line 22
  return;
}
}
#line 24 "/usr/local/ddv/models/con2/src/linux/kernel/timer.c"
__inline void add_timer_on(struct timer_list *timer , int cpu ) 
{ 


  {
#line 27
  add_timer(timer);
#line 28
  return;
}
}
#line 30 "/usr/local/ddv/models/con2/src/linux/kernel/timer.c"
int del_timer(struct timer_list *timer ) 
{ 


  {
#line 32
  timer->__ddv_active = (short)0;
#line 33
  return (0);
}
}
#line 35 "/usr/local/ddv/models/con2/src/linux/kernel/timer.c"
__inline int mod_timer(struct timer_list *timer , unsigned long expires ) 
{ 


  {
#line 41
  timer->expires = expires;
#line 42
  timer->__ddv_active = (short)1;
#line 43
  return (0);
}
}
#line 1 "tty_io.o"
#pragma merger("0","/tmp/cil-2N8zAsgv.i","")
#line 97 "/usr/local/ddv/models/con2/include/linux/tty_driver.h"
struct tty_driver *alloc_tty_driver(int lines ) ;
#line 101
void tty_set_operations(struct tty_driver *driver , struct tty_operations  const  *op ) ;
#line 13 "/usr/local/ddv/models/con2/include/ddverify/tty.h"
struct ddv_tty_driver global_tty_driver  ;
#line 4 "/usr/local/ddv/models/con2/src/linux/drivers/char/tty_io.c"
struct tty_driver *alloc_tty_driver(int lines ) 
{ 


  {
#line 6
  if (! global_tty_driver.allocated) {
#line 7
    global_tty_driver.driver.magic = 21506;
#line 8
    global_tty_driver.driver.num = lines;
  } else {
#line 10
    return ((struct tty_driver *)((void *)0));
  }
#line 12
  return ((struct tty_driver *)0);
}
}
#line 14 "/usr/local/ddv/models/con2/src/linux/drivers/char/tty_io.c"
void tty_set_operations(struct tty_driver *driver , struct tty_operations  const  *op ) 
{ 


  {
#line 17
  driver->open = (int (*)(struct tty_struct *tty , struct file *filp ))op->open;
#line 18
  driver->close = (void (*)(struct tty_struct *tty , struct file *filp ))op->close;
#line 19
  driver->write = (int (*)(struct tty_struct *tty , unsigned char const   *buf , int count ))op->write;
#line 20
  driver->put_char = (void (*)(struct tty_struct *tty , unsigned char ch ))op->put_char;
#line 21
  driver->flush_chars = (void (*)(struct tty_struct *tty ))op->flush_chars;
#line 22
  driver->write_room = (int (*)(struct tty_struct *tty ))op->write_room;
#line 23
  driver->chars_in_buffer = (int (*)(struct tty_struct *tty ))op->chars_in_buffer;
#line 24
  driver->ioctl = (int (*)(struct tty_struct *tty , struct file *file , unsigned int cmd ,
                           unsigned long arg ))op->ioctl;
#line 25
  driver->set_termios = (void (*)(struct tty_struct *tty , struct termios *old ))op->set_termios;
#line 26
  driver->throttle = (void (*)(struct tty_struct *tty ))op->throttle;
#line 27
  driver->unthrottle = (void (*)(struct tty_struct *tty ))op->unthrottle;
#line 28
  driver->stop = (void (*)(struct tty_struct *tty ))op->stop;
#line 29
  driver->start = (void (*)(struct tty_struct *tty ))op->start;
#line 30
  driver->hangup = (void (*)(struct tty_struct *tty ))op->hangup;
#line 31
  driver->break_ctl = (void (*)(struct tty_struct *tty , int state ))op->break_ctl;
#line 32
  driver->flush_buffer = (void (*)(struct tty_struct *tty ))op->flush_buffer;
#line 33
  driver->set_ldisc = (void (*)(struct tty_struct *tty ))op->set_ldisc;
#line 34
  driver->wait_until_sent = (void (*)(struct tty_struct *tty , int timeout ))op->wait_until_sent;
#line 35
  driver->send_xchar = (void (*)(struct tty_struct *tty , char ch ))op->send_xchar;
#line 36
  driver->read_proc = (int (*)(char *page , char **start , off_t off , int count ,
                               int *eof , void *data ))op->read_proc;
#line 37
  driver->write_proc = (int (*)(struct file *file , char const   *buffer , unsigned long count ,
                                void *data ))op->write_proc;
#line 38
  driver->tiocmget = (int (*)(struct tty_struct *tty , struct file *file ))op->tiocmget;
#line 39
  driver->tiocmset = (int (*)(struct tty_struct *tty , struct file *file , unsigned int set ,
                              unsigned int clear ))op->tiocmset;
#line 40
  return;
}
}
#line 1 "usercopy.o"
#pragma merger("0","/tmp/cil-SeC48xj4.i","")
#line 41 "/usr/local/ddv/models/con2/include/asm/uaccess.h"
__inline int __get_user(int size , void *ptr ) ;
#line 43
__inline int get_user(int size , void *ptr ) ;
#line 46
__inline int __put_user(int size , void *ptr ) ;
#line 48
__inline int put_user(int size , void *ptr ) ;
#line 51
__inline unsigned long copy_to_user(void *to , void const   *from , unsigned long n ) ;
#line 53
__inline unsigned long copy_from_user(void *to , void *from , unsigned long n ) ;
#line 5 "/usr/local/ddv/models/con2/src/linux/arch/i386/lib/usercopy.c"
__inline int __get_user(int size , void *ptr ) 
{ 
  int tmp ;

  {
#line 8
  assert_context_process();
#line 10
  tmp = nondet_int();
#line 10
  return (tmp);
}
}
#line 37 "/usr/local/ddv/models/con2/src/linux/arch/i386/lib/usercopy.c"
__inline unsigned long copy_to_user(void *to , void const   *from , unsigned long n ) 
{ 
  unsigned long tmp ;

  {
#line 40
  assert_context_process();
#line 42
  tmp = nondet_ulong();
#line 42
  return (tmp);
}
}
#line 45 "/usr/local/ddv/models/con2/src/linux/arch/i386/lib/usercopy.c"
__inline unsigned long copy_from_user(void *to , void *from , unsigned long n ) 
{ 
  unsigned long tmp ;

  {
#line 48
  assert_context_process();
#line 50
  tmp = nondet_ulong();
#line 50
  return (tmp);
}
}
#line 1 "vmalloc.o"
#pragma merger("0","/tmp/cil-mAVqvewr.i","")
#line 6 "/usr/local/ddv/models/con2/include/linux/vmalloc.h"
void *vmalloc(unsigned long size ) ;
#line 6 "/usr/local/ddv/models/con2/src/linux/mm/vmalloc.c"
void *vmalloc(unsigned long size ) 
{ 
  void *tmp ;

  {
#line 8
  tmp = malloc((size_t )size);
#line 8
  return (tmp);
}
}
#line 1 "wait.o"
#pragma merger("0","/tmp/cil-xYb1vWvq.i","")
#line 64 "/usr/local/ddv/models/con2/include/linux/wait.h"
__inline void init_waitqueue_head(wait_queue_head_t *q ) ;
#line 71
__inline void wake_up(wait_queue_head_t *q ) ;
#line 73
__inline void wake_up_all(wait_queue_head_t *q ) ;
#line 75
__inline void wake_up_interruptible(wait_queue_head_t *q ) ;
#line 88
__inline void sleep_on(wait_queue_head_t *q ) ;
#line 90
__inline void interruptible_sleep_on(wait_queue_head_t *q ) ;
#line 3 "/usr/local/ddv/models/con2/src/linux/kernel/wait.c"
__inline void init_waitqueue_head(wait_queue_head_t *q ) 
{ 


  {
#line 5
  q->init = 1;
#line 6
  return;
}
}
#line 8 "/usr/local/ddv/models/con2/src/linux/kernel/wait.c"
__inline void wake_up(wait_queue_head_t *q ) 
{ 


  {
#line 14
  return;
}
}
#line 1 "workqueue.o"
#pragma merger("0","/tmp/cil-kSKc7jSD.i","")
#line 46 "/usr/local/ddv/models/con2/include/linux/workqueue.h"
__inline int schedule_work(struct work_struct *work ) ;
#line 5 "/usr/local/ddv/models/con2/src/linux/kernel/workqueue.c"
__inline int schedule_work(struct work_struct *work ) 
{ 
  int i ;

  {
#line 14
  i = 0;
#line 14
  while (i < 10) {
#line 15
    if ((unsigned long )shared_workqueue[i] == (unsigned long )work) {
#line 16
      return (0);
    }
#line 19
    if ((unsigned long )shared_workqueue[i] == (unsigned long )((void *)0)) {
#line 20
      shared_workqueue[i] = work;
#line 22
      return (1);
    }
#line 14
    i ++;
  }
#line 27
  return (-1);
}
}
#line 30 "/usr/local/ddv/models/con2/src/linux/kernel/workqueue.c"
void call_shared_workqueue_functions(void) 
{ 
  unsigned short i ;
  unsigned short tmp ;

  {
#line 32
  tmp = nondet_ushort();
#line 32
  i = tmp;
#line 33
  __CPROVER_assume((int )i < 10);
#line 35
  if ((unsigned long )shared_workqueue[i] != (unsigned long )((void *)0)) {
#line 36
    (*((shared_workqueue[i])->func))((shared_workqueue[i])->data);
#line 37
    shared_workqueue[i] = (struct work_struct *)((void *)0);
  }
#line 39
  return;
}
}
