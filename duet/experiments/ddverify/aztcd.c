/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is true */

#line 4 "/usr/local/ddv/models/con2/include/asm/posix_types.h"
typedef unsigned long __kernel_ino_t;
#line 5 "/usr/local/ddv/models/con2/include/asm/posix_types.h"
typedef unsigned short __kernel_mode_t;
#line 12 "/usr/local/ddv/models/con2/include/asm/posix_types.h"
typedef unsigned int __kernel_size_t;
#line 13 "/usr/local/ddv/models/con2/include/asm/posix_types.h"
typedef int __kernel_ssize_t;
#line 4 "/usr/local/ddv/models/con2/include/asm/types.h"
typedef unsigned short umode_t;
#line 13 "/usr/local/ddv/models/con2/include/asm/types.h"
typedef unsigned int __u32;
#line 9 "/usr/local/ddv/models/con2/include/linux/types.h"
typedef __u32 __kernel_dev_t;
#line 11 "/usr/local/ddv/models/con2/include/linux/types.h"
typedef __kernel_dev_t dev_t;
#line 12 "/usr/local/ddv/models/con2/include/linux/types.h"
typedef __kernel_ino_t ino_t;
#line 13 "/usr/local/ddv/models/con2/include/linux/types.h"
typedef __kernel_mode_t mode_t;
#line 30 "/usr/local/ddv/models/con2/include/linux/types.h"
typedef long long loff_t;
#line 38 "/usr/local/ddv/models/con2/include/linux/types.h"
typedef __kernel_size_t size_t;
#line 43 "/usr/local/ddv/models/con2/include/linux/types.h"
typedef __kernel_ssize_t ssize_t;
#line 44 "/usr/local/ddv/models/con2/include/ddverify/satabs.h"
struct __pthread_t_struct {
   int id ;
};
#line 49 "/usr/local/ddv/models/con2/include/ddverify/satabs.h"
struct __pthread_attr_t_struct {
   int dummy ;
};
#line 54 "/usr/local/ddv/models/con2/include/ddverify/satabs.h"
typedef struct __pthread_t_struct pthread_t;
#line 55 "/usr/local/ddv/models/con2/include/ddverify/satabs.h"
typedef struct __pthread_attr_t_struct pthread_attr_t;
#line 6 "/usr/local/ddv/models/con2/include/asm/atomic.h"
typedef int atomic_t;
#line 67 "/usr/local/ddv/models/con2/include/linux/gfp.h"
struct page;
#line 4 "/usr/local/ddv/models/con2/include/linux/dcache.h"
struct inode;
#line 4 "/usr/local/ddv/models/con2/include/linux/dcache.h"
struct dentry {
   struct inode *d_inode ;
};
#line 83 "/usr/local/ddv/models/con2/include/linux/fs.h"
struct iovec;
#line 84
struct poll_table_struct;
#line 85
struct vm_area_struct;
#line 90 "/usr/local/ddv/models/con2/include/linux/fs.h"
struct address_space {
   struct inode *host ;
};
#line 94
struct file_operations;
#line 94 "/usr/local/ddv/models/con2/include/linux/fs.h"
struct file {
   struct dentry *f_dentry ;
   struct file_operations *f_op ;
   atomic_t f_count ;
   unsigned int f_flags ;
   mode_t f_mode ;
   loff_t f_pos ;
   void *private_data ;
   struct address_space *f_mapping ;
};
#line 105
struct gendisk;
#line 105 "/usr/local/ddv/models/con2/include/linux/fs.h"
struct block_device {
   struct inode *bd_inode ;
   struct gendisk *bd_disk ;
   struct block_device *bd_contains ;
   unsigned int bd_block_size ;
};
#line 113
struct cdev;
#line 113 "/usr/local/ddv/models/con2/include/linux/fs.h"
struct inode {
   umode_t i_mode ;
   struct block_device *i_bdev ;
   dev_t i_rdev ;
   loff_t i_size ;
   struct cdev *i_cdev ;
};
#line 122 "/usr/local/ddv/models/con2/include/linux/fs.h"
struct __anonstruct_read_descriptor_t_4 {
   size_t written ;
   size_t count ;
};
#line 122 "/usr/local/ddv/models/con2/include/linux/fs.h"
typedef struct __anonstruct_read_descriptor_t_4 read_descriptor_t;
#line 130 "/usr/local/ddv/models/con2/include/linux/fs.h"
struct file_lock {
   int something ;
};
#line 134
struct module;
#line 134 "/usr/local/ddv/models/con2/include/linux/fs.h"
struct file_operations {
   struct module *owner ;
   loff_t (*llseek)(struct file * , loff_t  , int  ) ;
   ssize_t (*read)(struct file * , char * , size_t  , loff_t * ) ;
   ssize_t (*write)(struct file * , char const   * , size_t  , loff_t * ) ;
   int (*readdir)(struct file * , void * , int (*)(void * , char const   * , int  ,
                                                   loff_t  , ino_t  , unsigned int  ) ) ;
   unsigned int (*poll)(struct file * , struct poll_table_struct * ) ;
   int (*ioctl)(struct inode * , struct file * , unsigned int  , unsigned long  ) ;
   long (*unlocked_ioctl)(struct file * , unsigned int  , unsigned long  ) ;
   long (*compat_ioctl)(struct file * , unsigned int  , unsigned long  ) ;
   int (*mmap)(struct file * , struct vm_area_struct * ) ;
   int (*open)(struct inode * , struct file * ) ;
   int (*flush)(struct file * ) ;
   int (*release)(struct inode * , struct file * ) ;
   int (*fsync)(struct file * , struct dentry * , int datasync ) ;
   int (*fasync)(int  , struct file * , int  ) ;
   int (*lock)(struct file * , int  , struct file_lock * ) ;
   ssize_t (*readv)(struct file * , struct iovec  const  * , unsigned long  , loff_t * ) ;
   ssize_t (*writev)(struct file * , struct iovec  const  * , unsigned long  , loff_t * ) ;
   ssize_t (*sendfile)(struct file * , loff_t * , size_t  , int (*)(read_descriptor_t * ,
                                                                    struct page * ,
                                                                    unsigned long  ,
                                                                    unsigned long  ) ,
                       void * ) ;
   ssize_t (*sendpage)(struct file * , struct page * , int  , size_t  , loff_t * ,
                       int  ) ;
   unsigned long (*get_unmapped_area)(struct file * , unsigned long  , unsigned long  ,
                                      unsigned long  , unsigned long  ) ;
   int (*check_flags)(int  ) ;
   int (*dir_notify)(struct file *filp , unsigned long arg ) ;
   int (*flock)(struct file * , int  , struct file_lock * ) ;
   int (*open_exec)(struct inode * ) ;
};
#line 4 "/usr/local/ddv/models/con2/include/linux/cdev.h"
struct cdev {
   struct module *owner ;
   struct file_operations *ops ;
   dev_t dev ;
   unsigned int count ;
};
#line 13 "/usr/local/ddv/models/con2/include/ddverify/cdev.h"
struct ddv_cdev {
   struct cdev *cdevp ;
   struct file filp ;
   struct inode inode ;
   int open ;
};
#line 30 "/usr/local/ddv/models/con2/include/asm/types.h"
typedef unsigned long long u64;
#line 91 "/usr/local/ddv/models/con2/include/linux/types.h"
typedef unsigned long sector_t;
#line 15 "/usr/local/ddv/models/con2/include/ddverify/pthread.h"
struct __pthread_t_struct___0 {
   int id ;
};
#line 25 "/usr/local/ddv/models/con2/include/ddverify/pthread.h"
struct __pthread_mutex_t_struct {
   _Bool locked ;
};
#line 30 "/usr/local/ddv/models/con2/include/ddverify/pthread.h"
struct __pthread_mutexattr_t_struct {
   int dummy ;
};
#line 50 "/usr/local/ddv/models/con2/include/ddverify/pthread.h"
typedef struct __pthread_t_struct___0 pthread_t___0;
#line 52 "/usr/local/ddv/models/con2/include/ddverify/pthread.h"
typedef struct __pthread_mutex_t_struct pthread_mutex_t;
#line 53 "/usr/local/ddv/models/con2/include/ddverify/pthread.h"
typedef struct __pthread_mutexattr_t_struct pthread_mutexattr_t;
#line 9 "/usr/local/ddv/models/con2/include/linux/list.h"
struct list_head {
   struct list_head *next ;
   struct list_head *prev ;
};
#line 4 "/usr/local/ddv/models/con2/include/linux/spinlock_types.h"
struct __anonstruct_spinlock_t_9 {
   int init ;
   int locked ;
};
#line 4 "/usr/local/ddv/models/con2/include/linux/spinlock_types.h"
typedef struct __anonstruct_spinlock_t_9 spinlock_t;
#line 4 "/usr/local/ddv/models/con2/include/linux/timer.h"
struct timer_list {
   unsigned long expires ;
   void (*function)(unsigned long  ) ;
   unsigned long data ;
   short __ddv_active ;
   short __ddv_init ;
};
#line 82 "/usr/local/ddv/models/con2/include/linux/fs.h"
struct hd_geometry;
#line 168 "/usr/local/ddv/models/con2/include/linux/fs.h"
struct block_device_operations {
   int (*open)(struct inode * , struct file * ) ;
   int (*release)(struct inode * , struct file * ) ;
   int (*ioctl)(struct inode * , struct file * , unsigned int  , unsigned long  ) ;
   long (*unlocked_ioctl)(struct file * , unsigned int  , unsigned long  ) ;
   long (*compat_ioctl)(struct file * , unsigned int  , unsigned long  ) ;
   int (*direct_access)(struct block_device * , sector_t  , unsigned long * ) ;
   int (*media_changed)(struct gendisk * ) ;
   int (*revalidate_disk)(struct gendisk * ) ;
   int (*getgeo)(struct block_device * , struct hd_geometry * ) ;
   struct module *owner ;
};
#line 18 "/usr/local/ddv/models/con2/include/linux/ioport.h"
struct resource {
   char const   *name ;
   unsigned long start ;
   unsigned long end ;
   unsigned long flags ;
};
#line 24 "/usr/local/ddv/models/con2/include/linux/module.h"
struct module {
   int something ;
};
#line 8 "/usr/local/ddv/models/con2/include/linux/pm.h"
struct pm_message {
   int event ;
};
#line 8 "/usr/local/ddv/models/con2/include/linux/pm.h"
typedef struct pm_message pm_message_t;
#line 25 "/usr/local/ddv/models/con2/include/linux/device.h"
struct device {
   void *driver_data ;
   void (*release)(struct device *dev ) ;
};
#line 17 "/usr/local/ddv/models/con2/include/linux/genhd.h"
struct request_queue;
#line 17 "/usr/local/ddv/models/con2/include/linux/genhd.h"
struct gendisk {
   int major ;
   int first_minor ;
   int minors ;
   char disk_name[32] ;
   struct block_device_operations *fops ;
   struct request_queue *queue ;
   void *private_data ;
   int flags ;
   struct device *driverfs_dev ;
   char devfs_name[64] ;
};
#line 12 "/usr/local/ddv/models/con2/include/linux/workqueue.h"
struct work_struct {
   unsigned long pending ;
   void (*func)(void * ) ;
   void *data ;
   int init ;
};
#line 9 "/usr/local/ddv/models/con2/include/linux/mm_types.h"
struct page {
   int something ;
};
#line 4 "/usr/local/ddv/models/con2/include/asm/ptrace.h"
struct pt_regs {
   int something ;
};
#line 28 "/usr/local/ddv/models/con2/include/linux/interrupt.h"
typedef int irqreturn_t;
#line 34 "/usr/local/ddv/models/con2/include/linux/interrupt.h"
struct tasklet_struct {
   atomic_t count ;
   void (*func)(unsigned long  ) ;
   unsigned long data ;
   int init ;
};
#line 11 "/usr/local/ddv/models/con2/include/linux/backing-dev.h"
struct backing_dev_info {
   unsigned long ra_pages ;
   unsigned long state ;
   unsigned int capabilities ;
};
#line 6 "/usr/local/ddv/models/con2/include/linux/bio.h"
struct bio_vec {
   struct page *bv_page ;
   unsigned int bv_len ;
   unsigned int bv_offset ;
};
#line 13
struct bio;
#line 14 "/usr/local/ddv/models/con2/include/linux/bio.h"
typedef int bio_end_io_t(struct bio * , unsigned int  , int  );
#line 17 "/usr/local/ddv/models/con2/include/linux/bio.h"
struct bio {
   sector_t bi_sector ;
   struct bio *bi_next ;
   struct block_device *bi_bdev ;
   unsigned long bi_flags ;
   unsigned long bi_rw ;
   unsigned short bi_vcnt ;
   unsigned short bi_idx ;
   unsigned short bi_phys_segments ;
   unsigned int bi_size ;
   struct bio_vec *bi_io_vec ;
   bio_end_io_t *bi_end_io ;
   void *bi_private ;
};
#line 4 "/usr/local/ddv/models/con2/include/linux/elevator.h"
struct request;
#line 23 "/usr/local/ddv/models/con2/include/linux/blkdev.h"
typedef struct request_queue request_queue_t;
#line 25 "/usr/local/ddv/models/con2/include/linux/blkdev.h"
typedef void request_fn_proc(request_queue_t *q );
#line 26 "/usr/local/ddv/models/con2/include/linux/blkdev.h"
typedef int make_request_fn(request_queue_t *q , struct bio *bio );
#line 27 "/usr/local/ddv/models/con2/include/linux/blkdev.h"
typedef void unplug_fn(request_queue_t * );
#line 32
enum rq_cmd_type_bits {
    REQ_TYPE_FS = 1,
    REQ_TYPE_BLOCK_PC = 2,
    REQ_TYPE_SENSE = 3,
    REQ_TYPE_PM_SUSPEND = 4,
    REQ_TYPE_PM_RESUME = 5,
    REQ_TYPE_PM_SHUTDOWN = 6,
    REQ_TYPE_FLUSH = 7,
    REQ_TYPE_SPECIAL = 8,
    REQ_TYPE_LINUX_BLOCK = 9,
    REQ_TYPE_ATA_CMD = 10,
    REQ_TYPE_ATA_TASK = 11,
    REQ_TYPE_ATA_TASKFILE = 12,
    REQ_TYPE_ATA_PC = 13
} ;
#line 54 "/usr/local/ddv/models/con2/include/linux/blkdev.h"
struct request_queue {
   request_fn_proc *request_fn ;
   make_request_fn *make_request_fn ;
   unplug_fn *unplug_fn ;
   struct backing_dev_info backing_dev_info ;
   void *queuedata ;
   unsigned long queue_flags ;
   spinlock_t *queue_lock ;
   unsigned short hardsect_size ;
   int __ddv_genhd_no ;
   int __ddv_queue_alive ;
};
#line 90 "/usr/local/ddv/models/con2/include/linux/blkdev.h"
struct request {
   struct list_head queuelist ;
   struct list_head donelist ;
   request_queue_t *q ;
   unsigned long flags ;
   unsigned int cmd_flags ;
   enum rq_cmd_type_bits cmd_type ;
   struct bio *bio ;
   void *completion_data ;
   struct gendisk *rq_disk ;
   sector_t sector ;
   unsigned long nr_sectors ;
   unsigned int current_nr_sectors ;
   char *buffer ;
   int errors ;
   unsigned short nr_phys_segments ;
   unsigned char cmd[16] ;
};
#line 15 "/usr/local/ddv/models/con2/include/ddverify/genhd.h"
struct ddv_genhd {
   struct gendisk *gd ;
   struct inode inode ;
   struct file file ;
   struct request current_request ;
   int requests_open ;
};
#line 6 "/usr/local/ddv/models/con2/include/linux/mod_devicetable.h"
typedef unsigned long kernel_ulong_t;
#line 10 "/usr/local/ddv/models/con2/include/linux/mod_devicetable.h"
struct pci_device_id {
   __u32 vendor ;
   __u32 device ;
   __u32 subvendor ;
   __u32 subdevice ;
   __u32 class ;
   __u32 class_mask ;
   kernel_ulong_t driver_data ;
};
#line 40 "/usr/local/ddv/models/con2/include/linux/pci.h"
typedef int pci_power_t;
#line 43
struct pci_bus;
#line 43 "/usr/local/ddv/models/con2/include/linux/pci.h"
struct pci_dev {
   struct pci_bus *bus ;
   unsigned int devfn ;
   unsigned short vendor ;
   unsigned short device ;
   u64 dma_mask ;
   struct device dev ;
   unsigned int irq ;
   struct resource resource[12] ;
};
#line 62 "/usr/local/ddv/models/con2/include/linux/pci.h"
struct pci_bus {
   unsigned char number ;
};
#line 67 "/usr/local/ddv/models/con2/include/linux/pci.h"
struct pci_driver {
   char *name ;
   struct pci_device_id  const  *id_table ;
   int (*probe)(struct pci_dev *dev , struct pci_device_id  const  *id ) ;
   void (*remove)(struct pci_dev *dev ) ;
   int (*suspend)(struct pci_dev *dev , pm_message_t state ) ;
   int (*resume)(struct pci_dev *dev ) ;
   int (*enable_wake)(struct pci_dev *dev , pci_power_t state , int enable ) ;
   void (*shutdown)(struct pci_dev *dev ) ;
};
#line 6 "/usr/local/ddv/models/con2/include/ddverify/pci.h"
struct ddv_pci_driver {
   struct pci_driver *pci_driver ;
   struct pci_dev pci_dev ;
   unsigned int no_pci_device_id ;
   int dev_initialized ;
};
#line 9 "/usr/local/ddv/models/con2/include/ddverify/interrupt.h"
struct registered_irq {
   irqreturn_t (*handler)(int  , void * , struct pt_regs * ) ;
   void *dev_id ;
};
#line 10 "/usr/local/ddv/models/con2/include/ddverify/tasklet.h"
struct ddv_tasklet {
   struct tasklet_struct *tasklet ;
   unsigned short is_running ;
};
#line 10 "/usr/local/ddv/models/con2/include/ddverify/timer.h"
struct ddv_timer {
   struct timer_list *timer ;
};
#line 88 "/usr/local/ddv/models/con2/include/linux/types.h"
typedef unsigned int gfp_t;
#line 7 "/usr/local/ddv/models/con2/include/asm/types.h"
typedef unsigned char __u8;
#line 16 "/usr/local/ddv/models/con2/include/linux/wait.h"
struct __wait_queue_head {
   int number_process_waiting ;
   int wakeup ;
   int init ;
};
#line 22 "/usr/local/ddv/models/con2/include/linux/wait.h"
typedef struct __wait_queue_head wait_queue_head_t;
#line 132 "aztcd.h"
struct msf {
   unsigned char min ;
   unsigned char sec ;
   unsigned char frame ;
};
#line 138 "aztcd.h"
struct azt_Play_msf {
   struct msf start ;
   struct msf end ;
};
#line 143 "aztcd.h"
struct azt_DiskInfo {
   unsigned char first ;
   unsigned char next ;
   unsigned char last ;
   struct msf diskLength ;
   struct msf firstTrack ;
   unsigned char multi ;
   struct msf nextSession ;
   struct msf lastSession ;
   unsigned char xa ;
   unsigned char audio ;
};
#line 156 "aztcd.h"
struct azt_Toc {
   unsigned char ctrl_addr ;
   unsigned char track ;
   unsigned char pointIndex ;
   struct msf trackTime ;
   struct msf diskTime ;
};
#line 153 "cdrom.h"
struct cdrom_msf0 {
   __u8 minute ;
   __u8 second ;
   __u8 frame ;
};
#line 161 "cdrom.h"
union cdrom_addr {
   struct cdrom_msf0 msf ;
   int lba ;
};
#line 168 "cdrom.h"
struct cdrom_msf {
   __u8 cdmsf_min0 ;
   __u8 cdmsf_sec0 ;
   __u8 cdmsf_frame0 ;
   __u8 cdmsf_min1 ;
   __u8 cdmsf_sec1 ;
   __u8 cdmsf_frame1 ;
};
#line 179 "cdrom.h"
struct cdrom_ti {
   __u8 cdti_trk0 ;
   __u8 cdti_ind0 ;
   __u8 cdti_trk1 ;
   __u8 cdti_ind1 ;
};
#line 188 "cdrom.h"
struct cdrom_tochdr {
   __u8 cdth_trk0 ;
   __u8 cdth_trk1 ;
};
#line 195 "cdrom.h"
struct cdrom_volctrl {
   __u8 channel0 ;
   __u8 channel1 ;
   __u8 channel2 ;
   __u8 channel3 ;
};
#line 204 "cdrom.h"
struct cdrom_subchnl {
   __u8 cdsc_format ;
   __u8 cdsc_audiostatus ;
   __u8 cdsc_adr : 4 ;
   __u8 cdsc_ctrl : 4 ;
   __u8 cdsc_trk ;
   __u8 cdsc_ind ;
   union cdrom_addr cdsc_absaddr ;
   union cdrom_addr cdsc_reladdr ;
};
#line 218 "cdrom.h"
struct cdrom_tocentry {
   __u8 cdte_track ;
   __u8 cdte_adr : 4 ;
   __u8 cdte_ctrl : 4 ;
   __u8 cdte_format ;
   union cdrom_addr cdte_addr ;
   __u8 cdte_datamode ;
};
#line 246 "cdrom.h"
struct cdrom_multisession {
   union cdrom_addr addr ;
   __u8 xa_flag ;
   __u8 addr_format ;
};
#line 248 "aztcd.c"
enum azt_state_e {
    AZT_S_IDLE = 0,
    AZT_S_START = 1,
    AZT_S_MODE = 2,
    AZT_S_READ = 3,
    AZT_S_DATA = 4,
    AZT_S_STOP = 5,
    AZT_S_STOPPING = 6
} ;
#line 256
enum azt_read_modes {
    AZT_MODE_0 = 0,
    AZT_MODE_1 = 1,
    AZT_MODE_2 = 2
} ;
#line 34 "/usr/local/ddv/models/con2/include/linux/miscdevice.h"
struct miscdevice {
   int minor ;
   char const   *name ;
   struct file_operations *fops ;
};
#line 7 "/usr/local/ddv/models/con2/include/linux/proc_fs.h"
struct proc_dir_entry {
   int something ;
};
#line 20 "/usr/local/ddv/models/con2/include/linux/mutex.h"
struct mutex {
   int locked ;
   int init ;
};
#line 4 "/usr/local/ddv/models/con2/include/asm/semaphore.h"
struct semaphore {
   int init ;
   int locked ;
};
#line 7 "/usr/local/ddv/models/con2/include/asm/posix_types.h"
typedef long __kernel_off_t;
#line 15 "/usr/local/ddv/models/con2/include/linux/types.h"
typedef __kernel_off_t off_t;
#line 6 "/usr/local/ddv/models/con2/include/asm/termbits.h"
typedef unsigned char cc_t;
#line 8 "/usr/local/ddv/models/con2/include/asm/termbits.h"
typedef unsigned int tcflag_t;
#line 11 "/usr/local/ddv/models/con2/include/asm/termbits.h"
struct termios {
   tcflag_t c_iflag ;
   tcflag_t c_oflag ;
   tcflag_t c_cflag ;
   tcflag_t c_lflag ;
   cc_t c_line ;
   cc_t c_cc[19] ;
};
#line 9 "/usr/local/ddv/models/con2/include/linux/tty_driver.h"
struct tty_struct;
#line 12 "/usr/local/ddv/models/con2/include/linux/tty_driver.h"
struct tty_operations {
   int (*open)(struct tty_struct *tty , struct file *filp ) ;
   void (*close)(struct tty_struct *tty , struct file *filp ) ;
   int (*write)(struct tty_struct *tty , unsigned char const   *buf , int count ) ;
   void (*put_char)(struct tty_struct *tty , unsigned char ch ) ;
   void (*flush_chars)(struct tty_struct *tty ) ;
   int (*write_room)(struct tty_struct *tty ) ;
   int (*chars_in_buffer)(struct tty_struct *tty ) ;
   int (*ioctl)(struct tty_struct *tty , struct file *file , unsigned int cmd , unsigned long arg ) ;
   void (*set_termios)(struct tty_struct *tty , struct termios *old ) ;
   void (*throttle)(struct tty_struct *tty ) ;
   void (*unthrottle)(struct tty_struct *tty ) ;
   void (*stop)(struct tty_struct *tty ) ;
   void (*start)(struct tty_struct *tty ) ;
   void (*hangup)(struct tty_struct *tty ) ;
   void (*break_ctl)(struct tty_struct *tty , int state ) ;
   void (*flush_buffer)(struct tty_struct *tty ) ;
   void (*set_ldisc)(struct tty_struct *tty ) ;
   void (*wait_until_sent)(struct tty_struct *tty , int timeout ) ;
   void (*send_xchar)(struct tty_struct *tty , char ch ) ;
   int (*read_proc)(char *page , char **start , off_t off , int count , int *eof ,
                    void *data ) ;
   int (*write_proc)(struct file *file , char const   *buffer , unsigned long count ,
                     void *data ) ;
   int (*tiocmget)(struct tty_struct *tty , struct file *file ) ;
   int (*tiocmset)(struct tty_struct *tty , struct file *file , unsigned int set ,
                   unsigned int clear ) ;
};
#line 43 "/usr/local/ddv/models/con2/include/linux/tty_driver.h"
struct tty_driver {
   int magic ;
   struct cdev cdev ;
   struct module *owner ;
   char const   *driver_name ;
   char const   *name ;
   int name_base ;
   int major ;
   int minor_start ;
   int minor_num ;
   int num ;
   short type ;
   short subtype ;
   struct termios init_termios ;
   int flags ;
   int refcount ;
   struct proc_dir_entry *proc_entry ;
   int (*open)(struct tty_struct *tty , struct file *filp ) ;
   void (*close)(struct tty_struct *tty , struct file *filp ) ;
   int (*write)(struct tty_struct *tty , unsigned char const   *buf , int count ) ;
   void (*put_char)(struct tty_struct *tty , unsigned char ch ) ;
   void (*flush_chars)(struct tty_struct *tty ) ;
   int (*write_room)(struct tty_struct *tty ) ;
   int (*chars_in_buffer)(struct tty_struct *tty ) ;
   int (*ioctl)(struct tty_struct *tty , struct file *file , unsigned int cmd , unsigned long arg ) ;
   void (*set_termios)(struct tty_struct *tty , struct termios *old ) ;
   void (*throttle)(struct tty_struct *tty ) ;
   void (*unthrottle)(struct tty_struct *tty ) ;
   void (*stop)(struct tty_struct *tty ) ;
   void (*start)(struct tty_struct *tty ) ;
   void (*hangup)(struct tty_struct *tty ) ;
   void (*break_ctl)(struct tty_struct *tty , int state ) ;
   void (*flush_buffer)(struct tty_struct *tty ) ;
   void (*set_ldisc)(struct tty_struct *tty ) ;
   void (*wait_until_sent)(struct tty_struct *tty , int timeout ) ;
   void (*send_xchar)(struct tty_struct *tty , char ch ) ;
   int (*read_proc)(char *page , char **start , off_t off , int count , int *eof ,
                    void *data ) ;
   int (*write_proc)(struct file *file , char const   *buffer , unsigned long count ,
                     void *data ) ;
   int (*tiocmget)(struct tty_struct *tty , struct file *file ) ;
   int (*tiocmset)(struct tty_struct *tty , struct file *file , unsigned int set ,
                   unsigned int clear ) ;
};
#line 113 "/usr/local/ddv/models/con2/include/linux/tty.h"
struct tty_struct {
   int magic ;
   struct tty_driver *driver ;
   int index ;
   struct termios *termios ;
   struct termios *termios_locked ;
   char name[64] ;
   unsigned long flags ;
   int count ;
   unsigned char stopped : 1 ;
   unsigned char hw_stopped : 1 ;
   unsigned char flow_stopped : 1 ;
   unsigned char packet : 1 ;
   unsigned int receive_room ;
   wait_queue_head_t write_wait ;
   wait_queue_head_t read_wait ;
   void *disc_data ;
   void *driver_data ;
   unsigned char closing : 1 ;
};
#line 7 "/usr/local/ddv/models/con2/include/ddverify/tty.h"
struct ddv_tty_driver {
   struct tty_driver driver ;
   unsigned short allocated ;
   unsigned short registered ;
};
#line 1 "cdev.o"
#pragma merger("0","/tmp/cil-4nZTjFvY.i","")
#line 11 "/usr/local/ddv/models/con2/include/ddverify/ddverify.h"
int current_execution_context  ;
#line 42 "/usr/local/ddv/models/con2/include/ddverify/ddverify.h"
int (*_ddv_module_init)(void)  ;
#line 43 "/usr/local/ddv/models/con2/include/ddverify/ddverify.h"
void (*_ddv_module_exit)(void)  ;
#line 15 "/usr/local/ddv/models/con2/include/ddverify/satabs.h"
extern unsigned short nondet_ushort() ;
#line 16
extern int nondet_int() ;
#line 17
extern unsigned int nondet_uint() ;
#line 19
extern unsigned long nondet_ulong() ;
#line 20
extern char nondet_char() ;
#line 23
extern loff_t nondet_loff_t() ;
#line 24
extern size_t nondet_size_t() ;
#line 57
extern pthread_t nondet_pthread_t() ;
#line 59 "/usr/local/ddv/models/con2/include/ddverify/satabs.h"
__inline extern int pthread_create(pthread_t *__threadp , pthread_attr_t const   *__attr ,
                                   void *(*__start_routine)(void * ) , void *__arg ) 
{ 


  {
#line 65
  *__threadp = nondet_pthread_t();
#line 66
  (*__start_routine)(__arg);
#line 67
  return (0);
}
}
#line 7 "/usr/local/ddv/models/con2/include/linux/jiffies.h"
unsigned long jiffies  ;
#line 12 "/usr/local/ddv/models/con2/include/ddverify/fixed_cdev.h"
struct cdev fixed_cdev[10]  ;
#line 13 "/usr/local/ddv/models/con2/include/ddverify/fixed_cdev.h"
int fixed_cdev_used  =    0;
#line 11 "/usr/local/ddv/models/con2/include/ddverify/cdev.h"
short number_cdev_registered  =    (short)0;
#line 22 "/usr/local/ddv/models/con2/include/ddverify/cdev.h"
struct ddv_cdev cdev_registered[10]  ;
#line 24
void call_cdev_functions(void) ;
#line 21 "/usr/local/ddv/models/con2/src/ddverify/cdev.c"
extern int ( /* missing proto */  __CPROVER_assume)() ;
#line 5 "/usr/local/ddv/models/con2/src/ddverify/cdev.c"
void call_cdev_functions(void) 
{ 
  int cdev_no ;
  int result ;
  loff_t loff_t_value ;
  int int_value ;
  unsigned int uint_value ;
  unsigned long ulong_value ;
  char char_value ;
  size_t size_t_value ;
  unsigned short tmp ;
  int tmp___0 ;
  unsigned short tmp___1 ;

  {
#line 16
  if ((int )number_cdev_registered == 0) {
#line 17
    return;
  }
#line 20
  tmp = nondet_ushort();
#line 20
  cdev_no = (int )tmp;
#line 21
  if (0 <= cdev_no) {
#line 21
    if (cdev_no < (int )number_cdev_registered) {
#line 21
      tmp___0 = 1;
    } else {
#line 21
      tmp___0 = 0;
    }
  } else {
#line 21
    tmp___0 = 0;
  }
#line 21
  __CPROVER_assume(tmp___0);
#line 23
  tmp___1 = nondet_ushort();
#line 23
  switch ((int )tmp___1) {
  case 0: 
#line 25
  if (((cdev_registered[cdev_no].cdevp)->ops)->llseek) {
#line 26
    loff_t_value = nondet_loff_t();
#line 27
    int_value = nondet_int();
#line 29
    (*(((cdev_registered[cdev_no].cdevp)->ops)->llseek))(& cdev_registered[cdev_no].filp,
                                                         loff_t_value, int_value);
  }
#line 33
  break;
  case 1: 
#line 35
  if (((cdev_registered[cdev_no].cdevp)->ops)->read) {
#line 36
    char_value = nondet_char();
#line 37
    size_t_value = nondet_size_t();
#line 39
    (*(((cdev_registered[cdev_no].cdevp)->ops)->read))(& cdev_registered[cdev_no].filp,
                                                       & char_value, size_t_value,
                                                       & loff_t_value);
  }
#line 44
  break;
  case 2: 
#line 47
  break;
  case 3: 
#line 49
  if (((cdev_registered[cdev_no].cdevp)->ops)->write) {
#line 50
    char_value = nondet_char();
#line 51
    size_t_value = nondet_size_t();
#line 53
    (*(((cdev_registered[cdev_no].cdevp)->ops)->write))(& cdev_registered[cdev_no].filp,
                                                        (char const   *)(& char_value),
                                                        size_t_value, & loff_t_value);
  }
#line 58
  break;
  case 4: 
#line 61
  break;
  case 5: 
#line 64
  break;
  case 6: 
#line 67
  break;
  case 7: 
#line 69
  if (((cdev_registered[cdev_no].cdevp)->ops)->ioctl) {
#line 70
    uint_value = nondet_uint();
#line 71
    ulong_value = nondet_ulong();
#line 73
    (*(((cdev_registered[cdev_no].cdevp)->ops)->ioctl))(& cdev_registered[cdev_no].inode,
                                                        & cdev_registered[cdev_no].filp,
                                                        uint_value, ulong_value);
  }
#line 79
  break;
  case 8: 
#line 82
  break;
  case 9: 
#line 85
  break;
  case 10: 
#line 88
  break;
  case 11: 
#line 90
  if (((cdev_registered[cdev_no].cdevp)->ops)->open) {
#line 90
    if (! cdev_registered[cdev_no].open) {
#line 92
      result = (*(((cdev_registered[cdev_no].cdevp)->ops)->open))(& cdev_registered[cdev_no].inode,
                                                                  & cdev_registered[cdev_no].filp);
#line 95
      if (! result) {
#line 96
        cdev_registered[cdev_no].open = 1;
      }
    }
  }
#line 99
  break;
  case 12: 
#line 102
  break;
  case 13: 
#line 104
  if (((cdev_registered[cdev_no].cdevp)->ops)->release) {
#line 104
    if (cdev_registered[cdev_no].open) {
#line 106
      result = (*(((cdev_registered[cdev_no].cdevp)->ops)->release))(& cdev_registered[cdev_no].inode,
                                                                     & cdev_registered[cdev_no].filp);
#line 109
      if (! result) {
#line 110
        cdev_registered[cdev_no].open = 0;
      }
    }
  }
#line 113
  break;
  case 14: 
#line 116
  break;
  case 15: 
#line 119
  break;
  case 16: 
#line 122
  break;
  case 17: 
#line 125
  break;
  case 18: 
#line 128
  break;
  case 19: 
#line 131
  break;
  case 20: 
#line 134
  break;
  case 21: 
#line 137
  break;
  case 22: 
#line 140
  break;
  case 23: 
#line 143
  break;
  case 24: 
#line 146
  break;
  case 25: 
#line 149
  break;
  case 26: 
#line 152
  break;
  default: 
#line 154
  break;
  }
#line 156
  return;
}
}
#line 1 "char_dev.o"
#pragma merger("0","/tmp/cil-cqI_dtpc.i","")
#line 8 "/usr/local/ddv/models/con2/include/linux/slab.h"
extern void kfree(void const   * ) ;
#line 195 "/usr/local/ddv/models/con2/include/linux/fs.h"
__inline int alloc_chrdev_region(dev_t *dev , unsigned int baseminor , unsigned int count ,
                                 char const   *name ) ;
#line 196
__inline int register_chrdev_region(dev_t from , unsigned int count , char const   *name ) ;
#line 199
__inline int register_chrdev(unsigned int major , char const   *name , struct file_operations *fops ) ;
#line 200
__inline int unregister_chrdev(unsigned int major , char const   *name ) ;
#line 11 "/usr/local/ddv/models/con2/include/linux/cdev.h"
__inline void cdev_init(struct cdev *cdev , struct file_operations *fops ) ;
#line 13
__inline struct cdev *cdev_alloc(void) ;
#line 17
__inline int cdev_add(struct cdev *p , dev_t dev , unsigned int count ) ;
#line 19
__inline void cdev_del(struct cdev *p ) ;
#line 9 "/usr/local/ddv/models/con2/src/linux/fs/char_dev.c"
__inline int alloc_chrdev_region(dev_t *dev , unsigned int baseminor , unsigned int count ,
                                 char const   *name ) 
{ 
  int major ;
  int return_value ;
  int tmp ;
  int tmp___0 ;
  unsigned int tmp___1 ;

  {
#line 12
  tmp = nondet_int();
#line 12
  return_value = tmp;
#line 13
  if (return_value == 0) {
#line 13
    tmp___0 = 1;
  } else
#line 13
  if (return_value == -1) {
#line 13
    tmp___0 = 1;
  } else {
#line 13
    tmp___0 = 0;
  }
#line 13
  __CPROVER_assume(tmp___0);
#line 15
  if (return_value == 0) {
#line 16
    tmp___1 = nondet_uint();
#line 16
    major = (int )tmp___1;
#line 17
    *dev = (unsigned int )(major << 20) | baseminor;
  }
#line 20
  return (return_value);
}
}
#line 23 "/usr/local/ddv/models/con2/src/linux/fs/char_dev.c"
__inline int register_chrdev_region(dev_t from , unsigned int count , char const   *name ) 
{ 
  int return_value ;
  int tmp ;
  int tmp___0 ;

  {
#line 25
  tmp = nondet_int();
#line 25
  return_value = tmp;
#line 26
  if (return_value == 0) {
#line 26
    tmp___0 = 1;
  } else
#line 26
  if (return_value == -1) {
#line 26
    tmp___0 = 1;
  } else {
#line 26
    tmp___0 = 0;
  }
#line 26
  __CPROVER_assume(tmp___0);
#line 28
  return (return_value);
}
}
#line 33 "/usr/local/ddv/models/con2/src/linux/fs/char_dev.c"
__inline int register_chrdev(unsigned int major , char const   *name , struct file_operations *fops ) 
{ 
  struct cdev *cdev ;
  int err ;
  int tmp ;

  {
#line 39
  tmp = register_chrdev_region((dev_t )0, 256U, name);
#line 39
  major = (unsigned int )tmp;
#line 41
  cdev = cdev_alloc();
#line 42
  cdev->owner = fops->owner;
#line 43
  cdev->ops = fops;
#line 45
  err = cdev_add(cdev, major << 20, 256U);
#line 47
  if (err) {
#line 48
    kfree((void const   *)cdev);
#line 49
    return (err);
  }
#line 52
  return ((int )major);
}
}
#line 55 "/usr/local/ddv/models/con2/src/linux/fs/char_dev.c"
__inline int unregister_chrdev(unsigned int major , char const   *name ) 
{ 


  {
#line 57
  return (0);
}
}
#line 60 "/usr/local/ddv/models/con2/src/linux/fs/char_dev.c"
__inline struct cdev *cdev_alloc(void) 
{ 
  int tmp ;

  {
#line 62
  if (fixed_cdev_used < 10) {
#line 63
    tmp = fixed_cdev_used;
#line 63
    fixed_cdev_used ++;
#line 63
    return (& fixed_cdev[tmp]);
  }
#line 65
  return ((struct cdev *)0);
}
}
#line 67 "/usr/local/ddv/models/con2/src/linux/fs/char_dev.c"
__inline void cdev_init(struct cdev *cdev , struct file_operations *fops ) 
{ 


  {
#line 69
  cdev->ops = fops;
#line 70
  return;
}
}
#line 72 "/usr/local/ddv/models/con2/src/linux/fs/char_dev.c"
__inline int cdev_add(struct cdev *p , dev_t dev , unsigned int count ) 
{ 
  int return_value ;
  int tmp ;
  int tmp___0 ;

  {
#line 74
  p->dev = dev;
#line 75
  p->count = count;
#line 77
  tmp = nondet_int();
#line 77
  return_value = tmp;
#line 78
  if (return_value == 0) {
#line 78
    tmp___0 = 1;
  } else
#line 78
  if (return_value == -1) {
#line 78
    tmp___0 = 1;
  } else {
#line 78
    tmp___0 = 0;
  }
#line 78
  __CPROVER_assume(tmp___0);
#line 80
  if (return_value == 0) {
#line 81
    if ((int )number_cdev_registered < 10) {
#line 83
      cdev_registered[number_cdev_registered].cdevp = p;
#line 84
      cdev_registered[number_cdev_registered].inode.i_rdev = dev;
#line 85
      cdev_registered[number_cdev_registered].inode.i_cdev = p;
#line 86
      cdev_registered[number_cdev_registered].open = 0;
#line 88
      number_cdev_registered = (short )((int )number_cdev_registered + 1);
    } else {
#line 90
      return (-1);
    }
  }
#line 94
  return (return_value);
}
}
#line 97 "/usr/local/ddv/models/con2/src/linux/fs/char_dev.c"
__inline void cdev_del(struct cdev *p ) 
{ 
  int i ;

  {
#line 101
  i = 0;
#line 101
  while (i < (int )number_cdev_registered) {
#line 102
    if ((unsigned long )cdev_registered[i].cdevp == (unsigned long )p) {
#line 103
      cdev_registered[i].cdevp = (struct cdev *)0;
#line 105
      return;
    }
#line 101
    i ++;
  }
#line 108
  return;
}
}
#line 1 "ddverify.o"
#pragma merger("0","/tmp/cil-F5CE61aT.i","")
#line 45 "/usr/local/ddv/models/con2/include/ddverify/ddverify.h"
int call_ddv(void) ;
#line 39 "/usr/local/ddv/models/con2/include/ddverify/satabs.h"
extern void __CPROVER_atomic_begin() ;
#line 40
extern void __CPROVER_atomic_end() ;
#line 186 "/usr/local/ddv/models/con2/include/ddverify/pthread.h"
__inline extern int pthread_mutex_init(pthread_mutex_t *__mutex , pthread_mutexattr_t const   *__mutex_attr ) 
{ 
  pthread_mutex_t i ;

  {
#line 190
  i.locked = (_Bool)0;
#line 191
  *__mutex = i;
#line 192
  return (0);
}
}
#line 194 "/usr/local/ddv/models/con2/include/ddverify/pthread.h"
__inline extern int pthread_mutex_destroy(pthread_mutex_t *__mutex ) 
{ 


  {
#line 196
  return (0);
}
}
#line 203 "/usr/local/ddv/models/con2/include/ddverify/pthread.h"
__inline extern int pthread_mutex_lock(pthread_mutex_t *__mutex ) 
{ 


  {
#line 206
  __CPROVER_atomic_begin();
#line 207
  __CPROVER_assume(! __mutex->locked);
#line 208
  __mutex->locked = (_Bool)1;
#line 209
  __CPROVER_atomic_end();
#line 210
  return (0);
}
}
#line 216
extern int ( /* missing proto */  __CPROVER_assert)() ;
#line 213 "/usr/local/ddv/models/con2/include/ddverify/pthread.h"
__inline extern int pthread_mutex_unlock(pthread_mutex_t *__mutex ) 
{ 


  {
#line 216
  __CPROVER_assert((int )__mutex->locked, "pthread_mutex_unlock without lock");
#line 217
  __mutex->locked = (_Bool)0;
#line 218
  return (0);
}
}
#line 9 "/usr/local/ddv/models/con2/include/linux/spinlock.h"
void spin_lock_init(spinlock_t *lock ) ;
#line 12 "/usr/local/ddv/models/con2/include/ddverify/genhd.h"
short number_genhd_registered  =    (short)0;
#line 13 "/usr/local/ddv/models/con2/include/ddverify/genhd.h"
short number_fixed_genhd_used  =    (short)0;
#line 24 "/usr/local/ddv/models/con2/include/ddverify/genhd.h"
struct gendisk fixed_gendisk[10]  ;
#line 25 "/usr/local/ddv/models/con2/include/ddverify/genhd.h"
struct ddv_genhd genhd_registered[10]  ;
#line 14 "/usr/local/ddv/models/con2/include/ddverify/pci.h"
struct ddv_pci_driver registered_pci_driver  ;
#line 19
extern void call_pci_functions() ;
#line 14 "/usr/local/ddv/models/con2/include/ddverify/interrupt.h"
struct registered_irq registered_irq[16]  ;
#line 16
void call_interrupt_handler(void) ;
#line 8 "/usr/local/ddv/models/con2/include/ddverify/tasklet.h"
short number_tasklet_registered  =    (short)0;
#line 15 "/usr/local/ddv/models/con2/include/ddverify/tasklet.h"
struct ddv_tasklet tasklet_registered[10]  ;
#line 17
void call_tasklet_functions(void) ;
#line 8 "/usr/local/ddv/models/con2/include/ddverify/timer.h"
short number_timer_registered  =    (short)0;
#line 14 "/usr/local/ddv/models/con2/include/ddverify/timer.h"
struct ddv_timer timer_registered[5]  ;
#line 16
extern void call_timer_functions() ;
#line 8 "/usr/local/ddv/models/con2/include/ddverify/workqueue.h"
struct work_struct *shared_workqueue[10]  ;
#line 10
void call_shared_workqueue_functions(void) ;
#line 7 "/usr/local/ddv/models/con2/include/linux/smp_lock.h"
spinlock_t kernel_lock  ;
#line 15 "/usr/local/ddv/models/con2/src/ddverify/ddverify.c"
void init_kernel(void) 
{ 
  int i ;

  {
#line 19
  spin_lock_init(& kernel_lock);
#line 21
  i = 0;
#line 21
  while (i < 10) {
#line 22
    shared_workqueue[i] = (struct work_struct *)((void *)0);
#line 21
    i ++;
  }
#line 25
  i = 0;
#line 25
  while (i < 10) {
#line 26
    tasklet_registered[i].tasklet = (struct tasklet_struct *)((void *)0);
#line 27
    tasklet_registered[i].is_running = (unsigned short)0;
#line 25
    i ++;
  }
#line 29
  return;
}
}
#line 31 "/usr/local/ddv/models/con2/src/ddverify/ddverify.c"
static void *ddv_2(void *arg ) 
{ 
  unsigned short random ;

  {
#line 35
  while (1) {
#line 36
    random = nondet_ushort();
#line 38
    switch ((int )random) {
    case 1: 
#line 40
    current_execution_context = 2;
#line 41
    call_timer_functions();
#line 42
    current_execution_context = 1;
#line 43
    break;
    case 2: 
#line 46
    current_execution_context = 2;
#line 47
    call_interrupt_handler();
#line 48
    current_execution_context = 1;
#line 49
    break;
    case 3: 
#line 52
    current_execution_context = 1;
#line 53
    call_shared_workqueue_functions();
#line 54
    current_execution_context = 1;
#line 55
    break;
    case 4: 
#line 58
    current_execution_context = 2;
#line 59
    call_tasklet_functions();
#line 60
    current_execution_context = 1;
#line 61
    break;
    case 5: 
#line 64
    current_execution_context = 1;
#line 65
    call_pci_functions();
#line 66
    current_execution_context = 1;
#line 67
    break;
    default: 
#line 70
    break;
    }
#line 35
    if (! random) {
#line 35
      break;
    }
  }
#line 73
  return ((void *)0);
}
}
#line 75 "/usr/local/ddv/models/con2/src/ddverify/ddverify.c"
void ddv(void) 
{ 
  pthread_t___0 thread ;
  int tmp ;

  {
#line 81
  pthread_create((struct __pthread_t_struct *)(& thread), (struct __pthread_attr_t_struct  const  *)((void *)0),
                 & ddv_2, (void *)0);
#line 83
  while (1) {
#line 84
    current_execution_context = 1;
#line 86
    call_cdev_functions();
#line 83
    tmp = nondet_int();
#line 83
    if (! tmp) {
#line 83
      break;
    }
  }
#line 93
  return;
}
}
#line 95 "/usr/local/ddv/models/con2/src/ddverify/ddverify.c"
int call_ddv(void) 
{ 
  int err ;

  {
#line 99
  current_execution_context = 1;
#line 101
  init_kernel();
#line 103
  err = (*_ddv_module_init)();
#line 105
  if (err) {
#line 106
    return (-1);
  }
#line 110
  ddv();
#line 112
  current_execution_context = 1;
#line 113
  (*_ddv_module_exit)();
#line 115
  return (0);
}
}
#line 1 "genhd.o"
#pragma merger("0","/tmp/cil-1qBbyimL.i","")
#line 9 "/usr/local/ddv/models/con2/include/ddverify/satabs.h"
extern void *malloc(size_t size ) ;
#line 207 "/usr/local/ddv/models/con2/include/linux/fs.h"
int register_blkdev(unsigned int major , char const   *name ) ;
#line 208
int unregister_blkdev(unsigned int major , char const   *name ) ;
#line 33 "/usr/local/ddv/models/con2/include/linux/genhd.h"
void add_disk(struct gendisk *disk ) ;
#line 35
void del_gendisk(struct gendisk *gp ) ;
#line 37
struct gendisk *alloc_disk(int minors ) ;
#line 6 "/usr/local/ddv/models/con2/src/linux/block/genhd.c"
int register_blkdev(unsigned int major , char const   *name ) 
{ 
  int result ;
  int tmp ;

  {
#line 8
  tmp = nondet_int();
#line 8
  result = tmp;
#line 14
  return (result);
}
}
#line 17 "/usr/local/ddv/models/con2/src/linux/block/genhd.c"
int unregister_blkdev(unsigned int major , char const   *name ) 
{ 


  {
#line 19
  return (0);
}
}
#line 22 "/usr/local/ddv/models/con2/src/linux/block/genhd.c"
struct gendisk *alloc_disk(int minors ) 
{ 
  struct gendisk *gd ;

  {
#line 26
  if ((int )number_fixed_genhd_used < 10) {
#line 27
    gd = & fixed_gendisk[number_fixed_genhd_used];
#line 28
    gd->minors = minors;
#line 30
    number_fixed_genhd_used = (short )((int )number_fixed_genhd_used + 1);
#line 32
    return (gd);
  } else {
#line 34
    return ((struct gendisk *)((void *)0));
  }
}
}
#line 38 "/usr/local/ddv/models/con2/src/linux/block/genhd.c"
void add_disk(struct gendisk *disk ) 
{ 
  void *tmp ;

  {
#line 40
  if ((int )number_genhd_registered < 10) {
#line 41
    genhd_registered[number_genhd_registered].gd = disk;
#line 42
    tmp = malloc((size_t )sizeof(struct block_device ));
#line 42
    genhd_registered[number_genhd_registered].inode.i_bdev = (struct block_device *)tmp;
#line 43
    (genhd_registered[number_genhd_registered].inode.i_bdev)->bd_disk = disk;
#line 45
    number_genhd_registered = (short )((int )number_genhd_registered + 1);
  }
#line 47
  return;
}
}
#line 49 "/usr/local/ddv/models/con2/src/linux/block/genhd.c"
void del_gendisk(struct gendisk *gp ) 
{ 
  int i ;

  {
#line 53
  i = 0;
#line 53
  while (i < (int )number_genhd_registered) {
#line 54
    if ((unsigned long )genhd_registered[i].gd == (unsigned long )gp) {
#line 55
      genhd_registered[i].gd = (struct gendisk *)((void *)0);
    }
#line 53
    i ++;
  }
#line 58
  return;
}
}
#line 1 "interrupt.o"
#pragma merger("0","/tmp/cil-9p9TZsRo.i","")
#line 10 "/usr/local/ddv/models/con2/src/ddverify/interrupt.c"
void call_interrupt_handler(void) 
{ 
  unsigned short i ;
  struct pt_regs regs ;
  int tmp ;

  {
#line 15
  tmp = nondet_int();
#line 15
  i = (unsigned short )tmp;
#line 16
  __CPROVER_assume((int )i < 16);
#line 18
  if (registered_irq[i].handler) {
#line 19
    (*(registered_irq[i].handler))((int )i, registered_irq[i].dev_id, & regs);
  }
#line 22
  return;
}
}
#line 1 "ioctl.o"
#pragma merger("0","/tmp/cil-5emvH0wa.i","")
#line 1 "ll_rw_blk.o"
#pragma merger("0","/tmp/cil-cHqPncNN.i","")
#line 192 "/usr/local/ddv/models/con2/include/linux/blkdev.h"
request_queue_t *blk_alloc_queue(gfp_t gfp_mask ) ;
#line 194
request_queue_t *blk_init_queue(request_fn_proc *rfn , spinlock_t *lock ) ;
#line 196
void blk_queue_make_request(request_queue_t *q , make_request_fn *mfn ) ;
#line 198
void blk_queue_hardsect_size(request_queue_t *q , unsigned short size ) ;
#line 200
void blk_cleanup_queue(request_queue_t *q ) ;
#line 220
void end_request(struct request *req , int uptodate ) ;
#line 6 "/usr/local/ddv/models/con2/include/ddverify/blkdev.h"
request_queue_t fixed_request_queue[10]  ;
#line 8 "/usr/local/ddv/models/con2/include/ddverify/blkdev.h"
int number_request_queue_used  =    0;
#line 7 "/usr/local/ddv/models/con2/src/linux/block/ll_rw_blk.c"
request_queue_t *get_fixed_request_queue(void) 
{ 
  int tmp ;

  {
#line 9
  if (number_request_queue_used < 10) {
#line 10
    tmp = number_request_queue_used;
#line 10
    number_request_queue_used ++;
#line 10
    return (& fixed_request_queue[tmp]);
  } else {
#line 12
    return ((request_queue_t *)((void *)0));
  }
}
}
#line 16 "/usr/local/ddv/models/con2/src/linux/block/ll_rw_blk.c"
request_queue_t *blk_init_queue(request_fn_proc *rfn , spinlock_t *lock ) 
{ 
  request_queue_t *queue ;
  int tmp ;

  {
#line 20
  tmp = nondet_int();
#line 20
  if (tmp) {
#line 21
    queue = get_fixed_request_queue();
#line 23
    queue->queue_lock = lock;
#line 24
    queue->request_fn = rfn;
#line 25
    queue->make_request_fn = (make_request_fn *)((void *)0);
#line 26
    queue->__ddv_queue_alive = 1;
#line 28
    return (queue);
  } else {
#line 30
    return ((request_queue_t *)((void *)0));
  }
}
}
#line 34 "/usr/local/ddv/models/con2/src/linux/block/ll_rw_blk.c"
request_queue_t *blk_alloc_queue(gfp_t gfp_mask ) 
{ 
  request_queue_t *queue ;
  int tmp ;

  {
#line 38
  tmp = nondet_int();
#line 38
  if (tmp) {
#line 39
    queue = get_fixed_request_queue();
#line 41
    queue->request_fn = (request_fn_proc *)((void *)0);
#line 42
    queue->make_request_fn = (make_request_fn *)((void *)0);
#line 43
    queue->__ddv_queue_alive = 1;
#line 45
    return (queue);
  } else {
#line 47
    return ((request_queue_t *)((void *)0));
  }
}
}
#line 51 "/usr/local/ddv/models/con2/src/linux/block/ll_rw_blk.c"
void blk_queue_make_request(request_queue_t *q , make_request_fn *mfn ) 
{ 


  {
#line 53
  q->make_request_fn = mfn;
#line 54
  return;
}
}
#line 56 "/usr/local/ddv/models/con2/src/linux/block/ll_rw_blk.c"
void end_request(struct request *req , int uptodate ) 
{ 
  int genhd_no ;

  {
#line 58
  genhd_no = ((req->rq_disk)->queue)->__ddv_genhd_no;
#line 60
  genhd_registered[genhd_no].requests_open = 0;
#line 61
  return;
}
}
#line 64 "/usr/local/ddv/models/con2/src/linux/block/ll_rw_blk.c"
void blk_queue_hardsect_size(request_queue_t *q , unsigned short size ) 
{ 


  {
#line 66
  q->hardsect_size = size;
#line 67
  return;
}
}
#line 69 "/usr/local/ddv/models/con2/src/linux/block/ll_rw_blk.c"
void blk_cleanup_queue(request_queue_t *q ) 
{ 


  {
#line 71
  q->__ddv_queue_alive = 0;
#line 72
  return;
}
}
#line 1 "__main.o"
#pragma merger("0","/tmp/cil-5FCHWV04.i","")
#line 18 "/usr/local/ddv/models/con2/include/linux/compiler.h"
extern void barrier(void) ;
#line 28 "/usr/local/ddv/models/con2/include/linux/timer.h"
void add_timer(struct timer_list *timer ) ;
#line 29
int del_timer(struct timer_list *timer ) ;
#line 71 "/usr/local/ddv/models/con2/include/linux/wait.h"
void wake_up(wait_queue_head_t *q ) ;
#line 88
void sleep_on(wait_queue_head_t *q ) ;
#line 30 "/usr/local/ddv/models/con2/include/linux/string.h"
extern void *memcpy(void * , void const   * , __kernel_size_t  ) ;
#line 90 "/usr/local/ddv/models/con2/include/linux/ioport.h"
struct resource *request_region(unsigned long start , unsigned long len , char const   *name ) ;
#line 92
void release_region(unsigned long start , unsigned long len ) ;
#line 34 "/usr/local/ddv/models/con2/include/linux/kernel.h"
extern int printk(char const   *fmt  , ...) ;
#line 35
extern int sprintf(char *buf , char const   *fmt  , ...) ;
#line 39 "/usr/local/ddv/models/con2/include/linux/genhd.h"
extern void put_disk(struct gendisk *disk ) ;
#line 51 "/usr/local/ddv/models/con2/include/asm/uaccess.h"
unsigned long copy_to_user(void *to , void const   *from , unsigned long n ) ;
#line 53
unsigned long copy_from_user(void *to , void *from , unsigned long n ) ;
#line 4 "/usr/local/ddv/models/con2/include/linux/elevator.h"
extern struct request *elv_next_request(struct request_queue *q ) ;
#line 14 "/usr/local/ddv/models/con2/include/asm/io.h"
unsigned char inb(unsigned int port ) ;
#line 15
void outb(unsigned char byte , unsigned int port ) ;
#line 24
void outb_p(unsigned char byte , unsigned int port ) ;
#line 32
extern unsigned int insb(unsigned int  , void *addr , unsigned long count ) ;
#line 228 "aztcd.c"
struct request_queue *azt_queue  ;
#line 230 "aztcd.c"
int current_valid(void) 
{ 
  struct request *tmp ;
  struct request *tmp___0 ;
  struct request *tmp___1 ;
  int tmp___2 ;

  {
#line 232
  tmp = elv_next_request(azt_queue);
#line 232
  if (tmp) {
#line 232
    tmp___0 = elv_next_request(azt_queue);
#line 232
    if ((unsigned long )(tmp___0->cmd) == (unsigned long )((unsigned char *)0)) {
#line 232
      tmp___1 = elv_next_request(azt_queue);
#line 232
      if (tmp___1->sector != 0xffffffffffffffffUL) {
#line 232
        tmp___2 = 1;
      } else {
#line 232
        tmp___2 = 0;
      }
    } else {
#line 232
      tmp___2 = 0;
    }
  } else {
#line 232
    tmp___2 = 0;
  }
#line 232
  return (tmp___2);
}
}
#line 265 "aztcd.c"
int aztPresent  =    0;
#line 267 "aztcd.c"
int volatile   azt_transfer_is_active  =    (int volatile   )0;
#line 269 "aztcd.c"
char azt_buf[37632]  ;
#line 271 "aztcd.c"
char buf[2352]  ;
#line 274 "aztcd.c"
int volatile   azt_buf_bn[16]  ;
#line 274 "aztcd.c"
int volatile   azt_next_bn  ;
#line 275 "aztcd.c"
int volatile   azt_buf_in  ;
#line 275 "aztcd.c"
int volatile   azt_buf_out  =    (int volatile   )-1;
#line 276 "aztcd.c"
int volatile   azt_error  =    (int volatile   )0;
#line 277 "aztcd.c"
int azt_open_count  =    0;
#line 278 "aztcd.c"
enum azt_state_e  volatile  azt_state  =    (enum azt_state_e  volatile  )0;
#line 283 "aztcd.c"
enum azt_read_modes  volatile  azt_read_mode  =    (enum azt_read_modes  volatile  )1;
#line 285 "aztcd.c"
int azt_mode  =    -1;
#line 286 "aztcd.c"
int volatile   azt_read_count  =    (int volatile   )1;
#line 288 "aztcd.c"
int aztcd  =    -1;
#line 292 "aztcd.c"
int azt_port_auto[16]  = {      800,      768,      784,      816, 
        0};
#line 294 "aztcd.c"
char azt_cont  =    (char)0;
#line 295 "aztcd.c"
char azt_init_end  =    (char)0;
#line 296 "aztcd.c"
char azt_auto_eject  =    (char)0;
#line 298 "aztcd.c"
int AztTimeout  ;
#line 298 "aztcd.c"
int AztTries  ;
#line 299 "aztcd.c"
wait_queue_head_t azt_waitq  =    {0, 0, 1};
#line 300 "aztcd.c"
struct timer_list delay_timer  =    {0UL, (void (*)(unsigned long  ))((void *)0), 0UL, (short)0, (short)1};
#line 302 "aztcd.c"
struct azt_DiskInfo DiskInfo  ;
#line 303 "aztcd.c"
struct azt_Toc Toc[104]  ;
#line 304 "aztcd.c"
struct azt_Play_msf azt_Play  ;
#line 306 "aztcd.c"
int aztAudioStatus  =    21;
#line 307 "aztcd.c"
char aztDiskChanged  =    (char)1;
#line 308 "aztcd.c"
char aztTocUpToDate  =    (char)0;
#line 310 "aztcd.c"
unsigned char aztIndatum  ;
#line 311 "aztcd.c"
unsigned long aztTimeOutCount  ;
#line 312 "aztcd.c"
int aztCmd  =    0;
#line 314 "aztcd.c"
spinlock_t aztSpin  =    {1, 0};
#line 321
void aztStatTimer(void) ;
#line 324
int aztGetDiskInfo(void) ;
#line 326
int aztGetMultiDiskInfo(void) ;
#line 328
int aztGetToc(int multi ) ;
#line 331
int check_aztcd_media_change(struct gendisk *disk ) ;
#line 332
int aztcd_ioctl(struct inode *ip , struct file *fp , unsigned int cmd , unsigned long arg ) ;
#line 334
int aztcd_open(struct inode *ip , struct file *fp ) ;
#line 335
int aztcd_release(struct inode *inode , struct file *file ) ;
#line 337 "aztcd.c"
struct block_device_operations azt_fops  = 
#line 337
     {& aztcd_open, & aztcd_release, & aztcd_ioctl, (long (*)(struct file * , unsigned int  ,
                                                            unsigned long  ))0, (long (*)(struct file * ,
                                                                                          unsigned int  ,
                                                                                          unsigned long  ))0,
    (int (*)(struct block_device * , sector_t  , unsigned long * ))0, & check_aztcd_media_change,
    (int (*)(struct gendisk * ))0, (int (*)(struct block_device * , struct hd_geometry * ))0,
    (struct module *)0};
#line 346
void azt_poll(void) ;
#line 349
void azt_hsg2msf(long hsg , struct msf *msf ) ;
#line 350
long azt_msf2hsg(struct msf *mp ) ;
#line 351
void azt_bin2bcd(unsigned char *p ) ;
#line 352
int azt_bcd2bin(unsigned char bcd ) ;
#line 362 "aztcd.c"
void op_ok(void) 
{ 


  {
#line 364
  aztTimeOutCount = 0UL;
#line 365
  while (1) {
#line 366
    aztIndatum = inb((unsigned int )aztcd);
#line 367
    aztTimeOutCount ++;
#line 368
    if (aztTimeOutCount >= 8000000UL) {
#line 369
      printk("aztcd: Error Wait OP_OK\n");
#line 370
      break;
    }
#line 365
    if (! ((int )aztIndatum != 1)) {
#line 365
      break;
    }
  }
#line 373
  return;
}
}
#line 394 "aztcd.c"
void sten_low(void) 
{ 


  {
#line 396
  aztTimeOutCount = 0UL;
#line 397
  while (1) {
#line 398
    aztIndatum = inb((unsigned int )(aztcd + 1));
#line 399
    aztTimeOutCount ++;
#line 400
    if (aztTimeOutCount >= 8000000UL) {
#line 401
      if (azt_init_end) {
#line 402
        printk("aztcd: Error Wait STEN_LOW commands:%x\n", aztCmd);
      }
#line 405
      break;
    }
#line 397
    if (! ((int )aztIndatum & 4)) {
#line 397
      break;
    }
  }
#line 408
  return;
}
}
#line 412 "aztcd.c"
void dten_low(void) 
{ 


  {
#line 414
  aztTimeOutCount = 0UL;
#line 415
  while (1) {
#line 416
    aztIndatum = inb((unsigned int )(aztcd + 1));
#line 417
    aztTimeOutCount ++;
#line 418
    if (aztTimeOutCount >= 8000000UL) {
#line 419
      printk("aztcd: Error Wait DTEN_OK\n");
#line 420
      break;
    }
#line 415
    if (! ((int )aztIndatum & 2)) {
#line 415
      break;
    }
  }
#line 423
  return;
}
}
#line 430 "aztcd.c"
void statusAzt(void) 
{ 


  {
#line 432
  AztTimeout = 400;
#line 433
  delay_timer.expires = jiffies + 1UL;
#line 433
  delay_timer.function = (void (*)(unsigned long  ))((void *)(& aztStatTimer));
#line 433
  add_timer(& delay_timer);
#line 434
  sleep_on(& azt_waitq);
#line 435
  if (AztTimeout <= 0) {
#line 436
    printk("aztcd: Error Wait STEN_LOW_WAIT command:%x\n", aztCmd);
  }
#line 438
  return;
}
}
#line 441 "aztcd.c"
void aztStatTimer(void) 
{ 
  unsigned char tmp ;

  {
#line 443
  tmp = inb((unsigned int )(aztcd + 1));
#line 443
  if (! ((int )tmp & 4)) {
#line 444
    wake_up(& azt_waitq);
#line 445
    return;
  }
#line 447
  AztTimeout --;
#line 448
  if (AztTimeout <= 0) {
#line 449
    wake_up(& azt_waitq);
#line 450
    printk("aztcd: Error aztStatTimer: Timeout\n");
#line 451
    return;
  }
#line 453
  delay_timer.expires = jiffies + 1UL;
#line 453
  delay_timer.function = (void (*)(unsigned long  ))((void *)(& aztStatTimer));
#line 453
  add_timer(& delay_timer);
#line 454
  return;
}
}
#line 463 "aztcd.c"
int aztSendCmd(int cmd ) 
{ 
  unsigned char data ;
  int retry ;
  unsigned char tmp ;
  unsigned char tmp___0 ;

  {
#line 472
  if (aztcd == 496) {
#line 473
    outb_p((unsigned char)160, (unsigned int )(aztcd + 6));
  } else
#line 472
  if (aztcd == 368) {
#line 473
    outb_p((unsigned char)160, (unsigned int )(aztcd + 6));
  }
#line 473
  outb_p((unsigned char)16, (unsigned int )(aztcd + 6));
#line 473
  outb_p((unsigned char)0, (unsigned int )(aztcd + 7));
#line 473
  outb_p((unsigned char)16, (unsigned int )(aztcd + 6));
#line 475
  aztCmd = cmd;
#line 476
  outb((unsigned char)4, (unsigned int )(aztcd + 2));
#line 477
  while (1) {
#line 478
    tmp = inb((unsigned int )(aztcd + 1));
#line 478
    if ((int )tmp & 4) {
#line 479
      break;
    }
#line 480
    inb((unsigned int )aztcd);
  }
#line 482
  while (1) {
#line 483
    tmp___0 = inb((unsigned int )(aztcd + 1));
#line 483
    if ((int )tmp___0 & 2) {
#line 484
      break;
    }
#line 485
    inb((unsigned int )aztcd);
  }
#line 487
  retry = 0;
#line 487
  while (retry < 3) {
#line 488
    outb((unsigned char )cmd, (unsigned int )aztcd);
#line 489
    sten_low();
#line 490
    data = inb((unsigned int )aztcd);
#line 491
    if ((int )data == 1) {
#line 492
      return (0);
    }
#line 494
    if ((int )data == 5) {
#line 495
      sten_low();
#line 496
      data = inb((unsigned int )aztcd);
#line 497
      printk("### Error 1 aztcd: aztSendCmd %x  Error Code %x\n", cmd, (int )data);
    }
#line 487
    retry ++;
  }
#line 502
  if (retry >= 3) {
#line 503
    printk("### Error 2 aztcd: aztSendCmd %x \n", cmd);
#line 504
    azt_error = (int volatile   )165;
  }
#line 506
  printk("aztcd: Warning: %s failed\n", "aztSendCmd");
#line 506
  return (-1);
}
}
#line 512 "aztcd.c"
int sendAztCmd(int cmd , struct azt_Play_msf *params ) 
{ 
  unsigned char data ;
  int retry ;

  {
#line 522
  retry = 0;
#line 522
  while (retry < 3) {
#line 523
    aztSendCmd(cmd);
#line 524
    outb(params->start.min, (unsigned int )aztcd);
#line 525
    outb(params->start.sec, (unsigned int )aztcd);
#line 526
    outb(params->start.frame, (unsigned int )aztcd);
#line 527
    outb(params->end.min, (unsigned int )aztcd);
#line 528
    outb(params->end.sec, (unsigned int )aztcd);
#line 529
    outb(params->end.frame, (unsigned int )aztcd);
#line 530
    sten_low();
#line 531
    data = inb((unsigned int )aztcd);
#line 532
    if ((int )data == 2) {
#line 533
      return (0);
    }
#line 535
    if ((int )data == 6) {
#line 536
      sten_low();
#line 537
      data = inb((unsigned int )aztcd);
#line 538
      printk("### Error 1 aztcd: sendAztCmd %x  Error Code %x\n", cmd, (int )data);
    }
#line 522
    retry ++;
  }
#line 543
  if (retry >= 3) {
#line 544
    printk("### Error 2 aztcd: sendAztCmd %x\n ", cmd);
#line 545
    azt_error = (int volatile   )165;
  }
#line 547
  printk("aztcd: Warning: %s failed\n", "sendAztCmd");
#line 547
  return (-1);
}
}
#line 553 "aztcd.c"
int aztSeek(struct azt_Play_msf *params ) 
{ 
  unsigned char data ;
  int retry ;

  {
#line 562
  retry = 0;
#line 562
  while (retry < 3) {
#line 563
    aztSendCmd(48);
#line 564
    outb(params->start.min, (unsigned int )aztcd);
#line 565
    outb(params->start.sec, (unsigned int )aztcd);
#line 566
    outb(params->start.frame, (unsigned int )aztcd);
#line 567
    sten_low();
#line 568
    data = inb((unsigned int )aztcd);
#line 569
    if ((int )data == 2) {
#line 570
      return (0);
    }
#line 572
    if ((int )data == 6) {
#line 573
      sten_low();
#line 574
      data = inb((unsigned int )aztcd);
#line 575
      printk("### Error 1 aztcd: aztSeek\n");
    }
#line 562
    retry ++;
  }
#line 578
  if (retry >= 3) {
#line 579
    printk("### Error 2 aztcd: aztSeek\n ");
#line 580
    azt_error = (int volatile   )165;
  }
#line 582
  printk("aztcd: Warning: %s failed\n", "aztSeek");
#line 582
  return (-1);
}
}
#line 589 "aztcd.c"
int aztSetDiskType(int type ) 
{ 
  unsigned char data ;
  int retry ;

  {
#line 597
  retry = 0;
#line 597
  while (retry < 3) {
#line 598
    aztSendCmd(161);
#line 599
    outb((unsigned char )type, (unsigned int )aztcd);
#line 600
    sten_low();
#line 601
    data = inb((unsigned int )aztcd);
#line 602
    if ((int )data == 2) {
#line 603
      azt_read_mode = (enum azt_read_modes  volatile  )type;
#line 604
      return (0);
    }
#line 606
    if ((int )data == 6) {
#line 607
      sten_low();
#line 608
      data = inb((unsigned int )aztcd);
#line 609
      printk("### Error 1 aztcd: aztSetDiskType %x Error Code %x\n", type, (int )data);
    }
#line 597
    retry ++;
  }
#line 614
  if (retry >= 3) {
#line 615
    printk("### Error 2 aztcd: aztSetDiskType %x\n ", type);
#line 616
    azt_error = (int volatile   )165;
  }
#line 618
  printk("aztcd: Warning: %s failed\n", "aztSetDiskType");
#line 618
  return (-1);
}
}
#line 625 "aztcd.c"
int aztStatus(void) 
{ 
  int st ;
  unsigned char tmp ;

  {
#line 632
  sten_low();
#line 633
  if (aztTimeOutCount < 8000000UL) {
#line 634
    tmp = inb((unsigned int )aztcd);
#line 634
    st = (int )tmp & 255;
#line 635
    return (st);
  } else {
#line 637
    printk("aztcd: Warning: %s failed\n", "aztStatus");
#line 637
    return (-1);
  }
}
}
#line 643 "aztcd.c"
int getAztStatus(void) 
{ 
  int st ;
  int tmp ;
  unsigned char tmp___0 ;

  {
#line 647
  tmp = aztSendCmd(65);
#line 647
  if (tmp) {
#line 648
    printk("aztcd: Warning: %s failed\n", "getAztStatus 1");
#line 648
    return (-1);
  }
#line 649
  sten_low();
#line 650
  tmp___0 = inb((unsigned int )aztcd);
#line 650
  st = (int )tmp___0 & 255;
#line 654
  if (st == 255) {
#line 655
    printk("aztcd: AST_CMD_CHECK error or no status available\n");
#line 657
    return (-1);
  } else
#line 654
  if (st & 128) {
#line 655
    printk("aztcd: AST_CMD_CHECK error or no status available\n");
#line 657
    return (-1);
  }
#line 660
  if ((st & 28) != 4) {
#line 660
    if (aztAudioStatus == 17) {
#line 663
      aztAudioStatus = 19;
    }
  }
#line 665
  if (st & 2) {
#line 666
    aztDiskChanged = (char)1;
#line 667
    aztTocUpToDate = (char)0;
#line 668
    aztAudioStatus = 21;
  } else
#line 665
  if (st & 32) {
#line 666
    aztDiskChanged = (char)1;
#line 667
    aztTocUpToDate = (char)0;
#line 668
    aztAudioStatus = 21;
  }
#line 670
  return (st);
}
}
#line 677 "aztcd.c"
int aztPlay(struct azt_Play_msf *arg ) 
{ 
  int tmp ;

  {
#line 679
  tmp = sendAztCmd(144, arg);
#line 679
  if (tmp < 0) {
#line 680
    printk("aztcd: Warning: %s failed\n", "aztPlay");
#line 680
    return (-1);
  }
#line 681
  return (0);
}
}
#line 689 "aztcd.c"
void aztCloseDoor(void) 
{ 


  {
#line 691
  aztSendCmd(97);
#line 692
  sten_low();
#line 693
  return;
}
}
#line 696 "aztcd.c"
void aztLockDoor(void) 
{ 


  {
#line 699
  aztSendCmd(113);
#line 700
  sten_low();
#line 702
  return;
}
}
#line 705 "aztcd.c"
void aztUnlockDoor(void) 
{ 


  {
#line 708
  aztSendCmd(114);
#line 709
  sten_low();
#line 711
  return;
}
}
#line 719 "aztcd.c"
int aztGetValue(unsigned char *result ) 
{ 
  int s ;
  unsigned char tmp ;

  {
#line 723
  sten_low();
#line 724
  if (aztTimeOutCount >= 8000000UL) {
#line 725
    printk("aztcd: aztGetValue timeout\n");
#line 726
    return (-1);
  }
#line 728
  tmp = inb((unsigned int )aztcd);
#line 728
  s = (int )tmp & 255;
#line 729
  *result = (unsigned char )s;
#line 730
  return (0);
}
}
#line 737 "aztcd.c"
int aztGetQChannelInfo(struct azt_Toc *qp ) 
{ 
  unsigned char notUsed ;
  int st ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;

  {
#line 745
  st = getAztStatus();
#line 745
  if (st == -1) {
#line 746
    printk("aztcd: Warning: %s failed\n", "aztGetQChannelInfo 1");
#line 746
    return (-1);
  }
#line 747
  tmp = aztSendCmd(80);
#line 747
  if (tmp) {
#line 748
    printk("aztcd: Warning: %s failed\n", "aztGetQChannelInfo 2");
#line 748
    return (-1);
  }
#line 750
  tmp___0 = aztGetValue(& notUsed);
#line 750
  if (tmp___0) {
#line 751
    printk("aztcd: Warning: %s failed\n", "aztGetQChannelInfo 3");
#line 751
    return (-1);
  }
#line 752
  if ((st & 28) == 12) {
#line 753
    qp->ctrl_addr = (unsigned char)0;
#line 754
    qp->track = (unsigned char)0;
#line 755
    qp->pointIndex = (unsigned char)0;
#line 756
    qp->trackTime.min = (unsigned char)0;
#line 757
    qp->trackTime.sec = (unsigned char)0;
#line 758
    qp->trackTime.frame = (unsigned char)0;
#line 759
    qp->diskTime.min = (unsigned char)0;
#line 760
    qp->diskTime.sec = (unsigned char)0;
#line 761
    qp->diskTime.frame = (unsigned char)0;
#line 762
    return (0);
  } else {
#line 764
    tmp___1 = aztGetValue(& qp->ctrl_addr);
#line 764
    if (tmp___1 < 0) {
#line 765
      printk("aztcd: Warning: %s failed\n", "aztGetQChannelInfo 4");
#line 765
      return (-1);
    }
#line 766
    tmp___2 = aztGetValue(& qp->track);
#line 766
    if (tmp___2 < 0) {
#line 767
      printk("aztcd: Warning: %s failed\n", "aztGetQChannelInfo 4");
#line 767
      return (-1);
    }
#line 768
    tmp___3 = aztGetValue(& qp->pointIndex);
#line 768
    if (tmp___3 < 0) {
#line 769
      printk("aztcd: Warning: %s failed\n", "aztGetQChannelInfo 4");
#line 769
      return (-1);
    }
#line 770
    tmp___4 = aztGetValue(& qp->trackTime.min);
#line 770
    if (tmp___4 < 0) {
#line 771
      printk("aztcd: Warning: %s failed\n", "aztGetQChannelInfo 4");
#line 771
      return (-1);
    }
#line 772
    tmp___5 = aztGetValue(& qp->trackTime.sec);
#line 772
    if (tmp___5 < 0) {
#line 773
      printk("aztcd: Warning: %s failed\n", "aztGetQChannelInfo 4");
#line 773
      return (-1);
    }
#line 774
    tmp___6 = aztGetValue(& qp->trackTime.frame);
#line 774
    if (tmp___6 < 0) {
#line 775
      printk("aztcd: Warning: %s failed\n", "aztGetQChannelInfo 4");
#line 775
      return (-1);
    }
#line 776
    tmp___7 = aztGetValue(& notUsed);
#line 776
    if (tmp___7 < 0) {
#line 777
      printk("aztcd: Warning: %s failed\n", "aztGetQChannelInfo 4");
#line 777
      return (-1);
    }
#line 778
    tmp___8 = aztGetValue(& qp->diskTime.min);
#line 778
    if (tmp___8 < 0) {
#line 779
      printk("aztcd: Warning: %s failed\n", "aztGetQChannelInfo 4");
#line 779
      return (-1);
    }
#line 780
    tmp___9 = aztGetValue(& qp->diskTime.sec);
#line 780
    if (tmp___9 < 0) {
#line 781
      printk("aztcd: Warning: %s failed\n", "aztGetQChannelInfo 4");
#line 781
      return (-1);
    }
#line 782
    tmp___10 = aztGetValue(& qp->diskTime.frame);
#line 782
    if (tmp___10 < 0) {
#line 783
      printk("aztcd: Warning: %s failed\n", "aztGetQChannelInfo 4");
#line 783
      return (-1);
    }
  }
#line 788
  return (0);
}
}
#line 794 "aztcd.c"
int aztUpdateToc(void) 
{ 
  int st ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 801
  if (aztTocUpToDate) {
#line 802
    return (0);
  }
#line 804
  tmp = aztGetDiskInfo();
#line 804
  if (tmp < 0) {
#line 805
    return (-5);
  }
#line 807
  tmp___0 = aztGetToc(0);
#line 807
  if (tmp___0 < 0) {
#line 808
    return (-5);
  }
#line 814
  if (! ((int )Toc[DiskInfo.first].ctrl_addr & 64)) {
#line 815
    DiskInfo.audio = (unsigned char)1;
  } else {
#line 817
    DiskInfo.audio = (unsigned char)0;
  }
#line 820
  if (! DiskInfo.audio) {
#line 821
    azt_Play.start.min = (unsigned char)0;
#line 822
    azt_Play.start.sec = (unsigned char)2;
#line 823
    azt_Play.start.frame = (unsigned char)0;
#line 824
    azt_Play.end.min = (unsigned char)0;
#line 825
    azt_Play.end.sec = (unsigned char)0;
#line 826
    azt_Play.end.frame = (unsigned char)1;
#line 827
    tmp___1 = sendAztCmd(32, & azt_Play);
#line 827
    if (tmp___1) {
#line 828
      return (-1);
    }
#line 829
    dten_low();
#line 830
    st = 0;
#line 830
    while (st < 2048) {
#line 831
      inb((unsigned int )aztcd);
#line 830
      st ++;
    }
  }
#line 833
  tmp___2 = getAztStatus();
#line 833
  DiskInfo.xa = (unsigned char )(tmp___2 & 1);
#line 834
  if (DiskInfo.xa) {
#line 835
    printk("aztcd: XA support experimental - mail results to Werner.Zimmermann@fht-esslingen.de\n");
  }
#line 843
  DiskInfo.multi = (unsigned char)0;
#line 845
  if (DiskInfo.xa) {
#line 846
    aztGetMultiDiskInfo();
  }
#line 849
  if (DiskInfo.multi) {
#line 850
    DiskInfo.lastSession.min = Toc[DiskInfo.next].diskTime.min;
#line 851
    DiskInfo.lastSession.sec = Toc[DiskInfo.next].diskTime.sec;
#line 852
    DiskInfo.lastSession.frame = Toc[DiskInfo.next].diskTime.frame;
#line 854
    printk("aztcd: Multisession support experimental\n");
  } else {
#line 856
    DiskInfo.lastSession.min = Toc[DiskInfo.first].diskTime.min;
#line 858
    DiskInfo.lastSession.sec = Toc[DiskInfo.first].diskTime.sec;
#line 860
    DiskInfo.lastSession.frame = Toc[DiskInfo.first].diskTime.frame;
  }
#line 864
  aztTocUpToDate = (char)1;
#line 868
  return (0);
}
}
#line 875 "aztcd.c"
int aztGetDiskInfo(void) 
{ 
  int limit ;
  unsigned char test ;
  struct azt_Toc qInfo ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 884
  tmp = aztSendCmd(49);
#line 884
  if (tmp) {
#line 885
    printk("aztcd: Warning: %s failed\n", "aztGetDiskInfo 1");
#line 885
    return (-1);
  }
#line 886
  statusAzt();
#line 887
  test = (unsigned char)0;
#line 888
  limit = 300;
#line 888
  while (limit > 0) {
#line 889
    tmp___0 = aztGetQChannelInfo(& qInfo);
#line 889
    if (tmp___0 < 0) {
#line 890
      printk("aztcd: Warning: %s failed\n", "aztGetDiskInfo 2");
#line 890
      return (-1);
    }
#line 891
    if ((int )qInfo.pointIndex == 160) {
#line 892
      DiskInfo.first = qInfo.diskTime.min;
#line 893
      tmp___1 = azt_bcd2bin(DiskInfo.first);
#line 893
      DiskInfo.first = (unsigned char )tmp___1;
#line 894
      test = (unsigned char )((int )test | 1);
    }
#line 896
    if ((int )qInfo.pointIndex == 161) {
#line 897
      DiskInfo.last = qInfo.diskTime.min;
#line 898
      tmp___2 = azt_bcd2bin(DiskInfo.last);
#line 898
      DiskInfo.last = (unsigned char )tmp___2;
#line 899
      test = (unsigned char )((int )test | 2);
    }
#line 901
    if ((int )qInfo.pointIndex == 162) {
#line 902
      DiskInfo.diskLength.min = qInfo.diskTime.min;
#line 903
      DiskInfo.diskLength.sec = qInfo.diskTime.sec;
#line 904
      DiskInfo.diskLength.frame = qInfo.diskTime.frame;
#line 905
      test = (unsigned char )((int )test | 4);
    }
#line 907
    if ((int )qInfo.pointIndex == (int )DiskInfo.first) {
#line 907
      if ((int )test & 1) {
#line 908
        DiskInfo.firstTrack.min = qInfo.diskTime.min;
#line 909
        DiskInfo.firstTrack.sec = qInfo.diskTime.sec;
#line 910
        DiskInfo.firstTrack.frame = qInfo.diskTime.frame;
#line 911
        test = (unsigned char )((int )test | 8);
      }
    }
#line 913
    if ((int )test == 15) {
#line 914
      break;
    }
#line 888
    limit --;
  }
#line 925
  if ((int )test != 15) {
#line 926
    return (-1);
  }
#line 927
  return (0);
}
}
#line 934 "aztcd.c"
int aztGetMultiDiskInfo(void) 
{ 
  int limit ;
  int k ;
  unsigned char test ;
  struct azt_Toc qInfo ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 936
  k = 5;
#line 944
  while (1) {
#line 945
    azt_Play.start.min = Toc[(int )DiskInfo.last + 1].diskTime.min;
#line 946
    azt_Play.start.sec = Toc[(int )DiskInfo.last + 1].diskTime.sec;
#line 947
    azt_Play.start.frame = Toc[(int )DiskInfo.last + 1].diskTime.frame;
#line 949
    test = (unsigned char)0;
#line 951
    limit = 30;
#line 951
    while (limit > 0) {
#line 952
      tmp = aztSeek(& azt_Play);
#line 952
      if (tmp) {
#line 953
        printk("aztcd: Warning: %s failed\n", "aztGetMultiDiskInfo 1");
#line 953
        return (-1);
      }
#line 954
      tmp___0 = aztGetQChannelInfo(& qInfo);
#line 954
      if (tmp___0 < 0) {
#line 955
        printk("aztcd: Warning: %s failed\n", "aztGetMultiDiskInfo 2");
#line 955
        return (-1);
      }
#line 956
      if ((int )qInfo.track == 0) {
#line 956
        if (qInfo.pointIndex) {
#line 957
          break;
        }
      }
#line 958
      azt_Play.start.sec = (unsigned char )((int )azt_Play.start.sec + 10);
#line 958
      if ((int )azt_Play.start.sec > 59) {
#line 959
        azt_Play.start.sec = (unsigned char)0;
#line 960
        azt_Play.start.min = (unsigned char )((int )azt_Play.start.min + 1);
      }
#line 951
      limit --;
    }
#line 963
    if (! limit) {
#line 964
      break;
    }
#line 970
    limit = 300;
#line 970
    while (limit > 0) {
#line 971
      azt_Play.start.frame = (unsigned char )((int )azt_Play.start.frame + 1);
#line 971
      if ((int )azt_Play.start.frame > 74) {
#line 972
        azt_Play.start.frame = (unsigned char)0;
#line 973
        if ((int )azt_Play.start.sec > 59) {
#line 974
          azt_Play.start.sec = (unsigned char)0;
#line 975
          azt_Play.start.min = (unsigned char )((int )azt_Play.start.min + 1);
        }
      }
#line 978
      tmp___1 = aztSeek(& azt_Play);
#line 978
      if (tmp___1) {
#line 979
        printk("aztcd: Warning: %s failed\n", "aztGetMultiDiskInfo 3");
#line 979
        return (-1);
      }
#line 980
      tmp___2 = aztGetQChannelInfo(& qInfo);
#line 980
      if (tmp___2 < 0) {
#line 981
        printk("aztcd: Warning: %s failed\n", "aztGetMultiDiskInfo 4");
#line 981
        return (-1);
      }
#line 982
      if ((int )qInfo.pointIndex == 160) {
#line 983
        DiskInfo.next = qInfo.diskTime.min;
#line 984
        tmp___3 = azt_bcd2bin(DiskInfo.next);
#line 984
        DiskInfo.next = (unsigned char )tmp___3;
#line 985
        test = (unsigned char )((int )test | 1);
      }
#line 987
      if ((int )qInfo.pointIndex == 161) {
#line 988
        DiskInfo.last = qInfo.diskTime.min;
#line 989
        tmp___4 = azt_bcd2bin(DiskInfo.last);
#line 989
        DiskInfo.last = (unsigned char )tmp___4;
#line 990
        test = (unsigned char )((int )test | 2);
      }
#line 992
      if ((int )qInfo.pointIndex == 162) {
#line 993
        DiskInfo.diskLength.min = qInfo.diskTime.min;
#line 995
        DiskInfo.diskLength.sec = qInfo.diskTime.sec;
#line 997
        DiskInfo.diskLength.frame = qInfo.diskTime.frame;
#line 999
        test = (unsigned char )((int )test | 4);
      }
#line 1001
      if ((int )qInfo.pointIndex == (int )DiskInfo.next) {
#line 1001
        if ((int )test & 1) {
#line 1002
          DiskInfo.nextSession.min = qInfo.diskTime.min;
#line 1004
          DiskInfo.nextSession.sec = qInfo.diskTime.sec;
#line 1006
          DiskInfo.nextSession.frame = qInfo.diskTime.frame;
#line 1008
          test = (unsigned char )((int )test | 8);
        }
      }
#line 1010
      if ((int )test == 15) {
#line 1011
        break;
      }
#line 970
      limit --;
    }
#line 1023
    if ((int )test != 15) {
#line 1024
      break;
    } else {
#line 1026
      DiskInfo.multi = (unsigned char)1;
    }
#line 1027
    aztGetToc(1);
#line 944
    k --;
#line 944
    if (! k) {
#line 944
      break;
    }
  }
#line 1033
  return (0);
}
}
#line 1040 "aztcd.c"
int aztGetToc(int multi ) 
{ 
  int i ;
  int px ;
  int limit ;
  struct azt_Toc qInfo ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 1049
  if (! multi) {
#line 1050
    i = 0;
#line 1050
    while (i < 104) {
#line 1051
      Toc[i].pointIndex = (unsigned char)0;
#line 1050
      i ++;
    }
#line 1052
    i = (int )DiskInfo.last + 3;
  } else {
#line 1054
    i = (int )DiskInfo.next;
#line 1054
    while (i < 104) {
#line 1055
      Toc[i].pointIndex = (unsigned char)0;
#line 1054
      i ++;
    }
#line 1056
    i = ((int )DiskInfo.last + 4) - (int )DiskInfo.next;
  }
#line 1064
  if (! multi) {
#line 1065
    azt_mode = 5;
#line 1066
    tmp = aztSendCmd(49);
#line 1066
    if (tmp) {
#line 1067
      printk("aztcd: Warning: %s failed\n", "aztGetToc 2");
#line 1067
      return (-1);
    }
#line 1068
    statusAzt();
  }
#line 1070
  limit = 300;
#line 1070
  while (limit > 0) {
#line 1071
    if (multi) {
#line 1072
      azt_Play.start.sec = (unsigned char )((int )azt_Play.start.sec + 1);
#line 1072
      if ((int )azt_Play.start.sec > 59) {
#line 1073
        azt_Play.start.sec = (unsigned char)0;
#line 1074
        azt_Play.start.min = (unsigned char )((int )azt_Play.start.min + 1);
      }
#line 1076
      tmp___0 = aztSeek(& azt_Play);
#line 1076
      if (tmp___0) {
#line 1077
        printk("aztcd: Warning: %s failed\n", "aztGetToc 3");
#line 1077
        return (-1);
      }
    }
#line 1079
    tmp___1 = aztGetQChannelInfo(& qInfo);
#line 1079
    if (tmp___1 < 0) {
#line 1080
      break;
    }
#line 1082
    px = azt_bcd2bin(qInfo.pointIndex);
#line 1084
    if (px > 0) {
#line 1084
      if (px < 104) {
#line 1084
        if ((int )qInfo.track == 0) {
#line 1085
          if ((int )Toc[px].pointIndex == 0) {
#line 1086
            Toc[px] = qInfo;
#line 1087
            i --;
          }
        }
      }
    }
#line 1090
    if (i <= 0) {
#line 1091
      break;
    }
#line 1070
    limit --;
  }
#line 1094
  Toc[(int )DiskInfo.last + 1].diskTime = DiskInfo.diskLength;
#line 1095
  Toc[DiskInfo.last].trackTime = DiskInfo.diskLength;
#line 1115
  if (limit > 0) {
#line 1115
    tmp___2 = 0;
  } else {
#line 1115
    tmp___2 = -1;
  }
#line 1115
  return (tmp___2);
}
}
#line 1145 "aztcd.c"
int check_aztcd_media_change(struct gendisk *disk ) 
{ 


  {
#line 1147
  if (aztDiskChanged) {
#line 1148
    aztDiskChanged = (char)0;
#line 1149
    return (1);
  } else {
#line 1151
    return (0);
  }
}
}
#line 1157 "aztcd.c"
int aztcd_ioctl(struct inode *ip , struct file *fp , unsigned int cmd , unsigned long arg ) 
{ 
  int i ;
  struct azt_Toc qInfo ;
  struct cdrom_ti ti ;
  struct cdrom_tochdr tocHdr ;
  struct cdrom_msf msf ;
  struct cdrom_tocentry entry ;
  struct azt_Toc *tocPtr ;
  struct cdrom_subchnl subchnl ;
  struct cdrom_volctrl volctrl ;
  void *argp ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  struct cdrom_multisession ms ;
  unsigned long tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  long tmp___8 ;
  unsigned long tmp___9 ;
  unsigned long tmp___10 ;
  unsigned long tmp___11 ;
  unsigned long tmp___12 ;
  unsigned long tmp___13 ;
  long tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  unsigned long tmp___18 ;
  unsigned long tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  long tmp___23 ;
  long tmp___24 ;
  int tmp___25 ;
  int tmp___26 ;
  int tmp___27 ;
  int tmp___28 ;
  int tmp___29 ;
  int tmp___30 ;
  unsigned long tmp___31 ;
  unsigned long tmp___32 ;
  int tmp___33 ;
  int tmp___34 ;
  unsigned char tmp___35 ;
  unsigned long tmp___36 ;
  int tmp___37 ;
  unsigned long tmp___38 ;
  int tmp___39 ;
  unsigned long tmp___40 ;
  unsigned long tmp___41 ;
  int tmp___42 ;
  int tmp___43 ;
  int tmp___44 ;

  {
#line 1169
  argp = (void *)arg;
#line 1176
  if (! ip) {
#line 1177
    printk("aztcd: Warning: %s failed\n", "aztcd_ioctl 1");
#line 1177
    return (-22);
  }
#line 1178
  tmp = getAztStatus();
#line 1178
  if (tmp < 0) {
#line 1179
    printk("aztcd: Warning: %s failed\n", "aztcd_ioctl 2");
#line 1179
    return (-5);
  }
#line 1180
  if (! aztTocUpToDate) {
#line 1180
    goto _L;
  } else
#line 1180
  if (aztDiskChanged) {
    _L: /* CIL Label */ 
#line 1181
    i = aztUpdateToc();
#line 1181
    if (i < 0) {
#line 1182
      printk("aztcd: Warning: %s failed\n", "aztcd_ioctl 3");
#line 1182
      return (i);
    }
  }
#line 1185
  switch (cmd) {
  case 21256U: 
#line 1189
  tmp___0 = aztSendCmd(97);
#line 1189
  if (tmp___0) {
#line 1190
    printk("aztcd: Warning: %s failed\n", "aztcd_ioctl 4");
#line 1190
    return (-1);
  }
#line 1191
  statusAzt();
#line 1193
  break;
  case 21255U: 
#line 1195
  tmp___1 = aztSendCmd(129);
#line 1195
  if (tmp___1) {
#line 1196
    printk("aztcd: Warning: %s failed\n", "aztcd_ioctl 5");
#line 1196
    return (-1);
  }
#line 1197
  statusAzt();
#line 1199
  aztAudioStatus = 21;
#line 1200
  break;
  case 21249U: 
#line 1202
  if (aztAudioStatus != 17) {
#line 1203
    return (-22);
  }
#line 1205
  tmp___2 = aztGetQChannelInfo(& qInfo);
#line 1205
  if (tmp___2 < 0) {
#line 1206
    aztAudioStatus = 21;
#line 1207
    printk("aztcd: Warning: %s failed\n", "aztcd_ioctl 7");
#line 1207
    return (0);
  }
#line 1209
  azt_Play.start = qInfo.diskTime;
#line 1211
  tmp___3 = aztSendCmd(128);
#line 1211
  if (tmp___3) {
#line 1212
    printk("aztcd: Warning: %s failed\n", "aztcd_ioctl 8");
#line 1212
    return (-1);
  }
#line 1213
  statusAzt();
#line 1214
  aztAudioStatus = 18;
#line 1215
  break;
  case 21250U: 
#line 1217
  if (aztAudioStatus != 18) {
#line 1218
    return (-22);
  }
#line 1220
  i = aztPlay(& azt_Play);
#line 1221
  if (i < 0) {
#line 1222
    aztAudioStatus = 20;
#line 1223
    return (-5);
  }
#line 1225
  aztAudioStatus = 17;
#line 1226
  break;
  case 21264U: 
#line 1233
  tmp___4 = copy_from_user((void *)(& ms), argp, sizeof(struct cdrom_multisession ));
#line 1233
  if (tmp___4) {
#line 1235
    return (-14);
  }
#line 1236
  if ((int )ms.addr_format == 2) {
#line 1237
    tmp___5 = azt_bcd2bin(DiskInfo.lastSession.min);
#line 1237
    ms.addr.msf.minute = (__u8 )tmp___5;
#line 1239
    tmp___6 = azt_bcd2bin(DiskInfo.lastSession.sec);
#line 1239
    ms.addr.msf.second = (__u8 )tmp___6;
#line 1241
    tmp___7 = azt_bcd2bin(DiskInfo.lastSession.frame);
#line 1241
    ms.addr.msf.frame = (__u8 )tmp___7;
  } else
#line 1244
  if ((int )ms.addr_format == 1) {
#line 1245
    tmp___8 = azt_msf2hsg(& DiskInfo.lastSession);
#line 1245
    ms.addr.lba = (int )tmp___8;
  } else {
#line 1248
    return (-22);
  }
#line 1249
  ms.xa_flag = DiskInfo.xa;
#line 1250
  tmp___9 = copy_to_user(argp, (void const   *)(& ms), sizeof(struct cdrom_multisession ));
#line 1250
  if (tmp___9) {
#line 1252
    return (-14);
  }
#line 1270
  return (0);
  case 21252U: 
#line 1273
  tmp___10 = copy_from_user((void *)(& ti), argp, sizeof(ti));
#line 1273
  if (tmp___10) {
#line 1274
    return (-14);
  }
#line 1275
  if ((int )ti.cdti_trk0 < (int )DiskInfo.first) {
#line 1278
    return (-22);
  } else
#line 1275
  if ((int )ti.cdti_trk0 > (int )DiskInfo.last) {
#line 1278
    return (-22);
  } else
#line 1275
  if ((int )ti.cdti_trk1 < (int )ti.cdti_trk0) {
#line 1278
    return (-22);
  }
#line 1280
  if ((int )ti.cdti_trk1 > (int )DiskInfo.last) {
#line 1281
    ti.cdti_trk1 = DiskInfo.last;
  }
#line 1282
  azt_Play.start = Toc[ti.cdti_trk0].diskTime;
#line 1283
  azt_Play.end = Toc[(int )ti.cdti_trk1 + 1].diskTime;
#line 1290
  i = aztPlay(& azt_Play);
#line 1291
  if (i < 0) {
#line 1292
    aztAudioStatus = 20;
#line 1293
    return (-5);
  }
#line 1295
  aztAudioStatus = 17;
#line 1296
  break;
  case 21251U: 
#line 1304
  tmp___11 = copy_from_user((void *)(& msf), argp, sizeof(msf));
#line 1304
  if (tmp___11) {
#line 1305
    return (-14);
  }
#line 1307
  azt_bin2bcd(& msf.cdmsf_min0);
#line 1308
  azt_bin2bcd(& msf.cdmsf_sec0);
#line 1309
  azt_bin2bcd(& msf.cdmsf_frame0);
#line 1310
  azt_bin2bcd(& msf.cdmsf_min1);
#line 1311
  azt_bin2bcd(& msf.cdmsf_sec1);
#line 1312
  azt_bin2bcd(& msf.cdmsf_frame1);
#line 1313
  azt_Play.start.min = msf.cdmsf_min0;
#line 1314
  azt_Play.start.sec = msf.cdmsf_sec0;
#line 1315
  azt_Play.start.frame = msf.cdmsf_frame0;
#line 1316
  azt_Play.end.min = msf.cdmsf_min1;
#line 1317
  azt_Play.end.sec = msf.cdmsf_sec1;
#line 1318
  azt_Play.end.frame = msf.cdmsf_frame1;
#line 1325
  i = aztPlay(& azt_Play);
#line 1326
  if (i < 0) {
#line 1327
    aztAudioStatus = 20;
#line 1328
    return (-5);
  }
#line 1330
  aztAudioStatus = 17;
#line 1331
  break;
  case 21253U: 
#line 1334
  tocHdr.cdth_trk0 = DiskInfo.first;
#line 1335
  tocHdr.cdth_trk1 = DiskInfo.last;
#line 1336
  tmp___12 = copy_to_user(argp, (void const   *)(& tocHdr), sizeof(tocHdr));
#line 1336
  if (tmp___12) {
#line 1337
    return (-14);
  }
#line 1338
  break;
  case 21254U: 
#line 1340
  tmp___13 = copy_from_user((void *)(& entry), argp, sizeof(entry));
#line 1340
  if (tmp___13) {
#line 1341
    return (-14);
  }
#line 1342
  if (! aztTocUpToDate) {
#line 1343
    aztUpdateToc();
  } else
#line 1342
  if (aztDiskChanged) {
#line 1343
    aztUpdateToc();
  }
#line 1344
  if ((int )entry.cdte_track == 170) {
#line 1345
    tocPtr = & Toc[(int )DiskInfo.last + 1];
  } else
#line 1346
  if ((int )entry.cdte_track > (int )DiskInfo.last) {
#line 1348
    return (-22);
  } else
#line 1346
  if ((int )entry.cdte_track < (int )DiskInfo.first) {
#line 1348
    return (-22);
  } else {
#line 1350
    tocPtr = & Toc[entry.cdte_track];
  }
#line 1351
  entry.cdte_adr = tocPtr->ctrl_addr;
#line 1352
  entry.cdte_ctrl = (__u8 )((int )tocPtr->ctrl_addr >> 4);
#line 1353
  if ((int )entry.cdte_format == 1) {
#line 1354
    tmp___14 = azt_msf2hsg(& tocPtr->diskTime);
#line 1354
    entry.cdte_addr.lba = (int )tmp___14;
  } else
#line 1356
  if ((int )entry.cdte_format == 2) {
#line 1357
    tmp___15 = azt_bcd2bin(tocPtr->diskTime.min);
#line 1357
    entry.cdte_addr.msf.minute = (__u8 )tmp___15;
#line 1359
    tmp___16 = azt_bcd2bin(tocPtr->diskTime.sec);
#line 1359
    entry.cdte_addr.msf.second = (__u8 )tmp___16;
#line 1361
    tmp___17 = azt_bcd2bin(tocPtr->diskTime.frame);
#line 1361
    entry.cdte_addr.msf.frame = (__u8 )tmp___17;
  } else {
#line 1364
    return (-22);
  }
#line 1366
  tmp___18 = copy_to_user(argp, (void const   *)(& entry), sizeof(entry));
#line 1366
  if (tmp___18) {
#line 1367
    return (-14);
  }
#line 1368
  break;
  case 21259U: 
#line 1370
  tmp___19 = copy_from_user((void *)(& subchnl), argp, sizeof(struct cdrom_subchnl ));
#line 1370
  if (tmp___19) {
#line 1372
    return (-14);
  }
#line 1373
  tmp___20 = aztGetQChannelInfo(& qInfo);
#line 1373
  if (tmp___20 < 0) {
#line 1379
    return (-5);
  }
#line 1381
  subchnl.cdsc_audiostatus = (__u8 )aztAudioStatus;
#line 1382
  subchnl.cdsc_adr = qInfo.ctrl_addr;
#line 1383
  subchnl.cdsc_ctrl = (__u8 )((int )qInfo.ctrl_addr >> 4);
#line 1384
  tmp___21 = azt_bcd2bin(qInfo.track);
#line 1384
  subchnl.cdsc_trk = (__u8 )tmp___21;
#line 1385
  tmp___22 = azt_bcd2bin(qInfo.pointIndex);
#line 1385
  subchnl.cdsc_ind = (__u8 )tmp___22;
#line 1386
  if ((int )subchnl.cdsc_format == 1) {
#line 1387
    tmp___23 = azt_msf2hsg(& qInfo.diskTime);
#line 1387
    subchnl.cdsc_absaddr.lba = (int )tmp___23;
#line 1389
    tmp___24 = azt_msf2hsg(& qInfo.trackTime);
#line 1389
    subchnl.cdsc_reladdr.lba = (int )tmp___24;
  } else {
#line 1392
    subchnl.cdsc_format = (__u8 )2;
#line 1393
    tmp___25 = azt_bcd2bin(qInfo.diskTime.min);
#line 1393
    subchnl.cdsc_absaddr.msf.minute = (__u8 )tmp___25;
#line 1395
    tmp___26 = azt_bcd2bin(qInfo.diskTime.sec);
#line 1395
    subchnl.cdsc_absaddr.msf.second = (__u8 )tmp___26;
#line 1397
    tmp___27 = azt_bcd2bin(qInfo.diskTime.frame);
#line 1397
    subchnl.cdsc_absaddr.msf.frame = (__u8 )tmp___27;
#line 1399
    tmp___28 = azt_bcd2bin(qInfo.trackTime.min);
#line 1399
    subchnl.cdsc_reladdr.msf.minute = (__u8 )tmp___28;
#line 1401
    tmp___29 = azt_bcd2bin(qInfo.trackTime.sec);
#line 1401
    subchnl.cdsc_reladdr.msf.second = (__u8 )tmp___29;
#line 1403
    tmp___30 = azt_bcd2bin(qInfo.trackTime.frame);
#line 1403
    subchnl.cdsc_reladdr.msf.frame = (__u8 )tmp___30;
  }
#line 1406
  tmp___31 = copy_to_user(argp, (void const   *)(& subchnl), sizeof(struct cdrom_subchnl ));
#line 1406
  if (tmp___31) {
#line 1407
    return (-14);
  }
#line 1408
  break;
  case 21258U: 
#line 1413
  tmp___32 = copy_from_user((void *)(& volctrl), argp, sizeof(volctrl));
#line 1413
  if (tmp___32) {
#line 1414
    return (-14);
  }
#line 1415
  azt_Play.start.min = (unsigned char)33;
#line 1416
  azt_Play.start.sec = (unsigned char)132;
#line 1417
  azt_Play.start.frame = volctrl.channel0;
#line 1418
  azt_Play.end.min = volctrl.channel1;
#line 1419
  azt_Play.end.sec = volctrl.channel2;
#line 1420
  azt_Play.end.frame = volctrl.channel3;
#line 1421
  sendAztCmd(147, & azt_Play);
#line 1422
  statusAzt();
#line 1423
  break;
  case 21257U: 
#line 1425
  aztUnlockDoor();
#line 1427
  if (aztAudioStatus == 17) {
#line 1428
    tmp___33 = aztSendCmd(129);
#line 1428
    if (tmp___33) {
#line 1429
      printk("aztcd: Warning: %s failed\n", "azt_ioctl 10");
#line 1429
      return (-1);
    }
#line 1430
    statusAzt();
  }
#line 1432
  tmp___34 = aztSendCmd(96);
#line 1432
  if (tmp___34) {
#line 1433
    printk("aztcd: Warning: %s failed\n", "azt_ioctl 11");
#line 1433
    return (-1);
  }
#line 1434
  statusAzt();
#line 1435
  aztAudioStatus = 21;
#line 1436
  break;
  case 21263U: 
#line 1438
  azt_auto_eject = (char )arg;
#line 1439
  break;
  case 21266U: 
#line 1441
  outb((unsigned char)16, (unsigned int )aztcd);
#line 1442
  sten_low();
#line 1443
  tmp___35 = inb((unsigned int )aztcd);
#line 1443
  if ((int )tmp___35 != 1) {
#line 1444
    printk("aztcd: AZTECH CD-ROM drive does not respond\n");
  }
#line 1447
  break;
  case 21268U: 
  case 21269U: 
#line 1456
  tmp___36 = copy_from_user((void *)(& msf), argp, sizeof(msf));
#line 1456
  if (tmp___36) {
#line 1457
    return (-14);
  }
#line 1459
  azt_bin2bcd(& msf.cdmsf_min0);
#line 1460
  azt_bin2bcd(& msf.cdmsf_sec0);
#line 1461
  azt_bin2bcd(& msf.cdmsf_frame0);
#line 1462
  msf.cdmsf_min1 = (__u8 )0;
#line 1463
  msf.cdmsf_sec1 = (__u8 )0;
#line 1464
  msf.cdmsf_frame1 = (__u8 )1;
#line 1465
  azt_Play.start.min = msf.cdmsf_min0;
#line 1466
  azt_Play.start.sec = msf.cdmsf_sec0;
#line 1467
  azt_Play.start.frame = msf.cdmsf_frame0;
#line 1468
  azt_Play.end.min = msf.cdmsf_min1;
#line 1469
  azt_Play.end.sec = msf.cdmsf_sec1;
#line 1470
  azt_Play.end.frame = msf.cdmsf_frame1;
#line 1471
  if (cmd == 21268U) {
#line 1472
    if (DiskInfo.xa) {
#line 1473
      return (-1);
    } else {
#line 1475
      tmp___37 = sendAztCmd(33, & azt_Play);
#line 1475
      if (tmp___37) {
#line 1476
        return (-1);
      }
#line 1477
      dten_low();
#line 1478
      insb((unsigned int )aztcd, (void *)(buf), 2352UL);
#line 1479
      tmp___38 = copy_to_user(argp, (void const   *)(& buf), 2352UL);
#line 1479
      if (tmp___38) {
#line 1480
        return (-14);
      }
    }
  } else {
#line 1484
    tmp___39 = sendAztCmd(32, & azt_Play);
#line 1484
    if (tmp___39) {
#line 1485
      return (-1);
    }
#line 1486
    dten_low();
#line 1487
    insb((unsigned int )aztcd, (void *)(buf), 2048UL);
#line 1488
    tmp___40 = copy_to_user(argp, (void const   *)(& buf), 2048UL);
#line 1488
    if (tmp___40) {
#line 1489
      return (-14);
    }
  }
#line 1492
  break;
  case 21270U: 
#line 1494
  tmp___41 = copy_from_user((void *)(& msf), argp, sizeof(msf));
#line 1494
  if (tmp___41) {
#line 1495
    return (-14);
  }
#line 1497
  azt_bin2bcd(& msf.cdmsf_min0);
#line 1498
  azt_bin2bcd(& msf.cdmsf_sec0);
#line 1499
  azt_bin2bcd(& msf.cdmsf_frame0);
#line 1500
  azt_Play.start.min = msf.cdmsf_min0;
#line 1501
  azt_Play.start.sec = msf.cdmsf_sec0;
#line 1502
  azt_Play.start.frame = msf.cdmsf_frame0;
#line 1503
  tmp___42 = aztSeek(& azt_Play);
#line 1503
  if (tmp___42) {
#line 1504
    return (-1);
  }
#line 1505
  break;
  case 21261U: 
#line 1508
  tmp___43 = aztSetDiskType(1);
#line 1508
  return (tmp___43);
  case 21260U: 
#line 1510
  tmp___44 = aztSetDiskType(2);
#line 1510
  return (tmp___44);
  default: 
#line 1512
  return (-22);
  }
#line 1518
  return (0);
}
}
#line 1525 "aztcd.c"
void azt_transfer(void) 
{ 
  int tmp ;
  int bn ;
  struct request *tmp___0 ;
  int i ;
  int offs ;
  struct request *tmp___1 ;
  int nr_sectors ;
  struct request *tmp___2 ;
  struct request *tmp___3 ;
  struct request *tmp___4 ;
  struct request *tmp___5 ;
  struct request *tmp___6 ;
  struct request *tmp___7 ;
  struct request *tmp___8 ;
  struct request *tmp___9 ;

  {
#line 1530
  tmp = current_valid();
#line 1530
  if (! tmp) {
#line 1531
    return;
  }
#line 1533
  while (1) {
#line 1533
    tmp___9 = elv_next_request(azt_queue);
#line 1533
    if (! tmp___9->nr_sectors) {
#line 1533
      break;
    }
#line 1534
    tmp___0 = elv_next_request(azt_queue);
#line 1534
    bn = (int )(tmp___0->sector / 4UL);
#line 1536
    i = 0;
#line 1536
    while (1) {
#line 1536
      if (i < 16) {
#line 1536
        if (! (azt_buf_bn[i] != (int volatile   )bn)) {
#line 1536
          break;
        }
      } else {
#line 1536
        break;
      }
#line 1536
      i ++;
    }
#line 1537
    if (i < 16) {
#line 1538
      tmp___1 = elv_next_request(azt_queue);
#line 1538
      offs = (int )(((unsigned long )(i * 4) + (tmp___1->sector & 3UL)) * 512UL);
#line 1539
      tmp___2 = elv_next_request(azt_queue);
#line 1539
      nr_sectors = (int )(4UL - (tmp___2->sector & 3UL));
#line 1540
      if (azt_buf_out != (int volatile   )i) {
#line 1541
        azt_buf_out = (int volatile   )i;
#line 1542
        if (azt_buf_bn[i] != (int volatile   )bn) {
#line 1543
          azt_buf_out = (int volatile   )-1;
#line 1544
          continue;
        }
      }
#line 1547
      tmp___4 = elv_next_request(azt_queue);
#line 1547
      if ((unsigned long )nr_sectors > tmp___4->nr_sectors) {
#line 1548
        tmp___3 = elv_next_request(azt_queue);
#line 1548
        nr_sectors = (int )tmp___3->nr_sectors;
      }
#line 1549
      tmp___5 = elv_next_request(azt_queue);
#line 1549
      memcpy((void *)tmp___5->buffer, (void const   *)(azt_buf + offs), (__kernel_size_t )(nr_sectors * 512));
#line 1551
      tmp___6 = elv_next_request(azt_queue);
#line 1551
      tmp___6->nr_sectors -= (unsigned long )nr_sectors;
#line 1552
      tmp___7 = elv_next_request(azt_queue);
#line 1552
      tmp___7->sector += (sector_t )nr_sectors;
#line 1553
      tmp___8 = elv_next_request(azt_queue);
#line 1553
      tmp___8->buffer += nr_sectors * 512;
    } else {
#line 1555
      azt_buf_out = (int volatile   )-1;
#line 1556
      break;
    }
  }
#line 1559
  return;
}
}
#line 1561 "aztcd.c"
void do_aztcd_request(request_queue_t *q ) 
{ 
  struct request *tmp ;
  struct request *tmp___0 ;
  struct request *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  struct request *tmp___4 ;
  int tmp___5 ;

  {
#line 1567
  if (DiskInfo.audio) {
#line 1568
    printk("aztcd: Error, tried to mount an Audio CD\n");
#line 1569
    tmp = elv_next_request(azt_queue);
#line 1569
    end_request(tmp, 0);
#line 1570
    return;
  }
#line 1572
  azt_transfer_is_active = (int volatile   )1;
#line 1573
  while (1) {
#line 1573
    tmp___5 = current_valid();
#line 1573
    if (! tmp___5) {
#line 1573
      break;
    }
#line 1574
    azt_transfer();
#line 1575
    tmp___4 = elv_next_request(azt_queue);
#line 1575
    if (tmp___4->nr_sectors == 0UL) {
#line 1576
      tmp___0 = elv_next_request(azt_queue);
#line 1576
      end_request(tmp___0, 1);
    } else {
#line 1578
      azt_buf_out = (int volatile   )-1;
#line 1579
      if ((unsigned int volatile   )azt_state == (unsigned int volatile   )0) {
#line 1580
        if (! aztTocUpToDate) {
#line 1580
          goto _L;
        } else
#line 1580
        if (aztDiskChanged) {
          _L: /* CIL Label */ 
#line 1581
          tmp___3 = aztUpdateToc();
#line 1581
          if (tmp___3 < 0) {
#line 1582
            while (1) {
#line 1582
              tmp___2 = current_valid();
#line 1582
              if (! tmp___2) {
#line 1582
                break;
              }
#line 1583
              tmp___1 = elv_next_request(azt_queue);
#line 1583
              end_request(tmp___1, 0);
            }
#line 1584
            break;
          }
        }
#line 1587
        azt_state = (enum azt_state_e  volatile  )1;
#line 1588
        AztTries = 5;
#line 1589
        delay_timer.expires = jiffies + 1UL;
#line 1589
        delay_timer.function = (void (*)(unsigned long  ))((void *)(& azt_poll));
#line 1589
        add_timer(& delay_timer);
      }
#line 1591
      break;
    }
  }
#line 1594
  azt_transfer_is_active = (int volatile   )0;
#line 1601
  return;
}
}
#line 1604 "aztcd.c"
void azt_invalidate_buffers(void) 
{ 
  int i ;

  {
#line 1611
  i = 0;
#line 1611
  while (i < 16) {
#line 1612
    azt_buf_bn[i] = (int volatile   )-1;
#line 1611
    i ++;
  }
#line 1613
  azt_buf_out = (int volatile   )-1;
#line 1614
  return;
}
}
#line 1619 "aztcd.c"
int aztcd_open(struct inode *ip , struct file *fp ) 
{ 
  int st ;
  int tmp ;

  {
#line 1627
  if (aztPresent == 0) {
#line 1628
    return (-6);
  }
#line 1630
  if (! azt_open_count) {
#line 1630
    if ((unsigned int volatile   )azt_state == (unsigned int volatile   )0) {
#line 1631
      azt_invalidate_buffers();
#line 1633
      st = getAztStatus();
#line 1634
      if (st == -1) {
#line 1635
        goto err_out;
      }
#line 1637
      if (st & 64) {
#line 1638
        printk("aztcd: Door Open?\n");
#line 1639
        aztCloseDoor();
#line 1640
        st = getAztStatus();
      }
#line 1643
      if (st & 32) {
#line 1644
        printk("aztcd: Disk Changed or No Disk in Drive?\n");
#line 1646
        aztTocUpToDate = (char)0;
      } else
#line 1643
      if (st & 2) {
#line 1644
        printk("aztcd: Disk Changed or No Disk in Drive?\n");
#line 1646
        aztTocUpToDate = (char)0;
      }
#line 1648
      tmp = aztUpdateToc();
#line 1648
      if (tmp) {
#line 1649
        goto err_out;
      }
    }
  }
#line 1652
  azt_open_count ++;
#line 1653
  aztLockDoor();
#line 1658
  return (0);
  err_out: 
#line 1661
  return (-5);
}
}
#line 1668 "aztcd.c"
int aztcd_release(struct inode *inode , struct file *file ) 
{ 


  {
#line 1675
  azt_open_count --;
#line 1675
  if (! azt_open_count) {
#line 1676
    azt_invalidate_buffers();
#line 1677
    aztUnlockDoor();
#line 1678
    if (azt_auto_eject) {
#line 1679
      aztSendCmd(96);
    }
#line 1680
    del_timer(& delay_timer);
  }
#line 1682
  return (0);
}
}
#line 1685 "aztcd.c"
struct gendisk *azt_disk  ;
#line 1691 "aztcd.c"
int aztcd_init(void) 
{ 
  long count ;
  long max_count ;
  unsigned char result[50] ;
  int st ;
  void *status ;
  int i ;
  int ret ;
  struct resource *tmp ;
  unsigned char tmp___0 ;
  struct resource *tmp___1 ;
  struct resource *tmp___2 ;
  unsigned char tmp___3 ;
  unsigned char tmp___4 ;
  int tmp___5 ;

  {
#line 1696
  status = (void *)0;
#line 1697
  i = 0;
#line 1698
  ret = 0;
#line 1700
  if (aztcd == 0) {
#line 1701
    printk("<6>aztcd: no Aztech CD-ROM Initialization");
#line 1702
    return (-5);
  }
#line 1705
  printk("<6>aztcd: AZTECH, ORCHID, OKANO, WEARNES, TXC, CyDROM CD-ROM Driver\n");
#line 1707
  printk("<6>aztcd: (C) 1994-98 W.Zimmermann\n");
#line 1708
  if (aztcd == -1) {
#line 1709
    printk("aztcd: DriverVersion=%s For IDE/ATAPI-drives use ide-cd.c\n", "2.60");
  } else {
#line 1713
    printk("aztcd: DriverVersion=%s BaseAddress=0x%x  For IDE/ATAPI-drives use ide-cd.c\n",
           "2.60", aztcd);
  }
#line 1716
  printk("<6>aztcd: If you have problems, read /usr/src/linux/Documentation/cdrom/aztcd\n");
#line 1738
  if (aztcd == -1) {
#line 1739
    i = 0;
#line 1739
    while (1) {
#line 1739
      if (azt_port_auto[i] != 0) {
#line 1739
        if (! (i < 16)) {
#line 1739
          break;
        }
      } else {
#line 1739
        break;
      }
#line 1740
      aztcd = azt_port_auto[i];
#line 1741
      printk("<6>aztcd: Autoprobing BaseAddress=0x%x\n", aztcd);
#line 1744
      tmp = request_region((unsigned long )aztcd, 4UL, "aztcd");
#line 1744
      if (! tmp) {
#line 1745
        goto __Cont;
      }
#line 1747
      outb((unsigned char)4, (unsigned int )(aztcd + 2));
#line 1748
      inb((unsigned int )aztcd);
#line 1749
      inb((unsigned int )aztcd);
#line 1750
      outb((unsigned char)160, (unsigned int )aztcd);
#line 1752
      aztTimeOutCount = 0UL;
#line 1753
      while (1) {
#line 1754
        aztIndatum = inb((unsigned int )(aztcd + 1));
#line 1755
        aztTimeOutCount ++;
#line 1756
        if (aztTimeOutCount >= 10000UL) {
#line 1757
          break;
        }
#line 1753
        if (! ((int )aztIndatum & 4)) {
#line 1753
          break;
        }
      }
#line 1759
      tmp___0 = inb((unsigned int )aztcd);
#line 1759
      if ((int )tmp___0 == 1) {
#line 1760
        break;
      } else {
#line 1763
        release_region((unsigned long )aztcd, 4UL);
      }
      __Cont: /* CIL Label */ 
#line 1739
      i ++;
    }
#line 1766
    if (azt_port_auto[i] == 0) {
#line 1767
      printk("<6>aztcd: no AZTECH CD-ROM drive found\n");
#line 1768
      return (-5);
    } else
#line 1766
    if (i == 16) {
#line 1767
      printk("<6>aztcd: no AZTECH CD-ROM drive found\n");
#line 1768
      return (-5);
    }
  } else {
#line 1771
    if (aztcd == 496) {
#line 1772
      tmp___1 = request_region((unsigned long )aztcd, 8UL, "aztcd");
#line 1772
      status = (void *)tmp___1;
    } else
#line 1771
    if (aztcd == 368) {
#line 1772
      tmp___1 = request_region((unsigned long )aztcd, 8UL, "aztcd");
#line 1772
      status = (void *)tmp___1;
    } else {
#line 1774
      tmp___2 = request_region((unsigned long )aztcd, 4UL, "aztcd");
#line 1774
      status = (void *)tmp___2;
    }
#line 1775
    if (! status) {
#line 1776
      printk("<4>aztcd: conflict, I/O port (%X) already used\n", aztcd);
#line 1778
      return (-5);
    }
#line 1781
    if (aztcd == 496) {
#line 1782
      outb_p((unsigned char)160, (unsigned int )(aztcd + 6));
    } else
#line 1781
    if (aztcd == 368) {
#line 1782
      outb_p((unsigned char)160, (unsigned int )(aztcd + 6));
    }
#line 1782
    outb_p((unsigned char)16, (unsigned int )(aztcd + 6));
#line 1782
    outb_p((unsigned char)0, (unsigned int )(aztcd + 7));
#line 1782
    outb_p((unsigned char)16, (unsigned int )(aztcd + 6));
#line 1784
    outb((unsigned char)4, (unsigned int )(aztcd + 2));
#line 1785
    inb((unsigned int )aztcd);
#line 1786
    inb((unsigned int )aztcd);
#line 1787
    outb((unsigned char)160, (unsigned int )aztcd);
#line 1789
    aztTimeOutCount = 0UL;
#line 1790
    while (1) {
#line 1791
      aztIndatum = inb((unsigned int )(aztcd + 1));
#line 1792
      aztTimeOutCount ++;
#line 1793
      if (aztTimeOutCount >= 10000UL) {
#line 1794
        break;
      }
#line 1790
      if (! ((int )aztIndatum & 4)) {
#line 1790
        break;
      }
    }
#line 1797
    tmp___4 = inb((unsigned int )aztcd);
#line 1797
    if ((int )tmp___4 != 1) {
#line 1811
      printk("<6>aztcd: drive reset - please wait\n");
#line 1813
      count = 0L;
#line 1813
      while (count < 50L) {
#line 1814
        inb((unsigned int )(aztcd + 1));
#line 1815
        inb((unsigned int )aztcd);
#line 1813
        count ++;
      }
#line 1817
      outb((unsigned char)4, (unsigned int )(aztcd + 2));
#line 1818
      inb((unsigned int )aztcd);
#line 1819
      inb((unsigned int )aztcd);
#line 1820
      getAztStatus();
#line 1821
      outb((unsigned char)16, (unsigned int )aztcd);
#line 1822
      sten_low();
#line 1823
      tmp___3 = inb((unsigned int )aztcd);
#line 1823
      if ((int )tmp___3 != 1) {
#line 1824
        printk("<4>aztcd: no AZTECH CD-ROM drive found\n");
#line 1826
        ret = -5;
#line 1827
        goto err_out;
      }
#line 1830
      count = 0L;
#line 1830
      while (count < 8000000L) {
#line 1832
        barrier();
#line 1830
        count ++;
      }
#line 1835
      st = getAztStatus();
#line 1835
      if (st == -1) {
#line 1836
        printk("<4>aztcd: Drive Status Error Status=%x\n", st);
#line 1838
        ret = -5;
#line 1839
        goto err_out;
      }
#line 1844
      outb((unsigned char)4, (unsigned int )(aztcd + 2));
#line 1845
      inb((unsigned int )aztcd);
#line 1846
      inb((unsigned int )aztcd);
#line 1847
      outb((unsigned char)160, (unsigned int )aztcd);
#line 1848
      sten_low();
#line 1849
      op_ok();
    }
  }
#line 1854
  azt_init_end = (char)1;
#line 1855
  sten_low();
#line 1856
  result[0] = inb((unsigned int )aztcd);
#line 1857
  count = 1L;
#line 1857
  while (count < 50L) {
#line 1858
    aztTimeOutCount = 0UL;
#line 1859
    while (1) {
#line 1860
      aztIndatum = inb((unsigned int )(aztcd + 1));
#line 1861
      aztTimeOutCount ++;
#line 1862
      if (aztTimeOutCount >= 10000UL) {
#line 1863
        break;
      }
#line 1859
      if (! ((int )aztIndatum & 4)) {
#line 1859
        break;
      }
    }
#line 1865
    if (aztTimeOutCount >= 10000UL) {
#line 1866
      break;
    }
#line 1867
    result[count] = inb((unsigned int )aztcd);
#line 1857
    count ++;
  }
#line 1869
  if (count > 30L) {
#line 1870
    max_count = 30L;
  } else {
#line 1872
    max_count = count;
  }
#line 1873
  printk("<6>aztcd: FirmwareVersion=");
#line 1874
  count = 1L;
#line 1874
  while (count < max_count) {
#line 1875
    printk("%c", (int )result[count]);
#line 1874
    count ++;
  }
#line 1876
  printk("<<>> ");
#line 1878
  if ((int )result[1] == 65) {
#line 1878
    if ((int )result[2] == 90) {
#line 1878
      if ((int )result[3] == 84) {
#line 1879
        printk("AZTECH drive detected\n");
      } else {
#line 1878
        goto _L___3;
      }
    } else {
#line 1878
      goto _L___3;
    }
  } else
  _L___3: /* CIL Label */ 
#line 1881
  if ((int )result[2] == 67) {
#line 1881
    if ((int )result[3] == 68) {
#line 1881
      if ((int )result[4] == 68) {
#line 1883
        printk("ORCHID or WEARNES drive detected\n");
      } else {
#line 1881
        goto _L___1;
      }
    } else {
#line 1881
      goto _L___1;
    }
  } else
  _L___1: /* CIL Label */ 
#line 1884
  if ((int )result[1] == 3) {
#line 1884
    if ((int )result[2] == 53) {
#line 1885
      printk("TXC or CyCDROM drive detected\n");
    } else {
#line 1884
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
#line 1887
    printk("\nunknown drive or firmware version detected\n");
#line 1888
    printk("aztcd may not run stable, if you want to try anyhow,\n");
#line 1890
    printk("boot with: aztcd=<BaseAddress>,0x79\n");
#line 1891
    if ((int )azt_cont != 121) {
#line 1892
      printk("aztcd: FirmwareVersion=");
#line 1893
      count = 1L;
#line 1893
      while (count < 5L) {
#line 1894
        printk("%c", (int )result[count]);
#line 1893
        count ++;
      }
#line 1895
      printk("<<>> ");
#line 1896
      printk("Aborted\n");
#line 1897
      ret = -5;
#line 1898
      goto err_out;
    }
  }
#line 1901
  azt_disk = alloc_disk(1);
#line 1902
  if (! azt_disk) {
#line 1903
    goto err_out;
  }
#line 1905
  tmp___5 = register_blkdev(29U, "aztcd");
#line 1905
  if (tmp___5) {
#line 1906
    ret = -5;
#line 1907
    goto err_out2;
  }
#line 1910
  azt_queue = blk_init_queue(& do_aztcd_request, & aztSpin);
#line 1911
  if (! azt_queue) {
#line 1912
    ret = -12;
#line 1913
    goto err_out3;
  }
#line 1916
  blk_queue_hardsect_size(azt_queue, (unsigned short)2048);
#line 1917
  azt_disk->major = 29;
#line 1918
  azt_disk->first_minor = 0;
#line 1919
  azt_disk->fops = & azt_fops;
#line 1920
  sprintf(azt_disk->disk_name, "aztcd");
#line 1921
  sprintf(azt_disk->devfs_name, "aztcd");
#line 1922
  azt_disk->queue = azt_queue;
#line 1923
  add_disk(azt_disk);
#line 1924
  azt_invalidate_buffers();
#line 1925
  aztPresent = 1;
#line 1926
  aztCloseDoor();
#line 1927
  return (0);
  err_out3: 
#line 1929
  unregister_blkdev(29U, "aztcd");
  err_out2: 
#line 1931
  put_disk(azt_disk);
  err_out: 
#line 1933
  if (aztcd == 496) {
#line 1934
    outb_p((unsigned char)160, (unsigned int )(aztcd + 6));
#line 1935
    release_region((unsigned long )aztcd, 8UL);
  } else
#line 1933
  if (aztcd == 368) {
#line 1934
    outb_p((unsigned char)160, (unsigned int )(aztcd + 6));
#line 1935
    release_region((unsigned long )aztcd, 8UL);
  } else {
#line 1937
    release_region((unsigned long )aztcd, 4UL);
  }
#line 1938
  return (ret);
}
}
#line 1942 "aztcd.c"
void aztcd_exit(void) 
{ 
  int tmp ;

  {
#line 1944
  del_gendisk(azt_disk);
#line 1945
  put_disk(azt_disk);
#line 1946
  tmp = unregister_blkdev(29U, "aztcd");
#line 1946
  if (tmp == -22) {
#line 1947
    printk("What\'s that: can\'t unregister aztcd\n");
#line 1948
    return;
  }
#line 1950
  blk_cleanup_queue(azt_queue);
#line 1951
  if (aztcd == 496) {
#line 1952
    outb_p((unsigned char)160, (unsigned int )(aztcd + 6));
#line 1953
    release_region((unsigned long )aztcd, 8UL);
  } else
#line 1951
  if (aztcd == 368) {
#line 1952
    outb_p((unsigned char)160, (unsigned int )(aztcd + 6));
#line 1953
    release_region((unsigned long )aztcd, 8UL);
  } else {
#line 1955
    release_region((unsigned long )aztcd, 4UL);
  }
#line 1956
  printk("<6>aztcd module released.\n");
#line 1957
  return;
}
}
#line 1959 "aztcd.c"
int (*_ddv_tmp_init)(void)  =    & aztcd_init;
#line 1960 "aztcd.c"
void (*_ddv_tmp_exit)(void)  =    & aztcd_exit;
#line 1966 "aztcd.c"
void azt_poll(void) 
{ 
  int st ;
  int loop_ctl ;
  int skip ;
  int tmp ;
  unsigned char tmp___0 ;
  struct request *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  struct request *tmp___5 ;
  struct request *tmp___6 ;
  char const   *tmp___7 ;
  struct request *tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  struct request *tmp___11 ;
  char const   *tmp___12 ;
  struct request *tmp___13 ;
  int tmp___14 ;
  struct azt_Play_msf msf ;
  int i ;
  struct request *tmp___15 ;
  long tmp___16 ;
  long tmp___17 ;
  long tmp___18 ;
  long tmp___19 ;
  long tmp___20 ;
  long tmp___21 ;
  int tmp___22 ;
  unsigned char tmp___23 ;
  struct request *tmp___24 ;
  int tmp___25 ;
  int tmp___26 ;
  int tmp___27 ;
  struct request *tmp___28 ;
  struct request *tmp___29 ;
  int volatile   tmp___30 ;
  struct request *tmp___31 ;
  struct request *tmp___32 ;
  int tmp___33 ;
  int tmp___34 ;
  struct request *tmp___35 ;
  struct request *tmp___36 ;
  int i___0 ;
  unsigned char tmp___37 ;
  int tmp___38 ;
  struct request *tmp___39 ;
  int tmp___40 ;
  int tmp___41 ;
  int tmp___42 ;

  {
#line 1968
  st = 0;
#line 1969
  loop_ctl = 1;
#line 1970
  skip = 0;
#line 1972
  if (azt_error) {
#line 1973
    tmp = aztSendCmd(64);
#line 1973
    if (tmp) {
#line 1974
      printk("aztcd: Warning: %s failed\n", "azt_poll 1");
#line 1974
      return;
    }
#line 1975
    sten_low();
#line 1976
    tmp___0 = inb((unsigned int )aztcd);
#line 1976
    azt_error = (int volatile   )((int )tmp___0 & 255);
#line 1977
    printk("aztcd: I/O error 0x%02x\n", azt_error);
#line 1978
    azt_invalidate_buffers();
#line 1985
    tmp___3 = AztTries;
#line 1985
    AztTries --;
#line 1985
    if (! tmp___3) {
#line 1986
      printk("aztcd: Read of Block %d Failed, Maybe Audio Disk? Giving up\n", azt_next_bn);
#line 1989
      if (azt_transfer_is_active) {
#line 1990
        AztTries = 0;
#line 1991
        loop_ctl = 0;
      }
#line 1993
      tmp___2 = current_valid();
#line 1993
      if (tmp___2) {
#line 1994
        tmp___1 = elv_next_request(azt_queue);
#line 1994
        end_request(tmp___1, 0);
      }
#line 1995
      AztTries = 5;
    }
#line 1997
    azt_error = (int volatile   )0;
#line 1998
    azt_state = (enum azt_state_e  volatile  )5;
  }
#line 2001
  while (loop_ctl) {
#line 2002
    loop_ctl = 0;
#line 2004
    switch ((unsigned int volatile   )azt_state) {
    case (unsigned int volatile   )0: 
#line 2013
    return;
    case (unsigned int volatile   )1: 
#line 2022
    tmp___4 = aztSendCmd(65);
#line 2022
    if (tmp___4) {
#line 2023
      printk("aztcd: Warning: %s failed\n", "azt_poll 2");
#line 2023
      return;
    }
#line 2024
    if (azt_mode == 1) {
#line 2024
      azt_state = (enum azt_state_e  volatile  )3;
    } else {
#line 2024
      azt_state = (enum azt_state_e  volatile  )2;
    }
#line 2026
    AztTimeout = 3000;
#line 2027
    break;
    case (unsigned int volatile   )2: 
#line 2036
    if (! skip) {
#line 2037
      st = aztStatus();
#line 2037
      if (st != -1) {
#line 2038
        if (st & 2) {
#line 2038
          goto _L;
        } else
#line 2038
        if (st & 32) {
          _L: /* CIL Label */ 
#line 2040
          aztDiskChanged = (char)1;
#line 2041
          aztTocUpToDate = (char)0;
#line 2042
          azt_invalidate_buffers();
#line 2043
          tmp___5 = elv_next_request(azt_queue);
#line 2043
          end_request(tmp___5, 0);
#line 2044
          printk("aztcd: Disk Changed or Not Ready 1 - Unmount Disk!\n");
        }
      } else {
#line 2048
        break;
      }
    }
#line 2050
    skip = 0;
#line 2052
    if (st & 64) {
#line 2052
      goto _L___0;
    } else
#line 2052
    if (st & 32) {
      _L___0: /* CIL Label */ 
#line 2053
      aztDiskChanged = (char)1;
#line 2054
      aztTocUpToDate = (char)0;
#line 2055
      printk("aztcd: Disk Changed or Not Ready 2 - Unmount Disk!\n");
#line 2057
      tmp___6 = elv_next_request(azt_queue);
#line 2057
      end_request(tmp___6, 0);
#line 2058
      if (st & 64) {
#line 2058
        tmp___7 = "aztcd: door open\n";
      } else {
#line 2058
        tmp___7 = "aztcd: disk removed\n";
      }
#line 2058
      printk(tmp___7);
#line 2061
      if (azt_transfer_is_active) {
#line 2062
        azt_state = (enum azt_state_e  volatile  )1;
#line 2063
        loop_ctl = 1;
#line 2064
        break;
      }
#line 2066
      azt_state = (enum azt_state_e  volatile  )0;
#line 2067
      while (1) {
#line 2067
        tmp___9 = current_valid();
#line 2067
        if (! tmp___9) {
#line 2067
          break;
        }
#line 2068
        tmp___8 = elv_next_request(azt_queue);
#line 2068
        end_request(tmp___8, 0);
      }
#line 2069
      return;
    }
#line 2077
    tmp___10 = aztSendCmd(65);
#line 2077
    if (tmp___10) {
#line 2078
      printk("aztcd: Warning: %s failed\n", "azt_poll 4");
#line 2078
      return;
    }
#line 2079
    sten_low();
#line 2080
    azt_mode = 1;
#line 2081
    azt_state = (enum azt_state_e  volatile  )3;
#line 2082
    AztTimeout = 3000;
#line 2084
    break;
    case (unsigned int volatile   )3: 
#line 2094
    if (! skip) {
#line 2095
      st = aztStatus();
#line 2095
      if (st != -1) {
#line 2096
        if (st & 2) {
#line 2096
          goto _L___1;
        } else
#line 2096
        if (st & 32) {
          _L___1: /* CIL Label */ 
#line 2098
          aztDiskChanged = (char)1;
#line 2099
          aztTocUpToDate = (char)0;
#line 2100
          azt_invalidate_buffers();
#line 2101
          printk("aztcd: Disk Changed or Not Ready 3 - Unmount Disk!\n");
#line 2103
          tmp___11 = elv_next_request(azt_queue);
#line 2103
          end_request(tmp___11, 0);
        }
      } else {
#line 2106
        break;
      }
    }
#line 2109
    skip = 0;
#line 2110
    if (st & 64) {
#line 2110
      goto _L___2;
    } else
#line 2110
    if (st & 32) {
      _L___2: /* CIL Label */ 
#line 2111
      aztDiskChanged = (char)1;
#line 2112
      aztTocUpToDate = (char)0;
#line 2113
      if (st & 64) {
#line 2113
        tmp___12 = "aztcd: door open\n";
      } else {
#line 2113
        tmp___12 = "aztcd: disk removed\n";
      }
#line 2113
      printk(tmp___12);
#line 2116
      if (azt_transfer_is_active) {
#line 2117
        azt_state = (enum azt_state_e  volatile  )1;
#line 2118
        loop_ctl = 1;
#line 2119
        break;
      }
#line 2121
      azt_state = (enum azt_state_e  volatile  )0;
#line 2122
      while (1) {
#line 2122
        tmp___14 = current_valid();
#line 2122
        if (! tmp___14) {
#line 2122
          break;
        }
#line 2123
        tmp___13 = elv_next_request(azt_queue);
#line 2123
        end_request(tmp___13, 0);
      }
#line 2124
      return;
    }
#line 2127
    tmp___22 = current_valid();
#line 2127
    if (tmp___22) {
#line 2130
      tmp___15 = elv_next_request(azt_queue);
#line 2130
      azt_next_bn = (int volatile   )(tmp___15->sector / 4UL);
#line 2131
      azt_hsg2msf((long )azt_next_bn, & msf.start);
#line 2132
      i = 0;
#line 2134
      while (1) {
#line 2134
        tmp___16 = azt_msf2hsg(& msf.start);
#line 2134
        i ++;
#line 2134
        tmp___17 = azt_msf2hsg(& Toc[i].trackTime);
#line 2134
        if (! (tmp___16 > tmp___17)) {
#line 2134
          break;
        }
      }
#line 2137
      tmp___20 = azt_msf2hsg(& msf.start);
#line 2137
      tmp___21 = azt_msf2hsg(& Toc[i].trackTime);
#line 2137
      if (tmp___20 < tmp___21 - 16L) {
#line 2140
        azt_read_count = (int volatile   )16;
      } else {
#line 2145
        tmp___18 = azt_msf2hsg(& Toc[i].trackTime);
#line 2145
        tmp___19 = azt_msf2hsg(& msf.start);
#line 2145
        azt_read_count = (int volatile   )((tmp___18 / 4L) * 4L - tmp___19);
#line 2149
        if (azt_read_count < (int volatile   )0) {
#line 2150
          azt_read_count = (int volatile   )0;
        }
#line 2151
        if (azt_read_count > (int volatile   )16) {
#line 2152
          azt_read_count = (int volatile   )16;
        }
#line 2154
        printk("aztcd: warning - trying to read beyond end of track\n");
      }
#line 2163
      msf.end.min = (unsigned char)0;
#line 2164
      msf.end.sec = (unsigned char)0;
#line 2165
      msf.end.frame = (unsigned char )azt_read_count;
#line 2177
      if ((unsigned int volatile   )azt_read_mode == (unsigned int volatile   )2) {
#line 2178
        sendAztCmd(33, & msf);
      } else {
#line 2180
        sendAztCmd(32, & msf);
      }
#line 2182
      azt_state = (enum azt_state_e  volatile  )4;
#line 2183
      AztTimeout = 3000;
    } else {
#line 2185
      azt_state = (enum azt_state_e  volatile  )5;
#line 2186
      loop_ctl = 1;
#line 2187
      break;
    }
#line 2190
    break;
    case (unsigned int volatile   )4: 
#line 2201
    tmp___23 = inb((unsigned int )(aztcd + 1));
#line 2201
    st = (int )tmp___23 & 6;
#line 2203
    switch (st) {
    case 2: 
#line 2212
    tmp___26 = AztTries;
#line 2212
    AztTries --;
#line 2212
    if (! tmp___26) {
#line 2213
      printk("aztcd: Read of Block %d Failed, Maybe Audio Disk ? Giving up\n", azt_next_bn);
#line 2216
      if (azt_transfer_is_active) {
#line 2217
        AztTries = 0;
#line 2218
        break;
      }
#line 2220
      tmp___25 = current_valid();
#line 2220
      if (tmp___25) {
#line 2221
        tmp___24 = elv_next_request(azt_queue);
#line 2221
        end_request(tmp___24, 0);
      }
#line 2222
      AztTries = 5;
    }
#line 2224
    azt_state = (enum azt_state_e  volatile  )1;
#line 2225
    AztTimeout = 3000;
#line 2226
    loop_ctl = 1;
#line 2227
    break;
    case 6: 
#line 2238
    break;
    default: 
#line 2247
    AztTries = 5;
#line 2248
    tmp___27 = current_valid();
#line 2248
    if (! tmp___27) {
#line 2248
      if (azt_buf_in == azt_buf_out) {
#line 2249
        azt_state = (enum azt_state_e  volatile  )5;
#line 2250
        loop_ctl = 1;
#line 2251
        break;
      }
    }
#line 2253
    if (azt_read_count <= (int volatile   )0) {
#line 2254
      printk("aztcd: warning - try to read 0 frames\n");
    }
#line 2256
    while (azt_read_count) {
#line 2257
      azt_buf_bn[azt_buf_in] = (int volatile   )-1;
#line 2258
      dten_low();
#line 2267
      if (aztTimeOutCount >= 8000000UL) {
#line 2268
        tmp___28 = elv_next_request(azt_queue);
#line 2268
        printk("read_count:%d CURRENT->nr_sectors:%ld azt_buf_in:%d\n", azt_read_count,
               tmp___28->nr_sectors, azt_buf_in);
#line 2273
        printk("azt_transfer_is_active:%x\n", azt_transfer_is_active);
#line 2276
        azt_read_count = (int volatile   )0;
#line 2277
        azt_state = (enum azt_state_e  volatile  )5;
#line 2278
        loop_ctl = 1;
#line 2279
        tmp___29 = elv_next_request(azt_queue);
#line 2279
        end_request(tmp___29, 1);
      } else {
#line 2281
        if ((unsigned int volatile   )azt_read_mode == (unsigned int volatile   )2) {
#line 2283
          insb((unsigned int )aztcd, (void *)(azt_buf + 2352 * (int )azt_buf_in),
               2352UL);
        } else {
#line 2289
          insb((unsigned int )aztcd, (void *)(azt_buf + 2048 * (int )azt_buf_in),
               2048UL);
        }
#line 2295
        azt_read_count -= (int volatile   )1;
#line 2308
        tmp___30 = azt_next_bn;
#line 2308
        azt_next_bn += (int volatile   )1;
#line 2308
        azt_buf_bn[azt_buf_in] = tmp___30;
#line 2310
        if (azt_buf_out == (int volatile   )-1) {
#line 2311
          azt_buf_out = azt_buf_in;
        }
#line 2313
        if (azt_buf_in + (int volatile   )1 == (int volatile   )16) {
#line 2313
          azt_buf_in = (int volatile   )0;
        } else {
#line 2313
          azt_buf_in += (int volatile   )1;
        }
      }
    }
#line 2319
    if (! azt_transfer_is_active) {
#line 2320
      while (1) {
#line 2320
        tmp___33 = current_valid();
#line 2320
        if (! tmp___33) {
#line 2320
          break;
        }
#line 2321
        azt_transfer();
#line 2322
        tmp___32 = elv_next_request(azt_queue);
#line 2322
        if (tmp___32->nr_sectors == 0UL) {
#line 2324
          tmp___31 = elv_next_request(azt_queue);
#line 2324
          end_request(tmp___31, 1);
        } else {
#line 2326
          break;
        }
      }
    }
#line 2330
    tmp___34 = current_valid();
#line 2330
    if (tmp___34) {
#line 2330
      tmp___35 = elv_next_request(azt_queue);
#line 2330
      if (tmp___35->sector / 4UL < (sector_t )azt_next_bn) {
#line 2334
        azt_state = (enum azt_state_e  volatile  )5;
#line 2335
        loop_ctl = 1;
#line 2336
        break;
      } else {
#line 2330
        tmp___36 = elv_next_request(azt_queue);
#line 2330
        if (tmp___36->sector / 4UL > (sector_t )(azt_next_bn + (int volatile   )16)) {
#line 2334
          azt_state = (enum azt_state_e  volatile  )5;
#line 2335
          loop_ctl = 1;
#line 2336
          break;
        }
      }
    }
#line 2338
    AztTimeout = 3000;
#line 2339
    if (azt_read_count == (int volatile   )0) {
#line 2340
      azt_state = (enum azt_state_e  volatile  )5;
#line 2341
      loop_ctl = 1;
#line 2342
      break;
    }
#line 2344
    break;
    }
#line 2346
    break;
    case (unsigned int volatile   )5: 
#line 2356
    if (azt_read_count != (int volatile   )0) {
#line 2357
      printk("aztcd: discard data=%x frames\n", azt_read_count);
    }
#line 2359
    while (azt_read_count != (int volatile   )0) {
#line 2361
      tmp___37 = inb((unsigned int )(aztcd + 1));
#line 2361
      if (! ((int )tmp___37 & 2)) {
#line 2362
        if ((unsigned int volatile   )azt_read_mode == (unsigned int volatile   )2) {
#line 2363
          i___0 = 0;
#line 2363
          while (i___0 < 2352) {
#line 2366
            inb((unsigned int )aztcd);
#line 2363
            i___0 ++;
          }
        } else {
#line 2368
          i___0 = 0;
#line 2368
          while (i___0 < 2048) {
#line 2370
            inb((unsigned int )aztcd);
#line 2368
            i___0 ++;
          }
        }
      }
#line 2372
      azt_read_count -= (int volatile   )1;
    }
#line 2374
    tmp___38 = aztSendCmd(65);
#line 2374
    if (tmp___38) {
#line 2375
      printk("aztcd: Warning: %s failed\n", "azt_poll 5");
#line 2375
      return;
    }
#line 2376
    azt_state = (enum azt_state_e  volatile  )6;
#line 2377
    AztTimeout = 1000;
#line 2378
    break;
    case (unsigned int volatile   )6: 
#line 2388
    st = aztStatus();
#line 2388
    if (st == -1) {
#line 2388
      if (AztTimeout) {
#line 2389
        break;
      }
    }
#line 2391
    if (st != -1) {
#line 2391
      if (st & 2) {
#line 2391
        goto _L___3;
      } else
#line 2391
      if (st & 32) {
        _L___3: /* CIL Label */ 
#line 2394
        aztDiskChanged = (char)1;
#line 2395
        aztTocUpToDate = (char)0;
#line 2396
        azt_invalidate_buffers();
#line 2397
        printk("aztcd: Disk Changed or Not Ready 4 - Unmount Disk!\n");
#line 2399
        tmp___39 = elv_next_request(azt_queue);
#line 2399
        end_request(tmp___39, 0);
      }
    }
#line 2407
    tmp___40 = current_valid();
#line 2407
    if (tmp___40) {
#line 2408
      if (st != -1) {
#line 2409
        if (azt_mode == 1) {
#line 2410
          azt_state = (enum azt_state_e  volatile  )3;
#line 2411
          loop_ctl = 1;
#line 2412
          skip = 1;
#line 2413
          break;
        } else {
#line 2415
          azt_state = (enum azt_state_e  volatile  )2;
#line 2416
          loop_ctl = 1;
#line 2417
          skip = 1;
#line 2418
          break;
        }
      } else {
#line 2421
        azt_state = (enum azt_state_e  volatile  )1;
#line 2422
        AztTimeout = 1;
      }
    } else {
#line 2425
      azt_state = (enum azt_state_e  volatile  )0;
#line 2426
      return;
    }
#line 2428
    break;
    default: 
#line 2431
    printk("aztcd: invalid state %d\n", (unsigned int volatile   )azt_state);
#line 2432
    return;
    }
  }
#line 2437
  tmp___42 = AztTimeout;
#line 2437
  AztTimeout --;
#line 2437
  if (! tmp___42) {
#line 2438
    printk("aztcd: timeout in state %d\n", (unsigned int volatile   )azt_state);
#line 2439
    azt_state = (enum azt_state_e  volatile  )5;
#line 2440
    tmp___41 = aztSendCmd(129);
#line 2440
    if (tmp___41) {
#line 2441
      printk("aztcd: Warning: %s failed\n", "azt_poll 6");
#line 2441
      return;
    }
#line 2442
    statusAzt();
  }
#line 2445
  delay_timer.expires = jiffies + 1UL;
#line 2445
  delay_timer.function = (void (*)(unsigned long  ))((void *)(& azt_poll));
#line 2445
  add_timer(& delay_timer);
#line 2446
  return;
}
}
#line 2453 "aztcd.c"
void azt_hsg2msf(long hsg , struct msf *msf ) 
{ 


  {
#line 2455
  hsg += 150L;
#line 2456
  msf->min = (unsigned char )(hsg / 4500L);
#line 2457
  hsg %= 4500L;
#line 2458
  msf->sec = (unsigned char )(hsg / 75L);
#line 2459
  msf->frame = (unsigned char )(hsg % 75L);
#line 2468
  azt_bin2bcd(& msf->min);
#line 2469
  azt_bin2bcd(& msf->sec);
#line 2470
  azt_bin2bcd(& msf->frame);
#line 2471
  return;
}
}
#line 2473 "aztcd.c"
long azt_msf2hsg(struct msf *mp ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 2475
  tmp = azt_bcd2bin(mp->frame);
#line 2475
  tmp___0 = azt_bcd2bin(mp->sec);
#line 2475
  tmp___1 = azt_bcd2bin(mp->min);
#line 2475
  return ((long )(((tmp + tmp___0 * 75) + tmp___1 * 4500) - 150));
}
}
#line 2479 "aztcd.c"
void azt_bin2bcd(unsigned char *p ) 
{ 
  int u ;
  int t ;

  {
#line 2483
  u = (int )*p % 10;
#line 2484
  t = (int )*p / 10;
#line 2485
  *p = (unsigned char )(u | (t << 4));
#line 2486
  return;
}
}
#line 2488 "aztcd.c"
int azt_bcd2bin(unsigned char bcd ) 
{ 


  {
#line 2490
  return (((int )bcd >> 4) * 10 + ((int )bcd & 15));
}
}
#line 2493 "aztcd.c"
char _ddv_module_license[4]  = {      (char )'G',      (char )'P',      (char )'L',      (char )'\000'};
#line 2494 "aztcd.c"
int _ddv_module_param_major  =    29;
#line 4 "__main.c"
int main(void) 
{ 


  {
#line 6
  _ddv_module_init = & aztcd_init;
#line 7
  _ddv_module_exit = & aztcd_exit;
#line 8
  call_ddv();
#line 10
  return (0);
}
}
#line 1 "manage.o"
#pragma merger("0","/tmp/cil-b_5yc1Nw.i","")
#line 75 "/usr/local/ddv/models/con2/include/linux/interrupt.h"
int request_irq(unsigned int irq , irqreturn_t (*handler)(int  , void * , struct pt_regs * ) ,
                unsigned long irqflags , char const   *devname , void *dev_id ) ;
#line 78
void free_irq(unsigned int irq , void *dev_id ) ;
#line 4 "/usr/local/ddv/models/con2/src/linux/kernel/irq/manage.c"
int request_irq(unsigned int irq , irqreturn_t (*handler)(int  , void * , struct pt_regs * ) ,
                unsigned long irqflags , char const   *devname , void *dev_id ) 
{ 
  int tmp ;

  {
#line 7
  tmp = nondet_int();
#line 7
  if (tmp) {
#line 8
    registered_irq[irq].handler = handler;
#line 9
    registered_irq[irq].dev_id = dev_id;
#line 11
    return (0);
  } else {
#line 13
    return (-1);
  }
}
}
#line 17 "/usr/local/ddv/models/con2/src/linux/kernel/irq/manage.c"
void free_irq(unsigned int irq , void *dev_id ) 
{ 


  {
#line 19
  registered_irq[irq].handler = (irqreturn_t (*)(int  , void * , struct pt_regs * ))((void *)0);
#line 20
  registered_irq[irq].dev_id = (void *)0;
#line 21
  return;
}
}
#line 1 "misc.o"
#pragma merger("0","/tmp/cil-qHZ7UWq9.i","")
#line 40 "/usr/local/ddv/models/con2/include/linux/miscdevice.h"
int misc_register(struct miscdevice *misc ) ;
#line 11 "/usr/local/ddv/models/con2/include/linux/proc_fs.h"
struct proc_dir_entry *proc_root_driver  ;
#line 18 "/usr/local/ddv/models/con2/src/linux/drivers/char/misc.c"
int misc_register(struct miscdevice *misc ) 
{ 
  int i ;
  dev_t dev ;
  int tmp ;

  {
#line 23
  if (fixed_cdev_used < 10) {
#line 24
    i = fixed_cdev_used;
#line 25
    fixed_cdev_used ++;
#line 27
    fixed_cdev[i].owner = (struct module *)0;
#line 28
    fixed_cdev[i].ops = misc->fops;
#line 30
    dev = (dev_t )((10 << 20) | misc->minor);
#line 32
    tmp = cdev_add(& fixed_cdev[i], dev, 0U);
#line 32
    return (tmp);
  } else {
#line 34
    return (-1);
  }
}
}
#line 1 "mutex.o"
#pragma merger("0","/tmp/cil-JVG4dUf5.i","")
#line 32 "/usr/local/ddv/models/con2/include/ddverify/ddverify.h"
__inline static int assert_context_process(void) 
{ 


  {
#line 34
  return (0);
}
}
#line 32 "/usr/local/ddv/models/con2/include/linux/mutex.h"
__inline void mutex_init(struct mutex *lock ) ;
#line 34
__inline void mutex_lock(struct mutex *lock ) ;
#line 36
__inline void mutex_unlock(struct mutex *lock ) ;
#line 4 "/usr/local/ddv/models/con2/src/linux/kernel/mutex.c"
__inline void mutex_init(struct mutex *lock ) 
{ 


  {
#line 7
  __CPROVER_atomic_begin();
#line 11
  lock->locked = 0;
#line 12
  lock->init = 1;
#line 13
  __CPROVER_atomic_end();
#line 14
  return;
}
}
#line 16 "/usr/local/ddv/models/con2/src/linux/kernel/mutex.c"
__inline void mutex_lock(struct mutex *lock ) 
{ 


  {
#line 27
  while (1) {
#line 29
    __CPROVER_atomic_begin();
#line 30
    if (lock->locked == 0) {
#line 32
      lock->locked = 1;
#line 33
      __CPROVER_atomic_end();
#line 34
      return;
    }
#line 36
    __CPROVER_atomic_end();
  }
}
}
#line 41 "/usr/local/ddv/models/con2/src/linux/kernel/mutex.c"
__inline void mutex_unlock(struct mutex *lock ) 
{ 


  {
#line 44
  __CPROVER_atomic_begin();
#line 45
  assert_context_process();
#line 49
  lock->locked = 0;
#line 50
  __CPROVER_atomic_end();
#line 51
  return;
}
}
#line 1 "page_alloc.o"
#pragma merger("0","/tmp/cil-hV07oMya.i","")
#line 55 "/usr/local/ddv/models/con2/include/linux/gfp.h"
__inline unsigned long __get_free_pages(gfp_t gfp_mask , unsigned int order ) ;
#line 57
__inline unsigned long __get_free_page(gfp_t gfp_mask ) ;
#line 59
__inline unsigned long get_zeroed_page(gfp_t gfp_mask ) ;
#line 70
__inline struct page *alloc_pages(gfp_t gfp_mask , unsigned int order ) ;
#line 72
__inline struct page *alloc_page(gfp_t gfp_mask ) ;
#line 5 "/usr/local/ddv/models/con2/src/linux/mm/page_alloc.c"
__inline unsigned long __get_free_pages(gfp_t gfp_mask , unsigned int order ) 
{ 


  {
#line 8
  if (gfp_mask & 16U) {
#line 9
    assert_context_process();
  }
#line 11
  return (0UL);
}
}
#line 13 "/usr/local/ddv/models/con2/src/linux/mm/page_alloc.c"
__inline unsigned long __get_free_page(gfp_t gfp_mask ) 
{ 


  {
#line 16
  if (gfp_mask & 16U) {
#line 17
    assert_context_process();
  }
#line 19
  return (0UL);
}
}
#line 38 "/usr/local/ddv/models/con2/src/linux/mm/page_alloc.c"
__inline struct page *alloc_pages(gfp_t gfp_mask , unsigned int order ) 
{ 


  {
#line 41
  if (gfp_mask & 16U) {
#line 42
    assert_context_process();
  }
#line 44
  return ((struct page *)0);
}
}
#line 46 "/usr/local/ddv/models/con2/src/linux/mm/page_alloc.c"
__inline struct page *alloc_page(gfp_t gfp_mask ) 
{ 


  {
#line 49
  if (gfp_mask & 16U) {
#line 50
    assert_context_process();
  }
#line 52
  return ((struct page *)0);
}
}
#line 1 "pci.o"
#pragma merger("0","/tmp/cil-H6nAfQ1t.i","")
#line 96 "/usr/local/ddv/models/con2/include/linux/ioport.h"
extern struct resource *request_mem_region(unsigned long start , unsigned long len ,
                                           char const   *name ) ;
#line 98
extern void release_mem_region(unsigned long start , unsigned long len ) ;
#line 87 "/usr/local/ddv/models/con2/include/linux/pci.h"
__inline struct pci_dev *pci_get_class(unsigned int class , struct pci_dev *from ) ;
#line 141
__inline int pci_register_driver(struct pci_driver *driver ) ;
#line 143
__inline void pci_unregister_driver(struct pci_driver *driver ) ;
#line 145
__inline int pci_enable_device(struct pci_dev *dev ) ;
#line 152
__inline int pci_request_regions(struct pci_dev *pdev , char const   *res_name ) ;
#line 154
__inline void pci_release_regions(struct pci_dev *pdev ) ;
#line 156
__inline int pci_request_region(struct pci_dev *pdev , int bar , char const   *res_name ) ;
#line 158
__inline void pci_release_region(struct pci_dev *pdev , int bar ) ;
#line 8 "/usr/local/ddv/models/con2/src/linux/pci.c"
__inline int pci_enable_device(struct pci_dev *dev ) 
{ 
  int i ;
  unsigned int tmp ;
  unsigned short tmp___0 ;

  {
#line 12
  i = 0;
#line 12
  while (i < 12) {
#line 13
    dev->resource[i].flags = 256UL;
#line 14
    tmp = nondet_uint();
#line 14
    dev->resource[i].start = (unsigned long )tmp;
#line 15
    tmp___0 = nondet_ushort();
#line 15
    dev->resource[i].end = dev->resource[i].start + (unsigned long )tmp___0;
#line 12
    i ++;
  }
#line 17
  return (0);
}
}
#line 19 "/usr/local/ddv/models/con2/src/linux/pci.c"
__inline struct pci_dev *pci_get_class(unsigned int class , struct pci_dev *from ) 
{ 
  void *tmp ;
  int tmp___0 ;

  {
#line 21
  if ((unsigned long )from == (unsigned long )((void *)0)) {
#line 22
    tmp = malloc((size_t )sizeof(struct pci_dev ));
#line 22
    from = (struct pci_dev *)tmp;
  }
#line 25
  tmp___0 = nondet_int();
#line 25
  if (tmp___0) {
#line 26
    from->vendor = nondet_ushort();
#line 27
    from->device = nondet_ushort();
#line 28
    from->irq = nondet_uint();
#line 29
    __CPROVER_assume(from->irq < 16U);
#line 31
    return (from);
  } else {
#line 33
    return ((struct pci_dev *)((void *)0));
  }
}
}
#line 37 "/usr/local/ddv/models/con2/src/linux/pci.c"
__inline int pci_register_driver(struct pci_driver *driver ) 
{ 
  int tmp ;

  {
#line 39
  tmp = nondet_int();
#line 39
  if (tmp) {
#line 40
    registered_pci_driver.pci_driver = driver;
#line 41
    registered_pci_driver.no_pci_device_id = (unsigned int )(sizeof(driver->id_table) / sizeof(struct pci_device_id ));
#line 42
    registered_pci_driver.dev_initialized = 0;
#line 44
    return (0);
  } else {
#line 46
    return (-1);
  }
}
}
#line 50 "/usr/local/ddv/models/con2/src/linux/pci.c"
__inline void pci_unregister_driver(struct pci_driver *driver ) 
{ 


  {
#line 52
  registered_pci_driver.pci_driver = (struct pci_driver *)((void *)0);
#line 53
  registered_pci_driver.no_pci_device_id = 0U;
#line 54
  return;
}
}
#line 56 "/usr/local/ddv/models/con2/src/linux/pci.c"
__inline void pci_release_region(struct pci_dev *pdev , int bar ) 
{ 
  unsigned long tmp ;
  unsigned long tmp___0 ;
  unsigned long tmp___1 ;

  {
#line 58
  if (pdev->resource[bar].start == 0UL) {
#line 58
    if (pdev->resource[bar].end == pdev->resource[bar].start) {
#line 58
      tmp = 0UL;
    } else {
#line 58
      tmp = (pdev->resource[bar].end - pdev->resource[bar].start) + 1UL;
    }
  } else {
#line 58
    tmp = (pdev->resource[bar].end - pdev->resource[bar].start) + 1UL;
  }
#line 58
  if (tmp == 0UL) {
#line 59
    return;
  }
#line 60
  if (pdev->resource[bar].flags & 256UL) {
#line 61
    if (pdev->resource[bar].start == 0UL) {
#line 61
      if (pdev->resource[bar].end == pdev->resource[bar].start) {
#line 61
        tmp___0 = 0UL;
      } else {
#line 61
        tmp___0 = (pdev->resource[bar].end - pdev->resource[bar].start) + 1UL;
      }
    } else {
#line 61
      tmp___0 = (pdev->resource[bar].end - pdev->resource[bar].start) + 1UL;
    }
#line 61
    release_region(pdev->resource[bar].start, tmp___0);
  } else
#line 63
  if (pdev->resource[bar].flags & 512UL) {
#line 64
    if (pdev->resource[bar].start == 0UL) {
#line 64
      if (pdev->resource[bar].end == pdev->resource[bar].start) {
#line 64
        tmp___1 = 0UL;
      } else {
#line 64
        tmp___1 = (pdev->resource[bar].end - pdev->resource[bar].start) + 1UL;
      }
    } else {
#line 64
      tmp___1 = (pdev->resource[bar].end - pdev->resource[bar].start) + 1UL;
    }
#line 64
    release_mem_region(pdev->resource[bar].start, tmp___1);
  }
#line 66
  return;
}
}
#line 68 "/usr/local/ddv/models/con2/src/linux/pci.c"
__inline int pci_request_region(struct pci_dev *pdev , int bar , char const   *res_name ) 
{ 
  unsigned long tmp ;
  unsigned long tmp___0 ;
  struct resource *tmp___1 ;
  unsigned long tmp___2 ;
  struct resource *tmp___3 ;

  {
#line 70
  if (pdev->resource[bar].start == 0UL) {
#line 70
    if (pdev->resource[bar].end == pdev->resource[bar].start) {
#line 70
      tmp = 0UL;
    } else {
#line 70
      tmp = (pdev->resource[bar].end - pdev->resource[bar].start) + 1UL;
    }
  } else {
#line 70
    tmp = (pdev->resource[bar].end - pdev->resource[bar].start) + 1UL;
  }
#line 70
  if (tmp == 0UL) {
#line 71
    return (0);
  }
#line 73
  if (pdev->resource[bar].flags & 256UL) {
#line 74
    if (pdev->resource[bar].start == 0UL) {
#line 74
      if (pdev->resource[bar].end == pdev->resource[bar].start) {
#line 74
        tmp___0 = 0UL;
      } else {
#line 74
        tmp___0 = (pdev->resource[bar].end - pdev->resource[bar].start) + 1UL;
      }
    } else {
#line 74
      tmp___0 = (pdev->resource[bar].end - pdev->resource[bar].start) + 1UL;
    }
#line 74
    tmp___1 = request_region(pdev->resource[bar].start, tmp___0, res_name);
#line 74
    if (! tmp___1) {
#line 76
      return (-16);
    }
  } else
#line 78
  if (pdev->resource[bar].flags & 512UL) {
#line 79
    if (pdev->resource[bar].start == 0UL) {
#line 79
      if (pdev->resource[bar].end == pdev->resource[bar].start) {
#line 79
        tmp___2 = 0UL;
      } else {
#line 79
        tmp___2 = (pdev->resource[bar].end - pdev->resource[bar].start) + 1UL;
      }
    } else {
#line 79
      tmp___2 = (pdev->resource[bar].end - pdev->resource[bar].start) + 1UL;
    }
#line 79
    tmp___3 = request_mem_region(pdev->resource[bar].start, tmp___2, res_name);
#line 79
    if (! tmp___3) {
#line 81
      return (-16);
    }
  }
#line 84
  return (0);
}
}
#line 87 "/usr/local/ddv/models/con2/src/linux/pci.c"
__inline void pci_release_regions(struct pci_dev *pdev ) 
{ 
  int i ;

  {
#line 91
  i = 0;
#line 91
  while (i < 6) {
#line 92
    pci_release_region(pdev, i);
#line 91
    i ++;
  }
#line 93
  return;
}
}
#line 95 "/usr/local/ddv/models/con2/src/linux/pci.c"
__inline int pci_request_regions(struct pci_dev *pdev , char const   *res_name ) 
{ 
  int i ;
  int tmp ;

  {
#line 99
  i = 0;
#line 99
  while (i < 6) {
#line 100
    tmp = pci_request_region(pdev, i, res_name);
#line 100
    if (tmp) {
#line 101
      goto err_out;
    }
#line 99
    i ++;
  }
#line 102
  return (0);
  err_out: 
#line 105
  while (1) {
#line 105
    i --;
#line 105
    if (! (i >= 0)) {
#line 105
      break;
    }
#line 106
    pci_release_region(pdev, i);
  }
#line 108
  return (-16);
}
}
#line 1 "resource.o"
#pragma merger("0","/tmp/cil-VHyhkdJv.i","")
#line 21 "/usr/local/ddv/models/con2/include/ddverify/satabs.h"
extern unsigned char nondet_uchar() ;
#line 22
extern unsigned int nondet_unsigned() ;
#line 10 "/usr/local/ddv/models/con2/include/ddverify/ioport.h"
int ddv_ioport_request_start  ;
#line 11 "/usr/local/ddv/models/con2/include/ddverify/ioport.h"
int ddv_ioport_request_len  ;
#line 6 "/usr/local/ddv/models/con2/src/linux/kernel/resource.c"
struct resource *request_region(unsigned long start , unsigned long len , char const   *name ) 
{ 
  struct resource *resource ;
  void *tmp ;

  {
#line 9
  tmp = malloc((size_t )sizeof(struct resource ));
#line 9
  resource = (struct resource *)tmp;
#line 14
  ddv_ioport_request_start = (int )start;
#line 15
  ddv_ioport_request_len = (int )len;
#line 17
  return (resource);
}
}
#line 20 "/usr/local/ddv/models/con2/src/linux/kernel/resource.c"
void release_region(unsigned long start , unsigned long len ) 
{ 
  unsigned int i ;

  {
#line 22
  i = 0U;
#line 28
  ddv_ioport_request_start = 0;
#line 29
  ddv_ioport_request_len = 0;
#line 30
  return;
}
}
#line 32 "/usr/local/ddv/models/con2/src/linux/kernel/resource.c"
unsigned char inb(unsigned int port ) 
{ 
  int tmp ;
  unsigned char tmp___0 ;

  {
#line 35
  if (port >= (unsigned int )ddv_ioport_request_start) {
#line 35
    if (port < (unsigned int )(ddv_ioport_request_start + ddv_ioport_request_len)) {
#line 35
      tmp = 1;
    } else {
#line 35
      tmp = 0;
    }
  } else {
#line 35
    tmp = 0;
  }
#line 35
  __CPROVER_assert(tmp, "I/O port is requested");
#line 37
  tmp___0 = nondet_uchar();
#line 37
  return (tmp___0);
}
}
#line 40 "/usr/local/ddv/models/con2/src/linux/kernel/resource.c"
void outb(unsigned char byte , unsigned int port ) 
{ 
  int tmp ;

  {
#line 43
  if (port >= (unsigned int )ddv_ioport_request_start) {
#line 43
    if (port < (unsigned int )(ddv_ioport_request_start + ddv_ioport_request_len)) {
#line 43
      tmp = 1;
    } else {
#line 43
      tmp = 0;
    }
  } else {
#line 43
    tmp = 0;
  }
#line 43
  __CPROVER_assert(tmp, "I/O port is requested");
#line 44
  return;
}
}
#line 46 "/usr/local/ddv/models/con2/src/linux/kernel/resource.c"
__inline unsigned short inw(unsigned int port ) 
{ 
  int tmp ;
  unsigned short tmp___0 ;

  {
#line 49
  if (port >= (unsigned int )ddv_ioport_request_start) {
#line 49
    if (port < (unsigned int )(ddv_ioport_request_start + ddv_ioport_request_len)) {
#line 49
      tmp = 1;
    } else {
#line 49
      tmp = 0;
    }
  } else {
#line 49
    tmp = 0;
  }
#line 49
  __CPROVER_assert(tmp, "I/O port is requested");
#line 51
  tmp___0 = nondet_ushort();
#line 51
  return (tmp___0);
}
}
#line 54 "/usr/local/ddv/models/con2/src/linux/kernel/resource.c"
__inline void outw(unsigned short word , unsigned int port ) 
{ 
  int tmp ;

  {
#line 57
  if (port >= (unsigned int )ddv_ioport_request_start) {
#line 57
    if (port < (unsigned int )(ddv_ioport_request_start + ddv_ioport_request_len)) {
#line 57
      tmp = 1;
    } else {
#line 57
      tmp = 0;
    }
  } else {
#line 57
    tmp = 0;
  }
#line 57
  __CPROVER_assert(tmp, "I/O port is requested");
#line 58
  return;
}
}
#line 60 "/usr/local/ddv/models/con2/src/linux/kernel/resource.c"
__inline unsigned int inl(unsigned int port ) 
{ 
  int tmp ;
  unsigned int tmp___0 ;

  {
#line 63
  if (port >= (unsigned int )ddv_ioport_request_start) {
#line 63
    if (port < (unsigned int )(ddv_ioport_request_start + ddv_ioport_request_len)) {
#line 63
      tmp = 1;
    } else {
#line 63
      tmp = 0;
    }
  } else {
#line 63
    tmp = 0;
  }
#line 63
  __CPROVER_assert(tmp, "I/O port is requested");
#line 65
  tmp___0 = nondet_unsigned();
#line 65
  return (tmp___0);
}
}
#line 68 "/usr/local/ddv/models/con2/src/linux/kernel/resource.c"
__inline void outl(unsigned int doubleword , unsigned int port ) 
{ 
  int tmp ;

  {
#line 71
  if (port >= (unsigned int )ddv_ioport_request_start) {
#line 71
    if (port < (unsigned int )(ddv_ioport_request_start + ddv_ioport_request_len)) {
#line 71
      tmp = 1;
    } else {
#line 71
      tmp = 0;
    }
  } else {
#line 71
    tmp = 0;
  }
#line 71
  __CPROVER_assert(tmp, "I/O port is requested");
#line 72
  return;
}
}
#line 74 "/usr/local/ddv/models/con2/src/linux/kernel/resource.c"
__inline unsigned char inb_p(unsigned int port ) 
{ 
  int tmp ;
  unsigned char tmp___0 ;

  {
#line 77
  if (port >= (unsigned int )ddv_ioport_request_start) {
#line 77
    if (port < (unsigned int )(ddv_ioport_request_start + ddv_ioport_request_len)) {
#line 77
      tmp = 1;
    } else {
#line 77
      tmp = 0;
    }
  } else {
#line 77
    tmp = 0;
  }
#line 77
  __CPROVER_assert(tmp, "I/O port is requested");
#line 79
  tmp___0 = nondet_uchar();
#line 79
  return (tmp___0);
}
}
#line 82 "/usr/local/ddv/models/con2/src/linux/kernel/resource.c"
void outb_p(unsigned char byte , unsigned int port ) 
{ 
  int tmp ;

  {
#line 85
  if (port >= (unsigned int )ddv_ioport_request_start) {
#line 85
    if (port < (unsigned int )(ddv_ioport_request_start + ddv_ioport_request_len)) {
#line 85
      tmp = 1;
    } else {
#line 85
      tmp = 0;
    }
  } else {
#line 85
    tmp = 0;
  }
#line 85
  __CPROVER_assert(tmp, "I/O port is requested");
#line 86
  return;
}
}
#line 1 "sched.o"
#pragma merger("0","/tmp/cil-sgQ76BWD.i","")
#line 18 "/usr/local/ddv/models/con2/include/ddverify/satabs.h"
extern long nondet_long() ;
#line 43 "/usr/local/ddv/models/con2/include/linux/sched.h"
void schedule(void) ;
#line 45
long schedule_timeout(long timeout ) ;
#line 8 "/usr/local/ddv/models/con2/src/linux/kernel/sched.c"
void schedule(void) 
{ 


  {
#line 10
  assert_context_process();
#line 11
  return;
}
}
#line 13 "/usr/local/ddv/models/con2/src/linux/kernel/sched.c"
long schedule_timeout(long timeout ) 
{ 
  long tmp ;

  {
#line 15
  assert_context_process();
#line 17
  tmp = nondet_long();
#line 17
  return (tmp);
}
}
#line 1 "semaphore.o"
#pragma merger("0","/tmp/cil-nUo2xVQB.i","")
#line 23 "/usr/local/ddv/models/con2/include/asm/semaphore.h"
__inline void sema_init(struct semaphore *sem , int val ) ;
#line 25
__inline void init_MUTEX(struct semaphore *sem ) ;
#line 27
__inline void init_MUTEX_LOCKED(struct semaphore *sem ) ;
#line 29
__inline void down(struct semaphore *sem ) ;
#line 31
__inline int down_interruptible(struct semaphore *sem ) ;
#line 33
__inline int down_trylock(struct semaphore *sem ) ;
#line 35
__inline void up(struct semaphore *sem ) ;
#line 6 "/usr/local/ddv/models/con2/src/linux/kernel/semaphore.c"
__inline void sema_init(struct semaphore *sem , int val ) 
{ 


  {
#line 9
  __CPROVER_atomic_begin();
#line 10
  sem->init = 1;
#line 11
  sem->locked = 0;
#line 12
  __CPROVER_atomic_end();
#line 13
  return;
}
}
#line 15 "/usr/local/ddv/models/con2/src/linux/kernel/semaphore.c"
__inline void init_MUTEX(struct semaphore *sem ) 
{ 


  {
#line 18
  __CPROVER_atomic_begin();
#line 19
  sem->init = 1;
#line 20
  sem->locked = 0;
#line 21
  __CPROVER_atomic_end();
#line 22
  return;
}
}
#line 24 "/usr/local/ddv/models/con2/src/linux/kernel/semaphore.c"
__inline void init_MUTEX_LOCKED(struct semaphore *sem ) 
{ 


  {
#line 27
  __CPROVER_atomic_begin();
#line 28
  sem->init = 1;
#line 29
  sem->locked = 1;
#line 30
  __CPROVER_atomic_end();
#line 31
  return;
}
}
#line 33 "/usr/local/ddv/models/con2/src/linux/kernel/semaphore.c"
__inline void down(struct semaphore *sem ) 
{ 


  {
#line 44
  while (1) {
#line 46
    __CPROVER_atomic_begin();
#line 47
    if (sem->locked == 0) {
#line 49
      sem->locked = 1;
#line 50
      __CPROVER_atomic_end();
#line 51
      return;
    }
#line 53
    __CPROVER_atomic_end();
  }
}
}
#line 58 "/usr/local/ddv/models/con2/src/linux/kernel/semaphore.c"
__inline int down_interruptible(struct semaphore *sem ) 
{ 
  int tmp ;

  {
#line 69
  while (1) {
#line 71
    __CPROVER_atomic_begin();
#line 72
    if (sem->locked == 0) {
#line 74
      sem->locked = 1;
#line 75
      __CPROVER_atomic_end();
#line 76
      return (0);
    }
#line 78
    tmp = nondet_int();
#line 78
    if (tmp) {
#line 79
      __CPROVER_atomic_end();
#line 80
      return (-1);
    }
#line 83
    __CPROVER_atomic_end();
  }
}
}
#line 88 "/usr/local/ddv/models/con2/src/linux/kernel/semaphore.c"
__inline int down_trylock(struct semaphore *sem ) 
{ 


  {
#line 91
  __CPROVER_atomic_begin();
#line 97
  if (sem->locked == 0) {
#line 98
    sem->locked = 1;
#line 99
    __CPROVER_atomic_end();
#line 100
    return (-1);
  }
#line 102
  __CPROVER_atomic_end();
#line 103
  return (0);
}
}
#line 106 "/usr/local/ddv/models/con2/src/linux/kernel/semaphore.c"
__inline void up(struct semaphore *sem ) 
{ 


  {
#line 109
  __CPROVER_atomic_begin();
#line 110
  assert_context_process();
#line 114
  sem->locked = 0;
#line 115
  __CPROVER_atomic_end();
#line 116
  return;
}
}
#line 1 "slab.o"
#pragma merger("0","/tmp/cil-btadhqtK.i","")
#line 10 "/usr/local/ddv/models/con2/include/linux/slab.h"
void *kmalloc(size_t size , gfp_t flags ) ;
#line 12
void *kzalloc(size_t size , gfp_t flags ) ;
#line 6 "/usr/local/ddv/models/con2/src/linux/mm/slab.c"
void *kmalloc(size_t size , gfp_t flags ) 
{ 
  void *tmp ;

  {
#line 8
  if (flags & 16U) {
#line 9
    assert_context_process();
  }
#line 12
  tmp = malloc(size);
#line 12
  return (tmp);
}
}
#line 15 "/usr/local/ddv/models/con2/src/linux/mm/slab.c"
void *kzalloc(size_t size , gfp_t flags ) 
{ 
  void *tmp ;

  {
#line 17
  if (flags & 16U) {
#line 18
    assert_context_process();
  }
#line 21
  tmp = malloc(size);
#line 21
  return (tmp);
}
}
#line 1 "softirq.o"
#pragma merger("0","/tmp/cil-LUE9ZMdb.i","")
#line 50 "/usr/local/ddv/models/con2/include/linux/interrupt.h"
__inline void tasklet_schedule(struct tasklet_struct *t ) ;
#line 65
__inline void tasklet_init(struct tasklet_struct *t , void (*func)(unsigned long  ) ,
                           unsigned long data ) ;
#line 4 "/usr/local/ddv/models/con2/src/linux/kernel/softirq.c"
__inline void tasklet_schedule(struct tasklet_struct *t ) 
{ 
  int i ;
  int next_free ;

  {
#line 7
  next_free = -1;
#line 13
  i = 0;
#line 13
  while (i < 10) {
#line 14
    if ((unsigned long )tasklet_registered[i].tasklet == (unsigned long )((void *)0)) {
#line 15
      next_free = i;
    }
#line 17
    if ((unsigned long )tasklet_registered[i].tasklet == (unsigned long )t) {
#line 17
      if ((int )tasklet_registered[i].is_running == 0) {
#line 19
        return;
      }
    }
#line 13
    i ++;
  }
#line 28
  tasklet_registered[next_free].tasklet = t;
#line 29
  tasklet_registered[next_free].is_running = (unsigned short)0;
#line 30
  return;
}
}
#line 32 "/usr/local/ddv/models/con2/src/linux/kernel/softirq.c"
__inline void tasklet_init(struct tasklet_struct *t , void (*func)(unsigned long  ) ,
                           unsigned long data ) 
{ 


  {
#line 36
  t->count = 0;
#line 37
  t->init = 0;
#line 38
  t->func = func;
#line 39
  t->data = data;
#line 40
  return;
}
}
#line 1 "spinlock.o"
#pragma merger("0","/tmp/cil-KYhNy3i2.i","")
#line 10 "/usr/local/ddv/models/con2/include/linux/spinlock.h"
__inline void spin_lock(spinlock_t *lock ) ;
#line 11
__inline void spin_lock_irqsave(spinlock_t *lock , unsigned long flags ) ;
#line 12
__inline void spin_lock_irq(spinlock_t *lock ) ;
#line 13
__inline void spin_lock_bh(spinlock_t *lock ) ;
#line 15
__inline void spin_unlock(spinlock_t *lock ) ;
#line 16
__inline void spin_unlock_irqrestore(spinlock_t *lock , unsigned long flags ) ;
#line 17
__inline void spin_unlock_irq(spinlock_t *lock ) ;
#line 18
__inline void spin_unlock_bh(spinlock_t *lock ) ;
#line 4 "/usr/local/ddv/models/con2/src/linux/kernel/spinlock.c"
void spin_lock_init(spinlock_t *lock ) 
{ 


  {
#line 6
  lock->init = 1;
#line 7
  lock->locked = 0;
#line 8
  return;
}
}
#line 10 "/usr/local/ddv/models/con2/src/linux/kernel/spinlock.c"
__inline void spin_lock(spinlock_t *lock ) 
{ 


  {
#line 20
  while (1) {
#line 22
    __CPROVER_atomic_begin();
#line 23
    if (lock->locked == 0) {
#line 25
      lock->locked = 1;
#line 26
      __CPROVER_atomic_end();
#line 27
      return;
    }
#line 29
    __CPROVER_atomic_end();
  }
}
}
#line 34 "/usr/local/ddv/models/con2/src/linux/kernel/spinlock.c"
__inline void spin_lock_irqsave(spinlock_t *lock , unsigned long flags ) 
{ 


  {
#line 44
  while (1) {
#line 46
    __CPROVER_atomic_begin();
#line 47
    if (lock->locked == 0) {
#line 49
      lock->locked = 1;
#line 50
      __CPROVER_atomic_end();
#line 51
      return;
    }
#line 53
    __CPROVER_atomic_end();
  }
}
}
#line 106 "/usr/local/ddv/models/con2/src/linux/kernel/spinlock.c"
__inline void spin_unlock(spinlock_t *lock ) 
{ 


  {
#line 109
  __CPROVER_atomic_begin();
#line 113
  lock->locked = 0;
#line 114
  __CPROVER_atomic_end();
#line 115
  return;
}
}
#line 117 "/usr/local/ddv/models/con2/src/linux/kernel/spinlock.c"
__inline void spin_unlock_irqrestore(spinlock_t *lock , unsigned long flags ) 
{ 


  {
#line 120
  __CPROVER_atomic_begin();
#line 124
  lock->locked = 0;
#line 125
  __CPROVER_atomic_end();
#line 126
  return;
}
}
#line 1 "tasklet.o"
#pragma merger("0","/tmp/cil-G4a1nku3.i","")
#line 3 "/usr/local/ddv/models/con2/src/ddverify/tasklet.c"
void call_tasklet_functions(void) 
{ 
  unsigned int i ;

  {
#line 6
  __CPROVER_assume(i < 10U);
#line 8
  if ((unsigned long )tasklet_registered[i].tasklet != (unsigned long )((void *)0)) {
#line 8
    if ((tasklet_registered[i].tasklet)->count == 0) {
#line 10
      tasklet_registered[i].is_running = (unsigned short)1;
#line 11
      (*((tasklet_registered[i].tasklet)->func))((tasklet_registered[i].tasklet)->data);
#line 12
      tasklet_registered[i].is_running = (unsigned short)0;
#line 13
      tasklet_registered[i].tasklet = (struct tasklet_struct *)((void *)0);
    }
  }
#line 15
  return;
}
}
#line 1 "timer.o"
#pragma merger("0","/tmp/cil-2RWBF56k.i","")
#line 26 "/usr/local/ddv/models/con2/include/linux/timer.h"
__inline void init_timer(struct timer_list *timer ) ;
#line 27
__inline void add_timer_on(struct timer_list *timer , int cpu ) ;
#line 30
__inline int mod_timer(struct timer_list *timer , unsigned long expires ) ;
#line 4 "/usr/local/ddv/models/con2/src/linux/kernel/timer.c"
__inline void init_timer(struct timer_list *timer ) 
{ 


  {
#line 6
  if ((int )number_timer_registered < 5) {
#line 7
    timer->__ddv_active = (short)0;
#line 8
    timer->__ddv_init = (short)1;
#line 9
    timer_registered[number_timer_registered].timer = timer;
#line 11
    number_timer_registered = (short )((int )number_timer_registered + 1);
  }
#line 13
  return;
}
}
#line 15 "/usr/local/ddv/models/con2/src/linux/kernel/timer.c"
void add_timer(struct timer_list *timer ) 
{ 


  {
#line 21
  timer->__ddv_active = (short)1;
#line 22
  return;
}
}
#line 24 "/usr/local/ddv/models/con2/src/linux/kernel/timer.c"
__inline void add_timer_on(struct timer_list *timer , int cpu ) 
{ 


  {
#line 27
  add_timer(timer);
#line 28
  return;
}
}
#line 30 "/usr/local/ddv/models/con2/src/linux/kernel/timer.c"
int del_timer(struct timer_list *timer ) 
{ 


  {
#line 32
  timer->__ddv_active = (short)0;
#line 33
  return (0);
}
}
#line 35 "/usr/local/ddv/models/con2/src/linux/kernel/timer.c"
__inline int mod_timer(struct timer_list *timer , unsigned long expires ) 
{ 


  {
#line 41
  timer->expires = expires;
#line 42
  timer->__ddv_active = (short)1;
#line 43
  return (0);
}
}
#line 1 "tty_io.o"
#pragma merger("0","/tmp/cil-uljdkKJr.i","")
#line 97 "/usr/local/ddv/models/con2/include/linux/tty_driver.h"
struct tty_driver *alloc_tty_driver(int lines ) ;
#line 101
void tty_set_operations(struct tty_driver *driver , struct tty_operations  const  *op ) ;
#line 13 "/usr/local/ddv/models/con2/include/ddverify/tty.h"
struct ddv_tty_driver global_tty_driver  ;
#line 4 "/usr/local/ddv/models/con2/src/linux/drivers/char/tty_io.c"
struct tty_driver *alloc_tty_driver(int lines ) 
{ 


  {
#line 6
  if (! global_tty_driver.allocated) {
#line 7
    global_tty_driver.driver.magic = 21506;
#line 8
    global_tty_driver.driver.num = lines;
  } else {
#line 10
    return ((struct tty_driver *)((void *)0));
  }
#line 12
  return ((struct tty_driver *)0);
}
}
#line 14 "/usr/local/ddv/models/con2/src/linux/drivers/char/tty_io.c"
void tty_set_operations(struct tty_driver *driver , struct tty_operations  const  *op ) 
{ 


  {
#line 17
  driver->open = (int (*)(struct tty_struct *tty , struct file *filp ))op->open;
#line 18
  driver->close = (void (*)(struct tty_struct *tty , struct file *filp ))op->close;
#line 19
  driver->write = (int (*)(struct tty_struct *tty , unsigned char const   *buf , int count ))op->write;
#line 20
  driver->put_char = (void (*)(struct tty_struct *tty , unsigned char ch ))op->put_char;
#line 21
  driver->flush_chars = (void (*)(struct tty_struct *tty ))op->flush_chars;
#line 22
  driver->write_room = (int (*)(struct tty_struct *tty ))op->write_room;
#line 23
  driver->chars_in_buffer = (int (*)(struct tty_struct *tty ))op->chars_in_buffer;
#line 24
  driver->ioctl = (int (*)(struct tty_struct *tty , struct file *file , unsigned int cmd ,
                           unsigned long arg ))op->ioctl;
#line 25
  driver->set_termios = (void (*)(struct tty_struct *tty , struct termios *old ))op->set_termios;
#line 26
  driver->throttle = (void (*)(struct tty_struct *tty ))op->throttle;
#line 27
  driver->unthrottle = (void (*)(struct tty_struct *tty ))op->unthrottle;
#line 28
  driver->stop = (void (*)(struct tty_struct *tty ))op->stop;
#line 29
  driver->start = (void (*)(struct tty_struct *tty ))op->start;
#line 30
  driver->hangup = (void (*)(struct tty_struct *tty ))op->hangup;
#line 31
  driver->break_ctl = (void (*)(struct tty_struct *tty , int state ))op->break_ctl;
#line 32
  driver->flush_buffer = (void (*)(struct tty_struct *tty ))op->flush_buffer;
#line 33
  driver->set_ldisc = (void (*)(struct tty_struct *tty ))op->set_ldisc;
#line 34
  driver->wait_until_sent = (void (*)(struct tty_struct *tty , int timeout ))op->wait_until_sent;
#line 35
  driver->send_xchar = (void (*)(struct tty_struct *tty , char ch ))op->send_xchar;
#line 36
  driver->read_proc = (int (*)(char *page , char **start , off_t off , int count ,
                               int *eof , void *data ))op->read_proc;
#line 37
  driver->write_proc = (int (*)(struct file *file , char const   *buffer , unsigned long count ,
                                void *data ))op->write_proc;
#line 38
  driver->tiocmget = (int (*)(struct tty_struct *tty , struct file *file ))op->tiocmget;
#line 39
  driver->tiocmset = (int (*)(struct tty_struct *tty , struct file *file , unsigned int set ,
                              unsigned int clear ))op->tiocmset;
#line 40
  return;
}
}
#line 1 "usercopy.o"
#pragma merger("0","/tmp/cil-dhkvuzot.i","")
#line 41 "/usr/local/ddv/models/con2/include/asm/uaccess.h"
__inline int __get_user(int size , void *ptr ) ;
#line 43
__inline int get_user(int size , void *ptr ) ;
#line 46
__inline int __put_user(int size , void *ptr ) ;
#line 48
__inline int put_user(int size , void *ptr ) ;
#line 5 "/usr/local/ddv/models/con2/src/linux/arch/i386/lib/usercopy.c"
__inline int __get_user(int size , void *ptr ) 
{ 
  int tmp ;

  {
#line 8
  assert_context_process();
#line 10
  tmp = nondet_int();
#line 10
  return (tmp);
}
}
#line 37 "/usr/local/ddv/models/con2/src/linux/arch/i386/lib/usercopy.c"
unsigned long copy_to_user(void *to , void const   *from , unsigned long n ) 
{ 
  unsigned long tmp ;

  {
#line 40
  assert_context_process();
#line 42
  tmp = nondet_ulong();
#line 42
  return (tmp);
}
}
#line 45 "/usr/local/ddv/models/con2/src/linux/arch/i386/lib/usercopy.c"
unsigned long copy_from_user(void *to , void *from , unsigned long n ) 
{ 
  unsigned long tmp ;

  {
#line 48
  assert_context_process();
#line 50
  tmp = nondet_ulong();
#line 50
  return (tmp);
}
}
#line 1 "vmalloc.o"
#pragma merger("0","/tmp/cil-__tCq7FV.i","")
#line 6 "/usr/local/ddv/models/con2/include/linux/vmalloc.h"
void *vmalloc(unsigned long size ) ;
#line 6 "/usr/local/ddv/models/con2/src/linux/mm/vmalloc.c"
void *vmalloc(unsigned long size ) 
{ 
  void *tmp ;

  {
#line 8
  tmp = malloc((size_t )size);
#line 8
  return (tmp);
}
}
#line 1 "wait.o"
#pragma merger("0","/tmp/cil-J1YJQE9v.i","")
#line 64 "/usr/local/ddv/models/con2/include/linux/wait.h"
__inline void init_waitqueue_head(wait_queue_head_t *q ) ;
#line 73
__inline void wake_up_all(wait_queue_head_t *q ) ;
#line 75
__inline void wake_up_interruptible(wait_queue_head_t *q ) ;
#line 90
__inline void interruptible_sleep_on(wait_queue_head_t *q ) ;
#line 3 "/usr/local/ddv/models/con2/src/linux/kernel/wait.c"
__inline void init_waitqueue_head(wait_queue_head_t *q ) 
{ 


  {
#line 5
  q->init = 1;
#line 6
  return;
}
}
#line 8 "/usr/local/ddv/models/con2/src/linux/kernel/wait.c"
void wake_up(wait_queue_head_t *q ) 
{ 


  {
#line 14
  return;
}
}
#line 16 "/usr/local/ddv/models/con2/src/linux/kernel/wait.c"
__inline void wake_up_all(wait_queue_head_t *q ) 
{ 


  {
#line 22
  return;
}
}
#line 32 "/usr/local/ddv/models/con2/src/linux/kernel/wait.c"
void sleep_on(wait_queue_head_t *q ) 
{ 


  {
#line 38
  return;
}
}
#line 1 "workqueue.o"
#pragma merger("0","/tmp/cil-JLr0Sybl.i","")
#line 46 "/usr/local/ddv/models/con2/include/linux/workqueue.h"
__inline int schedule_work(struct work_struct *work ) ;
#line 5 "/usr/local/ddv/models/con2/src/linux/kernel/workqueue.c"
__inline int schedule_work(struct work_struct *work ) 
{ 
  int i ;

  {
#line 14
  i = 0;
#line 14
  while (i < 10) {
#line 15
    if ((unsigned long )shared_workqueue[i] == (unsigned long )work) {
#line 16
      return (0);
    }
#line 19
    if ((unsigned long )shared_workqueue[i] == (unsigned long )((void *)0)) {
#line 20
      shared_workqueue[i] = work;
#line 22
      return (1);
    }
#line 14
    i ++;
  }
#line 27
  return (-1);
}
}
#line 30 "/usr/local/ddv/models/con2/src/linux/kernel/workqueue.c"
void call_shared_workqueue_functions(void) 
{ 
  unsigned short i ;
  unsigned short tmp ;

  {
#line 32
  tmp = nondet_ushort();
#line 32
  i = tmp;
#line 33
  __CPROVER_assume((int )i < 10);
#line 35
  if ((unsigned long )shared_workqueue[i] != (unsigned long )((void *)0)) {
#line 36
    (*((shared_workqueue[i])->func))((shared_workqueue[i])->data);
#line 37
    shared_workqueue[i] = (struct work_struct *)((void *)0);
  }
#line 39
  return;
}
}
