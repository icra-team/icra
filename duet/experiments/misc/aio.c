/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is true */

#line 213 "/usr/lib/gcc/x86_64-linux-gnu/4.7/include/stddef.h"
typedef unsigned long size_t;
#line 181 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __ssize_t;
#line 102 "/usr/include/stdio.h"
typedef __ssize_t ssize_t;
#line 200 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef unsigned char u_int8_t;
#line 202 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef unsigned int u_int32_t;
#line 28 "/usr/include/x86_64-linux-gnu/bits/sigset.h"
struct __anonstruct___sigset_t_12 {
   unsigned long __val[1024UL / (8UL * sizeof(unsigned long ))] ;
};
#line 28 "/usr/include/x86_64-linux-gnu/bits/sigset.h"
typedef struct __anonstruct___sigset_t_12 __sigset_t;
#line 37 "/usr/include/x86_64-linux-gnu/sys/select.h"
typedef __sigset_t sigset_t;
#line 60 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef unsigned long pthread_t;
#line 63 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
union pthread_attr_t {
   char __size[56] ;
   long __align ;
};
#line 69 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef union pthread_attr_t pthread_attr_t;
#line 75 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
struct __pthread_internal_list {
   struct __pthread_internal_list *__prev ;
   struct __pthread_internal_list *__next ;
};
#line 75 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef struct __pthread_internal_list __pthread_list_t;
#line 90 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
struct __pthread_mutex_s {
   int __lock ;
   unsigned int __count ;
   int __owner ;
   unsigned int __nusers ;
   int __kind ;
   int __spins ;
   __pthread_list_t __list ;
};
#line 90 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
union __anonunion_pthread_mutex_t_14 {
   struct __pthread_mutex_s __data ;
   char __size[40] ;
   long __align ;
};
#line 90 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef union __anonunion_pthread_mutex_t_14 pthread_mutex_t;
#line 120 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
union __anonunion_pthread_mutexattr_t_15 {
   char __size[4] ;
   int __align ;
};
#line 120 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef union __anonunion_pthread_mutexattr_t_15 pthread_mutexattr_t;
#line 129 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
struct __anonstruct___data_17 {
   int __lock ;
   unsigned int __futex ;
   unsigned long long __total_seq ;
   unsigned long long __wakeup_seq ;
   unsigned long long __woken_seq ;
   void *__mutex ;
   unsigned int __nwaiters ;
   unsigned int __broadcast_seq ;
};
#line 129 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
union __anonunion_pthread_cond_t_16 {
   struct __anonstruct___data_17 __data ;
   char __size[48] ;
   long long __align ;
};
#line 129 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef union __anonunion_pthread_cond_t_16 pthread_cond_t;
#line 146 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
union __anonunion_pthread_condattr_t_18 {
   char __size[4] ;
   int __align ;
};
#line 146 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef union __anonunion_pthread_condattr_t_18 pthread_condattr_t;
#line 28 "util_types.h"
typedef u_int32_t status_t;
#line 28 "queue.h"
struct queue_ {
   void *head ;
   void *tail ;
   u_int32_t count ;
   u_int32_t limit ;
   pthread_mutex_t mutex ;
   char const   *owner ;
};
#line 28 "queue.h"
typedef struct queue_ queue_t;
#line 50 "queue.h"
struct queue_link_ {
   void *queue_next ;
   void *queue_prev ;
   queue_t *owner_queue ;
};
#line 50 "queue.h"
typedef struct queue_link_ queue_link_t;
#line 26 "aio_simple.h"
enum _aio_thread_status {
    THREAD_STARTING = 0,
    THREAD_WAITING = 1,
    THREAD_BUSY = 2,
    THREAD_FAILED = 3,
    THREAD_DONE = 4
} ;
#line 33 "aio_simple.h"
typedef enum _aio_thread_status aio_thread_status;
#line 35 "aio_simple.h"
struct aio_req_queue_ {
   pthread_mutex_t mutex ;
   pthread_cond_t cond ;
   queue_t *queue ;
};
#line 35 "aio_simple.h"
typedef struct aio_req_queue_ aio_req_queue_t;
#line 42 "aio_simple.h"
struct aio_thread_ {
   queue_link_t link ;
   pthread_t thread ;
   aio_req_queue_t *req_queue ;
   aio_thread_status t_status ;
};
#line 42 "aio_simple.h"
typedef struct aio_thread_ aio_thread_t;
#line 50 "aio_simple.h"
struct aio_msg_ {
   queue_link_t link ;
   size_t size ;
   u_int8_t *msg ;
};
#line 50 "aio_simple.h"
typedef struct aio_msg_ aio_msg_t;
#line 1 "cil-GU0xBf_3.o"
#pragma merger("0","/tmp/cil-FeO61O71.i","-Wall,-Werror,-g")
#line 364 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int sprintf(char * __restrict  __s , char const   * __restrict  __format 
                                                 , ...) ;
#line 846
extern void perror(char const   *__s ) ;
#line 395 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 455
extern  __attribute__((__nothrow__)) void ( __attribute__((__nonnull__(1), __leaf__)) bzero)(void *__s ,
                                                                                             size_t __n ) ;
#line 465 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 482
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 542
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 366 "/usr/include/unistd.h"
extern ssize_t write(int __fd , void const   *__buf , size_t __n ) ;
#line 444
extern unsigned int sleep(unsigned int __seconds ) ;
#line 232 "/usr/include/pthread.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,3))) pthread_create)(pthread_t * __restrict  __newthread ,
                                                                                             pthread_attr_t const   * __restrict  __attr ,
                                                                                             void *(*__start_routine)(void * ) ,
                                                                                             void * __restrict  __arg ) ;
#line 286
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) pthread_attr_init)(pthread_attr_t *__attr ) ;
#line 740
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) pthread_mutex_init)(pthread_mutex_t *__mutex ,
                                                                                                         pthread_mutexattr_t const   *__mutexattr ) ;
#line 753
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) pthread_mutex_lock)(pthread_mutex_t *__mutex ) ;
#line 764
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) pthread_mutex_unlock)(pthread_mutex_t *__mutex ) ;
#line 959
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) pthread_cond_init)(pthread_cond_t * __restrict  __cond ,
                                                                                                        pthread_condattr_t const   * __restrict  __cond_attr ) ;
#line 968
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) pthread_cond_signal)(pthread_cond_t *__cond ) ;
#line 980
extern int ( __attribute__((__nonnull__(1,2))) pthread_cond_wait)(pthread_cond_t * __restrict  __cond ,
                                                                  pthread_mutex_t * __restrict  __mutex ) ;
#line 223 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) sigemptyset)(sigset_t *__set ) ;
#line 229
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) sigaddset)(sigset_t *__set ,
                                                                                                int __signo ) ;
#line 30 "/usr/include/x86_64-linux-gnu/bits/sigthread.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) pthread_sigmask)(int __how ,
                                                                                      __sigset_t const   * __restrict  __newmask ,
                                                                                      __sigset_t * __restrict  __oldmask ) ;
#line 146 "/usr/include/fcntl.h"
extern int ( __attribute__((__nonnull__(1))) open)(char const   *__file , int __oflag 
                                                   , ...) ;
#line 70 "/usr/include/assert.h"
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) __assert_fail)(char const   *__assertion ,
                                                                                                   char const   *__file ,
                                                                                                   unsigned int __line ,
                                                                                                   char const   *__function ) ;
#line 76 "queue.h"
queue_t *queue_create(status_t *status , char const   *owner , size_t limit ) ;
#line 81
status_t queue_enqueue(queue_t *queue , queue_link_t *link ) ;
#line 82
status_t queue_enqueue_ts(queue_t *queue , queue_link_t *link ) ;
#line 85
void *queue_dequeue(queue_t *queue , status_t *status ) ;
#line 86
void *queue_dequeue_ts(queue_t *queue , status_t *status ) ;
#line 87
void *queue_peek(queue_t *queue , status_t *status ) ;
#line 89
size_t queue_get_count(queue_t *queue ) ;
#line 40 "aio_simple.c"
static pthread_attr_t globattr  ;
#line 41 "aio_simple.c"
static queue_t *aio_thread_q  ;
#line 42 "aio_simple.c"
static int aio_fd  ;
#line 47 "aio_simple.c"
static void *aio_thread_loop(void *arg ) 
{ 
  aio_thread_t *aio_thread ;
  aio_msg_t *aio_msg ;
  sigset_t new_sigs ;
  aio_req_queue_t *aio_req_q ;
  status_t status ;
  void *tmp ;
  void *tmp___0 ;

  {
#line 56
  aio_thread = (aio_thread_t *)arg;
#line 57
  if ((unsigned long )aio_thread == (unsigned long )((void *)0)) {
#line 59
    __assert_fail("0", "aio_simple.c", 59U, "aio_thread_loop");
  }
#line 62
  aio_req_q = aio_thread->req_queue;
#line 64
  sigemptyset(& new_sigs);
#line 65
  sigaddset(& new_sigs, 13);
#line 66
  sigaddset(& new_sigs, 17);
#line 67
  sigaddset(& new_sigs, 3);
#line 68
  sigaddset(& new_sigs, 5);
#line 69
  sigaddset(& new_sigs, 1);
#line 70
  sigaddset(& new_sigs, 15);
#line 71
  sigaddset(& new_sigs, 2);
#line 72
  sigaddset(& new_sigs, 14);
#line 73
  pthread_sigmask(0, (__sigset_t const   * __restrict  )(& new_sigs), (__sigset_t * __restrict  )((void *)0));
#line 75
  while (1) {
#line 77
    aio_thread->t_status = (aio_thread_status )1;
#line 79
    pthread_mutex_lock(& aio_req_q->mutex);
#line 80
    pthread_cond_wait((pthread_cond_t * __restrict  )(& aio_req_q->cond), (pthread_mutex_t * __restrict  )(& aio_req_q->mutex));
#line 81
    pthread_mutex_unlock(& aio_req_q->mutex);
#line 83
    aio_thread->t_status = (aio_thread_status )2;
#line 85
    tmp = queue_dequeue_ts(aio_req_q->queue, & status);
#line 85
    aio_msg = (aio_msg_t *)tmp;
#line 88
    while (aio_msg) {
#line 90
      write(aio_fd, (void const   *)aio_msg->msg, aio_msg->size);
#line 91
      free((void *)aio_msg->msg);
#line 92
      free((void *)aio_msg);
#line 94
      tmp___0 = queue_dequeue_ts(aio_req_q->queue, & status);
#line 94
      aio_msg = (aio_msg_t *)tmp___0;
    }
#line 97
    aio_thread->t_status = (aio_thread_status )4;
  }
}
}
#line 105 "aio_simple.c"
static void aio_init(void) 
{ 
  aio_thread_t *aio_thread ;
  aio_req_queue_t *req_q ;
  int tstatus ;
  queue_t *queue ;
  status_t status ;
  int i ;
  size_t qcount ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  size_t tmp___2 ;

  {
#line 116
  pthread_attr_init(& globattr);
#line 121
  aio_thread_q = queue_create(& status, "aio", (size_t )0);
#line 122
  if ((unsigned long )aio_thread_q == (unsigned long )((void *)0)) {
#line 124
    __assert_fail("0", "aio_simple.c", 124U, "aio_init");
  }
#line 130
  i = 0;
#line 130
  while (i < 1) {
#line 132
    tmp = malloc(sizeof(aio_thread_t ));
#line 132
    aio_thread = (aio_thread_t *)tmp;
#line 133
    if ((unsigned long )aio_thread == (unsigned long )((void *)0)) {
#line 135
      __assert_fail("0", "aio_simple.c", 135U, "aio_init");
    }
#line 138
    tmp___0 = malloc(sizeof(aio_req_queue_t ));
#line 138
    req_q = (aio_req_queue_t *)tmp___0;
#line 139
    if ((unsigned long )req_q == (unsigned long )((void *)0)) {
#line 141
      __assert_fail("0", "aio_simple.c", 141U, "aio_init");
    }
#line 143
    aio_thread->req_queue = req_q;
#line 148
    tstatus = pthread_mutex_init(& (aio_thread->req_queue)->mutex, (pthread_mutexattr_t const   *)((void *)0));
#line 149
    if (tstatus != 0) {
#line 151
      __assert_fail("0", "aio_simple.c", 151U, "aio_init");
    }
#line 157
    tstatus = pthread_cond_init((pthread_cond_t * __restrict  )(& (aio_thread->req_queue)->cond),
                                (pthread_condattr_t const   * __restrict  )((void *)0));
#line 158
    if (tstatus != 0) {
#line 160
      __assert_fail("0", "aio_simple.c", 160U, "aio_init");
    }
#line 166
    queue = queue_create(& status, "aio", (size_t )0);
#line 167
    if ((unsigned long )queue == (unsigned long )((void *)0)) {
#line 169
      __assert_fail("0", "aio_simple.c", 169U, "aio_init");
    }
#line 171
    (aio_thread->req_queue)->queue = queue;
#line 177
    status = queue_enqueue(aio_thread_q, & aio_thread->link);
#line 178
    if (status != 0U) {
#line 180
      __assert_fail("0", "aio_simple.c", 180U, "aio_init");
    }
#line 130
    i ++;
  }
#line 187
  qcount = queue_get_count(aio_thread_q);
#line 188
  while (1) {
#line 188
    tmp___2 = qcount;
#line 188
    qcount --;
#line 188
    if (! tmp___2) {
#line 188
      break;
    }
#line 190
    tmp___1 = queue_dequeue(aio_thread_q, & status);
#line 190
    aio_thread = (aio_thread_t *)tmp___1;
#line 191
    if ((unsigned long )aio_thread == (unsigned long )((void *)0)) {
#line 193
      __assert_fail("0", "aio_simple.c", 193U, "aio_init");
    }
#line 195
    tstatus = pthread_create((pthread_t * __restrict  )(& aio_thread->thread), (pthread_attr_t const   * __restrict  )(& globattr),
                             & aio_thread_loop, (void * __restrict  )aio_thread);
#line 197
    if (tstatus != 0) {
#line 199
      __assert_fail("0", "aio_simple.c", 199U, "aio_init");
    }
#line 205
    status = queue_enqueue(aio_thread_q, & aio_thread->link);
#line 206
    if (status != 0U) {
#line 208
      __assert_fail("0", "aio_simple.c", 208U, "aio_init");
    }
  }
#line 211
  return;
}
}
#line 216 "aio_simple.c"
int main(void) 
{ 
  int fd ;
  aio_thread_t *aio_thread ;
  aio_req_queue_t *aio_req_q ;
  u_int8_t *msg ;
  aio_msg_t *aio_msg ;
  int i ;
  size_t slen ;
  status_t status ;
  int signal_stat ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
#line 229
  fd = open("/tmp/aio.out", 577, 448);
#line 230
  if (fd < 0) {
#line 232
    perror("file open failed");
#line 233
    exit(1);
  }
#line 235
  aio_fd = fd;
#line 237
  aio_init();
#line 239
  i = 0;
#line 239
  while (i < 10) {
#line 245
    tmp = malloc((size_t )128);
#line 245
    msg = (u_int8_t *)tmp;
#line 246
    if ((unsigned long )msg == (unsigned long )((void *)0)) {
#line 248
      perror("Malloc");
#line 249
      exit(1);
    }
#line 252
    bzero((void *)msg, (size_t )128);
#line 254
    sprintf((char * __restrict  )msg, (char const   * __restrict  )"%s: AIO test iteration %d\n",
            "main", i);
#line 256
    tmp___0 = malloc(sizeof(aio_msg_t ));
#line 256
    aio_msg = (aio_msg_t *)tmp___0;
#line 257
    if ((unsigned long )aio_msg == (unsigned long )((void *)0)) {
#line 259
      perror("Malloc2");
#line 260
      exit(1);
    }
#line 263
    slen = strlen((char const   *)msg);
#line 265
    aio_msg->size = slen;
#line 266
    aio_msg->msg = msg;
#line 268
    tmp___1 = queue_peek(aio_thread_q, & status);
#line 268
    aio_thread = (aio_thread_t *)tmp___1;
#line 269
    if ((unsigned long )aio_thread == (unsigned long )((void *)0)) {
#line 271
      perror("queue_peek");
#line 272
      exit(1);
    }
#line 275
    aio_req_q = aio_thread->req_queue;
#line 277
    status = queue_enqueue_ts(aio_req_q->queue, & aio_msg->link);
#line 278
    if (status != 0U) {
#line 280
      perror("enqueue");
#line 281
      exit(1);
    }
#line 284
    signal_stat = pthread_cond_signal(& aio_req_q->cond);
#line 285
    if (signal_stat < 0) {
#line 287
      perror("cond_sig");
#line 288
      exit(1);
    }
#line 239
    i ++;
  }
#line 292
  sleep(1U);
#line 294
  exit(0);
}
}
#line 1 "cil-QL2OwXWO.o"
#pragma merger("0","/tmp/cil-w8oapoIk.i","-Wall,-Werror,-g")
#line 77 "queue.h"
queue_t *queue_create_ts(status_t *status , char const   *owner , size_t limit ) ;
#line 79
status_t queue_destroy(queue_t *queue ) ;
#line 80
status_t queue_destroy_ts(queue_t *queue ) ;
#line 83
status_t queue_requeue(queue_t *queue , queue_link_t *link ) ;
#line 84
status_t queue_requeue_ts(queue_t *queue , queue_link_t *link ) ;
#line 88
void *queue_peek_ts(queue_t *queue , status_t *status ) ;
#line 90
size_t queue_get_count_ts(queue_t *queue ) ;
#line 91
status_t queue_set_limit(queue_t *queue , u_int32_t limit ) ;
#line 92
status_t queue_check(queue_link_t *link ) ;
#line 93
void *queue_get_next(queue_t *queue , queue_link_t *curr , status_t *status ) ;
#line 37 "queue.c"
queue_t *queue_create(status_t *status , char const   *owner , size_t limit ) 
{ 
  queue_t *tq ;
  void *tmp ;
  void *tmp___0 ;

  {
#line 42
  *status = (status_t )0;
#line 44
  tmp = malloc(sizeof(queue_t ));
#line 44
  tq = (queue_t *)tmp;
#line 46
  if ((unsigned long )tq == (unsigned long )((void *)0)) {
#line 47
    *status = (status_t )12;
#line 48
    return ((queue_t *)((void *)0));
  }
#line 51
  tmp___0 = (void *)0;
#line 51
  tq->tail = tmp___0;
#line 51
  tq->head = tmp___0;
#line 52
  tq->count = (u_int32_t )0;
#line 53
  tq->owner = owner;
#line 54
  tq->limit = (u_int32_t )limit;
#line 56
  return (tq);
}
}
#line 68 "queue.c"
queue_t *queue_create_ts(status_t *status , char const   *owner , size_t limit ) 
{ 
  queue_t *queue ;
  status_t local_status ;
  void *tmp ;
  void *tmp___0 ;
  int tmp___1 ;

  {
#line 74
  local_status = (status_t )0;
#line 74
  *status = local_status;
#line 76
  tmp = malloc(sizeof(queue_t ));
#line 76
  queue = (queue_t *)tmp;
#line 78
  if ((unsigned long )queue == (unsigned long )((void *)0)) {
#line 79
    *status = (status_t )12;
#line 80
    return ((queue_t *)((void *)0));
  }
#line 83
  tmp___0 = (void *)0;
#line 83
  queue->tail = tmp___0;
#line 83
  queue->head = tmp___0;
#line 84
  queue->count = (u_int32_t )0;
#line 85
  queue->owner = owner;
#line 86
  queue->limit = (u_int32_t )limit;
#line 91
  tmp___1 = pthread_mutex_init(& queue->mutex, (pthread_mutexattr_t const   *)((void *)0));
#line 91
  local_status = (status_t )tmp___1;
#line 92
  if (local_status != 0U) {
#line 94
    free((void *)queue);
#line 95
    queue = (queue_t *)((void *)0);
  }
#line 98
  *status = local_status;
#line 99
  return (queue);
}
}
#line 105 "queue.c"
status_t queue_destroy(queue_t *queue ) 
{ 


  {
#line 108
  if ((unsigned long )queue == (unsigned long )((void *)0)) {
#line 109
    return ((status_t )2);
  }
#line 111
  if (queue->head) {
#line 112
    return ((status_t )16);
  } else
#line 111
  if (queue->tail) {
#line 112
    return ((status_t )16);
  } else
#line 111
  if (queue->count) {
#line 112
    return ((status_t )16);
  } else {
#line 114
    free((void *)queue);
#line 115
    return ((status_t )0);
  }
}
}
#line 123 "queue.c"
status_t queue_destroy_ts(queue_t *queue ) 
{ 
  status_t status ;
  int tmp ;

  {
#line 128
  if ((unsigned long )queue == (unsigned long )((void *)0)) {
#line 129
    return ((status_t )2);
  }
#line 131
  tmp = pthread_mutex_lock(& queue->mutex);
#line 131
  status = (status_t )tmp;
#line 133
  if (queue->head) {
#line 134
    pthread_mutex_unlock(& queue->mutex);
#line 135
    return ((status_t )16);
  } else
#line 133
  if (queue->tail) {
#line 134
    pthread_mutex_unlock(& queue->mutex);
#line 135
    return ((status_t )16);
  } else
#line 133
  if (queue->count) {
#line 134
    pthread_mutex_unlock(& queue->mutex);
#line 135
    return ((status_t )16);
  } else {
#line 137
    pthread_mutex_unlock(& queue->mutex);
#line 138
    free((void *)queue);
#line 139
    return ((status_t )0);
  }
}
}
#line 146 "queue.c"
status_t queue_set_limit(queue_t *queue , u_int32_t limit ) 
{ 


  {
#line 150
  queue->limit = limit;
#line 152
  return ((status_t )0);
}
}
#line 158 "queue.c"
status_t queue_set_limit_ts(queue_t *queue , u_int32_t limit ) 
{ 
  status_t status ;
  int tmp ;

  {
#line 163
  tmp = pthread_mutex_lock(& queue->mutex);
#line 163
  status = (status_t )tmp;
#line 164
  if (status != 0U) {
#line 165
    return (status);
  }
#line 168
  queue->limit = limit;
#line 170
  pthread_mutex_unlock(& queue->mutex);
#line 172
  return ((status_t )0);
}
}
#line 181 "queue.c"
status_t queue_enqueue(queue_t *queue , queue_link_t *link ) 
{ 
  queue_link_t *cur_head ;
  void *tmp ;
  void *tmp___0 ;

  {
#line 186
  if ((unsigned long )queue == (unsigned long )((void *)0)) {
#line 187
    return ((status_t )22);
  }
#line 188
  if ((unsigned long )link == (unsigned long )((void *)0)) {
#line 189
    return ((status_t )22);
  }
#line 191
  if (queue->limit > 0U) {
#line 192
    if (queue->count >= queue->limit) {
#line 193
      return ((status_t )16);
    }
  }
#line 196
  if (! ((unsigned long )link->queue_next == (unsigned long )((void *)0))) {
#line 196
    __assert_fail("link->queue_next == ((void *)0)", "queue.c", 196U, "queue_enqueue");
  }
#line 197
  if (! ((unsigned long )link->queue_prev == (unsigned long )((void *)0))) {
#line 197
    __assert_fail("link->queue_prev == ((void *)0)", "queue.c", 197U, "queue_enqueue");
  }
#line 199
  link->owner_queue = queue;
#line 201
  if ((unsigned long )queue->head == (unsigned long )((void *)0)) {
#line 202
    tmp = (void *)link;
#line 202
    queue->tail = tmp;
#line 202
    queue->head = tmp;
#line 203
    tmp___0 = (void *)0;
#line 203
    link->queue_prev = tmp___0;
#line 203
    link->queue_next = tmp___0;
  } else {
#line 205
    cur_head = (queue_link_t *)queue->head;
#line 206
    cur_head->queue_prev = (void *)link;
#line 207
    link->queue_next = (void *)cur_head;
#line 208
    link->queue_prev = (void *)0;
#line 209
    queue->head = (void *)link;
  }
#line 212
  (queue->count) ++;
#line 214
  return ((status_t )0);
}
}
#line 225 "queue.c"
status_t queue_enqueue_ts(queue_t *queue , queue_link_t *link ) 
{ 
  status_t status ;
  int tmp ;

  {
#line 230
  tmp = pthread_mutex_lock(& queue->mutex);
#line 230
  status = (status_t )tmp;
#line 231
  if (status != 0U) {
#line 232
    return (status);
  }
#line 235
  status = queue_enqueue(queue, link);
#line 237
  pthread_mutex_unlock(& queue->mutex);
#line 239
  return (status);
}
}
#line 247 "queue.c"
status_t queue_requeue(queue_t *queue , queue_link_t *link ) 
{ 
  queue_link_t *cur_tail ;
  void *tmp ;
  void *tmp___0 ;

  {
#line 252
  if ((unsigned long )queue == (unsigned long )((void *)0)) {
#line 253
    return ((status_t )22);
  }
#line 254
  if ((unsigned long )link == (unsigned long )((void *)0)) {
#line 255
    return ((status_t )22);
  }
#line 257
  if ((unsigned long )queue->head == (unsigned long )((void *)0)) {
#line 258
    tmp = (void *)link;
#line 258
    queue->tail = tmp;
#line 258
    queue->head = tmp;
#line 259
    tmp___0 = (void *)0;
#line 259
    link->queue_prev = tmp___0;
#line 259
    link->queue_next = tmp___0;
  } else {
#line 261
    cur_tail = (queue_link_t *)queue->tail;
#line 262
    cur_tail->queue_next = (void *)link;
#line 263
    link->queue_prev = (void *)cur_tail;
#line 264
    link->queue_next = (void *)0;
#line 265
    queue->tail = (void *)link;
  }
#line 268
  (queue->count) ++;
#line 270
  return ((status_t )0);
}
}
#line 280 "queue.c"
status_t queue_requeue_ts(queue_t *queue , queue_link_t *link ) 
{ 
  status_t status ;
  int tmp ;

  {
#line 285
  tmp = pthread_mutex_lock(& queue->mutex);
#line 285
  status = (status_t )tmp;
#line 286
  if (status != 0U) {
#line 287
    return (status);
  }
#line 290
  status = queue_requeue(queue, link);
#line 292
  pthread_mutex_unlock(& queue->mutex);
#line 294
  return (status);
}
}
#line 302 "queue.c"
void *queue_dequeue(queue_t *queue , status_t *status ) 
{ 
  queue_link_t *cur_tail ;
  queue_link_t *new_tail ;
  void *tmp ;

  {
#line 308
  if ((unsigned long )queue == (unsigned long )((void *)0)) {
#line 309
    *status = (status_t )22;
#line 310
    return ((void *)0);
  }
#line 312
  if ((unsigned long )queue->tail == (unsigned long )((void *)0)) {
#line 313
    *status = (status_t )61;
#line 314
    return ((void *)0);
  }
#line 317
  cur_tail = (queue_link_t *)queue->tail;
#line 319
  if ((unsigned long )queue->head == (unsigned long )queue->tail) {
#line 320
    tmp = (void *)0;
#line 320
    queue->tail = tmp;
#line 320
    queue->head = tmp;
  } else {
#line 322
    new_tail = (queue_link_t *)cur_tail->queue_prev;
#line 322
    queue->tail = (void *)new_tail;
#line 323
    new_tail->queue_next = (void *)0;
  }
#line 326
  cur_tail->queue_next = (void *)0;
#line 327
  cur_tail->queue_prev = (void *)0;
#line 328
  cur_tail->owner_queue = (queue_t *)((void *)0);
#line 330
  (queue->count) --;
#line 332
  *status = (status_t )0;
#line 334
  return ((void *)cur_tail);
}
}
#line 344 "queue.c"
void *queue_dequeue_ts(queue_t *queue , status_t *status ) 
{ 
  status_t local_status ;
  queue_link_t *cur_tail ;
  int tmp ;
  void *tmp___0 ;

  {
#line 351
  tmp = pthread_mutex_lock(& queue->mutex);
#line 351
  local_status = (status_t )tmp;
#line 352
  if (local_status != 0U) {
#line 353
    *status = local_status;
#line 354
    return ((void *)0);
  }
#line 357
  tmp___0 = queue_dequeue(queue, status);
#line 357
  cur_tail = (queue_link_t *)tmp___0;
#line 359
  pthread_mutex_unlock(& queue->mutex);
#line 361
  return ((void *)cur_tail);
}
}
#line 367 "queue.c"
void *queue_peek(queue_t *queue , status_t *status ) 
{ 


  {
#line 370
  return (queue->tail);
}
}
#line 377 "queue.c"
void *queue_peek_ts(queue_t *queue , status_t *status ) 
{ 
  status_t local_status ;
  void *tail ;
  int tmp ;

  {
#line 383
  tmp = pthread_mutex_lock(& queue->mutex);
#line 383
  local_status = (status_t )tmp;
#line 384
  if (local_status != 0U) {
#line 385
    *status = local_status;
#line 386
    return ((void *)0);
  }
#line 389
  tail = queue_peek(queue, status);
#line 391
  pthread_mutex_unlock(& queue->mutex);
#line 393
  return (tail);
}
}
#line 400 "queue.c"
void *queue_get_next(queue_t *queue , queue_link_t *curr , status_t *status ) 
{ 
  queue_link_t *next ;

  {
#line 405
  *status = (status_t )0;
#line 407
  if ((unsigned long )queue == (unsigned long )((void *)0)) {
#line 408
    *status = (status_t )22;
#line 409
    return ((void *)0);
  }
#line 411
  if ((unsigned long )queue->tail == (unsigned long )((void *)0)) {
#line 412
    *status = (status_t )61;
#line 413
    return ((void *)0);
  }
#line 416
  if ((unsigned long )curr == (unsigned long )((void *)0)) {
#line 418
    return (queue->tail);
  }
#line 421
  if ((unsigned long )curr == (unsigned long )queue->head) {
#line 422
    *status = (status_t )16;
#line 423
    return ((void *)0);
  }
#line 426
  next = (queue_link_t *)curr->queue_prev;
#line 427
  return ((void *)next);
}
}
#line 433 "queue.c"
size_t queue_get_count(queue_t *queue ) 
{ 


  {
#line 436
  return ((size_t )queue->count);
}
}
#line 443 "queue.c"
size_t queue_get_count_ts(queue_t *queue ) 
{ 
  size_t size ;
  status_t status ;
  int tmp ;

  {
#line 449
  tmp = pthread_mutex_lock(& queue->mutex);
#line 449
  status = (status_t )tmp;
#line 450
  if (status != 0U) {
#line 451
    return ((size_t )0);
  }
#line 454
  size = queue_get_count(queue);
#line 456
  pthread_mutex_unlock(& queue->mutex);
#line 458
  return (size);
}
}
#line 464 "queue.c"
status_t queue_check(queue_link_t *link ) 
{ 


  {
#line 467
  if ((unsigned long )link->queue_next != (unsigned long )((void *)0)) {
#line 469
    return ((status_t )16);
  }
#line 472
  if ((unsigned long )link->queue_prev != (unsigned long )((void *)0)) {
#line 474
    return ((status_t )16);
  }
#line 477
  return ((status_t )0);
}
}
