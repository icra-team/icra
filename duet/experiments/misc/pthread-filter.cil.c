/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is true */

#line 148 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 156 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __clockid_t;
#line 184 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __syscall_slong_t;
#line 91 "/usr/include/time.h"
typedef __clockid_t clockid_t;
#line 120 "/usr/include/time.h"
struct timespec {
   __time_t tv_sec ;
   __syscall_slong_t tv_nsec ;
};
#line 60 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef unsigned long pthread_t;
#line 5 "pixel.h"
struct _pixel {
   unsigned char r ;
   unsigned char g ;
   unsigned char b ;
};
#line 5 "pixel.h"
typedef struct _pixel pixel;
#line 9 "imagepart.h"
struct _imagethread;
#line 11 "imagepart.h"
struct _imagepart {
   struct _pixel *sourcePixels ;
   struct _pixel *destinationPixels ;
   int height ;
   int width ;
   int ystart ;
   int ystop ;
   int pixelCount ;
   int bytes ;
};
#line 7 "imagethread.h"
struct _imagethread {
   int rank ;
   int thread_count ;
   pthread_t *thread ;
   struct _imagepart *partition ;
   void *argument ;
};
#line 7 "imagethread.h"
typedef struct _imagethread imagethread___0;
#line 16 "blurfilter.h"
struct _blurfilterdata {
   int xsize ;
   int ysize ;
   pixel *src ;
   pixel *dst ;
   int radius ;
   double *w ;
   imagethread___0 *imageThreads ;
   int rank ;
};
#line 16 "blurfilter.h"
typedef struct _blurfilterdata blurfilterdata;
#line 213 "/usr/lib/gcc/x86_64-linux-gnu/4.7/include/stddef.h"
typedef unsigned long size_t;
#line 140 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 141 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 155 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 161 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 246 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 11 "imagepart.h"
typedef struct _imagepart imagepart;
#line 63 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
union pthread_attr_t {
   char __size[56] ;
   long __align ;
};
#line 69 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef union pthread_attr_t pthread_attr_t;
#line 75 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
struct __pthread_internal_list {
   struct __pthread_internal_list *__prev ;
   struct __pthread_internal_list *__next ;
};
#line 75 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef struct __pthread_internal_list __pthread_list_t;
#line 90 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
struct __pthread_mutex_s {
   int __lock ;
   unsigned int __count ;
   int __owner ;
   unsigned int __nusers ;
   int __kind ;
   int __spins ;
   __pthread_list_t __list ;
};
#line 90 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
union __anonunion_pthread_mutex_t_10 {
   struct __pthread_mutex_s __data ;
   char __size[40] ;
   long __align ;
};
#line 90 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef union __anonunion_pthread_mutex_t_10 pthread_mutex_t;
#line 129 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
struct __anonstruct___data_13 {
   int __lock ;
   unsigned int __futex ;
   unsigned long long __total_seq ;
   unsigned long long __wakeup_seq ;
   unsigned long long __woken_seq ;
   void *__mutex ;
   unsigned int __nwaiters ;
   unsigned int __broadcast_seq ;
};
#line 129 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
union __anonunion_pthread_cond_t_12 {
   struct __anonstruct___data_13 __data ;
   char __size[48] ;
   long long __align ;
};
#line 129 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef union __anonunion_pthread_cond_t_12 pthread_cond_t;
#line 316 "/usr/include/libio.h"
typedef struct _IO_FILE _IO_FILE;
#line 12 "thresfilter.h"
struct _thresfilterdata {
   int xsize ;
   int ysize ;
   pixel *src ;
   pixel *dst ;
   unsigned int *thresholdsum ;
   imagethread___0 *imageThreads ;
   int rank ;
   pthread_mutex_t *thresholdsum_mutex ;
};
#line 12 "thresfilter.h"
typedef struct _thresfilterdata thresfilterdata;
#line 1 "cil-uP_m9y7g.o"
#pragma merger("0","/tmp/cil-qtknGkr9.i","-pthread,-g,-traceback")
#line 362 "/usr/include/stdio.h"
extern int printf(char const   * __restrict  __format  , ...) ;
#line 342 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) clock_gettime)(clockid_t __clock_id ,
                                                                                    struct timespec *__tp ) ;
#line 9 "pixel.h"
pixel *pix(pixel *image , int const   xx , int const   yy , int const   xsize ) ;
#line 10
pixel *pix_trans(pixel *image , int const   xx , int const   yy , int const   ysize ) ;
#line 20 "imagethread.h"
void SynchronizationPoint(void) ;
#line 27 "blurfilter.h"
void *blurfilterwrapper(void *arg ) ;
#line 28
void blurfilter(int const   xsize , int const   ysize , pixel *src , pixel *dst ,
                int const   radius , double const   *w , imagethread___0 *imageThreads ,
                int rank ) ;
#line 16 "blurfilter.c"
void *blurfilterwrapper(void *arg ) 
{ 
  blurfilterdata *data ;

  {
#line 17
  data = (blurfilterdata *)arg;
#line 18
  blurfilter((int const   )data->xsize, (int const   )data->ysize, data->src, data->dst,
             (int const   )data->radius, (double const   *)data->w, data->imageThreads,
             data->rank);
#line 19
  return ((void *)0);
}
}
#line 22 "blurfilter.c"
void blurfilter(int const   xsize , int const   ysize , pixel *src , pixel *dst ,
                int const   radius , double const   *w , imagethread___0 *imageThreads ,
                int rank ) 
{ 
  int x ;
  int y ;
  int x2 ;
  int wi ;
  double r ;
  double g ;
  double b ;
  double n ;
  double wc ;
  struct timespec stime___0 ;
  struct timespec etime ;
  imagethread___0 *thread ;
  struct _imagepart *part ;
  int ystart ;
  int ystop ;
  pixel *tmp ;
  pixel *tmp___0 ;
  pixel *tmp___1 ;
  pixel *tmp___2 ;
  pixel *tmp___3 ;
  pixel *tmp___4 ;
  pixel *tmp___5 ;
  pixel *tmp___6 ;
  pixel *tmp___7 ;
  pixel *tmp___8 ;
  pixel *tmp___9 ;
  pixel *tmp___10 ;
  pixel *tmp___11 ;
  pixel *tmp___12 ;
  pixel *tmp___13 ;
  pixel *tmp___14 ;
  pixel *tmp___15 ;
  pixel *tmp___16 ;
  pixel *tmp___17 ;
  pixel *tmp___18 ;
  pixel *tmp___19 ;
  pixel *tmp___20 ;
  pixel *tmp___21 ;
  pixel *tmp___22 ;

  {
#line 35
  thread = imageThreads + rank;
#line 36
  part = thread->partition;
#line 37
  ystart = part->ystart;
#line 38
  ystop = part->ystop;
#line 40
  clock_gettime(0, & stime___0);
#line 41
  y = ystart;
#line 41
  while (y < ystop) {
#line 42
    x = 0;
#line 42
    while (x < (int )xsize) {
#line 43
      tmp = pix(src, (int const   )x, (int const   )y, xsize);
#line 43
      r = (double )(*(w + 0) * (double const   )tmp->r);
#line 44
      tmp___0 = pix(src, (int const   )x, (int const   )y, xsize);
#line 44
      g = (double )(*(w + 0) * (double const   )tmp___0->g);
#line 45
      tmp___1 = pix(src, (int const   )x, (int const   )y, xsize);
#line 45
      b = (double )(*(w + 0) * (double const   )tmp___1->b);
#line 46
      n = (double )*(w + 0);
#line 47
      wi = 1;
#line 47
      while (wi <= (int )radius) {
#line 48
        wc = (double )*(w + wi);
#line 49
        x2 = x - wi;
#line 50
        if (x2 >= 0) {
#line 51
          tmp___2 = pix(src, (int const   )x2, (int const   )y, xsize);
#line 51
          r += wc * (double )tmp___2->r;
#line 52
          tmp___3 = pix(src, (int const   )x2, (int const   )y, xsize);
#line 52
          g += wc * (double )tmp___3->g;
#line 53
          tmp___4 = pix(src, (int const   )x2, (int const   )y, xsize);
#line 53
          b += wc * (double )tmp___4->b;
#line 54
          n += wc;
        }
#line 56
        x2 = x + wi;
#line 57
        if (x2 < (int )xsize) {
#line 58
          tmp___5 = pix(src, (int const   )x2, (int const   )y, xsize);
#line 58
          r += wc * (double )tmp___5->r;
#line 59
          tmp___6 = pix(src, (int const   )x2, (int const   )y, xsize);
#line 59
          g += wc * (double )tmp___6->g;
#line 60
          tmp___7 = pix(src, (int const   )x2, (int const   )y, xsize);
#line 60
          b += wc * (double )tmp___7->b;
#line 61
          n += wc;
        }
#line 47
        wi ++;
      }
#line 64
      tmp___8 = pix_trans(dst, (int const   )x, (int const   )y, ysize);
#line 64
      tmp___8->r = (unsigned char )(r / n);
#line 65
      tmp___9 = pix_trans(dst, (int const   )x, (int const   )y, ysize);
#line 65
      tmp___9->g = (unsigned char )(g / n);
#line 66
      tmp___10 = pix_trans(dst, (int const   )x, (int const   )y, ysize);
#line 66
      tmp___10->b = (unsigned char )(b / n);
#line 42
      x ++;
    }
#line 41
    y ++;
  }
#line 70
  SynchronizationPoint();
#line 72
  y = 0;
#line 72
  while (y < (int )xsize) {
#line 73
    x = ystart;
#line 73
    while (x < ystop) {
#line 74
      tmp___11 = pix(dst, (int const   )x, (int const   )y, ysize);
#line 74
      r = (double )(*(w + 0) * (double const   )tmp___11->r);
#line 75
      tmp___12 = pix(dst, (int const   )x, (int const   )y, ysize);
#line 75
      g = (double )(*(w + 0) * (double const   )tmp___12->g);
#line 76
      tmp___13 = pix(dst, (int const   )x, (int const   )y, ysize);
#line 76
      b = (double )(*(w + 0) * (double const   )tmp___13->b);
#line 77
      n = (double )*(w + 0);
#line 78
      wi = 1;
#line 78
      while (wi <= (int )radius) {
#line 79
        wc = (double )*(w + wi);
#line 80
        x2 = x - wi;
#line 81
        if (x2 >= 0) {
#line 82
          tmp___14 = pix(dst, (int const   )x2, (int const   )y, ysize);
#line 82
          r += wc * (double )tmp___14->r;
#line 83
          tmp___15 = pix(dst, (int const   )x2, (int const   )y, ysize);
#line 83
          g += wc * (double )tmp___15->g;
#line 84
          tmp___16 = pix(dst, (int const   )x2, (int const   )y, ysize);
#line 84
          b += wc * (double )tmp___16->b;
#line 85
          n += wc;
        }
#line 87
        x2 = x + wi;
#line 88
        if (x2 < (int )ysize) {
#line 89
          tmp___17 = pix(dst, (int const   )x2, (int const   )y, ysize);
#line 89
          r += wc * (double )tmp___17->r;
#line 90
          tmp___18 = pix(dst, (int const   )x2, (int const   )y, ysize);
#line 90
          g += wc * (double )tmp___18->g;
#line 91
          tmp___19 = pix(dst, (int const   )x2, (int const   )y, ysize);
#line 91
          b += wc * (double )tmp___19->b;
#line 92
          n += wc;
        }
#line 78
        wi ++;
      }
#line 95
      tmp___20 = pix_trans(src, (int const   )x, (int const   )y, xsize);
#line 95
      tmp___20->r = (unsigned char )(r / n);
#line 96
      tmp___21 = pix_trans(src, (int const   )x, (int const   )y, xsize);
#line 96
      tmp___21->g = (unsigned char )(g / n);
#line 97
      tmp___22 = pix_trans(src, (int const   )x, (int const   )y, xsize);
#line 97
      tmp___22->b = (unsigned char )(b / n);
#line 73
      x ++;
    }
#line 72
    y ++;
  }
#line 100
  clock_gettime(0, & etime);
#line 102
  printf((char const   * __restrict  )"Filtering %d took %g secs\n", rank, (double )(etime.tv_sec - stime___0.tv_sec) + 1e-9 * (double )(etime.tv_nsec - stime___0.tv_nsec));
#line 105
  SynchronizationPoint();
#line 106
  return;
}
}
#line 1 "cil-vLz6YM6P.o"
#pragma merger("0","/tmp/cil-TT0mBh8b.i","-pthread,-g,-traceback")
#line 147 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) atoi)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 465
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 170 "/usr/include/stdio.h"
extern struct _IO_FILE *stderr ;
#line 356
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 172 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strdup)(char const   *__s )  __attribute__((__malloc__)) ;
#line 21 "ppmio.h"
int read_ppm(char const   *fname , int *xpix , int *ypix , int *max , char *data ) ;
#line 31
int write_ppm(char const   *fname , int xpix , int ypix , char *data ) ;
#line 11 "pixel.h"
pixel *allocate_image(int size ) ;
#line 22 "imagepart.h"
void divide(imagethread___0 *threadData , int count , pixel *sourceImage , pixel *destinationImage ,
            int const   xsize , int const   ysize ) ;
#line 17 "imagethread.h"
pthread_t *createThread(void *function , void *argument ) ;
#line 18
imagethread___0 *createThreadData(int count ) ;
#line 19
void setThreadSyncCount(int count ) ;
#line 19 "gaussw.h"
void get_gauss_weights(int n , double *weights_out ) ;
#line 12 "blurmain.c"
int blurmain(int argc , char **argv ) 
{ 
  int thread_count ;
  int radius ;
  int xsize ;
  int ysize ;
  int colmax ;
  pixel *src ;
  pixel *dst ;
  imagethread___0 *imageThreads ;
  blurfilterdata *blurdata ;
  int i ;
  char *inputFilepath ;
  char *outputFilepath ;
  struct timespec stime___0 ;
  struct timespec etime ;
  double *w ;
  void *tmp ;
  int tmp___0 ;
  void *tmp___1 ;
  int tmp___2 ;

  {
#line 27
  src = allocate_image(1000000);
#line 28
  dst = allocate_image(1000000);
#line 30
  tmp = malloc(sizeof(double ) * 1000UL);
#line 30
  w = (double *)tmp;
#line 34
  if (argc != 5) {
#line 35
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Usage: %s thread_count radius infile outfile\n",
            *(argv + 0));
#line 36
    return (1);
  }
#line 39
  thread_count = atoi((char const   *)*(argv + 1));
#line 40
  if (thread_count < 1) {
#line 41
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Too few threads\n");
#line 42
    return (1);
  }
#line 45
  thread_count = atoi((char const   *)*(argv + 1));
#line 46
  radius = atoi((char const   *)*(argv + 2));
#line 47
  if (radius > 1000) {
#line 48
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Radius (%d) must be greater than zero and less then %d\n",
            radius, 1000);
#line 49
    return (1);
  } else
#line 47
  if (radius < 1) {
#line 48
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Radius (%d) must be greater than zero and less then %d\n",
            radius, 1000);
#line 49
    return (1);
  }
#line 52
  inputFilepath = strdup((char const   *)*(argv + 3));
#line 53
  outputFilepath = strdup((char const   *)*(argv + 4));
#line 56
  tmp___0 = read_ppm((char const   *)inputFilepath, & xsize, & ysize, & colmax, (char *)src);
#line 56
  if (tmp___0 != 0) {
#line 57
    return (1);
  }
#line 59
  if (colmax > 255) {
#line 60
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Too large maximum color-component value\n");
#line 61
    return (1);
  }
#line 64
  printf((char const   * __restrict  )"Has read the image, generating coefficients\n");
#line 67
  get_gauss_weights(radius, w);
#line 69
  printf((char const   * __restrict  )"Calling filter\n");
#line 71
  clock_gettime(0, & stime___0);
#line 73
  printf((char const   * __restrict  )"Creating threads\n");
#line 74
  imageThreads = createThreadData(thread_count);
#line 76
  printf((char const   * __restrict  )"Dividing image\n");
#line 77
  divide(imageThreads, thread_count, src, dst, (int const   )xsize, (int const   )ysize);
#line 78
  printf((char const   * __restrict  )"\n");
#line 80
  printf((char const   * __restrict  )"Setting arguments\n");
#line 81
  tmp___1 = malloc(sizeof(blurfilterdata ) * (unsigned long )thread_count);
#line 81
  blurdata = (blurfilterdata *)tmp___1;
#line 82
  i = 0;
#line 82
  while (i < thread_count) {
#line 83
    (blurdata + i)->xsize = xsize;
#line 84
    (blurdata + i)->ysize = ysize;
#line 85
    (blurdata + i)->src = src;
#line 86
    (blurdata + i)->dst = dst;
#line 87
    (blurdata + i)->radius = radius;
#line 88
    (blurdata + i)->w = w;
#line 89
    (blurdata + i)->imageThreads = imageThreads;
#line 90
    (blurdata + i)->rank = i;
#line 82
    i ++;
  }
#line 93
  printf((char const   * __restrict  )"Starting threads\n");
#line 94
  setThreadSyncCount(thread_count);
#line 95
  i = 0;
#line 95
  while (i < thread_count) {
#line 97
    (imageThreads + i)->argument = (void *)(blurdata + i);
#line 98
    (imageThreads + i)->thread = createThread((void *)(& blurfilterwrapper), (imageThreads + i)->argument);
#line 95
    i ++;
  }
#line 101
  printf((char const   * __restrict  )"Threads working on x-axis\n");
#line 102
  SynchronizationPoint();
#line 103
  printf((char const   * __restrict  )"Threads working on y-axis\n");
#line 104
  SynchronizationPoint();
#line 105
  printf((char const   * __restrict  )"Threads done\n");
#line 107
  clock_gettime(0, & etime);
#line 109
  printf((char const   * __restrict  )"Filtering took: %g secs\n", (double )(etime.tv_sec - stime___0.tv_sec) + 1e-9 * (double )(etime.tv_nsec - stime___0.tv_nsec));
#line 113
  printf((char const   * __restrict  )"Writing output file \"%s\"\n", outputFilepath);
#line 115
  tmp___2 = write_ppm((char const   *)outputFilepath, xsize, ysize, (char *)src);
#line 115
  if (tmp___2 != 0) {
#line 116
    return (1);
  }
#line 119
  return (0);
}
}
#line 1 "cil-tR1BCyr5.o"
#pragma merger("0","/tmp/cil-wQ3Irmb1.i","-pthread,-g,-traceback")
#line 100 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h"
extern  __attribute__((__nothrow__)) double ( __attribute__((__leaf__)) exp)(double __x ) ;
#line 18 "gaussw.c"
void get_gauss_weights(int n , double *weights_out ) 
{ 
  double x ;
  int i ;

  {
#line 22
  i = 0;
#line 22
  while (i < n + 1) {
#line 23
    x = ((double )i * 1.33) / (double )n;
#line 24
    *(weights_out + i) = exp((- x * x) * 3.14159);
#line 22
    i ++;
  }
#line 26
  return;
}
}
#line 1 "cil-kmxtXIcO.o"
#pragma merger("0","/tmp/cil-UaIHifcB.i","-pthread,-g,-traceback")
#line 8 "imagepart.c"
void divide(imagethread___0 *threadData , int count , pixel *sourceImage , pixel *destinationImage ,
            int const   xsize , int const   ysize ) 
{ 
  int i ;
  int partHeight ;
  int partHeightLeft ;
  void *tmp ;

  {
#line 13
  partHeight = (int )(ysize / (int const   )count);
#line 14
  partHeightLeft = (int )(ysize % (int const   )count);
#line 16
  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Setting structs\n");
#line 18
  i = 0;
#line 18
  while (i < count) {
#line 19
    tmp = malloc(sizeof(imagepart ));
#line 19
    (threadData + i)->partition = (imagepart *)tmp;
#line 18
    i ++;
  }
#line 22
  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Setting initial height\n");
#line 24
  i = 0;
#line 24
  while (i < count) {
#line 25
    ((threadData + i)->partition)->width = (int )xsize;
#line 26
    ((threadData + i)->partition)->height = partHeight;
#line 24
    i ++;
  }
#line 29
  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Setting corrected height\n");
#line 30
  i = 0;
#line 30
  while (i < partHeightLeft) {
#line 31
    (((threadData + i)->partition)->height) ++;
#line 30
    i ++;
  }
#line 34
  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Setting pixel count & bytes\n");
#line 35
  i = 0;
#line 35
  while (i < count) {
#line 37
    ((threadData + i)->partition)->pixelCount = ((threadData + i)->partition)->width * ((threadData + i)->partition)->height;
#line 39
    ((threadData + i)->partition)->bytes = (int )((unsigned long )((threadData + i)->partition)->pixelCount * sizeof(pixel ));
#line 35
    i ++;
  }
#line 42
  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Setting ystart, sourcePixels and destinationPixels\n");
#line 44
  ((threadData + 0)->partition)->ystart = 0;
#line 45
  ((threadData + 0)->partition)->ystop = ((threadData + 0)->partition)->height;
#line 47
  ((threadData + 0)->partition)->sourcePixels = sourceImage;
#line 48
  ((threadData + 0)->partition)->destinationPixels = destinationImage;
#line 49
  i = 1;
#line 49
  while (i < count) {
#line 51
    ((threadData + i)->partition)->ystart = ((threadData + (i - 1))->partition)->ystop;
#line 52
    ((threadData + i)->partition)->ystop = ((threadData + i)->partition)->ystart + ((threadData + i)->partition)->height;
#line 54
    ((threadData + i)->partition)->sourcePixels = ((threadData + (i - 1))->partition)->sourcePixels + ((threadData + (i - 1))->partition)->bytes;
#line 55
    ((threadData + i)->partition)->destinationPixels = ((threadData + (i - 1))->partition)->destinationPixels + ((threadData + (i - 1))->partition)->bytes;
#line 49
    i ++;
  }
#line 70
  return;
}
}
#line 1 "cil-oouRxBhj.o"
#pragma merger("0","/tmp/cil-X9D3bo40.i","-pthread,-g,-traceback")
#line 232 "/usr/include/pthread.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,3))) pthread_create)(pthread_t * __restrict  __newthread ,
                                                                                             pthread_attr_t const   * __restrict  __attr ,
                                                                                             void *(*__start_routine)(void * ) ,
                                                                                             void * __restrict  __arg ) ;
#line 753
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) pthread_mutex_lock)(pthread_mutex_t *__mutex ) ;
#line 764
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) pthread_mutex_unlock)(pthread_mutex_t *__mutex ) ;
#line 972
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) pthread_cond_broadcast)(pthread_cond_t *__cond ) ;
#line 980
extern int ( __attribute__((__nonnull__(1,2))) pthread_cond_wait)(pthread_cond_t * __restrict  __cond ,
                                                                  pthread_mutex_t * __restrict  __mutex ) ;
#line 6 "imagethread.c"
pthread_mutex_t sync_lock  =    {{0, 0U, 0, 0U, 0, 0, {(struct __pthread_internal_list *)0, (struct __pthread_internal_list *)0}}};
#line 7 "imagethread.c"
pthread_cond_t sync_cond  =    {{0, 0U, 0ULL, 0ULL, 0ULL, (void *)0, 0U, 0U}};
#line 8 "imagethread.c"
int sync_max_count  =    0;
#line 9 "imagethread.c"
int sync_count  =    0;
#line 11 "imagethread.c"
pthread_t *createThread(void *function , void *argument ) 
{ 
  pthread_t *thread ;
  void *tmp ;

  {
#line 13
  tmp = malloc(sizeof(pthread_t ));
#line 13
  thread = (pthread_t *)tmp;
#line 14
  pthread_create((pthread_t * __restrict  )thread, (pthread_attr_t const   * __restrict  )((void *)0),
                 (void *(*)(void * ))function, (void * __restrict  )argument);
#line 15
  return (thread);
}
}
#line 18 "imagethread.c"
imagethread___0 *createThreadData(int count ) 
{ 
  int i ;
  imagethread___0 *threads ;
  void *tmp ;

  {
#line 21
  tmp = malloc(sizeof(imagethread___0 ) * (unsigned long )count);
#line 21
  threads = (imagethread___0 *)tmp;
#line 22
  i = 0;
#line 22
  while (i < count) {
#line 23
    (threads + i)->rank = i;
#line 24
    (threads + i)->thread_count = count;
#line 22
    i ++;
  }
#line 26
  return (threads);
}
}
#line 31 "imagethread.c"
void setThreadSyncCount(int count ) 
{ 


  {
#line 32
  sync_max_count = count + 1;
#line 33
  return;
}
}
#line 35 "imagethread.c"
void SynchronizationPoint(void) 
{ 


  {
#line 38
  pthread_mutex_lock(& sync_lock);
#line 41
  sync_count ++;
#line 44
  if (sync_count < sync_max_count) {
#line 46
    pthread_cond_wait((pthread_cond_t * __restrict  )(& sync_cond), (pthread_mutex_t * __restrict  )(& sync_lock));
  } else {
#line 51
    sync_count = 0;
#line 54
    pthread_cond_broadcast(& sync_cond);
  }
#line 59
  pthread_mutex_unlock(& sync_lock);
#line 60
  return;
}
}
#line 1 "cil-F1tfFFoh.o"
#pragma merger("0","/tmp/cil-y_JT2XzS.i","-pthread,-g,-traceback")
#line 4 "thresmain.h"
int thresmain(int argc , char **argv ) ;
#line 542 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 6 "main.c"
int main(int argc , char **argv ) 
{ 
  int result ;

  {
#line 8
  result = 0;
#line 9
  if (argc == 4) {
#line 10
    printf((char const   * __restrict  )"Threshold!\n");
#line 11
    result = thresmain(argc, argv);
  } else
#line 12
  if (argc == 5) {
#line 13
    printf((char const   * __restrict  )"Blur!\n");
#line 14
    result = blurmain(argc, argv);
  } else {
#line 16
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Threshold usage: %s thread_count infile outfile\n",
            *(argv + 0));
#line 17
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Blur usage: %s thread_count radius infile outfile\n",
            *(argv + 0));
#line 18
    result = 1;
  }
#line 21
  exit(result);
}
}
#line 1 "cil-VH9qfam7.o"
#pragma merger("0","/tmp/cil-cM0dVvAR.i","-pthread,-g,-traceback")
#line 538 "/usr/include/stdio.h"
extern int getchar(void) ;
#line 6 "pixel.c"
pixel *pix(pixel *image , int const   xx , int const   yy , int const   xsize ) 
{ 
  register int off ;

  {
#line 8
  off = (int )(xsize * yy + xx);
#line 10
  if (off >= 1000000) {
#line 11
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"\n Terribly wrong: %d %d %d\n",
            xx, yy, xsize);
  }
#line 13
  return (image + off);
}
}
#line 16 "pixel.c"
pixel *pix_trans(pixel *image , int const   xx , int const   yy , int const   ysize ) 
{ 
  register int off ;

  {
#line 18
  off = (int )(ysize * xx + yy);
#line 20
  if (off >= 1000000) {
#line 21
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"\n Terribly wrong: %d %d %d\n",
            xx, yy, ysize);
  }
#line 23
  return (image + off);
}
}
#line 26 "pixel.c"
pixel *allocate_image(int size ) 
{ 
  pixel *image ;
  void *tmp ;

  {
#line 29
  tmp = malloc(sizeof(pixel ) * (unsigned long )size);
#line 29
  image = (pixel *)tmp;
#line 30
  if (! image) {
#line 31
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"malloc failed");
#line 32
    getchar();
#line 33
    exit(1);
  }
#line 35
  return (image);
}
}
#line 1 "cil-oaqObFYB.o"
#pragma merger("0","/tmp/cil-Kl42Li3z.i","-pthread,-g,-traceback")
#line 435 "/usr/include/libio.h"
extern int _IO_getc(_IO_FILE *__fp ) ;
#line 3 "ppm.h"
void ppm_error(char *str ) ;
#line 6
char ppm_readchar(FILE *file ) ;
#line 9
int ppm_readmagicnumber(FILE *file ) ;
#line 12
int ppm_readint(FILE *file ) ;
#line 4 "ppm.c"
void ppm_error(char *str ) 
{ 


  {
#line 6
  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s\n", str);
#line 7
  getchar();
#line 8
  exit(1);
}
}
#line 12 "ppm.c"
char ppm_readchar(FILE *file ) 
{ 
  char ch ;
  int tmp ;
  int tmp___0 ;

  {
#line 15
  tmp = _IO_getc(file);
#line 15
  ch = (char )tmp;
#line 16
  if ((int )ch == -1) {
#line 17
    ppm_error((char *)"read error");
  }
#line 18
  if ((int )ch == 35) {
#line 18
    while (1) {
#line 19
      tmp___0 = _IO_getc(file);
#line 19
      ch = (char )tmp___0;
#line 20
      if ((int )ch == -1) {
#line 21
        ppm_error((char *)"read error");
      }
#line 18
      if (! ((int )ch != 10)) {
#line 18
        break;
      }
    }
  }
#line 24
  return (ch);
}
}
#line 28 "ppm.c"
int ppm_readmagicnumber(FILE *file ) 
{ 
  int ch1 ;
  int ch2 ;

  {
#line 32
  ch1 = _IO_getc(file);
#line 33
  if (ch1 == -1) {
#line 34
    ppm_error((char *)"read error");
  }
#line 35
  ch2 = _IO_getc(file);
#line 36
  if (ch2 == -1) {
#line 37
    ppm_error((char *)"read error");
  }
#line 38
  return (ch1 * 256 + ch2);
}
}
#line 42 "ppm.c"
int ppm_readint(FILE *file ) 
{ 
  char ch ;
  int i ;

  {
#line 47
  while (1) {
#line 48
    ch = ppm_readchar(file);
#line 47
    if (! ((int )ch == 32)) {
#line 47
      if (! ((int )ch == 9)) {
#line 47
        if (! ((int )ch == 10)) {
#line 47
          break;
        }
      }
    }
  }
#line 51
  if ((int )ch < 48) {
#line 52
    ppm_error((char *)"error in readint");
  } else
#line 51
  if ((int )ch > 57) {
#line 52
    ppm_error((char *)"error in readint");
  }
#line 53
  i = 0;
#line 54
  while (1) {
#line 55
    i = i * 10 + ((int )ch - 48);
#line 56
    ch = ppm_readchar(file);
#line 54
    if ((int )ch >= 48) {
#line 54
      if (! ((int )ch <= 57)) {
#line 54
        break;
      }
    } else {
#line 54
      break;
    }
  }
#line 58
  return (i);
}
}
#line 1 "cil-JqqI5iP9.o"
#pragma merger("0","/tmp/cil-hRQF31VE.i","-pthread,-g,-traceback")
#line 237 "/usr/include/stdio.h"
extern int fclose(FILE *__stream ) ;
#line 272
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
#line 425
extern int fscanf(FILE * __restrict  __stream , char const   * __restrict  __format 
                  , ...)  __asm__("__isoc99_fscanf")  ;
#line 433
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) sscanf)(char const   * __restrict  __s ,
                                                                             char const   * __restrict  __format 
                                                                             , ...)  __asm__("__isoc99_sscanf")  ;
#line 622
extern char *fgets(char * __restrict  __s , int __n , FILE * __restrict  __stream ) ;
#line 709
extern size_t fread(void * __restrict  __ptr , size_t __size , size_t __n , FILE * __restrict  __stream ) ;
#line 715
extern size_t fwrite(void const   * __restrict  __ptr , size_t __size , size_t __n ,
                     FILE * __restrict  __s ) ;
#line 846
extern void perror(char const   *__s ) ;
#line 143 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strncmp)(char const   *__s1 ,
                                                                                                char const   *__s2 ,
                                                                                                size_t __n )  __attribute__((__pure__)) ;
#line 409
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) strerror)(int __errnum ) ;
#line 12 "ppmio.c"
int read_ppm(char const   *fname , int *xpix , int *ypix , int *max , char *data ) 
{ 
  char ftype[40] ;
  char ctype[40] ;
  unsigned int tmp ;
  char line[80] ;
  int errno ;
  FILE *fp ;
  char *filename ;
  int bytesToRead ;
  int bytesRead ;
  char *tmp___0 ;
  char *tmp___1 ;
  size_t tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 14
  ctype[0] = (char )'P';
#line 14
  ctype[1] = (char )'6';
#line 14
  ctype[2] = (char )'\000';
#line 14
  tmp = 3U;
#line 14
  while (! (tmp >= 40U)) {
#line 14
    ctype[tmp] = (char)0;
#line 14
    tmp ++;
  }
#line 24
  errno = 0;
#line 26
  filename = strdup(fname);
#line 28
  if ((unsigned long )filename == (unsigned long )((void *)0)) {
#line 28
    filename = (char *)"\000";
  }
#line 29
  fp = fopen((char const   * __restrict  )filename, (char const   * __restrict  )"r");
#line 30
  if ((unsigned long )fp == (unsigned long )((void *)0)) {
#line 31
    tmp___0 = strerror(errno);
#line 31
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"read_ppm failed to open %s: %s\n",
            filename, tmp___0);
#line 32
    getchar();
#line 33
    exit(1);
  }
#line 36
  fgets((char * __restrict  )(line), 80, (FILE * __restrict  )fp);
#line 37
  sscanf((char const   * __restrict  )(line), (char const   * __restrict  )"%s", ftype);
#line 39
  while (1) {
#line 39
    tmp___1 = fgets((char * __restrict  )(line), 80, (FILE * __restrict  )fp);
#line 39
    if (tmp___1) {
#line 39
      if (! ((int )line[0] == 35)) {
#line 39
        break;
      }
    } else {
#line 39
      break;
    }
  }
#line 41
  sscanf((char const   * __restrict  )(line), (char const   * __restrict  )"%d%d",
         xpix, ypix);
#line 42
  fscanf((FILE * __restrict  )fp, (char const   * __restrict  )"%d\n", max);
#line 44
  if (*xpix * *ypix > 1000000) {
#line 45
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Image size is too big\n");
#line 46
    return (4);
  }
#line 49
  tmp___3 = strncmp((char const   *)(ftype), (char const   *)(ctype), (size_t )2);
#line 49
  if (tmp___3 == 0) {
#line 50
    bytesToRead = (*xpix * *ypix) * 3;
#line 51
    tmp___2 = fread((void * __restrict  )data, sizeof(char ), (size_t )bytesToRead,
                    (FILE * __restrict  )fp);
#line 51
    bytesRead = (int )tmp___2;
#line 54
    if (bytesRead != bytesToRead) {
#line 55
      perror("Read failed");
#line 56
      return (2);
    }
  } else {
#line 59
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Wrong file format: %s\n",
            ftype);
  }
#line 62
  tmp___4 = fclose(fp);
#line 62
  if (tmp___4 == -1) {
#line 63
    perror("Close failed");
#line 64
    return (3);
  }
#line 66
  return (0);
}
}
#line 71 "ppmio.c"
int write_ppm(char const   *fname , int xpix , int ypix , char *data ) 
{ 
  FILE *fp ;
  char *filename ;
  int errnoOut ;
  int bytesToWrite ;
  int bytesWritten ;
  char *tmp ;
  size_t tmp___0 ;
  int tmp___1 ;

  {
#line 75
  errnoOut = 0;
#line 80
  filename = strdup(fname);
#line 82
  if ((unsigned long )filename == (unsigned long )((void *)0)) {
#line 88
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"write_ppm filename is null.\n");
#line 89
    exit(1);
  }
#line 92
  fp = fopen((char const   * __restrict  )filename, (char const   * __restrict  )"w");
#line 94
  if ((unsigned long )fp == (unsigned long )((void *)0)) {
#line 95
    tmp = strerror(errnoOut);
#line 95
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"write_ppm failed to open %s: %s\n",
            filename, tmp);
#line 96
    getchar();
#line 97
    exit(1);
  }
#line 100
  fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"P6\n");
#line 101
  fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"%d %d 255\n", xpix,
          ypix);
#line 102
  bytesToWrite = (xpix * ypix) * 3;
#line 103
  tmp___0 = fwrite((void const   * __restrict  )data, sizeof(char ), (size_t )bytesToWrite,
                   (FILE * __restrict  )fp);
#line 103
  bytesWritten = (int )tmp___0;
#line 106
  if (bytesWritten != bytesToWrite) {
#line 107
    perror("Write failed");
#line 108
    return (2);
  }
#line 110
  tmp___1 = fclose(fp);
#line 110
  if (tmp___1 == -1) {
#line 111
    perror("Close failed");
#line 112
    return (3);
  }
#line 114
  return (0);
}
}
#line 1 "cil-N6UWdFkW.o"
#pragma merger("0","/tmp/cil-yRVw9Oip.i","-pthread,-g,-traceback")
#line 23 "thresfilter.h"
void *thresfilterwrapper(void *arg ) ;
#line 24
void thresfilter(int const   xsize , int const   ysize , pixel *src , unsigned int *thresholdsum ,
                 pthread_mutex_t *thresholdsum_mutex , imagethread___0 *imageThreads ,
                 int rank ) ;
#line 5 "thresfilter.c"
void *thresfilterwrapper(void *arg ) 
{ 
  thresfilterdata *data ;

  {
#line 6
  data = (thresfilterdata *)arg;
#line 7
  thresfilter((int const   )data->xsize, (int const   )data->ysize, data->src, data->thresholdsum,
              data->thresholdsum_mutex, data->imageThreads, data->rank);
#line 8
  return ((void *)0);
}
}
#line 11 "thresfilter.c"
void thresfilter(int const   xsize , int const   ysize , pixel *src , unsigned int *thresholdsum ,
                 pthread_mutex_t *thresholdsum_mutex , imagethread___0 *imageThreads ,
                 int rank ) 
{ 
  unsigned int sum ;
  unsigned int i ;
  unsigned int psum ;
  unsigned int nump ;
  unsigned int numptot ;
  unsigned int start ;
  unsigned int stop ;
  struct timespec stime___0 ;
  struct timespec etime ;
  imagethread___0 *thread ;
  struct _imagepart *part ;
  int ystart ;
  int ystop ;
  unsigned char tmp ;
  unsigned char tmp___0 ;
  unsigned char tmp___1 ;
  unsigned char tmp___2 ;

  {
#line 21
  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Hello from thread %d\n",
          rank);
#line 23
  thread = imageThreads + rank;
#line 24
  part = thread->partition;
#line 25
  ystart = part->ystart;
#line 26
  ystop = part->ystop;
#line 28
  clock_gettime(0, & stime___0);
#line 30
  numptot = (unsigned int )(xsize * ysize);
#line 31
  nump = (unsigned int )part->pixelCount;
#line 32
  start = (unsigned int )(part->width * part->ystart);
#line 33
  stop = (unsigned int )(part->width * part->ystart) + nump;
#line 35
  i = start;
#line 35
  sum = 0U;
#line 35
  while (i < stop) {
#line 36
    sum += ((unsigned int )(src + i)->r + (unsigned int )(src + i)->g) + (unsigned int )(src + i)->b;
#line 35
    i ++;
  }
#line 39
  pthread_mutex_lock(thresholdsum_mutex);
#line 41
  *thresholdsum += sum;
#line 42
  pthread_mutex_unlock(thresholdsum_mutex);
#line 45
  SynchronizationPoint();
#line 47
  sum = *thresholdsum / numptot;
#line 50
  i = start;
#line 50
  while (i < stop) {
#line 51
    psum = ((unsigned int )(src + i)->r + (unsigned int )(src + i)->g) + (unsigned int )(src + i)->b;
#line 52
    if (sum > psum) {
#line 53
      tmp___0 = (unsigned char)0;
#line 53
      (src + i)->b = tmp___0;
#line 53
      tmp = tmp___0;
#line 53
      (src + i)->g = tmp;
#line 53
      (src + i)->r = tmp;
    } else {
#line 56
      tmp___2 = (unsigned char)255;
#line 56
      (src + i)->b = tmp___2;
#line 56
      tmp___1 = tmp___2;
#line 56
      (src + i)->g = tmp___1;
#line 56
      (src + i)->r = tmp___1;
    }
#line 50
    i ++;
  }
#line 59
  clock_gettime(0, & etime);
#line 61
  printf((char const   * __restrict  )"Filtering %d took %g secs\n", rank, (double )(etime.tv_sec - stime___0.tv_sec) + 1e-9 * (double )(etime.tv_nsec - stime___0.tv_nsec));
#line 64
  SynchronizationPoint();
#line 65
  return;
}
}
#line 1 "cil-3jYHL1iz.o"
#pragma merger("0","/tmp/cil-MnAJyjkE.i","-pthread,-g,-traceback")
#line 1 "cil-thuWmItE.o"
#pragma merger("0","/tmp/cil-1mHd2xoG.i","-pthread,-g,-traceback")
#line 11 "thresmain.c"
int thresmain(int argc , char **argv ) 
{ 
  int thread_count ;
  int xsize ;
  int ysize ;
  int colmax ;
  pixel *src ;
  pixel *dst ;
  imagethread___0 *imageThreads ;
  thresfilterdata *thresdata ;
  pthread_mutex_t thresholdsum_mutex ;
  unsigned int thresholdsum ;
  int i ;
  char *inputFilepath ;
  char *outputFilepath ;
  struct timespec stime___0 ;
  struct timespec etime ;
  int tmp ;
  void *tmp___0 ;
  int tmp___1 ;

  {
#line 18
  thresholdsum_mutex.__data.__lock = 0;
#line 18
  thresholdsum_mutex.__data.__count = 0U;
#line 18
  thresholdsum_mutex.__data.__owner = 0;
#line 18
  thresholdsum_mutex.__data.__nusers = 0U;
#line 18
  thresholdsum_mutex.__data.__kind = 0;
#line 18
  thresholdsum_mutex.__data.__spins = 0;
#line 18
  thresholdsum_mutex.__data.__list.__prev = (struct __pthread_internal_list *)0;
#line 18
  thresholdsum_mutex.__data.__list.__next = (struct __pthread_internal_list *)0;
#line 19
  thresholdsum = 0U;
#line 25
  src = allocate_image(1000000);
#line 26
  dst = allocate_image(1000000);
#line 30
  if (argc != 4) {
#line 31
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Usage: %s thread_count infile outfile\n",
            *(argv + 0));
#line 32
    return (1);
  }
#line 35
  thread_count = atoi((char const   *)*(argv + 1));
#line 36
  if (thread_count < 1) {
#line 37
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Too few threads\n");
#line 38
    return (1);
  }
#line 41
  inputFilepath = strdup((char const   *)*(argv + 2));
#line 42
  outputFilepath = strdup((char const   *)*(argv + 3));
#line 45
  tmp = read_ppm((char const   *)inputFilepath, & xsize, & ysize, & colmax, (char *)src);
#line 45
  if (tmp != 0) {
#line 46
    return (1);
  }
#line 48
  if (colmax > 255) {
#line 49
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Too large maximum color-component value\n");
#line 50
    return (1);
  }
#line 53
  printf((char const   * __restrict  )"Creating threads\n");
#line 54
  imageThreads = createThreadData(thread_count);
#line 56
  printf((char const   * __restrict  )"Dividing image\n");
#line 57
  divide(imageThreads, thread_count, src, dst, (int const   )xsize, (int const   )ysize);
#line 58
  printf((char const   * __restrict  )"\n");
#line 60
  printf((char const   * __restrict  )"Setting arguments\n");
#line 61
  tmp___0 = malloc(sizeof(thresfilterdata ) * (unsigned long )thread_count);
#line 61
  thresdata = (thresfilterdata *)tmp___0;
#line 62
  i = 0;
#line 62
  while (i < thread_count) {
#line 63
    (thresdata + i)->xsize = xsize;
#line 64
    (thresdata + i)->ysize = ysize;
#line 65
    (thresdata + i)->src = src;
#line 66
    (thresdata + i)->dst = dst;
#line 67
    (thresdata + i)->thresholdsum = & thresholdsum;
#line 68
    (thresdata + i)->imageThreads = imageThreads;
#line 69
    (thresdata + i)->rank = i;
#line 70
    (thresdata + i)->thresholdsum_mutex = & thresholdsum_mutex;
#line 62
    i ++;
  }
#line 73
  clock_gettime(0, & stime___0);
#line 74
  printf((char const   * __restrict  )"Starting threads\n");
#line 75
  setThreadSyncCount(thread_count);
#line 76
  i = 0;
#line 76
  while (i < thread_count) {
#line 78
    (imageThreads + i)->argument = (void *)(thresdata + i);
#line 79
    (imageThreads + i)->thread = createThread((void *)(& thresfilterwrapper), (imageThreads + i)->argument);
#line 76
    i ++;
  }
#line 82
  printf((char const   * __restrict  )"Threads working on average value\n");
#line 83
  SynchronizationPoint();
#line 84
  printf((char const   * __restrict  )"Average value is %d\n", thresholdsum / (unsigned int )(xsize * ysize));
#line 85
  printf((char const   * __restrict  )"Threads working on threshold\n");
#line 86
  SynchronizationPoint();
#line 87
  printf((char const   * __restrict  )"Threads done\n");
#line 88
  clock_gettime(0, & etime);
#line 90
  printf((char const   * __restrict  )"Filtering took: %g secs\n", (double )(etime.tv_sec - stime___0.tv_sec) + 1e-9 * (double )(etime.tv_nsec - stime___0.tv_nsec));
#line 94
  printf((char const   * __restrict  )"Writing output file\n");
#line 96
  tmp___1 = write_ppm((char const   *)outputFilepath, xsize, ysize, (char *)src);
#line 96
  if (tmp___1 != 0) {
#line 97
    return (1);
  }
#line 100
  return (0);
}
}
