/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is true */

#line 213 "/usr/lib/gcc/x86_64-linux-gnu/4.7/include/stddef.h"
typedef unsigned long size_t;
#line 200 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef unsigned char u_int8_t;
#line 202 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef unsigned int u_int32_t;
#line 75 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
struct __pthread_internal_list {
   struct __pthread_internal_list *__prev ;
   struct __pthread_internal_list *__next ;
};
#line 75 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef struct __pthread_internal_list __pthread_list_t;
#line 90 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
struct __pthread_mutex_s {
   int __lock ;
   unsigned int __count ;
   int __owner ;
   unsigned int __nusers ;
   int __kind ;
   int __spins ;
   __pthread_list_t __list ;
};
#line 90 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
union __anonunion_pthread_mutex_t_14 {
   struct __pthread_mutex_s __data ;
   char __size[40] ;
   long __align ;
};
#line 90 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef union __anonunion_pthread_mutex_t_14 pthread_mutex_t;
#line 28 "util_types.h"
typedef u_int32_t status_t;
#line 28 "queue.h"
struct queue_ {
   void *head ;
   void *tail ;
   u_int32_t count ;
   u_int32_t limit ;
   pthread_mutex_t mutex ;
   char const   *owner ;
};
#line 28 "queue.h"
typedef struct queue_ queue_t;
#line 50 "queue.h"
struct queue_link_ {
   void *queue_next ;
   void *queue_prev ;
   queue_t *owner_queue ;
};
#line 50 "queue.h"
typedef struct queue_link_ queue_link_t;
#line 59 "queue.h"
struct queue_test_ {
   queue_link_t link ;
   u_int32_t addr1 ;
   u_int32_t addr2 ;
};
#line 59 "queue.h"
typedef struct queue_test_ queue_test_t;
#line 120 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
union __anonunion_pthread_mutexattr_t_15 {
   char __size[4] ;
   int __align ;
};
#line 120 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef union __anonunion_pthread_mutexattr_t_15 pthread_mutexattr_t;
#line 201 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef unsigned short u_int16_t;
#line 25 "itable.h"
struct itable_ {
   u_int16_t count ;
   u_int16_t length ;
   u_int32_t alloc ;
   void *itable_element[0] ;
};
#line 25 "itable.h"
typedef struct itable_ itable_t;
#line 1 "cil-yH62dHiz.o"
#pragma merger("0","/tmp/cil-6csJUFwG.i","-Wall,-Werror,-g")
#line 362 "/usr/include/stdio.h"
extern int printf(char const   * __restrict  __format  , ...) ;
#line 409 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) strerror)(int __errnum ) ;
#line 455
extern  __attribute__((__nothrow__)) void ( __attribute__((__nonnull__(1), __leaf__)) bzero)(void *__s ,
                                                                                             size_t __n ) ;
#line 465 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 482
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 542
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 76 "queue.h"
queue_t *queue_create(status_t *status , char const   *owner , size_t limit ) ;
#line 81
status_t queue_enqueue(queue_t *queue , queue_link_t *link ) ;
#line 85
void *queue_dequeue(queue_t *queue , status_t *status ) ;
#line 89
size_t queue_get_count(queue_t *queue ) ;
#line 93
void *queue_get_next(queue_t *queue , queue_link_t *curr , status_t *status ) ;
#line 103 "util_test.c"
static status_t queue_test(void) 
{ 
  queue_t *q ;
  queue_test_t *qt ;
  status_t status ;
  u_int8_t count ;
  void *tmp ;
  void *tmp___0 ;

  {
#line 111
  q = (queue_t *)((void *)0);
#line 112
  qt = (queue_test_t *)((void *)0);
#line 113
  status = (status_t )0;
#line 115
  q = queue_create(& status, "queue_test", (size_t )255);
#line 116
  if ((unsigned long )q == (unsigned long )((void *)0)) {
#line 118
    return (status);
  }
#line 121
  count = (u_int8_t )0;
#line 121
  while ((int )count < 255) {
#line 123
    tmp = malloc(sizeof(queue_test_t ));
#line 123
    qt = (queue_test_t *)tmp;
#line 124
    if ((unsigned long )qt == (unsigned long )((void *)0)) {
#line 126
      return ((status_t )12);
    }
#line 129
    bzero((void *)qt, sizeof(queue_test_t ));
#line 131
    qt->addr1 = (u_int32_t )qt;
#line 132
    qt->addr2 = (u_int32_t )count;
#line 134
    status = queue_enqueue(q, & qt->link);
#line 135
    if (status != 0U) {
#line 137
      return (status);
    }
#line 121
    count = (u_int8_t )((int )count + 1);
  }
#line 141
  count = (u_int8_t )0;
#line 141
  while ((int )count < 255) {
#line 143
    tmp___0 = queue_dequeue(q, & status);
#line 143
    qt = (queue_test_t *)tmp___0;
#line 144
    if ((unsigned long )qt == (unsigned long )((void *)0)) {
#line 146
      return (status);
    }
#line 149
    if (qt->addr2 != (u_int32_t )count) {
#line 151
      return ((status_t )2);
    } else {
#line 155
      free((void *)qt);
    }
#line 141
    count = (u_int8_t )((int )count + 1);
  }
#line 159
  return ((status_t )0);
}
}
#line 162 "util_test.c"
static status_t queue_walk_test(void) 
{ 
  queue_t *q ;
  queue_test_t *qt ;
  queue_test_t *next_qt ;
  status_t status ;
  u_int8_t count ;
  size_t q_count ;
  void *tmp ;
  void *tmp___0 ;

  {
#line 171
  q = (queue_t *)((void *)0);
#line 172
  qt = (queue_test_t *)((void *)0);
#line 173
  status = (status_t )0;
#line 175
  q = queue_create(& status, "queue_test", (size_t )255);
#line 176
  if ((unsigned long )q == (unsigned long )((void *)0)) {
#line 178
    return (status);
  }
#line 181
  count = (u_int8_t )0;
#line 181
  while ((int )count < 33) {
#line 183
    tmp = malloc(sizeof(queue_test_t ));
#line 183
    qt = (queue_test_t *)tmp;
#line 184
    if ((unsigned long )qt == (unsigned long )((void *)0)) {
#line 186
      return ((status_t )12);
    }
#line 189
    bzero((void *)qt, sizeof(queue_test_t ));
#line 191
    qt->addr1 = (u_int32_t )qt;
#line 192
    qt->addr2 = (u_int32_t )count;
#line 194
    status = queue_enqueue(q, & qt->link);
#line 195
    if (status != 0U) {
#line 197
      return (status);
    }
#line 181
    count = (u_int8_t )((int )count + 1);
  }
#line 201
  qt = (queue_test_t *)((void *)0);
#line 202
  q_count = queue_get_count(q);
#line 203
  count = (u_int8_t )0;
#line 203
  while ((size_t )count < q_count * 2UL) {
#line 205
    tmp___0 = queue_get_next(q, & qt->link, & status);
#line 205
    next_qt = (queue_test_t *)tmp___0;
#line 206
    if ((unsigned long )next_qt == (unsigned long )((void *)0)) {
#line 207
      next_qt = qt;
    }
#line 210
    if ((unsigned long )qt != (unsigned long )((void *)0)) {
#line 211
      printf((char const   * __restrict  )"curr[0x%x][%d] next[0x%x][%d]\n", qt->addr1,
             qt->addr2, next_qt->addr1, next_qt->addr2);
    }
#line 215
    if (status == 16U) {
#line 220
      printf((char const   * __restrict  )"End of List, Starting over from the top\n");
#line 221
      qt = (queue_test_t *)((void *)0);
#line 222
      goto __Cont;
    }
#line 225
    qt = next_qt;
    __Cont: /* CIL Label */ 
#line 203
    count = (u_int8_t )((int )count + 1);
  }
#line 228
  return ((status_t )0);
}
}
#line 231 "util_test.c"
int main(void) 
{ 
  status_t status ;
  char *tmp ;
  char *tmp___0 ;

  {
#line 239
  status = queue_test();
#line 240
  tmp = strerror((int )status);
#line 240
  printf((char const   * __restrict  )"Queue Test: %s\n", tmp);
#line 242
  status = queue_walk_test();
#line 243
  tmp___0 = strerror((int )status);
#line 243
  printf((char const   * __restrict  )"Queue Test: %s\n", tmp___0);
#line 245
  exit(0);
}
}
#line 1 "cil-MfuHeZRQ.o"
#pragma merger("0","/tmp/cil-pANG3OX5.i","-Wall,-Werror,-g")
#line 70 "/usr/include/assert.h"
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) __assert_fail)(char const   *__assertion ,
                                                                                                   char const   *__file ,
                                                                                                   unsigned int __line ,
                                                                                                   char const   *__function ) ;
#line 740 "/usr/include/pthread.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) pthread_mutex_init)(pthread_mutex_t *__mutex ,
                                                                                                         pthread_mutexattr_t const   *__mutexattr ) ;
#line 753
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) pthread_mutex_lock)(pthread_mutex_t *__mutex ) ;
#line 764
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) pthread_mutex_unlock)(pthread_mutex_t *__mutex ) ;
#line 77 "queue.h"
queue_t *queue_create_ts(status_t *status , char const   *owner , size_t limit ) ;
#line 79
status_t queue_destroy(queue_t *queue ) ;
#line 80
status_t queue_destroy_ts(queue_t *queue ) ;
#line 82
status_t queue_enqueue_ts(queue_t *queue , queue_link_t *link ) ;
#line 83
status_t queue_requeue(queue_t *queue , queue_link_t *link ) ;
#line 84
status_t queue_requeue_ts(queue_t *queue , queue_link_t *link ) ;
#line 86
void *queue_dequeue_ts(queue_t *queue , status_t *status ) ;
#line 87
void *queue_peek(queue_t *queue , status_t *status ) ;
#line 88
void *queue_peek_ts(queue_t *queue , status_t *status ) ;
#line 90
size_t queue_get_count_ts(queue_t *queue ) ;
#line 91
status_t queue_set_limit(queue_t *queue , u_int32_t limit ) ;
#line 92
status_t queue_check(queue_link_t *link ) ;
#line 37 "queue.c"
queue_t *queue_create(status_t *status , char const   *owner , size_t limit ) 
{ 
  queue_t *tq ;
  void *tmp ;
  void *tmp___0 ;

  {
#line 42
  *status = (status_t )0;
#line 44
  tmp = malloc(sizeof(queue_t ));
#line 44
  tq = (queue_t *)tmp;
#line 46
  if ((unsigned long )tq == (unsigned long )((void *)0)) {
#line 47
    *status = (status_t )12;
#line 48
    return ((queue_t *)((void *)0));
  }
#line 51
  tmp___0 = (void *)0;
#line 51
  tq->tail = tmp___0;
#line 51
  tq->head = tmp___0;
#line 52
  tq->count = (u_int32_t )0;
#line 53
  tq->owner = owner;
#line 54
  tq->limit = (u_int32_t )limit;
#line 56
  return (tq);
}
}
#line 68 "queue.c"
queue_t *queue_create_ts(status_t *status , char const   *owner , size_t limit ) 
{ 
  queue_t *queue ;
  status_t local_status ;
  void *tmp ;
  void *tmp___0 ;
  int tmp___1 ;

  {
#line 74
  local_status = (status_t )0;
#line 74
  *status = local_status;
#line 76
  tmp = malloc(sizeof(queue_t ));
#line 76
  queue = (queue_t *)tmp;
#line 78
  if ((unsigned long )queue == (unsigned long )((void *)0)) {
#line 79
    *status = (status_t )12;
#line 80
    return ((queue_t *)((void *)0));
  }
#line 83
  tmp___0 = (void *)0;
#line 83
  queue->tail = tmp___0;
#line 83
  queue->head = tmp___0;
#line 84
  queue->count = (u_int32_t )0;
#line 85
  queue->owner = owner;
#line 86
  queue->limit = (u_int32_t )limit;
#line 91
  tmp___1 = pthread_mutex_init(& queue->mutex, (pthread_mutexattr_t const   *)((void *)0));
#line 91
  local_status = (status_t )tmp___1;
#line 92
  if (local_status != 0U) {
#line 94
    free((void *)queue);
#line 95
    queue = (queue_t *)((void *)0);
  }
#line 98
  *status = local_status;
#line 99
  return (queue);
}
}
#line 105 "queue.c"
status_t queue_destroy(queue_t *queue ) 
{ 


  {
#line 108
  if ((unsigned long )queue == (unsigned long )((void *)0)) {
#line 109
    return ((status_t )2);
  }
#line 111
  if (queue->head) {
#line 112
    return ((status_t )16);
  } else
#line 111
  if (queue->tail) {
#line 112
    return ((status_t )16);
  } else
#line 111
  if (queue->count) {
#line 112
    return ((status_t )16);
  } else {
#line 114
    free((void *)queue);
#line 115
    return ((status_t )0);
  }
}
}
#line 123 "queue.c"
status_t queue_destroy_ts(queue_t *queue ) 
{ 
  status_t status ;
  int tmp ;

  {
#line 128
  if ((unsigned long )queue == (unsigned long )((void *)0)) {
#line 129
    return ((status_t )2);
  }
#line 131
  tmp = pthread_mutex_lock(& queue->mutex);
#line 131
  status = (status_t )tmp;
#line 133
  if (queue->head) {
#line 134
    pthread_mutex_unlock(& queue->mutex);
#line 135
    return ((status_t )16);
  } else
#line 133
  if (queue->tail) {
#line 134
    pthread_mutex_unlock(& queue->mutex);
#line 135
    return ((status_t )16);
  } else
#line 133
  if (queue->count) {
#line 134
    pthread_mutex_unlock(& queue->mutex);
#line 135
    return ((status_t )16);
  } else {
#line 137
    pthread_mutex_unlock(& queue->mutex);
#line 138
    free((void *)queue);
#line 139
    return ((status_t )0);
  }
}
}
#line 146 "queue.c"
status_t queue_set_limit(queue_t *queue , u_int32_t limit ) 
{ 


  {
#line 150
  queue->limit = limit;
#line 152
  return ((status_t )0);
}
}
#line 158 "queue.c"
status_t queue_set_limit_ts(queue_t *queue , u_int32_t limit ) 
{ 
  status_t status ;
  int tmp ;

  {
#line 163
  tmp = pthread_mutex_lock(& queue->mutex);
#line 163
  status = (status_t )tmp;
#line 164
  if (status != 0U) {
#line 165
    return (status);
  }
#line 168
  queue->limit = limit;
#line 170
  pthread_mutex_unlock(& queue->mutex);
#line 172
  return ((status_t )0);
}
}
#line 181 "queue.c"
status_t queue_enqueue(queue_t *queue , queue_link_t *link ) 
{ 
  queue_link_t *cur_head ;
  void *tmp ;
  void *tmp___0 ;

  {
#line 186
  if ((unsigned long )queue == (unsigned long )((void *)0)) {
#line 187
    return ((status_t )22);
  }
#line 188
  if ((unsigned long )link == (unsigned long )((void *)0)) {
#line 189
    return ((status_t )22);
  }
#line 191
  if (queue->limit > 0U) {
#line 192
    if (queue->count >= queue->limit) {
#line 193
      return ((status_t )16);
    }
  }
#line 196
  if (! ((unsigned long )link->queue_next == (unsigned long )((void *)0))) {
#line 196
    __assert_fail("link->queue_next == ((void *)0)", "queue.c", 196U, "queue_enqueue");
  }
#line 197
  if (! ((unsigned long )link->queue_prev == (unsigned long )((void *)0))) {
#line 197
    __assert_fail("link->queue_prev == ((void *)0)", "queue.c", 197U, "queue_enqueue");
  }
#line 199
  link->owner_queue = queue;
#line 201
  if ((unsigned long )queue->head == (unsigned long )((void *)0)) {
#line 202
    tmp = (void *)link;
#line 202
    queue->tail = tmp;
#line 202
    queue->head = tmp;
#line 203
    tmp___0 = (void *)0;
#line 203
    link->queue_prev = tmp___0;
#line 203
    link->queue_next = tmp___0;
  } else {
#line 205
    cur_head = (queue_link_t *)queue->head;
#line 206
    cur_head->queue_prev = (void *)link;
#line 207
    link->queue_next = (void *)cur_head;
#line 208
    link->queue_prev = (void *)0;
#line 209
    queue->head = (void *)link;
  }
#line 212
  (queue->count) ++;
#line 214
  return ((status_t )0);
}
}
#line 225 "queue.c"
status_t queue_enqueue_ts(queue_t *queue , queue_link_t *link ) 
{ 
  status_t status ;
  int tmp ;

  {
#line 230
  tmp = pthread_mutex_lock(& queue->mutex);
#line 230
  status = (status_t )tmp;
#line 231
  if (status != 0U) {
#line 232
    return (status);
  }
#line 235
  status = queue_enqueue(queue, link);
#line 237
  pthread_mutex_unlock(& queue->mutex);
#line 239
  return (status);
}
}
#line 247 "queue.c"
status_t queue_requeue(queue_t *queue , queue_link_t *link ) 
{ 
  queue_link_t *cur_tail ;
  void *tmp ;
  void *tmp___0 ;

  {
#line 252
  if ((unsigned long )queue == (unsigned long )((void *)0)) {
#line 253
    return ((status_t )22);
  }
#line 254
  if ((unsigned long )link == (unsigned long )((void *)0)) {
#line 255
    return ((status_t )22);
  }
#line 257
  if ((unsigned long )queue->head == (unsigned long )((void *)0)) {
#line 258
    tmp = (void *)link;
#line 258
    queue->tail = tmp;
#line 258
    queue->head = tmp;
#line 259
    tmp___0 = (void *)0;
#line 259
    link->queue_prev = tmp___0;
#line 259
    link->queue_next = tmp___0;
  } else {
#line 261
    cur_tail = (queue_link_t *)queue->tail;
#line 262
    cur_tail->queue_next = (void *)link;
#line 263
    link->queue_prev = (void *)cur_tail;
#line 264
    link->queue_next = (void *)0;
#line 265
    queue->tail = (void *)link;
  }
#line 268
  (queue->count) ++;
#line 270
  return ((status_t )0);
}
}
#line 280 "queue.c"
status_t queue_requeue_ts(queue_t *queue , queue_link_t *link ) 
{ 
  status_t status ;
  int tmp ;

  {
#line 285
  tmp = pthread_mutex_lock(& queue->mutex);
#line 285
  status = (status_t )tmp;
#line 286
  if (status != 0U) {
#line 287
    return (status);
  }
#line 290
  status = queue_requeue(queue, link);
#line 292
  pthread_mutex_unlock(& queue->mutex);
#line 294
  return (status);
}
}
#line 302 "queue.c"
void *queue_dequeue(queue_t *queue , status_t *status ) 
{ 
  queue_link_t *cur_tail ;
  queue_link_t *new_tail ;
  void *tmp ;

  {
#line 308
  if ((unsigned long )queue == (unsigned long )((void *)0)) {
#line 309
    *status = (status_t )22;
#line 310
    return ((void *)0);
  }
#line 312
  if ((unsigned long )queue->tail == (unsigned long )((void *)0)) {
#line 313
    *status = (status_t )61;
#line 314
    return ((void *)0);
  }
#line 317
  cur_tail = (queue_link_t *)queue->tail;
#line 319
  if ((unsigned long )queue->head == (unsigned long )queue->tail) {
#line 320
    tmp = (void *)0;
#line 320
    queue->tail = tmp;
#line 320
    queue->head = tmp;
  } else {
#line 322
    new_tail = (queue_link_t *)cur_tail->queue_prev;
#line 322
    queue->tail = (void *)new_tail;
#line 323
    new_tail->queue_next = (void *)0;
  }
#line 326
  cur_tail->queue_next = (void *)0;
#line 327
  cur_tail->queue_prev = (void *)0;
#line 328
  cur_tail->owner_queue = (queue_t *)((void *)0);
#line 330
  (queue->count) --;
#line 332
  *status = (status_t )0;
#line 334
  return ((void *)cur_tail);
}
}
#line 344 "queue.c"
void *queue_dequeue_ts(queue_t *queue , status_t *status ) 
{ 
  status_t local_status ;
  queue_link_t *cur_tail ;
  int tmp ;
  void *tmp___0 ;

  {
#line 351
  tmp = pthread_mutex_lock(& queue->mutex);
#line 351
  local_status = (status_t )tmp;
#line 352
  if (local_status != 0U) {
#line 353
    *status = local_status;
#line 354
    return ((void *)0);
  }
#line 357
  tmp___0 = queue_dequeue(queue, status);
#line 357
  cur_tail = (queue_link_t *)tmp___0;
#line 359
  pthread_mutex_unlock(& queue->mutex);
#line 361
  return ((void *)cur_tail);
}
}
#line 367 "queue.c"
void *queue_peek(queue_t *queue , status_t *status ) 
{ 


  {
#line 370
  return (queue->tail);
}
}
#line 377 "queue.c"
void *queue_peek_ts(queue_t *queue , status_t *status ) 
{ 
  status_t local_status ;
  void *tail ;
  int tmp ;

  {
#line 383
  tmp = pthread_mutex_lock(& queue->mutex);
#line 383
  local_status = (status_t )tmp;
#line 384
  if (local_status != 0U) {
#line 385
    *status = local_status;
#line 386
    return ((void *)0);
  }
#line 389
  tail = queue_peek(queue, status);
#line 391
  pthread_mutex_unlock(& queue->mutex);
#line 393
  return (tail);
}
}
#line 400 "queue.c"
void *queue_get_next(queue_t *queue , queue_link_t *curr , status_t *status ) 
{ 
  queue_link_t *next ;

  {
#line 405
  *status = (status_t )0;
#line 407
  if ((unsigned long )queue == (unsigned long )((void *)0)) {
#line 408
    *status = (status_t )22;
#line 409
    return ((void *)0);
  }
#line 411
  if ((unsigned long )queue->tail == (unsigned long )((void *)0)) {
#line 412
    *status = (status_t )61;
#line 413
    return ((void *)0);
  }
#line 416
  if ((unsigned long )curr == (unsigned long )((void *)0)) {
#line 418
    return (queue->tail);
  }
#line 421
  if ((unsigned long )curr == (unsigned long )queue->head) {
#line 422
    *status = (status_t )16;
#line 423
    return ((void *)0);
  }
#line 426
  next = (queue_link_t *)curr->queue_prev;
#line 427
  return ((void *)next);
}
}
#line 433 "queue.c"
size_t queue_get_count(queue_t *queue ) 
{ 


  {
#line 436
  return ((size_t )queue->count);
}
}
#line 443 "queue.c"
size_t queue_get_count_ts(queue_t *queue ) 
{ 
  size_t size ;
  status_t status ;
  int tmp ;

  {
#line 449
  tmp = pthread_mutex_lock(& queue->mutex);
#line 449
  status = (status_t )tmp;
#line 450
  if (status != 0U) {
#line 451
    return ((size_t )0);
  }
#line 454
  size = queue_get_count(queue);
#line 456
  pthread_mutex_unlock(& queue->mutex);
#line 458
  return (size);
}
}
#line 464 "queue.c"
status_t queue_check(queue_link_t *link ) 
{ 


  {
#line 467
  if ((unsigned long )link->queue_next != (unsigned long )((void *)0)) {
#line 469
    return ((status_t )16);
  }
#line 472
  if ((unsigned long )link->queue_prev != (unsigned long )((void *)0)) {
#line 474
    return ((status_t )16);
  }
#line 477
  return ((status_t )0);
}
}
#line 1 "cil-s6wtdcj9.o"
#pragma merger("0","/tmp/cil-exopdsl_.i","-Wall,-Werror,-g")
#line 35 "itable.h"
itable_t *itable_create(itable_t *client_itable , size_t length ) ;
#line 36
status_t itable_add(itable_t *itable , void *element , u_int16_t index___0 ) ;
#line 37
void *itable_delete(itable_t *itable , u_int16_t index___0 , status_t *status ) ;
#line 40
status_t itable_destroy(itable_t *itable ) ;
#line 41
void *itable_walk(itable_t *itable , u_int16_t index_base , u_int16_t *index_current ,
                  status_t *status ) ;
#line 66
void *itable_get_next(itable_t *itable , u_int16_t *index___0 , status_t *status ) ;
#line 29 "itable.c"
static u_int32_t itable_debug  =    (u_int32_t )0;
#line 35 "itable.c"
itable_t *itable_create(itable_t *client_itable , size_t length ) 
{ 
  itable_t *itable ;
  u_int8_t *mem ;
  size_t size ;
  void *tmp ;

  {
#line 42
  if (length == 0UL) {
#line 43
    size = (sizeof(itable_t ) + sizeof(void *)) + 65535UL * sizeof(void *);
  } else {
#line 45
    size = (sizeof(itable_t ) + sizeof(void *)) + sizeof(void *) * length;
  }
#line 52
  if ((unsigned long )client_itable == (unsigned long )((void *)0)) {
#line 53
    tmp = malloc(size);
#line 53
    mem = (u_int8_t *)tmp;
#line 54
    bzero((void *)mem, size);
#line 55
    itable = (itable_t *)mem;
#line 56
    itable->alloc = (u_int32_t )1;
  } else {
#line 58
    itable = client_itable;
  }
#line 60
  if ((unsigned long )itable == (unsigned long )((void *)0)) {
#line 61
    return ((itable_t *)((void *)0));
  }
#line 63
  itable->count = (u_int16_t )0;
#line 65
  if (length == 0UL) {
#line 66
    itable->length = (u_int16_t )65535;
  } else {
#line 68
    itable->length = (u_int16_t )length;
  }
#line 71
  return (itable);
}
}
#line 77 "itable.c"
status_t itable_add(itable_t *itable , void *element , u_int16_t index___0 ) 
{ 


  {
#line 80
  if ((unsigned long )itable == (unsigned long )((void *)0)) {
#line 81
    return ((status_t )2);
  }
#line 83
  if ((int )index___0 > (int )itable->length) {
#line 84
    return ((status_t )22);
  }
#line 86
  if ((unsigned long )itable->itable_element[index___0] != (unsigned long )((void *)0)) {
#line 87
    return ((status_t )17);
  }
#line 89
  itable->itable_element[index___0] = element;
#line 91
  itable->count = (u_int16_t )((int )itable->count + 1);
#line 93
  return ((status_t )0);
}
}
#line 99 "itable.c"
void *itable_delete(itable_t *itable , u_int16_t index___0 , status_t *status ) 
{ 
  void *element ;

  {
#line 104
  *status = (status_t )0;
#line 106
  if ((unsigned long )itable == (unsigned long )((void *)0)) {
#line 107
    *status = (status_t )2;
  }
#line 108
  if ((int )index___0 > (int )itable->length) {
#line 109
    *status = (status_t )22;
  }
#line 110
  if ((unsigned long )itable->itable_element[index___0] == (unsigned long )((void *)0)) {
#line 111
    *status = (status_t )2;
  }
#line 113
  if (*status != 0U) {
#line 114
    if (itable_debug) {
#line 115
      printf((char const   * __restrict  )"status %d\n", *status);
    }
#line 117
    return ((void *)0);
  }
#line 120
  element = itable->itable_element[index___0];
#line 121
  itable->itable_element[index___0] = (void *)0;
#line 122
  itable->count = (u_int16_t )((int )itable->count - 1);
#line 123
  if (itable_debug) {
#line 124
    printf((char const   * __restrict  )"element[0x%x]\n", (u_int32_t )element);
  }
#line 126
  return (element);
}
}
#line 132 "itable.c"
status_t itable_destroy(itable_t *itable ) 
{ 


  {
#line 135
  if ((unsigned long )itable == (unsigned long )((void *)0)) {
#line 136
    return ((status_t )2);
  }
#line 138
  if (itable->count) {
#line 139
    if (itable_debug) {
#line 140
      printf((char const   * __restrict  )"Itable Mgr: Attempt to destory non-empty itable [0x%x]\n",
             (u_int32_t )itable);
    }
#line 143
    return ((status_t )16);
  }
#line 145
  itable->count = (u_int16_t )0;
#line 146
  if (itable->alloc == 1U) {
#line 147
    free((void *)itable);
  }
#line 149
  return ((status_t )0);
}
}
#line 155 "itable.c"
void *itable_walk(itable_t *itable , u_int16_t index_base , u_int16_t *index_current ,
                  status_t *status ) 
{ 
  void *element ;
  u_int16_t ic ;
  u_int16_t in ;

  {
#line 163
  status = (status_t *)0;
#line 164
  ic = *index_current;
#line 166
  if ((unsigned long )itable == (unsigned long )((void *)0)) {
#line 167
    *status = (status_t )2;
#line 168
    return ((void *)0);
  }
#line 170
  if ((int )index_base > (int )itable->length) {
#line 171
    *status = (status_t )22;
#line 172
    return ((void *)0);
  }
#line 174
  if ((unsigned long )index_current == (unsigned long )((void *)0)) {
#line 175
    *status = (status_t )22;
#line 176
    return ((void *)0);
  }
#line 179
  if ((int )*index_current < (int )index_base) {
#line 180
    *index_current = index_base;
  }
#line 181
  if ((int )*index_current == (int )itable->length) {
#line 182
    *status = (status_t )28;
#line 183
    return ((void *)0);
  }
#line 186
  element = itable->itable_element[*index_current];
#line 187
  *index_current = (u_int16_t )((int )*index_current + 1);
#line 188
  in = *index_current;
#line 190
  return (element);
}
}
#line 196 "itable.c"
void *itable_get_next(itable_t *itable , u_int16_t *index___0 , status_t *status ) 
{ 
  void *element ;

  {
#line 203
  *status = (status_t )0;
#line 205
  if ((unsigned long )itable == (unsigned long )((void *)0)) {
#line 206
    *status = (status_t )2;
#line 207
    return ((void *)0);
  }
#line 210
  if ((unsigned long )index___0 == (unsigned long )((void *)0)) {
#line 211
    *status = (status_t )22;
#line 212
    return ((void *)0);
  }
#line 215
  if ((int )*index___0 >= (int )itable->length) {
#line 216
    *status = (status_t )28;
#line 217
    return ((void *)0);
  }
#line 220
  if ((int )itable->count == 0) {
#line 221
    *status = (status_t )2;
#line 222
    return ((void *)0);
  }
#line 225
  element = itable->itable_element[*index___0];
#line 226
  *index___0 = (u_int16_t )((int )*index___0 + 1);
#line 227
  while ((unsigned long )element == (unsigned long )((void *)0)) {
#line 228
    if ((int )*index___0 >= (int )itable->length) {
#line 229
      element = (void *)0;
#line 230
      *status = (status_t )28;
#line 231
      break;
    }
#line 233
    element = itable->itable_element[*index___0];
#line 234
    *index___0 = (u_int16_t )((int )*index___0 + 1);
  }
#line 237
  return (element);
}
}
