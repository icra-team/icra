/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is true */

#line 213 "/usr/lib/gcc/x86_64-linux-gnu/4.7/include/stddef.h"
typedef unsigned long size_t;
#line 181 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __ssize_t;
#line 198 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __socklen_t;
#line 102 "/usr/include/stdio.h"
typedef __ssize_t ssize_t;
#line 60 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef unsigned long pthread_t;
#line 63 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
union pthread_attr_t {
   char __size[56] ;
   long __align ;
};
#line 69 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef union pthread_attr_t pthread_attr_t;
#line 75 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
struct __pthread_internal_list {
   struct __pthread_internal_list *__prev ;
   struct __pthread_internal_list *__next ;
};
#line 75 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef struct __pthread_internal_list __pthread_list_t;
#line 90 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
struct __pthread_mutex_s {
   int __lock ;
   unsigned int __count ;
   int __owner ;
   unsigned int __nusers ;
   int __kind ;
   int __spins ;
   __pthread_list_t __list ;
};
#line 90 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
union __anonunion_pthread_mutex_t_14 {
   struct __pthread_mutex_s __data ;
   char __size[40] ;
   long __align ;
};
#line 90 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef union __anonunion_pthread_mutex_t_14 pthread_mutex_t;
#line 120 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
union __anonunion_pthread_mutexattr_t_15 {
   char __size[4] ;
   int __align ;
};
#line 120 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef union __anonunion_pthread_mutexattr_t_15 pthread_mutexattr_t;
#line 129 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
struct __anonstruct___data_17 {
   int __lock ;
   unsigned int __futex ;
   unsigned long long __total_seq ;
   unsigned long long __wakeup_seq ;
   unsigned long long __woken_seq ;
   void *__mutex ;
   unsigned int __nwaiters ;
   unsigned int __broadcast_seq ;
};
#line 129 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
union __anonunion_pthread_cond_t_16 {
   struct __anonstruct___data_17 __data ;
   char __size[48] ;
   long long __align ;
};
#line 129 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef union __anonunion_pthread_cond_t_16 pthread_cond_t;
#line 146 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
union __anonunion_pthread_condattr_t_18 {
   char __size[4] ;
   int __align ;
};
#line 146 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef union __anonunion_pthread_condattr_t_18 pthread_condattr_t;
#line 33 "/usr/include/x86_64-linux-gnu/bits/socket.h"
typedef __socklen_t socklen_t;
#line 28 "/usr/include/x86_64-linux-gnu/bits/sockaddr.h"
typedef unsigned short sa_family_t;
#line 147 "/usr/include/x86_64-linux-gnu/bits/socket.h"
struct sockaddr {
   sa_family_t sa_family ;
   char sa_data[14] ;
};
#line 49 "/usr/include/stdint.h"
typedef unsigned short uint16_t;
#line 51 "/usr/include/stdint.h"
typedef unsigned int uint32_t;
#line 96 "/usr/include/netinet/in.h"
typedef uint16_t in_port_t;
#line 140 "/usr/include/netinet/in.h"
typedef uint32_t in_addr_t;
#line 141 "/usr/include/netinet/in.h"
struct in_addr {
   in_addr_t s_addr ;
};
#line 224 "/usr/include/netinet/in.h"
struct sockaddr_in {
   sa_family_t sin_family ;
   in_port_t sin_port ;
   struct in_addr sin_addr ;
   unsigned char sin_zero[((sizeof(struct sockaddr ) - sizeof(unsigned short )) - sizeof(in_port_t )) - sizeof(struct in_addr )] ;
};
#line 7 "queue.h"
struct queue_node_s {
   int data ;
   struct queue_node_s *next_node ;
};
#line 12 "queue.h"
struct queue_int_s {
   struct queue_node_s *head ;
   struct queue_node_s *tail ;
};
#line 22 "m_http.h"
struct http_request_s {
   char *method ;
   char *path ;
   char *version ;
   char *request_header[19] ;
};
#line 30 "m_http.h"
struct http_response_s {
   char *version ;
   int status_code ;
   char *reason_phrase ;
   char *response_header[9] ;
   char *message_body ;
};
#line 140 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 141 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 155 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 161 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 246 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
/* compiler builtin: 
   void *__builtin_alloca(unsigned long  ) ;  */
#line 1 "server.o"
#pragma merger("0","/tmp/cil-oyvDRFDP.i","")
#line 362 "/usr/include/stdio.h"
extern int printf(char const   * __restrict  __format  , ...) ;
#line 364
extern  __attribute__((__nothrow__)) int sprintf(char * __restrict  __s , char const   * __restrict  __format 
                                                 , ...) ;
#line 147 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) atoi)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 482
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 62 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1), __leaf__)) memset)(void *__s ,
                                                                                               int __c ,
                                                                                               size_t __n ) ;
#line 395
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 532
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcasecmp)(char const   *__s1 ,
                                                                                                   char const   *__s2 )  __attribute__((__pure__)) ;
#line 114 "/usr/include/x86_64-linux-gnu/sys/socket.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) socket)(int __domain ,
                                                                             int __type ,
                                                                             int __protocol ) ;
#line 124
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) bind)(int __fd ,
                                                                           struct sockaddr  const  *__addr ,
                                                                           socklen_t __len ) ;
#line 150
extern ssize_t send(int __fd , void const   *__buf , size_t __n , int __flags ) ;
#line 157
extern ssize_t recv(int __fd , void *__buf , size_t __n , int __flags ) ;
#line 234
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) listen)(int __fd ,
                                                                             int __n ) ;
#line 244
extern int accept(int __fd , struct sockaddr * __restrict  __addr , socklen_t * __restrict  __addr_len ) ;
#line 367 "/usr/include/netinet/in.h"
extern  __attribute__((__nothrow__)) uint32_t ( __attribute__((__leaf__)) htonl)(uint32_t __hostlong )  __attribute__((__const__)) ;
#line 369
extern  __attribute__((__nothrow__)) uint16_t ( __attribute__((__leaf__)) htons)(uint16_t __hostshort )  __attribute__((__const__)) ;
#line 232 "/usr/include/pthread.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,3))) pthread_create)(pthread_t * __restrict  __newthread ,
                                                                                             pthread_attr_t const   * __restrict  __attr ,
                                                                                             void *(*__start_routine)(void * ) ,
                                                                                             void * __restrict  __arg ) ;
#line 740
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) pthread_mutex_init)(pthread_mutex_t *__mutex ,
                                                                                                         pthread_mutexattr_t const   *__mutexattr ) ;
#line 753
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) pthread_mutex_lock)(pthread_mutex_t *__mutex ) ;
#line 764
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) pthread_mutex_unlock)(pthread_mutex_t *__mutex ) ;
#line 959
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) pthread_cond_init)(pthread_cond_t * __restrict  __cond ,
                                                                                                        pthread_condattr_t const   * __restrict  __cond_attr ) ;
#line 972
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) pthread_cond_broadcast)(pthread_cond_t *__cond ) ;
#line 980
extern int ( __attribute__((__nonnull__(1,2))) pthread_cond_wait)(pthread_cond_t * __restrict  __cond ,
                                                                  pthread_mutex_t * __restrict  __mutex ) ;
#line 18 "queue.h"
struct queue_int_s *create_queue(void) ;
#line 19
int enqueue(struct queue_int_s *queue , int data ) ;
#line 20
int dequeue(struct queue_int_s *queue , int *data ) ;
#line 22
int is_empty_queue(struct queue_int_s *queue ) ;
#line 7 "helperlib.h"
void print_user_error(char *message , char *detail ) ;
#line 8
void print_system_error(char *message ) ;
#line 17
int count_occurence(char *str , char character ) ;
#line 23
char *copy_str_dynamic(char *originalStr ) ;
#line 40 "m_http.h"
struct http_request_s *create_request_struct(void) ;
#line 41
struct http_response_s *create_response_struct(void) ;
#line 43
int parse_http_request(struct http_request_s *request_obj , char *request , struct http_response_s *response_obj ) ;
#line 45
int exec_http_request(struct http_request_s *request_obj , struct http_response_s *response_obj ) ;
#line 47
void delete_request(struct http_request_s **request_obj ) ;
#line 48
void delete_response(struct http_response_s **response_obj ) ;
#line 50
void set_status_code_error(struct http_response_s *response_obj , int status_code ,
                           char *reason_phrase , char *error_message ) ;
#line 52
char *get_response_text(struct http_response_s *response_obj ) ;
#line 14 "server.c"
static int const   DEFAULT_NUM_WORKER  =    (int const   )10;
#line 15 "server.c"
static int const   MAX_WORKER  =    (int const   )5000;
#line 16 "server.c"
static int const   MAX_WAIT  =    (int const   )5;
#line 17 "server.c"
static int const   MAX_LEN_REQUEST  =    (int const   )800;
#line 20 "server.c"
static int const   MAX_NUM_SLASH  =    (int const   )2;
#line 21 "server.c"
static char SUPPORT_HTTP[9]  = 
#line 21
  {      (char )'H',      (char )'T',      (char )'T',      (char )'P', 
        (char )'/',      (char )'1',      (char )'.',      (char )'1', 
        (char )'\000'};
#line 24 "server.c"
struct queue_int_s *clientQueue  ;
#line 27 "server.c"
pthread_mutex_t queue_mutex  ;
#line 28 "server.c"
pthread_cond_t queue_has_client  ;
#line 31
void create_worker(pthread_t *workerArr , int *threadId_arr , int numWorker ) ;
#line 32
void *handle_client_request(void *workerId ) ;
#line 33
char *read_request(int clientSocket ) ;
#line 35 "server.c"
int main(int argc , char **argv ) 
{ 
  int bossSocket ;
  int numWorker ;
  int clientSocket ;
  int notOverload ;
  int flagSignal ;
  struct sockaddr_in serverAddr ;
  struct sockaddr_in clientAddr ;
  socklen_t clientLen ;
  in_port_t serverPort ;
  pthread_t *workerArr ;
  unsigned long __lengthofworkerArr ;
  void *tmp ;
  int *threadId_arr ;
  unsigned long __lengthofthreadId_arr ;
  void *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 41
  __lengthofworkerArr = (unsigned long )MAX_WORKER;
#line 41
  tmp = __builtin_alloca(sizeof(*workerArr) * __lengthofworkerArr);
#line 41
  workerArr = (pthread_t *)tmp;
#line 42
  __lengthofthreadId_arr = (unsigned long )MAX_WORKER;
#line 42
  tmp___0 = __builtin_alloca(sizeof(*threadId_arr) * __lengthofthreadId_arr);
#line 42
  threadId_arr = (int *)tmp___0;
#line 44
  if (argc < 2) {
#line 45
    print_user_error((char *)"In-line arguments", (char *)"You must specify the port number");
  }
#line 46
  tmp___1 = atoi((char const   *)*(argv + 1));
#line 46
  serverPort = (in_port_t )tmp___1;
#line 49
  bossSocket = socket(2, 1, 6);
#line 50
  if (bossSocket < 0) {
#line 51
    print_system_error((char *)"socket() fails");
  }
#line 54
  memset((void *)(& serverAddr), 0, sizeof(struct sockaddr_in ));
#line 55
  serverAddr.sin_family = (sa_family_t )2;
#line 56
  serverAddr.sin_addr.s_addr = htonl((in_addr_t )0);
#line 57
  serverAddr.sin_port = htons(serverPort);
#line 59
  tmp___2 = bind(bossSocket, (struct sockaddr  const  *)((struct sockaddr *)(& serverAddr)),
                 (socklen_t )sizeof(serverAddr));
#line 59
  if (tmp___2 < 0) {
#line 60
    print_system_error((char *)"bind() fails");
  }
#line 63
  clientQueue = create_queue();
#line 64
  pthread_mutex_init(& queue_mutex, (pthread_mutexattr_t const   *)((void *)0));
#line 65
  pthread_cond_init((pthread_cond_t * __restrict  )(& queue_has_client), (pthread_condattr_t const   * __restrict  )((void *)0));
#line 68
  if (argc < 3) {
#line 69
    numWorker = (int )DEFAULT_NUM_WORKER;
  } else {
#line 72
    numWorker = atoi((char const   *)*(argv + 2));
#line 73
    if (numWorker > (int )MAX_WORKER) {
#line 74
      numWorker = (int )MAX_WORKER;
    }
  }
#line 77
  printf((char const   * __restrict  )"Hi\n");
#line 78
  create_worker(workerArr, threadId_arr, numWorker);
#line 79
  printf((char const   * __restrict  )"Hi there!\n");
#line 82
  tmp___3 = listen(bossSocket, (int )MAX_WAIT);
#line 82
  if (tmp___3 < 0) {
#line 83
    print_system_error((char *)"listen() fails");
  }
#line 86
  while (1) {
#line 89
    clientLen = (socklen_t )sizeof(struct sockaddr_in );
#line 90
    clientSocket = accept(bossSocket, (struct sockaddr * __restrict  )((struct sockaddr *)(& clientAddr)),
                          (socklen_t * __restrict  )(& clientLen));
#line 91
    if (clientSocket < 0) {
#line 92
      print_system_error((char *)"accept() fails");
    }
#line 95
    pthread_mutex_lock(& queue_mutex);
#line 97
    flagSignal = 0;
#line 98
    tmp___4 = is_empty_queue(clientQueue);
#line 98
    if (tmp___4) {
#line 100
      flagSignal = 1;
    }
#line 101
    notOverload = enqueue(clientQueue, clientSocket);
#line 102
    if (flagSignal) {
#line 103
      pthread_cond_broadcast(& queue_has_client);
    }
#line 105
    pthread_mutex_unlock(& queue_mutex);
  }
}
}
#line 114 "server.c"
void create_worker(pthread_t *workerArr , int *threadId_arr , int numWorker ) 
{ 
  int threadIndex ;
  int returnVal ;
  char message[100] ;

  {
#line 120
  threadIndex = 0;
#line 120
  while (threadIndex < numWorker) {
#line 122
    *(threadId_arr + threadIndex) = threadIndex;
#line 124
    returnVal = pthread_create((pthread_t * __restrict  )(workerArr + threadIndex),
                               (pthread_attr_t const   * __restrict  )((void *)0),
                               & handle_client_request, (void * __restrict  )(threadId_arr + threadIndex));
#line 125
    printf((char const   * __restrict  )"Hi %d\n", threadIndex);
#line 126
    if (returnVal) {
#line 128
      sprintf((char * __restrict  )(message), (char const   * __restrict  )"pthread_create() fails with error code %d",
              returnVal);
#line 129
      print_system_error(message);
    }
#line 120
    threadIndex ++;
  }
#line 133
  printf((char const   * __restrict  )"I am finished\n");
#line 134
  return;
}
}
#line 205
extern int ( /* missing proto */  close)() ;
#line 136 "server.c"
void *handle_client_request(void *workerId ) 
{ 
  int id ;
  char *request ;
  int clientSocket ;
  int parseSuccess ;
  struct http_request_s *request_obj ;
  struct http_response_s *response_obj ;
  char *response ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  size_t tmp___2 ;

  {
#line 138
  id = *((int *)workerId);
#line 140
  request = (char *)((void *)0);
#line 144
  response = (char *)((void *)0);
#line 145
  printf((char const   * __restrict  )"Hullo in %d\n", id);
#line 146
  while (1) {
#line 148
    clientSocket = -1;
#line 149
    printf((char const   * __restrict  )"Go to loop in %d\n", id);
#line 150
    pthread_mutex_lock(& queue_mutex);
#line 152
    tmp = is_empty_queue(clientQueue);
#line 152
    if (tmp) {
#line 154
      pthread_cond_wait((pthread_cond_t * __restrict  )(& queue_has_client), (pthread_mutex_t * __restrict  )(& queue_mutex));
    } else {
#line 158
      dequeue(clientQueue, & clientSocket);
    }
#line 160
    pthread_mutex_unlock(& queue_mutex);
#line 161
    printf((char const   * __restrict  )"Worker with id = %d handles socketId = %d\n",
           id, clientSocket);
#line 162
    if (clientSocket >= 0) {
#line 165
      request_obj = create_request_struct();
#line 166
      response_obj = create_response_struct();
#line 167
      response = (char *)((void *)0);
#line 170
      request = read_request(clientSocket);
#line 173
      printf((char const   * __restrict  )"OK reading request\n");
#line 175
      parseSuccess = parse_http_request(request_obj, request, response_obj);
#line 177
      response_obj->version = copy_str_dynamic(SUPPORT_HTTP);
#line 179
      if (parseSuccess) {
#line 182
        tmp___1 = strcasecmp((char const   *)request_obj->version, (char const   *)(SUPPORT_HTTP));
#line 182
        if (tmp___1 != 0) {
#line 184
          set_status_code_error(response_obj, 505, (char *)"505 HTTP Version Not Supported",
                                (char *)"This server supports only HTTP/1.1");
        } else {
#line 189
          tmp___0 = count_occurence(request_obj->path, (char )'/');
#line 189
          if (tmp___0 > (int )MAX_NUM_SLASH) {
#line 190
            set_status_code_error(response_obj, 401, (char *)"401 Unauthorized", (char *)"You are not authorized to access the requested file on this server");
          } else {
#line 193
            exec_http_request(request_obj, response_obj);
          }
        }
      }
#line 200
      response = get_response_text(response_obj);
#line 201
      tmp___2 = strlen((char const   *)response);
#line 201
      send(clientSocket, (void const   *)response, tmp___2, 0);
#line 205
      close(clientSocket);
#line 206
      free((void *)request);
#line 207
      free((void *)response);
#line 208
      delete_request(& request_obj);
#line 209
      delete_response(& response_obj);
    }
  }
}
}
#line 215 "server.c"
char *read_request(int clientSocket ) 
{ 
  char *buffer ;
  unsigned long __lengthofbuffer ;
  void *tmp ;
  int totalByte ;
  ssize_t numByteRecv ;
  ssize_t curBufferLen ;
  char *curBuffer ;
  char *tmp___0 ;

  {
#line 217
  __lengthofbuffer = (unsigned long )MAX_LEN_REQUEST;
#line 217
  tmp = __builtin_alloca(sizeof(*buffer) * __lengthofbuffer);
#line 217
  buffer = (char *)tmp;
#line 218
  totalByte = 0;
#line 222
  curBuffer = buffer;
#line 223
  curBufferLen = (ssize_t )MAX_LEN_REQUEST;
#line 224
  while (1) {
#line 226
    numByteRecv = recv(clientSocket, (void *)curBuffer, (size_t )(curBufferLen - 1L),
                       0);
#line 227
    printf((char const   * __restrict  )"numByte = %d\n", numByteRecv);
#line 228
    if (numByteRecv < 0L) {
#line 229
      print_system_error((char *)"recv() fails");
    } else {
#line 233
      totalByte += (int )numByteRecv;
#line 234
      if (totalByte >= 2) {
#line 234
        if ((int )*(buffer + (totalByte - 1)) == 10) {
#line 234
          if ((int )*(buffer + (totalByte - 2)) == 13) {
#line 236
            *(buffer + totalByte) = (char )'\000';
#line 237
            break;
          } else {
#line 241
            curBuffer += numByteRecv;
#line 242
            curBufferLen -= (ssize_t )((int )numByteRecv);
          }
        } else {
#line 241
          curBuffer += numByteRecv;
#line 242
          curBufferLen -= (ssize_t )((int )numByteRecv);
        }
      } else {
#line 241
        curBuffer += numByteRecv;
#line 242
        curBufferLen -= (ssize_t )((int )numByteRecv);
      }
    }
#line 224
    if (! numByteRecv) {
#line 224
      break;
    }
  }
#line 247
  *(buffer + totalByte) = (char )'\000';
#line 249
  tmp___0 = copy_str_dynamic(buffer);
#line 249
  return (tmp___0);
}
}
#line 1 "m_http.o"
#pragma merger("0","/tmp/cil-tetk3bUv.i","")
#line 433 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) sscanf)(char const   * __restrict  __s ,
                                                                             char const   * __restrict  __format 
                                                                             , ...)  __asm__("__isoc99_sscanf")  ;
#line 465 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 133 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcat)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 344
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(2), __leaf__)) strtok)(char * __restrict  __s ,
                                                                                               char const   * __restrict  __delim ) ;
#line 50 "/usr/include/x86_64-linux-gnu/bits/errno.h"
extern  __attribute__((__nothrow__)) int *( __attribute__((__leaf__)) __errno_location)(void)  __attribute__((__const__)) ;
#line 11 "helperlib.h"
int find_str_index(char **strArr , int numStr , char *str ) ;
#line 26
char *read_whole_file(char *relative_path , int *error_code ) ;
#line 29
char *generate_html_error_page(char *header , char *error_message ) ;
#line 18 "m_http.h"
static char *METHOD_LIST[8]  = 
#line 18 "m_http.h"
  {      (char *)"GET",      (char *)"POST",      (char *)"OPTIONS",      (char *)"HEAD", 
        (char *)"PUT",      (char *)"DELETE",      (char *)"TRACE",      (char *)"CONNECT"};
#line 49 "m_http.c"
extern int ( /* missing proto */  strcasestr)() ;
#line 61
int find_occurrence_index(char *str , char character , int occurence ) ;
#line 15 "m_http.c"
int parse_http_request(struct http_request_s *request_obj , char *request , struct http_response_s *response_obj ) 
{ 
  char delims[3] ;
  char *requestLine ;
  char m_method[20] ;
  char m_url[500] ;
  char m_protocol[20] ;
  int index___0 ;
  char relative_path[510] ;
  unsigned int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 17
  delims[0] = (char )'\r';
#line 17
  delims[1] = (char )'\n';
#line 17
  delims[2] = (char )'\000';
#line 18
  requestLine = (char *)((void *)0);
#line 21
  relative_path[0] = (char )'.';
#line 21
  relative_path[1] = (char )'\000';
#line 21
  tmp = 2U;
#line 21
  while (! (tmp >= 510U)) {
#line 21
    relative_path[tmp] = (char)0;
#line 21
    tmp ++;
  }
#line 23
  printf((char const   * __restrict  )"Going to do strtok\n");
#line 25
  requestLine = strtok((char * __restrict  )request, (char const   * __restrict  )(delims));
#line 26
  printf((char const   * __restrict  )"Finish strtok the first time\n");
#line 27
  printf((char const   * __restrict  )"Result = %s\n", requestLine);
#line 29
  if ((unsigned long )requestLine == (unsigned long )((void *)0)) {
#line 31
    set_status_code_error(response_obj, 400, (char *)"400 Bad Request", (char *)"Your request does not follow HTTP format");
#line 32
    return (0);
  }
#line 34
  sscanf((char const   * __restrict  )requestLine, (char const   * __restrict  )"%s %s %s",
         m_method, m_url, m_protocol);
#line 35
  printf((char const   * __restrict  )"method = %s\n", m_method);
#line 36
  printf((char const   * __restrict  )"url = %s\n", m_url);
#line 37
  printf((char const   * __restrict  )"protcol = %s\n", m_protocol);
#line 38
  printf((char const   * __restrict  )"Going to check method name!\n");
#line 39
  tmp___0 = find_str_index(METHOD_LIST, 8, m_method);
#line 39
  if (tmp___0 < 0) {
#line 42
    set_status_code_error(response_obj, 501, (char *)"501 Not Implemented", (char *)"Method name is invalid or it is not implemented on this server");
#line 43
    return (0);
  }
#line 45
  printf((char const   * __restrict  )"Hullo 1\n");
#line 46
  request_obj->method = copy_str_dynamic(m_method);
#line 47
  printf((char const   * __restrict  )"Method name is OK\n");
#line 48
  printf((char const   * __restrict  )"Going to check protocol\n");
#line 49
  tmp___1 = strcasestr(m_protocol, "HTTP");
#line 49
  if ((unsigned long )tmp___1 == (unsigned long )((void *)0)) {
#line 52
    set_status_code_error(response_obj, 505, (char *)"505 HTTP Version Not Supported",
                          (char *)"The protocol is not HTTP. This server can only handle HTTP requests");
#line 53
    return (0);
  }
#line 55
  printf((char const   * __restrict  )"Hullo 2\n");
#line 56
  request_obj->version = copy_str_dynamic(m_protocol);
#line 57
  printf((char const   * __restrict  )"Protocol is OK\n");
#line 58
  tmp___2 = strcasestr(m_url, "HTTP://");
#line 58
  if ((unsigned long )tmp___2 != (unsigned long )((void *)0)) {
#line 61
    index___0 = find_occurrence_index(m_url, '/', 3);
  } else {
#line 65
    index___0 = 0;
  }
#line 67
  strcat((char * __restrict  )(relative_path), (char const   * __restrict  )(m_url + index___0));
#line 68
  printf((char const   * __restrict  )"Relative path = %s\n", relative_path);
#line 70
  request_obj->path = copy_str_dynamic(relative_path);
#line 73
  if ((unsigned long )request_obj->method == (unsigned long )((void *)0)) {
#line 75
    set_status_code_error(response_obj, 500, (char *)"500 Internal Server Error",
                          (char *)"Memory allocation in the server failed");
#line 76
    return (0);
  } else
#line 73
  if ((unsigned long )request_obj->version == (unsigned long )((void *)0)) {
#line 75
    set_status_code_error(response_obj, 500, (char *)"500 Internal Server Error",
                          (char *)"Memory allocation in the server failed");
#line 76
    return (0);
  } else
#line 73
  if ((unsigned long )request_obj->path == (unsigned long )((void *)0)) {
#line 75
    set_status_code_error(response_obj, 500, (char *)"500 Internal Server Error",
                          (char *)"Memory allocation in the server failed");
#line 76
    return (0);
  }
#line 79
  printf((char const   * __restrict  )"Hullo. Finish the path");
#line 81
  while ((unsigned long )requestLine != (unsigned long )((void *)0)) {
#line 83
    requestLine = strtok((char * __restrict  )((void *)0), (char const   * __restrict  )(delims));
  }
#line 91
  return (1);
}
}
#line 94 "m_http.c"
struct http_request_s *create_request_struct(void) 
{ 
  struct http_request_s *new_obj ;
  void *tmp ;
  int index___0 ;

  {
#line 96
  tmp = malloc(sizeof(struct http_request_s ));
#line 96
  new_obj = (struct http_request_s *)tmp;
#line 99
  new_obj->method = (char *)((void *)0);
#line 100
  new_obj->path = (char *)((void *)0);
#line 101
  new_obj->version = (char *)((void *)0);
#line 102
  index___0 = 0;
#line 102
  while (index___0 < 19) {
#line 103
    new_obj->request_header[index___0] = (char *)((void *)0);
#line 102
    index___0 ++;
  }
#line 105
  return (new_obj);
}
}
#line 108 "m_http.c"
void delete_request(struct http_request_s **request_obj ) 
{ 
  int index___0 ;

  {
#line 111
  free((void *)(*request_obj)->method);
#line 112
  free((void *)(*request_obj)->path);
#line 113
  free((void *)(*request_obj)->version);
#line 114
  index___0 = 0;
#line 114
  while (index___0 < 19) {
#line 115
    free((void *)(*request_obj)->request_header[index___0]);
#line 114
    index___0 ++;
  }
#line 117
  free((void *)*request_obj);
#line 118
  *request_obj = (struct http_request_s *)((void *)0);
#line 119
  return;
}
}
#line 121 "m_http.c"
int exec_http_request(struct http_request_s *request_obj , struct http_response_s *response_obj ) 
{ 
  int error_code ;
  char *file_content ;
  int *tmp ;
  int tmp___0 ;

  {
#line 126
  tmp___0 = strcasecmp((char const   *)request_obj->method, "GET");
#line 126
  if (tmp___0 == 0) {
#line 128
    file_content = read_whole_file(request_obj->path, & error_code);
#line 130
    if (error_code == 0) {
#line 132
      printf((char const   * __restrict  )"Sucess in exec\n");
#line 134
      response_obj->message_body = file_content;
#line 135
      response_obj->status_code = 200;
#line 136
      response_obj->reason_phrase = copy_str_dynamic((char *)"200 OK");
    } else {
#line 140
      if (error_code == 1) {
#line 143
        tmp = __errno_location();
#line 143
        switch (*tmp) {
        case 36: 
#line 146
        set_status_code_error(response_obj, 414, (char *)"414 Request-URI Too Long",
                              (char *)"Your Request URI or path name is too long to be handled on this server.");
#line 147
        break;
        case 75: 
#line 149
        set_status_code_error(response_obj, 413, (char *)"413 Request Entity Too Large",
                              (char *)"Your requested file is too large to be opened on this server.");
#line 150
        break;
        case 2: 
#line 152
        set_status_code_error(response_obj, 404, (char *)"404 Not Found", (char *)"Your requested file cannot be found on this server.");
        }
      } else {
#line 157
        set_status_code_error(response_obj, 500, (char *)"500 Internal Server Error",
                              (char *)"Memory allocation on this server failed.");
      }
#line 158
      return (0);
    }
  }
#line 162
  return (1);
}
}
#line 165 "m_http.c"
struct http_response_s *create_response_struct(void) 
{ 
  struct http_response_s *new_obj ;
  void *tmp ;
  int index___0 ;

  {
#line 167
  tmp = malloc(sizeof(struct http_response_s ));
#line 167
  new_obj = (struct http_response_s *)tmp;
#line 170
  new_obj->version = (char *)((void *)0);
#line 171
  new_obj->status_code = 0;
#line 172
  new_obj->reason_phrase = (char *)((void *)0);
#line 173
  new_obj->message_body = (char *)((void *)0);
#line 175
  index___0 = 0;
#line 175
  while (index___0 < 9) {
#line 176
    new_obj->response_header[index___0] = (char *)((void *)0);
#line 175
    index___0 ++;
  }
#line 178
  return (new_obj);
}
}
#line 181 "m_http.c"
void delete_response(struct http_response_s **response_obj ) 
{ 
  int index___0 ;

  {
#line 185
  free((void *)(*response_obj)->version);
#line 186
  free((void *)(*response_obj)->reason_phrase);
#line 187
  free((void *)(*response_obj)->message_body);
#line 189
  index___0 = 0;
#line 189
  while (index___0 < 9) {
#line 190
    free((void *)(*response_obj)->response_header[index___0]);
#line 189
    index___0 ++;
  }
#line 192
  free((void *)*response_obj);
#line 193
  *response_obj = (struct http_response_s *)((void *)0);
#line 194
  return;
}
}
#line 200 "m_http.c"
void set_status_code_error(struct http_response_s *response_obj , int status_code ,
                           char *reason_phrase , char *error_message ) 
{ 


  {
#line 202
  response_obj->status_code = status_code;
#line 203
  response_obj->reason_phrase = copy_str_dynamic(reason_phrase);
#line 204
  response_obj->message_body = generate_html_error_page(reason_phrase, error_message);
#line 205
  return;
}
}
#line 208 "m_http.c"
char *get_response_text(struct http_response_s *response_obj ) 
{ 
  char buffer[3000] ;
  char *tmp ;

  {
#line 213
  sprintf((char * __restrict  )(buffer), (char const   * __restrict  )"%s %d %s\r\n\r\n%s",
          response_obj->version, response_obj->status_code, response_obj->reason_phrase,
          response_obj->message_body);
#line 215
  tmp = copy_str_dynamic(buffer);
#line 215
  return (tmp);
}
}
#line 1 "helperlib.o"
#pragma merger("0","/tmp/cil-aohltGiy.i","")
#line 170 "/usr/include/stdio.h"
extern struct _IO_FILE *stderr ;
#line 237
extern int fclose(FILE *__stream ) ;
#line 272
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
#line 356
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 695
extern int puts(char const   *__s ) ;
#line 709
extern size_t fread(void * __restrict  __ptr , size_t __size , size_t __n , FILE * __restrict  __stream ) ;
#line 749
extern int fseek(FILE *__stream , long __off , int __whence ) ;
#line 754
extern long ftell(FILE *__stream ) ;
#line 759
extern void rewind(FILE *__stream ) ;
#line 846
extern void perror(char const   *__s ) ;
#line 542 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 125 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcpy)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 4 "helperlib.c"
void print_system_error(char *message ) 
{ 


  {
#line 6
  perror((char const   *)message);
#line 7
  exit(1);
}
}
#line 10 "helperlib.c"
void print_user_error(char *message , char *detail ) 
{ 


  {
#line 12
  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s: %s\n", message,
          detail);
#line 13
  exit(1);
}
}
#line 17 "helperlib.c"
int find_str_index(char **strArr , int numStr , char *str ) 
{ 
  int index___0 ;
  int tmp ;

  {
#line 21
  index___0 = 0;
#line 21
  while (index___0 < numStr) {
#line 23
    tmp = strcasecmp((char const   *)*(strArr + index___0), (char const   *)str);
#line 23
    if (tmp == 0) {
#line 24
      return (index___0);
    }
#line 21
    index___0 ++;
  }
#line 27
  return (-1);
}
}
#line 31 "helperlib.c"
int find_occurrence_index(char *str , char character , int occurence ) 
{ 
  int index___0 ;
  int curr_occur ;

  {
#line 35
  index___0 = 0;
#line 35
  curr_occur = 0;
#line 35
  while ((int )*(str + index___0) != 0) {
#line 36
    if ((int )*(str + index___0) == (int )character) {
#line 38
      curr_occur ++;
#line 39
      if (curr_occur == occurence) {
#line 40
        return (index___0);
      }
    }
#line 35
    index___0 ++;
  }
#line 43
  return (-1);
}
}
#line 53 "helperlib.c"
char *copy_str_dynamic(char *originalStr ) 
{ 
  char *newStrPointer ;
  size_t tmp ;
  void *tmp___0 ;

  {
#line 55
  if ((unsigned long )originalStr == (unsigned long )((void *)0)) {
#line 56
    return ((char *)((void *)0));
  }
#line 59
  tmp = strlen((char const   *)originalStr);
#line 59
  tmp___0 = malloc((tmp + 1UL) * sizeof(char ));
#line 59
  newStrPointer = (char *)tmp___0;
#line 61
  if ((unsigned long )newStrPointer == (unsigned long )((void *)0)) {
#line 63
    printf((char const   * __restrict  )"error with malloc\n");
#line 64
    return ((char *)((void *)0));
  }
#line 67
  strcpy((char * __restrict  )newStrPointer, (char const   * __restrict  )originalStr);
#line 69
  return (newStrPointer);
}
}
#line 78 "helperlib.c"
int count_occurence(char *str , char character ) 
{ 
  int num ;
  int index___0 ;

  {
#line 80
  num = 0;
#line 82
  if ((unsigned long )str != (unsigned long )((void *)0)) {
#line 84
    index___0 = 0;
#line 84
    while ((int )*(str + index___0) != 0) {
#line 85
      if ((int )*(str + index___0) == (int )character) {
#line 86
        num ++;
      }
#line 84
      index___0 ++;
    }
  }
#line 89
  return (num);
}
}
#line 102 "helperlib.c"
char *read_whole_file(char *relative_path , int *error_code ) 
{ 
  char *buffer ;
  int numByte ;
  FILE *fin ;
  FILE *tmp ;
  long tmp___0 ;
  void *tmp___1 ;
  size_t tmp___2 ;

  {
#line 107
  printf((char const   * __restrict  )"Go to function read_whole_file\n");
#line 109
  tmp = fopen((char const   * __restrict  )relative_path, (char const   * __restrict  )"rb");
#line 109
  fin = tmp;
#line 110
  if ((unsigned long )fin == (unsigned long )((void *)0)) {
#line 112
    *error_code = 1;
#line 113
    return ((char *)((void *)0));
  }
#line 115
  printf((char const   * __restrict  )"Valid path OK\n");
#line 117
  fseek(fin, 0L, 2);
#line 119
  tmp___0 = ftell(fin);
#line 119
  numByte = (int )tmp___0;
#line 121
  rewind(fin);
#line 122
  printf((char const   * __restrict  )"Determine size = %d: OK\n", numByte);
#line 124
  tmp___1 = malloc((unsigned long )(numByte + 1) * sizeof(char ));
#line 124
  buffer = (char *)tmp___1;
#line 125
  if ((unsigned long )buffer == (unsigned long )((void *)0)) {
#line 127
    *error_code = 2;
#line 128
    return ((char *)((void *)0));
  }
#line 131
  fread((void * __restrict  )buffer, (size_t )numByte, (size_t )1, (FILE * __restrict  )fin);
#line 132
  *(buffer + numByte) = (char )'\000';
#line 133
  tmp___2 = strlen((char const   *)buffer);
#line 133
  printf((char const   * __restrict  )"Length buffer = %d vs Byte = %d\n", tmp___2,
         numByte);
#line 134
  printf((char const   * __restrict  )"Read OK\n");
#line 135
  fclose(fin);
#line 136
  printf((char const   * __restrict  )"Close file OK\n");
#line 138
  *error_code = 0;
#line 139
  printf((char const   * __restrict  )"Totally OK?\n");
#line 140
  puts((char const   *)buffer);
#line 141
  return (buffer);
}
}
#line 144 "helperlib.c"
char *generate_html_error_page(char *header , char *error_message ) 
{ 
  char buffer[2001] ;
  char *tmp ;

  {
#line 148
  sprintf((char * __restrict  )(buffer), (char const   * __restrict  )"<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Transitional//EN\" \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\">\n<html xmlns=\"http://www.w3.org/1999/xhtml\">\n<head>\n<meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\" />\n<title>%s</title>\n</head>\n<body><h1>%s</h1><p>%s</p></body></html>",
          header, header, error_message);
#line 150
  tmp = copy_str_dynamic(buffer);
#line 150
  return (tmp);
}
}
#line 1 "queue.o"
#pragma merger("0","/tmp/cil-g8jStOXW.i","")
#line 21 "queue.h"
void delete_queue(struct queue_int_s **queuePointer ) ;
#line 9 "queue.c"
struct queue_int_s *create_queue(void) 
{ 
  struct queue_int_s *newQueue ;
  void *tmp ;

  {
#line 11
  tmp = malloc(sizeof(struct queue_int_s ));
#line 11
  newQueue = (struct queue_int_s *)tmp;
#line 13
  if ((unsigned long )newQueue != (unsigned long )((void *)0)) {
#line 15
    newQueue->head = (struct queue_node_s *)((void *)0);
#line 16
    newQueue->tail = (struct queue_node_s *)((void *)0);
  }
#line 19
  return (newQueue);
}
}
#line 28 "queue.c"
int enqueue(struct queue_int_s *queue , int data ) 
{ 
  struct queue_node_s *newNode ;
  void *tmp ;
  void *tmp___0 ;

  {
#line 31
  if ((unsigned long )queue->head == (unsigned long )((void *)0)) {
#line 34
    tmp = malloc(sizeof(struct queue_node_s ));
#line 34
    queue->head = (struct queue_node_s *)tmp;
#line 35
    if ((unsigned long )queue->head == (unsigned long )((void *)0)) {
#line 36
      return (0);
    }
#line 37
    (queue->head)->data = data;
#line 38
    (queue->head)->next_node = (struct queue_node_s *)((void *)0);
#line 39
    queue->tail = queue->head;
  } else {
#line 44
    tmp___0 = malloc(sizeof(struct queue_node_s ));
#line 44
    newNode = (struct queue_node_s *)tmp___0;
#line 45
    newNode->data = data;
#line 46
    newNode->next_node = (struct queue_node_s *)((void *)0);
#line 49
    (queue->tail)->next_node = newNode;
#line 52
    queue->tail = newNode;
  }
#line 54
  return (1);
}
}
#line 64 "queue.c"
int dequeue(struct queue_int_s *queue , int *data ) 
{ 
  int tmp ;
  struct queue_node_s *nextHead ;
  struct queue_node_s *oldHead ;

  {
#line 66
  tmp = is_empty_queue(queue);
#line 66
  if (tmp) {
#line 67
    return (0);
  }
#line 69
  nextHead = (queue->head)->next_node;
#line 71
  *data = (queue->head)->data;
#line 74
  oldHead = queue->head;
#line 75
  queue->head = nextHead;
#line 76
  free((void *)oldHead);
#line 78
  if ((unsigned long )queue->head == (unsigned long )((void *)0)) {
#line 80
    queue->tail = (struct queue_node_s *)((void *)0);
  }
#line 81
  return (1);
}
}
#line 88 "queue.c"
void delete_queue(struct queue_int_s **queuePointer ) 
{ 
  struct queue_node_s *curNode ;
  struct queue_node_s *temp ;

  {
#line 90
  if ((unsigned long )queuePointer == (unsigned long )((void *)0)) {
#line 91
    return;
  }
#line 92
  curNode = (*queuePointer)->head;
#line 95
  while ((unsigned long )curNode != (unsigned long )((void *)0)) {
#line 97
    temp = curNode->next_node;
#line 98
    free((void *)curNode);
#line 99
    curNode = temp;
  }
#line 101
  free((void *)*queuePointer);
#line 102
  *queuePointer = (struct queue_int_s *)((void *)0);
#line 103
  return;
}
}
#line 109 "queue.c"
int is_empty_queue(struct queue_int_s *queue ) 
{ 
  int tmp ;

  {
#line 111
  if ((unsigned long )queue->head == (unsigned long )((void *)0)) {
#line 111
    tmp = 1;
  } else {
#line 111
    tmp = 0;
  }
#line 111
  return (tmp);
}
}
