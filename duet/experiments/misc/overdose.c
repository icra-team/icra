/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is true */

#line 213 "/usr/lib/gcc/x86_64-linux-gnu/4.7/include/stddef.h"
typedef unsigned long size_t;
#line 140 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 141 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 181 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __ssize_t;
#line 198 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __socklen_t;
#line 60 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef unsigned long pthread_t;
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 40 "/usr/lib/gcc/x86_64-linux-gnu/4.7/include/stdarg.h"
typedef __builtin_va_list __gnuc_va_list;
#line 155 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 161 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 246 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 102 "/usr/include/stdio.h"
typedef __ssize_t ssize_t;
#line 33 "/usr/include/x86_64-linux-gnu/bits/socket.h"
typedef __socklen_t socklen_t;
#line 28 "/usr/include/x86_64-linux-gnu/bits/sockaddr.h"
typedef unsigned short sa_family_t;
#line 147 "/usr/include/x86_64-linux-gnu/bits/socket.h"
struct sockaddr {
   sa_family_t sa_family ;
   char sa_data[14] ;
};
#line 143 "/usr/include/curses.h"
typedef unsigned long chtype;
#line 341
struct _win_st;
#line 341 "/usr/include/curses.h"
typedef struct _win_st WINDOW;
#line 343 "/usr/include/curses.h"
typedef chtype attr_t;
#line 388
struct ldat;
#line 390 "/usr/include/curses.h"
struct pdat {
   short _pad_y ;
   short _pad_x ;
   short _pad_top ;
   short _pad_left ;
   short _pad_bottom ;
   short _pad_right ;
};
#line 390 "/usr/include/curses.h"
struct _win_st {
   short _cury ;
   short _curx ;
   short _maxy ;
   short _maxx ;
   short _begy ;
   short _begx ;
   short _flags ;
   attr_t _attrs ;
   chtype _bkgd ;
   _Bool _notimeout ;
   _Bool _clear ;
   _Bool _leaveok ;
   _Bool _scroll ;
   _Bool _idlok ;
   _Bool _idcok ;
   _Bool _immed ;
   _Bool _sync ;
   _Bool _use_keypad ;
   int _delay ;
   struct ldat *_line ;
   short _regtop ;
   short _regbottom ;
   int _parx ;
   int _pary ;
   WINDOW *_parent ;
   struct pdat _pad ;
   short _yoffset ;
};
#line 135 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __gid_t;
#line 79 "/usr/include/stdio.h"
typedef __gnuc_va_list va_list;
#line 27 "/usr/include/x86_64-linux-gnu/bits/ioctl-types.h"
struct winsize {
   unsigned short ws_row ;
   unsigned short ws_col ;
   unsigned short ws_xpixel ;
   unsigned short ws_ypixel ;
};
#line 85 "/usr/include/signal.h"
typedef void (*__sighandler_t)(int  );
#line 325 "/usr/lib/gcc/x86_64-linux-gnu/4.7/include/stddef.h"
typedef int wchar_t;
#line 24 "snprintf.h"
typedef int gint;
#line 25 "snprintf.h"
typedef char gchar;
#line 142 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __pid_t;
#line 148 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 75 "/usr/include/time.h"
typedef __time_t time_t;
#line 133 "/usr/include/time.h"
struct tm {
   int tm_sec ;
   int tm_min ;
   int tm_hour ;
   int tm_mday ;
   int tm_mon ;
   int tm_year ;
   int tm_wday ;
   int tm_yday ;
   int tm_isdst ;
   long tm_gmtoff ;
   char const   *tm_zone ;
};
#line 63 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
union pthread_attr_t {
   char __size[56] ;
   long __align ;
};
#line 69 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef union pthread_attr_t pthread_attr_t;
#line 48 "/usr/include/x86_64-linux-gnu/sys/utsname.h"
struct utsname {
   char sysname[65] ;
   char nodename[65] ;
   char release[65] ;
   char version[65] ;
   char machine[65] ;
   char __domainname[65] ;
};
#line 53 "md5.h"
typedef unsigned char md5_byte_t;
#line 54 "md5.h"
typedef unsigned int md5_word_t;
#line 57 "md5.h"
struct md5_state_s {
   md5_word_t count[2] ;
   md5_word_t abcd[4] ;
   md5_byte_t buf[64] ;
};
#line 57 "md5.h"
typedef struct md5_state_s md5_state_t;
#line 6 "sha.h"
typedef unsigned int uint32;
#line 11 "sha.h"
struct __anonstruct_SHA_CTX_1 {
   uint32 H[5] ;
   uint32 W[80] ;
   int lenW ;
   uint32 sizeHi ;
   uint32 sizeLo ;
};
#line 11 "sha.h"
typedef struct __anonstruct_SHA_CTX_1 SHA_CTX;
#line 316 "/usr/include/libio.h"
typedef struct _IO_FILE _IO_FILE;
#line 49 "/usr/include/stdint.h"
typedef unsigned short uint16_t;
#line 51 "/usr/include/stdint.h"
typedef unsigned int uint32_t;
#line 96 "/usr/include/netinet/in.h"
typedef uint16_t in_port_t;
#line 140 "/usr/include/netinet/in.h"
typedef uint32_t in_addr_t;
#line 141 "/usr/include/netinet/in.h"
struct in_addr {
   in_addr_t s_addr ;
};
#line 224 "/usr/include/netinet/in.h"
struct sockaddr_in {
   sa_family_t sin_family ;
   in_port_t sin_port ;
   struct in_addr sin_addr ;
   unsigned char sin_zero[((sizeof(struct sockaddr ) - sizeof(unsigned short )) - sizeof(in_port_t )) - sizeof(struct in_addr )] ;
};
#line 100 "/usr/include/netdb.h"
struct hostent {
   char *h_name ;
   char **h_aliases ;
   int h_addrtype ;
   int h_length ;
   char **h_addr_list ;
};
#line 326 "/usr/include/netdb.h"
struct protoent {
   char *p_name ;
   char **p_aliases ;
   int p_proto ;
};
/* compiler builtin: 
   void *__builtin___memmove_chk(void * , void const   * , unsigned long  , unsigned long  ) ;  */
/* compiler builtin: 
   void *__builtin___memcpy_chk(void * , void const   * , unsigned long  , unsigned long  ) ;  */
/* compiler builtin: 
   int __builtin___vsprintf_chk(char * , int  , unsigned long  , char const   * ,
                                __builtin_va_list  ) ;  */
/* compiler builtin: 
   char *__builtin___strncpy_chk(char * , char const   * , unsigned long  , unsigned long  ) ;  */
/* compiler builtin: 
   char *__builtin___strcat_chk(char * , char const   * , unsigned long  ) ;  */
/* compiler builtin: 
   unsigned long __builtin_object_size(void * , int  ) ;  */
/* compiler builtin: 
   int __builtin___sprintf_chk(char * , int  , unsigned long  , char const   *  , ...) ;  */
/* compiler builtin: 
   int __builtin___snprintf_chk(char * , unsigned long  , int  , unsigned long  ,
                                char const   *  , ...) ;  */
/* compiler builtin: 
   int __builtin___vsnprintf_chk(char * , unsigned long  , int  , unsigned long  ,
                                 char const   * , __builtin_va_list  ) ;  */
/* compiler builtin: 
   char *__builtin___strcpy_chk(char * , char const   * , unsigned long  ) ;  */
/* compiler builtin: 
   void *__builtin___memset_chk(void * , int  , unsigned long  , unsigned long  ) ;  */
/* compiler builtin: 
   char *__builtin___strncat_chk(char * , char const   * , unsigned long  , unsigned long  ) ;  */
/* compiler builtin: 
   int __builtin_va_arg_pack(void) ;  */
#line 1 "cmd.o"
#pragma merger("0","/tmp/cil-B6wMb7cC.i","-Os,-fomit-frame-pointer,-fstack-protector-all")
#line 42 "/usr/include/string.h"
__inline extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2),
__leaf__, __artificial__, __always_inline__)) memcpy)(void * __restrict  __dest ,
                                                      void const   * __restrict  __src ,
                                                      size_t __len ) ;
#line 46
__inline extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2),
__leaf__, __artificial__, __always_inline__)) memmove)(void *__dest , void const   *__src ,
                                                       size_t __len ) ;
#line 62
__inline extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1),
__leaf__, __artificial__, __always_inline__)) memset)(void *__dest , int __ch , size_t __len ) ;
#line 125
__inline extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2),
__leaf__, __artificial__, __always_inline__)) strcpy)(char * __restrict  __dest ,
                                                      char const   * __restrict  __src ) ;
#line 128
__inline extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2),
__leaf__, __artificial__, __always_inline__)) strncpy)(char * __restrict  __dest ,
                                                       char const   * __restrict  __src ,
                                                       size_t __len ) ;
#line 133
__inline extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2),
__leaf__, __artificial__, __always_inline__)) strcat)(char * __restrict  __dest ,
                                                      char const   * __restrict  __src ) ;
#line 136
__inline extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2),
__leaf__, __artificial__, __always_inline__)) strncat)(char * __restrict  __dest ,
                                                       char const   * __restrict  __src ,
                                                       size_t __len ) ;
#line 451
__inline extern  __attribute__((__nothrow__)) void ( __attribute__((__nonnull__(1,2),
__leaf__, __artificial__, __always_inline__)) bcopy)(void const   *__src , void *__dest ,
                                                     size_t __len ) ;
#line 455
__inline extern  __attribute__((__nothrow__)) void ( __attribute__((__nonnull__(1),
__leaf__, __artificial__, __always_inline__)) bzero)(void *__dest , size_t __len ) ;
#line 532
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcasecmp)(char const   *__s1 ,
                                                                                                   char const   *__s2 )  __attribute__((__pure__)) ;
#line 575
__inline extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2),
__leaf__, __artificial__, __always_inline__)) stpncpy)(char * __restrict  __dest ,
                                                       char const   * __restrict  __src ,
                                                       size_t __n ) ;
#line 47 "/usr/include/x86_64-linux-gnu/bits/string3.h"
__inline extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2),
__leaf__, __artificial__, __always_inline__)) memcpy)(void * __restrict  __dest ,
                                                      void const   * __restrict  __src ,
                                                      size_t __len ) ;
#line 47 "/usr/include/x86_64-linux-gnu/bits/string3.h"
__inline extern void *( __attribute__((__nonnull__(1,2), __leaf__, __artificial__,
__always_inline__)) memcpy)(void * __restrict  __dest , void const   * __restrict  __src ,
                            size_t __len ) 
{ 
  unsigned long tmp ;
  void *tmp___0 ;

  {
#line 51
  tmp = __builtin_object_size((void *)__dest, 0);
#line 51
  tmp___0 = __builtin___memcpy_chk((void *)__dest, (void const   *)__src, __len, tmp);
#line 51
  return (tmp___0);
}
}
#line 54
__inline extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2),
__leaf__, __artificial__, __always_inline__)) memmove)(void *__dest , void const   *__src ,
                                                       size_t __len ) ;
#line 54 "/usr/include/x86_64-linux-gnu/bits/string3.h"
__inline extern void *( __attribute__((__nonnull__(1,2), __leaf__, __artificial__,
__always_inline__)) memmove)(void *__dest , void const   *__src , size_t __len ) 
{ 
  unsigned long tmp ;
  void *tmp___0 ;

  {
#line 57
  tmp = __builtin_object_size(__dest, 0);
#line 57
  tmp___0 = __builtin___memmove_chk(__dest, __src, __len, tmp);
#line 57
  return (tmp___0);
}
}
#line 75
__inline extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1),
__leaf__, __artificial__, __always_inline__)) memset)(void *__dest , int __ch , size_t __len ) ;
#line 75 "/usr/include/x86_64-linux-gnu/bits/string3.h"
__inline extern void *( __attribute__((__nonnull__(1), __leaf__, __artificial__, __always_inline__)) memset)(void *__dest ,
                                                                                                             int __ch ,
                                                                                                             size_t __len ) 
{ 
  unsigned long tmp ;
  void *tmp___0 ;

  {
#line 84
  tmp = __builtin_object_size(__dest, 0);
#line 84
  tmp___0 = __builtin___memset_chk(__dest, __ch, __len, tmp);
#line 84
  return (tmp___0);
}
}
#line 88
__inline extern  __attribute__((__nothrow__)) void ( __attribute__((__nonnull__(1,2),
__leaf__, __artificial__, __always_inline__)) bcopy)(void const   *__src , void *__dest ,
                                                     size_t __len ) ;
#line 88 "/usr/include/x86_64-linux-gnu/bits/string3.h"
__inline extern void ( __attribute__((__nonnull__(1,2), __leaf__, __artificial__,
__always_inline__)) bcopy)(void const   *__src , void *__dest , size_t __len ) 
{ 
  unsigned long tmp ;

  {
#line 91
  tmp = __builtin_object_size(__dest, 0);
#line 91
  __builtin___memmove_chk(__dest, __src, __len, tmp);
#line 92
  return;
}
}
#line 94
__inline extern  __attribute__((__nothrow__)) void ( __attribute__((__nonnull__(1),
__leaf__, __artificial__, __always_inline__)) bzero)(void *__dest , size_t __len ) ;
#line 94 "/usr/include/x86_64-linux-gnu/bits/string3.h"
__inline extern void ( __attribute__((__nonnull__(1), __leaf__, __artificial__, __always_inline__)) bzero)(void *__dest ,
                                                                                                           size_t __len ) 
{ 
  unsigned long tmp ;

  {
#line 97
  tmp = __builtin_object_size(__dest, 0);
#line 97
  __builtin___memset_chk(__dest, '\000', __len, tmp);
#line 98
  return;
}
}
#line 101
__inline extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2),
__leaf__, __artificial__, __always_inline__)) strcpy)(char * __restrict  __dest ,
                                                      char const   * __restrict  __src ) ;
#line 101 "/usr/include/x86_64-linux-gnu/bits/string3.h"
__inline extern char *( __attribute__((__nonnull__(1,2), __leaf__, __artificial__,
__always_inline__)) strcpy)(char * __restrict  __dest , char const   * __restrict  __src ) 
{ 
  unsigned long tmp ;
  char *tmp___0 ;

  {
#line 104
  tmp = __builtin_object_size((void *)__dest, 1);
#line 104
  tmp___0 = __builtin___strcpy_chk((char *)__dest, (char const   *)__src, tmp);
#line 104
  return (tmp___0);
}
}
#line 116
__inline extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2),
__leaf__, __artificial__, __always_inline__)) strncpy)(char * __restrict  __dest ,
                                                       char const   * __restrict  __src ,
                                                       size_t __len ) ;
#line 116 "/usr/include/x86_64-linux-gnu/bits/string3.h"
__inline extern char *( __attribute__((__nonnull__(1,2), __leaf__, __artificial__,
__always_inline__)) strncpy)(char * __restrict  __dest , char const   * __restrict  __src ,
                             size_t __len ) 
{ 
  unsigned long tmp ;
  char *tmp___0 ;

  {
#line 120
  tmp = __builtin_object_size((void *)__dest, 1);
#line 120
  tmp___0 = __builtin___strncpy_chk((char *)__dest, (char const   *)__src, __len,
                                    tmp);
#line 120
  return (tmp___0);
}
}
#line 124
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) __stpncpy_chk)(char *__dest ,
                                                                                      char const   *__src ,
                                                                                      size_t __n ,
                                                                                      size_t __destlen ) ;
#line 126
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) __stpncpy_alias)(char *__dest ,
                                                                                        char const   *__src ,
                                                                                        size_t __n )  __asm__("stpncpy")  ;
#line 129
__inline extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2),
__leaf__, __artificial__, __always_inline__)) stpncpy)(char * __restrict  __dest ,
                                                       char const   * __restrict  __src ,
                                                       size_t __n ) ;
#line 129 "/usr/include/x86_64-linux-gnu/bits/string3.h"
__inline extern char *( __attribute__((__nonnull__(1,2), __leaf__, __artificial__,
__always_inline__)) stpncpy)(char * __restrict  __dest , char const   * __restrict  __src ,
                             size_t __n ) 
{ 
  unsigned long tmp ;
  char *tmp___0 ;
  unsigned long tmp___1 ;
  char *tmp___3 ;

  {
#line 132
  tmp___1 = __builtin_object_size((void *)__dest, 1);
#line 132
  if (tmp___1 != 0xffffffffffffffffUL) {
#line 134
    tmp = __builtin_object_size((void *)__dest, 1);
#line 134
    tmp___0 = __stpncpy_chk((char *)__dest, (char const   *)__src, __n, tmp);
#line 134
    return (tmp___0);
  }
#line 135
  tmp___3 = __stpncpy_alias((char *)__dest, (char const   *)__src, __n);
#line 135
  return (tmp___3);
}
}
#line 139
__inline extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2),
__leaf__, __artificial__, __always_inline__)) strcat)(char * __restrict  __dest ,
                                                      char const   * __restrict  __src ) ;
#line 139 "/usr/include/x86_64-linux-gnu/bits/string3.h"
__inline extern char *( __attribute__((__nonnull__(1,2), __leaf__, __artificial__,
__always_inline__)) strcat)(char * __restrict  __dest , char const   * __restrict  __src ) 
{ 
  unsigned long tmp ;
  char *tmp___0 ;

  {
#line 142
  tmp = __builtin_object_size((void *)__dest, 1);
#line 142
  tmp___0 = __builtin___strcat_chk((char *)__dest, (char const   *)__src, tmp);
#line 142
  return (tmp___0);
}
}
#line 146
__inline extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2),
__leaf__, __artificial__, __always_inline__)) strncat)(char * __restrict  __dest ,
                                                       char const   * __restrict  __src ,
                                                       size_t __len ) ;
#line 146 "/usr/include/x86_64-linux-gnu/bits/string3.h"
__inline extern char *( __attribute__((__nonnull__(1,2), __leaf__, __artificial__,
__always_inline__)) strncat)(char * __restrict  __dest , char const   * __restrict  __src ,
                             size_t __len ) 
{ 
  unsigned long tmp ;
  char *tmp___0 ;

  {
#line 150
  tmp = __builtin_object_size((void *)__dest, 1);
#line 150
  tmp___0 = __builtin___strncat_chk((char *)__dest, (char const   *)__src, __len,
                                    tmp);
#line 150
  return (tmp___0);
}
}
#line 7 "ycht.h"
void ycmd(int socket___0 , int service , char *text , int len ) ;
#line 9
void ysay(int socket___0 , char *msg ) ;
#line 10
void yemote(int socket___0 , char *msg ) ;
#line 356 "/usr/include/stdio.h"
__inline extern int ( __attribute__((__artificial__, __always_inline__)) fprintf)(FILE * __restrict  __stream ,
                                                                                  char const   * __restrict  __fmt 
                                                                                  , ...) ;
#line 362
__inline extern int ( __attribute__((__artificial__, __always_inline__)) printf)(char const   * __restrict  __fmt 
                                                                                 , ...) ;
#line 364
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__, __artificial__,
__always_inline__)) sprintf)(char * __restrict  __s , char const   * __restrict  __fmt 
                             , ...) ;
#line 371
__inline extern int ( __attribute__((__artificial__, __always_inline__)) vfprintf)(FILE * __restrict  __stream ,
                                                                                   char const   * __restrict  __fmt ,
                                                                                   __gnuc_va_list __ap ) ;
#line 377
__inline extern int ( __attribute__((__artificial__, __always_inline__)) vprintf)(char const   * __restrict  __fmt ,
                                                                                  __gnuc_va_list __ap ) ;
#line 379
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__, __artificial__,
__always_inline__)) vsprintf)(char * __restrict  __s , char const   * __restrict  __fmt ,
                              __gnuc_va_list __ap ) ;
#line 386
__inline extern  __attribute__((__nothrow__)) int ( /* format attribute */ __attribute__((__leaf__,
__artificial__, __always_inline__)) snprintf)(char * __restrict  __s , size_t __n ,
                                              char const   * __restrict  __fmt  , ...) ;
#line 390
__inline extern  __attribute__((__nothrow__)) int ( /* format attribute */ __attribute__((__leaf__,
__artificial__, __always_inline__)) vsnprintf)(char * __restrict  __s , size_t __n ,
                                               char const   * __restrict  __fmt ,
                                               __gnuc_va_list __ap ) ;
#line 412
__inline extern int ( /* format attribute */ __attribute__((__artificial__, __always_inline__)) vdprintf)(int __fd ,
                                                                                                          char const   * __restrict  __fmt ,
                                                                                                          __gnuc_va_list __ap ) ;
#line 415
__inline extern int ( /* format attribute */ __attribute__((__artificial__, __always_inline__)) dprintf)(int __fd ,
                                                                                                         char const   * __restrict  __fmt 
                                                                                                         , ...) ;
#line 622
__inline extern char *( __attribute__((__warn_unused_result__, __artificial__, __always_inline__)) fgets)(char * __restrict  __s ,
                                                                                                          int __n ,
                                                                                                          FILE * __restrict  __stream ) ;
#line 638
__inline extern char *( __attribute__((__warn_unused_result__, __artificial__, __always_inline__)) gets)(char *__str )  __attribute__((__deprecated__)) ;
#line 709
__inline extern size_t ( __attribute__((__warn_unused_result__, __artificial__, __always_inline__)) fread)(void * __restrict  __ptr ,
                                                                                                           size_t __size ,
                                                                                                           size_t __n ,
                                                                                                           FILE * __restrict  __stream ) ;
#line 737
__inline extern size_t ( __attribute__((__warn_unused_result__, __artificial__, __always_inline__)) fread_unlocked)(void * __restrict  __ptr ,
                                                                                                                    size_t __size ,
                                                                                                                    size_t __n ,
                                                                                                                    FILE * __restrict  __stream ) ;
#line 30 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__, __artificial__,
__always_inline__)) sprintf)(char * __restrict  __s , char const   * __restrict  __fmt 
                             , ...) ;
#line 30 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern int ( __attribute__((__leaf__, __artificial__, __always_inline__)) sprintf)(char * __restrict  __s ,
                                                                                            char const   * __restrict  __fmt 
                                                                                            , ...) 
{ 
  unsigned long tmp ;
  int tmp___0 ;

  {
#line 33
  tmp = __builtin_object_size((void *)__s, 1);
#line 33
  tmp___0 = __builtin___sprintf_chk((char *)__s, 1, tmp, (char const   *)__fmt, __builtin_va_arg_pack());
#line 33
  return (tmp___0);
}
}
#line 42
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__, __artificial__,
__always_inline__)) vsprintf)(char * __restrict  __s , char const   * __restrict  __fmt ,
                              __gnuc_va_list __ap ) ;
#line 42 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern int ( __attribute__((__leaf__, __artificial__, __always_inline__)) vsprintf)(char * __restrict  __s ,
                                                                                             char const   * __restrict  __fmt ,
                                                                                             __gnuc_va_list __ap ) 
{ 
  unsigned long tmp ;
  int tmp___0 ;

  {
#line 46
  tmp = __builtin_object_size((void *)__s, 1);
#line 46
  tmp___0 = __builtin___vsprintf_chk((char *)__s, 1, tmp, (char const   *)__fmt, __ap);
#line 46
  return (tmp___0);
}
}
#line 60
__inline extern  __attribute__((__nothrow__)) int ( /* format attribute */ __attribute__((__leaf__,
__artificial__, __always_inline__)) snprintf)(char * __restrict  __s , size_t __n ,
                                              char const   * __restrict  __fmt  , ...) ;
#line 60 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern int ( /* format attribute */ __attribute__((__leaf__, __artificial__,
__always_inline__)) snprintf)(char * __restrict  __s , size_t __n , char const   * __restrict  __fmt 
                              , ...) 
{ 
  unsigned long tmp ;
  int tmp___0 ;

  {
#line 64
  tmp = __builtin_object_size((void *)__s, 1);
#line 64
  tmp___0 = __builtin___snprintf_chk((char *)__s, __n, 1, tmp, (char const   *)__fmt,
                                     __builtin_va_arg_pack());
#line 64
  return (tmp___0);
}
}
#line 73
__inline extern  __attribute__((__nothrow__)) int ( /* format attribute */ __attribute__((__leaf__,
__artificial__, __always_inline__)) vsnprintf)(char * __restrict  __s , size_t __n ,
                                               char const   * __restrict  __fmt ,
                                               __gnuc_va_list __ap ) ;
#line 73 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern int ( /* format attribute */ __attribute__((__leaf__, __artificial__,
__always_inline__)) vsnprintf)(char * __restrict  __s , size_t __n , char const   * __restrict  __fmt ,
                               __gnuc_va_list __ap ) 
{ 
  unsigned long tmp ;
  int tmp___0 ;

  {
#line 77
  tmp = __builtin_object_size((void *)__s, 1);
#line 77
  tmp___0 = __builtin___vsnprintf_chk((char *)__s, __n, 1, tmp, (char const   *)__fmt,
                                      __ap);
#line 77
  return (tmp___0);
}
}
#line 85
extern int __fprintf_chk(FILE * __restrict  __stream , int __flag , char const   * __restrict  __format 
                         , ...) ;
#line 87
extern int __printf_chk(int __flag , char const   * __restrict  __format  , ...) ;
#line 88
extern int __vfprintf_chk(FILE * __restrict  __stream , int __flag , char const   * __restrict  __format ,
                          __gnuc_va_list __ap ) ;
#line 90
extern int __vprintf_chk(int __flag , char const   * __restrict  __format , __gnuc_va_list __ap ) ;
#line 94 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern int ( __attribute__((__artificial__, __always_inline__)) fprintf)(FILE * __restrict  __stream ,
                                                                                  char const   * __restrict  __fmt 
                                                                                  , ...) 
{ 
  int tmp ;

  {
#line 97
  tmp = __fprintf_chk(__stream, 1, __fmt, __builtin_va_arg_pack());
#line 97
  return (tmp);
}
}
#line 101 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern int ( __attribute__((__artificial__, __always_inline__)) printf)(char const   * __restrict  __fmt 
                                                                                 , ...) 
{ 
  int tmp ;

  {
#line 104
  tmp = __printf_chk(1, __fmt, __builtin_va_arg_pack());
#line 104
  return (tmp);
}
}
#line 113 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern int ( __attribute__((__artificial__, __always_inline__)) vprintf)(char const   * __restrict  __fmt ,
                                                                                  __gnuc_va_list __ap ) 
{ 
  int tmp ;

  {
#line 119
  tmp = __vprintf_chk(1, __fmt, __ap);
#line 119
  return (tmp);
}
}
#line 123 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern int ( __attribute__((__artificial__, __always_inline__)) vfprintf)(FILE * __restrict  __stream ,
                                                                                   char const   * __restrict  __fmt ,
                                                                                   __gnuc_va_list __ap ) 
{ 
  int tmp ;

  {
#line 127
  tmp = __vfprintf_chk(__stream, 1, __fmt, __ap);
#line 127
  return (tmp);
}
}
#line 131
extern int ( /* format attribute */  __dprintf_chk)(int __fd , int __flag , char const   * __restrict  __fmt 
                                                    , ...) ;
#line 133
extern int ( /* format attribute */  __vdprintf_chk)(int __fd , int __flag , char const   * __restrict  __fmt ,
                                                     __gnuc_va_list __arg ) ;
#line 138 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern int ( /* format attribute */ __attribute__((__artificial__, __always_inline__)) dprintf)(int __fd ,
                                                                                                         char const   * __restrict  __fmt 
                                                                                                         , ...) 
{ 
  int tmp ;

  {
#line 141
  tmp = __dprintf_chk(__fd, 1, __fmt, __builtin_va_arg_pack());
#line 141
  return (tmp);
}
}
#line 149 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern int ( /* format attribute */ __attribute__((__artificial__, __always_inline__)) vdprintf)(int __fd ,
                                                                                                          char const   * __restrict  __fmt ,
                                                                                                          __gnuc_va_list __ap ) 
{ 
  int tmp ;

  {
#line 152
  tmp = __vdprintf_chk(__fd, 1, __fmt, __ap);
#line 152
  return (tmp);
}
}
#line 227
extern char *( __attribute__((__warn_unused_result__)) __gets_chk)(char *__str , size_t  ) ;
#line 228
extern char *( __attribute__((__warn_unused_result__)) __gets_warn)(char *__str )  __asm__("gets") __attribute__((__warning__("please use fgets or getline instead, gets can\'t specify buffer size"))) ;
#line 232
__inline extern char *( __attribute__((__warn_unused_result__, __artificial__, __always_inline__)) gets)(char *__str )  __attribute__((__deprecated__)) ;
#line 232 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern char *( __attribute__((__warn_unused_result__, __artificial__, __always_inline__)) gets)(char *__str ) 
{ 
  unsigned long tmp ;
  char *tmp___0 ;
  unsigned long tmp___1 ;
  char *tmp___2 ;

  {
#line 235
  tmp___1 = __builtin_object_size((void *)__str, 1);
#line 235
  if (tmp___1 != 0xffffffffffffffffUL) {
#line 236
    tmp = __builtin_object_size((void *)__str, 1);
#line 236
    tmp___0 = __gets_chk(__str, tmp);
#line 236
    return (tmp___0);
  }
#line 237
  tmp___2 = __gets_warn(__str);
#line 237
  return (tmp___2);
}
}
#line 241
extern char *( __attribute__((__warn_unused_result__)) __fgets_chk)(char * __restrict  __s ,
                                                                    size_t __size ,
                                                                    int __n , FILE * __restrict  __stream ) ;
#line 243
extern char *( __attribute__((__warn_unused_result__)) __fgets_alias)(char * __restrict  __s ,
                                                                      int __n , FILE * __restrict  __stream )  __asm__("fgets")  ;
#line 246
extern char *( __attribute__((__warn_unused_result__)) __fgets_chk_warn)(char * __restrict  __s ,
                                                                         size_t __size ,
                                                                         int __n ,
                                                                         FILE * __restrict  __stream )  __asm__("__fgets_chk") __attribute__((__warning__("fgets called with bigger size than length of destination buffer"))) ;
#line 252 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern char *( __attribute__((__warn_unused_result__, __artificial__, __always_inline__)) fgets)(char * __restrict  __s ,
                                                                                                          int __n ,
                                                                                                          FILE * __restrict  __stream ) 
{ 
  unsigned long tmp ;
  char *tmp___0 ;
  unsigned long tmp___1 ;
  char *tmp___2 ;
  unsigned long tmp___3 ;
  unsigned long tmp___4 ;
  char *tmp___5 ;

  {
#line 255
  tmp___4 = __builtin_object_size((void *)__s, 1);
#line 255
  if (tmp___4 != 0xffffffffffffffffUL) {
#line 258
    tmp = __builtin_object_size((void *)__s, 1);
#line 258
    tmp___0 = __fgets_chk(__s, tmp, __n, __stream);
#line 258
    return (tmp___0);
#line 260
    tmp___3 = __builtin_object_size((void *)__s, 1);
#line 260
    if ((size_t )__n > tmp___3) {
#line 261
      tmp___1 = __builtin_object_size((void *)__s, 1);
#line 261
      tmp___2 = __fgets_chk_warn(__s, tmp___1, __n, __stream);
#line 261
      return (tmp___2);
    }
  }
#line 263
  tmp___5 = __fgets_alias(__s, __n, __stream);
#line 263
  return (tmp___5);
}
}
#line 266
extern size_t ( __attribute__((__warn_unused_result__)) __fread_chk)(void * __restrict  __ptr ,
                                                                     size_t __ptrlen ,
                                                                     size_t __size ,
                                                                     size_t __n ,
                                                                     FILE * __restrict  __stream ) ;
#line 269
extern size_t ( __attribute__((__warn_unused_result__)) __fread_alias)(void * __restrict  __ptr ,
                                                                       size_t __size ,
                                                                       size_t __n ,
                                                                       FILE * __restrict  __stream )  __asm__("fread")  ;
#line 273
extern size_t ( __attribute__((__warn_unused_result__)) __fread_chk_warn)(void * __restrict  __ptr ,
                                                                          size_t __ptrlen ,
                                                                          size_t __size ,
                                                                          size_t __n ,
                                                                          FILE * __restrict  __stream )  __asm__("__fread_chk") __attribute__((__warning__("fread called with bigger size * nmemb than length of destination buffer"))) ;
#line 281 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern size_t ( __attribute__((__warn_unused_result__, __artificial__, __always_inline__)) fread)(void * __restrict  __ptr ,
                                                                                                           size_t __size ,
                                                                                                           size_t __n ,
                                                                                                           FILE * __restrict  __stream ) 
{ 
  unsigned long tmp ;
  size_t tmp___0 ;
  unsigned long tmp___1 ;
  size_t tmp___2 ;
  unsigned long tmp___3 ;
  unsigned long tmp___4 ;
  size_t tmp___5 ;

  {
#line 285
  tmp___4 = __builtin_object_size((void *)__ptr, 0);
#line 285
  if (tmp___4 != 0xffffffffffffffffUL) {
#line 290
    tmp = __builtin_object_size((void *)__ptr, 0);
#line 290
    tmp___0 = __fread_chk(__ptr, tmp, __size, __n, __stream);
#line 290
    return (tmp___0);
#line 292
    tmp___3 = __builtin_object_size((void *)__ptr, 0);
#line 292
    if (__size * __n > tmp___3) {
#line 293
      tmp___1 = __builtin_object_size((void *)__ptr, 0);
#line 293
      tmp___2 = __fread_chk_warn(__ptr, tmp___1, __size, __n, __stream);
#line 293
      return (tmp___2);
    }
  }
#line 295
  tmp___5 = __fread_alias(__ptr, __size, __n, __stream);
#line 295
  return (tmp___5);
}
}
#line 327
extern size_t ( __attribute__((__warn_unused_result__)) __fread_unlocked_chk)(void * __restrict  __ptr ,
                                                                              size_t __ptrlen ,
                                                                              size_t __size ,
                                                                              size_t __n ,
                                                                              FILE * __restrict  __stream ) ;
#line 330
extern size_t ( __attribute__((__warn_unused_result__)) __fread_unlocked_alias)(void * __restrict  __ptr ,
                                                                                size_t __size ,
                                                                                size_t __n ,
                                                                                FILE * __restrict  __stream )  __asm__("fread_unlocked")  ;
#line 334
extern size_t ( __attribute__((__warn_unused_result__)) __fread_unlocked_chk_warn)(void * __restrict  __ptr ,
                                                                                   size_t __ptrlen ,
                                                                                   size_t __size ,
                                                                                   size_t __n ,
                                                                                   FILE * __restrict  __stream )  __asm__("__fread_unlocked_chk") __attribute__((__warning__("fread_unlocked called with bigger size * nmemb than length of destination buffer"))) ;
#line 342 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern size_t ( __attribute__((__warn_unused_result__, __artificial__, __always_inline__)) fread_unlocked)(void * __restrict  __ptr ,
                                                                                                                    size_t __size ,
                                                                                                                    size_t __n ,
                                                                                                                    FILE * __restrict  __stream ) 
{ 
  unsigned long tmp ;
  size_t tmp___0 ;
  unsigned long tmp___1 ;
  size_t tmp___2 ;
  unsigned long tmp___3 ;
  unsigned long tmp___4 ;
  size_t tmp___5 ;

  {
#line 346
  tmp___4 = __builtin_object_size((void *)__ptr, 0);
#line 346
  if (tmp___4 != 0xffffffffffffffffUL) {
#line 351
    tmp = __builtin_object_size((void *)__ptr, 0);
#line 351
    tmp___0 = __fread_unlocked_chk(__ptr, tmp, __size, __n, __stream);
#line 351
    return (tmp___0);
#line 354
    tmp___3 = __builtin_object_size((void *)__ptr, 0);
#line 354
    if (__size * __n > tmp___3) {
#line 355
      tmp___1 = __builtin_object_size((void *)__ptr, 0);
#line 355
      tmp___2 = __fread_unlocked_chk_warn(__ptr, tmp___1, __size, __n, __stream);
#line 355
      return (tmp___2);
    }
  }
#line 380
  tmp___5 = __fread_unlocked_alias(__ptr, __size, __n, __stream);
#line 380
  return (tmp___5);
}
}
#line 157 "/usr/include/x86_64-linux-gnu/sys/socket.h"
__inline extern ssize_t ( __attribute__((__artificial__, __always_inline__)) recv)(int __fd ,
                                                                                   void *__buf ,
                                                                                   size_t __n ,
                                                                                   int __flags ) ;
#line 175
__inline extern ssize_t ( __attribute__((__artificial__, __always_inline__)) recvfrom)(int __fd ,
                                                                                       void * __restrict  __buf ,
                                                                                       size_t __n ,
                                                                                       int __flags ,
                                                                                       struct sockaddr * __restrict  __addr ,
                                                                                       socklen_t * __restrict  __addr_len ) ;
#line 23 "/usr/include/x86_64-linux-gnu/bits/socket2.h"
extern ssize_t __recv_chk(int __fd , void *__buf , size_t __n , size_t __buflen ,
                          int __flags ) ;
#line 25
extern ssize_t __recv_alias(int __fd , void *__buf , size_t __n , int __flags )  __asm__("recv")  ;
#line 27
extern ssize_t __recv_chk_warn(int __fd , void *__buf , size_t __n , size_t __buflen ,
                               int __flags )  __asm__("__recv_chk") __attribute__((__warning__("recv called with bigger length than size of destination buffer"))) ;
#line 33 "/usr/include/x86_64-linux-gnu/bits/socket2.h"
__inline extern ssize_t ( __attribute__((__artificial__, __always_inline__)) recv)(int __fd ,
                                                                                   void *__buf ,
                                                                                   size_t __n ,
                                                                                   int __flags ) 
{ 
  unsigned long tmp ;
  ssize_t tmp___0 ;
  unsigned long tmp___1 ;
  ssize_t tmp___2 ;
  unsigned long tmp___3 ;
  unsigned long tmp___4 ;
  ssize_t tmp___5 ;

  {
#line 36
  tmp___4 = __builtin_object_size(__buf, 0);
#line 36
  if (tmp___4 != 0xffffffffffffffffUL) {
#line 39
    tmp = __builtin_object_size(__buf, 0);
#line 39
    tmp___0 = __recv_chk(__fd, __buf, __n, tmp, __flags);
#line 39
    return (tmp___0);
#line 41
    tmp___3 = __builtin_object_size(__buf, 0);
#line 41
    if (__n > tmp___3) {
#line 42
      tmp___1 = __builtin_object_size(__buf, 0);
#line 42
      tmp___2 = __recv_chk_warn(__fd, __buf, __n, tmp___1, __flags);
#line 42
      return (tmp___2);
    }
  }
#line 44
  tmp___5 = __recv_alias(__fd, __buf, __n, __flags);
#line 44
  return (tmp___5);
}
}
#line 47
extern ssize_t __recvfrom_chk(int __fd , void * __restrict  __buf , size_t __n , size_t __buflen ,
                              int __flags , struct sockaddr * __restrict  __addr ,
                              socklen_t * __restrict  __addr_len ) ;
#line 51
extern ssize_t __recvfrom_alias(int __fd , void * __restrict  __buf , size_t __n ,
                                int __flags , struct sockaddr * __restrict  __addr ,
                                socklen_t * __restrict  __addr_len )  __asm__("recvfrom")  ;
#line 55
extern ssize_t __recvfrom_chk_warn(int __fd , void * __restrict  __buf , size_t __n ,
                                   size_t __buflen , int __flags , struct sockaddr * __restrict  __addr ,
                                   socklen_t * __restrict  __addr_len )  __asm__("__recvfrom_chk") __attribute__((__warning__("recvfrom called with bigger length than size of destination buffer"))) ;
#line 63 "/usr/include/x86_64-linux-gnu/bits/socket2.h"
__inline extern ssize_t ( __attribute__((__artificial__, __always_inline__)) recvfrom)(int __fd ,
                                                                                       void * __restrict  __buf ,
                                                                                       size_t __n ,
                                                                                       int __flags ,
                                                                                       struct sockaddr * __restrict  __addr ,
                                                                                       socklen_t * __restrict  __addr_len ) 
{ 
  unsigned long tmp ;
  ssize_t tmp___0 ;
  unsigned long tmp___1 ;
  ssize_t tmp___2 ;
  unsigned long tmp___3 ;
  unsigned long tmp___4 ;
  ssize_t tmp___5 ;

  {
#line 67
  tmp___4 = __builtin_object_size((void *)__buf, 0);
#line 67
  if (tmp___4 != 0xffffffffffffffffUL) {
#line 70
    tmp = __builtin_object_size((void *)__buf, 0);
#line 70
    tmp___0 = __recvfrom_chk(__fd, __buf, __n, tmp, __flags, __addr, __addr_len);
#line 70
    return (tmp___0);
#line 72
    tmp___3 = __builtin_object_size((void *)__buf, 0);
#line 72
    if (__n > tmp___3) {
#line 73
      tmp___1 = __builtin_object_size((void *)__buf, 0);
#line 73
      tmp___2 = __recvfrom_chk_warn(__fd, __buf, __n, tmp___1, __flags, __addr, __addr_len);
#line 73
      return (tmp___2);
    }
  }
#line 76
  tmp___5 = __recvfrom_alias(__fd, __buf, __n, __flags, __addr, __addr_len);
#line 76
  return (tmp___5);
}
}
#line 21 "main.h"
char *defserver  ;
#line 21 "main.h"
char *defroom  ;
#line 21 "main.h"
char *defuser  ;
#line 21 "main.h"
char *username  ;
#line 21 "main.h"
char **users  ;
#line 21 "main.h"
char **ignore  ;
#line 22 "main.h"
pthread_t thrdid  ;
#line 23 "main.h"
int s  ;
#line 23 "main.h"
int connected  ;
#line 23 "main.h"
int logdin  ;
#line 23 "main.h"
int joindroom  ;
#line 23 "main.h"
int tson  ;
#line 23 "main.h"
int col  ;
#line 33
void disconnect(void) ;
#line 34
void quit(void) ;
#line 37
void ignoreuser(char *uS ) ;
#line 39
int conn(char *host ) ;
#line 40
int login(char *id ) ;
#line 41
void join(char *room ) ;
#line 5 "cmd.h"
void command(char *cmd , char *arg ) ;
#line 776 "/usr/include/curses.h"
extern int wattr_on(WINDOW * , attr_t  , void * ) ;
#line 7 "gui.h"
WINDOW *inputwin  ;
#line 7 "gui.h"
WINDOW *outputwin  ;
#line 7 "gui.h"
WINDOW *statuswin  ;
#line 13
void guiprintf(char *fmt  , ...) ;
#line 74 "cmd.c"
void yfollow(int socket___0 , char *user ) ;
#line 76
void yping(int socket___0 ) ;
#line 78
void pexec(char *cmd ) ;
#line 91
void togglets(void) ;
#line 32 "cmd.c"
void command(char *cmd , char *arg ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;

  {
#line 34
  tmp = strcasecmp((char const   *)cmd, "connect");
#line 34
  if (tmp == 0) {
#line 35
    if (arg) {
#line 36
      if ((int )*(arg + 0) == 0) {
#line 37
        conn((char *)"");
      } else {
#line 39
        conn(arg);
      }
    } else {
#line 42
      conn((char *)"");
    }
  }
#line 45
  tmp___0 = strcasecmp((char const   *)cmd, "login");
#line 45
  if (tmp___0 == 0) {
#line 46
    if (arg) {
#line 47
      if ((int )*(arg + 0) == 0) {
#line 48
        login((char *)"");
      } else {
#line 50
        login(arg);
      }
    } else {
#line 53
      login((char *)"");
    }
  }
#line 56
  tmp___1 = strcasecmp((char const   *)cmd, "logout");
#line 56
  if (tmp___1 == 0) {
#line 57
    ycmd(s, 113, (char *)"logout", 6);
  }
#line 58
  tmp___2 = strcasecmp((char const   *)cmd, "disconnect");
#line 58
  if (tmp___2 == 0) {
#line 59
    disconnect();
  }
#line 60
  tmp___3 = strcasecmp((char const   *)cmd, "join");
#line 60
  if (tmp___3 == 0) {
#line 61
    if (arg) {
#line 62
      if ((int )*(arg + 0) == 0) {
#line 63
        join((char *)"");
      } else {
#line 65
        join(arg);
      }
    } else {
#line 68
      join((char *)"");
    }
  }
#line 71
  tmp___4 = strcasecmp((char const   *)cmd, "me");
#line 71
  if (tmp___4 == 0) {
#line 72
    yemote(s, arg);
  }
#line 73
  tmp___5 = strcasecmp((char const   *)cmd, "follow");
#line 73
  if (tmp___5 == 0) {
#line 74
    yfollow(s, arg);
  }
#line 75
  tmp___6 = strcasecmp((char const   *)cmd, "ping");
#line 75
  if (tmp___6 == 0) {
#line 76
    yping(s);
  }
#line 77
  tmp___7 = strcasecmp((char const   *)cmd, "exec");
#line 77
  if (tmp___7 == 0) {
#line 78
    pexec(arg);
  }
#line 79
  tmp___8 = strcasecmp((char const   *)cmd, "i");
#line 79
  if (tmp___8 == 0) {
#line 79
    goto _L;
  } else {
#line 79
    tmp___9 = strcasecmp((char const   *)cmd, "ignore");
#line 79
    if (tmp___9 == 0) {
      _L: /* CIL Label */ 
#line 80
      if (arg) {
#line 81
        if ((int )*(arg + 0) == 0) {
#line 82
          ignoreuser((char *)"");
        } else {
#line 84
          ignoreuser(arg);
        }
      } else {
#line 87
        ignoreuser((char *)"");
      }
    }
  }
#line 90
  tmp___10 = strcasecmp((char const   *)cmd, "timestamp");
#line 90
  if (tmp___10 == 0) {
#line 91
    togglets();
  } else {
#line 90
    tmp___11 = strcasecmp((char const   *)cmd, "ts");
#line 90
    if (tmp___11 == 0) {
#line 91
      togglets();
    }
  }
#line 92
  tmp___12 = strcasecmp((char const   *)cmd, "quit");
#line 92
  if (tmp___12 == 0) {
#line 93
    quit();
  } else {
#line 92
    tmp___13 = strcasecmp((char const   *)cmd, "q");
#line 92
    if (tmp___13 == 0) {
#line 93
      quit();
    }
  }
#line 94
  tmp___14 = strcasecmp((char const   *)cmd, "target");
#line 94
  if (tmp___14 == 0) {
#line 95
    if (joindroom == 1) {
#line 99
      ysay(s, (char *)"Overdose was built for target \"Unix\"");
    } else {
#line 105
      guiprintf((char *)"This version of Overdose was built for Unix.\n");
    }
  }
#line 108
  tmp___15 = strcasecmp((char const   *)cmd, "ver");
#line 108
  if (tmp___15 == 0) {
#line 108
    goto _L___0;
  } else {
#line 108
    tmp___16 = strcasecmp((char const   *)cmd, "version");
#line 108
    if (tmp___16 == 0) {
      _L___0: /* CIL Label */ 
#line 109
      if (joindroom == 1) {
#line 110
        ysay(s, (char *)"I am using Overdose version 0.3, builton a x86_64 box running Linux 3.8.0-32-generic.");
      } else {
#line 114
        guiprintf((char *)"Overdose version ");
#line 115
        wattr_on(outputwin, (attr_t )(4 << 8), (void *)0);
#line 116
        guiprintf((char *)"0.3");
#line 117
        wattr_on(outputwin, (attr_t )(7 << 8), (void *)0);
#line 118
        guiprintf((char *)".\nBuild system is ");
#line 119
        wattr_on(outputwin, (attr_t )(2 << 8), (void *)0);
#line 120
        guiprintf((char *)"x86_64");
#line 121
        wattr_on(outputwin, (attr_t )(7 << 8), (void *)0);
#line 122
        guiprintf((char *)" running ");
#line 123
        wattr_on(outputwin, (attr_t )(1 << 8), (void *)0);
#line 124
        guiprintf((char *)"Linux");
#line 125
        wattr_on(outputwin, (attr_t )(7 << 8), (void *)0);
#line 126
        guiprintf((char *)" ");
#line 127
        wattr_on(outputwin, (attr_t )(6 << 8), (void *)0);
#line 128
        guiprintf((char *)"3.8.0-32-generic");
#line 129
        wattr_on(outputwin, (attr_t )(7 << 8), (void *)0);
#line 130
        guiprintf((char *)".\n");
      }
    }
  }
#line 133
  return;
}
}
/* compiler builtin: 
   void __builtin_va_end(__builtin_va_list  ) ;  */
/* compiler builtin: 
   void __builtin_va_start(__builtin_va_list  ) ;  */
#line 1 "gui.o"
#pragma merger("0","/tmp/cil-Cr2PNvhs.i","-Os,-fomit-frame-pointer,-fstack-protector-all")
#line 14 "strutil.h"
int strarrlen(char **strarr ) ;
#line 17
void strcatl(char *dst , char const   *src , size_t size ) ;
#line 143 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strncmp)(char const   *__s1 ,
                                                                                                char const   *__s2 ,
                                                                                                size_t __n )  __attribute__((__pure__)) ;
#line 232
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strchr)(char const   *__s ,
                                                                                               int __c )  __attribute__((__pure__)) ;
#line 395
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 41 "/usr/include/x86_64-linux-gnu/sys/ioctl.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) ioctl)(int __fd ,
                                                                            unsigned long __request 
                                                                            , ...) ;
#line 570 "/usr/include/curses.h"
extern int cbreak(void) ;
#line 586
extern int delwin(WINDOW * ) ;
#line 594
extern int endwin(void) ;
#line 595
extern char erasechar(void) ;
#line 605
extern _Bool has_colors(void) ;
#line 615
extern WINDOW *initscr(void) ;
#line 617
extern int init_pair(short  , short  , short  ) ;
#line 630
extern int keypad(WINDOW * , _Bool  ) ;
#line 673
extern int mvwin(WINDOW * , int  , int  ) ;
#line 690
extern WINDOW *newwin(int  , int  , int  , int  ) ;
#line 694
extern int noecho(void) ;
#line 724
extern int scrollok(WINDOW * , _Bool  ) ;
#line 747
extern int start_color(void) ;
#line 767
extern int waddch(WINDOW * , chtype const    ) ;
#line 770
extern int waddnstr(WINDOW * , char const   * , int  ) ;
#line 783
extern int wclear(WINDOW * ) ;
#line 788
extern int wdelch(WINDOW * ) ;
#line 792
extern int wgetch(WINDOW * ) ;
#line 806
extern int wmove(WINDOW * , int  , int  ) ;
#line 808
extern int wprintw(WINDOW * , char const   *  , ...) ;
#line 811
extern int wrefresh(WINDOW * ) ;
#line 877
extern int resize_term(int  , int  ) ;
#line 886
extern int wresize(WINDOW * , int  , int  ) ;
#line 1358
extern WINDOW *stdscr ;
#line 1362
extern int COLS ;
#line 11 "gui.h"
void startgui(void) ;
#line 12
void endgui(void) ;
#line 14
int guigetln(char **text , int echo___0 ) ;
#line 102 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) __sighandler_t ( __attribute__((__leaf__)) signal)(int __sig ,
                                                                                        void (*__handler)(int  ) ) ;
#line 360 "/usr/include/unistd.h"
__inline extern ssize_t ( __attribute__((__warn_unused_result__, __artificial__, __always_inline__)) read)(int __fd ,
                                                                                                           void *__buf ,
                                                                                                           size_t __nbytes ) ;
#line 511
__inline extern  __attribute__((__nothrow__)) char *( __attribute__((__warn_unused_result__,
__leaf__, __artificial__, __always_inline__)) getcwd)(char *__buf , size_t __size ) ;
#line 525
__inline extern  __attribute__((__nothrow__)) char __attribute__((__deprecated__))  *( __attribute__((__warn_unused_result__,
__nonnull__(1), __leaf__, __artificial__, __always_inline__)) getwd)(char *__buf )  __attribute__((__deprecated__)) ;
#line 623
__inline extern  __attribute__((__nothrow__)) size_t ( __attribute__((__leaf__, __artificial__,
__always_inline__)) confstr)(int __name , char *__buf , size_t __len ) ;
#line 711
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__warn_unused_result__,
__leaf__, __artificial__, __always_inline__)) getgroups)(int __size , __gid_t *__list ) ;
#line 796
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__warn_unused_result__,
__nonnull__(2), __leaf__, __artificial__, __always_inline__)) ttyname_r)(int __fd ,
                                                                         char *__buf ,
                                                                         size_t __buflen ) ;
#line 831
__inline extern  __attribute__((__nothrow__)) ssize_t ( __attribute__((__warn_unused_result__,
__nonnull__(1,2), __leaf__, __artificial__, __always_inline__)) readlink)(char const   * __restrict  __path ,
                                                                          char * __restrict  __buf ,
                                                                          size_t __len ) ;
#line 842
__inline extern  __attribute__((__nothrow__)) ssize_t ( __attribute__((__warn_unused_result__,
__nonnull__(2,3), __leaf__, __artificial__, __always_inline__)) readlinkat)(int __fd ,
                                                                            char const   * __restrict  __path ,
                                                                            char * __restrict  __buf ,
                                                                            size_t __len ) ;
#line 879
__inline extern int ( __attribute__((__nonnull__(1), __artificial__, __always_inline__)) getlogin_r)(char *__buf ,
                                                                                                     size_t __buflen ) ;
#line 901
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1),
__leaf__, __artificial__, __always_inline__)) gethostname)(char *__buf , size_t __buflen ) ;
#line 919
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__warn_unused_result__,
__nonnull__(1), __leaf__, __artificial__, __always_inline__)) getdomainname)(char *__buf ,
                                                                             size_t __buflen ) ;
#line 23 "/usr/include/x86_64-linux-gnu/bits/unistd.h"
extern ssize_t ( __attribute__((__warn_unused_result__)) __read_chk)(int __fd , void *__buf ,
                                                                     size_t __nbytes ,
                                                                     size_t __buflen ) ;
#line 25
extern ssize_t ( __attribute__((__warn_unused_result__)) __read_alias)(int __fd ,
                                                                       void *__buf ,
                                                                       size_t __nbytes )  __asm__("read")  ;
#line 27
extern ssize_t ( __attribute__((__warn_unused_result__)) __read_chk_warn)(int __fd ,
                                                                          void *__buf ,
                                                                          size_t __nbytes ,
                                                                          size_t __buflen )  __asm__("__read_chk") __attribute__((__warning__("read called with bigger length than size of the destination buffer"))) ;
#line 33 "/usr/include/x86_64-linux-gnu/bits/unistd.h"
__inline extern ssize_t ( __attribute__((__warn_unused_result__, __artificial__, __always_inline__)) read)(int __fd ,
                                                                                                           void *__buf ,
                                                                                                           size_t __nbytes ) 
{ 
  unsigned long tmp ;
  ssize_t tmp___0 ;
  unsigned long tmp___1 ;
  ssize_t tmp___2 ;
  unsigned long tmp___3 ;
  unsigned long tmp___4 ;
  ssize_t tmp___5 ;

  {
#line 36
  tmp___4 = __builtin_object_size(__buf, 0);
#line 36
  if (tmp___4 != 0xffffffffffffffffUL) {
#line 39
    tmp = __builtin_object_size(__buf, 0);
#line 39
    tmp___0 = __read_chk(__fd, __buf, __nbytes, tmp);
#line 39
    return (tmp___0);
#line 41
    tmp___3 = __builtin_object_size(__buf, 0);
#line 41
    if (__nbytes > tmp___3) {
#line 42
      tmp___1 = __builtin_object_size(__buf, 0);
#line 42
      tmp___2 = __read_chk_warn(__fd, __buf, __nbytes, tmp___1);
#line 42
      return (tmp___2);
    }
  }
#line 44
  tmp___5 = __read_alias(__fd, __buf, __nbytes);
#line 44
  return (tmp___5);
}
}
#line 123
extern  __attribute__((__nothrow__)) ssize_t ( __attribute__((__warn_unused_result__,
__nonnull__(1,2), __leaf__)) __readlink_chk)(char const   * __restrict  __path , char * __restrict  __buf ,
                                             size_t __len , size_t __buflen ) ;
#line 127
extern  __attribute__((__nothrow__)) ssize_t ( __attribute__((__warn_unused_result__,
__nonnull__(1,2), __leaf__)) __readlink_alias)(char const   * __restrict  __path ,
                                               char * __restrict  __buf , size_t __len )  __asm__("readlink")  ;
#line 131
extern  __attribute__((__nothrow__)) ssize_t ( __attribute__((__warn_unused_result__,
__nonnull__(1,2), __leaf__)) __readlink_chk_warn)(char const   * __restrict  __path ,
                                                  char * __restrict  __buf , size_t __len ,
                                                  size_t __buflen )  __asm__("__readlink_chk") __attribute__((__warning__("readlink called with bigger length than size of destination buffer"))) ;
#line 138
__inline extern  __attribute__((__nothrow__)) ssize_t ( __attribute__((__warn_unused_result__,
__nonnull__(1,2), __leaf__, __artificial__, __always_inline__)) readlink)(char const   * __restrict  __path ,
                                                                          char * __restrict  __buf ,
                                                                          size_t __len ) ;
#line 138 "/usr/include/x86_64-linux-gnu/bits/unistd.h"
__inline extern ssize_t ( __attribute__((__warn_unused_result__, __nonnull__(1,2),
__leaf__, __artificial__, __always_inline__)) readlink)(char const   * __restrict  __path ,
                                                        char * __restrict  __buf ,
                                                        size_t __len ) 
{ 
  unsigned long tmp ;
  ssize_t tmp___0 ;
  unsigned long tmp___1 ;
  ssize_t tmp___2 ;
  unsigned long tmp___3 ;
  unsigned long tmp___4 ;
  ssize_t tmp___5 ;

  {
#line 142
  tmp___4 = __builtin_object_size((void *)__buf, 1);
#line 142
  if (tmp___4 != 0xffffffffffffffffUL) {
#line 145
    tmp = __builtin_object_size((void *)__buf, 1);
#line 145
    tmp___0 = __readlink_chk(__path, __buf, __len, tmp);
#line 145
    return (tmp___0);
#line 147
    tmp___3 = __builtin_object_size((void *)__buf, 1);
#line 147
    if (__len > tmp___3) {
#line 148
      tmp___1 = __builtin_object_size((void *)__buf, 1);
#line 148
      tmp___2 = __readlink_chk_warn(__path, __buf, __len, tmp___1);
#line 148
      return (tmp___2);
    }
  }
#line 150
  tmp___5 = __readlink_alias(__path, __buf, __len);
#line 150
  return (tmp___5);
}
}
#line 155
extern  __attribute__((__nothrow__)) ssize_t ( __attribute__((__warn_unused_result__,
__nonnull__(2,3), __leaf__)) __readlinkat_chk)(int __fd , char const   * __restrict  __path ,
                                               char * __restrict  __buf , size_t __len ,
                                               size_t __buflen ) ;
#line 159
extern  __attribute__((__nothrow__)) ssize_t ( __attribute__((__warn_unused_result__,
__nonnull__(2,3), __leaf__)) __readlinkat_alias)(int __fd , char const   * __restrict  __path ,
                                                 char * __restrict  __buf , size_t __len )  __asm__("readlinkat")  ;
#line 164
extern  __attribute__((__nothrow__)) ssize_t ( __attribute__((__warn_unused_result__,
__nonnull__(2,3), __leaf__)) __readlinkat_chk_warn)(int __fd , char const   * __restrict  __path ,
                                                    char * __restrict  __buf , size_t __len ,
                                                    size_t __buflen )  __asm__("__readlinkat_chk") __attribute__((__warning__("readlinkat called with bigger length than size of destination buffer"))) ;
#line 172
__inline extern  __attribute__((__nothrow__)) ssize_t ( __attribute__((__warn_unused_result__,
__nonnull__(2,3), __leaf__, __artificial__, __always_inline__)) readlinkat)(int __fd ,
                                                                            char const   * __restrict  __path ,
                                                                            char * __restrict  __buf ,
                                                                            size_t __len ) ;
#line 172 "/usr/include/x86_64-linux-gnu/bits/unistd.h"
__inline extern ssize_t ( __attribute__((__warn_unused_result__, __nonnull__(2,3),
__leaf__, __artificial__, __always_inline__)) readlinkat)(int __fd , char const   * __restrict  __path ,
                                                          char * __restrict  __buf ,
                                                          size_t __len ) 
{ 
  unsigned long tmp ;
  ssize_t tmp___0 ;
  unsigned long tmp___1 ;
  ssize_t tmp___2 ;
  unsigned long tmp___3 ;
  unsigned long tmp___4 ;
  ssize_t tmp___5 ;

  {
#line 176
  tmp___4 = __builtin_object_size((void *)__buf, 1);
#line 176
  if (tmp___4 != 0xffffffffffffffffUL) {
#line 179
    tmp = __builtin_object_size((void *)__buf, 1);
#line 179
    tmp___0 = __readlinkat_chk(__fd, __path, __buf, __len, tmp);
#line 179
    return (tmp___0);
#line 181
    tmp___3 = __builtin_object_size((void *)__buf, 1);
#line 181
    if (__len > tmp___3) {
#line 182
      tmp___1 = __builtin_object_size((void *)__buf, 1);
#line 182
      tmp___2 = __readlinkat_chk_warn(__fd, __path, __buf, __len, tmp___1);
#line 182
      return (tmp___2);
    }
  }
#line 185
  tmp___5 = __readlinkat_alias(__fd, __path, __buf, __len);
#line 185
  return (tmp___5);
}
}
#line 189
extern  __attribute__((__nothrow__)) char *( __attribute__((__warn_unused_result__,
__leaf__)) __getcwd_chk)(char *__buf , size_t __size , size_t __buflen ) ;
#line 191
extern  __attribute__((__nothrow__)) char *( __attribute__((__warn_unused_result__,
__leaf__)) __getcwd_alias)(char *__buf , size_t __size )  __asm__("getcwd")  ;
#line 193
extern  __attribute__((__nothrow__)) char *( __attribute__((__warn_unused_result__,
__leaf__)) __getcwd_chk_warn)(char *__buf , size_t __size , size_t __buflen )  __asm__("__getcwd_chk") __attribute__((__warning__("getcwd caller with bigger length than size of destination buffer"))) ;
#line 199
__inline extern  __attribute__((__nothrow__)) char *( __attribute__((__warn_unused_result__,
__leaf__, __artificial__, __always_inline__)) getcwd)(char *__buf , size_t __size ) ;
#line 199 "/usr/include/x86_64-linux-gnu/bits/unistd.h"
__inline extern char *( __attribute__((__warn_unused_result__, __leaf__, __artificial__,
__always_inline__)) getcwd)(char *__buf , size_t __size ) 
{ 
  unsigned long tmp ;
  char *tmp___0 ;
  unsigned long tmp___1 ;
  char *tmp___2 ;
  unsigned long tmp___3 ;
  unsigned long tmp___4 ;
  char *tmp___5 ;

  {
#line 202
  tmp___4 = __builtin_object_size((void *)__buf, 1);
#line 202
  if (tmp___4 != 0xffffffffffffffffUL) {
#line 205
    tmp = __builtin_object_size((void *)__buf, 1);
#line 205
    tmp___0 = __getcwd_chk(__buf, __size, tmp);
#line 205
    return (tmp___0);
#line 207
    tmp___3 = __builtin_object_size((void *)__buf, 1);
#line 207
    if (__size > tmp___3) {
#line 208
      tmp___1 = __builtin_object_size((void *)__buf, 1);
#line 208
      tmp___2 = __getcwd_chk_warn(__buf, __size, tmp___1);
#line 208
      return (tmp___2);
    }
  }
#line 210
  tmp___5 = __getcwd_alias(__buf, __size);
#line 210
  return (tmp___5);
}
}
#line 214
extern  __attribute__((__nothrow__)) char *( __attribute__((__warn_unused_result__,
__nonnull__(1), __leaf__)) __getwd_chk)(char *__buf , size_t buflen ) ;
#line 216
extern  __attribute__((__nothrow__)) char *( __attribute__((__warn_unused_result__,
__nonnull__(1), __leaf__)) __getwd_warn)(char *__buf )  __asm__("getwd") __attribute__((__warning__("please use getcwd instead, as getwd doesn\'t specify buffer size"))) ;
#line 220
__inline extern  __attribute__((__nothrow__)) char __attribute__((__deprecated__))  *( __attribute__((__warn_unused_result__,
__nonnull__(1), __leaf__, __artificial__, __always_inline__)) getwd)(char *__buf )  __attribute__((__deprecated__)) ;
#line 220 "/usr/include/x86_64-linux-gnu/bits/unistd.h"
__inline extern char __attribute__((__deprecated__))  *( __attribute__((__warn_unused_result__,
__nonnull__(1), __leaf__, __artificial__, __always_inline__)) getwd)(char *__buf ) 
{ 
  unsigned long tmp ;
  char *tmp___0 ;
  unsigned long tmp___1 ;
  char *tmp___2 ;

  {
#line 223
  tmp___1 = __builtin_object_size((void *)__buf, 1);
#line 223
  if (tmp___1 != 0xffffffffffffffffUL) {
#line 224
    tmp = __builtin_object_size((void *)__buf, 1);
#line 224
    tmp___0 = __getwd_chk(__buf, tmp);
#line 224
    return ((char __attribute__((__deprecated__))  *)tmp___0);
  }
#line 225
  tmp___2 = __getwd_warn(__buf);
#line 225
  return ((char __attribute__((__deprecated__))  *)tmp___2);
}
}
#line 229
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__leaf__)) __confstr_chk)(int __name ,
                                                                                       char *__buf ,
                                                                                       size_t __len ,
                                                                                       size_t __buflen ) ;
#line 231
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__leaf__)) __confstr_alias)(int __name ,
                                                                                         char *__buf ,
                                                                                         size_t __len )  __asm__("confstr")  ;
#line 233
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__leaf__)) __confstr_chk_warn)(int __name ,
                                                                                            char *__buf ,
                                                                                            size_t __len ,
                                                                                            size_t __buflen )  __asm__("__confstr_chk") __attribute__((__warning__("confstr called with bigger length than size of destination buffer"))) ;
#line 239
__inline extern  __attribute__((__nothrow__)) size_t ( __attribute__((__leaf__, __artificial__,
__always_inline__)) confstr)(int __name , char *__buf , size_t __len ) ;
#line 239 "/usr/include/x86_64-linux-gnu/bits/unistd.h"
__inline extern size_t ( __attribute__((__leaf__, __artificial__, __always_inline__)) confstr)(int __name ,
                                                                                               char *__buf ,
                                                                                               size_t __len ) 
{ 
  unsigned long tmp ;
  size_t tmp___0 ;
  unsigned long tmp___1 ;
  size_t tmp___2 ;
  unsigned long tmp___3 ;
  unsigned long tmp___4 ;
  size_t tmp___5 ;

  {
#line 242
  tmp___4 = __builtin_object_size((void *)__buf, 1);
#line 242
  if (tmp___4 != 0xffffffffffffffffUL) {
#line 245
    tmp = __builtin_object_size((void *)__buf, 1);
#line 245
    tmp___0 = __confstr_chk(__name, __buf, __len, tmp);
#line 245
    return (tmp___0);
#line 247
    tmp___3 = __builtin_object_size((void *)__buf, 1);
#line 247
    if (tmp___3 < __len) {
#line 248
      tmp___1 = __builtin_object_size((void *)__buf, 1);
#line 248
      tmp___2 = __confstr_chk_warn(__name, __buf, __len, tmp___1);
#line 248
      return (tmp___2);
    }
  }
#line 250
  tmp___5 = __confstr_alias(__name, __buf, __len);
#line 250
  return (tmp___5);
}
}
#line 254
extern  __attribute__((__nothrow__)) int ( __attribute__((__warn_unused_result__,
__leaf__)) __getgroups_chk)(int __size , __gid_t *__list , size_t __listlen ) ;
#line 256
extern  __attribute__((__nothrow__)) int ( __attribute__((__warn_unused_result__,
__leaf__)) __getgroups_alias)(int __size , __gid_t *__list )  __asm__("getgroups")  ;
#line 258
extern  __attribute__((__nothrow__)) int ( __attribute__((__warn_unused_result__,
__leaf__)) __getgroups_chk_warn)(int __size , __gid_t *__list , size_t __listlen )  __asm__("__getgroups_chk") __attribute__((__warning__("getgroups called with bigger group count than what can fit into destination buffer"))) ;
#line 264
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__warn_unused_result__,
__leaf__, __artificial__, __always_inline__)) getgroups)(int __size , __gid_t *__list ) ;
#line 264 "/usr/include/x86_64-linux-gnu/bits/unistd.h"
__inline extern int ( __attribute__((__warn_unused_result__, __leaf__, __artificial__,
__always_inline__)) getgroups)(int __size , __gid_t *__list ) 
{ 
  unsigned long tmp ;
  int tmp___0 ;
  unsigned long tmp___1 ;
  int tmp___2 ;
  unsigned long tmp___3 ;
  unsigned long tmp___4 ;
  int tmp___5 ;

  {
#line 267
  tmp___4 = __builtin_object_size((void *)__list, 1);
#line 267
  if (tmp___4 != 0xffffffffffffffffUL) {
#line 270
    tmp = __builtin_object_size((void *)__list, 1);
#line 270
    tmp___0 = __getgroups_chk(__size, __list, tmp);
#line 270
    return (tmp___0);
#line 272
    tmp___3 = __builtin_object_size((void *)__list, 1);
#line 272
    if ((unsigned long )__size * sizeof(__gid_t ) > tmp___3) {
#line 273
      tmp___1 = __builtin_object_size((void *)__list, 1);
#line 273
      tmp___2 = __getgroups_chk_warn(__size, __list, tmp___1);
#line 273
      return (tmp___2);
    }
  }
#line 275
  tmp___5 = __getgroups_alias(__size, __list);
#line 275
  return (tmp___5);
}
}
#line 279
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2), __leaf__)) __ttyname_r_chk)(int __fd ,
                                                                                                      char *__buf ,
                                                                                                      size_t __buflen ,
                                                                                                      size_t __nreal ) ;
#line 281
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2), __leaf__)) __ttyname_r_alias)(int __fd ,
                                                                                                        char *__buf ,
                                                                                                        size_t __buflen )  __asm__("ttyname_r")  ;
#line 284
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2), __leaf__)) __ttyname_r_chk_warn)(int __fd ,
                                                                                                           char *__buf ,
                                                                                                           size_t __buflen ,
                                                                                                           size_t __nreal )  __asm__("__ttyname_r_chk") __attribute__((__warning__("ttyname_r called with bigger buflen than size of destination buffer"))) ;
#line 290
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__warn_unused_result__,
__nonnull__(2), __leaf__, __artificial__, __always_inline__)) ttyname_r)(int __fd ,
                                                                         char *__buf ,
                                                                         size_t __buflen ) ;
#line 290 "/usr/include/x86_64-linux-gnu/bits/unistd.h"
__inline extern int ( __attribute__((__warn_unused_result__, __nonnull__(2), __leaf__,
__artificial__, __always_inline__)) ttyname_r)(int __fd , char *__buf , size_t __buflen ) 
{ 
  unsigned long tmp ;
  int tmp___0 ;
  unsigned long tmp___1 ;
  int tmp___2 ;
  unsigned long tmp___3 ;
  unsigned long tmp___4 ;
  int tmp___5 ;

  {
#line 293
  tmp___4 = __builtin_object_size((void *)__buf, 1);
#line 293
  if (tmp___4 != 0xffffffffffffffffUL) {
#line 296
    tmp = __builtin_object_size((void *)__buf, 1);
#line 296
    tmp___0 = __ttyname_r_chk(__fd, __buf, __buflen, tmp);
#line 296
    return (tmp___0);
#line 298
    tmp___3 = __builtin_object_size((void *)__buf, 1);
#line 298
    if (__buflen > tmp___3) {
#line 299
      tmp___1 = __builtin_object_size((void *)__buf, 1);
#line 299
      tmp___2 = __ttyname_r_chk_warn(__fd, __buf, __buflen, tmp___1);
#line 299
      return (tmp___2);
    }
  }
#line 301
  tmp___5 = __ttyname_r_alias(__fd, __buf, __buflen);
#line 301
  return (tmp___5);
}
}
#line 306
extern int ( __attribute__((__nonnull__(1))) __getlogin_r_chk)(char *__buf , size_t __buflen ,
                                                               size_t __nreal ) ;
#line 308
extern int ( __attribute__((__nonnull__(1))) __getlogin_r_alias)(char *__buf , size_t __buflen )  __asm__("getlogin_r")  ;
#line 310
extern int ( __attribute__((__nonnull__(1))) __getlogin_r_chk_warn)(char *__buf ,
                                                                    size_t __buflen ,
                                                                    size_t __nreal )  __asm__("__getlogin_r_chk") __attribute__((__warning__("getlogin_r called with bigger buflen than size of destination buffer"))) ;
#line 316 "/usr/include/x86_64-linux-gnu/bits/unistd.h"
__inline extern int ( __attribute__((__nonnull__(1), __artificial__, __always_inline__)) getlogin_r)(char *__buf ,
                                                                                                     size_t __buflen ) 
{ 
  unsigned long tmp ;
  int tmp___0 ;
  unsigned long tmp___1 ;
  int tmp___2 ;
  unsigned long tmp___3 ;
  unsigned long tmp___4 ;
  int tmp___5 ;

  {
#line 319
  tmp___4 = __builtin_object_size((void *)__buf, 1);
#line 319
  if (tmp___4 != 0xffffffffffffffffUL) {
#line 322
    tmp = __builtin_object_size((void *)__buf, 1);
#line 322
    tmp___0 = __getlogin_r_chk(__buf, __buflen, tmp);
#line 322
    return (tmp___0);
#line 324
    tmp___3 = __builtin_object_size((void *)__buf, 1);
#line 324
    if (__buflen > tmp___3) {
#line 325
      tmp___1 = __builtin_object_size((void *)__buf, 1);
#line 325
      tmp___2 = __getlogin_r_chk_warn(__buf, __buflen, tmp___1);
#line 325
      return (tmp___2);
    }
  }
#line 327
  tmp___5 = __getlogin_r_alias(__buf, __buflen);
#line 327
  return (tmp___5);
}
}
#line 333
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) __gethostname_chk)(char *__buf ,
                                                                                                        size_t __buflen ,
                                                                                                        size_t __nreal ) ;
#line 335
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) __gethostname_alias)(char *__buf ,
                                                                                                          size_t __buflen )  __asm__("gethostname")  ;
#line 337
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) __gethostname_chk_warn)(char *__buf ,
                                                                                                             size_t __buflen ,
                                                                                                             size_t __nreal )  __asm__("__gethostname_chk") __attribute__((__warning__("gethostname called with bigger buflen than size of destination buffer"))) ;
#line 343
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1),
__leaf__, __artificial__, __always_inline__)) gethostname)(char *__buf , size_t __buflen ) ;
#line 343 "/usr/include/x86_64-linux-gnu/bits/unistd.h"
__inline extern int ( __attribute__((__nonnull__(1), __leaf__, __artificial__, __always_inline__)) gethostname)(char *__buf ,
                                                                                                                size_t __buflen ) 
{ 
  unsigned long tmp ;
  int tmp___0 ;
  unsigned long tmp___1 ;
  int tmp___2 ;
  unsigned long tmp___3 ;
  unsigned long tmp___4 ;
  int tmp___5 ;

  {
#line 346
  tmp___4 = __builtin_object_size((void *)__buf, 1);
#line 346
  if (tmp___4 != 0xffffffffffffffffUL) {
#line 349
    tmp = __builtin_object_size((void *)__buf, 1);
#line 349
    tmp___0 = __gethostname_chk(__buf, __buflen, tmp);
#line 349
    return (tmp___0);
#line 351
    tmp___3 = __builtin_object_size((void *)__buf, 1);
#line 351
    if (__buflen > tmp___3) {
#line 352
      tmp___1 = __builtin_object_size((void *)__buf, 1);
#line 352
      tmp___2 = __gethostname_chk_warn(__buf, __buflen, tmp___1);
#line 352
      return (tmp___2);
    }
  }
#line 354
  tmp___5 = __gethostname_alias(__buf, __buflen);
#line 354
  return (tmp___5);
}
}
#line 360
extern  __attribute__((__nothrow__)) int ( __attribute__((__warn_unused_result__,
__nonnull__(1), __leaf__)) __getdomainname_chk)(char *__buf , size_t __buflen , size_t __nreal ) ;
#line 362
extern  __attribute__((__nothrow__)) int ( __attribute__((__warn_unused_result__,
__nonnull__(1), __leaf__)) __getdomainname_alias)(char *__buf , size_t __buflen )  __asm__("getdomainname")  ;
#line 365
extern  __attribute__((__nothrow__)) int ( __attribute__((__warn_unused_result__,
__nonnull__(1), __leaf__)) __getdomainname_chk_warn)(char *__buf , size_t __buflen ,
                                                     size_t __nreal )  __asm__("__getdomainname_chk") __attribute__((__warning__("getdomainname called with bigger buflen than size of destination buffer"))) ;
#line 372
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__warn_unused_result__,
__nonnull__(1), __leaf__, __artificial__, __always_inline__)) getdomainname)(char *__buf ,
                                                                             size_t __buflen ) ;
#line 372 "/usr/include/x86_64-linux-gnu/bits/unistd.h"
__inline extern int ( __attribute__((__warn_unused_result__, __nonnull__(1), __leaf__,
__artificial__, __always_inline__)) getdomainname)(char *__buf , size_t __buflen ) 
{ 
  unsigned long tmp ;
  int tmp___0 ;
  unsigned long tmp___1 ;
  int tmp___2 ;
  unsigned long tmp___3 ;
  unsigned long tmp___4 ;
  int tmp___5 ;

  {
#line 375
  tmp___4 = __builtin_object_size((void *)__buf, 1);
#line 375
  if (tmp___4 != 0xffffffffffffffffUL) {
#line 378
    tmp = __builtin_object_size((void *)__buf, 1);
#line 378
    tmp___0 = __getdomainname_chk(__buf, __buflen, tmp);
#line 378
    return (tmp___0);
#line 380
    tmp___3 = __builtin_object_size((void *)__buf, 1);
#line 380
    if (__buflen > tmp___3) {
#line 381
      tmp___1 = __builtin_object_size((void *)__buf, 1);
#line 381
      tmp___2 = __getdomainname_chk_warn(__buf, __buflen, tmp___1);
#line 381
      return (tmp___2);
    }
  }
#line 383
  tmp___5 = __getdomainname_alias(__buf, __buflen);
#line 383
  return (tmp___5);
}
}
#line 465 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__warn_unused_result__,
__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 467
extern  __attribute__((__nothrow__)) void *( __attribute__((__warn_unused_result__,
__leaf__)) calloc)(size_t __nmemb , size_t __size )  __attribute__((__malloc__)) ;
#line 479
extern  __attribute__((__nothrow__)) void *( __attribute__((__warn_unused_result__,
__leaf__)) realloc)(void *__ptr , size_t __size ) ;
#line 482
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 733
__inline extern  __attribute__((__nothrow__)) char *( __attribute__((__warn_unused_result__,
__leaf__, __artificial__, __always_inline__)) realpath)(char const   * __restrict  __name ,
                                                        char * __restrict  __resolved ) ;
#line 866
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__warn_unused_result__,
__leaf__, __artificial__, __always_inline__)) wctomb)(char *__s , wchar_t __wchar ) ;
#line 870
__inline extern  __attribute__((__nothrow__)) size_t ( __attribute__((__leaf__, __artificial__,
__always_inline__)) mbstowcs)(wchar_t * __restrict  __dst , char const   * __restrict  __src ,
                              size_t __len ) ;
#line 873
__inline extern  __attribute__((__nothrow__)) size_t ( __attribute__((__leaf__, __artificial__,
__always_inline__)) wcstombs)(char * __restrict  __dst , wchar_t const   * __restrict  __src ,
                              size_t __len ) ;
#line 23 "/usr/include/x86_64-linux-gnu/bits/stdlib.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__warn_unused_result__,
__leaf__)) __realpath_chk)(char const   * __restrict  __name , char * __restrict  __resolved ,
                           size_t __resolvedlen ) ;
#line 26
extern  __attribute__((__nothrow__)) char *( __attribute__((__warn_unused_result__,
__leaf__)) __realpath_alias)(char const   * __restrict  __name , char * __restrict  __resolved )  __asm__("realpath")  ;
#line 36
__inline extern  __attribute__((__nothrow__)) char *( __attribute__((__warn_unused_result__,
__leaf__, __artificial__, __always_inline__)) realpath)(char const   * __restrict  __name ,
                                                        char * __restrict  __resolved ) ;
#line 36 "/usr/include/x86_64-linux-gnu/bits/stdlib.h"
__inline extern char *( __attribute__((__warn_unused_result__, __leaf__, __artificial__,
__always_inline__)) realpath)(char const   * __restrict  __name , char * __restrict  __resolved ) 
{ 
  unsigned long tmp ;
  char *tmp___0 ;
  unsigned long tmp___1 ;
  char *tmp___2 ;

  {
#line 39
  tmp___1 = __builtin_object_size((void *)__resolved, 1);
#line 39
  if (tmp___1 != 0xffffffffffffffffUL) {
#line 45
    tmp = __builtin_object_size((void *)__resolved, 1);
#line 45
    tmp___0 = __realpath_chk(__name, __resolved, tmp);
#line 45
    return (tmp___0);
  }
#line 48
  tmp___2 = __realpath_alias(__name, __resolved);
#line 48
  return (tmp___2);
}
}
#line 52
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2), __leaf__)) __ptsname_r_chk)(int __fd ,
                                                                                                      char *__buf ,
                                                                                                      size_t __buflen ,
                                                                                                      size_t __nreal ) ;
#line 54
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2), __leaf__)) __ptsname_r_alias)(int __fd ,
                                                                                                        char *__buf ,
                                                                                                        size_t __buflen )  __asm__("ptsname_r")  ;
#line 57
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2), __leaf__)) __ptsname_r_chk_warn)(int __fd ,
                                                                                                           char *__buf ,
                                                                                                           size_t __buflen ,
                                                                                                           size_t __nreal )  __asm__("__ptsname_r_chk") __attribute__((__warning__("ptsname_r called with buflen bigger than size of buf"))) ;
#line 63
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__, __artificial__,
__always_inline__)) ptsname_r)(int __fd , char *__buf , size_t __buflen ) ;
#line 63 "/usr/include/x86_64-linux-gnu/bits/stdlib.h"
__inline extern int ( __attribute__((__leaf__, __artificial__, __always_inline__)) ptsname_r)(int __fd ,
                                                                                              char *__buf ,
                                                                                              size_t __buflen ) 
{ 
  unsigned long tmp ;
  int tmp___0 ;
  unsigned long tmp___1 ;
  int tmp___2 ;
  unsigned long tmp___3 ;
  unsigned long tmp___4 ;
  int tmp___5 ;

  {
#line 66
  tmp___4 = __builtin_object_size((void *)__buf, 1);
#line 66
  if (tmp___4 != 0xffffffffffffffffUL) {
#line 69
    tmp = __builtin_object_size((void *)__buf, 1);
#line 69
    tmp___0 = __ptsname_r_chk(__fd, __buf, __buflen, tmp);
#line 69
    return (tmp___0);
#line 70
    tmp___3 = __builtin_object_size((void *)__buf, 1);
#line 70
    if (__buflen > tmp___3) {
#line 71
      tmp___1 = __builtin_object_size((void *)__buf, 1);
#line 71
      tmp___2 = __ptsname_r_chk_warn(__fd, __buf, __buflen, tmp___1);
#line 71
      return (tmp___2);
    }
  }
#line 73
  tmp___5 = __ptsname_r_alias(__fd, __buf, __buflen);
#line 73
  return (tmp___5);
}
}
#line 77
extern  __attribute__((__nothrow__)) int ( __attribute__((__warn_unused_result__,
__leaf__)) __wctomb_chk)(char *__s , wchar_t __wchar , size_t __buflen ) ;
#line 79
extern  __attribute__((__nothrow__)) int ( __attribute__((__warn_unused_result__,
__leaf__)) __wctomb_alias)(char *__s , wchar_t __wchar )  __asm__("wctomb")  ;
#line 82
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__warn_unused_result__,
__leaf__, __artificial__, __always_inline__)) wctomb)(char *__s , wchar_t __wchar ) ;
#line 82 "/usr/include/x86_64-linux-gnu/bits/stdlib.h"
__inline extern int ( __attribute__((__warn_unused_result__, __leaf__, __artificial__,
__always_inline__)) wctomb)(char *__s , wchar_t __wchar ) 
{ 
  unsigned long tmp ;
  int tmp___0 ;
  unsigned long tmp___1 ;
  unsigned long tmp___2 ;
  int tmp___3 ;

  {
#line 92
  tmp___1 = __builtin_object_size((void *)__s, 1);
#line 92
  if (tmp___1 != 0xffffffffffffffffUL) {
#line 92
    tmp___2 = __builtin_object_size((void *)__s, 1);
#line 92
    if (16UL > tmp___2) {
#line 93
      tmp = __builtin_object_size((void *)__s, 1);
#line 93
      tmp___0 = __wctomb_chk(__s, __wchar, tmp);
#line 93
      return (tmp___0);
    }
  }
#line 94
  tmp___3 = __wctomb_alias(__s, __wchar);
#line 94
  return (tmp___3);
}
}
#line 98
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__leaf__)) __mbstowcs_chk)(wchar_t * __restrict  __dst ,
                                                                                        char const   * __restrict  __src ,
                                                                                        size_t __len ,
                                                                                        size_t __dstlen ) ;
#line 101
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__leaf__)) __mbstowcs_alias)(wchar_t * __restrict  __dst ,
                                                                                          char const   * __restrict  __src ,
                                                                                          size_t __len )  __asm__("mbstowcs")  ;
#line 105
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__leaf__)) __mbstowcs_chk_warn)(wchar_t * __restrict  __dst ,
                                                                                             char const   * __restrict  __src ,
                                                                                             size_t __len ,
                                                                                             size_t __dstlen )  __asm__("__mbstowcs_chk") __attribute__((__warning__("mbstowcs called with dst buffer smaller than len * sizeof (wchar_t)"))) ;
#line 112
__inline extern  __attribute__((__nothrow__)) size_t ( __attribute__((__leaf__, __artificial__,
__always_inline__)) mbstowcs)(wchar_t * __restrict  __dst , char const   * __restrict  __src ,
                              size_t __len ) ;
#line 112 "/usr/include/x86_64-linux-gnu/bits/stdlib.h"
__inline extern size_t ( __attribute__((__leaf__, __artificial__, __always_inline__)) mbstowcs)(wchar_t * __restrict  __dst ,
                                                                                                char const   * __restrict  __src ,
                                                                                                size_t __len ) 
{ 
  unsigned long tmp ;
  size_t tmp___0 ;
  unsigned long tmp___1 ;
  size_t tmp___2 ;
  unsigned long tmp___3 ;
  unsigned long tmp___4 ;
  size_t tmp___5 ;

  {
#line 116
  tmp___4 = __builtin_object_size((void *)__dst, 1);
#line 116
  if (tmp___4 != 0xffffffffffffffffUL) {
#line 119
    tmp = __builtin_object_size((void *)__dst, 1);
#line 119
    tmp___0 = __mbstowcs_chk(__dst, __src, __len, tmp / sizeof(wchar_t ));
#line 119
    return (tmp___0);
#line 122
    tmp___3 = __builtin_object_size((void *)__dst, 1);
#line 122
    if (__len > tmp___3 / sizeof(wchar_t )) {
#line 123
      tmp___1 = __builtin_object_size((void *)__dst, 1);
#line 123
      tmp___2 = __mbstowcs_chk_warn(__dst, __src, __len, tmp___1 / sizeof(wchar_t ));
#line 123
      return (tmp___2);
    }
  }
#line 126
  tmp___5 = __mbstowcs_alias(__dst, __src, __len);
#line 126
  return (tmp___5);
}
}
#line 130
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__leaf__)) __wcstombs_chk)(char * __restrict  __dst ,
                                                                                        wchar_t const   * __restrict  __src ,
                                                                                        size_t __len ,
                                                                                        size_t __dstlen ) ;
#line 133
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__leaf__)) __wcstombs_alias)(char * __restrict  __dst ,
                                                                                          wchar_t const   * __restrict  __src ,
                                                                                          size_t __len )  __asm__("wcstombs")  ;
#line 137
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__leaf__)) __wcstombs_chk_warn)(char * __restrict  __dst ,
                                                                                             wchar_t const   * __restrict  __src ,
                                                                                             size_t __len ,
                                                                                             size_t __dstlen )  __asm__("__wcstombs_chk") __attribute__((__warning__("wcstombs called with dst buffer smaller than len"))) ;
#line 143
__inline extern  __attribute__((__nothrow__)) size_t ( __attribute__((__leaf__, __artificial__,
__always_inline__)) wcstombs)(char * __restrict  __dst , wchar_t const   * __restrict  __src ,
                              size_t __len ) ;
#line 143 "/usr/include/x86_64-linux-gnu/bits/stdlib.h"
__inline extern size_t ( __attribute__((__leaf__, __artificial__, __always_inline__)) wcstombs)(char * __restrict  __dst ,
                                                                                                wchar_t const   * __restrict  __src ,
                                                                                                size_t __len ) 
{ 
  unsigned long tmp ;
  size_t tmp___0 ;
  unsigned long tmp___1 ;
  size_t tmp___2 ;
  unsigned long tmp___3 ;
  unsigned long tmp___4 ;
  size_t tmp___5 ;

  {
#line 147
  tmp___4 = __builtin_object_size((void *)__dst, 1);
#line 147
  if (tmp___4 != 0xffffffffffffffffUL) {
#line 150
    tmp = __builtin_object_size((void *)__dst, 1);
#line 150
    tmp___0 = __wcstombs_chk(__dst, __src, __len, tmp);
#line 150
    return (tmp___0);
#line 151
    tmp___3 = __builtin_object_size((void *)__dst, 1);
#line 151
    if (__len > tmp___3) {
#line 152
      tmp___1 = __builtin_object_size((void *)__dst, 1);
#line 152
      tmp___2 = __wcstombs_chk_warn(__dst, __src, __len, tmp___1);
#line 152
      return (tmp___2);
    }
  }
#line 154
  tmp___5 = __wcstombs_alias(__dst, __src, __len);
#line 154
  return (tmp___5);
}
}
#line 26 "snprintf.h"
int vasprintf(char **ptr , char const   *fmt , va_list ap ) ;
#line 50 "gui.c"
void *resize(int a ) ;
#line 55 "gui.c"
void *resize(int a ) 
{ 
  struct winsize size ;
  int maxy ;
  int maxx ;

  {
#line 58
  ioctl(1, 21523UL, & size);
#line 59
  resize_term((int )size.ws_row, (int )size.ws_col);
#line 61
  if (stdscr) {
#line 61
    maxy = (int )stdscr->_maxy + 1;
  } else {
#line 61
    maxy = -1;
  }
#line 61
  if (stdscr) {
#line 61
    maxx = (int )stdscr->_maxx + 1;
  } else {
#line 61
    maxx = -1;
  }
#line 62
  wresize(inputwin, 1, maxx);
#line 63
  wresize(outputwin, maxy - 1, maxx);
#line 64
  wresize(statuswin, 1, maxx);
#line 65
  mvwin(inputwin, maxy - 1, 0);
#line 66
  mvwin(inputwin, maxy - 2, 0);
#line 67
  wclear(outputwin);
#line 68
  wrefresh(outputwin);
#line 69
  wrefresh(inputwin);
#line 70
  wrefresh(statuswin);
#line 74
  signal(28, (void (*)(int  ))(& resize));
#line 75
  return ((void *)0);
}
}
#line 91 "gui.c"
void startgui(void) 
{ 
  _Bool tmp ;
  int maxy ;
  int maxx ;

  {
#line 93
  initscr();
#line 94
  tmp = has_colors();
#line 94
  if (tmp) {
#line 96
    start_color();
#line 100
    init_pair((short)0, (short)0, (short)0);
#line 101
    init_pair((short)2, (short)2, (short)0);
#line 102
    init_pair((short)1, (short)1, (short)0);
#line 103
    init_pair((short)6, (short)6, (short)0);
#line 104
    init_pair((short)7, (short)7, (short)0);
#line 105
    init_pair((short)5, (short)5, (short)0);
#line 106
    init_pair((short)4, (short)4, (short)0);
#line 107
    init_pair((short)3, (short)3, (short)0);
  }
#line 109
  cbreak();
#line 110
  noecho();
#line 111
  keypad(stdscr, (_Bool)1);
#line 113
  if (stdscr) {
#line 113
    maxy = (int )stdscr->_maxy + 1;
  } else {
#line 113
    maxy = -1;
  }
#line 113
  if (stdscr) {
#line 113
    maxx = (int )stdscr->_maxx + 1;
  } else {
#line 113
    maxx = -1;
  }
#line 114
  outputwin = newwin(maxy - 1, 0, 0, 0);
#line 115
  inputwin = newwin(1, 0, maxy - 1, 0);
#line 116
  statuswin = newwin(1, 0, maxy - 2, 0);
#line 117
  scrollok(outputwin, (_Bool)1);
#line 118
  scrollok(inputwin, (_Bool)1);
#line 119
  scrollok(statuswin, (_Bool)0);
#line 120
  wattr_on(statuswin, 1UL << 18, (void *)0);
#line 122
  signal(28, (void (*)(int  ))(& resize));
#line 124
  return;
}
}
#line 126 "gui.c"
void wordwrap(char *s___0 ) 
{ 
  int mcol ;
  int row ;
  int col___0 ;
  char *ptr ;
  char *tmp ;
  char *buf ;
  void *tmp___0 ;
  int cols ;
  char *tmp___1 ;
  char *spc ;
  int n ;
  size_t tmp___2 ;

  {
#line 130
  if (outputwin) {
#line 130
    row = (int )outputwin->_cury;
  } else {
#line 130
    row = -1;
  }
#line 130
  if (outputwin) {
#line 130
    col___0 = (int )outputwin->_curx;
  } else {
#line 130
    col___0 = -1;
  }
#line 131
  tmp = strchr((char const   *)s___0, '\000');
#line 131
  ptr = tmp;
#line 132
  while ((unsigned long )ptr > (unsigned long )s___0) {
#line 134
    ptr --;
#line 135
    if ((int )*ptr == 10) {
#line 136
      *ptr = (char )'\000';
    } else
#line 135
    if ((int )*ptr == 32) {
#line 136
      *ptr = (char )'\000';
    } else {
#line 137
      break;
    }
  }
#line 140
  tmp___0 = calloc((size_t )2048, sizeof(char ));
#line 140
  buf = (char *)tmp___0;
#line 140
  if (! buf) {
#line 142
    guiprintf((char *)"");
  }
#line 143
  mcol = COLS - 1;
#line 144
  cols = mcol - col___0;
#line 145
  ptr = s___0;
#line 146
  while (1) {
#line 146
    tmp___2 = strlen((char const   *)ptr);
#line 146
    if (! (tmp___2 > (size_t )cols)) {
#line 146
      break;
    }
#line 148
    tmp___1 = strchr((char const   *)ptr, '\n');
#line 148
    if (tmp___1) {
#line 148
      break;
    }
#line 149
    spc = ptr + cols;
#line 150
    while ((unsigned long )spc > (unsigned long )ptr) {
#line 152
      if ((int )*spc == 32) {
#line 153
        break;
      } else {
#line 155
        spc --;
      }
    }
#line 157
    if ((unsigned long )spc > (unsigned long )ptr) {
#line 159
      n = (int )(spc - ptr);
#line 160
      strncat((char * __restrict  )buf, (char const   * __restrict  )ptr, (size_t )n);
#line 161
      strcatl(buf, "\n", (size_t )2048);
#line 162
      ptr = spc + 1;
#line 163
      while (1) {
#line 163
        if (*ptr) {
#line 163
          if (! ((int )*ptr == 32)) {
#line 163
            break;
          }
        } else {
#line 163
          break;
        }
#line 163
        ptr ++;
      }
#line 164
      cols = mcol;
    } else {
#line 168
      strncat((char * __restrict  )buf, (char const   * __restrict  )ptr, (size_t )cols);
#line 169
      strcatl(buf, "\n", (size_t )2048);
#line 170
      ptr += cols;
#line 171
      while (1) {
#line 171
        if (*ptr) {
#line 171
          if (! ((int )*ptr == 32)) {
#line 171
            break;
          }
        } else {
#line 171
          break;
        }
#line 171
        ptr ++;
      }
#line 172
      cols = mcol;
    }
  }
#line 175
  if ((unsigned long )ptr == (unsigned long )s___0) {
#line 177
    wprintw(outputwin, "%s", s___0);
  } else
#line 179
  if ((int )*ptr != 0) {
#line 181
    strcatl(buf, (char const   *)ptr, (size_t )2048);
#line 182
    wprintw(outputwin, "%s", buf);
  }
#line 184
  free((void *)buf);
#line 185
  return;
}
}
#line 187 "gui.c"
void endgui(void) 
{ 


  {
#line 189
  delwin(outputwin);
#line 190
  delwin(inputwin);
#line 191
  endwin();
#line 192
  return;
}
}
#line 198 "gui.c"
void guiprintf(char *fmt  , ...) 
{ 
  int maxx ;
  int maxy ;
  char *text ;
  void *tmp ;
  va_list ap ;

  {
#line 201
  tmp = malloc((size_t )4097);
#line 201
  text = (char *)tmp;
#line 203
  if (stdscr) {
#line 203
    maxy = (int )stdscr->_maxy + 1;
  } else {
#line 203
    maxy = -1;
  }
#line 203
  if (stdscr) {
#line 203
    maxx = (int )stdscr->_maxx + 1;
  } else {
#line 203
    maxx = -1;
  }
#line 204
  __builtin_va_start(ap, fmt);
#line 205
  vasprintf(& text, (gchar const   *)fmt, ap);
#line 206
  __builtin_va_end(ap);
#line 207
  wprintw(outputwin, (char const   *)text);
#line 208
  free((void *)text);
#line 209
  wrefresh(outputwin);
#line 210
  wrefresh(inputwin);
#line 211
  return;
}
}
#line 216 "gui.c"
int guigetln(char **text , int echo___0 ) 
{ 
  int c___0 ;
  int len ;
  void *tmp ;
  int y ;
  int x ;
  int tmp___0 ;
  void *tmp___1 ;
  int y___0 ;
  int x___0 ;
  int tmp___2 ;
  int i ;
  size_t tmp___3 ;
  void *tmp___4 ;
  size_t tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  void *tmp___8 ;
  char tmp___9 ;

  {
#line 218
  len = 0;
#line 219
  tmp = malloc(sizeof(char ));
#line 219
  *text = (char *)tmp;
#line 220
  while (1) {
#line 220
    c___0 = wgetch(inputwin);
#line 220
    if (! c___0) {
#line 220
      break;
    }
#line 222
    if (c___0 == 10) {
#line 224
      *(*text + len) = (char)0;
#line 225
      if (echo___0 != 0) {
#line 226
        wclear(inputwin);
      }
#line 227
      return (len);
    } else
#line 229
    if (c___0 == 260) {
#line 232
      if (inputwin) {
#line 232
        y = (int )inputwin->_cury;
      } else {
#line 232
        y = -1;
      }
#line 232
      if (inputwin) {
#line 232
        x = (int )inputwin->_curx;
      } else {
#line 232
        x = -1;
      }
#line 233
      tmp___0 = wmove(inputwin, y, x - 1);
#line 233
      if (! (tmp___0 == -1)) {
#line 233
        wdelch(inputwin);
      }
    } else
#line 235
    if (c___0 == 263) {
#line 235
      goto _L;
    } else {
#line 235
      tmp___9 = erasechar();
#line 235
      if (c___0 == (int )tmp___9) {
#line 235
        goto _L;
      } else
#line 235
      if (c___0 == 8) {
        _L: /* CIL Label */ 
#line 237
        if (len == 0) {
#line 238
          continue;
        }
#line 239
        len --;
#line 240
        *(*text + len) = (char)0;
#line 241
        tmp___1 = realloc((void *)*text, (unsigned long )(len + 1) * sizeof(char ));
#line 241
        *text = (char *)tmp___1;
#line 242
        if (echo___0 != 0) {
#line 245
          if (inputwin) {
#line 245
            y___0 = (int )inputwin->_cury;
          } else {
#line 245
            y___0 = -1;
          }
#line 245
          if (inputwin) {
#line 245
            x___0 = (int )inputwin->_curx;
          } else {
#line 245
            x___0 = -1;
          }
#line 246
          tmp___2 = wmove(inputwin, y___0, x___0 - 1);
#line 246
          if (! (tmp___2 == -1)) {
#line 246
            wdelch(inputwin);
          }
        }
      } else
#line 249
      if (c___0 == 9) {
#line 252
        i = 0;
#line 252
        while (1) {
#line 252
          tmp___7 = strarrlen(users);
#line 252
          if (! (i < tmp___7)) {
#line 252
            break;
          }
#line 253
          tmp___6 = strncmp((char const   *)*text, (char const   *)*(users + i), (size_t )len);
#line 253
          if (tmp___6 == 0) {
#line 255
            wclear(inputwin);
#line 256
            waddnstr(inputwin, (char const   *)*(users + i), -1);
#line 257
            waddnstr(inputwin, "> ", -1);
#line 258
            wrefresh(inputwin);
#line 259
            tmp___3 = strlen((char const   *)*(users + i));
#line 259
            len = (int )(tmp___3 + 2UL);
#line 260
            tmp___4 = realloc((void *)*text, (unsigned long )(len + 3) * sizeof(char ));
#line 260
            *text = (char *)tmp___4;
#line 261
            tmp___5 = strlen((char const   *)*(users + i));
#line 261
            strncpy((char * __restrict  )*text, (char const   * __restrict  )*(users + i),
                    tmp___5 + 1UL);
#line 262
            strncat((char * __restrict  )*text, (char const   * __restrict  )"> ",
                    (size_t )2);
#line 263
            break;
          }
#line 252
          i ++;
        }
      } else
#line 266
      if (c___0 == 15) {
#line 268
        wrefresh(outputwin);
#line 269
        wrefresh(inputwin);
#line 270
        wrefresh(statuswin);
      } else
#line 272
      if (c___0 >= 32) {
#line 274
        if (echo___0 != 0) {
#line 275
          waddch(inputwin, (chtype const   )c___0);
        }
#line 276
        *(*text + len) = (char )c___0;
#line 277
        len ++;
#line 278
        tmp___8 = realloc((void *)*text, (unsigned long )(len + 1) * sizeof(char ));
#line 278
        *text = (char *)tmp___8;
      }
    }
  }
#line 281
  return (0);
}
}
#line 1 "http.o"
#pragma merger("0","/tmp/cil-hih1uVHU.i","-Os,-fomit-frame-pointer,-fstack-protector-all")
#line 7 "strutil.h"
int StrLen(char *str ) ;
#line 8
int oasprintf(char **strp , char *fmt  , ...) ;
#line 9
char *substr(char *str , int start , size_t length ) ;
#line 140 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcmp)(char const   *__s1 ,
                                                                                               char const   *__s2 )  __attribute__((__pure__)) ;
#line 409
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) strerror)(int __errnum ) ;
#line 220 "/usr/include/x86_64-linux-gnu/sys/socket.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) getsockopt)(int __fd ,
                                                                                 int __level ,
                                                                                 int __optname ,
                                                                                 void * __restrict  __optval ,
                                                                                 socklen_t * __restrict  __optlen ) ;
#line 50 "/usr/include/x86_64-linux-gnu/bits/errno.h"
extern  __attribute__((__nothrow__)) int *( __attribute__((__leaf__)) __errno_location)(void)  __attribute__((__const__)) ;
#line 5 "tcp.h"
int tcp_connect(char *host , int port ) ;
#line 13 "http.c"
char *http_read(int socket___0 ) 
{ 
  char *c___0 ;
  char *p ;
  char *text ;
  size_t pos ;
  size_t alloc ;
  int rl ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  size_t tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;

  {
#line 15
  c___0 = (char *)((void *)0);
#line 15
  p = (char *)((void *)0);
#line 16
  text = (char *)((void *)0);
#line 17
  pos = (size_t )0;
#line 17
  alloc = (size_t )0;
#line 18
  rl = 0;
#line 19
  tmp = malloc((size_t )4);
#line 19
  c___0 = (char *)tmp;
#line 20
  bzero((void *)c___0, (size_t )2);
#line 21
  tmp___0 = malloc((size_t )1048576);
#line 21
  text = (char *)tmp___0;
#line 22
  alloc = (size_t )1048576;
#line 23
  bzero((void *)text, (size_t )6);
#line 24
  getsockopt(socket___0, 1, 4, (void * __restrict  )((void *)0), (socklen_t * __restrict  )((void *)0));
#line 28
  while (1) {
#line 28
    tmp___8 = (int )read(socket___0, c___0, 1);
#line 28
    if (! tmp___8) {
#line 28
      break;
    }
#line 34
    if (pos == alloc) {
#line 35
      tmp___1 = realloc((void *)text, alloc + 1048576UL);
#line 35
      p = (char *)tmp___1;
#line 36
      if ((unsigned long )p != (unsigned long )((void *)0)) {
#line 37
        text = p;
#line 38
        alloc = (size_t )1048576;
      } else {
#line 40
        tmp___2 = __errno_location();
#line 40
        tmp___3 = strerror(*tmp___2);
#line 40
        guiprintf("%s\n", tmp___3);
#line 40
        break;
      }
    }
#line 51
    *(text + pos) = *(c___0 + 0);
#line 52
    pos ++;
#line 57
    tmp___7 = StrLen(text);
#line 57
    if (tmp___7 > 3) {
#line 58
      tmp___4 = strlen((char const   *)text);
#line 58
      tmp___5 = substr(text, (int )(tmp___4 - 4UL), (size_t )4);
#line 58
      tmp___6 = strcmp((char const   *)tmp___5, "\r\n\r\n");
#line 58
      if (tmp___6 == 0) {
#line 59
        break;
      } else
#line 58
      if ((int )*(c___0 + 0) == 0) {
#line 59
        break;
      }
    }
  }
#line 64
  free((void *)c___0);
#line 65
  return (text);
}
}
#line 81
extern int ( /* missing proto */  write)() ;
#line 98
extern int close(int __fd ) ;
#line 71 "http.c"
int http_get(char *host , int port , char *file , char **header , char **body ) 
{ 
  int socket___0 ;
  char *request ;
  void *tmp ;
  size_t tmp___0 ;

  {
#line 74
  socket___0 = tcp_connect(host, port);
#line 74
  if (socket___0 < 0) {
#line 75
    return (socket___0);
  }
#line 76
  tmp = malloc((size_t )4097);
#line 76
  request = (char *)tmp;
#line 77
  oasprintf(& request, (char *)"GET %s HTTP/1.0\r\nAccept: */*\r\nAccept: text/html\r\n\r\n",
            file);
#line 81
  tmp___0 = strlen((char const   *)request);
#line 81
  write(socket___0, request, tmp___0);
#line 83
  free((void *)request);
#line 87
  *header = http_read(socket___0);
#line 91
  *body = http_read(socket___0);
#line 98
  close(socket___0);
#line 100
  return (0);
}
}
#line 1 "main.o"
#pragma merger("0","/tmp/cil-LKnMt34M.i","-Os,-fomit-frame-pointer,-fstack-protector-all")
#line 192 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) time_t ( __attribute__((__leaf__)) time)(time_t *__timer ) ;
#line 243
extern  __attribute__((__nothrow__)) struct tm *( __attribute__((__leaf__)) localtime)(time_t const   *__timer ) ;
#line 232 "/usr/include/pthread.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,3))) pthread_create)(pthread_t * __restrict  __newthread ,
                                                                                             pthread_attr_t const   * __restrict  __attr ,
                                                                                             void *(*__start_routine)(void * ) ,
                                                                                             void * __restrict  __arg ) ;
#line 241
extern  __attribute__((__noreturn__)) void pthread_exit(void *__retval ) ;
#line 237 "/usr/include/stdio.h"
extern int fclose(FILE *__stream ) ;
#line 272
extern FILE *( __attribute__((__warn_unused_result__)) fopen)(char const   * __restrict  __filename ,
                                                              char const   * __restrict  __modes ) ;
#line 531
extern int fgetc(FILE *__stream ) ;
#line 695
extern int puts(char const   *__s ) ;
#line 873
extern FILE *( __attribute__((__warn_unused_result__)) popen)(char const   *__command ,
                                                              char const   *__modes ) ;
#line 879
extern int pclose(FILE *__stream ) ;
#line 10 "strutil.h"
int split(char *separator , char *str , char ***array ) ;
#line 15
int strarrdel(char ***strarr , char *str ) ;
#line 21
int isUser(char **uA , char *uS ) ;
#line 22
int toggleIgnore(char ***uA , char *uS ) ;
#line 24
char **unserializeArray(char *fS ) ;
#line 172 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strdup)(char const   *__s )  __attribute__((__malloc__)) ;
#line 555
 __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strsep)(char ** __restrict  string ,
                                                                                          char const   * __restrict  delim ) ;
#line 24 "main.h"
void timestamp(void) ;
#line 25
void wrongopt(char *arg ) ;
#line 26
void showversion(void) ;
#line 27
void showhelp(int exitstatus ) ;
#line 28
void noarg(char *arg ) ;
#line 29
void printusers(void) ;
#line 30
void atlogout(void) ;
#line 31
void yrecvd(int service , char *content , int len ) ;
#line 32
void *recvthread(void) ;
#line 35
char *readline(FILE *f ) ;
#line 36
void loadignore(void) ;
#line 38
void readconfig(void) ;
#line 42
void debug_message(char *msg ) ;
#line 43
void updateroom(void) ;
#line 5 "ycht.h"
int yauth(char *username___0 , char *password , char **auth ) ;
#line 6
void yrecv(int socket___0 ) ;
#line 81 "/usr/include/x86_64-linux-gnu/sys/utsname.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) uname)(struct utsname *__name ) ;
#line 603 "/usr/include/unistd.h"
extern  __attribute__((__noreturn__)) void _exit(int __status ) ;
#line 628
extern  __attribute__((__nothrow__)) __pid_t ( __attribute__((__leaf__)) getpid)(void) ;
#line 542 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 563
extern  __attribute__((__nothrow__)) char *( __attribute__((__warn_unused_result__,
__nonnull__(1), __leaf__)) getenv)(char const   *__name ) ;
#line 21 "main.c"
char *defserver  =    (char *)0;
#line 21 "main.c"
char *defroom  =    (char *)0;
#line 21 "main.c"
char *defuser  =    (char *)0;
#line 21 "main.c"
char *groom  ;
#line 24 "main.c"
int connected  =    0;
#line 24 "main.c"
int logdin  =    0;
#line 24 "main.c"
int joindrom  =    0;
#line 36 "main.c"
void debug_message(char *msg ) 
{ 


  {
#line 38
  wattr_on(outputwin, (attr_t )(2 << 8), (void *)0);
#line 39
  guiprintf((char *)"DEBUG: %s\n", msg);
#line 40
  wattr_on(outputwin, (attr_t )(7 << 8), (void *)0);
#line 41
  return;
}
}
#line 43 "main.c"
void parselongopt(char *opt ) 
{ 
  int tmp___0 ;
  int tmp___1 ;

  {
#line 46
  if ((int )*(opt + 0) == 45) {
#line 46
    if ((int )*(opt + 1) == 45) {
#line 47
      opt ++;
#line 48
      opt ++;
#line 49
      tmp___0 = strcmp((char const   *)opt, "help");
#line 49
      if (tmp___0 == 0) {
#line 50
        showhelp(0);
      }
#line 52
      tmp___1 = strcmp((char const   *)opt, "version");
#line 52
      if (tmp___1 == 0) {
#line 53
        showversion();
#line 54
        exit(0);
      } else {
#line 56
        opt --;
#line 57
        opt --;
#line 58
        wrongopt(opt);
      }
    } else {
#line 61
      opt --;
#line 62
      opt --;
#line 63
      wrongopt(opt);
    }
  } else {
#line 61
    opt --;
#line 62
    opt --;
#line 63
    wrongopt(opt);
  }
#line 65
  return;
}
}
#line 67 "main.c"
void wrongopt(char *arg ) 
{ 


  {
#line 69
  printf((char const   * __restrict  )"Unknown option: %s\n", arg);
#line 70
  showhelp(1);
#line 71
  return;
}
}
#line 73 "main.c"
void noarg(char *arg ) 
{ 


  {
#line 75
  printf((char const   * __restrict  )"Option requires an argument: %s\n", arg);
#line 76
  showhelp(1);
#line 77
  return;
}
}
#line 79 "main.c"
void showversion(void) 
{ 
  struct utsname uts ;

  {
#line 84
  printf((char const   * __restrict  )"Overdose version 0.3\n");
#line 85
  printf((char const   * __restrict  )"Copyright (C) 2006 Segin\n");
#line 86
  printf((char const   * __restrict  )"Built on a x86_64 box running Linux 3.8.0-32-generic.\n");
#line 90
  uname(& uts);
#line 91
  printf((char const   * __restrict  )"Current running system is %s %s %s.\n", uts.sysname,
         uts.release, uts.machine);
#line 94
  return;
}
}
#line 96 "main.c"
void showhelp(int exitstatus ) 
{ 


  {
#line 98
  showversion();
#line 99
  puts("POSIX (short) options:\n\n\t-r <room>\tAutomatically join specified room after login.\n\t-s <server>\tAutomatically connect to the specified server.\n\t-u <user>\tLogin as the specified user.\n\nGNU long options:\n\n\t--help\t\tShows this help screen.\n\t--version\tShows the version and quits.\n");
#line 109
  exit(exitstatus);
}
}
#line 112 "main.c"
void parseargs(int argc , char **argv ) 
{ 
  int x ;
  int y ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 114
  y = 0;
#line 115
  if (argc == 0) {
#line 115
    return;
  }
#line 116
  x = 0;
#line 116
  while (x < argc) {
#line 117
    if ((int )*(*(argv + (x + y)) + 0) == 45) {
#line 118
      tmp = strcmp((char const   *)*(argv + (x + y)), "-u");
#line 118
      if (tmp == 0) {
#line 119
        if ((unsigned long )*(argv + ((x + y) + 1)) != (unsigned long )((void *)0)) {
#line 120
          defuser = strdup((char const   *)*(argv + ((x + y) + 1)));
#line 121
          y ++;
        } else {
#line 123
          noarg(*(argv + (x + y)));
        }
      }
#line 126
      tmp___0 = strcmp((char const   *)*(argv + (x + y)), "-s");
#line 126
      if (tmp___0 == 0) {
#line 127
        if ((unsigned long )*(argv + ((x + y) + 1)) != (unsigned long )((void *)0)) {
#line 128
          defserver = strdup((char const   *)*(argv + ((x + y) + 1)));
#line 129
          y ++;
        } else {
#line 131
          noarg(*(argv + (x + y)));
        }
      }
#line 134
      tmp___1 = strcmp((char const   *)*(argv + (x + y)), "-r");
#line 134
      if (tmp___1 == 0) {
#line 135
        if ((unsigned long )*(argv + ((x + y) + 1)) != (unsigned long )((void *)0)) {
#line 136
          defroom = strdup((char const   *)*(argv + ((x + y) + 1)));
#line 137
          y ++;
        } else {
#line 139
          noarg(*(argv + (x + y)));
        }
      }
#line 142
      if ((int )*(*(argv + (x + y)) + 1) == 45) {
#line 143
        if ((int )*(*(argv + (x + y)) + 2) != 0) {
#line 144
          parselongopt(*(argv + (x + y)));
        }
      } else {
#line 147
        wrongopt(*(argv + (x + y)));
#line 148
        showhelp(1);
      }
    } else {
#line 151
      wrongopt(*(argv + (x + y)));
#line 152
      showhelp(1);
    }
#line 116
    x ++;
  }
#line 155
  return;
}
}
#line 157 "main.c"
void printusers(void) 
{ 
  int l ;
  int tmp ;
  char *str ;
  char *txt ;
  void *tmp___0 ;
  int i ;

  {
#line 159
  tmp = strarrlen(users);
#line 159
  l = tmp;
#line 160
  tmp___0 = malloc(2048UL * sizeof(char ));
#line 160
  txt = (char *)tmp___0;
#line 161
  memset((void *)txt, 0, (size_t )2047);
#line 162
  if (l == 0) {
#line 164
    guiprintf((char *)"no users in room\n");
#line 165
    return;
  }
#line 167
  wattr_on(outputwin, (attr_t )(6 << 8), (void *)0);
#line 168
  strcat((char * __restrict  )txt, (char const   * __restrict  )">> ");
#line 170
  i = 0;
#line 170
  while (i < l - 1) {
#line 171
    oasprintf(& str, (char *)"%s, ", *(users + i));
#line 172
    strcat((char * __restrict  )txt, (char const   * __restrict  )str);
#line 173
    free((void *)str);
#line 170
    i ++;
  }
#line 175
  oasprintf(& str, (char *)"%s\n", *(users + (l - 1)));
#line 176
  strcat((char * __restrict  )txt, (char const   * __restrict  )str);
#line 177
  free((void *)str);
#line 178
  wordwrap(txt);
#line 179
  guiprintf((char *)"\n");
#line 180
  wattr_on(outputwin, (attr_t )(7 << 8), (void *)0);
#line 181
  updateroom();
#line 182
  return;
}
}
#line 184 "main.c"
void atlogout(void) 
{ 
  void *tmp ;

  {
#line 186
  logdin = 0;
#line 187
  free((void *)users);
#line 188
  tmp = malloc(sizeof(char *));
#line 188
  users = (char **)tmp;
#line 189
  *(users + 0) = (char *)0;
#line 190
  guiprintf((char *)"logged out\n");
#line 191
  joindroom = 0;
#line 192
  return;
}
}
#line 194 "main.c"
void atdisconnect(void) 
{ 


  {
#line 196
  if (logdin == 1) {
#line 197
    atlogout();
  } else {
#line 199
    joindroom = 0;
  }
#line 201
  connected = 0;
#line 202
  guiprintf((char *)"disconnected\n");
#line 203
  return;
}
}
#line 205 "main.c"
char *removepart(char *start , char *end , char *str ) 
{ 
  char *str2 ;
  void *tmp ;
  int i ;
  int ii ;
  int startlen ;
  size_t tmp___0 ;
  int endlen ;
  size_t tmp___1 ;
  int a ;
  int tmp___2 ;
  size_t tmp___3 ;
  int tmp___4 ;
  void *tmp___5 ;

  {
#line 207
  tmp = malloc(sizeof(char ));
#line 207
  str2 = (char *)tmp;
#line 208
  tmp___0 = strlen((char const   *)start);
#line 208
  startlen = (int )tmp___0;
#line 208
  tmp___1 = strlen((char const   *)end);
#line 208
  endlen = (int )tmp___1;
#line 209
  i = 0;
#line 209
  ii = 0;
#line 209
  while ((int )*(str + i) != 0) {
#line 211
    tmp___3 = strlen((char const   *)start);
#line 211
    tmp___4 = strncmp((char const   *)(str + i), (char const   *)start, tmp___3);
#line 211
    if (tmp___4 == 0) {
#line 214
      a = i;
#line 214
      while ((int )*(str + a) != 0) {
#line 215
        tmp___2 = strncmp((char const   *)((str + startlen) + a), (char const   *)end,
                          (size_t )endlen);
#line 215
        if (tmp___2 == 0) {
#line 217
          i = ((startlen + a) + endlen) - 1;
#line 218
          ii --;
#line 219
          goto endloop;
        }
#line 214
        a ++;
      }
    }
#line 222
    *(str2 + ii) = *(str + i);
#line 223
    tmp___5 = realloc((void *)str2, (unsigned long )(ii + 2) * sizeof(char ));
#line 223
    str2 = (char *)tmp___5;
    endloop: 
#line 209
    i ++;
#line 209
    ii ++;
  }
#line 226
  *(str2 + ii) = (char)0;
#line 227
  return (str2);
}
}
#line 230 "main.c"
char *removestr(char *rem , char *str ) 
{ 
  char *str2 ;
  void *tmp ;
  int i ;
  int ii ;
  int len ;
  size_t tmp___0 ;
  int tmp___1 ;
  void *tmp___2 ;

  {
#line 232
  tmp = malloc(sizeof(char ));
#line 232
  str2 = (char *)tmp;
#line 233
  tmp___0 = strlen((char const   *)rem);
#line 233
  len = (int )tmp___0;
#line 234
  i = 0;
#line 234
  ii = 0;
#line 234
  while ((int )*(str + i) != 0) {
#line 236
    tmp___1 = strncmp((char const   *)(str + i), (char const   *)rem, (size_t )len);
#line 236
    if (tmp___1 == 0) {
#line 238
      i = (i + len) - 1;
#line 239
      ii --;
#line 240
      goto endloop;
    }
#line 242
    *(str2 + ii) = *(str + i);
#line 243
    tmp___2 = realloc((void *)str2, (unsigned long )(ii + 2) * sizeof(char ));
#line 243
    str2 = (char *)tmp___2;
    endloop: 
#line 234
    i ++;
#line 234
    ii ++;
  }
#line 246
  *(str2 + ii) = (char)0;
#line 247
  return (str2);
}
}
#line 250 "main.c"
char *removeformatting(char *str ) 
{ 
  char *str2 ;
  char *tmp ;
  char *str3 ;
  char *tmp___0 ;

  {
#line 252
  tmp = removepart((char *)"<font", (char *)">", str);
#line 252
  str2 = tmp;
#line 253
  tmp___0 = removepart((char *)"<FONT", (char *)">", str2);
#line 253
  str3 = tmp___0;
#line 254
  free((void *)str2);
#line 255
  str2 = removepart((char *)"<fade", (char *)">", str3);
#line 256
  free((void *)str3);
#line 257
  str3 = removepart((char *)"<FADE", (char *)">", str2);
#line 258
  free((void *)str2);
#line 259
  str2 = removestr((char *)"</font>", str3);
#line 260
  free((void *)str3);
#line 261
  str3 = removestr((char *)"</FONT>", str2);
#line 262
  free((void *)str2);
#line 263
  str2 = removestr((char *)"</fade>", str3);
#line 264
  free((void *)str3);
#line 265
  str3 = removestr((char *)"</FADE>", str2);
#line 266
  free((void *)str2);
#line 267
  str2 = removepart((char *)"\033", (char *)"m", str3);
#line 268
  free((void *)str3);
#line 269
  str3 = removestr((char *)"<red>", str2);
#line 270
  free((void *)str2);
#line 271
  str2 = removestr((char *)"<green>", str3);
#line 272
  free((void *)str3);
#line 273
  str3 = removestr((char *)"<b>", str2);
#line 274
  free((void *)str2);
#line 275
  str2 = removestr((char *)"</b>", str3);
#line 276
  free((void *)str3);
#line 277
  str3 = removestr((char *)"<i>", str2);
#line 278
  free((void *)str2);
#line 279
  str2 = removestr((char *)"</i>", str3);
#line 280
  free((void *)str3);
#line 281
  str3 = removestr((char *)"<u>", str2);
#line 282
  free((void *)str2);
#line 283
  str2 = removestr((char *)"</u>", str3);
#line 284
  free((void *)str3);
#line 285
  return (str2);
}
}
#line 288 "main.c"
void updateroom(void) 
{ 
  char *str ;
  void *tmp ;
  char *str2 ;
  void *tmp___0 ;
  int maxy ;
  int maxx ;
  int a ;
  int b ;
  size_t tmp___1 ;

  {
#line 290
  tmp = malloc((size_t )4096);
#line 290
  str = (char *)tmp;
#line 291
  tmp___0 = malloc((size_t )4096);
#line 291
  str2 = (char *)tmp___0;
#line 293
  if (stdscr) {
#line 293
    maxy = (int )stdscr->_maxy + 1;
  } else {
#line 293
    maxy = -1;
  }
#line 293
  if (stdscr) {
#line 293
    maxx = (int )stdscr->_maxx + 1;
  } else {
#line 293
    maxx = -1;
  }
#line 294
  wclear(statuswin);
#line 295
  snprintf((char * __restrict  )str, (size_t )4096, (char const   * __restrict  )" %s -- %s",
           groom, username);
#line 296
  tmp___1 = strlen((char const   *)str);
#line 296
  a = (int )tmp___1;
#line 297
  b = maxx - a;
#line 298
  bzero((void *)str2, (size_t )4096);
#line 299
  memset((void *)str2, 32, (size_t )b);
#line 300
  strcat((char * __restrict  )str, (char const   * __restrict  )str2);
#line 301
  waddnstr(statuswin, (char const   *)str, -1);
#line 302
  free((void *)str);
#line 303
  free((void *)str2);
#line 304
  wrefresh(statuswin);
#line 305
  wrefresh(inputwin);
#line 306
  return;
}
}
#line 308 "main.c"
void yrecvd(int service , char *content , int len ) 
{ 
  char **data ;
  char **data2 ;
  int c___0 ;
  int tmp ;
  int userc ;
  int tmp___0 ;
  int i ;
  int i2 ;
  int ii ;
  int tmp___1 ;
  void *tmp___2 ;
  size_t tmp___3 ;
  void *tmp___4 ;
  size_t tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  char *text ;
  char *tmp___11 ;
  int tmp___12 ;
  char *etext ;
  char *tmp___13 ;

  {
#line 311
  split((char *)"\300\200", content, & data);
#line 312
  switch (service) {
  case 1: 
#line 315
  guiprintf((char *)"logged in\n");
#line 316
  logdin = 1;
#line 317
  break;
  case 2: 
#line 319
  if (logdin == 1) {
#line 320
    disconnect();
  }
#line 321
  return;
#line 322
  break;
  case 17: 
#line 324
  tmp___7 = strcmp((char const   *)*(data + 0), "*** Danger Will Robinson!!!");
#line 324
  if (tmp___7 == 0) {
#line 325
    guiprintf((char *)"no such room\n");
  } else {
#line 326
    tmp___6 = strcmp((char const   *)*(data + 0), "That room is full.  Try a similar room?");
#line 326
    if (tmp___6 == 0) {
#line 327
      guiprintf((char *)"room is full\n");
    } else {
#line 331
      tmp = split((char *)"\001\002", *(data + 8), & data2);
#line 331
      c___0 = tmp / 6;
#line 332
      tmp___0 = strarrlen(users);
#line 332
      userc = tmp___0;
#line 334
      i = 0;
#line 334
      i2 = 0;
#line 334
      while (i < c___0) {
#line 337
        ii = 0;
#line 337
        while (ii < userc) {
#line 338
          tmp___1 = strcmp((char const   *)*(users + ii), (char const   *)*(data2 + i * 6));
#line 338
          if (tmp___1 == 0) {
#line 340
            i2 --;
#line 341
            goto endadd;
          }
#line 337
          ii ++;
        }
#line 343
        tmp___2 = realloc((void *)users, (unsigned long )((userc + i2) + 2) * sizeof(char *));
#line 343
        users = (char **)tmp___2;
#line 344
        tmp___3 = strlen((char const   *)*(data2 + i * 6));
#line 344
        tmp___4 = malloc((tmp___3 + 1UL) * sizeof(char ));
#line 344
        *(users + (userc + i2)) = (char *)tmp___4;
#line 345
        tmp___5 = strlen((char const   *)*(data2 + i * 6));
#line 345
        strncpy((char * __restrict  )*(users + (userc + i2)), (char const   * __restrict  )*(data2 + i * 6),
                tmp___5 + 1UL);
#line 346
        *(users + ((userc + i2) + 1)) = (char *)0;
        endadd: 
#line 334
        i ++;
#line 334
        i2 ++;
      }
#line 349
      if (c___0 > 1) {
#line 350
        printusers();
      } else {
#line 353
        timestamp();
#line 354
        wattr_on(outputwin, (attr_t )(6 << 8), (void *)0);
#line 355
        guiprintf((char *)">> %s\n", *(data2 + 0));
#line 356
        wattr_on(outputwin, (attr_t )(7 << 8), (void *)0);
#line 357
        updateroom();
      }
#line 359
      free((void *)data2);
    }
  }
#line 361
  break;
  case 18: 
#line 363
  timestamp();
#line 364
  if (logdin == 1) {
#line 364
    tmp___8 = strcmp((char const   *)*(data + 2), (char const   *)username);
#line 364
    if (tmp___8 == 0) {
#line 366
      disconnect();
#line 367
      return;
#line 368
      break;
    }
  }
#line 370
  wattr_on(outputwin, (attr_t )(2 << 8), (void *)0);
#line 371
  guiprintf((char *)"<< %s\n", *(data + 2));
#line 372
  wattr_on(outputwin, (attr_t )(7 << 8), (void *)0);
#line 373
  strarrdel(& users, *(data + 2));
#line 374
  updateroom();
#line 375
  break;
  case 65: 
#line 378
  tmp___9 = isUser(ignore, *(data + 2));
#line 378
  if (tmp___9 == 1) {
#line 378
    break;
  }
#line 379
  timestamp();
#line 380
  tmp___10 = strcmp((char const   *)username, (char const   *)*(data + 2));
#line 380
  if (tmp___10 == 0) {
#line 381
    wattr_on(outputwin, (attr_t )(4 << 8), (void *)0);
  } else {
#line 383
    wattr_on(outputwin, (attr_t )(3 << 8), (void *)0);
  }
#line 384
  guiprintf((char *)"%s: ", *(data + 2));
#line 385
  wattr_on(outputwin, (attr_t )(7 << 8), (void *)0);
#line 386
  tmp___11 = removeformatting(*(data + 4));
#line 386
  text = tmp___11;
#line 387
  wordwrap(text);
#line 388
  guiprintf((char *)"\n");
#line 389
  free((void *)text);
#line 390
  updateroom();
#line 391
  break;
  case 67: 
#line 393
  tmp___12 = isUser(ignore, *(data + 2));
#line 393
  if (tmp___12 == 1) {
#line 393
    break;
  }
#line 394
  timestamp();
#line 395
  wattr_on(outputwin, (attr_t )(1 << 8), (void *)0);
#line 396
  guiprintf((char *)"* ");
#line 397
  wattr_on(outputwin, (attr_t )(7 << 8), (void *)0);
#line 398
  tmp___13 = removeformatting(*(data + 4));
#line 398
  etext = tmp___13;
#line 399
  guiprintf((char *)"%s ", *(data + 2));
#line 400
  wordwrap(etext);
#line 401
  guiprintf((char *)"\n");
#line 402
  free((void *)etext);
#line 403
  updateroom();
#line 404
  break;
  }
#line 406
  free((void *)data);
#line 407
  return;
}
}
#line 409 "main.c"
void timestamp(void) 
{ 
  struct tm *times ;
  time_t lt ;

  {
#line 413
  if (tson == 1) {
#line 414
    lt = time((time_t *)((void *)0));
#line 415
    times = localtime((time_t const   *)(& lt));
#line 433
    guiprintf((char *)"[%02d:%02d:%02d] ", times->tm_hour, times->tm_min, times->tm_sec);
  }
#line 435
  return;
}
}
#line 437 "main.c"
void *recvthread(void) 
{ 


  {
#line 439
  yrecv(s);
#line 440
  atdisconnect();
#line 441
  pthread_exit((void *)0);
}
}
#line 444 "main.c"
void disconnect(void) 
{ 


  {
#line 446
  close(s);
#line 447
  atdisconnect();
#line 448
  return;
}
}
#line 450 "main.c"
void pexec(char *cmd ) 
{ 
  char buf[2048] ;
  unsigned int tmp ;
  char temp[80] ;
  unsigned int tmp___0 ;
  char txt[4096] ;
  int a ;
  FILE *popen_in ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  char *tmp___3 ;
  size_t tmp___4 ;
  size_t tmp___5 ;

  {
#line 452
  buf[0] = (char )'\000';
#line 452
  buf[1] = (char )'\000';
#line 452
  buf[2] = (char )'\000';
#line 452
  tmp = 3U;
#line 452
  while (! (tmp >= 2048U)) {
#line 452
    buf[tmp] = (char)0;
#line 452
    tmp ++;
  }
#line 453
  temp[0] = (char )'\000';
#line 453
  temp[1] = (char )'\000';
#line 453
  temp[2] = (char )'\000';
#line 453
  tmp___0 = 3U;
#line 453
  while (! (tmp___0 >= 80U)) {
#line 453
    temp[tmp___0] = (char)0;
#line 453
    tmp___0 ++;
  }
#line 457
  popen_in = popen((char const   *)cmd, "r");
#line 457
  if ((unsigned long )popen_in == (unsigned long )((void *)0)) {
#line 458
    return;
  }
#line 459
  while (1) {
#line 459
    tmp___3 = fgets((char * __restrict  )(temp), 2, (FILE * __restrict  )popen_in);
#line 459
    if (tmp___3) {
#line 459
      tmp___4 = strlen((char const   *)(buf));
#line 459
      if (! (tmp___4 < 800UL)) {
#line 459
        break;
      }
    } else {
#line 459
      break;
    }
#line 460
    strncat((char * __restrict  )(buf), (char const   * __restrict  )(temp), (size_t )2);
#line 461
    tmp___1 = strlen((char const   *)(buf));
#line 461
    tmp___2 = strlen((char const   *)cmd);
#line 461
    if (tmp___1 + tmp___2 > 510UL) {
#line 462
      break;
    }
  }
#line 464
  pclose(popen_in);
#line 465
  sprintf((char * __restrict  )(txt), (char const   * __restrict  )"%s: %s", cmd,
          buf);
#line 466
  tmp___5 = strlen((char const   *)(txt));
#line 466
  a = (int )tmp___5;
#line 467
  txt[a - 1] = (char )'\000';
#line 472
  ysay(s, txt);
#line 473
  return;
}
}
#line 475 "main.c"
void quit(void) 
{ 


  {
#line 477
  free((void *)groom);
#line 478
  if (logdin == 1) {
#line 479
    ycmd(s, 113, (char *)"logout", 6);
  }
#line 480
  if (connected == 1) {
#line 481
    disconnect();
  }
#line 482
  endgui();
#line 483
  free((void *)defroom);
#line 484
  free((void *)defuser);
#line 485
  free((void *)defserver);
#line 489
  _exit(0);
}
}
#line 492 "main.c"
char *readline(FILE *f ) 
{ 
  char *line ;
  void *tmp ;
  int i ;
  char c___0 ;
  int tmp___0 ;
  void *tmp___1 ;

  {
#line 494
  tmp = malloc(2UL * sizeof(char ));
#line 494
  line = (char *)tmp;
#line 496
  i = 0;
#line 496
  while (1) {
#line 498
    tmp___0 = fgetc(f);
#line 498
    c___0 = (char )tmp___0;
#line 499
    if ((int )c___0 == 10) {
#line 500
      break;
    } else
#line 499
    if ((int )c___0 == -1) {
#line 500
      break;
    }
#line 501
    *(line + i) = c___0;
#line 502
    tmp___1 = realloc((void *)line, (unsigned long )(i + 3) * sizeof(char ));
#line 502
    line = (char *)tmp___1;
#line 496
    i ++;
  }
#line 504
  *(line + i) = (char)0;
#line 505
  if (i == 0) {
#line 506
    return ((char *)0);
  }
#line 507
  return (line);
}
}
#line 510 "main.c"
void togglets(void) 
{ 


  {
#line 512
  if (tson == 1) {
#line 513
    tson = 0;
  } else {
#line 515
    tson = 1;
  }
#line 517
  return;
}
}
#line 519 "main.c"
void readconfig(void) 
{ 
  char *path ;
  char *tmp ;
  FILE *cfg ;

  {
#line 522
  tmp = getenv("HOME");
#line 522
  oasprintf(& path, (char *)"%s/.overdoserc", tmp);
#line 524
  cfg = fopen((char const   * __restrict  )path, (char const   * __restrict  )"r");
#line 524
  if ((unsigned long )cfg == (unsigned long )((FILE *)0)) {
#line 525
    return;
  }
#line 526
  free((void *)path);
#line 527
  defserver = readline(cfg);
#line 528
  defroom = readline(cfg);
#line 529
  defuser = readline(cfg);
#line 530
  fclose(cfg);
#line 531
  return;
}
}
#line 533 "main.c"
void ignoreuser(char *uS ) 
{ 
  char *str ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 535
  tmp = malloc(512UL * sizeof(char ));
#line 535
  str = (char *)tmp;
#line 536
  tmp___0 = strcmp((char const   *)uS, "");
#line 536
  if (tmp___0 == 0) {
#line 536
    return;
  }
#line 537
  tmp___1 = toggleIgnore(& ignore, uS);
#line 537
  if (tmp___1 == 1) {
#line 538
    snprintf((char * __restrict  )str, (size_t )512, (char const   * __restrict  )"*** Added %s to ignore list.",
             uS);
#line 539
    wordwrap(str);
  } else {
#line 541
    snprintf((char * __restrict  )str, (size_t )512, (char const   * __restrict  )"*** Removed %s from ignore list.",
             uS);
#line 542
    wordwrap(str);
  }
#line 544
  return;
}
}
#line 546 "main.c"
void loadignore(void) 
{ 
  char *path ;
  FILE *cfg ;
  char *tmp ;
  char *tmp___0 ;

  {
#line 550
  tmp = getenv("HOME");
#line 550
  oasprintf(& path, (char *)"%s/.zinc/ignore", tmp);
#line 551
  cfg = fopen((char const   * __restrict  )path, (char const   * __restrict  )"r");
#line 551
  if ((unsigned long )cfg == (unsigned long )((FILE *)0)) {
#line 552
    free((void *)path);
#line 553
    tmp___0 = getenv("HOME");
#line 553
    oasprintf(& path, (char *)"%s/.overdoseig", tmp___0);
#line 554
    cfg = fopen((char const   * __restrict  )path, (char const   * __restrict  )"r");
#line 554
    if ((unsigned long )cfg == (unsigned long )((FILE *)0)) {
#line 555
      free((void *)path);
#line 556
      return;
    } else {
#line 558
      fclose(cfg);
#line 559
      ignore = unserializeArray(path);
#line 560
      free((void *)path);
#line 561
      return;
    }
#line 563
    fclose(cfg);
#line 564
    ignore = unserializeArray(path);
#line 565
    free((void *)path);
#line 566
    return;
  }
#line 568
  return;
}
}
#line 570 "main.c"
void connerr(void) 
{ 
  char *str ;
  int *tmp ;
  char *tmp___0 ;

  {
#line 573
  tmp = __errno_location();
#line 573
  tmp___0 = strerror(*tmp);
#line 573
  oasprintf(& str, (char *)"error: %s\n", tmp___0);
#line 574
  wordwrap(str);
#line 575
  guiprintf((char *)"\n");
#line 576
  return;
}
}
#line 578 "main.c"
int conn(char *host ) 
{ 
  int tmp ;

  {
#line 580
  if ((int )*(host + 0) == 0) {
#line 582
    guiprintf((char *)"enter server address [or press enter for jcs.chat.dcn.yahoo.com]: ");
#line 583
    guigetln(& host, 1);
#line 584
    if ((int )*(host + 0) == 0) {
#line 584
      host = (char *)"jcs.chat.dcn.yahoo.com";
    }
#line 585
    guiprintf((char *)"%s\n", host);
  }
#line 587
  if (logdin == 1) {
#line 588
    ycmd(s, 113, (char *)"logout", 6);
  }
#line 589
  if (connected == 1) {
#line 590
    disconnect();
  }
#line 591
  s = tcp_connect(host, 8001);
#line 591
  if (s < 0) {
#line 592
    connerr();
#line 592
    return (1);
  }
#line 593
  connected = 1;
#line 594
  tmp = pthread_create((pthread_t * __restrict  )(& thrdid), (pthread_attr_t const   * __restrict  )0,
                       (void *(*)(void * ))(& recvthread), (void * __restrict  )0);
#line 594
  if (tmp != 0) {
#line 595
    guiprintf((char *)"error: cant create thread\n");
#line 595
    return (1);
  }
#line 596
  guiprintf((char *)"connected\n");
#line 597
  return (0);
}
}
#line 600 "main.c"
int login(char *id ) 
{ 
  int tmp ;
  char *password ;
  char *auth ;
  int tmp___0 ;
  size_t tmp___1 ;

  {
#line 603
  if (connected != 1) {
#line 604
    tmp = conn(defserver);
#line 604
    if (tmp != 0) {
#line 608
      return (1);
    }
  }
#line 610
  if ((int )*(id + 0) == 0) {
#line 612
    guiprintf((char *)"enter your username: ");
#line 613
    guigetln(& username, 1);
#line 614
    guiprintf((char *)"%s\n", username);
#line 615
    guiprintf((char *)"enter your password (will not echo)\n");
  } else {
#line 619
    oasprintf(& username, (char *)"%s", id);
#line 620
    guiprintf((char *)"enter password for %s\n", username);
  }
#line 623
  guigetln(& password, 0);
#line 624
  guiprintf((char *)"logging in...\n");
#line 626
  tmp___0 = yauth(username, password, & auth);
#line 626
  if (tmp___0 != 0) {
#line 627
    guiprintf((char *)"error: cannot login\n");
#line 627
    return (1);
  }
#line 628
  free((void *)password);
#line 629
  tmp___1 = strlen((char const   *)auth);
#line 629
  ycmd(s, 1, auth, (int )tmp___1);
#line 630
  free((void *)auth);
#line 631
  guiprintf((char *)"login sent\n");
#line 632
  return (0);
}
}
#line 635 "main.c"
void join(char *room ) 
{ 
  int tmp ;
  int tmp___0 ;
  size_t tmp___1 ;

  {
#line 637
  if ((int )*(room + 0) == 0) {
#line 639
    guiprintf((char *)"enter room to join [or press enter for Linux, FreeBSD, Solaris:1]: ");
#line 640
    guigetln(& room, 1);
#line 641
    tmp = strcmp((char const   *)room, "");
#line 641
    if (tmp == 0) {
#line 641
      room = (char *)"Linux, FreeBSD, Solaris:1";
    }
#line 642
    guiprintf((char *)"%s\n", room);
  }
#line 644
  if (logdin == 0) {
#line 645
    tmp___0 = login(defuser);
#line 645
    if (tmp___0 != 0) {
#line 646
      return;
    }
  }
#line 647
  tmp___1 = strlen((char const   *)room);
#line 647
  ycmd(s, 17, room, (int )tmp___1);
#line 648
  strncpy((char * __restrict  )groom, (char const   * __restrict  )room, (size_t )32);
#line 649
  updateroom();
#line 650
  joindroom = 1;
#line 651
  return;
}
}
#line 653 "main.c"
int main(int argc , char **argv ) 
{ 
  int didlogin ;
  void *tmp ;
  void *tmp___0 ;
  __pid_t tmp___1 ;
  char *txt ;
  int tmp___2 ;
  char *txt2 ;
  char *cmd ;
  char *tmp___3 ;

  {
#line 662
  tson = 1;
#line 663
  argc --;
#line 664
  argv ++;
#line 665
  tmp = malloc((size_t )128);
#line 665
  groom = (char *)tmp;
#line 666
  parseargs(argc, argv);
#line 667
  tmp___0 = malloc(sizeof(char *));
#line 667
  users = (char **)tmp___0;
#line 668
  *(users + 0) = (char *)0;
#line 669
  startgui();
#line 670
  signal(2, (void (*)(int  ))(& quit));
#line 671
  tmp___1 = getpid();
#line 671
  guiprintf((char *)"Overdose 0.3. Running as PID %d\n", tmp___1);
#line 672
  readconfig();
#line 673
  didlogin = login(defuser);
#line 674
  if (didlogin != 0) {
#line 675
    guiprintf((char *)"Login failed.\n");
  }
#line 677
  if ((unsigned long )defserver != (unsigned long )((char *)0)) {
#line 678
    conn(defserver);
  }
#line 679
  if ((unsigned long )defroom != (unsigned long )((char *)0)) {
#line 680
    join(defroom);
  }
#line 681
  while (1) {
#line 684
    tmp___2 = guigetln(& txt, 1);
#line 684
    if (tmp___2 == 0) {
#line 686
      free((void *)txt);
#line 687
      goto __Cont;
    }
#line 689
    if ((int )*(txt + 0) == 47) {
#line 691
      txt2 = txt + 1;
#line 692
      if ((int )*(txt2 + 0) == 0) {
#line 693
        printusers();
      } else {
#line 696
        tmp___3 = strsep((char ** __restrict  )(& txt2), (char const   * __restrict  )" ");
#line 696
        cmd = tmp___3;
#line 697
        command(cmd, txt2);
      }
    } else {
#line 701
      ysay(s, txt);
    }
#line 702
    free((void *)txt);
    __Cont: /* CIL Label */ ;
  }
}
}
#line 1 "md5.o"
#pragma merger("0","/tmp/cil-6NG0zp69.i","-Os,-fomit-frame-pointer,-fstack-protector-all")
#line 72 "md5.h"
void md5_init(md5_state_t *pms ) ;
#line 79
void md5_append(md5_state_t *pms , md5_byte_t const   *data , int nbytes ) ;
#line 86
void md5_finish(md5_state_t *pms , md5_byte_t *digest ) ;
#line 186 "md5.c"
static void md5_process(md5_state_t *pms , md5_byte_t const   *data ) 
{ 
  md5_word_t a ;
  md5_word_t b ;
  md5_word_t c___0 ;
  md5_word_t d ;
  md5_word_t t ;
  md5_word_t X[16] ;
  md5_byte_t const   *xp ;
  int i ;

  {
#line 189
  a = pms->abcd[0];
#line 189
  b = pms->abcd[1];
#line 189
  c___0 = pms->abcd[2];
#line 189
  d = pms->abcd[3];
#line 204
  xp = data;
#line 207
  i = 0;
#line 207
  while (i < 16) {
#line 208
    X[i] = (md5_word_t )((((int const   )*(xp + 0) + ((int const   )*(xp + 1) << 8)) + ((int const   )*(xp + 2) << 16)) + ((int const   )*(xp + 3) << 24));
#line 207
    i ++;
#line 207
    xp += 4;
  }
#line 239
  t = ((a + ((b & c___0) | (~ b & d))) + X[0]) + 3614090360U;
#line 239
  a = ((t << 7) | (t >> 25)) + b;
#line 240
  t = ((d + ((a & b) | (~ a & c___0))) + X[1]) + 3905402710U;
#line 240
  d = ((t << 12) | (t >> 20)) + a;
#line 241
  t = ((c___0 + ((d & a) | (~ d & b))) + X[2]) + 606105819U;
#line 241
  c___0 = ((t << 17) | (t >> 15)) + d;
#line 242
  t = ((b + ((c___0 & d) | (~ c___0 & a))) + X[3]) + 3250441966U;
#line 242
  b = ((t << 22) | (t >> 10)) + c___0;
#line 243
  t = ((a + ((b & c___0) | (~ b & d))) + X[4]) + 4118548399U;
#line 243
  a = ((t << 7) | (t >> 25)) + b;
#line 244
  t = ((d + ((a & b) | (~ a & c___0))) + X[5]) + 1200080426U;
#line 244
  d = ((t << 12) | (t >> 20)) + a;
#line 245
  t = ((c___0 + ((d & a) | (~ d & b))) + X[6]) + 2821735955U;
#line 245
  c___0 = ((t << 17) | (t >> 15)) + d;
#line 246
  t = ((b + ((c___0 & d) | (~ c___0 & a))) + X[7]) + 4249261313U;
#line 246
  b = ((t << 22) | (t >> 10)) + c___0;
#line 247
  t = ((a + ((b & c___0) | (~ b & d))) + X[8]) + 1770035416U;
#line 247
  a = ((t << 7) | (t >> 25)) + b;
#line 248
  t = ((d + ((a & b) | (~ a & c___0))) + X[9]) + 2336552879U;
#line 248
  d = ((t << 12) | (t >> 20)) + a;
#line 249
  t = ((c___0 + ((d & a) | (~ d & b))) + X[10]) + 4294925233U;
#line 249
  c___0 = ((t << 17) | (t >> 15)) + d;
#line 250
  t = ((b + ((c___0 & d) | (~ c___0 & a))) + X[11]) + 2304563134U;
#line 250
  b = ((t << 22) | (t >> 10)) + c___0;
#line 251
  t = ((a + ((b & c___0) | (~ b & d))) + X[12]) + 1804603682U;
#line 251
  a = ((t << 7) | (t >> 25)) + b;
#line 252
  t = ((d + ((a & b) | (~ a & c___0))) + X[13]) + 4254626195U;
#line 252
  d = ((t << 12) | (t >> 20)) + a;
#line 253
  t = ((c___0 + ((d & a) | (~ d & b))) + X[14]) + 2792965006U;
#line 253
  c___0 = ((t << 17) | (t >> 15)) + d;
#line 254
  t = ((b + ((c___0 & d) | (~ c___0 & a))) + X[15]) + 1236535329U;
#line 254
  b = ((t << 22) | (t >> 10)) + c___0;
#line 265
  t = ((a + ((b & d) | (c___0 & ~ d))) + X[1]) + 4129170786U;
#line 265
  a = ((t << 5) | (t >> 27)) + b;
#line 266
  t = ((d + ((a & c___0) | (b & ~ c___0))) + X[6]) + 3225465664U;
#line 266
  d = ((t << 9) | (t >> 23)) + a;
#line 267
  t = ((c___0 + ((d & b) | (a & ~ b))) + X[11]) + 643717713U;
#line 267
  c___0 = ((t << 14) | (t >> 18)) + d;
#line 268
  t = ((b + ((c___0 & a) | (d & ~ a))) + X[0]) + 3921069994U;
#line 268
  b = ((t << 20) | (t >> 12)) + c___0;
#line 269
  t = ((a + ((b & d) | (c___0 & ~ d))) + X[5]) + 3593408605U;
#line 269
  a = ((t << 5) | (t >> 27)) + b;
#line 270
  t = ((d + ((a & c___0) | (b & ~ c___0))) + X[10]) + 38016083U;
#line 270
  d = ((t << 9) | (t >> 23)) + a;
#line 271
  t = ((c___0 + ((d & b) | (a & ~ b))) + X[15]) + 3634488961U;
#line 271
  c___0 = ((t << 14) | (t >> 18)) + d;
#line 272
  t = ((b + ((c___0 & a) | (d & ~ a))) + X[4]) + 3889429448U;
#line 272
  b = ((t << 20) | (t >> 12)) + c___0;
#line 273
  t = ((a + ((b & d) | (c___0 & ~ d))) + X[9]) + 568446438U;
#line 273
  a = ((t << 5) | (t >> 27)) + b;
#line 274
  t = ((d + ((a & c___0) | (b & ~ c___0))) + X[14]) + 3275163606U;
#line 274
  d = ((t << 9) | (t >> 23)) + a;
#line 275
  t = ((c___0 + ((d & b) | (a & ~ b))) + X[3]) + 4107603335U;
#line 275
  c___0 = ((t << 14) | (t >> 18)) + d;
#line 276
  t = ((b + ((c___0 & a) | (d & ~ a))) + X[8]) + 1163531501U;
#line 276
  b = ((t << 20) | (t >> 12)) + c___0;
#line 277
  t = ((a + ((b & d) | (c___0 & ~ d))) + X[13]) + 2850285829U;
#line 277
  a = ((t << 5) | (t >> 27)) + b;
#line 278
  t = ((d + ((a & c___0) | (b & ~ c___0))) + X[2]) + 4243563512U;
#line 278
  d = ((t << 9) | (t >> 23)) + a;
#line 279
  t = ((c___0 + ((d & b) | (a & ~ b))) + X[7]) + 1735328473U;
#line 279
  c___0 = ((t << 14) | (t >> 18)) + d;
#line 280
  t = ((b + ((c___0 & a) | (d & ~ a))) + X[12]) + 2368359562U;
#line 280
  b = ((t << 20) | (t >> 12)) + c___0;
#line 291
  t = ((a + ((b ^ c___0) ^ d)) + X[5]) + 4294588738U;
#line 291
  a = ((t << 4) | (t >> 28)) + b;
#line 292
  t = ((d + ((a ^ b) ^ c___0)) + X[8]) + 2272392833U;
#line 292
  d = ((t << 11) | (t >> 21)) + a;
#line 293
  t = ((c___0 + ((d ^ a) ^ b)) + X[11]) + 1839030562U;
#line 293
  c___0 = ((t << 16) | (t >> 16)) + d;
#line 294
  t = ((b + ((c___0 ^ d) ^ a)) + X[14]) + 4259657740U;
#line 294
  b = ((t << 23) | (t >> 9)) + c___0;
#line 295
  t = ((a + ((b ^ c___0) ^ d)) + X[1]) + 2763975236U;
#line 295
  a = ((t << 4) | (t >> 28)) + b;
#line 296
  t = ((d + ((a ^ b) ^ c___0)) + X[4]) + 1272893353U;
#line 296
  d = ((t << 11) | (t >> 21)) + a;
#line 297
  t = ((c___0 + ((d ^ a) ^ b)) + X[7]) + 4139469664U;
#line 297
  c___0 = ((t << 16) | (t >> 16)) + d;
#line 298
  t = ((b + ((c___0 ^ d) ^ a)) + X[10]) + 3200236656U;
#line 298
  b = ((t << 23) | (t >> 9)) + c___0;
#line 299
  t = ((a + ((b ^ c___0) ^ d)) + X[13]) + 681279174U;
#line 299
  a = ((t << 4) | (t >> 28)) + b;
#line 300
  t = ((d + ((a ^ b) ^ c___0)) + X[0]) + 3936430074U;
#line 300
  d = ((t << 11) | (t >> 21)) + a;
#line 301
  t = ((c___0 + ((d ^ a) ^ b)) + X[3]) + 3572445317U;
#line 301
  c___0 = ((t << 16) | (t >> 16)) + d;
#line 302
  t = ((b + ((c___0 ^ d) ^ a)) + X[6]) + 76029189U;
#line 302
  b = ((t << 23) | (t >> 9)) + c___0;
#line 303
  t = ((a + ((b ^ c___0) ^ d)) + X[9]) + 3654602809U;
#line 303
  a = ((t << 4) | (t >> 28)) + b;
#line 304
  t = ((d + ((a ^ b) ^ c___0)) + X[12]) + 3873151461U;
#line 304
  d = ((t << 11) | (t >> 21)) + a;
#line 305
  t = ((c___0 + ((d ^ a) ^ b)) + X[15]) + 530742520U;
#line 305
  c___0 = ((t << 16) | (t >> 16)) + d;
#line 306
  t = ((b + ((c___0 ^ d) ^ a)) + X[2]) + 3299628645U;
#line 306
  b = ((t << 23) | (t >> 9)) + c___0;
#line 317
  t = ((a + (c___0 ^ (b | ~ d))) + X[0]) + 4096336452U;
#line 317
  a = ((t << 6) | (t >> 26)) + b;
#line 318
  t = ((d + (b ^ (a | ~ c___0))) + X[7]) + 1126891415U;
#line 318
  d = ((t << 10) | (t >> 22)) + a;
#line 319
  t = ((c___0 + (a ^ (d | ~ b))) + X[14]) + 2878612391U;
#line 319
  c___0 = ((t << 15) | (t >> 17)) + d;
#line 320
  t = ((b + (d ^ (c___0 | ~ a))) + X[5]) + 4237533241U;
#line 320
  b = ((t << 21) | (t >> 11)) + c___0;
#line 321
  t = ((a + (c___0 ^ (b | ~ d))) + X[12]) + 1700485571U;
#line 321
  a = ((t << 6) | (t >> 26)) + b;
#line 322
  t = ((d + (b ^ (a | ~ c___0))) + X[3]) + 2399980690U;
#line 322
  d = ((t << 10) | (t >> 22)) + a;
#line 323
  t = ((c___0 + (a ^ (d | ~ b))) + X[10]) + 4293915773U;
#line 323
  c___0 = ((t << 15) | (t >> 17)) + d;
#line 324
  t = ((b + (d ^ (c___0 | ~ a))) + X[1]) + 2240044497U;
#line 324
  b = ((t << 21) | (t >> 11)) + c___0;
#line 325
  t = ((a + (c___0 ^ (b | ~ d))) + X[8]) + 1873313359U;
#line 325
  a = ((t << 6) | (t >> 26)) + b;
#line 326
  t = ((d + (b ^ (a | ~ c___0))) + X[15]) + 4264355552U;
#line 326
  d = ((t << 10) | (t >> 22)) + a;
#line 327
  t = ((c___0 + (a ^ (d | ~ b))) + X[6]) + 2734768916U;
#line 327
  c___0 = ((t << 15) | (t >> 17)) + d;
#line 328
  t = ((b + (d ^ (c___0 | ~ a))) + X[13]) + 1309151649U;
#line 328
  b = ((t << 21) | (t >> 11)) + c___0;
#line 329
  t = ((a + (c___0 ^ (b | ~ d))) + X[4]) + 4149444226U;
#line 329
  a = ((t << 6) | (t >> 26)) + b;
#line 330
  t = ((d + (b ^ (a | ~ c___0))) + X[11]) + 3174756917U;
#line 330
  d = ((t << 10) | (t >> 22)) + a;
#line 331
  t = ((c___0 + (a ^ (d | ~ b))) + X[2]) + 718787259U;
#line 331
  c___0 = ((t << 15) | (t >> 17)) + d;
#line 332
  t = ((b + (d ^ (c___0 | ~ a))) + X[9]) + 3951481745U;
#line 332
  b = ((t << 21) | (t >> 11)) + c___0;
#line 338
  pms->abcd[0] += a;
#line 339
  pms->abcd[1] += b;
#line 340
  pms->abcd[2] += c___0;
#line 341
  pms->abcd[3] += d;
#line 342
  return;
}
}
#line 344 "md5.c"
void md5_init(md5_state_t *pms ) 
{ 
  md5_word_t tmp ;

  {
#line 347
  tmp = (md5_word_t )0;
#line 347
  pms->count[1] = tmp;
#line 347
  pms->count[0] = tmp;
#line 348
  pms->abcd[0] = (md5_word_t )1732584193;
#line 349
  pms->abcd[1] = 4023233417U;
#line 350
  pms->abcd[2] = 2562383102U;
#line 351
  pms->abcd[3] = (md5_word_t )271733878;
#line 352
  return;
}
}
#line 354 "md5.c"
void md5_append(md5_state_t *pms , md5_byte_t const   *data , int nbytes ) 
{ 
  md5_byte_t const   *p ;
  int left ;
  int offset___0 ;
  md5_word_t nbits ;
  int copy ;
  int tmp ;

  {
#line 357
  p = data;
#line 358
  left = nbytes;
#line 359
  offset___0 = (int )((pms->count[0] >> 3) & 63U);
#line 360
  nbits = (md5_word_t )(nbytes << 3);
#line 362
  if (nbytes <= 0) {
#line 363
    return;
  }
#line 366
  pms->count[1] += (md5_word_t )(nbytes >> 29);
#line 367
  pms->count[0] += nbits;
#line 368
  if (pms->count[0] < nbits) {
#line 369
    (pms->count[1]) ++;
  }
#line 372
  if (offset___0) {
#line 373
    if (offset___0 + nbytes > 64) {
#line 373
      tmp = 64 - offset___0;
    } else {
#line 373
      tmp = nbytes;
    }
#line 373
    copy = tmp;
#line 375
    bcopy(p, pms->buf + offset___0, copy);
#line 376
    if (offset___0 + copy < 64) {
#line 377
      return;
    }
#line 378
    p += copy;
#line 379
    left -= copy;
#line 380
    md5_process(pms, (md5_byte_t const   *)(pms->buf));
  }
#line 384
  while (left >= 64) {
#line 385
    md5_process(pms, p);
#line 384
    p += 64;
#line 384
    left -= 64;
  }
#line 388
  if (left) {
#line 389
    bcopy(p, pms->buf, left);
  }
#line 390
  return;
}
}
#line 395 "md5.c"
static md5_byte_t const   pad[64]  = 
#line 395
  {      (md5_byte_t const   )128,      (md5_byte_t const   )0,      (md5_byte_t const   )0,      (md5_byte_t const   )0, 
        (md5_byte_t const   )0,      (md5_byte_t const   )0,      (md5_byte_t const   )0,      (md5_byte_t const   )0, 
        (md5_byte_t const   )0,      (md5_byte_t const   )0,      (md5_byte_t const   )0,      (md5_byte_t const   )0, 
        (md5_byte_t const   )0,      (md5_byte_t const   )0,      (md5_byte_t const   )0,      (md5_byte_t const   )0, 
        (md5_byte_t const   )0,      (md5_byte_t const   )0,      (md5_byte_t const   )0,      (md5_byte_t const   )0, 
        (md5_byte_t const   )0,      (md5_byte_t const   )0,      (md5_byte_t const   )0,      (md5_byte_t const   )0, 
        (md5_byte_t const   )0,      (md5_byte_t const   )0,      (md5_byte_t const   )0,      (md5_byte_t const   )0, 
        (md5_byte_t const   )0,      (md5_byte_t const   )0,      (md5_byte_t const   )0,      (md5_byte_t const   )0, 
        (md5_byte_t const   )0,      (md5_byte_t const   )0,      (md5_byte_t const   )0,      (md5_byte_t const   )0, 
        (md5_byte_t const   )0,      (md5_byte_t const   )0,      (md5_byte_t const   )0,      (md5_byte_t const   )0, 
        (md5_byte_t const   )0,      (md5_byte_t const   )0,      (md5_byte_t const   )0,      (md5_byte_t const   )0, 
        (md5_byte_t const   )0,      (md5_byte_t const   )0,      (md5_byte_t const   )0,      (md5_byte_t const   )0, 
        (md5_byte_t const   )0,      (md5_byte_t const   )0,      (md5_byte_t const   )0,      (md5_byte_t const   )0, 
        (md5_byte_t const   )0,      (md5_byte_t const   )0,      (md5_byte_t const   )0,      (md5_byte_t const   )0, 
        (md5_byte_t const   )0,      (md5_byte_t const   )0,      (md5_byte_t const   )0,      (md5_byte_t const   )0, 
        (md5_byte_t const   )0,      (md5_byte_t const   )0,      (md5_byte_t const   )0,      (md5_byte_t const   )0};
#line 392 "md5.c"
void md5_finish(md5_state_t *pms , md5_byte_t *digest ) 
{ 
  md5_byte_t data[8] ;
  int i ;

  {
#line 405
  i = 0;
#line 405
  while (i < 8) {
#line 406
    data[i] = (md5_byte_t )(pms->count[i >> 2] >> ((i & 3) << 3));
#line 405
    i ++;
  }
#line 408
  md5_append(pms, pad, (int )(((55U - (pms->count[0] >> 3)) & 63U) + 1U));
#line 410
  md5_append(pms, (md5_byte_t const   *)(data), 8);
#line 411
  i = 0;
#line 411
  while (i < 16) {
#line 412
    *(digest + i) = (md5_byte_t )(pms->abcd[i >> 2] >> ((i & 3) << 3));
#line 411
    i ++;
  }
#line 413
  return;
}
}
#line 1 "memtok.o"
#pragma merger("0","/tmp/cil-IkF79Z7g.i","-Os,-fomit-frame-pointer,-fstack-protector-all")
#line 92 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1), __leaf__)) memchr)(void const   *__s ,
                                                                                               int __c ,
                                                                                               size_t __n )  __attribute__((__pure__)) ;
#line 61 "memtok.c"
char *memtok(char *m , size_t bytes , char const   *delims , size_t delim_count ,
             size_t *found ) ;
#line 61 "memtok.c"
static char *mem  =    (char *)0;
#line 61 "memtok.c"
static char *c  =    (char *)0;
#line 62 "memtok.c"
static size_t offset  =    (size_t )0;
#line 62 "memtok.c"
static size_t offset_now  =    (size_t )0;
#line 62 "memtok.c"
static size_t limit  =    (size_t )0;
#line 77 "memtok.c"
static char *ret  =    (char *)0;
#line 58 "memtok.c"
char *memtok(char *m , size_t bytes , char const   *delims , size_t delim_count ,
             size_t *found ) 
{ 
  void *tmp ;

  {
#line 64
  if ((unsigned long )((char *)0) != (unsigned long )m) {
#line 66
    mem = m;
#line 67
    offset = (size_t )0;
#line 68
    limit = bytes;
  }
#line 71
  offset_now = offset;
#line 73
  c = mem;
#line 73
  while (offset < limit) {
#line 75
    tmp = memchr((void const   *)delims, (int )*c, delim_count);
#line 75
    if ((unsigned long )((void *)0) != (unsigned long )tmp) {
#line 79
      ret = mem;
#line 80
      mem = c + 1;
#line 81
      *found = offset - offset_now;
#line 82
      offset_now = offset + 1UL;
#line 83
      return (ret);
    }
#line 73
    offset ++;
#line 73
    c ++;
  }
#line 87
  return ((char *)0);
}
}
#line 90 "memtok.c"
char *memdup(char const   *mem___0 , size_t bytes ) 
{ 
  char *dup ;
  void *tmp ;

  {
#line 92
  dup = (char *)0;
#line 94
  if (0UL < bytes) {
#line 94
    if ((unsigned long )((char const   *)0) != (unsigned long )mem___0) {
#line 96
      tmp = malloc(bytes);
#line 96
      dup = (char *)tmp;
#line 97
      memcpy((void * __restrict  )dup, (void const   * __restrict  )mem___0, bytes);
    }
  }
#line 100
  return (dup);
}
}
#line 103 "memtok.c"
char *memdupasstr(char const   *mem___0 , size_t bytes ) 
{ 
  char *string ;

  {
#line 105
  string = (char *)0;
#line 107
  if (0UL < bytes) {
#line 107
    if ((unsigned long )((char const   *)0) != (unsigned long )mem___0) {
#line 109
      string = memdup(mem___0, bytes + 1UL);
#line 110
      *(string + bytes) = (char )'\000';
    }
  }
#line 113
  return (string);
}
}
#line 1 "sha.o"
#pragma merger("0","/tmp/cil-zOMvpVob.i","-Os,-fomit-frame-pointer,-fstack-protector-all")
#line 18 "sha.h"
void shaInit(SHA_CTX *ctx ) ;
#line 19
void shaUpdate(SHA_CTX *ctx , unsigned char *dataIn , int len ) ;
#line 20
void shaFinal(SHA_CTX *ctx , unsigned char *hashout ) ;
#line 21
void shaBlock(unsigned char *dataIn , int len , unsigned char *hashout ) ;
#line 25 "sha.c"
static void shaHashBlock(SHA_CTX *ctx ) ;
#line 27 "sha.c"
void shaInit(SHA_CTX *ctx ) 
{ 
  int i ;
  uint32 tmp ;

  {
#line 30
  ctx->lenW = 0;
#line 31
  tmp = (uint32 )0;
#line 31
  ctx->sizeLo = tmp;
#line 31
  ctx->sizeHi = tmp;
#line 35
  ctx->H[0] = (uint32 )1732584193L;
#line 36
  ctx->H[1] = (uint32 )4023233417L;
#line 37
  ctx->H[2] = (uint32 )2562383102L;
#line 38
  ctx->H[3] = (uint32 )271733878L;
#line 39
  ctx->H[4] = (uint32 )3285377520L;
#line 41
  i = 0;
#line 41
  while (i < 80) {
#line 42
    ctx->W[i] = (uint32 )0;
#line 41
    i ++;
  }
#line 43
  return;
}
}
#line 46 "sha.c"
void shaUpdate(SHA_CTX *ctx , unsigned char *dataIn , int len ) 
{ 
  int i ;

  {
#line 51
  i = 0;
#line 51
  while (i < len) {
#line 52
    ctx->W[ctx->lenW / 4] <<= 8;
#line 53
    ctx->W[ctx->lenW / 4] |= (uint32 )*(dataIn + i);
#line 54
    (ctx->lenW) ++;
#line 54
    if (ctx->lenW % 64 == 0) {
#line 55
      shaHashBlock(ctx);
#line 56
      ctx->lenW = 0;
    }
#line 58
    ctx->sizeLo += 8U;
#line 59
    ctx->sizeHi += (uint32 )(ctx->sizeLo < 8U);
#line 51
    i ++;
  }
#line 61
  return;
}
}
#line 64 "sha.c"
void shaFinal(SHA_CTX *ctx , unsigned char *hashout ) 
{ 
  unsigned char pad0x80 ;
  unsigned char pad0x00 ;
  unsigned char padlen[8] ;
  int i ;

  {
#line 65
  pad0x80 = (unsigned char)128;
#line 66
  pad0x00 = (unsigned char)0;
#line 72
  padlen[0] = (unsigned char )((ctx->sizeHi >> 24) & 255U);
#line 73
  padlen[1] = (unsigned char )((ctx->sizeHi >> 16) & 255U);
#line 74
  padlen[2] = (unsigned char )((ctx->sizeHi >> 8) & 255U);
#line 75
  padlen[3] = (unsigned char )(ctx->sizeHi & 255U);
#line 76
  padlen[4] = (unsigned char )((ctx->sizeLo >> 24) & 255U);
#line 77
  padlen[5] = (unsigned char )((ctx->sizeLo >> 16) & 255U);
#line 78
  padlen[6] = (unsigned char )((ctx->sizeLo >> 8) & 255U);
#line 79
  padlen[7] = (unsigned char )(ctx->sizeLo & 255U);
#line 80
  shaUpdate(ctx, & pad0x80, 1);
#line 81
  while (ctx->lenW != 56) {
#line 82
    shaUpdate(ctx, & pad0x00, 1);
  }
#line 83
  shaUpdate(ctx, padlen, 8);
#line 87
  i = 0;
#line 87
  while (i < 20) {
#line 88
    *(hashout + i) = (unsigned char )(ctx->H[i / 4] >> 24);
#line 89
    ctx->H[i / 4] <<= 8;
#line 87
    i ++;
  }
#line 95
  shaInit(ctx);
#line 96
  return;
}
}
#line 99 "sha.c"
void shaBlock(unsigned char *dataIn , int len , unsigned char *hashout ) 
{ 
  SHA_CTX ctx ;

  {
#line 102
  shaInit(& ctx);
#line 103
  shaUpdate(& ctx, dataIn, len);
#line 104
  shaFinal(& ctx, hashout);
#line 105
  return;
}
}
#line 110 "sha.c"
static void shaHashBlock(SHA_CTX *ctx ) 
{ 
  int t ;
  uint32 A ;
  uint32 B ;
  uint32 C ;
  uint32 D ;
  uint32 E ;
  uint32 TEMP ;

  {
#line 114
  t = 16;
#line 114
  while (t <= 79) {
#line 115
    ctx->W[t] = (uint32 )((long )(((((ctx->W[t - 3] ^ ctx->W[t - 8]) ^ ctx->W[t - 14]) ^ ctx->W[t - 16]) << 1) | ((((ctx->W[t - 3] ^ ctx->W[t - 8]) ^ ctx->W[t - 14]) ^ ctx->W[t - 16]) >> 31)) & 4294967295L);
#line 114
    t ++;
  }
#line 118
  A = ctx->H[0];
#line 119
  B = ctx->H[1];
#line 120
  C = ctx->H[2];
#line 121
  D = ctx->H[3];
#line 122
  E = ctx->H[4];
#line 124
  t = 0;
#line 124
  while (t <= 19) {
#line 125
    TEMP = (uint32 )(((((((long )((A << 5) | (A >> 27)) & 4294967295L) + (long )(((C ^ D) & B) ^ D)) + (long )E) + (long )ctx->W[t]) + 1518500249L) & 4294967295L);
#line 126
    E = D;
#line 126
    D = C;
#line 126
    C = (uint32 )((long )((B << 30) | (B >> 2)) & 4294967295L);
#line 126
    B = A;
#line 126
    A = TEMP;
#line 124
    t ++;
  }
#line 128
  t = 20;
#line 128
  while (t <= 39) {
#line 129
    TEMP = (uint32 )(((((((long )((A << 5) | (A >> 27)) & 4294967295L) + (long )((B ^ C) ^ D)) + (long )E) + (long )ctx->W[t]) + 1859775393L) & 4294967295L);
#line 130
    E = D;
#line 130
    D = C;
#line 130
    C = (uint32 )((long )((B << 30) | (B >> 2)) & 4294967295L);
#line 130
    B = A;
#line 130
    A = TEMP;
#line 128
    t ++;
  }
#line 132
  t = 40;
#line 132
  while (t <= 59) {
#line 133
    TEMP = (uint32 )(((((((long )((A << 5) | (A >> 27)) & 4294967295L) + (long )((B & C) | (D & (B | C)))) + (long )E) + (long )ctx->W[t]) + 2400959708L) & 4294967295L);
#line 134
    E = D;
#line 134
    D = C;
#line 134
    C = (uint32 )((long )((B << 30) | (B >> 2)) & 4294967295L);
#line 134
    B = A;
#line 134
    A = TEMP;
#line 132
    t ++;
  }
#line 136
  t = 60;
#line 136
  while (t <= 79) {
#line 137
    TEMP = (uint32 )(((((((long )((A << 5) | (A >> 27)) & 4294967295L) + (long )((B ^ C) ^ D)) + (long )E) + (long )ctx->W[t]) + 3395469782L) & 4294967295L);
#line 138
    E = D;
#line 138
    D = C;
#line 138
    C = (uint32 )((long )((B << 30) | (B >> 2)) & 4294967295L);
#line 138
    B = A;
#line 138
    A = TEMP;
#line 136
    t ++;
  }
#line 141
  ctx->H[0] += A;
#line 142
  ctx->H[1] += B;
#line 143
  ctx->H[2] += C;
#line 144
  ctx->H[3] += D;
#line 145
  ctx->H[4] += E;
#line 146
  return;
}
}
/* compiler builtin: 
   void __builtin_va_copy(__builtin_va_list  , __builtin_va_list  ) ;  */
/* compiler builtin: 
   void __builtin_va_arg(__builtin_va_list  , unsigned long  , void * ) ;  */
#line 1 "snprintf.o"
#pragma merger("0","/tmp/cil-DifmFMR8.i","-Os,-fomit-frame-pointer,-fstack-protector-all")
#line 70 "/usr/include/assert.h"
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) __assert_fail)(char const   *__assertion ,
                                                                                                   char const   *__file ,
                                                                                                   unsigned int __line ,
                                                                                                   char const   *__function ) ;
#line 407 "snprintf.c"
int portable_snprintf(char *str , size_t str_m , char const   *fmt  , ...) ;
#line 409
int portable_vsnprintf(char *str , size_t str_m , char const   *fmt , va_list ap ) ;
#line 415 "snprintf.c"
static char credits[209]  = 
#line 415
  {      (char )'\n',      (char )'@',      (char )'(',      (char )'#', 
        (char )')',      (char )'s',      (char )'n',      (char )'p', 
        (char )'r',      (char )'i',      (char )'n',      (char )'t', 
        (char )'f',      (char )'.',      (char )'c',      (char )',', 
        (char )' ',      (char )'v',      (char )'2',      (char )'.', 
        (char )'2',      (char )':',      (char )' ',      (char )'M', 
        (char )'a',      (char )'r',      (char )'k',      (char )' ', 
        (char )'M',      (char )'a',      (char )'r',      (char )'t', 
        (char )'i',      (char )'n',      (char )'e',      (char )'c', 
        (char )',',      (char )' ',      (char )'<',      (char )'m', 
        (char )'a',      (char )'r',      (char )'k',      (char )'.', 
        (char )'m',      (char )'a',      (char )'r',      (char )'t', 
        (char )'i',      (char )'n',      (char )'e',      (char )'c', 
        (char )'@',      (char )'i',      (char )'j',      (char )'s', 
        (char )'.',      (char )'s',      (char )'i',      (char )'>', 
        (char )'\n',      (char )'@',      (char )'(',      (char )'#', 
        (char )')',      (char )'s',      (char )'n',      (char )'p', 
        (char )'r',      (char )'i',      (char )'n',      (char )'t', 
        (char )'f',      (char )'.',      (char )'c',      (char )',', 
        (char )' ',      (char )'v',      (char )'2',      (char )'.', 
        (char )'2',      (char )':',      (char )' ',      (char )'C', 
        (char )'o',      (char )'p',      (char )'y',      (char )'r', 
        (char )'i',      (char )'g',      (char )'h',      (char )'t', 
        (char )' ',      (char )'1',      (char )'9',      (char )'9', 
        (char )'9',      (char )',',      (char )' ',      (char )'M', 
        (char )'a',      (char )'r',      (char )'k',      (char )' ', 
        (char )'M',      (char )'a',      (char )'r',      (char )'t', 
        (char )'i',      (char )'n',      (char )'e',      (char )'c', 
        (char )'.',      (char )' ',      (char )'F',      (char )'r', 
        (char )'o',      (char )'n',      (char )'t',      (char )'i', 
        (char )'e',      (char )'r',      (char )' ',      (char )'A', 
        (char )'r',      (char )'t',      (char )'i',      (char )'s', 
        (char )'t',      (char )'i',      (char )'c',      (char )' ', 
        (char )'L',      (char )'i',      (char )'c',      (char )'e', 
        (char )'n',      (char )'s',      (char )'e',      (char )' ', 
        (char )'a',      (char )'p',      (char )'p',      (char )'l', 
        (char )'i',      (char )'e',      (char )'s',      (char )'.', 
        (char )'\n',      (char )'@',      (char )'(',      (char )'#', 
        (char )')',      (char )'s',      (char )'n',      (char )'p', 
        (char )'r',      (char )'i',      (char )'n',      (char )'t', 
        (char )'f',      (char )'.',      (char )'c',      (char )',', 
        (char )' ',      (char )'v',      (char )'2',      (char )'.', 
        (char )'2',      (char )':',      (char )' ',      (char )'h', 
        (char )'t',      (char )'t',      (char )'p',      (char )':', 
        (char )'/',      (char )'/',      (char )'w',      (char )'w', 
        (char )'w',      (char )'.',      (char )'i',      (char )'j', 
        (char )'s',      (char )'.',      (char )'s',      (char )'i', 
        (char )'/',      (char )'s',      (char )'o',      (char )'f', 
        (char )'t',      (char )'w',      (char )'a',      (char )'r', 
        (char )'e',      (char )'/',      (char )'s',      (char )'n', 
        (char )'p',      (char )'r',      (char )'i',      (char )'n', 
        (char )'t',      (char )'f',      (char )'/',      (char )'\n', 
        (char )'\000'};
#line 445 "snprintf.c"
int vasprintf(char **ptr , char const   *fmt , va_list ap ) 
{ 
  size_t str_m ;
  int str_l ;
  va_list ap2 ;
  void *tmp ;
  int *tmp___0 ;
  int str_l2 ;
  int tmp___1 ;

  {
#line 449
  *ptr = (char *)((void *)0);
#line 451
  __builtin_va_copy(ap2, ap);
#line 452
  str_l = portable_vsnprintf((char *)((void *)0), (size_t )0, fmt, ap2);
#line 453
  __builtin_va_end(ap2);
#line 455
  if (! (str_l >= 0)) {
#line 455
    __assert_fail("str_l >= 0", "snprintf.c", 455U, "vasprintf");
  }
#line 456
  str_m = (size_t )str_l + 1UL;
#line 456
  tmp = malloc(str_m);
#line 456
  *ptr = (char *)tmp;
#line 457
  if ((unsigned long )*ptr == (unsigned long )((void *)0)) {
#line 457
    tmp___0 = __errno_location();
#line 457
    *tmp___0 = 12;
#line 457
    str_l = -1;
  } else {
#line 459
    tmp___1 = portable_vsnprintf(*ptr, str_m, fmt, ap);
#line 459
    str_l2 = tmp___1;
#line 460
    if (! (str_l2 == str_l)) {
#line 460
      __assert_fail("str_l2 == str_l", "snprintf.c", 460U, "vasprintf");
    }
  }
#line 462
  return (str_l);
}
}
#line 527 "snprintf.c"
int portable_snprintf(char *str , size_t str_m , char const   *fmt  , ...) 
{ 
  va_list ap ;
  int str_l ;

  {
#line 531
  __builtin_va_start(ap, fmt);
#line 532
  str_l = portable_vsnprintf(str, str_m, fmt, ap);
#line 533
  __builtin_va_end(ap);
#line 534
  return (str_l);
}
}
#line 541 "snprintf.c"
int portable_vsnprintf(char *str , size_t str_m , char const   *fmt , va_list ap ) 
{ 
  size_t str_l ;
  char const   *p ;
  char const   *q ;
  char *tmp ;
  size_t n ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  size_t avail ;
  register size_t nn ;
  size_t tmp___2 ;
  register char *dd ;
  register char const   *ss ;
  char *tmp___3 ;
  char const   *tmp___4 ;
  char const   *starting_p ;
  size_t min_field_width ;
  size_t precision ;
  int zero_padding ;
  int precision_specified ;
  int justify_left ;
  int alternate_form ;
  int force_sign ;
  int space_for_positive ;
  char length_modifier ;
  char tmp___5[32] ;
  char const   *str_arg ;
  size_t str_arg_l ;
  unsigned char uchar_arg ;
  size_t number_of_zeros_to_pad ;
  size_t zero_padding_insertion_ind ;
  char fmt_spec ;
  int j ;
  int tmp___6 ;
  unsigned int uj ;
  char const   *tmp___7 ;
  char const   *tmp___8 ;
  int j___0 ;
  int tmp___10 ;
  unsigned int uj___0 ;
  char const   *tmp___11 ;
  char const   *tmp___12 ;
  int j___1 ;
  int tmp___14 ;
  char const   *tmp___15 ;
  char const   *q___0 ;
  size_t tmp___16 ;
  void *tmp___17 ;
  int arg_sign ;
  int int_arg ;
  unsigned int uint_arg ;
  long long_arg ;
  unsigned long ulong_arg ;
  void *ptr_arg ;
  void *tmp___18 ;
  int tmp___19 ;
  long tmp___20 ;
  unsigned int tmp___21 ;
  unsigned long tmp___22 ;
  size_t tmp___23 ;
  size_t tmp___24 ;
  size_t tmp___25 ;
  char f[5] ;
  int f_l ;
  int tmp___26 ;
  int tmp___27 ;
  int tmp___28 ;
  int tmp___29 ;
  int tmp___30 ;
  int tmp___31 ;
  int tmp___32 ;
  int tmp___33 ;
  int tmp___34 ;
  int tmp___35 ;
  int tmp___36 ;
  size_t num_of_digits ;
  int n___0 ;
  int n___1 ;
  size_t avail___0 ;
  register size_t nn___0 ;
  size_t tmp___37 ;
  int tmp___38 ;
  register char *dd___0 ;
  register int cc ;
  int tmp___39 ;
  char *tmp___40 ;
  int n___2 ;
  size_t avail___1 ;
  register size_t nn___1 ;
  size_t tmp___41 ;
  register char *dd___1 ;
  register char const   *ss___0 ;
  char *tmp___42 ;
  char const   *tmp___43 ;
  size_t avail___2 ;
  register size_t nn___2 ;
  size_t tmp___44 ;
  register char *dd___2 ;
  register int cc___0 ;
  char *tmp___45 ;
  int n___3 ;
  size_t avail___3 ;
  register size_t nn___3 ;
  size_t tmp___46 ;
  register char *dd___3 ;
  register char const   *ss___1 ;
  char *tmp___47 ;
  char const   *tmp___48 ;
  int n___4 ;
  size_t avail___4 ;
  register size_t nn___4 ;
  size_t tmp___49 ;
  register char *dd___4 ;
  register int cc___1 ;
  char *tmp___50 ;
  size_t tmp___51 ;

  {
#line 547
  str_l = (size_t )0;
#line 548
  p = fmt;
#line 557
  if (! p) {
#line 557
    p = "";
  }
#line 558
  while (*p) {
#line 559
    if ((int const   )*p != 37) {
#line 563
      tmp = strchr(p + 1, '%');
#line 563
      q = (char const   *)tmp;
#line 564
      if (! q) {
#line 564
        tmp___0 = strlen(p);
#line 564
        tmp___1 = tmp___0;
      } else {
#line 564
        tmp___1 = (size_t )(q - p);
      }
#line 564
      n = tmp___1;
#line 565
      if (str_l < str_m) {
#line 566
        avail = str_m - str_l;
#line 567
        if (n > avail) {
#line 567
          tmp___2 = avail;
        } else {
#line 567
          tmp___2 = n;
        }
#line 567
        nn = tmp___2;
#line 567
        if (nn >= 6UL) {
#line 567
          memcpy((void * __restrict  )(str + str_l), (void const   * __restrict  )p,
                 nn);
        } else
#line 567
        if (nn > 0UL) {
#line 567
          ss = p;
#line 567
          dd = str + str_l;
#line 567
          while (nn > 0UL) {
#line 567
            tmp___3 = dd;
#line 567
            dd ++;
#line 567
            tmp___4 = ss;
#line 567
            ss ++;
#line 567
            *tmp___3 = (char )*tmp___4;
#line 567
            nn --;
          }
        }
      }
#line 569
      p += n;
#line 569
      str_l += n;
    } else {
#line 572
      min_field_width = (size_t )0;
#line 572
      precision = (size_t )0;
#line 573
      zero_padding = 0;
#line 573
      precision_specified = 0;
#line 573
      justify_left = 0;
#line 574
      alternate_form = 0;
#line 574
      force_sign = 0;
#line 575
      space_for_positive = 1;
#line 577
      length_modifier = (char )'\000';
#line 588
      number_of_zeros_to_pad = (size_t )0;
#line 592
      zero_padding_insertion_ind = (size_t )0;
#line 595
      fmt_spec = (char )'\000';
#line 598
      str_arg = (char const   *)(credits);
#line 599
      str_arg = (char const   *)((void *)0);
#line 600
      starting_p = p;
#line 600
      p ++;
#line 602
      while (1) {
#line 602
        if (! ((int const   )*p == 48)) {
#line 602
          if (! ((int const   )*p == 45)) {
#line 602
            if (! ((int const   )*p == 43)) {
#line 602
              if (! ((int const   )*p == 32)) {
#line 602
                if (! ((int const   )*p == 35)) {
#line 602
                  if (! ((int const   )*p == 39)) {
#line 602
                    break;
                  }
                }
              }
            }
          }
        }
#line 604
        switch ((int const   )*p) {
        case 48: 
#line 605
        zero_padding = 1;
#line 605
        break;
        case 45: 
#line 606
        justify_left = 1;
#line 606
        break;
        case 43: 
#line 607
        force_sign = 1;
#line 607
        space_for_positive = 0;
#line 607
        break;
        case 32: 
#line 608
        force_sign = 1;
#line 614
        break;
        case 35: 
#line 615
        alternate_form = 1;
#line 615
        break;
        case 39: 
#line 616
        break;
        }
#line 618
        p ++;
      }
#line 623
      if ((int const   )*p == 42) {
#line 625
        p ++;
#line 625
        tmp___6 = __builtin_va_arg(ap, int );
#line 625
        j = tmp___6;
#line 626
        if (j >= 0) {
#line 626
          min_field_width = (size_t )j;
        } else {
#line 627
          min_field_width = (size_t )(- j);
#line 627
          justify_left = 1;
        }
      } else
#line 628
      if ((int )*p >= 48) {
#line 628
        if ((int )*p <= 57) {
#line 631
          tmp___7 = p;
#line 631
          p ++;
#line 631
          uj = (unsigned int )((int const   )*tmp___7 - 48);
#line 632
          while (1) {
#line 632
            if ((int )*p >= 48) {
#line 632
              if (! ((int )*p <= 57)) {
#line 632
                break;
              }
            } else {
#line 632
              break;
            }
#line 632
            tmp___8 = p;
#line 632
            p ++;
#line 632
            uj = 10U * uj + (unsigned int )((int const   )*tmp___8 - 48);
          }
#line 633
          min_field_width = (size_t )uj;
        }
      }
#line 636
      if ((int const   )*p == 46) {
#line 637
        p ++;
#line 637
        precision_specified = 1;
#line 638
        if ((int const   )*p == 42) {
#line 639
          tmp___10 = __builtin_va_arg(ap, int );
#line 639
          j___0 = tmp___10;
#line 640
          p ++;
#line 641
          if (j___0 >= 0) {
#line 641
            precision = (size_t )j___0;
          } else {
#line 643
            precision_specified = 0;
#line 643
            precision = (size_t )0;
          }
        } else
#line 651
        if ((int )*p >= 48) {
#line 651
          if ((int )*p <= 57) {
#line 654
            tmp___11 = p;
#line 654
            p ++;
#line 654
            uj___0 = (unsigned int )((int const   )*tmp___11 - 48);
#line 655
            while (1) {
#line 655
              if ((int )*p >= 48) {
#line 655
                if (! ((int )*p <= 57)) {
#line 655
                  break;
                }
              } else {
#line 655
                break;
              }
#line 655
              tmp___12 = p;
#line 655
              p ++;
#line 655
              uj___0 = 10U * uj___0 + (unsigned int )((int const   )*tmp___12 - 48);
            }
#line 656
            precision = (size_t )uj___0;
          }
        }
      }
#line 660
      if ((int const   )*p == 104) {
#line 660
        goto _L;
      } else
#line 660
      if ((int const   )*p == 108) {
        _L: /* CIL Label */ 
#line 661
        length_modifier = (char )*p;
#line 661
        p ++;
#line 662
        if ((int )length_modifier == 108) {
#line 662
          if ((int const   )*p == 108) {
#line 666
            length_modifier = (char )'l';
#line 668
            p ++;
          }
        }
      }
#line 671
      fmt_spec = (char )*p;
#line 673
      switch ((int )fmt_spec) {
      case 105: 
#line 674
      fmt_spec = (char )'d';
#line 674
      break;
      case 68: 
#line 675
      fmt_spec = (char )'d';
#line 675
      length_modifier = (char )'l';
#line 675
      break;
      case 85: 
#line 676
      fmt_spec = (char )'u';
#line 676
      length_modifier = (char )'l';
#line 676
      break;
      case 79: 
#line 677
      fmt_spec = (char )'o';
#line 677
      length_modifier = (char )'l';
#line 677
      break;
      default: 
#line 678
      break;
      }
#line 681
      switch ((int )fmt_spec) {
      case 115: 
      case 99: 
      case 37: 
#line 685
      length_modifier = (char )'\000';
#line 690
      zero_padding = 0;
#line 692
      str_arg_l = (size_t )1;
#line 693
      switch ((int )fmt_spec) {
      case 37: 
#line 695
      str_arg = p;
#line 695
      break;
      case 99: 
#line 697
      tmp___14 = __builtin_va_arg(ap, int );
#line 697
      j___1 = tmp___14;
#line 698
      uchar_arg = (unsigned char )j___1;
#line 699
      str_arg = (char const   *)(& uchar_arg);
#line 700
      break;
      case 115: 
#line 703
      tmp___15 = __builtin_va_arg(ap, char const   *);
#line 703
      str_arg = tmp___15;
#line 704
      if (! str_arg) {
#line 704
        str_arg_l = (size_t )0;
      } else
#line 706
      if (! precision_specified) {
#line 706
        str_arg_l = strlen(str_arg);
      } else
#line 708
      if (precision == 0UL) {
#line 708
        str_arg_l = (size_t )0;
      } else {
#line 711
        if (precision <= 2147483647UL) {
#line 711
          tmp___16 = precision;
        } else {
#line 711
          tmp___16 = (size_t )2147483647;
        }
#line 711
        tmp___17 = memchr((void const   *)str_arg, '\000', tmp___16);
#line 711
        q___0 = (char const   *)tmp___17;
#line 713
        if (! q___0) {
#line 713
          str_arg_l = precision;
        } else {
#line 713
          str_arg_l = (size_t )(q___0 - str_arg);
        }
      }
#line 715
      break;
      default: 
#line 716
      break;
      }
#line 718
      break;
      case 112: 
      case 88: 
      case 120: 
      case 111: 
      case 117: 
      case 100: 
#line 723
      arg_sign = 0;
#line 728
      int_arg = 0;
#line 728
      uint_arg = 0U;
#line 731
      long_arg = 0L;
#line 731
      ulong_arg = 0UL;
#line 734
      ptr_arg = (void *)0;
#line 742
      if ((int )fmt_spec == 112) {
#line 760
        length_modifier = (char )'\000';
#line 762
        tmp___18 = __builtin_va_arg(ap, void *);
#line 762
        ptr_arg = tmp___18;
#line 763
        if ((unsigned long )ptr_arg != (unsigned long )((void *)0)) {
#line 763
          arg_sign = 1;
        }
      } else
#line 764
      if ((int )fmt_spec == 100) {
#line 765
        switch ((int )length_modifier) {
        case 104: 
        case 0: 
#line 773
        tmp___19 = __builtin_va_arg(ap, int );
#line 773
        int_arg = tmp___19;
#line 774
        if (int_arg > 0) {
#line 774
          arg_sign = 1;
        } else
#line 775
        if (int_arg < 0) {
#line 775
          arg_sign = -1;
        }
#line 776
        break;
        case 108: 
#line 778
        tmp___20 = __builtin_va_arg(ap, long );
#line 778
        long_arg = tmp___20;
#line 779
        if (long_arg > 0L) {
#line 779
          arg_sign = 1;
        } else
#line 780
        if (long_arg < 0L) {
#line 780
          arg_sign = -1;
        }
#line 781
        break;
        }
      } else {
#line 791
        switch ((int )length_modifier) {
        case 104: 
        case 0: 
#line 794
        tmp___21 = __builtin_va_arg(ap, unsigned int );
#line 794
        uint_arg = tmp___21;
#line 795
        if (uint_arg) {
#line 795
          arg_sign = 1;
        }
#line 796
        break;
        case 108: 
#line 798
        tmp___22 = __builtin_va_arg(ap, unsigned long );
#line 798
        ulong_arg = tmp___22;
#line 799
        if (ulong_arg) {
#line 799
          arg_sign = 1;
        }
#line 800
        break;
        }
      }
#line 809
      str_arg = (char const   *)(tmp___5);
#line 809
      str_arg_l = (size_t )0;
#line 816
      if (precision_specified) {
#line 816
        zero_padding = 0;
      }
#line 818
      if ((int )fmt_spec == 100) {
#line 819
        if (force_sign) {
#line 819
          if (arg_sign >= 0) {
#line 820
            tmp___23 = str_arg_l;
#line 820
            str_arg_l ++;
#line 820
            if (space_for_positive) {
#line 820
              tmp___5[tmp___23] = (char )' ';
            } else {
#line 820
              tmp___5[tmp___23] = (char )'+';
            }
          }
        }
      } else
#line 827
      if (alternate_form) {
#line 828
        if (arg_sign != 0) {
#line 828
          if ((int )fmt_spec == 120) {
#line 828
            goto _L___0;
          } else
#line 828
          if ((int )fmt_spec == 88) {
            _L___0: /* CIL Label */ 
#line 829
            tmp___24 = str_arg_l;
#line 829
            str_arg_l ++;
#line 829
            tmp___5[tmp___24] = (char )'0';
#line 829
            tmp___25 = str_arg_l;
#line 829
            str_arg_l ++;
#line 829
            tmp___5[tmp___25] = fmt_spec;
          }
        }
      }
#line 842
      zero_padding_insertion_ind = str_arg_l;
#line 843
      if (! precision_specified) {
#line 843
        precision = (size_t )1;
      }
#line 844
      if (precision == 0UL) {
#line 844
        if (! (arg_sign == 0)) {
#line 844
          goto _L___1;
        }
      } else {
        _L___1: /* CIL Label */ 
#line 856
        f_l = 0;
#line 857
        tmp___26 = f_l;
#line 857
        f_l ++;
#line 857
        f[tmp___26] = (char )'%';
#line 858
        if (! (! length_modifier)) {
#line 859
          if ((int )length_modifier == 50) {
#line 859
            tmp___27 = f_l;
#line 859
            f_l ++;
#line 859
            f[tmp___27] = (char )'l';
#line 859
            tmp___28 = f_l;
#line 859
            f_l ++;
#line 859
            f[tmp___28] = (char )'l';
          } else {
#line 860
            tmp___29 = f_l;
#line 860
            f_l ++;
#line 860
            f[tmp___29] = length_modifier;
          }
        }
#line 861
        tmp___30 = f_l;
#line 861
        f_l ++;
#line 861
        f[tmp___30] = fmt_spec;
#line 861
        tmp___31 = f_l;
#line 861
        f_l ++;
#line 861
        f[tmp___31] = (char )'\000';
#line 862
        if ((int )fmt_spec == 112) {
#line 862
          tmp___32 = sprintf((char * __restrict  )(tmp___5 + str_arg_l), (char const   * __restrict  )(f),
                             ptr_arg);
#line 862
          str_arg_l += (size_t )tmp___32;
        } else
#line 863
        if ((int )fmt_spec == 100) {
#line 864
          switch ((int )length_modifier) {
          case 104: 
          case 0: 
#line 866
          tmp___33 = sprintf((char * __restrict  )(tmp___5 + str_arg_l), (char const   * __restrict  )(f),
                             int_arg);
#line 866
          str_arg_l += (size_t )tmp___33;
#line 866
          break;
          case 108: 
#line 867
          tmp___34 = sprintf((char * __restrict  )(tmp___5 + str_arg_l), (char const   * __restrict  )(f),
                             long_arg);
#line 867
          str_arg_l += (size_t )tmp___34;
#line 867
          break;
          }
        } else {
#line 873
          switch ((int )length_modifier) {
          case 104: 
          case 0: 
#line 875
          tmp___35 = sprintf((char * __restrict  )(tmp___5 + str_arg_l), (char const   * __restrict  )(f),
                             uint_arg);
#line 875
          str_arg_l += (size_t )tmp___35;
#line 875
          break;
          case 108: 
#line 876
          tmp___36 = sprintf((char * __restrict  )(tmp___5 + str_arg_l), (char const   * __restrict  )(f),
                             ulong_arg);
#line 876
          str_arg_l += (size_t )tmp___36;
#line 876
          break;
          }
        }
#line 884
        if (zero_padding_insertion_ind < str_arg_l) {
#line 884
          if ((int )tmp___5[zero_padding_insertion_ind] == 45) {
#line 886
            zero_padding_insertion_ind ++;
          }
        }
#line 888
        if (zero_padding_insertion_ind + 1UL < str_arg_l) {
#line 888
          if ((int )tmp___5[zero_padding_insertion_ind] == 48) {
#line 888
            if ((int )tmp___5[zero_padding_insertion_ind + 1UL] == 120) {
#line 892
              zero_padding_insertion_ind += 2UL;
            } else
#line 888
            if ((int )tmp___5[zero_padding_insertion_ind + 1UL] == 88) {
#line 892
              zero_padding_insertion_ind += 2UL;
            }
          }
        }
      }
#line 895
      num_of_digits = str_arg_l - zero_padding_insertion_ind;
#line 896
      if (alternate_form) {
#line 896
        if ((int )fmt_spec == 111) {
#line 896
          if (zero_padding_insertion_ind < str_arg_l) {
#line 896
            if (! ((int )tmp___5[zero_padding_insertion_ind] == 48)) {
#line 896
              goto _L___2;
            }
          } else
          _L___2: /* CIL Label */ 
#line 907
          if (! precision_specified) {
#line 911
            precision = num_of_digits + 1UL;
#line 911
            precision_specified = 1;
          } else
#line 907
          if (precision < num_of_digits + 1UL) {
#line 911
            precision = num_of_digits + 1UL;
#line 911
            precision_specified = 1;
          }
        }
      }
#line 915
      if (num_of_digits < precision) {
#line 916
        number_of_zeros_to_pad = precision - num_of_digits;
      }
#line 919
      if (! justify_left) {
#line 919
        if (zero_padding) {
#line 920
          n___0 = (int )(min_field_width - (str_arg_l + number_of_zeros_to_pad));
#line 921
          if (n___0 > 0) {
#line 921
            number_of_zeros_to_pad += (size_t )n___0;
          }
        }
      }
#line 923
      break;
      default: 
#line 926
      zero_padding = 0;
#line 928
      justify_left = 1;
#line 928
      min_field_width = (size_t )0;
#line 938
      str_arg = p;
#line 938
      str_arg_l = (size_t )0;
#line 940
      if (*p) {
#line 940
        str_arg_l ++;
      }
#line 942
      break;
      }
#line 944
      if (*p) {
#line 944
        p ++;
      }
#line 947
      if (! justify_left) {
#line 948
        n___1 = (int )(min_field_width - (str_arg_l + number_of_zeros_to_pad));
#line 949
        if (n___1 > 0) {
#line 950
          if (str_l < str_m) {
#line 951
            avail___0 = str_m - str_l;
#line 952
            if ((size_t )n___1 > avail___0) {
#line 952
              tmp___37 = avail___0;
            } else {
#line 952
              tmp___37 = (size_t )n___1;
            }
#line 952
            nn___0 = tmp___37;
#line 952
            if (nn___0 >= 6UL) {
#line 952
              if (zero_padding) {
#line 952
                tmp___38 = '0';
              } else {
#line 952
                tmp___38 = ' ';
              }
#line 952
              memset((void *)(str + str_l), tmp___38, nn___0);
            } else
#line 952
            if (nn___0 > 0UL) {
#line 952
              if (zero_padding) {
#line 952
                tmp___39 = '0';
              } else {
#line 952
                tmp___39 = ' ';
              }
#line 952
              cc = tmp___39;
#line 952
              dd___0 = str + str_l;
#line 952
              while (nn___0 > 0UL) {
#line 952
                tmp___40 = dd___0;
#line 952
                dd___0 ++;
#line 952
                *tmp___40 = (char )cc;
#line 952
                nn___0 --;
              }
            }
          }
#line 954
          str_l += (size_t )n___1;
        }
      }
#line 959
      if (number_of_zeros_to_pad <= 0UL) {
#line 962
        zero_padding_insertion_ind = (size_t )0;
      } else {
#line 965
        n___2 = (int )zero_padding_insertion_ind;
#line 966
        if (n___2 > 0) {
#line 967
          if (str_l < str_m) {
#line 968
            avail___1 = str_m - str_l;
#line 969
            if ((size_t )n___2 > avail___1) {
#line 969
              tmp___41 = avail___1;
            } else {
#line 969
              tmp___41 = (size_t )n___2;
            }
#line 969
            nn___1 = tmp___41;
#line 969
            if (nn___1 >= 6UL) {
#line 969
              memcpy((void * __restrict  )(str + str_l), (void const   * __restrict  )str_arg,
                     nn___1);
            } else
#line 969
            if (nn___1 > 0UL) {
#line 969
              ss___0 = str_arg;
#line 969
              dd___1 = str + str_l;
#line 969
              while (nn___1 > 0UL) {
#line 969
                tmp___42 = dd___1;
#line 969
                dd___1 ++;
#line 969
                tmp___43 = ss___0;
#line 969
                ss___0 ++;
#line 969
                *tmp___42 = (char )*tmp___43;
#line 969
                nn___1 --;
              }
            }
          }
#line 971
          str_l += (size_t )n___2;
        }
#line 974
        n___2 = (int )number_of_zeros_to_pad;
#line 975
        if (n___2 > 0) {
#line 976
          if (str_l < str_m) {
#line 977
            avail___2 = str_m - str_l;
#line 978
            if ((size_t )n___2 > avail___2) {
#line 978
              tmp___44 = avail___2;
            } else {
#line 978
              tmp___44 = (size_t )n___2;
            }
#line 978
            nn___2 = tmp___44;
#line 978
            if (nn___2 >= 6UL) {
#line 978
              memset((void *)(str + str_l), '0', nn___2);
            } else
#line 978
            if (nn___2 > 0UL) {
#line 978
              cc___0 = '0';
#line 978
              dd___2 = str + str_l;
#line 978
              while (nn___2 > 0UL) {
#line 978
                tmp___45 = dd___2;
#line 978
                dd___2 ++;
#line 978
                *tmp___45 = (char )cc___0;
#line 978
                nn___2 --;
              }
            }
          }
#line 980
          str_l += (size_t )n___2;
        }
      }
#line 985
      n___3 = (int )(str_arg_l - zero_padding_insertion_ind);
#line 986
      if (n___3 > 0) {
#line 987
        if (str_l < str_m) {
#line 988
          avail___3 = str_m - str_l;
#line 989
          if ((size_t )n___3 > avail___3) {
#line 989
            tmp___46 = avail___3;
          } else {
#line 989
            tmp___46 = (size_t )n___3;
          }
#line 989
          nn___3 = tmp___46;
#line 989
          if (nn___3 >= 6UL) {
#line 989
            memcpy((void * __restrict  )(str + str_l), (void const   * __restrict  )(str_arg + zero_padding_insertion_ind),
                   nn___3);
          } else
#line 989
          if (nn___3 > 0UL) {
#line 989
            ss___1 = str_arg + zero_padding_insertion_ind;
#line 989
            dd___3 = str + str_l;
#line 989
            while (nn___3 > 0UL) {
#line 989
              tmp___47 = dd___3;
#line 989
              dd___3 ++;
#line 989
              tmp___48 = ss___1;
#line 989
              ss___1 ++;
#line 989
              *tmp___47 = (char )*tmp___48;
#line 989
              nn___3 --;
            }
          }
        }
#line 992
        str_l += (size_t )n___3;
      }
#line 996
      if (justify_left) {
#line 997
        n___4 = (int )(min_field_width - (str_arg_l + number_of_zeros_to_pad));
#line 998
        if (n___4 > 0) {
#line 999
          if (str_l < str_m) {
#line 1000
            avail___4 = str_m - str_l;
#line 1001
            if ((size_t )n___4 > avail___4) {
#line 1001
              tmp___49 = avail___4;
            } else {
#line 1001
              tmp___49 = (size_t )n___4;
            }
#line 1001
            nn___4 = tmp___49;
#line 1001
            if (nn___4 >= 6UL) {
#line 1001
              memset((void *)(str + str_l), ' ', nn___4);
            } else
#line 1001
            if (nn___4 > 0UL) {
#line 1001
              cc___1 = ' ';
#line 1001
              dd___4 = str + str_l;
#line 1001
              while (nn___4 > 0UL) {
#line 1001
                tmp___50 = dd___4;
#line 1001
                dd___4 ++;
#line 1001
                *tmp___50 = (char )cc___1;
#line 1001
                nn___4 --;
              }
            }
          }
#line 1003
          str_l += (size_t )n___4;
        }
      }
    }
  }
#line 1011
  if (str_m > 0UL) {
#line 1014
    if (str_l <= str_m - 1UL) {
#line 1014
      tmp___51 = str_l;
    } else {
#line 1014
      tmp___51 = str_m - 1UL;
    }
#line 1014
    *(str + tmp___51) = (char )'\000';
  }
#line 1026
  return ((int )str_l);
}
}
#line 1 "strutil.o"
#pragma merger("0","/tmp/cil-_7maxEXd.i","-Os,-fomit-frame-pointer,-fstack-protector-all")
#line 311 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strpbrk)(char const   *__s ,
                                                                                                  char const   *__accept )  __attribute__((__pure__)) ;
#line 435 "/usr/include/libio.h"
extern int _IO_getc(_IO_FILE *__fp ) ;
#line 828 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__warn_unused_result__,
__leaf__)) feof)(FILE *__stream ) ;
#line 17 "strutil.c"
 __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strsep)(char ** __restrict  string ,
                                                                                          char const   * __restrict  delim ) ;
#line 17 "strutil.c"
char *( __attribute__((__nonnull__(1,2), __leaf__)) strsep)(char ** __restrict  string ,
                                                            char const   * __restrict  delim ) 
{ 
  char *p ;
  char *q ;
  char ch ;
  char *tmp ;
  char *tmp___0 ;

  {
#line 21
  p = *string;
#line 21
  if (! p) {
#line 22
    return ((char *)((void *)0));
  }
#line 24
  if ((int const   )*(delim + 0) == 0) {
#line 24
    goto _L;
  } else
#line 24
  if ((int const   )*(delim + 1) == 0) {
    _L: /* CIL Label */ 
#line 26
    ch = (char )*(delim + 0);
#line 28
    if ((int )ch != 0) {
#line 29
      if ((int )*p == (int )ch) {
#line 29
        q = p;
      } else {
#line 29
        tmp = strchr((char const   *)(p + 1), (int )ch);
#line 29
        q = tmp;
      }
    } else {
#line 31
      q = (char *)((void *)0);
    }
  } else {
#line 34
    q = strpbrk((char const   *)p, (char const   *)delim);
  }
#line 36
  if (q) {
#line 38
    tmp___0 = q;
#line 38
    q ++;
#line 38
    *tmp___0 = (char )'\000';
#line 39
    *string = q;
  } else {
#line 42
    *string = (char *)((void *)0);
  }
#line 44
  return (p);
}
}
#line 48 "strutil.c"
void strcatl(char *dst , char const   *src , size_t size ) 
{ 
  int n ;
  int cnt ;
  size_t tmp ;

  {
#line 53
  tmp = strlen((char const   *)dst);
#line 53
  n = (int )tmp;
#line 54
  cnt = (int )((size - 1UL) - (size_t )n);
#line 55
  if (cnt > 0) {
#line 56
    strncat((char * __restrict  )dst, (char const   * __restrict  )src, (size_t )cnt);
  }
#line 57
  return;
}
}
#line 59 "strutil.c"
int strequal(char const   *s1 , char const   *s2 ) 
{ 
  int tmp___0 ;
  int tmp___1 ;

  {
#line 62
  if (s1) {
#line 62
    if (s2) {
#line 63
      tmp___1 = strcmp(s1, s2);
#line 63
      if (tmp___1) {
#line 63
        tmp___0 = 0;
      } else {
#line 63
        tmp___0 = 1;
      }
#line 63
      return (tmp___0);
    }
  }
#line 64
  return (0);
}
}
#line 74 "strutil.c"
int oasprintf(char **strp , char *fmt  , ...) 
{ 
  va_list ap ;
  int ret___0 ;

  {
#line 78
  __builtin_va_start(ap, fmt);
#line 79
  ret___0 = vasprintf(strp, fmt, ap);
#line 80
  __builtin_va_end(ap);
#line 81
  return (ret___0);
}
}
#line 84 "strutil.c"
char *substr(char *str , int start , size_t length ) 
{ 
  char *str2 ;
  void *tmp ;
  int i ;

  {
#line 86
  tmp = malloc(length * sizeof(char *));
#line 86
  str2 = (char *)tmp;
#line 88
  i = 0;
#line 88
  while ((size_t )i < length) {
#line 89
    *(str2 + i) = *(str + (start + i));
#line 88
    i ++;
  }
#line 90
  *(str2 + i) = (char)0;
#line 91
  return (str2);
}
}
#line 94 "strutil.c"
int split(char *separator , char *str , char ***array ) 
{ 
  char *str2 ;
  size_t tmp ;
  void *tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  void *tmp___3 ;
  int i ;
  void *tmp___4 ;
  char *tmp___5 ;

  {
#line 96
  tmp = strlen((char const   *)str);
#line 96
  tmp___0 = malloc((tmp + 1UL) * sizeof(char ));
#line 96
  str2 = (char *)tmp___0;
#line 97
  tmp___1 = strlen((char const   *)str);
#line 97
  strncpy((char * __restrict  )str2, (char const   * __restrict  )str, tmp___1);
#line 98
  tmp___2 = strlen((char const   *)str);
#line 98
  *(str2 + tmp___2) = (char)0;
#line 99
  tmp___3 = malloc(sizeof(char *));
#line 99
  *array = (char **)tmp___3;
#line 101
  i = 0;
#line 101
  while (1) {
#line 101
    tmp___5 = strsep((char ** __restrict  )(& str2), (char const   * __restrict  )separator);
#line 101
    *(*array + i) = tmp___5;
#line 101
    if (! tmp___5) {
#line 101
      break;
    }
#line 102
    tmp___4 = realloc((void *)*array, (unsigned long )(i + 2) * sizeof(char *));
#line 102
    *array = (char **)tmp___4;
#line 101
    i ++;
  }
#line 103
  free((void *)str2);
#line 104
  return (i);
}
}
#line 107 "strutil.c"
void strput(char *dest , int pos , char *text , int len ) 
{ 
  int i ;

  {
#line 110
  i = 0;
#line 110
  while (i < len) {
#line 111
    *(dest + (pos + i)) = *(text + i);
#line 110
    i ++;
  }
#line 112
  return;
}
}
#line 114 "strutil.c"
int digit(int num , int pos , int base ) 
{ 
  int num2 ;
  int i ;

  {
#line 116
  num2 = num;
#line 118
  i = 0;
#line 118
  while (i < pos) {
#line 119
    num2 /= base;
#line 118
    i ++;
  }
#line 120
  return (num2 % base);
}
}
#line 123 "strutil.c"
int strint(char *str , int len ) 
{ 
  int total ;
  int m ;
  int i ;
  int ch ;

  {
#line 125
  total = 0;
#line 126
  m = 1;
#line 128
  i = 0;
#line 128
  while (i < len) {
#line 130
    ch = (int )((unsigned char )*(str + ((len - 1) - i)));
#line 131
    total += ch * m;
#line 132
    m *= 256;
#line 128
    i ++;
  }
#line 134
  return (total);
}
}
#line 137 "strutil.c"
int StrLen(char *str ) 
{ 
  int x ;

  {
#line 140
  x = 0;
#line 140
  while ((int )*(str + x) != 0) {
#line 140
    x ++;
  }
#line 141
  return (x);
}
}
#line 148 "strutil.c"
int strarrlen(char **strarr ) 
{ 
  int c___0 ;

  {
#line 151
  c___0 = 0;
#line 151
  while ((unsigned long )*(strarr + c___0) != (unsigned long )((char *)0)) {
#line 151
    c___0 ++;
  }
#line 152
  return (c___0);
}
}
#line 155 "strutil.c"
int strarrdel(char ***strarr , char *str ) 
{ 
  int i ;
  int l ;
  int tmp ;
  void *tmp___0 ;
  int tmp___1 ;

  {
#line 157
  tmp = strarrlen(*strarr);
#line 157
  l = tmp;
#line 158
  if (l == 0) {
#line 158
    return (1);
  }
#line 159
  i = 0;
#line 159
  while (i < l) {
#line 160
    tmp___1 = strcmp((char const   *)*(*strarr + i), (char const   *)str);
#line 160
    if (tmp___1 == 0) {
#line 162
      free((void *)*(*strarr + i));
#line 163
      *(*strarr + i) = *(*strarr + (l - 1));
#line 164
      *(*strarr + (l - 1)) = (char *)0;
#line 165
      tmp___0 = realloc((void *)*strarr, (unsigned long )l * sizeof(char *));
#line 165
      *strarr = (char **)tmp___0;
#line 166
      return (0);
    }
#line 159
    i ++;
  }
#line 168
  return (1);
}
}
#line 179 "strutil.c"
int isUser(char **uA , char *uS ) 
{ 
  int i ;
  int sI ;
  int tmp ;
  int tmp___0 ;

  {
#line 181
  tmp = strarrlen(uA);
#line 181
  sI = tmp;
#line 183
  i = 0;
#line 183
  while (i < sI) {
#line 185
    tmp___0 = strcasecmp((char const   *)*(uA + i), (char const   *)uS);
#line 185
    if (tmp___0 == 0) {
#line 185
      return (1);
    }
#line 183
    i ++;
  }
#line 187
  return (0);
}
}
#line 196 "strutil.c"
int toggleIgnore(char ***uA , char *uS ) 
{ 
  int l ;
  void *tmp ;
  int tmp___0 ;

  {
#line 200
  tmp___0 = strarrdel(uA, uS);
#line 200
  if (tmp___0) {
#line 202
    l = strarrlen(*uA);
#line 203
    l ++;
#line 203
    tmp = realloc((void *)*uA, (unsigned long )l * sizeof(char *));
#line 203
    *uA = (char **)tmp;
#line 204
    l --;
#line 204
    *(*uA + l) = strdup((char const   *)uS);
#line 205
    return (1);
  }
#line 207
  return (0);
}
}
#line 214 "strutil.c"
int serializeArray(char **uA , char *fS ) 
{ 
  FILE *fP ;
  FILE *tmp ;
  int tmp___0 ;

  {
#line 216
  tmp = fopen((char const   * __restrict  )fS, (char const   * __restrict  )"w+");
#line 216
  fP = tmp;
#line 218
  while (1) {
#line 220
    fprintf((FILE * __restrict  )fP, (char const   * __restrict  )"%s\n", *uA);
#line 218
    uA ++;
#line 218
    if (! *uA) {
#line 218
      break;
    }
  }
#line 222
  tmp___0 = fclose(fP);
#line 222
  return (tmp___0);
}
}
#line 228 "strutil.c"
char **unserializeArray(char *fS ) 
{ 
  char **rA ;
  char *tA ;
  char tC ;
  int i ;
  int i2 ;
  FILE *fP ;
  FILE *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  int tmp___2 ;
  void *tmp___3 ;
  int tmp___4 ;

  {
#line 234
  tmp = fopen((char const   * __restrict  )fS, (char const   * __restrict  )"r");
#line 234
  fP = tmp;
#line 236
  rA = (char **)((void *)0);
#line 237
  tA = (char *)((void *)0);
#line 238
  i = 0;
#line 238
  while (1) {
#line 238
    tmp___4 = feof(fP);
#line 238
    if (tmp___4) {
#line 238
      break;
    }
#line 240
    tmp___0 = realloc((void *)rA, (unsigned long )(i + 1) * sizeof(char *));
#line 240
    rA = (char **)tmp___0;
#line 241
    i2 = 0;
#line 241
    while (1) {
#line 241
      tmp___2 = _IO_getc(fP);
#line 241
      tC = (char )tmp___2;
#line 241
      if ((int )tC != 10) {
#line 241
        if (! ((int )tC != -1)) {
#line 241
          break;
        }
      } else {
#line 241
        break;
      }
#line 243
      tmp___1 = realloc((void *)tA, (unsigned long )(i2 + 1) * sizeof(char ));
#line 243
      tA = (char *)tmp___1;
#line 244
      *(tA + i2) = tC;
#line 241
      i2 ++;
    }
#line 246
    tmp___3 = realloc((void *)tA, (unsigned long )(i2 + 1) * sizeof(char ));
#line 246
    tA = (char *)tmp___3;
#line 247
    *(tA + i2) = (char)0;
#line 248
    if ((int )tC != -1) {
#line 250
      *(rA + i) = tA;
    } else {
#line 254
      free((void *)tA);
#line 255
      *(rA + i) = (char *)0;
    }
#line 257
    tA = (char *)((void *)0);
#line 238
    i ++;
  }
#line 259
  return (rA);
}
}
#line 263 "strutil.c"
void mbcopy(char *src , char *dest , size_t len ) 
{ 
  char *tmp ;
  char *tmp___0 ;
  size_t tmp___1 ;
  char *lasts ;
  char *lastd ;
  char *tmp___2 ;
  char *tmp___3 ;
  size_t tmp___4 ;

  {
#line 265
  if ((unsigned long )dest < (unsigned long )src) {
#line 266
    while (1) {
#line 266
      tmp___1 = len;
#line 266
      len --;
#line 266
      if (! tmp___1) {
#line 266
        break;
      }
#line 267
      tmp = dest;
#line 267
      dest ++;
#line 267
      tmp___0 = src;
#line 267
      src ++;
#line 267
      *tmp = *tmp___0;
    }
  } else {
#line 270
    lasts = src + (len - 1UL);
#line 271
    lastd = dest + (len - 1UL);
#line 272
    while (1) {
#line 272
      tmp___4 = len;
#line 272
      len --;
#line 272
      if (! tmp___4) {
#line 272
        break;
      }
#line 273
      tmp___2 = lastd;
#line 273
      lastd --;
#line 273
      tmp___3 = lasts;
#line 273
      lasts --;
#line 273
      *tmp___2 = *tmp___3;
    }
  }
#line 275
  return;
}
}
#line 284 "strutil.c"
int is_instr(char c___0 , char *str ) 
{ 


  {
#line 288
  if ((int )*str == 0) {
#line 289
    return (1);
  }
#line 291
  while ((int )*str != 0) {
#line 292
    if ((int )c___0 == (int )*str) {
#line 293
      return (1);
    }
#line 294
    str ++;
  }
#line 297
  return (0);
}
}
#line 308 "strutil.c"
void strip_crlf(char *buf ) 
{ 
  char *p ;
  size_t tmp ;

  {
#line 314
  tmp = strlen((char const   *)buf);
#line 314
  p = buf + (tmp - 1UL);
#line 316
  while (1) {
#line 316
    if (! ((int )*p == 10)) {
#line 316
      if (! ((int )*p == 13)) {
#line 316
        break;
      }
    }
#line 317
    *p = (char )'\000';
#line 319
    if ((unsigned long )p == (unsigned long )buf) {
#line 320
      break;
    }
#line 321
    p --;
  }
#line 323
  return;
}
}
#line 329 "strutil.c"
int is_DblHash(char *buf ) 
{ 
  char *p ;

  {
#line 334
  p = buf + 0;
#line 335
  if ((int )*p == 35) {
#line 335
    p ++;
#line 335
    if ((int )*p == 35) {
#line 336
      return (1);
    }
  }
#line 339
  return (0);
}
}
#line 348 "strutil.c"
void *omemdup(void const   *ptr , size_t size ) 
{ 
  void *newptr ;
  void *tmp ;

  {
#line 350
  tmp = malloc(size);
#line 350
  newptr = tmp;
#line 352
  if (! newptr) {
#line 353
    return ((void *)0);
  }
#line 354
  memcpy((void * __restrict  )newptr, (void const   * __restrict  )ptr, size);
#line 355
  return (newptr);
}
}
#line 358 "strutil.c"
void strrep(char *str , char fm , char to ) 
{ 


  {
#line 360
  while (*str) {
#line 361
    if ((int )*str == (int )fm) {
#line 362
      *str = to;
    }
#line 364
    str ++;
  }
#line 366
  return;
}
}
#line 388 "strutil.c"
void pdbzero(char *to , int count ) 
{ 
  char *tmp ;
  int tmp___0 ;

  {
#line 393
  while (1) {
#line 393
    tmp___0 = count;
#line 393
    count --;
#line 393
    if (! (tmp___0 > 0)) {
#line 393
      break;
    }
#line 395
    tmp = to;
#line 395
    to ++;
#line 395
    *tmp = (char)0;
  }
#line 397
  return;
}
}
#line 430 "strutil.c"
int pdbcmp(char *from , char *to , size_t count ) 
{ 
  int rtnval ;
  char *tmp ;
  char *tmp___0 ;
  size_t tmp___1 ;

  {
#line 432
  rtnval = 0;
#line 434
  while (1) {
#line 434
    tmp___1 = count;
#line 434
    count --;
#line 434
    if (! (tmp___1 > 0UL)) {
#line 434
      break;
    }
#line 436
    tmp = from;
#line 436
    from ++;
#line 436
    tmp___0 = to;
#line 436
    to ++;
#line 436
    if ((int )*tmp != (int )*tmp___0) {
#line 438
      rtnval = 1;
#line 439
      break;
    }
  }
#line 442
  return (rtnval);
}
}
#line 464 "strutil.c"
char *pdstrchr(char const   *s___0 , int c___0 ) 
{ 
  char const   *tmp ;

  {
#line 466
  while (1) {
#line 467
    if ((int const   )*s___0 == (int const   )c___0) {
#line 469
      return ((char *)s___0);
    }
#line 466
    tmp = s___0;
#line 466
    s___0 ++;
#line 466
    if (! *tmp) {
#line 466
      break;
    }
  }
#line 472
  return ((char *)0);
}
}
#line 481 "strutil.c"
char *ostrdup(char *s___0 ) 
{ 
  char *result ;
  size_t tmp ;
  void *tmp___0 ;

  {
#line 483
  tmp = strlen((char const   *)s___0);
#line 483
  tmp___0 = malloc(tmp + 1UL);
#line 483
  result = (char *)tmp___0;
#line 484
  if ((unsigned long )result == (unsigned long )((char *)0)) {
#line 485
    return ((char *)0);
  }
#line 486
  strcpy((char * __restrict  )result, (char const   * __restrict  )s___0);
#line 487
  return (result);
}
}
/* compiler builtin: 
   int __builtin_bswap32(int  ) ;  */
#line 1 "tcp.o"
#pragma merger("0","/tmp/cil-C_iM9nOG.i","-Os,-fomit-frame-pointer,-fstack-protector-all")
#line 44 "/usr/include/x86_64-linux-gnu/bits/byteswap.h"
__inline static unsigned int __bswap_32(unsigned int __bsx ) 
{ 
  int tmp ;

  {
#line 47
  tmp = __builtin_bswap32((int )__bsx);
#line 47
  return ((unsigned int )tmp);
}
}
#line 114 "/usr/include/x86_64-linux-gnu/sys/socket.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) socket)(int __domain ,
                                                                             int __type ,
                                                                             int __protocol ) ;
#line 124
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) bind)(int __fd ,
                                                                           struct sockaddr  const  *__addr ,
                                                                           socklen_t __len ) ;
#line 138
extern int connect(int __fd , struct sockaddr  const  *__addr , socklen_t __len ) ;
#line 227
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) setsockopt)(int __fd ,
                                                                                 int __level ,
                                                                                 int __optname ,
                                                                                 void const   *__optval ,
                                                                                 socklen_t __optlen ) ;
#line 234
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) listen)(int __fd ,
                                                                             int __n ) ;
#line 144 "/usr/include/netdb.h"
extern struct hostent *gethostbyname(char const   *__name ) ;
#line 357
extern struct protoent *getprotobyname(char const   *__name ) ;
#line 18 "tcp.c"
int tcp_connect(char *host , int port ) 
{ 
  struct protoent *proto ;
  struct protoent *tmp ;
  int sock ;
  struct hostent *remotehost ;
  struct sockaddr_in addr ;
  register unsigned short __v ;
  register unsigned short __x ;
  int tmp___0 ;

  {
#line 41
  tmp = getprotobyname("tcp");
#line 41
  proto = tmp;
#line 43
  sock = socket(2, 1, proto->p_proto);
#line 43
  if (sock == -1) {
#line 44
    return (-1);
  }
#line 46
  remotehost = gethostbyname((char const   *)host);
#line 46
  if ((unsigned long )remotehost == (unsigned long )((struct hostent *)0)) {
#line 47
    return (-2);
  }
#line 49
  bzero((void *)(addr.sin_zero), (size_t )8);
#line 50
  addr.sin_family = (sa_family_t )2;
#line 51
  __x = (unsigned short )port;
#line 51
  __asm__  ("rorw $8, %w0": "=r" (__v): "0" (__x): "cc");
#line 51
  addr.sin_port = __v;
#line 52
  addr.sin_addr = *((struct in_addr *)*(remotehost->h_addr_list + 0));
#line 53
  tmp___0 = connect(sock, (struct sockaddr  const  *)((struct sockaddr *)(& addr)),
                    (socklen_t )sizeof(struct sockaddr ));
#line 53
  if (tmp___0 == -1) {
#line 54
    return (-3);
  }
#line 55
  return (sock);
}
}
#line 58 "tcp.c"
int tcp_listen(int port ) 
{ 
  struct protoent *proto ;
  struct protoent *tmp ;
  int sock ;
  int reuseaddr ;
  int tmp___0 ;
  struct sockaddr_in localsockaddr ;
  register unsigned short __v ;
  register unsigned short __x ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 65
  tmp = getprotobyname("tcp");
#line 65
  proto = tmp;
#line 67
  sock = socket(2, 1, proto->p_proto);
#line 67
  if (sock == -1) {
#line 69
    return (-1);
  }
#line 70
  reuseaddr = 1;
#line 71
  tmp___0 = setsockopt(sock, 1, 2, (void const   *)(& reuseaddr), (socklen_t )sizeof(int ));
#line 71
  if (tmp___0 == -1) {
#line 72
    return (-2);
  }
#line 74
  bzero((void *)(localsockaddr.sin_zero), sizeof(localsockaddr.sin_zero));
#line 75
  localsockaddr.sin_family = (sa_family_t )2;
#line 76
  localsockaddr.sin_addr.s_addr = __bswap_32((in_addr_t )0);
#line 77
  __x = (unsigned short )port;
#line 77
  __asm__  ("rorw $8, %w0": "=r" (__v): "0" (__x): "cc");
#line 77
  localsockaddr.sin_port = __v;
#line 78
  tmp___1 = bind(sock, (struct sockaddr  const  *)((struct sockaddr *)(& localsockaddr)),
                 (socklen_t )sizeof(localsockaddr));
#line 78
  if (tmp___1 == -1) {
#line 79
    return (-3);
  }
#line 80
  tmp___2 = listen(sock, 128);
#line 80
  if (tmp___2 == -1) {
#line 81
    return (-4);
  }
#line 82
  return (sock);
}
}
#line 1 "ycht.o"
#pragma merger("0","/tmp/cil-6GenTMem.i","-Os,-fomit-frame-pointer,-fstack-protector-all")
#line 13 "ycht.c"
int yauth(char *username___0 , char *password , char **auth ) 
{ 
  char *request ;
  void *tmp ;
  char *header ;
  char *body ;
  int error ;
  char **lines ;
  int linecount ;
  int tmp___0 ;
  char *part1 ;
  char *part2 ;
  int i ;
  char *cookiedata ;
  size_t tmp___1 ;
  char *tmp___2 ;
  char **cookie ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
#line 15
  tmp = malloc((size_t )65537);
#line 15
  request = (char *)tmp;
#line 16
  oasprintf(& request, (char *)"/config/login?.src=&login=%s&passwd=%s&n=1", username___0,
            password);
#line 22
  error = http_get((char *)"login.yahoo.com", 80, request, & header, & body);
#line 22
  if (error < 0) {
#line 23
    return (error);
  }
#line 27
  free((void *)request);
#line 28
  free((void *)body);
#line 30
  tmp___0 = split((char *)"\n", header, & lines);
#line 30
  linecount = tmp___0;
#line 31
  free((void *)header);
#line 32
  part1 = (char *)0;
#line 32
  part2 = (char *)0;
#line 34
  i = 0;
#line 34
  while (i < linecount) {
#line 35
    tmp___5 = strncmp((char const   *)*(lines + i), "Set-Cookie: ", (size_t )12);
#line 35
    if (tmp___5 == 0) {
#line 37
      tmp___1 = strlen((char const   *)*(lines + i));
#line 37
      tmp___2 = substr(*(lines + i), 12, tmp___1 - 13UL);
#line 37
      cookiedata = tmp___2;
#line 39
      split((char *)"; ", cookiedata, & cookie);
#line 40
      free((void *)cookiedata);
#line 41
      tmp___3 = strncmp((char const   *)*(cookie + 0), "Y=", (size_t )2);
#line 41
      if (tmp___3 == 0) {
#line 42
        part1 = *(cookie + 0);
      }
#line 43
      tmp___4 = strncmp((char const   *)*(cookie + 0), "T=", (size_t )2);
#line 43
      if (tmp___4 == 0) {
#line 44
        part2 = *(cookie + 0);
      }
#line 45
      free((void *)cookie);
    }
#line 34
    i ++;
  }
#line 47
  free((void *)lines);
#line 48
  if ((unsigned long )part1 == (unsigned long )((char *)0)) {
#line 49
    return (-4);
  } else
#line 48
  if ((unsigned long )part2 == (unsigned long )((char *)0)) {
#line 49
    return (-4);
  } else {
#line 48
    tmp___6 = strcmp((char const   *)part2, "T=z=0");
#line 48
    if (tmp___6 == 0) {
#line 49
      return (-4);
    }
  }
#line 50
  oasprintf(auth, (char *)"%s\001%s; %s", username___0, part1, part2);
#line 51
  free((void *)part1);
#line 52
  free((void *)part2);
#line 53
  return (0);
}
}
#line 56 "ycht.c"
void yrecv(int socket___0 ) 
{ 
  int c___0 ;
  char *header ;
  void *tmp ;
  int tmp___0 ;
  int len ;
  char *tmp___1 ;
  int tmp___2 ;
  char *content ;
  void *tmp___3 ;
  char *part ;
  void *tmp___4 ;
  int tmp___5 ;
  size_t tmp___6 ;
  char *tmp___7 ;
  int tmp___8 ;

  {
#line 59
  while (1) {
#line 61
    tmp = malloc(16UL * sizeof(char ));
#line 61
    header = (char *)tmp;
#line 65
    tmp___0 = (int )read(socket___0, header, 16);
#line 65
    if (tmp___0 == 0) {
#line 67
      break;
    }
#line 68
    tmp___1 = substr(header, 14, (size_t )2);
#line 68
    tmp___2 = strint(tmp___1, 2);
#line 68
    len = tmp___2;
#line 69
    tmp___3 = malloc((unsigned long )(len + 1) * sizeof(char ));
#line 69
    content = (char *)tmp___3;
#line 70
    bzero((void *)content, (size_t )(len + 1));
#line 71
    tmp___4 = malloc((unsigned long )(len + 1) * sizeof(char ));
#line 71
    part = (char *)tmp___4;
#line 75
    c___0 = (int )read(socket___0, content, len);
#line 77
    while (c___0 < len) {
#line 79
      bzero((void *)part, (size_t )(len + 1));
#line 83
      tmp___5 = (int )read(socket___0, part, len - c___0);
#line 83
      c___0 += tmp___5;
#line 85
      tmp___6 = strlen((char const   *)part);
#line 85
      strncat((char * __restrict  )content, (char const   * __restrict  )part, tmp___6);
    }
#line 87
    free((void *)part);
#line 88
    tmp___7 = substr(header, 10, (size_t )2);
#line 88
    tmp___8 = strint(tmp___7, 2);
#line 88
    yrecvd(tmp___8, content, len);
#line 89
    free((void *)header);
#line 90
    free((void *)content);
  }
#line 92
  return;
}
}
#line 94 "ycht.c"
void ycmd(int socket___0 , int service , char *text , int len ) 
{ 
  char header[16] ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  char *msg ;
  void *tmp___3 ;

  {
#line 96
  tmp = digit(service, 1, 256);
#line 96
  tmp___0 = digit(service, 0, 256);
#line 96
  tmp___1 = digit(len, 1, 256);
#line 96
  tmp___2 = digit(len, 0, 256);
#line 96
  header[0] = (char )'Y';
#line 96
  header[1] = (char )'C';
#line 96
  header[2] = (char )'H';
#line 96
  header[3] = (char )'T';
#line 96
  header[4] = (char)0;
#line 96
  header[5] = (char)0;
#line 96
  header[6] = (char)1;
#line 96
  header[7] = (char)0;
#line 96
  header[8] = (char)0;
#line 96
  header[9] = (char)0;
#line 96
  header[10] = (char )tmp;
#line 96
  header[11] = (char )tmp___0;
#line 96
  header[12] = (char)0;
#line 96
  header[13] = (char)0;
#line 96
  header[14] = (char )tmp___1;
#line 96
  header[15] = (char )tmp___2;
#line 97
  tmp___3 = malloc((unsigned long )(16 + len) * sizeof(char ));
#line 97
  msg = (char *)tmp___3;
#line 98
  strput(msg, 0, header, 16);
#line 99
  strput(msg, 16, text, len);
#line 103
  write(socket___0, msg, 16 + len);
#line 105
  free((void *)msg);
#line 106
  return;
}
}
#line 108 "ycht.c"
void ycmd_emote(int socket___0 , int service , char *text , int len ) 
{ 
  char header[16] ;
  int tmp ;
  int tmp___0 ;
  char *msg ;
  void *tmp___1 ;

  {
#line 110
  tmp = digit(len, 1, 256);
#line 110
  tmp___0 = digit(len, 0, 256);
#line 110
  header[0] = (char )'Y';
#line 110
  header[1] = (char )'C';
#line 110
  header[2] = (char )'H';
#line 110
  header[3] = (char )'T';
#line 110
  header[4] = (char)0;
#line 110
  header[5] = (char)0;
#line 110
  header[6] = (char)1;
#line 110
  header[7] = (char)0;
#line 110
  header[8] = (char)0;
#line 110
  header[9] = (char)0;
#line 110
  header[10] = (char)0;
#line 110
  header[11] = (char)67;
#line 110
  header[12] = (char)0;
#line 110
  header[13] = (char)0;
#line 110
  header[14] = (char )tmp;
#line 110
  header[15] = (char )tmp___0;
#line 111
  tmp___1 = malloc((unsigned long )(16 + len) * sizeof(char ));
#line 111
  msg = (char *)tmp___1;
#line 112
  strput(msg, 0, header, 16);
#line 113
  strput(msg, 16, text, len);
#line 117
  write(socket___0, msg, 16 + len);
#line 119
  free((void *)msg);
#line 120
  return;
}
}
#line 135 "ycht.c"
void ysay(int socket___0 , char *msg ) 
{ 
  char prefix[3] ;
  char *msg2 ;
  size_t tmp ;

  {
#line 137
  prefix[0] = (char)67;
#line 137
  prefix[1] = (char)1;
#line 137
  prefix[2] = (char)0;
#line 139
  oasprintf(& msg2, (char *)"%s%s", prefix, msg);
#line 140
  tmp = strlen((char const   *)msg2);
#line 140
  ycmd(socket___0, 65, msg2, (int )tmp);
#line 141
  free((void *)msg2);
#line 142
  return;
}
}
#line 144 "ycht.c"
void yemote(int socket___0 , char *msg ) 
{ 
  char prefix[3] ;
  char *msg2 ;
  size_t tmp ;

  {
#line 146
  prefix[0] = (char )' ';
#line 146
  prefix[1] = (char)1;
#line 146
  prefix[2] = (char)0;
#line 148
  oasprintf(& msg2, (char *)"%s%s", prefix, msg);
#line 149
  tmp = strlen((char const   *)msg2);
#line 149
  ycmd(socket___0, 67, msg2, (int )tmp);
#line 150
  free((void *)msg2);
#line 151
  return;
}
}
#line 153 "ycht.c"
void yfollow(int socket___0 , char *user ) 
{ 
  char prefix[6] ;
  char *msg2 ;
  size_t tmp ;

  {
#line 155
  prefix[0] = (char )'g';
#line 155
  prefix[1] = (char )'o';
#line 155
  prefix[2] = (char )'t';
#line 155
  prefix[3] = (char )'o';
#line 155
  prefix[4] = (char )' ';
#line 155
  prefix[5] = (char )'\000';
#line 157
  oasprintf(& msg2, (char *)"%s%s", prefix, user);
#line 158
  tmp = strlen((char const   *)msg2);
#line 158
  ycmd(socket___0, 113, msg2, (int )tmp);
#line 159
  free((void *)msg2);
#line 160
  return;
}
}
#line 166 "ycht.c"
void yping(int socket___0 ) 
{ 
  char msg[16] ;

  {
#line 168
  msg[0] = (char )'Y';
#line 168
  msg[1] = (char )'C';
#line 168
  msg[2] = (char )'H';
#line 168
  msg[3] = (char )'T';
#line 168
  msg[4] = (char)0;
#line 168
  msg[5] = (char)0;
#line 168
  msg[6] = (char)1;
#line 168
  msg[7] = (char)0;
#line 168
  msg[8] = (char)0;
#line 168
  msg[9] = (char)0;
#line 168
  msg[10] = (char)0;
#line 168
  msg[11] = (char)98;
#line 168
  msg[12] = (char)0;
#line 168
  msg[13] = (char)0;
#line 168
  msg[14] = (char)0;
#line 168
  msg[15] = (char)0;
#line 172
  write(socket___0, msg, 32);
#line 175
  return;
}
}
