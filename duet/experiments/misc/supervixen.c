/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is true */

#line 213 "/usr/lib/gcc/x86_64-linux-gnu/4.7/include/stddef.h"
typedef unsigned long size_t;
#line 133 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __dev_t;
#line 134 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __uid_t;
#line 135 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __gid_t;
#line 136 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __ino_t;
#line 138 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __mode_t;
#line 139 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __nlink_t;
#line 140 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 141 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 148 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 150 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __suseconds_t;
#line 162 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blksize_t;
#line 167 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blkcnt_t;
#line 181 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __ssize_t;
#line 184 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __syscall_slong_t;
#line 198 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __socklen_t;
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 40 "/usr/lib/gcc/x86_64-linux-gnu/4.7/include/stdarg.h"
typedef __builtin_va_list __gnuc_va_list;
#line 155 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 161 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 246 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 316 "/usr/include/libio.h"
typedef struct _IO_FILE _IO_FILE;
#line 79 "/usr/include/stdio.h"
typedef __gnuc_va_list va_list;
#line 102 "/usr/include/stdio.h"
typedef __ssize_t ssize_t;
#line 70 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __mode_t mode_t;
#line 28 "/usr/include/x86_64-linux-gnu/bits/sigset.h"
struct __anonstruct___sigset_t_6 {
   unsigned long __val[1024UL / (8UL * sizeof(unsigned long ))] ;
};
#line 28 "/usr/include/x86_64-linux-gnu/bits/sigset.h"
typedef struct __anonstruct___sigset_t_6 __sigset_t;
#line 120 "/usr/include/time.h"
struct timespec {
   __time_t tv_sec ;
   __syscall_slong_t tv_nsec ;
};
#line 30 "/usr/include/x86_64-linux-gnu/bits/time.h"
struct timeval {
   __time_t tv_sec ;
   __suseconds_t tv_usec ;
};
#line 54 "/usr/include/x86_64-linux-gnu/sys/select.h"
typedef long __fd_mask;
#line 64 "/usr/include/x86_64-linux-gnu/sys/select.h"
struct __anonstruct_fd_set_7 {
   __fd_mask __fds_bits[1024 / (8 * (int )sizeof(__fd_mask ))] ;
};
#line 64 "/usr/include/x86_64-linux-gnu/sys/select.h"
typedef struct __anonstruct_fd_set_7 fd_set;
#line 60 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef unsigned long pthread_t;
#line 43 "/usr/include/x86_64-linux-gnu/bits/uio.h"
struct iovec {
   void *iov_base ;
   size_t iov_len ;
};
#line 33 "/usr/include/x86_64-linux-gnu/bits/socket.h"
typedef __socklen_t socklen_t;
#line 28 "/usr/include/x86_64-linux-gnu/bits/sockaddr.h"
typedef unsigned short sa_family_t;
#line 147 "/usr/include/x86_64-linux-gnu/bits/socket.h"
struct sockaddr {
   sa_family_t sa_family ;
   char sa_data[14] ;
};
#line 222 "/usr/include/x86_64-linux-gnu/bits/socket.h"
struct msghdr {
   void *msg_name ;
   socklen_t msg_namelen ;
   struct iovec *msg_iov ;
   size_t msg_iovlen ;
   void *msg_control ;
   size_t msg_controllen ;
   int msg_flags ;
};
#line 240 "/usr/include/x86_64-linux-gnu/bits/socket.h"
struct cmsghdr {
   size_t cmsg_len ;
   int cmsg_level ;
   int cmsg_type ;
   unsigned char __cmsg_data[] ;
};
#line 48 "/usr/include/stdint.h"
typedef unsigned char uint8_t;
#line 49 "/usr/include/stdint.h"
typedef unsigned short uint16_t;
#line 51 "/usr/include/stdint.h"
typedef unsigned int uint32_t;
#line 96 "/usr/include/netinet/in.h"
typedef uint16_t in_port_t;
#line 140 "/usr/include/netinet/in.h"
typedef uint32_t in_addr_t;
#line 141 "/usr/include/netinet/in.h"
struct in_addr {
   in_addr_t s_addr ;
};
#line 197 "/usr/include/netinet/in.h"
union __anonunion___in6_u_23 {
   uint8_t __u6_addr8[16] ;
   uint16_t __u6_addr16[8] ;
   uint32_t __u6_addr32[4] ;
};
#line 197 "/usr/include/netinet/in.h"
struct in6_addr {
   union __anonunion___in6_u_23 __in6_u ;
};
#line 224 "/usr/include/netinet/in.h"
struct sockaddr_in {
   sa_family_t sin_family ;
   in_port_t sin_port ;
   struct in_addr sin_addr ;
   unsigned char sin_zero[((sizeof(struct sockaddr ) - sizeof(unsigned short )) - sizeof(in_port_t )) - sizeof(struct in_addr )] ;
};
#line 238 "/usr/include/netinet/in.h"
struct sockaddr_in6 {
   sa_family_t sin6_family ;
   in_port_t sin6_port ;
   uint32_t sin6_flowinfo ;
   struct in6_addr sin6_addr ;
   uint32_t sin6_scope_id ;
};
#line 567 "/usr/include/netdb.h"
struct addrinfo {
   int ai_flags ;
   int ai_family ;
   int ai_socktype ;
   int ai_protocol ;
   socklen_t ai_addrlen ;
   struct sockaddr *ai_addr ;
   char *ai_canonname ;
   struct addrinfo *ai_next ;
};
#line 325 "/usr/lib/gcc/x86_64-linux-gnu/4.7/include/stddef.h"
typedef int wchar_t;
#line 46 "/usr/include/x86_64-linux-gnu/bits/stat.h"
struct stat {
   __dev_t st_dev ;
   __ino_t st_ino ;
   __nlink_t st_nlink ;
   __mode_t st_mode ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   int __pad0 ;
   __dev_t st_rdev ;
   __off_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   __syscall_slong_t __unused[3] ;
};
#line 29 "/usr/include/x86_64-linux-gnu/sys/un.h"
struct sockaddr_un {
   sa_family_t sun_family ;
   char sun_path[108] ;
};
#line 75 "/usr/include/time.h"
typedef __time_t time_t;
#line 133 "/usr/include/time.h"
struct tm {
   int tm_sec ;
   int tm_min ;
   int tm_hour ;
   int tm_mday ;
   int tm_mon ;
   int tm_year ;
   int tm_wday ;
   int tm_yday ;
   int tm_isdst ;
   long tm_gmtoff ;
   char const   *tm_zone ;
};
#line 80 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __uid_t uid_t;
#line 50 "/usr/include/pwd.h"
struct passwd {
   char *pw_name ;
   char *pw_passwd ;
   __uid_t pw_uid ;
   __gid_t pw_gid ;
   char *pw_gecos ;
   char *pw_dir ;
   char *pw_shell ;
};
#line 24 "ozzylib.h"
struct pwinfo {
   struct passwd pw ;
   struct pwinfo *pi_next ;
};
#line 13 "ozzylib.h"
struct toz_conf {
   unsigned int line_no ;
   char *key ;
   char **param ;
   unsigned int param_use ;
   struct toz_conf *next ;
};
#line 22 "ozzylib.h"
typedef struct toz_conf oz_conf;
#line 56 "ozzy.h"
struct oz_errno_t {
   int error_code ;
   char *error_message ;
};
#line 75 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
struct __pthread_internal_list {
   struct __pthread_internal_list *__prev ;
   struct __pthread_internal_list *__next ;
};
#line 75 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef struct __pthread_internal_list __pthread_list_t;
#line 90 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
struct __pthread_mutex_s {
   int __lock ;
   unsigned int __count ;
   int __owner ;
   unsigned int __nusers ;
   int __kind ;
   int __spins ;
   __pthread_list_t __list ;
};
#line 90 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
union __anonunion_pthread_mutex_t_8 {
   struct __pthread_mutex_s __data ;
   char __size[40] ;
   long __align ;
};
#line 90 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef union __anonunion_pthread_mutex_t_8 pthread_mutex_t;
#line 92 "supervixen.h"
struct __anonstruct_tthreads_70 {
   int id ;
   int kind ;
   int pid ;
   int sockfd ;
   pthread_t thread ;
};
#line 92 "supervixen.h"
typedef struct __anonstruct_tthreads_70 tthreads;
#line 102 "supervixen.h"
struct __anonstruct_tservers_71 {
   char address[1024] ;
   int port ;
};
#line 102 "supervixen.h"
typedef struct __anonstruct_tservers_71 tservers;
#line 108 "supervixen.h"
struct __anonstruct_tsettings_72 {
   char realname[200] ;
   char nickname[20] ;
   char username[20] ;
   char hostname[1024] ;
   char *version ;
   char auth_user[1024] ;
   char auth_pass[1024] ;
   char fake_hostname[1024] ;
   int max_unauth_time ;
   int max_auth_tries ;
   int cli_pingsend ;
   int cli_pingtimeout ;
};
#line 108 "supervixen.h"
typedef struct __anonstruct_tsettings_72 tsettings;
#line 133 "supervixen.h"
struct commands_st {
   int id ;
   int from ;
   int cmdid ;
   void *param1 ;
   void *param2 ;
   void *param3 ;
   void *param4 ;
   struct commands_st *next ;
   struct commands_st *prev ;
};
#line 145 "supervixen.h"
typedef struct commands_st tcommands;
#line 147 "supervixen.h"
struct __anonstruct_tlisten_socks_74 {
   int sockfd ;
   char address[1024] ;
   unsigned int port ;
};
#line 147 "supervixen.h"
typedef struct __anonstruct_tlisten_socks_74 tlisten_socks;
#line 63 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
union pthread_attr_t {
   char __size[56] ;
   long __align ;
};
#line 69 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef union pthread_attr_t pthread_attr_t;
#line 120 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
union __anonunion_pthread_mutexattr_t_9 {
   char __size[4] ;
   int __align ;
};
#line 120 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef union __anonunion_pthread_mutexattr_t_9 pthread_mutexattr_t;
#line 85 "/usr/include/signal.h"
typedef void (*__sighandler_t)(int  );
#line 142 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __pid_t;
#line 124 "supervixen.h"
struct __anonstruct_irc_actions_73 {
   int code ;
   void *handler ;
   void *param1 ;
   void *param2 ;
   void *param3 ;
   void *param4 ;
};
#line 124 "supervixen.h"
typedef struct __anonstruct_irc_actions_73 irc_actions;
#line 149 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __useconds_t;
/* compiler builtin: 
   int __builtin_strcmp(char const   * , char const   * ) ;  */
/* compiler builtin: 
   void *__builtin___memmove_chk(void * , void const   * , unsigned long  , unsigned long  ) ;  */
/* compiler builtin: 
   char *__builtin_strchr(char * , int  ) ;  */
/* compiler builtin: 
   void *__builtin___memcpy_chk(void * , void const   * , unsigned long  , unsigned long  ) ;  */
/* compiler builtin: 
   int __builtin___vsprintf_chk(char * , int  , unsigned long  , char const   * ,
                                __builtin_va_list  ) ;  */
/* compiler builtin: 
   char *__builtin___strncpy_chk(char * , char const   * , unsigned long  , unsigned long  ) ;  */
/* compiler builtin: 
   void __builtin_va_end(__builtin_va_list  ) ;  */
/* compiler builtin: 
   char *__builtin___strcat_chk(char * , char const   * , unsigned long  ) ;  */
/* compiler builtin: 
   unsigned long __builtin_strlen(char const   * ) ;  */
/* compiler builtin: 
   unsigned long __builtin_object_size(void * , int  ) ;  */
/* compiler builtin: 
   int __builtin___sprintf_chk(char * , int  , unsigned long  , char const   *  , ...) ;  */
/* compiler builtin: 
   int __builtin___snprintf_chk(char * , unsigned long  , int  , unsigned long  ,
                                char const   *  , ...) ;  */
/* compiler builtin: 
   int __builtin___vsnprintf_chk(char * , unsigned long  , int  , unsigned long  ,
                                 char const   * , __builtin_va_list  ) ;  */
/* compiler builtin: 
   char *__builtin___strcpy_chk(char * , char const   * , unsigned long  ) ;  */
/* compiler builtin: 
   int __builtin_va_arg_pack_len(void) ;  */
/* compiler builtin: 
   void *__builtin___memset_chk(void * , int  , unsigned long  , unsigned long  ) ;  */
/* compiler builtin: 
   char *__builtin___strncat_chk(char * , char const   * , unsigned long  , unsigned long  ) ;  */
/* compiler builtin: 
   long __builtin_expect(long  , long  ) ;  */
/* compiler builtin: 
   int __builtin_va_arg_pack(void) ;  */
/* compiler builtin: 
   void __builtin_va_start(__builtin_va_list  ) ;  */
#line 1 "socket.o"
#pragma merger("0","/tmp/cil-TlAHCWYa.i","-Wall,-O3")
#line 392 "/usr/include/libio.h"
extern int __uflow(_IO_FILE * ) ;
#line 393
extern int __overflow(_IO_FILE * , int  ) ;
#line 435
extern int _IO_getc(_IO_FILE *__fp ) ;
#line 436
extern int _IO_putc(int __c , _IO_FILE *__fp ) ;
#line 168 "/usr/include/stdio.h"
extern struct _IO_FILE *stdin ;
#line 169
extern struct _IO_FILE *stdout ;
#line 356
__inline extern int ( __attribute__((__artificial__, __always_inline__)) fprintf)(FILE * __restrict  __stream ,
                                                                                  char const   * __restrict  __fmt 
                                                                                  , ...) ;
#line 362
__inline extern int ( __attribute__((__artificial__, __always_inline__)) printf)(char const   * __restrict  __fmt 
                                                                                 , ...) ;
#line 364
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__, __artificial__,
__always_inline__)) sprintf)(char * __restrict  __s , char const   * __restrict  __fmt 
                             , ...) ;
#line 371
__inline extern int ( __attribute__((__artificial__, __always_inline__)) vfprintf)(FILE * __restrict  __stream ,
                                                                                   char const   * __restrict  __fmt ,
                                                                                   __gnuc_va_list __ap ) ;
#line 377
__inline extern int ( __attribute__((__artificial__, __always_inline__)) vprintf)(char const   * __restrict  __fmt ,
                                                                                  __gnuc_va_list __ap ) ;
#line 379
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__, __artificial__,
__always_inline__)) vsprintf)(char * __restrict  __s , char const   * __restrict  __fmt ,
                              __gnuc_va_list __ap ) ;
#line 386
__inline extern  __attribute__((__nothrow__)) int ( /* format attribute */ __attribute__((__leaf__,
__artificial__, __always_inline__)) snprintf)(char * __restrict  __s , size_t __n ,
                                              char const   * __restrict  __fmt  , ...) ;
#line 390
__inline extern  __attribute__((__nothrow__)) int ( /* format attribute */ __attribute__((__leaf__,
__artificial__, __always_inline__)) vsnprintf)(char * __restrict  __s , size_t __n ,
                                               char const   * __restrict  __fmt ,
                                               __gnuc_va_list __ap ) ;
#line 412
__inline extern int ( /* format attribute */ __attribute__((__artificial__, __always_inline__)) vdprintf)(int __fd ,
                                                                                                          char const   * __restrict  __fmt ,
                                                                                                          __gnuc_va_list __ap ) ;
#line 415
__inline extern int ( /* format attribute */ __attribute__((__artificial__, __always_inline__)) dprintf)(int __fd ,
                                                                                                         char const   * __restrict  __fmt 
                                                                                                         , ...) ;
#line 538
__inline extern int getchar(void) ;
#line 551
__inline extern int getchar_unlocked(void) ;
#line 561
__inline extern int fgetc_unlocked(FILE *__fp ) ;
#line 580
__inline extern int putchar(int __c ) ;
#line 594
__inline extern int fputc_unlocked(int __c , FILE *__stream ) ;
#line 603
__inline extern int putchar_unlocked(int __c ) ;
#line 622
__inline extern char *( __attribute__((__warn_unused_result__, __artificial__, __always_inline__)) fgets)(char * __restrict  __s ,
                                                                                                          int __n ,
                                                                                                          FILE * __restrict  __stream ) ;
#line 638
__inline extern char *( __attribute__((__warn_unused_result__, __artificial__, __always_inline__)) gets)(char *__str )  __attribute__((__deprecated__)) ;
#line 709
__inline extern size_t ( __attribute__((__warn_unused_result__, __artificial__, __always_inline__)) fread)(void * __restrict  __ptr ,
                                                                                                           size_t __size ,
                                                                                                           size_t __n ,
                                                                                                           FILE * __restrict  __stream ) ;
#line 737
__inline extern size_t ( __attribute__((__warn_unused_result__, __artificial__, __always_inline__)) fread_unlocked)(void * __restrict  __ptr ,
                                                                                                                    size_t __size ,
                                                                                                                    size_t __n ,
                                                                                                                    FILE * __restrict  __stream ) ;
#line 836
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__warn_unused_result__,
__leaf__)) feof_unlocked)(FILE *__stream ) ;
#line 837
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__warn_unused_result__,
__leaf__)) ferror_unlocked)(FILE *__stream ) ;
#line 43 "/usr/include/x86_64-linux-gnu/bits/stdio.h"
__inline extern int getchar(void) 
{ 
  int tmp ;

  {
#line 46
  tmp = _IO_getc(stdin);
#line 46
  return (tmp);
}
}
#line 52 "/usr/include/x86_64-linux-gnu/bits/stdio.h"
__inline extern int fgetc_unlocked(FILE *__fp ) 
{ 
  int tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  long tmp___3 ;

  {
#line 55
  tmp___3 = __builtin_expect((long )((unsigned long )__fp->_IO_read_ptr >= (unsigned long )__fp->_IO_read_end),
                             0L);
#line 55
  if (tmp___3) {
#line 55
    tmp___0 = __uflow(__fp);
#line 55
    tmp___2 = tmp___0;
  } else {
#line 55
    tmp___1 = __fp->_IO_read_ptr;
#line 55
    (__fp->_IO_read_ptr) ++;
#line 55
    tmp___2 = (int )*((unsigned char *)tmp___1);
  }
#line 55
  return (tmp___2);
}
}
#line 69 "/usr/include/x86_64-linux-gnu/bits/stdio.h"
__inline extern int getchar_unlocked(void) 
{ 
  int tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  long tmp___3 ;

  {
#line 72
  tmp___3 = __builtin_expect((long )((unsigned long )stdin->_IO_read_ptr >= (unsigned long )stdin->_IO_read_end),
                             0L);
#line 72
  if (tmp___3) {
#line 72
    tmp___0 = __uflow(stdin);
#line 72
    tmp___2 = tmp___0;
  } else {
#line 72
    tmp___1 = stdin->_IO_read_ptr;
#line 72
    (stdin->_IO_read_ptr) ++;
#line 72
    tmp___2 = (int )*((unsigned char *)tmp___1);
  }
#line 72
  return (tmp___2);
}
}
#line 78 "/usr/include/x86_64-linux-gnu/bits/stdio.h"
__inline extern int putchar(int __c ) 
{ 
  int tmp ;

  {
#line 81
  tmp = _IO_putc(__c, stdout);
#line 81
  return (tmp);
}
}
#line 87 "/usr/include/x86_64-linux-gnu/bits/stdio.h"
__inline extern int fputc_unlocked(int __c , FILE *__stream ) 
{ 
  int tmp___0 ;
  char *tmp___1 ;
  char tmp___2 ;
  int tmp___3 ;
  long tmp___4 ;

  {
#line 90
  tmp___4 = __builtin_expect((long )((unsigned long )__stream->_IO_write_ptr >= (unsigned long )__stream->_IO_write_end),
                             0L);
#line 90
  if (tmp___4) {
#line 90
    tmp___0 = __overflow(__stream, (int )((unsigned char )__c));
#line 90
    tmp___3 = tmp___0;
  } else {
#line 90
    tmp___1 = __stream->_IO_write_ptr;
#line 90
    (__stream->_IO_write_ptr) ++;
#line 90
    tmp___2 = (char )__c;
#line 90
    *tmp___1 = tmp___2;
#line 90
    tmp___3 = (int )((unsigned char )tmp___2);
  }
#line 90
  return (tmp___3);
}
}
#line 104 "/usr/include/x86_64-linux-gnu/bits/stdio.h"
__inline extern int putchar_unlocked(int __c ) 
{ 
  int tmp___0 ;
  char *tmp___1 ;
  char tmp___2 ;
  int tmp___3 ;
  long tmp___4 ;

  {
#line 107
  tmp___4 = __builtin_expect((long )((unsigned long )stdout->_IO_write_ptr >= (unsigned long )stdout->_IO_write_end),
                             0L);
#line 107
  if (tmp___4) {
#line 107
    tmp___0 = __overflow(stdout, (int )((unsigned char )__c));
#line 107
    tmp___3 = tmp___0;
  } else {
#line 107
    tmp___1 = stdout->_IO_write_ptr;
#line 107
    (stdout->_IO_write_ptr) ++;
#line 107
    tmp___2 = (char )__c;
#line 107
    *tmp___1 = tmp___2;
#line 107
    tmp___3 = (int )((unsigned char )tmp___2);
  }
#line 107
  return (tmp___3);
}
}
#line 124
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__warn_unused_result__,
__leaf__)) feof_unlocked)(FILE *__stream ) ;
#line 124 "/usr/include/x86_64-linux-gnu/bits/stdio.h"
__inline extern int ( __attribute__((__warn_unused_result__, __leaf__)) feof_unlocked)(FILE *__stream ) 
{ 


  {
#line 127
  return ((__stream->_flags & 16) != 0);
}
}
#line 131
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__warn_unused_result__,
__leaf__)) ferror_unlocked)(FILE *__stream ) ;
#line 131 "/usr/include/x86_64-linux-gnu/bits/stdio.h"
__inline extern int ( __attribute__((__warn_unused_result__, __leaf__)) ferror_unlocked)(FILE *__stream ) 
{ 


  {
#line 134
  return ((__stream->_flags & 32) != 0);
}
}
#line 30 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__, __artificial__,
__always_inline__)) sprintf)(char * __restrict  __s , char const   * __restrict  __fmt 
                             , ...) ;
#line 30 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern int ( __attribute__((__leaf__, __artificial__, __always_inline__)) sprintf)(char * __restrict  __s ,
                                                                                            char const   * __restrict  __fmt 
                                                                                            , ...) 
{ 
  unsigned long tmp ;
  int tmp___0 ;

  {
#line 33
  tmp = __builtin_object_size((void *)__s, 1);
#line 33
  tmp___0 = __builtin___sprintf_chk((char *)__s, 1, tmp, (char const   *)__fmt, __builtin_va_arg_pack());
#line 33
  return (tmp___0);
}
}
#line 42
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__, __artificial__,
__always_inline__)) vsprintf)(char * __restrict  __s , char const   * __restrict  __fmt ,
                              __gnuc_va_list __ap ) ;
#line 42 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern int ( __attribute__((__leaf__, __artificial__, __always_inline__)) vsprintf)(char * __restrict  __s ,
                                                                                             char const   * __restrict  __fmt ,
                                                                                             __gnuc_va_list __ap ) 
{ 
  unsigned long tmp ;
  int tmp___0 ;

  {
#line 46
  tmp = __builtin_object_size((void *)__s, 1);
#line 46
  tmp___0 = __builtin___vsprintf_chk((char *)__s, 1, tmp, (char const   *)__fmt, __ap);
#line 46
  return (tmp___0);
}
}
#line 60
__inline extern  __attribute__((__nothrow__)) int ( /* format attribute */ __attribute__((__leaf__,
__artificial__, __always_inline__)) snprintf)(char * __restrict  __s , size_t __n ,
                                              char const   * __restrict  __fmt  , ...) ;
#line 60 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern int ( /* format attribute */ __attribute__((__leaf__, __artificial__,
__always_inline__)) snprintf)(char * __restrict  __s , size_t __n , char const   * __restrict  __fmt 
                              , ...) 
{ 
  unsigned long tmp ;
  int tmp___0 ;

  {
#line 64
  tmp = __builtin_object_size((void *)__s, 1);
#line 64
  tmp___0 = __builtin___snprintf_chk((char *)__s, __n, 1, tmp, (char const   *)__fmt,
                                     __builtin_va_arg_pack());
#line 64
  return (tmp___0);
}
}
#line 73
__inline extern  __attribute__((__nothrow__)) int ( /* format attribute */ __attribute__((__leaf__,
__artificial__, __always_inline__)) vsnprintf)(char * __restrict  __s , size_t __n ,
                                               char const   * __restrict  __fmt ,
                                               __gnuc_va_list __ap ) ;
#line 73 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern int ( /* format attribute */ __attribute__((__leaf__, __artificial__,
__always_inline__)) vsnprintf)(char * __restrict  __s , size_t __n , char const   * __restrict  __fmt ,
                               __gnuc_va_list __ap ) 
{ 
  unsigned long tmp ;
  int tmp___0 ;

  {
#line 77
  tmp = __builtin_object_size((void *)__s, 1);
#line 77
  tmp___0 = __builtin___vsnprintf_chk((char *)__s, __n, 1, tmp, (char const   *)__fmt,
                                      __ap);
#line 77
  return (tmp___0);
}
}
#line 85
extern int __fprintf_chk(FILE * __restrict  __stream , int __flag , char const   * __restrict  __format 
                         , ...) ;
#line 87
extern int __printf_chk(int __flag , char const   * __restrict  __format  , ...) ;
#line 88
extern int __vfprintf_chk(FILE * __restrict  __stream , int __flag , char const   * __restrict  __format ,
                          __gnuc_va_list __ap ) ;
#line 94 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern int ( __attribute__((__artificial__, __always_inline__)) fprintf)(FILE * __restrict  __stream ,
                                                                                  char const   * __restrict  __fmt 
                                                                                  , ...) 
{ 
  int tmp ;

  {
#line 97
  tmp = __fprintf_chk(__stream, 1, __fmt, __builtin_va_arg_pack());
#line 97
  return (tmp);
}
}
#line 101 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern int ( __attribute__((__artificial__, __always_inline__)) printf)(char const   * __restrict  __fmt 
                                                                                 , ...) 
{ 
  int tmp ;

  {
#line 104
  tmp = __printf_chk(1, __fmt, __builtin_va_arg_pack());
#line 104
  return (tmp);
}
}
#line 113 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern int ( __attribute__((__artificial__, __always_inline__)) vprintf)(char const   * __restrict  __fmt ,
                                                                                  __gnuc_va_list __ap ) 
{ 
  int tmp ;

  {
#line 117
  tmp = __vfprintf_chk((FILE * __restrict  )stdout, 1, __fmt, __ap);
#line 117
  return (tmp);
}
}
#line 123 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern int ( __attribute__((__artificial__, __always_inline__)) vfprintf)(FILE * __restrict  __stream ,
                                                                                   char const   * __restrict  __fmt ,
                                                                                   __gnuc_va_list __ap ) 
{ 
  int tmp ;

  {
#line 127
  tmp = __vfprintf_chk(__stream, 1, __fmt, __ap);
#line 127
  return (tmp);
}
}
#line 131
extern int ( /* format attribute */  __dprintf_chk)(int __fd , int __flag , char const   * __restrict  __fmt 
                                                    , ...) ;
#line 133
extern int ( /* format attribute */  __vdprintf_chk)(int __fd , int __flag , char const   * __restrict  __fmt ,
                                                     __gnuc_va_list __arg ) ;
#line 138 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern int ( /* format attribute */ __attribute__((__artificial__, __always_inline__)) dprintf)(int __fd ,
                                                                                                         char const   * __restrict  __fmt 
                                                                                                         , ...) 
{ 
  int tmp ;

  {
#line 141
  tmp = __dprintf_chk(__fd, 1, __fmt, __builtin_va_arg_pack());
#line 141
  return (tmp);
}
}
#line 149 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern int ( /* format attribute */ __attribute__((__artificial__, __always_inline__)) vdprintf)(int __fd ,
                                                                                                          char const   * __restrict  __fmt ,
                                                                                                          __gnuc_va_list __ap ) 
{ 
  int tmp ;

  {
#line 152
  tmp = __vdprintf_chk(__fd, 1, __fmt, __ap);
#line 152
  return (tmp);
}
}
#line 227
extern char *( __attribute__((__warn_unused_result__)) __gets_chk)(char *__str , size_t  ) ;
#line 228
extern char *( __attribute__((__warn_unused_result__)) __gets_warn)(char *__str )  __asm__("gets") __attribute__((__warning__("please use fgets or getline instead, gets can\'t specify buffer size"))) ;
#line 232
__inline extern char *( __attribute__((__warn_unused_result__, __artificial__, __always_inline__)) gets)(char *__str )  __attribute__((__deprecated__)) ;
#line 232 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern char *( __attribute__((__warn_unused_result__, __artificial__, __always_inline__)) gets)(char *__str ) 
{ 
  unsigned long tmp ;
  char *tmp___0 ;
  unsigned long tmp___1 ;
  char *tmp___2 ;

  {
#line 235
  tmp___1 = __builtin_object_size((void *)__str, 1);
#line 235
  if (tmp___1 != 0xffffffffffffffffUL) {
#line 236
    tmp = __builtin_object_size((void *)__str, 1);
#line 236
    tmp___0 = __gets_chk(__str, tmp);
#line 236
    return (tmp___0);
  }
#line 237
  tmp___2 = __gets_warn(__str);
#line 237
  return (tmp___2);
}
}
#line 241
extern char *( __attribute__((__warn_unused_result__)) __fgets_chk)(char * __restrict  __s ,
                                                                    size_t __size ,
                                                                    int __n , FILE * __restrict  __stream ) ;
#line 243
extern char *( __attribute__((__warn_unused_result__)) __fgets_alias)(char * __restrict  __s ,
                                                                      int __n , FILE * __restrict  __stream )  __asm__("fgets")  ;
#line 246
extern char *( __attribute__((__warn_unused_result__)) __fgets_chk_warn)(char * __restrict  __s ,
                                                                         size_t __size ,
                                                                         int __n ,
                                                                         FILE * __restrict  __stream )  __asm__("__fgets_chk") __attribute__((__warning__("fgets called with bigger size than length of destination buffer"))) ;
#line 252 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern char *( __attribute__((__warn_unused_result__, __artificial__, __always_inline__)) fgets)(char * __restrict  __s ,
                                                                                                          int __n ,
                                                                                                          FILE * __restrict  __stream ) 
{ 
  unsigned long tmp ;
  char *tmp___0 ;
  unsigned long tmp___1 ;
  char *tmp___2 ;
  unsigned long tmp___3 ;
  unsigned long tmp___4 ;
  char *tmp___5 ;

  {
#line 255
  tmp___4 = __builtin_object_size((void *)__s, 1);
#line 255
  if (tmp___4 != 0xffffffffffffffffUL) {
#line 258
    tmp = __builtin_object_size((void *)__s, 1);
#line 258
    tmp___0 = __fgets_chk(__s, tmp, __n, __stream);
#line 258
    return (tmp___0);
#line 260
    tmp___3 = __builtin_object_size((void *)__s, 1);
#line 260
    if ((size_t )__n > tmp___3) {
#line 261
      tmp___1 = __builtin_object_size((void *)__s, 1);
#line 261
      tmp___2 = __fgets_chk_warn(__s, tmp___1, __n, __stream);
#line 261
      return (tmp___2);
    }
  }
#line 263
  tmp___5 = __fgets_alias(__s, __n, __stream);
#line 263
  return (tmp___5);
}
}
#line 266
extern size_t ( __attribute__((__warn_unused_result__)) __fread_chk)(void * __restrict  __ptr ,
                                                                     size_t __ptrlen ,
                                                                     size_t __size ,
                                                                     size_t __n ,
                                                                     FILE * __restrict  __stream ) ;
#line 269
extern size_t ( __attribute__((__warn_unused_result__)) __fread_alias)(void * __restrict  __ptr ,
                                                                       size_t __size ,
                                                                       size_t __n ,
                                                                       FILE * __restrict  __stream )  __asm__("fread")  ;
#line 273
extern size_t ( __attribute__((__warn_unused_result__)) __fread_chk_warn)(void * __restrict  __ptr ,
                                                                          size_t __ptrlen ,
                                                                          size_t __size ,
                                                                          size_t __n ,
                                                                          FILE * __restrict  __stream )  __asm__("__fread_chk") __attribute__((__warning__("fread called with bigger size * nmemb than length of destination buffer"))) ;
#line 281 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern size_t ( __attribute__((__warn_unused_result__, __artificial__, __always_inline__)) fread)(void * __restrict  __ptr ,
                                                                                                           size_t __size ,
                                                                                                           size_t __n ,
                                                                                                           FILE * __restrict  __stream ) 
{ 
  unsigned long tmp ;
  size_t tmp___0 ;
  unsigned long tmp___1 ;
  size_t tmp___2 ;
  unsigned long tmp___3 ;
  unsigned long tmp___4 ;
  size_t tmp___5 ;

  {
#line 285
  tmp___4 = __builtin_object_size((void *)__ptr, 0);
#line 285
  if (tmp___4 != 0xffffffffffffffffUL) {
#line 290
    tmp = __builtin_object_size((void *)__ptr, 0);
#line 290
    tmp___0 = __fread_chk(__ptr, tmp, __size, __n, __stream);
#line 290
    return (tmp___0);
#line 292
    tmp___3 = __builtin_object_size((void *)__ptr, 0);
#line 292
    if (__size * __n > tmp___3) {
#line 293
      tmp___1 = __builtin_object_size((void *)__ptr, 0);
#line 293
      tmp___2 = __fread_chk_warn(__ptr, tmp___1, __size, __n, __stream);
#line 293
      return (tmp___2);
    }
  }
#line 295
  tmp___5 = __fread_alias(__ptr, __size, __n, __stream);
#line 295
  return (tmp___5);
}
}
#line 327
extern size_t ( __attribute__((__warn_unused_result__)) __fread_unlocked_chk)(void * __restrict  __ptr ,
                                                                              size_t __ptrlen ,
                                                                              size_t __size ,
                                                                              size_t __n ,
                                                                              FILE * __restrict  __stream ) ;
#line 330
extern size_t ( __attribute__((__warn_unused_result__)) __fread_unlocked_alias)(void * __restrict  __ptr ,
                                                                                size_t __size ,
                                                                                size_t __n ,
                                                                                FILE * __restrict  __stream )  __asm__("fread_unlocked")  ;
#line 334
extern size_t ( __attribute__((__warn_unused_result__)) __fread_unlocked_chk_warn)(void * __restrict  __ptr ,
                                                                                   size_t __ptrlen ,
                                                                                   size_t __size ,
                                                                                   size_t __n ,
                                                                                   FILE * __restrict  __stream )  __asm__("__fread_unlocked_chk") __attribute__((__warning__("fread_unlocked called with bigger size * nmemb than length of destination buffer"))) ;
#line 342 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern size_t ( __attribute__((__warn_unused_result__, __artificial__, __always_inline__)) fread_unlocked)(void * __restrict  __ptr ,
                                                                                                                    size_t __size ,
                                                                                                                    size_t __n ,
                                                                                                                    FILE * __restrict  __stream ) 
{ 
  unsigned long tmp ;
  size_t tmp___0 ;
  unsigned long tmp___1 ;
  size_t tmp___2 ;
  unsigned long tmp___3 ;
  unsigned long tmp___4 ;
  size_t tmp___11 ;

  {
#line 346
  tmp___4 = __builtin_object_size((void *)__ptr, 0);
#line 346
  if (tmp___4 != 0xffffffffffffffffUL) {
#line 351
    tmp = __builtin_object_size((void *)__ptr, 0);
#line 351
    tmp___0 = __fread_unlocked_chk(__ptr, tmp, __size, __n, __stream);
#line 351
    return (tmp___0);
#line 354
    tmp___3 = __builtin_object_size((void *)__ptr, 0);
#line 354
    if (__size * __n > tmp___3) {
#line 355
      tmp___1 = __builtin_object_size((void *)__ptr, 0);
#line 355
      tmp___2 = __fread_unlocked_chk_warn(__ptr, tmp___1, __size, __n, __stream);
#line 355
      return (tmp___2);
    }
  }
#line 380
  tmp___11 = __fread_unlocked_alias(__ptr, __size, __n, __stream);
#line 380
  return (tmp___11);
}
}
#line 190 "/usr/include/x86_64-linux-gnu/sys/syslog.h"
__inline extern void ( /* format attribute */ __attribute__((__artificial__, __always_inline__)) syslog)(int __pri ,
                                                                                                         char const   *__fmt 
                                                                                                         , ...) ;
#line 200
__inline extern void ( /* format attribute */ __attribute__((__artificial__, __always_inline__)) vsyslog)(int __pri ,
                                                                                                          char const   *__fmt ,
                                                                                                          __gnuc_va_list __ap ) ;
#line 24 "/usr/include/x86_64-linux-gnu/bits/syslog.h"
extern void ( /* format attribute */  __syslog_chk)(int __pri , int __flag , char const   *__fmt 
                                                    , ...) ;
#line 28 "/usr/include/x86_64-linux-gnu/bits/syslog.h"
__inline extern void ( /* format attribute */ __attribute__((__artificial__, __always_inline__)) syslog)(int __pri ,
                                                                                                         char const   *__fmt 
                                                                                                         , ...) 
{ 


  {
#line 31
  __syslog_chk(__pri, 1, __fmt, __builtin_va_arg_pack());
#line 32
  return;
}
}
#line 40
extern void ( /* format attribute */  __vsyslog_chk)(int __pri , int __flag , char const   *__fmt ,
                                                     __gnuc_va_list __ap ) ;
#line 44 "/usr/include/x86_64-linux-gnu/bits/syslog.h"
__inline extern void ( /* format attribute */ __attribute__((__artificial__, __always_inline__)) vsyslog)(int __pri ,
                                                                                                          char const   *__fmt ,
                                                                                                          __gnuc_va_list __ap ) 
{ 


  {
#line 47
  __vsyslog_chk(__pri, 1, __fmt, __ap);
#line 48
  return;
}
}
#line 106 "/usr/include/x86_64-linux-gnu/sys/select.h"
extern int select(int __nfds , fd_set * __restrict  __readfds , fd_set * __restrict  __writefds ,
                  fd_set * __restrict  __exceptfds , struct timeval * __restrict  __timeout ) ;
#line 24 "/usr/include/x86_64-linux-gnu/bits/select2.h"
extern long __fdelt_chk(long __d ) ;
#line 32 "/usr/include/x86_64-linux-gnu/sys/sysmacros.h"
__inline extern  __attribute__((__nothrow__)) unsigned int ( __attribute__((__leaf__)) gnu_dev_major)(unsigned long long __dev )  __attribute__((__const__)) ;
#line 35
__inline extern  __attribute__((__nothrow__)) unsigned int ( __attribute__((__leaf__)) gnu_dev_minor)(unsigned long long __dev )  __attribute__((__const__)) ;
#line 38
__inline extern  __attribute__((__nothrow__)) unsigned long long ( __attribute__((__leaf__)) gnu_dev_makedev)(unsigned int __major ,
                                                                                                              unsigned int __minor )  __attribute__((__const__)) ;
#line 43
__inline extern  __attribute__((__nothrow__)) unsigned int ( __attribute__((__leaf__)) gnu_dev_major)(unsigned long long __dev )  __attribute__((__const__)) ;
#line 43 "/usr/include/x86_64-linux-gnu/sys/sysmacros.h"
__inline extern unsigned int ( __attribute__((__leaf__)) gnu_dev_major)(unsigned long long __dev ) 
{ 


  {
#line 46
  return ((unsigned int )(((__dev >> 8) & 4095ULL) | (unsigned long long )((unsigned int )(__dev >> 32) & 4294963200U)));
}
}
#line 49
__inline extern  __attribute__((__nothrow__)) unsigned int ( __attribute__((__leaf__)) gnu_dev_minor)(unsigned long long __dev )  __attribute__((__const__)) ;
#line 49 "/usr/include/x86_64-linux-gnu/sys/sysmacros.h"
__inline extern unsigned int ( __attribute__((__leaf__)) gnu_dev_minor)(unsigned long long __dev ) 
{ 


  {
#line 52
  return ((unsigned int )((__dev & 255ULL) | (unsigned long long )((unsigned int )(__dev >> 12) & 4294967040U)));
}
}
#line 55
__inline extern  __attribute__((__nothrow__)) unsigned long long ( __attribute__((__leaf__)) gnu_dev_makedev)(unsigned int __major ,
                                                                                                              unsigned int __minor )  __attribute__((__const__)) ;
#line 55 "/usr/include/x86_64-linux-gnu/sys/sysmacros.h"
__inline extern unsigned long long ( __attribute__((__leaf__)) gnu_dev_makedev)(unsigned int __major ,
                                                                                unsigned int __minor ) 
{ 


  {
#line 58
  return (((unsigned long long )((__minor & 255U) | ((__major & 4095U) << 8)) | ((unsigned long long )(__minor & 4294967040U) << 12)) | ((unsigned long long )(__major & 4294963200U) << 32));
}
}
#line 270 "/usr/include/x86_64-linux-gnu/bits/socket.h"
__inline extern  __attribute__((__nothrow__)) struct cmsghdr *( __attribute__((__leaf__)) __cmsg_nxthdr)(struct msghdr *__mhdr ,
                                                                                                         struct cmsghdr *__cmsg ) ;
#line 276
__inline extern  __attribute__((__nothrow__)) struct cmsghdr *( __attribute__((__leaf__)) __cmsg_nxthdr)(struct msghdr *__mhdr ,
                                                                                                         struct cmsghdr *__cmsg ) ;
#line 276 "/usr/include/x86_64-linux-gnu/bits/socket.h"
__inline extern struct cmsghdr *( __attribute__((__leaf__)) __cmsg_nxthdr)(struct msghdr *__mhdr ,
                                                                           struct cmsghdr *__cmsg ) 
{ 


  {
#line 279
  if (__cmsg->cmsg_len < sizeof(struct cmsghdr )) {
#line 281
    return ((struct cmsghdr *)0);
  }
#line 283
  __cmsg = (struct cmsghdr *)((unsigned char *)__cmsg + (((__cmsg->cmsg_len + sizeof(size_t )) - 1UL) & ~ (sizeof(size_t ) - 1UL)));
#line 285
  if ((unsigned long )((unsigned char *)(__cmsg + 1)) > (unsigned long )((unsigned char *)__mhdr->msg_control + __mhdr->msg_controllen)) {
#line 290
    return ((struct cmsghdr *)0);
  } else
#line 285
  if ((unsigned long )((unsigned char *)__cmsg + (((__cmsg->cmsg_len + sizeof(size_t )) - 1UL) & ~ (sizeof(size_t ) - 1UL))) > (unsigned long )((unsigned char *)__mhdr->msg_control + __mhdr->msg_controllen)) {
#line 290
    return ((struct cmsghdr *)0);
  }
#line 291
  return (__cmsg);
}
}
#line 114 "/usr/include/x86_64-linux-gnu/sys/socket.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) socket)(int __domain ,
                                                                             int __type ,
                                                                             int __protocol ) ;
#line 124
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) bind)(int __fd ,
                                                                           struct sockaddr  const  *__addr ,
                                                                           socklen_t __len ) ;
#line 128
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) getsockname)(int __fd ,
                                                                                  struct sockaddr * __restrict  __addr ,
                                                                                  socklen_t * __restrict  __len ) ;
#line 138
extern int connect(int __fd , struct sockaddr  const  *__addr , socklen_t __len ) ;
#line 157
__inline extern ssize_t ( __attribute__((__artificial__, __always_inline__)) recv)(int __fd ,
                                                                                   void *__buf ,
                                                                                   size_t __n ,
                                                                                   int __flags ) ;
#line 164
extern ssize_t sendto(int __fd , void const   *__buf , size_t __n , int __flags ,
                      struct sockaddr  const  *__addr , socklen_t __addr_len ) ;
#line 175
__inline extern ssize_t ( __attribute__((__artificial__, __always_inline__)) recvfrom)(int __fd ,
                                                                                       void * __restrict  __buf ,
                                                                                       size_t __n ,
                                                                                       int __flags ,
                                                                                       struct sockaddr * __restrict  __addr ,
                                                                                       socklen_t * __restrict  __addr_len ) ;
#line 234
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) listen)(int __fd ,
                                                                             int __n ) ;
#line 23 "/usr/include/x86_64-linux-gnu/bits/socket2.h"
extern ssize_t __recv_chk(int __fd , void *__buf , size_t __n , size_t __buflen ,
                          int __flags ) ;
#line 25
extern ssize_t __recv_alias(int __fd , void *__buf , size_t __n , int __flags )  __asm__("recv")  ;
#line 27
extern ssize_t __recv_chk_warn(int __fd , void *__buf , size_t __n , size_t __buflen ,
                               int __flags )  __asm__("__recv_chk") __attribute__((__warning__("recv called with bigger length than size of destination buffer"))) ;
#line 33 "/usr/include/x86_64-linux-gnu/bits/socket2.h"
__inline extern ssize_t ( __attribute__((__artificial__, __always_inline__)) recv)(int __fd ,
                                                                                   void *__buf ,
                                                                                   size_t __n ,
                                                                                   int __flags ) 
{ 
  unsigned long tmp ;
  ssize_t tmp___0 ;
  unsigned long tmp___1 ;
  ssize_t tmp___2 ;
  unsigned long tmp___3 ;
  unsigned long tmp___4 ;
  ssize_t tmp___5 ;

  {
#line 36
  tmp___4 = __builtin_object_size(__buf, 0);
#line 36
  if (tmp___4 != 0xffffffffffffffffUL) {
#line 39
    tmp = __builtin_object_size(__buf, 0);
#line 39
    tmp___0 = __recv_chk(__fd, __buf, __n, tmp, __flags);
#line 39
    return (tmp___0);
#line 41
    tmp___3 = __builtin_object_size(__buf, 0);
#line 41
    if (__n > tmp___3) {
#line 42
      tmp___1 = __builtin_object_size(__buf, 0);
#line 42
      tmp___2 = __recv_chk_warn(__fd, __buf, __n, tmp___1, __flags);
#line 42
      return (tmp___2);
    }
  }
#line 44
  tmp___5 = __recv_alias(__fd, __buf, __n, __flags);
#line 44
  return (tmp___5);
}
}
#line 47
extern ssize_t __recvfrom_chk(int __fd , void * __restrict  __buf , size_t __n , size_t __buflen ,
                              int __flags , struct sockaddr * __restrict  __addr ,
                              socklen_t * __restrict  __addr_len ) ;
#line 51
extern ssize_t __recvfrom_alias(int __fd , void * __restrict  __buf , size_t __n ,
                                int __flags , struct sockaddr * __restrict  __addr ,
                                socklen_t * __restrict  __addr_len )  __asm__("recvfrom")  ;
#line 55
extern ssize_t __recvfrom_chk_warn(int __fd , void * __restrict  __buf , size_t __n ,
                                   size_t __buflen , int __flags , struct sockaddr * __restrict  __addr ,
                                   socklen_t * __restrict  __addr_len )  __asm__("__recvfrom_chk") __attribute__((__warning__("recvfrom called with bigger length than size of destination buffer"))) ;
#line 63 "/usr/include/x86_64-linux-gnu/bits/socket2.h"
__inline extern ssize_t ( __attribute__((__artificial__, __always_inline__)) recvfrom)(int __fd ,
                                                                                       void * __restrict  __buf ,
                                                                                       size_t __n ,
                                                                                       int __flags ,
                                                                                       struct sockaddr * __restrict  __addr ,
                                                                                       socklen_t * __restrict  __addr_len ) 
{ 
  unsigned long tmp ;
  ssize_t tmp___0 ;
  unsigned long tmp___1 ;
  ssize_t tmp___2 ;
  unsigned long tmp___3 ;
  unsigned long tmp___4 ;
  ssize_t tmp___5 ;

  {
#line 67
  tmp___4 = __builtin_object_size((void *)__buf, 0);
#line 67
  if (tmp___4 != 0xffffffffffffffffUL) {
#line 70
    tmp = __builtin_object_size((void *)__buf, 0);
#line 70
    tmp___0 = __recvfrom_chk(__fd, __buf, __n, tmp, __flags, __addr, __addr_len);
#line 70
    return (tmp___0);
#line 72
    tmp___3 = __builtin_object_size((void *)__buf, 0);
#line 72
    if (__n > tmp___3) {
#line 73
      tmp___1 = __builtin_object_size((void *)__buf, 0);
#line 73
      tmp___2 = __recvfrom_chk_warn(__fd, __buf, __n, tmp___1, __flags, __addr, __addr_len);
#line 73
      return (tmp___2);
    }
  }
#line 76
  tmp___5 = __recvfrom_alias(__fd, __buf, __n, __flags, __addr, __addr_len);
#line 76
  return (tmp___5);
}
}
#line 44 "/usr/include/strings.h"
__inline extern  __attribute__((__nothrow__)) void ( __attribute__((__nonnull__(1,2),
__leaf__, __artificial__, __always_inline__)) bcopy)(void const   *__src , void *__dest ,
                                                     size_t __len ) ;
#line 47
__inline extern  __attribute__((__nothrow__)) void ( __attribute__((__nonnull__(1),
__leaf__, __artificial__, __always_inline__)) bzero)(void *__dest , size_t __len ) ;
#line 662 "/usr/include/netdb.h"
extern int getaddrinfo(char const   * __restrict  __name , char const   * __restrict  __service ,
                       struct addrinfo  const  * __restrict  __req , struct addrinfo ** __restrict  __pai ) ;
#line 668
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) freeaddrinfo)(struct addrinfo *__ai ) ;
#line 144 "/usr/include/stdlib.h"
__inline extern  __attribute__((__nothrow__)) double ( __attribute__((__warn_unused_result__,
__nonnull__(1), __leaf__)) atof)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 147
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__warn_unused_result__,
__nonnull__(1), __leaf__)) atoi)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 150
__inline extern  __attribute__((__nothrow__)) long ( __attribute__((__warn_unused_result__,
__nonnull__(1), __leaf__)) atol)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 157
__inline extern  __attribute__((__nothrow__)) long long ( __attribute__((__warn_unused_result__,
__nonnull__(1), __leaf__)) atoll)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 164
extern  __attribute__((__nothrow__)) double ( __attribute__((__nonnull__(1), __leaf__)) strtod)(char const   * __restrict  __nptr ,
                                                                                                char ** __restrict  __endptr ) ;
#line 183
extern  __attribute__((__nothrow__)) long ( __attribute__((__nonnull__(1), __leaf__)) strtol)(char const   * __restrict  __nptr ,
                                                                                              char ** __restrict  __endptr ,
                                                                                              int __base ) ;
#line 209
extern  __attribute__((__nothrow__)) long long ( __attribute__((__nonnull__(1), __leaf__)) strtoll)(char const   * __restrict  __nptr ,
                                                                                                    char ** __restrict  __endptr ,
                                                                                                    int __base ) ;
#line 277
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__warn_unused_result__,
__nonnull__(1), __leaf__)) atoi)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 277 "/usr/include/stdlib.h"
__inline extern int ( __attribute__((__warn_unused_result__, __nonnull__(1), __leaf__)) atoi)(char const   *__nptr ) 
{ 
  long tmp ;

  {
#line 280
  tmp = strtol((char const   * __restrict  )__nptr, (char ** __restrict  )((char **)((void *)0)),
               10);
#line 280
  return ((int )tmp);
}
}
#line 282
__inline extern  __attribute__((__nothrow__)) long ( __attribute__((__warn_unused_result__,
__nonnull__(1), __leaf__)) atol)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 282 "/usr/include/stdlib.h"
__inline extern long ( __attribute__((__warn_unused_result__, __nonnull__(1), __leaf__)) atol)(char const   *__nptr ) 
{ 
  long tmp ;

  {
#line 285
  tmp = strtol((char const   * __restrict  )__nptr, (char ** __restrict  )((char **)((void *)0)),
               10);
#line 285
  return (tmp);
}
}
#line 291
__inline extern  __attribute__((__nothrow__)) long long ( __attribute__((__warn_unused_result__,
__nonnull__(1), __leaf__)) atoll)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 291 "/usr/include/stdlib.h"
__inline extern long long ( __attribute__((__warn_unused_result__, __nonnull__(1),
__leaf__)) atoll)(char const   *__nptr ) 
{ 
  long long tmp ;

  {
#line 294
  tmp = strtoll((char const   * __restrict  )__nptr, (char ** __restrict  )((char **)((void *)0)),
                10);
#line 294
  return (tmp);
}
}
#line 465
extern  __attribute__((__nothrow__)) void *( __attribute__((__warn_unused_result__,
__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 479
extern  __attribute__((__nothrow__)) void *( __attribute__((__warn_unused_result__,
__leaf__)) realloc)(void *__ptr , size_t __size ) ;
#line 482
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 733
__inline extern  __attribute__((__nothrow__)) char *( __attribute__((__warn_unused_result__,
__leaf__, __artificial__, __always_inline__)) realpath)(char const   * __restrict  __name ,
                                                        char * __restrict  __resolved ) ;
#line 866
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__warn_unused_result__,
__leaf__, __artificial__, __always_inline__)) wctomb)(char *__s , wchar_t __wchar ) ;
#line 870
__inline extern  __attribute__((__nothrow__)) size_t ( __attribute__((__leaf__, __artificial__,
__always_inline__)) mbstowcs)(wchar_t * __restrict  __dst , char const   * __restrict  __src ,
                              size_t __len ) ;
#line 873
__inline extern  __attribute__((__nothrow__)) size_t ( __attribute__((__leaf__, __artificial__,
__always_inline__)) wcstombs)(char * __restrict  __dst , wchar_t const   * __restrict  __src ,
                              size_t __len ) ;
#line 25 "/usr/include/x86_64-linux-gnu/bits/stdlib-float.h"
__inline extern  __attribute__((__nothrow__)) double ( __attribute__((__warn_unused_result__,
__nonnull__(1), __leaf__)) atof)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 25 "/usr/include/x86_64-linux-gnu/bits/stdlib-float.h"
__inline extern double ( __attribute__((__warn_unused_result__, __nonnull__(1), __leaf__)) atof)(char const   *__nptr ) 
{ 
  double tmp ;

  {
#line 28
  tmp = strtod((char const   * __restrict  )__nptr, (char ** __restrict  )((char **)((void *)0)));
#line 28
  return (tmp);
}
}
#line 23 "/usr/include/x86_64-linux-gnu/bits/stdlib.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__warn_unused_result__,
__leaf__)) __realpath_chk)(char const   * __restrict  __name , char * __restrict  __resolved ,
                           size_t __resolvedlen ) ;
#line 26
extern  __attribute__((__nothrow__)) char *( __attribute__((__warn_unused_result__,
__leaf__)) __realpath_alias)(char const   * __restrict  __name , char * __restrict  __resolved )  __asm__("realpath")  ;
#line 36
__inline extern  __attribute__((__nothrow__)) char *( __attribute__((__warn_unused_result__,
__leaf__, __artificial__, __always_inline__)) realpath)(char const   * __restrict  __name ,
                                                        char * __restrict  __resolved ) ;
#line 36 "/usr/include/x86_64-linux-gnu/bits/stdlib.h"
__inline extern char *( __attribute__((__warn_unused_result__, __leaf__, __artificial__,
__always_inline__)) realpath)(char const   * __restrict  __name , char * __restrict  __resolved ) 
{ 
  unsigned long tmp ;
  char *tmp___0 ;
  unsigned long tmp___1 ;
  char *tmp___2 ;

  {
#line 39
  tmp___1 = __builtin_object_size((void *)__resolved, 1);
#line 39
  if (tmp___1 != 0xffffffffffffffffUL) {
#line 45
    tmp = __builtin_object_size((void *)__resolved, 1);
#line 45
    tmp___0 = __realpath_chk(__name, __resolved, tmp);
#line 45
    return (tmp___0);
  }
#line 48
  tmp___2 = __realpath_alias(__name, __resolved);
#line 48
  return (tmp___2);
}
}
#line 52
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2), __leaf__)) __ptsname_r_chk)(int __fd ,
                                                                                                      char *__buf ,
                                                                                                      size_t __buflen ,
                                                                                                      size_t __nreal ) ;
#line 54
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2), __leaf__)) __ptsname_r_alias)(int __fd ,
                                                                                                        char *__buf ,
                                                                                                        size_t __buflen )  __asm__("ptsname_r")  ;
#line 57
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2), __leaf__)) __ptsname_r_chk_warn)(int __fd ,
                                                                                                           char *__buf ,
                                                                                                           size_t __buflen ,
                                                                                                           size_t __nreal )  __asm__("__ptsname_r_chk") __attribute__((__warning__("ptsname_r called with buflen bigger than size of buf"))) ;
#line 63
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__, __artificial__,
__always_inline__)) ptsname_r)(int __fd , char *__buf , size_t __buflen ) ;
#line 63
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__, __artificial__,
__always_inline__)) ptsname_r)(int __fd , char *__buf , size_t __buflen ) ;
#line 63 "/usr/include/x86_64-linux-gnu/bits/stdlib.h"
__inline extern int ( __attribute__((__leaf__, __artificial__, __always_inline__)) ptsname_r)(int __fd ,
                                                                                              char *__buf ,
                                                                                              size_t __buflen ) 
{ 
  unsigned long tmp ;
  int tmp___0 ;
  unsigned long tmp___1 ;
  int tmp___2 ;
  unsigned long tmp___3 ;
  unsigned long tmp___4 ;
  int tmp___5 ;

  {
#line 66
  tmp___4 = __builtin_object_size((void *)__buf, 1);
#line 66
  if (tmp___4 != 0xffffffffffffffffUL) {
#line 69
    tmp = __builtin_object_size((void *)__buf, 1);
#line 69
    tmp___0 = __ptsname_r_chk(__fd, __buf, __buflen, tmp);
#line 69
    return (tmp___0);
#line 70
    tmp___3 = __builtin_object_size((void *)__buf, 1);
#line 70
    if (__buflen > tmp___3) {
#line 71
      tmp___1 = __builtin_object_size((void *)__buf, 1);
#line 71
      tmp___2 = __ptsname_r_chk_warn(__fd, __buf, __buflen, tmp___1);
#line 71
      return (tmp___2);
    }
  }
#line 73
  tmp___5 = __ptsname_r_alias(__fd, __buf, __buflen);
#line 73
  return (tmp___5);
}
}
#line 77
extern  __attribute__((__nothrow__)) int ( __attribute__((__warn_unused_result__,
__leaf__)) __wctomb_chk)(char *__s , wchar_t __wchar , size_t __buflen ) ;
#line 79
extern  __attribute__((__nothrow__)) int ( __attribute__((__warn_unused_result__,
__leaf__)) __wctomb_alias)(char *__s , wchar_t __wchar )  __asm__("wctomb")  ;
#line 82
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__warn_unused_result__,
__leaf__, __artificial__, __always_inline__)) wctomb)(char *__s , wchar_t __wchar ) ;
#line 82 "/usr/include/x86_64-linux-gnu/bits/stdlib.h"
__inline extern int ( __attribute__((__warn_unused_result__, __leaf__, __artificial__,
__always_inline__)) wctomb)(char *__s , wchar_t __wchar ) 
{ 
  unsigned long tmp ;
  int tmp___0 ;
  unsigned long tmp___1 ;
  unsigned long tmp___2 ;
  int tmp___3 ;

  {
#line 92
  tmp___1 = __builtin_object_size((void *)__s, 1);
#line 92
  if (tmp___1 != 0xffffffffffffffffUL) {
#line 92
    tmp___2 = __builtin_object_size((void *)__s, 1);
#line 92
    if (16UL > tmp___2) {
#line 93
      tmp = __builtin_object_size((void *)__s, 1);
#line 93
      tmp___0 = __wctomb_chk(__s, __wchar, tmp);
#line 93
      return (tmp___0);
    }
  }
#line 94
  tmp___3 = __wctomb_alias(__s, __wchar);
#line 94
  return (tmp___3);
}
}
#line 98
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__leaf__)) __mbstowcs_chk)(wchar_t * __restrict  __dst ,
                                                                                        char const   * __restrict  __src ,
                                                                                        size_t __len ,
                                                                                        size_t __dstlen ) ;
#line 101
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__leaf__)) __mbstowcs_alias)(wchar_t * __restrict  __dst ,
                                                                                          char const   * __restrict  __src ,
                                                                                          size_t __len )  __asm__("mbstowcs")  ;
#line 105
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__leaf__)) __mbstowcs_chk_warn)(wchar_t * __restrict  __dst ,
                                                                                             char const   * __restrict  __src ,
                                                                                             size_t __len ,
                                                                                             size_t __dstlen )  __asm__("__mbstowcs_chk") __attribute__((__warning__("mbstowcs called with dst buffer smaller than len * sizeof (wchar_t)"))) ;
#line 112
__inline extern  __attribute__((__nothrow__)) size_t ( __attribute__((__leaf__, __artificial__,
__always_inline__)) mbstowcs)(wchar_t * __restrict  __dst , char const   * __restrict  __src ,
                              size_t __len ) ;
#line 112 "/usr/include/x86_64-linux-gnu/bits/stdlib.h"
__inline extern size_t ( __attribute__((__leaf__, __artificial__, __always_inline__)) mbstowcs)(wchar_t * __restrict  __dst ,
                                                                                                char const   * __restrict  __src ,
                                                                                                size_t __len ) 
{ 
  unsigned long tmp ;
  size_t tmp___0 ;
  unsigned long tmp___1 ;
  size_t tmp___2 ;
  unsigned long tmp___3 ;
  unsigned long tmp___4 ;
  size_t tmp___5 ;

  {
#line 116
  tmp___4 = __builtin_object_size((void *)__dst, 1);
#line 116
  if (tmp___4 != 0xffffffffffffffffUL) {
#line 119
    tmp = __builtin_object_size((void *)__dst, 1);
#line 119
    tmp___0 = __mbstowcs_chk(__dst, __src, __len, tmp / sizeof(wchar_t ));
#line 119
    return (tmp___0);
#line 122
    tmp___3 = __builtin_object_size((void *)__dst, 1);
#line 122
    if (__len > tmp___3 / sizeof(wchar_t )) {
#line 123
      tmp___1 = __builtin_object_size((void *)__dst, 1);
#line 123
      tmp___2 = __mbstowcs_chk_warn(__dst, __src, __len, tmp___1 / sizeof(wchar_t ));
#line 123
      return (tmp___2);
    }
  }
#line 126
  tmp___5 = __mbstowcs_alias(__dst, __src, __len);
#line 126
  return (tmp___5);
}
}
#line 130
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__leaf__)) __wcstombs_chk)(char * __restrict  __dst ,
                                                                                        wchar_t const   * __restrict  __src ,
                                                                                        size_t __len ,
                                                                                        size_t __dstlen ) ;
#line 133
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__leaf__)) __wcstombs_alias)(char * __restrict  __dst ,
                                                                                          wchar_t const   * __restrict  __src ,
                                                                                          size_t __len )  __asm__("wcstombs")  ;
#line 137
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__leaf__)) __wcstombs_chk_warn)(char * __restrict  __dst ,
                                                                                             wchar_t const   * __restrict  __src ,
                                                                                             size_t __len ,
                                                                                             size_t __dstlen )  __asm__("__wcstombs_chk") __attribute__((__warning__("wcstombs called with dst buffer smaller than len"))) ;
#line 143
__inline extern  __attribute__((__nothrow__)) size_t ( __attribute__((__leaf__, __artificial__,
__always_inline__)) wcstombs)(char * __restrict  __dst , wchar_t const   * __restrict  __src ,
                              size_t __len ) ;
#line 143 "/usr/include/x86_64-linux-gnu/bits/stdlib.h"
__inline extern size_t ( __attribute__((__leaf__, __artificial__, __always_inline__)) wcstombs)(char * __restrict  __dst ,
                                                                                                wchar_t const   * __restrict  __src ,
                                                                                                size_t __len ) 
{ 
  unsigned long tmp ;
  size_t tmp___0 ;
  unsigned long tmp___1 ;
  size_t tmp___2 ;
  unsigned long tmp___3 ;
  unsigned long tmp___4 ;
  size_t tmp___5 ;

  {
#line 147
  tmp___4 = __builtin_object_size((void *)__dst, 1);
#line 147
  if (tmp___4 != 0xffffffffffffffffUL) {
#line 150
    tmp = __builtin_object_size((void *)__dst, 1);
#line 150
    tmp___0 = __wcstombs_chk(__dst, __src, __len, tmp);
#line 150
    return (tmp___0);
#line 151
    tmp___3 = __builtin_object_size((void *)__dst, 1);
#line 151
    if (__len > tmp___3) {
#line 152
      tmp___1 = __builtin_object_size((void *)__dst, 1);
#line 152
      tmp___2 = __wcstombs_chk_warn(__dst, __src, __len, tmp___1);
#line 152
      return (tmp___2);
    }
  }
#line 154
  tmp___5 = __wcstombs_alias(__dst, __src, __len);
#line 154
  return (tmp___5);
}
}
#line 277 "/usr/include/pthread.h"
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) pthread_equal)(pthread_t __thread1 ,
                                                                                             pthread_t __thread2 )  __attribute__((__const__)) ;
#line 1143
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) pthread_equal)(pthread_t __thread1 ,
                                                                                             pthread_t __thread2 )  __attribute__((__const__)) ;
#line 1143 "/usr/include/pthread.h"
__inline extern int ( __attribute__((__leaf__)) pthread_equal)(pthread_t __thread1 ,
                                                               pthread_t __thread2 ) 
{ 


  {
#line 1146
  return (__thread1 == __thread2);
}
}
#line 353 "/usr/include/unistd.h"
extern int close(int __fd ) ;
#line 360
__inline extern ssize_t ( __attribute__((__warn_unused_result__, __artificial__, __always_inline__)) read)(int __fd ,
                                                                                                           void *__buf ,
                                                                                                           size_t __nbytes ) ;
#line 366
extern ssize_t ( __attribute__((__warn_unused_result__)) write)(int __fd , void const   *__buf ,
                                                                size_t __n ) ;
#line 511
__inline extern  __attribute__((__nothrow__)) char *( __attribute__((__warn_unused_result__,
__leaf__, __artificial__, __always_inline__)) getcwd)(char *__buf , size_t __size ) ;
#line 525
__inline extern  __attribute__((__nothrow__)) char __attribute__((__deprecated__))  *( __attribute__((__warn_unused_result__,
__nonnull__(1), __leaf__, __artificial__, __always_inline__)) getwd)(char *__buf )  __attribute__((__deprecated__)) ;
#line 623
__inline extern  __attribute__((__nothrow__)) size_t ( __attribute__((__leaf__, __artificial__,
__always_inline__)) confstr)(int __name , char *__buf , size_t __len ) ;
#line 711
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__warn_unused_result__,
__leaf__, __artificial__, __always_inline__)) getgroups)(int __size , __gid_t *__list ) ;
#line 796
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__warn_unused_result__,
__nonnull__(2), __leaf__, __artificial__, __always_inline__)) ttyname_r)(int __fd ,
                                                                         char *__buf ,
                                                                         size_t __buflen ) ;
#line 831
__inline extern  __attribute__((__nothrow__)) ssize_t ( __attribute__((__warn_unused_result__,
__nonnull__(1,2), __leaf__, __artificial__, __always_inline__)) readlink)(char const   * __restrict  __path ,
                                                                          char * __restrict  __buf ,
                                                                          size_t __len ) ;
#line 842
__inline extern  __attribute__((__nothrow__)) ssize_t ( __attribute__((__warn_unused_result__,
__nonnull__(2,3), __leaf__, __artificial__, __always_inline__)) readlinkat)(int __fd ,
                                                                            char const   * __restrict  __path ,
                                                                            char * __restrict  __buf ,
                                                                            size_t __len ) ;
#line 848
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) unlink)(char const   *__name ) ;
#line 879
__inline extern int ( __attribute__((__nonnull__(1), __artificial__, __always_inline__)) getlogin_r)(char *__buf ,
                                                                                                     size_t __buflen ) ;
#line 901
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1),
__leaf__, __artificial__, __always_inline__)) gethostname)(char *__buf , size_t __buflen ) ;
#line 919
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__warn_unused_result__,
__nonnull__(1), __leaf__, __artificial__, __always_inline__)) getdomainname)(char *__buf ,
                                                                             size_t __buflen ) ;
#line 23 "/usr/include/x86_64-linux-gnu/bits/unistd.h"
extern ssize_t ( __attribute__((__warn_unused_result__)) __read_chk)(int __fd , void *__buf ,
                                                                     size_t __nbytes ,
                                                                     size_t __buflen ) ;
#line 25
extern ssize_t ( __attribute__((__warn_unused_result__)) __read_alias)(int __fd ,
                                                                       void *__buf ,
                                                                       size_t __nbytes )  __asm__("read")  ;
#line 27
extern ssize_t ( __attribute__((__warn_unused_result__)) __read_chk_warn)(int __fd ,
                                                                          void *__buf ,
                                                                          size_t __nbytes ,
                                                                          size_t __buflen )  __asm__("__read_chk") __attribute__((__warning__("read called with bigger length than size of the destination buffer"))) ;
#line 33 "/usr/include/x86_64-linux-gnu/bits/unistd.h"
__inline extern ssize_t ( __attribute__((__warn_unused_result__, __artificial__, __always_inline__)) read)(int __fd ,
                                                                                                           void *__buf ,
                                                                                                           size_t __nbytes ) 
{ 
  unsigned long tmp ;
  ssize_t tmp___0 ;
  unsigned long tmp___1 ;
  ssize_t tmp___2 ;
  unsigned long tmp___3 ;
  unsigned long tmp___4 ;
  ssize_t tmp___5 ;

  {
#line 36
  tmp___4 = __builtin_object_size(__buf, 0);
#line 36
  if (tmp___4 != 0xffffffffffffffffUL) {
#line 39
    tmp = __builtin_object_size(__buf, 0);
#line 39
    tmp___0 = __read_chk(__fd, __buf, __nbytes, tmp);
#line 39
    return (tmp___0);
#line 41
    tmp___3 = __builtin_object_size(__buf, 0);
#line 41
    if (__nbytes > tmp___3) {
#line 42
      tmp___1 = __builtin_object_size(__buf, 0);
#line 42
      tmp___2 = __read_chk_warn(__fd, __buf, __nbytes, tmp___1);
#line 42
      return (tmp___2);
    }
  }
#line 44
  tmp___5 = __read_alias(__fd, __buf, __nbytes);
#line 44
  return (tmp___5);
}
}
#line 123
extern  __attribute__((__nothrow__)) ssize_t ( __attribute__((__warn_unused_result__,
__nonnull__(1,2), __leaf__)) __readlink_chk)(char const   * __restrict  __path , char * __restrict  __buf ,
                                             size_t __len , size_t __buflen ) ;
#line 127
extern  __attribute__((__nothrow__)) ssize_t ( __attribute__((__warn_unused_result__,
__nonnull__(1,2), __leaf__)) __readlink_alias)(char const   * __restrict  __path ,
                                               char * __restrict  __buf , size_t __len )  __asm__("readlink")  ;
#line 131
extern  __attribute__((__nothrow__)) ssize_t ( __attribute__((__warn_unused_result__,
__nonnull__(1,2), __leaf__)) __readlink_chk_warn)(char const   * __restrict  __path ,
                                                  char * __restrict  __buf , size_t __len ,
                                                  size_t __buflen )  __asm__("__readlink_chk") __attribute__((__warning__("readlink called with bigger length than size of destination buffer"))) ;
#line 138
__inline extern  __attribute__((__nothrow__)) ssize_t ( __attribute__((__warn_unused_result__,
__nonnull__(1,2), __leaf__, __artificial__, __always_inline__)) readlink)(char const   * __restrict  __path ,
                                                                          char * __restrict  __buf ,
                                                                          size_t __len ) ;
#line 138 "/usr/include/x86_64-linux-gnu/bits/unistd.h"
__inline extern ssize_t ( __attribute__((__warn_unused_result__, __nonnull__(1,2),
__leaf__, __artificial__, __always_inline__)) readlink)(char const   * __restrict  __path ,
                                                        char * __restrict  __buf ,
                                                        size_t __len ) 
{ 
  unsigned long tmp ;
  ssize_t tmp___0 ;
  unsigned long tmp___1 ;
  ssize_t tmp___2 ;
  unsigned long tmp___3 ;
  unsigned long tmp___4 ;
  ssize_t tmp___5 ;

  {
#line 142
  tmp___4 = __builtin_object_size((void *)__buf, 1);
#line 142
  if (tmp___4 != 0xffffffffffffffffUL) {
#line 145
    tmp = __builtin_object_size((void *)__buf, 1);
#line 145
    tmp___0 = __readlink_chk(__path, __buf, __len, tmp);
#line 145
    return (tmp___0);
#line 147
    tmp___3 = __builtin_object_size((void *)__buf, 1);
#line 147
    if (__len > tmp___3) {
#line 148
      tmp___1 = __builtin_object_size((void *)__buf, 1);
#line 148
      tmp___2 = __readlink_chk_warn(__path, __buf, __len, tmp___1);
#line 148
      return (tmp___2);
    }
  }
#line 150
  tmp___5 = __readlink_alias(__path, __buf, __len);
#line 150
  return (tmp___5);
}
}
#line 155
extern  __attribute__((__nothrow__)) ssize_t ( __attribute__((__warn_unused_result__,
__nonnull__(2,3), __leaf__)) __readlinkat_chk)(int __fd , char const   * __restrict  __path ,
                                               char * __restrict  __buf , size_t __len ,
                                               size_t __buflen ) ;
#line 159
extern  __attribute__((__nothrow__)) ssize_t ( __attribute__((__warn_unused_result__,
__nonnull__(2,3), __leaf__)) __readlinkat_alias)(int __fd , char const   * __restrict  __path ,
                                                 char * __restrict  __buf , size_t __len )  __asm__("readlinkat")  ;
#line 164
extern  __attribute__((__nothrow__)) ssize_t ( __attribute__((__warn_unused_result__,
__nonnull__(2,3), __leaf__)) __readlinkat_chk_warn)(int __fd , char const   * __restrict  __path ,
                                                    char * __restrict  __buf , size_t __len ,
                                                    size_t __buflen )  __asm__("__readlinkat_chk") __attribute__((__warning__("readlinkat called with bigger length than size of destination buffer"))) ;
#line 172
__inline extern  __attribute__((__nothrow__)) ssize_t ( __attribute__((__warn_unused_result__,
__nonnull__(2,3), __leaf__, __artificial__, __always_inline__)) readlinkat)(int __fd ,
                                                                            char const   * __restrict  __path ,
                                                                            char * __restrict  __buf ,
                                                                            size_t __len ) ;
#line 172 "/usr/include/x86_64-linux-gnu/bits/unistd.h"
__inline extern ssize_t ( __attribute__((__warn_unused_result__, __nonnull__(2,3),
__leaf__, __artificial__, __always_inline__)) readlinkat)(int __fd , char const   * __restrict  __path ,
                                                          char * __restrict  __buf ,
                                                          size_t __len ) 
{ 
  unsigned long tmp ;
  ssize_t tmp___0 ;
  unsigned long tmp___1 ;
  ssize_t tmp___2 ;
  unsigned long tmp___3 ;
  unsigned long tmp___4 ;
  ssize_t tmp___5 ;

  {
#line 176
  tmp___4 = __builtin_object_size((void *)__buf, 1);
#line 176
  if (tmp___4 != 0xffffffffffffffffUL) {
#line 179
    tmp = __builtin_object_size((void *)__buf, 1);
#line 179
    tmp___0 = __readlinkat_chk(__fd, __path, __buf, __len, tmp);
#line 179
    return (tmp___0);
#line 181
    tmp___3 = __builtin_object_size((void *)__buf, 1);
#line 181
    if (__len > tmp___3) {
#line 182
      tmp___1 = __builtin_object_size((void *)__buf, 1);
#line 182
      tmp___2 = __readlinkat_chk_warn(__fd, __path, __buf, __len, tmp___1);
#line 182
      return (tmp___2);
    }
  }
#line 185
  tmp___5 = __readlinkat_alias(__fd, __path, __buf, __len);
#line 185
  return (tmp___5);
}
}
#line 189
extern  __attribute__((__nothrow__)) char *( __attribute__((__warn_unused_result__,
__leaf__)) __getcwd_chk)(char *__buf , size_t __size , size_t __buflen ) ;
#line 191
extern  __attribute__((__nothrow__)) char *( __attribute__((__warn_unused_result__,
__leaf__)) __getcwd_alias)(char *__buf , size_t __size )  __asm__("getcwd")  ;
#line 193
extern  __attribute__((__nothrow__)) char *( __attribute__((__warn_unused_result__,
__leaf__)) __getcwd_chk_warn)(char *__buf , size_t __size , size_t __buflen )  __asm__("__getcwd_chk") __attribute__((__warning__("getcwd caller with bigger length than size of destination buffer"))) ;
#line 199
__inline extern  __attribute__((__nothrow__)) char *( __attribute__((__warn_unused_result__,
__leaf__, __artificial__, __always_inline__)) getcwd)(char *__buf , size_t __size ) ;
#line 199 "/usr/include/x86_64-linux-gnu/bits/unistd.h"
__inline extern char *( __attribute__((__warn_unused_result__, __leaf__, __artificial__,
__always_inline__)) getcwd)(char *__buf , size_t __size ) 
{ 
  unsigned long tmp ;
  char *tmp___0 ;
  unsigned long tmp___1 ;
  char *tmp___2 ;
  unsigned long tmp___3 ;
  unsigned long tmp___4 ;
  char *tmp___5 ;

  {
#line 202
  tmp___4 = __builtin_object_size((void *)__buf, 1);
#line 202
  if (tmp___4 != 0xffffffffffffffffUL) {
#line 205
    tmp = __builtin_object_size((void *)__buf, 1);
#line 205
    tmp___0 = __getcwd_chk(__buf, __size, tmp);
#line 205
    return (tmp___0);
#line 207
    tmp___3 = __builtin_object_size((void *)__buf, 1);
#line 207
    if (__size > tmp___3) {
#line 208
      tmp___1 = __builtin_object_size((void *)__buf, 1);
#line 208
      tmp___2 = __getcwd_chk_warn(__buf, __size, tmp___1);
#line 208
      return (tmp___2);
    }
  }
#line 210
  tmp___5 = __getcwd_alias(__buf, __size);
#line 210
  return (tmp___5);
}
}
#line 214
extern  __attribute__((__nothrow__)) char *( __attribute__((__warn_unused_result__,
__nonnull__(1), __leaf__)) __getwd_chk)(char *__buf , size_t buflen ) ;
#line 216
extern  __attribute__((__nothrow__)) char *( __attribute__((__warn_unused_result__,
__nonnull__(1), __leaf__)) __getwd_warn)(char *__buf )  __asm__("getwd") __attribute__((__warning__("please use getcwd instead, as getwd doesn\'t specify buffer size"))) ;
#line 220
__inline extern  __attribute__((__nothrow__)) char __attribute__((__deprecated__))  *( __attribute__((__warn_unused_result__,
__nonnull__(1), __leaf__, __artificial__, __always_inline__)) getwd)(char *__buf )  __attribute__((__deprecated__)) ;
#line 220 "/usr/include/x86_64-linux-gnu/bits/unistd.h"
__inline extern char __attribute__((__deprecated__))  *( __attribute__((__warn_unused_result__,
__nonnull__(1), __leaf__, __artificial__, __always_inline__)) getwd)(char *__buf ) 
{ 
  unsigned long tmp ;
  char *tmp___0 ;
  unsigned long tmp___1 ;
  char *tmp___2 ;

  {
#line 223
  tmp___1 = __builtin_object_size((void *)__buf, 1);
#line 223
  if (tmp___1 != 0xffffffffffffffffUL) {
#line 224
    tmp = __builtin_object_size((void *)__buf, 1);
#line 224
    tmp___0 = __getwd_chk(__buf, tmp);
#line 224
    return ((char __attribute__((__deprecated__))  *)tmp___0);
  }
#line 225
  tmp___2 = __getwd_warn(__buf);
#line 225
  return ((char __attribute__((__deprecated__))  *)tmp___2);
}
}
#line 229
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__leaf__)) __confstr_chk)(int __name ,
                                                                                       char *__buf ,
                                                                                       size_t __len ,
                                                                                       size_t __buflen ) ;
#line 231
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__leaf__)) __confstr_alias)(int __name ,
                                                                                         char *__buf ,
                                                                                         size_t __len )  __asm__("confstr")  ;
#line 233
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__leaf__)) __confstr_chk_warn)(int __name ,
                                                                                            char *__buf ,
                                                                                            size_t __len ,
                                                                                            size_t __buflen )  __asm__("__confstr_chk") __attribute__((__warning__("confstr called with bigger length than size of destination buffer"))) ;
#line 239
__inline extern  __attribute__((__nothrow__)) size_t ( __attribute__((__leaf__, __artificial__,
__always_inline__)) confstr)(int __name , char *__buf , size_t __len ) ;
#line 239 "/usr/include/x86_64-linux-gnu/bits/unistd.h"
__inline extern size_t ( __attribute__((__leaf__, __artificial__, __always_inline__)) confstr)(int __name ,
                                                                                               char *__buf ,
                                                                                               size_t __len ) 
{ 
  unsigned long tmp ;
  size_t tmp___0 ;
  unsigned long tmp___1 ;
  size_t tmp___2 ;
  unsigned long tmp___3 ;
  unsigned long tmp___4 ;
  size_t tmp___5 ;

  {
#line 242
  tmp___4 = __builtin_object_size((void *)__buf, 1);
#line 242
  if (tmp___4 != 0xffffffffffffffffUL) {
#line 245
    tmp = __builtin_object_size((void *)__buf, 1);
#line 245
    tmp___0 = __confstr_chk(__name, __buf, __len, tmp);
#line 245
    return (tmp___0);
#line 247
    tmp___3 = __builtin_object_size((void *)__buf, 1);
#line 247
    if (tmp___3 < __len) {
#line 248
      tmp___1 = __builtin_object_size((void *)__buf, 1);
#line 248
      tmp___2 = __confstr_chk_warn(__name, __buf, __len, tmp___1);
#line 248
      return (tmp___2);
    }
  }
#line 250
  tmp___5 = __confstr_alias(__name, __buf, __len);
#line 250
  return (tmp___5);
}
}
#line 254
extern  __attribute__((__nothrow__)) int ( __attribute__((__warn_unused_result__,
__leaf__)) __getgroups_chk)(int __size , __gid_t *__list , size_t __listlen ) ;
#line 256
extern  __attribute__((__nothrow__)) int ( __attribute__((__warn_unused_result__,
__leaf__)) __getgroups_alias)(int __size , __gid_t *__list )  __asm__("getgroups")  ;
#line 258
extern  __attribute__((__nothrow__)) int ( __attribute__((__warn_unused_result__,
__leaf__)) __getgroups_chk_warn)(int __size , __gid_t *__list , size_t __listlen )  __asm__("__getgroups_chk") __attribute__((__warning__("getgroups called with bigger group count than what can fit into destination buffer"))) ;
#line 264
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__warn_unused_result__,
__leaf__, __artificial__, __always_inline__)) getgroups)(int __size , __gid_t *__list ) ;
#line 264 "/usr/include/x86_64-linux-gnu/bits/unistd.h"
__inline extern int ( __attribute__((__warn_unused_result__, __leaf__, __artificial__,
__always_inline__)) getgroups)(int __size , __gid_t *__list ) 
{ 
  unsigned long tmp ;
  int tmp___0 ;
  unsigned long tmp___1 ;
  int tmp___2 ;
  unsigned long tmp___3 ;
  unsigned long tmp___4 ;
  int tmp___5 ;

  {
#line 267
  tmp___4 = __builtin_object_size((void *)__list, 1);
#line 267
  if (tmp___4 != 0xffffffffffffffffUL) {
#line 270
    tmp = __builtin_object_size((void *)__list, 1);
#line 270
    tmp___0 = __getgroups_chk(__size, __list, tmp);
#line 270
    return (tmp___0);
#line 272
    tmp___3 = __builtin_object_size((void *)__list, 1);
#line 272
    if ((unsigned long )__size * sizeof(__gid_t ) > tmp___3) {
#line 273
      tmp___1 = __builtin_object_size((void *)__list, 1);
#line 273
      tmp___2 = __getgroups_chk_warn(__size, __list, tmp___1);
#line 273
      return (tmp___2);
    }
  }
#line 275
  tmp___5 = __getgroups_alias(__size, __list);
#line 275
  return (tmp___5);
}
}
#line 279
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2), __leaf__)) __ttyname_r_chk)(int __fd ,
                                                                                                      char *__buf ,
                                                                                                      size_t __buflen ,
                                                                                                      size_t __nreal ) ;
#line 281
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2), __leaf__)) __ttyname_r_alias)(int __fd ,
                                                                                                        char *__buf ,
                                                                                                        size_t __buflen )  __asm__("ttyname_r")  ;
#line 284
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2), __leaf__)) __ttyname_r_chk_warn)(int __fd ,
                                                                                                           char *__buf ,
                                                                                                           size_t __buflen ,
                                                                                                           size_t __nreal )  __asm__("__ttyname_r_chk") __attribute__((__warning__("ttyname_r called with bigger buflen than size of destination buffer"))) ;
#line 290
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__warn_unused_result__,
__nonnull__(2), __leaf__, __artificial__, __always_inline__)) ttyname_r)(int __fd ,
                                                                         char *__buf ,
                                                                         size_t __buflen ) ;
#line 290 "/usr/include/x86_64-linux-gnu/bits/unistd.h"
__inline extern int ( __attribute__((__warn_unused_result__, __nonnull__(2), __leaf__,
__artificial__, __always_inline__)) ttyname_r)(int __fd , char *__buf , size_t __buflen ) 
{ 
  unsigned long tmp ;
  int tmp___0 ;
  unsigned long tmp___1 ;
  int tmp___2 ;
  unsigned long tmp___3 ;
  unsigned long tmp___4 ;
  int tmp___5 ;

  {
#line 293
  tmp___4 = __builtin_object_size((void *)__buf, 1);
#line 293
  if (tmp___4 != 0xffffffffffffffffUL) {
#line 296
    tmp = __builtin_object_size((void *)__buf, 1);
#line 296
    tmp___0 = __ttyname_r_chk(__fd, __buf, __buflen, tmp);
#line 296
    return (tmp___0);
#line 298
    tmp___3 = __builtin_object_size((void *)__buf, 1);
#line 298
    if (__buflen > tmp___3) {
#line 299
      tmp___1 = __builtin_object_size((void *)__buf, 1);
#line 299
      tmp___2 = __ttyname_r_chk_warn(__fd, __buf, __buflen, tmp___1);
#line 299
      return (tmp___2);
    }
  }
#line 301
  tmp___5 = __ttyname_r_alias(__fd, __buf, __buflen);
#line 301
  return (tmp___5);
}
}
#line 306
extern int ( __attribute__((__nonnull__(1))) __getlogin_r_chk)(char *__buf , size_t __buflen ,
                                                               size_t __nreal ) ;
#line 308
extern int ( __attribute__((__nonnull__(1))) __getlogin_r_alias)(char *__buf , size_t __buflen )  __asm__("getlogin_r")  ;
#line 310
extern int ( __attribute__((__nonnull__(1))) __getlogin_r_chk_warn)(char *__buf ,
                                                                    size_t __buflen ,
                                                                    size_t __nreal )  __asm__("__getlogin_r_chk") __attribute__((__warning__("getlogin_r called with bigger buflen than size of destination buffer"))) ;
#line 316 "/usr/include/x86_64-linux-gnu/bits/unistd.h"
__inline extern int ( __attribute__((__nonnull__(1), __artificial__, __always_inline__)) getlogin_r)(char *__buf ,
                                                                                                     size_t __buflen ) 
{ 
  unsigned long tmp ;
  int tmp___0 ;
  unsigned long tmp___1 ;
  int tmp___2 ;
  unsigned long tmp___3 ;
  unsigned long tmp___4 ;
  int tmp___5 ;

  {
#line 319
  tmp___4 = __builtin_object_size((void *)__buf, 1);
#line 319
  if (tmp___4 != 0xffffffffffffffffUL) {
#line 322
    tmp = __builtin_object_size((void *)__buf, 1);
#line 322
    tmp___0 = __getlogin_r_chk(__buf, __buflen, tmp);
#line 322
    return (tmp___0);
#line 324
    tmp___3 = __builtin_object_size((void *)__buf, 1);
#line 324
    if (__buflen > tmp___3) {
#line 325
      tmp___1 = __builtin_object_size((void *)__buf, 1);
#line 325
      tmp___2 = __getlogin_r_chk_warn(__buf, __buflen, tmp___1);
#line 325
      return (tmp___2);
    }
  }
#line 327
  tmp___5 = __getlogin_r_alias(__buf, __buflen);
#line 327
  return (tmp___5);
}
}
#line 333
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) __gethostname_chk)(char *__buf ,
                                                                                                        size_t __buflen ,
                                                                                                        size_t __nreal ) ;
#line 335
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) __gethostname_alias)(char *__buf ,
                                                                                                          size_t __buflen )  __asm__("gethostname")  ;
#line 337
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) __gethostname_chk_warn)(char *__buf ,
                                                                                                             size_t __buflen ,
                                                                                                             size_t __nreal )  __asm__("__gethostname_chk") __attribute__((__warning__("gethostname called with bigger buflen than size of destination buffer"))) ;
#line 343
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1),
__leaf__, __artificial__, __always_inline__)) gethostname)(char *__buf , size_t __buflen ) ;
#line 343 "/usr/include/x86_64-linux-gnu/bits/unistd.h"
__inline extern int ( __attribute__((__nonnull__(1), __leaf__, __artificial__, __always_inline__)) gethostname)(char *__buf ,
                                                                                                                size_t __buflen ) 
{ 
  unsigned long tmp ;
  int tmp___0 ;
  unsigned long tmp___1 ;
  int tmp___2 ;
  unsigned long tmp___3 ;
  unsigned long tmp___4 ;
  int tmp___5 ;

  {
#line 346
  tmp___4 = __builtin_object_size((void *)__buf, 1);
#line 346
  if (tmp___4 != 0xffffffffffffffffUL) {
#line 349
    tmp = __builtin_object_size((void *)__buf, 1);
#line 349
    tmp___0 = __gethostname_chk(__buf, __buflen, tmp);
#line 349
    return (tmp___0);
#line 351
    tmp___3 = __builtin_object_size((void *)__buf, 1);
#line 351
    if (__buflen > tmp___3) {
#line 352
      tmp___1 = __builtin_object_size((void *)__buf, 1);
#line 352
      tmp___2 = __gethostname_chk_warn(__buf, __buflen, tmp___1);
#line 352
      return (tmp___2);
    }
  }
#line 354
  tmp___5 = __gethostname_alias(__buf, __buflen);
#line 354
  return (tmp___5);
}
}
#line 360
extern  __attribute__((__nothrow__)) int ( __attribute__((__warn_unused_result__,
__nonnull__(1), __leaf__)) __getdomainname_chk)(char *__buf , size_t __buflen , size_t __nreal ) ;
#line 362
extern  __attribute__((__nothrow__)) int ( __attribute__((__warn_unused_result__,
__nonnull__(1), __leaf__)) __getdomainname_alias)(char *__buf , size_t __buflen )  __asm__("getdomainname")  ;
#line 365
extern  __attribute__((__nothrow__)) int ( __attribute__((__warn_unused_result__,
__nonnull__(1), __leaf__)) __getdomainname_chk_warn)(char *__buf , size_t __buflen ,
                                                     size_t __nreal )  __asm__("__getdomainname_chk") __attribute__((__warning__("getdomainname called with bigger buflen than size of destination buffer"))) ;
#line 372
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__warn_unused_result__,
__nonnull__(1), __leaf__, __artificial__, __always_inline__)) getdomainname)(char *__buf ,
                                                                             size_t __buflen ) ;
#line 372 "/usr/include/x86_64-linux-gnu/bits/unistd.h"
__inline extern int ( __attribute__((__warn_unused_result__, __nonnull__(1), __leaf__,
__artificial__, __always_inline__)) getdomainname)(char *__buf , size_t __buflen ) 
{ 
  unsigned long tmp ;
  int tmp___0 ;
  unsigned long tmp___1 ;
  int tmp___2 ;
  unsigned long tmp___3 ;
  unsigned long tmp___4 ;
  int tmp___5 ;

  {
#line 375
  tmp___4 = __builtin_object_size((void *)__buf, 1);
#line 375
  if (tmp___4 != 0xffffffffffffffffUL) {
#line 378
    tmp = __builtin_object_size((void *)__buf, 1);
#line 378
    tmp___0 = __getdomainname_chk(__buf, __buflen, tmp);
#line 378
    return (tmp___0);
#line 380
    tmp___3 = __builtin_object_size((void *)__buf, 1);
#line 380
    if (__buflen > tmp___3) {
#line 381
      tmp___1 = __builtin_object_size((void *)__buf, 1);
#line 381
      tmp___2 = __getdomainname_chk_warn(__buf, __buflen, tmp___1);
#line 381
      return (tmp___2);
    }
  }
#line 383
  tmp___5 = __getdomainname_alias(__buf, __buflen);
#line 383
  return (tmp___5);
}
}
#line 50 "/usr/include/x86_64-linux-gnu/bits/errno.h"
extern  __attribute__((__nothrow__)) int *( __attribute__((__leaf__)) __errno_location)(void)  __attribute__((__const__)) ;
#line 137 "/usr/include/fcntl.h"
extern int fcntl(int __fd , int __cmd  , ...) ;
#line 146
__inline extern int ( __attribute__((__nonnull__(1), __artificial__, __always_inline__)) open)(char const   *__path ,
                                                                                               int __oflag 
                                                                                               , ...) ;
#line 170
__inline extern int ( __attribute__((__nonnull__(2), __artificial__, __always_inline__)) openat)(int __fd ,
                                                                                                 char const   *__path ,
                                                                                                 int __oflag 
                                                                                                 , ...) ;
#line 26 "/usr/include/x86_64-linux-gnu/bits/fcntl2.h"
extern int ( __attribute__((__nonnull__(1))) __open_2)(char const   *__path , int __oflag ) ;
#line 27
extern int ( __attribute__((__nonnull__(1))) __open_alias)(char const   *__path ,
                                                           int __oflag  , ...)  __asm__("open")  ;
#line 35
extern void __open_too_many_args(void)  __attribute__((__error__("open can be called either with 2 or 3 arguments, not more"))) ;
#line 40 "/usr/include/x86_64-linux-gnu/bits/fcntl2.h"
__inline extern int ( __attribute__((__nonnull__(1), __artificial__, __always_inline__)) open)(char const   *__path ,
                                                                                               int __oflag 
                                                                                               , ...) 
{ 
  int tmp ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
#line 43
  tmp = __builtin_va_arg_pack_len();
#line 43
  if (tmp > 1) {
#line 44
    __open_too_many_args();
  }
#line 56
  tmp___4 = __builtin_va_arg_pack_len();
#line 56
  if (tmp___4 < 1) {
#line 57
    tmp___3 = __open_2(__path, __oflag);
#line 57
    return (tmp___3);
  }
#line 59
  tmp___5 = __open_alias(__path, __oflag, __builtin_va_arg_pack());
#line 59
  return (tmp___5);
}
}
#line 98
extern int ( __attribute__((__nonnull__(2))) __openat_2)(int __fd , char const   *__path ,
                                                         int __oflag ) ;
#line 100
extern int ( __attribute__((__nonnull__(2))) __openat_alias)(int __fd , char const   *__path ,
                                                             int __oflag  , ...)  __asm__("openat")  ;
#line 111
extern void __openat_too_many_args(void)  __attribute__((__error__("openat can be called either with 3 or 4 arguments, not more"))) ;
#line 116 "/usr/include/x86_64-linux-gnu/bits/fcntl2.h"
__inline extern int ( __attribute__((__nonnull__(2), __artificial__, __always_inline__)) openat)(int __fd ,
                                                                                                 char const   *__path ,
                                                                                                 int __oflag 
                                                                                                 , ...) 
{ 
  int tmp ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
#line 119
  tmp = __builtin_va_arg_pack_len();
#line 119
  if (tmp > 1) {
#line 120
    __openat_too_many_args();
  }
#line 132
  tmp___4 = __builtin_va_arg_pack_len();
#line 132
  if (tmp___4 < 1) {
#line 133
    tmp___3 = __openat_2(__fd, __path, __oflag);
#line 133
    return (tmp___3);
  }
#line 135
  tmp___5 = __openat_alias(__fd, __path, __oflag, __builtin_va_arg_pack());
#line 135
  return (tmp___5);
}
}
#line 103 "/usr/include/x86_64-linux-gnu/bits/sigset.h"
__inline extern int __sigismember(__sigset_t const   *__set , int __sig ) ;
#line 104
__inline extern int __sigaddset(__sigset_t *__set , int __sig ) ;
#line 105
__inline extern int __sigdelset(__sigset_t *__set , int __sig ) ;
#line 117 "/usr/include/x86_64-linux-gnu/bits/sigset.h"
__inline extern int __sigismember(__sigset_t const   *__set , int __sig ) 
{ 
  unsigned long __mask ;
  unsigned long __word ;
  int tmp ;

  {
#line 117
  __mask = 1UL << (unsigned long )(__sig - 1) % (8UL * sizeof(unsigned long ));
#line 117
  __word = (unsigned long )(__sig - 1) / (8UL * sizeof(unsigned long ));
#line 117
  if (__set->__val[__word] & __mask) {
#line 117
    tmp = 1;
  } else {
#line 117
    tmp = 0;
  }
#line 117
  return (tmp);
}
}
#line 118 "/usr/include/x86_64-linux-gnu/bits/sigset.h"
__inline extern int __sigaddset(__sigset_t *__set , int __sig ) 
{ 
  unsigned long __mask ;
  unsigned long __word ;

  {
#line 118
  __mask = 1UL << (unsigned long )(__sig - 1) % (8UL * sizeof(unsigned long ));
#line 118
  __word = (unsigned long )(__sig - 1) / (8UL * sizeof(unsigned long ));
#line 118
  __set->__val[__word] |= __mask;
#line 118
  return (0);
}
}
#line 119 "/usr/include/x86_64-linux-gnu/bits/sigset.h"
__inline extern int __sigdelset(__sigset_t *__set , int __sig ) 
{ 
  unsigned long __mask ;
  unsigned long __word ;

  {
#line 119
  __mask = 1UL << (unsigned long )(__sig - 1) % (8UL * sizeof(unsigned long ));
#line 119
  __word = (unsigned long )(__sig - 1) / (8UL * sizeof(unsigned long ));
#line 119
  __set->__val[__word] &= ~ __mask;
#line 119
  return (0);
}
}
#line 42 "/usr/include/string.h"
__inline extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2),
__leaf__, __artificial__, __always_inline__)) memcpy)(void * __restrict  __dest ,
                                                      void const   * __restrict  __src ,
                                                      size_t __len ) ;
#line 46
__inline extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2),
__leaf__, __artificial__, __always_inline__)) memmove)(void *__dest , void const   *__src ,
                                                       size_t __len ) ;
#line 62
__inline extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1),
__leaf__, __artificial__, __always_inline__)) memset)(void *__dest , int __ch , size_t __len ) ;
#line 125
__inline extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2),
__leaf__, __artificial__, __always_inline__)) strcpy)(char * __restrict  __dest ,
                                                      char const   * __restrict  __src ) ;
#line 128
__inline extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2),
__leaf__, __artificial__, __always_inline__)) strncpy)(char * __restrict  __dest ,
                                                       char const   * __restrict  __src ,
                                                       size_t __len ) ;
#line 133
__inline extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2),
__leaf__, __artificial__, __always_inline__)) strcat)(char * __restrict  __dest ,
                                                      char const   * __restrict  __src ) ;
#line 136
__inline extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2),
__leaf__, __artificial__, __always_inline__)) strncat)(char * __restrict  __dest ,
                                                       char const   * __restrict  __src ,
                                                       size_t __len ) ;
#line 395
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 575
__inline extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2),
__leaf__, __artificial__, __always_inline__)) stpncpy)(char * __restrict  __dest ,
                                                       char const   * __restrict  __src ,
                                                       size_t __n ) ;
#line 968 "/usr/include/x86_64-linux-gnu/bits/string2.h"
__inline extern size_t __strcspn_c1(char const   *__s , int __reject ) ;
#line 969 "/usr/include/x86_64-linux-gnu/bits/string2.h"
__inline extern size_t __strcspn_c1(char const   *__s , int __reject ) 
{ 
  register size_t __result ;

  {
#line 972
  __result = (size_t )0;
#line 973
  while (1) {
#line 973
    if ((int const   )*(__s + __result) != 0) {
#line 973
      if (! ((int const   )*(__s + __result) != (int const   )__reject)) {
#line 973
        break;
      }
    } else {
#line 973
      break;
    }
#line 974
    __result ++;
  }
#line 975
  return (__result);
}
}
#line 978
__inline extern size_t __strcspn_c2(char const   *__s , int __reject1 , int __reject2 ) ;
#line 980 "/usr/include/x86_64-linux-gnu/bits/string2.h"
__inline extern size_t __strcspn_c2(char const   *__s , int __reject1 , int __reject2 ) 
{ 
  register size_t __result ;

  {
#line 983
  __result = (size_t )0;
#line 984
  while (1) {
#line 984
    if ((int const   )*(__s + __result) != 0) {
#line 984
      if ((int const   )*(__s + __result) != (int const   )__reject1) {
#line 984
        if (! ((int const   )*(__s + __result) != (int const   )__reject2)) {
#line 984
          break;
        }
      } else {
#line 984
        break;
      }
    } else {
#line 984
      break;
    }
#line 986
    __result ++;
  }
#line 987
  return (__result);
}
}
#line 990
__inline extern size_t __strcspn_c3(char const   *__s , int __reject1 , int __reject2 ,
                                    int __reject3 ) ;
#line 992 "/usr/include/x86_64-linux-gnu/bits/string2.h"
__inline extern size_t __strcspn_c3(char const   *__s , int __reject1 , int __reject2 ,
                                    int __reject3 ) 
{ 
  register size_t __result ;

  {
#line 996
  __result = (size_t )0;
#line 997
  while (1) {
#line 997
    if ((int const   )*(__s + __result) != 0) {
#line 997
      if ((int const   )*(__s + __result) != (int const   )__reject1) {
#line 997
        if ((int const   )*(__s + __result) != (int const   )__reject2) {
#line 997
          if (! ((int const   )*(__s + __result) != (int const   )__reject3)) {
#line 997
            break;
          }
        } else {
#line 997
          break;
        }
      } else {
#line 997
        break;
      }
    } else {
#line 997
      break;
    }
#line 999
    __result ++;
  }
#line 1000
  return (__result);
}
}
#line 1044
__inline extern size_t __strspn_c1(char const   *__s , int __accept ) ;
#line 1045 "/usr/include/x86_64-linux-gnu/bits/string2.h"
__inline extern size_t __strspn_c1(char const   *__s , int __accept ) 
{ 
  register size_t __result ;

  {
#line 1048
  __result = (size_t )0;
#line 1050
  while ((int const   )*(__s + __result) == (int const   )__accept) {
#line 1051
    __result ++;
  }
#line 1052
  return (__result);
}
}
#line 1055
__inline extern size_t __strspn_c2(char const   *__s , int __accept1 , int __accept2 ) ;
#line 1057 "/usr/include/x86_64-linux-gnu/bits/string2.h"
__inline extern size_t __strspn_c2(char const   *__s , int __accept1 , int __accept2 ) 
{ 
  register size_t __result ;

  {
#line 1060
  __result = (size_t )0;
#line 1062
  while (1) {
#line 1062
    if (! ((int const   )*(__s + __result) == (int const   )__accept1)) {
#line 1062
      if (! ((int const   )*(__s + __result) == (int const   )__accept2)) {
#line 1062
        break;
      }
    }
#line 1063
    __result ++;
  }
#line 1064
  return (__result);
}
}
#line 1067
__inline extern size_t __strspn_c3(char const   *__s , int __accept1 , int __accept2 ,
                                   int __accept3 ) ;
#line 1069 "/usr/include/x86_64-linux-gnu/bits/string2.h"
__inline extern size_t __strspn_c3(char const   *__s , int __accept1 , int __accept2 ,
                                   int __accept3 ) 
{ 
  register size_t __result ;

  {
#line 1072
  __result = (size_t )0;
#line 1074
  while (1) {
#line 1074
    if (! ((int const   )*(__s + __result) == (int const   )__accept1)) {
#line 1074
      if (! ((int const   )*(__s + __result) == (int const   )__accept2)) {
#line 1074
        if (! ((int const   )*(__s + __result) == (int const   )__accept3)) {
#line 1074
          break;
        }
      }
    }
#line 1076
    __result ++;
  }
#line 1077
  return (__result);
}
}
#line 1120
__inline extern char *__strpbrk_c2(char const   *__s , int __accept1 , int __accept2 ) ;
#line 1122 "/usr/include/x86_64-linux-gnu/bits/string2.h"
__inline extern char *__strpbrk_c2(char const   *__s , int __accept1 , int __accept2 ) 
{ 
  char *tmp ;

  {
#line 1126
  while (1) {
#line 1126
    if ((int const   )*__s != 0) {
#line 1126
      if ((int const   )*__s != (int const   )__accept1) {
#line 1126
        if (! ((int const   )*__s != (int const   )__accept2)) {
#line 1126
          break;
        }
      } else {
#line 1126
        break;
      }
    } else {
#line 1126
      break;
    }
#line 1127
    __s ++;
  }
#line 1128
  if ((int const   )*__s == 0) {
#line 1128
    tmp = (char *)((void *)0);
  } else {
#line 1128
    tmp = (char *)((size_t )__s);
  }
#line 1128
  return (tmp);
}
}
#line 1131
__inline extern char *__strpbrk_c3(char const   *__s , int __accept1 , int __accept2 ,
                                   int __accept3 ) ;
#line 1133 "/usr/include/x86_64-linux-gnu/bits/string2.h"
__inline extern char *__strpbrk_c3(char const   *__s , int __accept1 , int __accept2 ,
                                   int __accept3 ) 
{ 
  char *tmp ;

  {
#line 1137
  while (1) {
#line 1137
    if ((int const   )*__s != 0) {
#line 1137
      if ((int const   )*__s != (int const   )__accept1) {
#line 1137
        if ((int const   )*__s != (int const   )__accept2) {
#line 1137
          if (! ((int const   )*__s != (int const   )__accept3)) {
#line 1137
            break;
          }
        } else {
#line 1137
          break;
        }
      } else {
#line 1137
        break;
      }
    } else {
#line 1137
      break;
    }
#line 1139
    __s ++;
  }
#line 1140
  if ((int const   )*__s == 0) {
#line 1140
    tmp = (char *)((void *)0);
  } else {
#line 1140
    tmp = (char *)((size_t )__s);
  }
#line 1140
  return (tmp);
}
}
#line 1170
__inline extern char *__strtok_r_1c(char *__s , char __sep , char **__nextp ) ;
#line 1171 "/usr/include/x86_64-linux-gnu/bits/string2.h"
__inline extern char *__strtok_r_1c(char *__s , char __sep , char **__nextp ) 
{ 
  char *__result ;
  char *tmp ;
  char *tmp___0 ;

  {
#line 1175
  if ((unsigned long )__s == (unsigned long )((void *)0)) {
#line 1176
    __s = *__nextp;
  }
#line 1177
  while ((int )*__s == (int )__sep) {
#line 1178
    __s ++;
  }
#line 1179
  __result = (char *)((void *)0);
#line 1180
  if ((int )*__s != 0) {
#line 1182
    tmp = __s;
#line 1182
    __s ++;
#line 1182
    __result = tmp;
#line 1183
    while ((int )*__s != 0) {
#line 1184
      tmp___0 = __s;
#line 1184
      __s ++;
#line 1184
      if ((int )*tmp___0 == (int )__sep) {
#line 1186
        *(__s + -1) = (char )'\000';
#line 1187
        break;
      }
    }
  }
#line 1190
  *__nextp = __s;
#line 1191
  return (__result);
}
}
#line 1220
__inline extern char *__strsep_1c(char **__s , char __reject ) ;
#line 1221 "/usr/include/x86_64-linux-gnu/bits/string2.h"
__inline extern char *__strsep_1c(char **__s , char __reject ) 
{ 
  register char *__retval ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___2 ;

  {
#line 1224
  __retval = *__s;
#line 1225
  if ((unsigned long )__retval != (unsigned long )((void *)0)) {
#line 1225
    tmp___2 = __builtin_strchr(__retval, (int )__reject);
#line 1225
    tmp___0 = tmp___2;
#line 1225
    *__s = tmp___0;
#line 1225
    if ((unsigned long )tmp___0 != (unsigned long )((void *)0)) {
#line 1226
      tmp = *__s;
#line 1226
      (*__s) ++;
#line 1226
      *tmp = (char )'\000';
    }
  }
#line 1227
  return (__retval);
}
}
#line 1230
__inline extern char *__strsep_2c(char **__s , char __reject1 , char __reject2 ) ;
#line 1231 "/usr/include/x86_64-linux-gnu/bits/string2.h"
__inline extern char *__strsep_2c(char **__s , char __reject1 , char __reject2 ) 
{ 
  register char *__retval ;
  register char *__cp ;
  char *tmp ;

  {
#line 1234
  __retval = *__s;
#line 1235
  if ((unsigned long )__retval != (unsigned long )((void *)0)) {
#line 1237
    __cp = __retval;
#line 1238
    while (1) {
#line 1240
      if ((int )*__cp == 0) {
#line 1242
        __cp = (char *)((void *)0);
#line 1243
        break;
      }
#line 1245
      if ((int )*__cp == (int )__reject1) {
#line 1247
        tmp = __cp;
#line 1247
        __cp ++;
#line 1247
        *tmp = (char )'\000';
#line 1248
        break;
      } else
#line 1245
      if ((int )*__cp == (int )__reject2) {
#line 1247
        tmp = __cp;
#line 1247
        __cp ++;
#line 1247
        *tmp = (char )'\000';
#line 1248
        break;
      }
#line 1250
      __cp ++;
    }
#line 1252
    *__s = __cp;
  }
#line 1254
  return (__retval);
}
}
#line 1257
__inline extern char *__strsep_3c(char **__s , char __reject1 , char __reject2 , char __reject3 ) ;
#line 1259 "/usr/include/x86_64-linux-gnu/bits/string2.h"
__inline extern char *__strsep_3c(char **__s , char __reject1 , char __reject2 , char __reject3 ) 
{ 
  register char *__retval ;
  register char *__cp ;
  char *tmp ;

  {
#line 1262
  __retval = *__s;
#line 1263
  if ((unsigned long )__retval != (unsigned long )((void *)0)) {
#line 1265
    __cp = __retval;
#line 1266
    while (1) {
#line 1268
      if ((int )*__cp == 0) {
#line 1270
        __cp = (char *)((void *)0);
#line 1271
        break;
      }
#line 1273
      if ((int )*__cp == (int )__reject1) {
#line 1275
        tmp = __cp;
#line 1275
        __cp ++;
#line 1275
        *tmp = (char )'\000';
#line 1276
        break;
      } else
#line 1273
      if ((int )*__cp == (int )__reject2) {
#line 1275
        tmp = __cp;
#line 1275
        __cp ++;
#line 1275
        *tmp = (char )'\000';
#line 1276
        break;
      } else
#line 1273
      if ((int )*__cp == (int )__reject3) {
#line 1275
        tmp = __cp;
#line 1275
        __cp ++;
#line 1275
        *tmp = (char )'\000';
#line 1276
        break;
      }
#line 1278
      __cp ++;
    }
#line 1280
    *__s = __cp;
  }
#line 1282
  return (__retval);
}
}
#line 47 "/usr/include/x86_64-linux-gnu/bits/string3.h"
__inline extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2),
__leaf__, __artificial__, __always_inline__)) memcpy)(void * __restrict  __dest ,
                                                      void const   * __restrict  __src ,
                                                      size_t __len ) ;
#line 47 "/usr/include/x86_64-linux-gnu/bits/string3.h"
__inline extern void *( __attribute__((__nonnull__(1,2), __leaf__, __artificial__,
__always_inline__)) memcpy)(void * __restrict  __dest , void const   * __restrict  __src ,
                            size_t __len ) 
{ 
  unsigned long tmp ;
  void *tmp___0 ;

  {
#line 51
  tmp = __builtin_object_size((void *)__dest, 0);
#line 51
  tmp___0 = __builtin___memcpy_chk((void *)__dest, (void const   *)__src, __len, tmp);
#line 51
  return (tmp___0);
}
}
#line 54
__inline extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2),
__leaf__, __artificial__, __always_inline__)) memmove)(void *__dest , void const   *__src ,
                                                       size_t __len ) ;
#line 54 "/usr/include/x86_64-linux-gnu/bits/string3.h"
__inline extern void *( __attribute__((__nonnull__(1,2), __leaf__, __artificial__,
__always_inline__)) memmove)(void *__dest , void const   *__src , size_t __len ) 
{ 
  unsigned long tmp ;
  void *tmp___0 ;

  {
#line 57
  tmp = __builtin_object_size(__dest, 0);
#line 57
  tmp___0 = __builtin___memmove_chk(__dest, __src, __len, tmp);
#line 57
  return (tmp___0);
}
}
#line 75
__inline extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1),
__leaf__, __artificial__, __always_inline__)) memset)(void *__dest , int __ch , size_t __len ) ;
#line 75 "/usr/include/x86_64-linux-gnu/bits/string3.h"
__inline extern void *( __attribute__((__nonnull__(1), __leaf__, __artificial__, __always_inline__)) memset)(void *__dest ,
                                                                                                             int __ch ,
                                                                                                             size_t __len ) 
{ 
  unsigned long tmp ;
  void *tmp___0 ;

  {
#line 84
  tmp = __builtin_object_size(__dest, 0);
#line 84
  tmp___0 = __builtin___memset_chk(__dest, __ch, __len, tmp);
#line 84
  return (tmp___0);
}
}
#line 88
__inline extern  __attribute__((__nothrow__)) void ( __attribute__((__nonnull__(1,2),
__leaf__, __artificial__, __always_inline__)) bcopy)(void const   *__src , void *__dest ,
                                                     size_t __len ) ;
#line 88 "/usr/include/x86_64-linux-gnu/bits/string3.h"
__inline extern void ( __attribute__((__nonnull__(1,2), __leaf__, __artificial__,
__always_inline__)) bcopy)(void const   *__src , void *__dest , size_t __len ) 
{ 
  unsigned long tmp ;

  {
#line 91
  tmp = __builtin_object_size(__dest, 0);
#line 91
  __builtin___memmove_chk(__dest, __src, __len, tmp);
#line 92
  return;
}
}
#line 94
__inline extern  __attribute__((__nothrow__)) void ( __attribute__((__nonnull__(1),
__leaf__, __artificial__, __always_inline__)) bzero)(void *__dest , size_t __len ) ;
#line 94 "/usr/include/x86_64-linux-gnu/bits/string3.h"
__inline extern void ( __attribute__((__nonnull__(1), __leaf__, __artificial__, __always_inline__)) bzero)(void *__dest ,
                                                                                                           size_t __len ) 
{ 
  unsigned long tmp ;

  {
#line 97
  tmp = __builtin_object_size(__dest, 0);
#line 97
  __builtin___memset_chk(__dest, '\000', __len, tmp);
#line 98
  return;
}
}
#line 101
__inline extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2),
__leaf__, __artificial__, __always_inline__)) strcpy)(char * __restrict  __dest ,
                                                      char const   * __restrict  __src ) ;
#line 101 "/usr/include/x86_64-linux-gnu/bits/string3.h"
__inline extern char *( __attribute__((__nonnull__(1,2), __leaf__, __artificial__,
__always_inline__)) strcpy)(char * __restrict  __dest , char const   * __restrict  __src ) 
{ 
  unsigned long tmp ;
  char *tmp___0 ;

  {
#line 104
  tmp = __builtin_object_size((void *)__dest, 1);
#line 104
  tmp___0 = __builtin___strcpy_chk((char *)__dest, (char const   *)__src, tmp);
#line 104
  return (tmp___0);
}
}
#line 116
__inline extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2),
__leaf__, __artificial__, __always_inline__)) strncpy)(char * __restrict  __dest ,
                                                       char const   * __restrict  __src ,
                                                       size_t __len ) ;
#line 116 "/usr/include/x86_64-linux-gnu/bits/string3.h"
__inline extern char *( __attribute__((__nonnull__(1,2), __leaf__, __artificial__,
__always_inline__)) strncpy)(char * __restrict  __dest , char const   * __restrict  __src ,
                             size_t __len ) 
{ 
  unsigned long tmp ;
  char *tmp___0 ;

  {
#line 120
  tmp = __builtin_object_size((void *)__dest, 1);
#line 120
  tmp___0 = __builtin___strncpy_chk((char *)__dest, (char const   *)__src, __len,
                                    tmp);
#line 120
  return (tmp___0);
}
}
#line 124
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) __stpncpy_chk)(char *__dest ,
                                                                                      char const   *__src ,
                                                                                      size_t __n ,
                                                                                      size_t __destlen ) ;
#line 126
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) __stpncpy_alias)(char *__dest ,
                                                                                        char const   *__src ,
                                                                                        size_t __n )  __asm__("stpncpy")  ;
#line 129
__inline extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2),
__leaf__, __artificial__, __always_inline__)) stpncpy)(char * __restrict  __dest ,
                                                       char const   * __restrict  __src ,
                                                       size_t __n ) ;
#line 129 "/usr/include/x86_64-linux-gnu/bits/string3.h"
__inline extern char *( __attribute__((__nonnull__(1,2), __leaf__, __artificial__,
__always_inline__)) stpncpy)(char * __restrict  __dest , char const   * __restrict  __src ,
                             size_t __n ) 
{ 
  unsigned long tmp ;
  char *tmp___0 ;
  unsigned long tmp___1 ;
  char *tmp___3 ;

  {
#line 132
  tmp___1 = __builtin_object_size((void *)__dest, 1);
#line 132
  if (tmp___1 != 0xffffffffffffffffUL) {
#line 134
    tmp = __builtin_object_size((void *)__dest, 1);
#line 134
    tmp___0 = __stpncpy_chk((char *)__dest, (char const   *)__src, __n, tmp);
#line 134
    return (tmp___0);
  }
#line 135
  tmp___3 = __stpncpy_alias((char *)__dest, (char const   *)__src, __n);
#line 135
  return (tmp___3);
}
}
#line 139
__inline extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2),
__leaf__, __artificial__, __always_inline__)) strcat)(char * __restrict  __dest ,
                                                      char const   * __restrict  __src ) ;
#line 139 "/usr/include/x86_64-linux-gnu/bits/string3.h"
__inline extern char *( __attribute__((__nonnull__(1,2), __leaf__, __artificial__,
__always_inline__)) strcat)(char * __restrict  __dest , char const   * __restrict  __src ) 
{ 
  unsigned long tmp ;
  char *tmp___0 ;

  {
#line 142
  tmp = __builtin_object_size((void *)__dest, 1);
#line 142
  tmp___0 = __builtin___strcat_chk((char *)__dest, (char const   *)__src, tmp);
#line 142
  return (tmp___0);
}
}
#line 146
__inline extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2),
__leaf__, __artificial__, __always_inline__)) strncat)(char * __restrict  __dest ,
                                                       char const   * __restrict  __src ,
                                                       size_t __len ) ;
#line 146 "/usr/include/x86_64-linux-gnu/bits/string3.h"
__inline extern char *( __attribute__((__nonnull__(1,2), __leaf__, __artificial__,
__always_inline__)) strncat)(char * __restrict  __dest , char const   * __restrict  __src ,
                             size_t __len ) 
{ 
  unsigned long tmp ;
  char *tmp___0 ;

  {
#line 150
  tmp = __builtin_object_size((void *)__dest, 1);
#line 150
  tmp___0 = __builtin___strncat_chk((char *)__dest, (char const   *)__src, __len,
                                    tmp);
#line 150
  return (tmp___0);
}
}
#line 210 "/usr/include/x86_64-linux-gnu/sys/stat.h"
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2),
__leaf__)) stat)(char const   * __restrict  __path , struct stat * __restrict  __statbuf ) ;
#line 215
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2),
__leaf__)) fstat)(int __fd , struct stat *__statbuf ) ;
#line 239
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2,3),
__leaf__)) fstatat)(int __fd , char const   * __restrict  __filename , struct stat * __restrict  __statbuf ,
                    int __flag ) ;
#line 264
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2),
__leaf__)) lstat)(char const   * __restrict  __path , struct stat * __restrict  __statbuf ) ;
#line 285
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) chmod)(char const   *__file ,
                                                                                            __mode_t __mode ) ;
#line 337
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1),
__leaf__)) mknod)(char const   *__path , __mode_t __mode , __dev_t __dev ) ;
#line 344
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2),
__leaf__)) mknodat)(int __fd , char const   *__path , __mode_t __mode , __dev_t __dev ) ;
#line 400
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(3), __leaf__)) __fxstat)(int __ver ,
                                                                                               int __fildes ,
                                                                                               struct stat *__stat_buf ) ;
#line 402
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2,3), __leaf__)) __xstat)(int __ver ,
                                                                                                char const   *__filename ,
                                                                                                struct stat *__stat_buf ) ;
#line 404
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2,3), __leaf__)) __lxstat)(int __ver ,
                                                                                                 char const   *__filename ,
                                                                                                 struct stat *__stat_buf ) ;
#line 406
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(3,4), __leaf__)) __fxstatat)(int __ver ,
                                                                                                   int __fildes ,
                                                                                                   char const   *__filename ,
                                                                                                   struct stat *__stat_buf ,
                                                                                                   int __flag ) ;
#line 443
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2,4), __leaf__)) __xmknod)(int __ver ,
                                                                                                 char const   *__path ,
                                                                                                 __mode_t __mode ,
                                                                                                 __dev_t *__dev ) ;
#line 446
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(3,5), __leaf__)) __xmknodat)(int __ver ,
                                                                                                   int __fd ,
                                                                                                   char const   *__path ,
                                                                                                   __mode_t __mode ,
                                                                                                   __dev_t *__dev ) ;
#line 453
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2),
__leaf__)) stat)(char const   * __restrict  __path , struct stat * __restrict  __statbuf ) ;
#line 453 "/usr/include/x86_64-linux-gnu/sys/stat.h"
__inline extern int ( __attribute__((__nonnull__(1,2), __leaf__)) stat)(char const   * __restrict  __path ,
                                                                        struct stat * __restrict  __statbuf ) 
{ 
  int tmp ;

  {
#line 456
  tmp = __xstat(1, (char const   *)__path, (struct stat *)__statbuf);
#line 456
  return (tmp);
}
}
#line 460
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2),
__leaf__)) lstat)(char const   * __restrict  __path , struct stat * __restrict  __statbuf ) ;
#line 460 "/usr/include/x86_64-linux-gnu/sys/stat.h"
__inline extern int ( __attribute__((__nonnull__(1,2), __leaf__)) lstat)(char const   * __restrict  __path ,
                                                                         struct stat * __restrict  __statbuf ) 
{ 
  int tmp ;

  {
#line 463
  tmp = __lxstat(1, (char const   *)__path, (struct stat *)__statbuf);
#line 463
  return (tmp);
}
}
#line 467
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2),
__leaf__)) fstat)(int __fd , struct stat *__statbuf ) ;
#line 467 "/usr/include/x86_64-linux-gnu/sys/stat.h"
__inline extern int ( __attribute__((__nonnull__(2), __leaf__)) fstat)(int __fd ,
                                                                       struct stat *__statbuf ) 
{ 
  int tmp ;

  {
#line 470
  tmp = __fxstat(1, __fd, __statbuf);
#line 470
  return (tmp);
}
}
#line 474
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2,3),
__leaf__)) fstatat)(int __fd , char const   * __restrict  __filename , struct stat * __restrict  __statbuf ,
                    int __flag ) ;
#line 474 "/usr/include/x86_64-linux-gnu/sys/stat.h"
__inline extern int ( __attribute__((__nonnull__(2,3), __leaf__)) fstatat)(int __fd ,
                                                                           char const   * __restrict  __filename ,
                                                                           struct stat * __restrict  __statbuf ,
                                                                           int __flag ) 
{ 
  int tmp ;

  {
#line 478
  tmp = __fxstatat(1, __fd, (char const   *)__filename, (struct stat *)__statbuf,
                   __flag);
#line 478
  return (tmp);
}
}
#line 483
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1),
__leaf__)) mknod)(char const   *__path , __mode_t __mode , __dev_t __dev ) ;
#line 483 "/usr/include/x86_64-linux-gnu/sys/stat.h"
__inline extern int ( __attribute__((__nonnull__(1), __leaf__)) mknod)(char const   *__path ,
                                                                       __mode_t __mode ,
                                                                       __dev_t __dev ) 
{ 
  int tmp ;

  {
#line 486
  tmp = __xmknod(0, __path, __mode, & __dev);
#line 486
  return (tmp);
}
}
#line 491
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2),
__leaf__)) mknodat)(int __fd , char const   *__path , __mode_t __mode , __dev_t __dev ) ;
#line 491 "/usr/include/x86_64-linux-gnu/sys/stat.h"
__inline extern int ( __attribute__((__nonnull__(2), __leaf__)) mknodat)(int __fd ,
                                                                         char const   *__path ,
                                                                         __mode_t __mode ,
                                                                         __dev_t __dev ) 
{ 
  int tmp ;

  {
#line 495
  tmp = __xmknodat(0, __fd, __path, __mode, & __dev);
#line 495
  return (tmp);
}
}
#line 58 "/usr/include/arpa/inet.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) inet_pton)(int __af ,
                                                                                char const   * __restrict  __cp ,
                                                                                void * __restrict  __buf ) ;
#line 64
extern  __attribute__((__nothrow__)) char const   *( __attribute__((__leaf__)) inet_ntop)(int __af ,
                                                                                          void const   * __restrict  __cp ,
                                                                                          char * __restrict  __buf ,
                                                                                          socklen_t __len ) ;
#line 29 "ozzylib.h"
int oz_isdatawaiting(int *sockfd ) ;
#line 30
int oz_listen(int *sockfd , int SOCK_TYPE , int port , char const   *addr ) ;
#line 31
int oz_close(int *sockfd ) ;
#line 32
int oz_writel(int *sockfd , char const   *str ) ;
#line 33
int oz_writefl(int *sockfd , char const   *format  , ...) ;
#line 34
int oz_readinit(char **str ) ;
#line 35
int oz_read(int *sockfd , char **str , char const   endchr ) ;
#line 41
int oz_clisock(int *sockfd , char const   *addr , char *port ) ;
#line 42
int oz_clisock_unix(int *sockfd , char const   *path ) ;
#line 43
int oz_clisock_tcp(int *sockfd , char const   *addr , char *port ) ;
#line 44
int oz_setnonblock(int *sockfd ) ;
#line 45
int oz_sendto(int *sockfd , char *addr , char *port , void *buf , size_t buf_size ) ;
#line 46
int oz_getstrap(struct sockaddr *addr , size_t addr_size , char *dst , size_t dst_size ,
                int *port ) ;
#line 49
void oz_readend(char **str ) ;
#line 53
void str_chop(char *txt ) ;
#line 80
unsigned int oz_readmax ;
#line 19 "socket.c"
int oz_isdatawaiting(int *sockfd ) 
{ 
  fd_set rfds ;
  struct timeval tv ;
  int rev ;
  int __d0 ;
  int __d1 ;
  long __d ;
  long tmp___1 ;

  {
#line 22
  rev = 0;
#line 24
  tv.tv_sec = (__time_t )0;
#line 25
  tv.tv_usec = (__suseconds_t )0;
#line 27
  while (1) {
#line 27
    __asm__  volatile   ("cld; rep; "
                         "stosq": "=c" (__d0), "=D" (__d1): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                         "1" (& rfds.__fds_bits[0]): "memory");
#line 27
    break;
  }
#line 28
  __d = (long )*sockfd;
#line 28
  tmp___1 = __fdelt_chk(__d);
#line 28
  rfds.__fds_bits[tmp___1] |= 1L << *sockfd % (8 * (int )sizeof(__fd_mask ));
#line 30
  rev = select(*sockfd + 1, (fd_set * __restrict  )(& rfds), (fd_set * __restrict  )((fd_set *)0),
               (fd_set * __restrict  )((fd_set *)0), (struct timeval * __restrict  )(& tv));
#line 32
  if (rev > 0) {
#line 33
    return (1);
  } else
#line 34
  if (rev == 0) {
#line 35
    return (0);
  } else {
#line 37
    return (-1);
  }
}
}
#line 63 "socket.c"
int oz_listen(int *sockfd , int SOCK_TYPE , int port , char const   *addr ) 
{ 
  int rev ;
  int safe_errno ;
  int AF ;
  struct sockaddr_in in_address ;
  struct sockaddr_in6 in6_address ;
  struct sockaddr_un un_address ;
  struct in6_addr address6 ;
  struct in_addr address4 ;
  struct stat filestat ;
  mode_t mode ;
  int tmp ;
  int tmp___0 ;
  register unsigned short __v ;
  register unsigned short __x ;
  register unsigned short __v___0 ;
  register unsigned short __x___0 ;
  int *tmp___1 ;
  int tmp___2 ;
  int *tmp___3 ;
  int tmp___4 ;
  int *tmp___5 ;
  int *tmp___6 ;

  {
#line 64
  rev = 0;
#line 65
  safe_errno = 0;
#line 66
  AF = -1;
#line 76
  tmp___0 = inet_pton(2, (char const   * __restrict  )addr, (void * __restrict  )(& address4));
#line 76
  if (tmp___0 > 0) {
#line 77
    AF = 2;
  } else {
#line 79
    tmp = inet_pton(10, (char const   * __restrict  )addr, (void * __restrict  )(& address6));
#line 79
    if (tmp > 0) {
#line 80
      AF = 10;
    } else {
#line 83
      AF = 1;
    }
  }
#line 85
  *sockfd = socket(AF, SOCK_TYPE, 0);
#line 87
  if (*sockfd == -1) {
#line 88
    return (-1);
  }
#line 90
  if (AF == 10) {
#line 91
    in6_address.sin6_family = (sa_family_t )10;
#line 92
    __x = (unsigned short )port;
#line 92
    __asm__  ("rorw $8, %w0": "=r" (__v): "0" (__x): "cc");
#line 92
    in6_address.sin6_port = __v;
#line 93
    in6_address.sin6_addr = address6;
#line 95
    rev = bind(*sockfd, (struct sockaddr  const  *)((struct sockaddr *)(& in6_address)),
               (socklen_t )sizeof(struct sockaddr_in6 ));
  } else
#line 98
  if (AF == 2) {
#line 99
    in_address.sin_family = (sa_family_t )2;
#line 100
    __x___0 = (unsigned short )port;
#line 100
    __asm__  ("rorw $8, %w0": "=r" (__v___0): "0" (__x___0): "cc");
#line 100
    in_address.sin_port = __v___0;
#line 101
    in_address.sin_addr = address4;
#line 103
    rev = bind(*sockfd, (struct sockaddr  const  *)((struct sockaddr *)(& in_address)),
               (socklen_t )sizeof(struct sockaddr_in ));
  } else
#line 106
  if (AF == 1) {
#line 107
    un_address.sun_family = (sa_family_t )1;
#line 108
    snprintf((char * __restrict  )(un_address.sun_path), sizeof(un_address.sun_path),
             (char const   * __restrict  )"%s", addr);
#line 115
    tmp___4 = lstat((char const   * __restrict  )(un_address.sun_path), (struct stat * __restrict  )(& filestat));
#line 115
    if (tmp___4 == 0) {
#line 116
      if ((filestat.st_mode & 61440U) == 40960U) {
#line 116
        goto _L;
      } else
#line 116
      if ((filestat.st_mode & 61440U) == 49152U) {
        _L: 
#line 121
        tmp___2 = unlink((char const   *)(un_address.sun_path));
#line 121
        if (tmp___2 != 0) {
#line 122
          tmp___1 = __errno_location();
#line 122
          *tmp___1 = 98;
#line 123
          return (-1);
        }
      } else {
#line 128
        tmp___3 = __errno_location();
#line 128
        *tmp___3 = 98;
#line 129
        return (-1);
      }
    }
#line 133
    rev = bind(*sockfd, (struct sockaddr  const  *)((struct sockaddr *)(& un_address)),
               (socklen_t )sizeof(struct sockaddr_un ));
#line 135
    if (port == 1) {
#line 135
      if (rev == 0) {
#line 136
        mode = (mode_t )(((((((((((256 >> 3) >> 3) | ((128 >> 3) >> 3)) | ((64 >> 3) >> 3)) | (64 >> 3)) | (128 >> 3)) | (256 >> 3)) | 64) | 128) | 256) | 512);
#line 137
        rev = chmod(addr, mode);
      } else {
#line 135
        goto _L___0;
      }
    } else
    _L___0: 
#line 140
    if (port == 0) {
#line 140
      if (rev == 0) {
#line 141
        mode = (mode_t )960;
#line 142
        rev = chmod(addr, mode);
      }
    }
  }
#line 146
  if (SOCK_TYPE == 1) {
#line 146
    if (rev == 0) {
#line 147
      rev = listen(*sockfd, 10);
    }
  }
#line 150
  if (rev == -1) {
#line 151
    tmp___5 = __errno_location();
#line 151
    safe_errno = *tmp___5;
#line 152
    close(*sockfd);
#line 153
    tmp___6 = __errno_location();
#line 153
    *tmp___6 = safe_errno;
#line 155
    return (-1);
  }
#line 158
  return (0);
}
}
#line 175 "socket.c"
int oz_close(int *sockfd ) 
{ 
  int rev ;

  {
#line 176
  rev = 0;
#line 178
  rev = close(*sockfd);
#line 180
  if (rev == -1) {
#line 181
    return (-1);
  } else {
#line 184
    return (0);
  }
}
}
#line 209 "socket.c"
int oz_writel(int *sockfd , char const   *str ) 
{ 
  int rev ;
  char *tmpstr ;
  size_t tmpstr_len ;
  size_t str_pos ;
  ssize_t tmp ;
  size_t tmp___0 ;
  void *tmp___1 ;
  size_t tmp___2 ;
  ssize_t tmp___3 ;

  {
#line 210
  rev = 0;
#line 212
  tmpstr_len = (size_t )0;
#line 216
  if ((int const   )*(str + 0) == 0) {
#line 217
    tmp = write(*sockfd, (void const   *)"\r\n", (size_t )2);
#line 217
    rev = (int )tmp;
#line 219
    if (rev == -1) {
#line 220
      return (-1);
    } else {
#line 222
      return (0);
    }
  }
#line 226
  tmp___0 = strlen(str);
#line 226
  tmpstr_len = tmp___0 + 1UL;
#line 226
  str_pos = tmpstr_len;
#line 227
  tmp___1 = malloc((tmpstr_len + 8UL) * sizeof(char ));
#line 227
  tmpstr = (char *)tmp___1;
#line 229
  if ((unsigned long )tmpstr == (unsigned long )((void *)0)) {
#line 230
    return (-2);
  }
#line 232
  strncpy((char * __restrict  )tmpstr, (char const   * __restrict  )str, tmpstr_len * sizeof(char ));
#line 234
  str_pos -= 2UL;
#line 235
  if ((int )*(tmpstr + str_pos) != 10) {
#line 236
    str_pos ++;
#line 236
    *(tmpstr + str_pos) = (char )'\r';
#line 237
    str_pos ++;
#line 237
    *(tmpstr + str_pos) = (char )'\n';
#line 238
    str_pos ++;
#line 238
    *(tmpstr + str_pos) = (char )'\000';
  }
#line 241
  tmp___2 = strlen((char const   *)tmpstr);
#line 241
  tmp___3 = write(*sockfd, (void const   *)((void *)tmpstr), tmp___2);
#line 241
  rev = (int )tmp___3;
#line 243
  free((void *)tmpstr);
#line 245
  if (rev == -1) {
#line 246
    return (-1);
  } else {
#line 249
    return (0);
  }
}
}
#line 268 "socket.c"
int oz_writefl(int *sockfd , char const   *format  , ...) 
{ 
  char msg[5000] ;
  va_list ap ;
  int tmp ;

  {
#line 272
  memset((void *)(msg), '\000', sizeof(msg));
#line 274
  __builtin_va_start(ap, format);
#line 275
  vsnprintf((char * __restrict  )(msg), sizeof(msg) - sizeof(char ), (char const   * __restrict  )format,
            ap);
#line 276
  __builtin_va_end(ap);
#line 279
  tmp = oz_writel(sockfd, (char const   *)(msg));
#line 279
  return (tmp);
}
}
#line 298 "socket.c"
int oz_readinit(char **str ) 
{ 
  void *tmp ;

  {
#line 299
  tmp = malloc(2UL * sizeof(char ));
#line 299
  *str = (char *)tmp;
#line 301
  if ((unsigned long )*str == (unsigned long )((void *)0)) {
#line 302
    return (-1);
  } else {
#line 305
    memset((void *)*str, '\000', 2UL * sizeof(char ));
#line 306
    return (0);
  }
}
}
#line 324 "socket.c"
void oz_readend(char **str ) 
{ 


  {
#line 325
  if ((unsigned long )*str != (unsigned long )((void *)0)) {
#line 326
    free((void *)*str);
  }
#line 327
  return;
}
}
#line 354 "socket.c"
int oz_read(int *sockfd , char **str , char const   endchr ) 
{ 
  unsigned int readbytes ;
  unsigned int chunk_use ;
  size_t i ;
  int done ;
  int rev ;
  char *str_tmp ;
  char buf ;
  void *tmp ;
  void *tmp___0 ;
  ssize_t tmp___1 ;

  {
#line 356
  readbytes = 0U;
#line 357
  chunk_use = 0U;
#line 358
  i = (size_t )0;
#line 359
  done = 0;
#line 360
  rev = 0;
#line 364
  tmp = realloc((void *)*str, 2UL * sizeof(char ));
#line 364
  *str = (char *)tmp;
#line 366
  if ((unsigned long )*str == (unsigned long )((void *)0)) {
#line 367
    return (-2);
  } else {
#line 369
    memset((void *)*str, '\000', 2UL * sizeof(char ));
  }
#line 371
  while (1) {
#line 372
    tmp___0 = realloc((void *)*str, 11UL * sizeof(char ) + i * sizeof(char ));
#line 372
    str_tmp = (char *)tmp___0;
#line 374
    if ((unsigned long )str_tmp == (unsigned long )((void *)0)) {
#line 375
      return (-2);
    } else {
#line 377
      *str = str_tmp;
    }
#line 379
    chunk_use = 0U;
#line 381
    while (1) {
#line 381
      if (done == 0) {
#line 381
        if (chunk_use < 10U) {
#line 381
          if (! (rev != -1)) {
#line 381
            break;
          }
        } else {
#line 381
          break;
        }
      } else {
#line 381
        break;
      }
#line 382
      if (oz_readmax > 0U) {
#line 382
        if (readbytes >= oz_readmax) {
#line 383
          done = 1;
        }
      }
#line 385
      tmp___1 = read(*sockfd, (void *)(& buf), sizeof(char ));
#line 385
      rev = (int )tmp___1;
#line 385
      readbytes += (unsigned int )rev;
#line 387
      switch (rev) {
      case 0: 
#line 389
      rev = -1;
#line 390
      break;
      }
#line 393
      if ((int )buf == (int )endchr) {
#line 393
        if (rev != -1) {
#line 394
          done = 1;
        } else {
#line 393
          goto _L;
        }
      } else
      _L: 
#line 396
      if (rev != -1) {
#line 397
        strncat((char * __restrict  )*str, (char const   * __restrict  )(& buf), (size_t )1);
      }
#line 399
      i ++;
#line 400
      chunk_use ++;
    }
#line 371
    if (done == 0) {
#line 371
      if (! (rev != -1)) {
#line 371
        break;
      }
    } else {
#line 371
      break;
    }
  }
#line 405
  if (rev == -1) {
#line 406
    return (-1);
  } else {
#line 409
    str_chop(*str);
#line 410
    return (0);
  }
}
}
#line 428 "socket.c"
int oz_clisock(int *sockfd , char const   *addr , char *port ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 429
  if ((unsigned long )port == (unsigned long )((void *)0)) {
#line 430
    tmp = oz_clisock_unix(sockfd, addr);
#line 430
    return (tmp);
  } else {
#line 432
    tmp___0 = oz_clisock_tcp(sockfd, addr, port);
#line 432
    return (tmp___0);
  }
}
}
#line 448 "socket.c"
int oz_clisock_unix(int *sockfd , char const   *path ) 
{ 
  int rev ;
  struct sockaddr_un usock ;

  {
#line 449
  rev = 0;
#line 452
  memset((void *)(& usock), '\000', sizeof(usock));
#line 454
  *sockfd = socket(1, 1, 0);
#line 456
  if (*sockfd == -1) {
#line 457
    return (-1);
  }
#line 459
  usock.sun_family = (sa_family_t )1;
#line 460
  strncat((char * __restrict  )(usock.sun_path), (char const   * __restrict  )path,
          sizeof(usock.sun_path));
#line 462
  rev = connect(*sockfd, (struct sockaddr  const  *)((struct sockaddr *)(& usock)),
                (socklen_t )sizeof(usock));
#line 464
  if (rev == -1) {
#line 465
    close(*sockfd);
  }
#line 467
  return (rev);
}
}
#line 485 "socket.c"
int oz_clisock_tcp(int *sockfd , char const   *addr , char *port ) 
{ 
  int rev ;
  int safe_errno ;
  struct addrinfo *hostinfo ;
  struct addrinfo *tmp_hostinfo ;
  struct addrinfo hints ;
  int *tmp ;
  int *tmp___0 ;

  {
#line 486
  rev = 0;
#line 487
  safe_errno = 0;
#line 493
  memset((void *)(& hints), 0, sizeof(hints));
#line 494
  hints.ai_family = 0;
#line 495
  hints.ai_socktype = 1;
#line 496
  hints.ai_flags = 1;
#line 498
  rev = getaddrinfo((char const   * __restrict  )addr, (char const   * __restrict  )port,
                    (struct addrinfo  const  * __restrict  )(& hints), (struct addrinfo ** __restrict  )(& hostinfo));
#line 500
  if (rev != 0) {
#line 501
    return (-2);
  } else {
#line 504
    tmp_hostinfo = hostinfo;
#line 506
    while (1) {
#line 507
      *sockfd = socket(tmp_hostinfo->ai_family, tmp_hostinfo->ai_socktype, 0);
#line 509
      if (*sockfd == -1) {
#line 510
        goto __Cont;
      }
#line 512
      rev = connect(*sockfd, (struct sockaddr  const  *)tmp_hostinfo->ai_addr, tmp_hostinfo->ai_addrlen);
#line 514
      if (rev == -1) {
#line 514
        if (safe_errno == 0) {
#line 515
          tmp = __errno_location();
#line 515
          safe_errno = *tmp;
        }
      }
#line 517
      if (rev == -1) {
#line 518
        close(*sockfd);
#line 520
        if ((unsigned long )tmp_hostinfo->ai_next == (unsigned long )((void *)0)) {
#line 521
          break;
        } else {
#line 524
          tmp_hostinfo = tmp_hostinfo->ai_next;
        }
      }
      __Cont: 
#line 506
      if (! (rev == -1)) {
#line 506
        break;
      }
    }
  }
#line 530
  freeaddrinfo(hostinfo);
#line 532
  if (rev == -1) {
#line 533
    if (safe_errno != 0) {
#line 534
      tmp___0 = __errno_location();
#line 534
      *tmp___0 = safe_errno;
    }
#line 536
    return (-1);
  } else {
#line 540
    return (0);
  }
}
}
#line 556 "socket.c"
int oz_setnonblock(int *sockfd ) 
{ 
  int rev ;

  {
#line 557
  rev = 0;
#line 559
  rev = fcntl(*sockfd, 4, 2048);
#line 561
  if (rev == -1) {
#line 562
    return (-1);
  }
#line 564
  return (0);
}
}
#line 581 "socket.c"
int oz_getsockfamily(int *sockfd ) 
{ 
  struct sockaddr addr ;
  int addr_size ;
  int tmp ;

  {
#line 583
  addr_size = (int )sizeof(addr);
#line 585
  tmp = getsockname(*sockfd, (struct sockaddr * __restrict  )(& addr), (socklen_t * __restrict  )(& addr_size));
#line 585
  if (tmp != 0) {
#line 586
    return (-1);
  }
#line 588
  if ((unsigned long )addr_size == sizeof(struct sockaddr_in )) {
#line 589
    return (2);
  } else
#line 591
  if ((unsigned long )addr_size == sizeof(struct sockaddr_in6 )) {
#line 592
    return (10);
  } else
#line 594
  if ((unsigned long )addr_size == sizeof(struct sockaddr_un )) {
#line 595
    return (1);
  }
#line 597
  return (-1);
}
}
#line 615 "socket.c"
int oz_sendto(int *sockfd , char *addr , char *port , void *buf , size_t buf_size ) 
{ 
  int rev ;
  int sockfd_af ;
  struct addrinfo hints ;
  struct addrinfo *hostinfo ;
  struct addrinfo *tmp_hostinfo ;
  ssize_t tmp ;

  {
#line 616
  rev = 0;
#line 617
  sockfd_af = 0;
#line 622
  sockfd_af = oz_getsockfamily(sockfd);
#line 624
  if (sockfd_af == -1) {
#line 625
    return (-1);
  }
#line 627
  memset((void *)(& hints), '\000', sizeof(hints));
#line 628
  hints.ai_family = sockfd_af;
#line 629
  hints.ai_socktype = 2;
#line 630
  hints.ai_flags = 1;
#line 632
  rev = getaddrinfo((char const   * __restrict  )addr, (char const   * __restrict  )port,
                    (struct addrinfo  const  * __restrict  )(& hints), (struct addrinfo ** __restrict  )(& hostinfo));
#line 634
  if (rev != 0) {
#line 635
    return (-2);
  }
#line 637
  tmp_hostinfo = hostinfo;
#line 639
  while (1) {
#line 640
    tmp = sendto(*sockfd, (void const   *)buf, buf_size, 0, (struct sockaddr  const  *)tmp_hostinfo->ai_addr,
                 tmp_hostinfo->ai_addrlen);
#line 640
    rev = (int )tmp;
#line 642
    if (rev > 0) {
#line 643
      rev = 0;
    }
#line 639
    if (rev != 0) {
#line 639
      tmp_hostinfo = tmp_hostinfo->ai_next;
#line 639
      if (! ((unsigned long )tmp_hostinfo != (unsigned long )((void *)0))) {
#line 639
        break;
      }
    } else {
#line 639
      break;
    }
  }
#line 647
  freeaddrinfo(hostinfo);
#line 649
  return (rev);
}
}
#line 665 "socket.c"
int oz_getstrap(struct sockaddr *addr , size_t addr_size , char *dst , size_t dst_size ,
                int *port ) 
{ 
  struct sockaddr_in *address4 ;
  struct sockaddr_in6 *address6 ;
  register unsigned short __v ;
  register unsigned short __x ;
  char const   *tmp ;
  register unsigned short __v___0 ;
  register unsigned short __x___0 ;
  char const   *tmp___0 ;

  {
#line 669
  memset((void *)dst, '\000', dst_size);
#line 670
  *port = 0;
#line 672
  if (addr_size == sizeof(struct sockaddr_in )) {
#line 673
    address4 = (struct sockaddr_in *)addr;
#line 674
    __x = address4->sin_port;
#line 674
    __asm__  ("rorw $8, %w0": "=r" (__v): "0" (__x): "cc");
#line 674
    *port = (int )__v;
#line 676
    tmp = inet_ntop(2, (void const   * __restrict  )(& address4->sin_addr), (char * __restrict  )dst,
                    (socklen_t )dst_size);
#line 676
    if ((unsigned long )tmp == (unsigned long )((void *)0)) {
#line 677
      return (-1);
    } else {
#line 680
      return (0);
    }
  } else
#line 683
  if (addr_size == sizeof(struct sockaddr_in6 )) {
#line 684
    address6 = (struct sockaddr_in6 *)addr;
#line 685
    __x___0 = address6->sin6_port;
#line 685
    __asm__  ("rorw $8, %w0": "=r" (__v___0): "0" (__x___0): "cc");
#line 685
    *port = (int )__v___0;
#line 687
    tmp___0 = inet_ntop(10, (void const   * __restrict  )(& address6->sin6_addr),
                        (char * __restrict  )dst, (socklen_t )dst_size);
#line 687
    if ((unsigned long )tmp___0 == (unsigned long )((void *)0)) {
#line 688
      return (-1);
    } else {
#line 691
      return (0);
    }
  }
#line 694
  return (-1);
}
}
#line 1 "log.o"
#pragma merger("0","/tmp/cil-LAGlpbJR.i","-Wall,-O3")
#line 242 "/usr/include/stdio.h"
extern int fflush(FILE *__stream ) ;
#line 181 "/usr/include/x86_64-linux-gnu/sys/syslog.h"
extern void openlog(char const   *__ident , int __option , int __facility ) ;
#line 192 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) time_t ( __attribute__((__leaf__)) time)(time_t *__timer ) ;
#line 243
extern  __attribute__((__nothrow__)) struct tm *( __attribute__((__leaf__)) localtime)(time_t const   *__timer ) ;
#line 48 "ozzylib.h"
void textout(char const   *format  , ...) ;
#line 55
void logit(char const   *format  , ...) ;
#line 77
unsigned int syslog_on ;
#line 78
unsigned int consolelog_on ;
#line 79
unsigned int logtime_on ;
#line 26 "log.c"
static int syslog_open  =    0;
#line 21 "log.c"
void logit(char const   *format  , ...) 
{ 
  char msg[5000] ;
  long timestamp ;
  struct tm t ;
  va_list ap ;
  struct tm *tmp ;

  {
#line 29
  if (syslog_open == 0) {
#line 30
    openlog((char const   *)((void *)0), 1, 1 << 3);
#line 31
    syslog_open = 1;
  }
#line 34
  if (syslog_on == 1U) {
#line 35
    __builtin_va_start(ap, format);
#line 36
    vsnprintf((char * __restrict  )(msg), sizeof(msg) - sizeof(char ), (char const   * __restrict  )format,
              ap);
#line 37
    __builtin_va_end(ap);
  } else
#line 34
  if (consolelog_on == 1U) {
#line 35
    __builtin_va_start(ap, format);
#line 36
    vsnprintf((char * __restrict  )(msg), sizeof(msg) - sizeof(char ), (char const   * __restrict  )format,
              ap);
#line 37
    __builtin_va_end(ap);
  }
#line 40
  if (syslog_on == 1U) {
#line 41
    syslog(6 | (1 << 3), "%s", msg);
  }
#line 43
  if (consolelog_on == 1U) {
#line 43
    if (logtime_on == 1U) {
#line 44
      timestamp = time((time_t *)((void *)0));
#line 45
      tmp = localtime((time_t const   *)(& timestamp));
#line 45
      t = *tmp;
#line 47
      textout("[%0.2i/%0.2i/%0.4i]|[%0.2i:%0.2i:%0.2i] %s", t.tm_mday, t.tm_mon + 1,
              t.tm_year + 1900, t.tm_hour, t.tm_min, t.tm_sec, msg);
    } else {
#line 43
      goto _L;
    }
  } else
  _L: 
#line 50
  if (consolelog_on == 1U) {
#line 50
    if (logtime_on == 0U) {
#line 51
      textout("%s", msg);
    }
  }
#line 52
  return;
}
}
#line 67 "log.c"
void textout(char const   *format  , ...) 
{ 
  char msg[5000] ;
  va_list ap ;

  {
#line 71
  __builtin_va_start(ap, format);
#line 72
  vsnprintf((char * __restrict  )(msg), sizeof(msg) - sizeof(char ), (char const   * __restrict  )format,
            ap);
#line 73
  __builtin_va_end(ap);
#line 75
  printf((char const   * __restrict  )"%s\r\n", msg);
#line 76
  fflush(stdout);
#line 77
  return;
}
}
#line 1 "util.o"
#pragma merger("0","/tmp/cil-6aPmWS8E.i","-Wall,-O3")
#line 531 "/usr/include/stdio.h"
extern int fgetc(FILE *__stream ) ;
#line 759
extern void rewind(FILE *__stream ) ;
#line 113 "/usr/include/strings.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcasecmp)(char const   *__s1 ,
                                                                                                   char const   *__s2 )  __attribute__((__pure__)) ;
#line 117
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strncasecmp)(char const   *__s1 ,
                                                                                                    char const   *__s2 ,
                                                                                                    size_t __n )  __attribute__((__pure__)) ;
#line 542 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 259 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strrchr)(char const   *__s ,
                                                                                                int __c )  __attribute__((__pure__)) ;
#line 338
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strstr)(char const   *__haystack ,
                                                                                                 char const   *__needle )  __attribute__((__pure__)) ;
#line 37 "ozzylib.h"
size_t str_comp(char const   *txt1 , char const   *txt2 ) ;
#line 38
size_t strn_comp(char const   *txt1 , char const   *txt2 ) ;
#line 39
size_t oz_cntlines(FILE *f ) ;
#line 40
int is_digits(char const   *str ) ;
#line 51
void getrealname(uid_t uid , char *s , size_t s_len ) ;
#line 52
void getusername(uid_t uid , char *s , size_t s_len ) ;
#line 58
void oz_splitfree(char **msg ) ;
#line 60
char **oz_splitmsg(char const   *txt ) ;
#line 66
void sysexit(char const   *format  , ...) ;
#line 68
int getpwinfo(char const   *pwfile , struct passwd *h , struct pwinfo **res ) ;
#line 69
void freepwinfo(struct pwinfo *pi ) ;
#line 71
unsigned long long oz_mactoint(char *macstr ) ;
#line 72
char *oz_inttomac(unsigned long long mac , char *macbuf , size_t macbuf_size ) ;
#line 25 "util.c"
size_t strn_comp(char const   *txt1 , char const   *txt2 ) 
{ 
  size_t tmp ;
  int tmp___0 ;

  {
#line 26
  tmp = strlen(txt2);
#line 26
  tmp___0 = strncasecmp(txt1, txt2, tmp);
#line 26
  return ((size_t )tmp___0);
}
}
#line 50 "util.c"
size_t str_comp(char const   *txt1 , char const   *txt2 ) 
{ 
  size_t i ;
  int tmp ;

  {
#line 51
  i = (size_t )0;
#line 52
  tmp = strcasecmp(txt1, txt2);
#line 52
  i = (size_t )tmp;
#line 54
  if (i == 0UL) {
#line 55
    return ((size_t )0);
  } else
#line 56
  if (i > 1UL) {
#line 57
    return ((size_t )-1);
  } else {
#line 59
    return ((size_t )-1);
  }
}
}
#line 77 "util.c"
void getrealname(uid_t uid , char *s , size_t s_len ) 
{ 
  struct passwd pwinfo ;
  struct pwinfo *res ;
  int tmp ;

  {
#line 81
  memset((void *)(& pwinfo), '\000', sizeof(pwinfo));
#line 82
  pwinfo.pw_uid = uid;
#line 83
  pwinfo.pw_gid = (__gid_t )-1;
#line 85
  tmp = getpwinfo((char const   *)((void *)0), & pwinfo, & res);
#line 85
  if (tmp != 0) {
#line 86
    memset((void *)s, '\000', s_len);
#line 87
    snprintf((char * __restrict  )s, s_len, (char const   * __restrict  )"NULL");
  } else {
#line 91
    memset((void *)s, '\000', s_len);
#line 92
    snprintf((char * __restrict  )s, s_len, (char const   * __restrict  )"%s", res->pw.pw_gecos);
#line 93
    freepwinfo(res);
  }
#line 95
  return;
}
}
#line 111 "util.c"
void getusername(uid_t uid , char *s , size_t s_len ) 
{ 
  struct passwd pwinfo ;
  struct pwinfo *res ;
  int tmp ;

  {
#line 115
  memset((void *)(& pwinfo), '\000', sizeof(pwinfo));
#line 116
  pwinfo.pw_uid = uid;
#line 117
  pwinfo.pw_gid = (__gid_t )-1;
#line 119
  tmp = getpwinfo((char const   *)((void *)0), & pwinfo, & res);
#line 119
  if (tmp != 0) {
#line 120
    memset((void *)s, '\000', s_len);
#line 121
    snprintf((char * __restrict  )s, s_len, (char const   * __restrict  )"NULL");
  } else {
#line 125
    memset((void *)s, '\000', s_len);
#line 126
    snprintf((char * __restrict  )s, s_len, (char const   * __restrict  )"%s", res->pw.pw_name);
#line 127
    freepwinfo(res);
  }
#line 129
  return;
}
}
#line 145 "util.c"
void str_chop(char *txt ) 
{ 
  size_t i ;

  {
#line 146
  i = (size_t )0;
#line 148
  while (*txt) {
#line 149
    txt ++;
  }
#line 151
  i = (size_t )0;
#line 151
  while (i < 5UL) {
#line 152
    if ((int )*txt == 10) {
#line 153
      *txt = (char )'\000';
    } else
#line 154
    if ((int )*txt == 13) {
#line 155
      *txt = (char )'\000';
    }
#line 157
    txt --;
#line 151
    i ++;
  }
#line 159
  return;
}
}
#line 174 "util.c"
int is_digits(char const   *str ) 
{ 


  {
#line 175
  while (*str) {
#line 176
    if ((int const   )*str >= 48) {
#line 176
      if (! ((int const   )*str <= 57)) {
#line 177
        return (-1);
      }
    } else {
#line 177
      return (-1);
    }
#line 179
    str ++;
  }
#line 182
  return (0);
}
}
#line 199 "util.c"
size_t oz_cntlines(FILE *f ) 
{ 
  size_t i ;
  int chr ;

  {
#line 200
  i = (size_t )0;
#line 203
  while (1) {
#line 203
    chr = fgetc(f);
#line 203
    if (! (chr != -1)) {
#line 203
      break;
    }
#line 204
    if (chr == 10) {
#line 205
      i ++;
    }
  }
#line 208
  rewind(f);
#line 210
  i ++;
#line 210
  return (i);
}
}
#line 230 "util.c"
char **oz_splitmsg(char const   *txt ) 
{ 
  char **msg ;
  char **tmsg ;
  char *bluff ;
  size_t txt_len ;
  size_t spaces ;
  size_t msg_len ;
  size_t msg_use ;
  size_t counter ;
  size_t i ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;

  {
#line 234
  txt_len = (size_t )0;
#line 235
  spaces = (size_t )0;
#line 236
  msg_len = (size_t )0;
#line 237
  msg_use = (size_t )0;
#line 238
  counter = (size_t )0;
#line 239
  i = (size_t )0;
#line 242
  if ((unsigned long )txt == (unsigned long )((void *)0)) {
#line 243
    return ((char **)((void *)0));
  }
#line 245
  txt_len = strlen(txt);
#line 247
  i = (size_t )0;
#line 247
  while (i < txt_len) {
#line 248
    if ((int const   )*(txt + i) == 32) {
#line 249
      spaces ++;
    }
#line 247
    i ++;
  }
#line 252
  spaces += 4UL;
#line 253
  tmp = malloc(spaces * sizeof(char *));
#line 253
  msg = (char **)tmp;
#line 254
  tmsg = msg;
#line 256
  if ((unsigned long )msg == (unsigned long )((void *)0)) {
#line 257
    return ((char **)((void *)0));
  }
#line 259
  msg_len = (size_t )10;
#line 260
  msg_use = (size_t )0;
#line 262
  tmp___0 = malloc(msg_len * sizeof(char ));
#line 262
  bluff = (char *)tmp___0;
#line 264
  if ((unsigned long )bluff == (unsigned long )((void *)0)) {
#line 265
    return ((char **)((void *)0));
  }
#line 267
  memset((void *)bluff, '\000', msg_len * sizeof(char ));
#line 268
  *(msg + 0) = bluff;
#line 270
  i = (size_t )0;
#line 270
  while (i < txt_len) {
#line 271
    if ((int const   )*(txt + i) == 32) {
#line 272
      msg_len = (size_t )10;
#line 273
      msg_use = (size_t )0;
#line 274
      counter ++;
#line 276
      tmp___1 = malloc(msg_len * sizeof(char ));
#line 276
      bluff = (char *)tmp___1;
#line 278
      if ((unsigned long )bluff == (unsigned long )((void *)0)) {
#line 279
        return ((char **)((void *)0));
      }
#line 281
      memset((void *)bluff, '\000', msg_len * sizeof(char ));
#line 282
      *(msg + counter) = bluff;
#line 284
      goto __Cont;
    }
#line 287
    if (! (msg_len < msg_use)) {
#line 288
      msg_len += 10UL;
#line 290
      tmp___2 = realloc((void *)*(msg + counter), msg_len * sizeof(char ));
#line 290
      bluff = (char *)tmp___2;
#line 292
      if ((unsigned long )bluff == (unsigned long )((void *)0)) {
#line 293
        return ((char **)((void *)0));
      }
#line 295
      *(msg + counter) = bluff;
    }
#line 298
    strncat((char * __restrict  )*(msg + counter), (char const   * __restrict  )(txt + i),
            (size_t )1);
#line 299
    msg_use ++;
    __Cont: 
#line 270
    i ++;
  }
#line 303
  *(msg + (counter + 1UL)) = (char *)((void *)0);
#line 305
  return (tmsg);
}
}
#line 322 "util.c"
void oz_splitfree(char **msg ) 
{ 
  size_t i ;

  {
#line 323
  i = (size_t )0;
#line 325
  while (*msg) {
#line 326
    free((void *)*msg);
#line 327
    msg ++;
#line 328
    i ++;
  }
#line 331
  msg -= i;
#line 332
  free((void *)msg);
#line 333
  return;
}
}
#line 348 "util.c"
void sysexit(char const   *format  , ...) 
{ 
  char msg[5000] ;
  va_list ap ;

  {
#line 352
  memset((void *)(msg), '\000', sizeof(msg));
#line 354
  __builtin_va_start(ap, format);
#line 355
  vsnprintf((char * __restrict  )(msg), sizeof(msg) - sizeof(char ), (char const   * __restrict  )format,
            ap);
#line 356
  __builtin_va_end(ap);
#line 358
  logit("%s", msg);
#line 359
  logit(" -- Terminating.");
#line 360
  exit(1);
}
}
#line 377 "util.c"
static void oz_macsplit(char *macstr , int *macstorage ) 
{ 
  char *p ;
  char *q ;
  char buf[10] ;
  int i ;
  char *tmp ;
  char *tmp___1 ;
  char *tmp___2 ;
  double tmp___3 ;

  {
#line 382
  q = macstr;
#line 382
  p = q;
#line 384
  i = 0;
#line 384
  while (i < 6) {
#line 386
    if ((unsigned long )q == (unsigned long )((void *)0)) {
#line 387
      break;
    } else
#line 386
    if ((int )*q == 0) {
#line 387
      break;
    }
#line 389
    p = q;
#line 392
    tmp___1 = __builtin_strchr(q, ':');
#line 392
    q = tmp___1;
#line 392
    if ((unsigned long )q != (unsigned long )((void *)0)) {
#line 393
      tmp = q;
#line 393
      q ++;
#line 393
      *tmp = (char )'\000';
    }
#line 396
    tmp___2 = strstr((char const   *)p, "0x");
#line 396
    if ((unsigned long )tmp___2 == (unsigned long )((void *)0)) {
#line 397
      snprintf((char * __restrict  )(buf), sizeof(buf), (char const   * __restrict  )"0x%s",
               p);
    } else {
#line 400
      snprintf((char * __restrict  )(buf), sizeof(buf), (char const   * __restrict  )"%s",
               p);
    }
#line 403
    tmp___3 = strtod((char const   * __restrict  )(buf), (char ** __restrict  )((void *)0));
#line 403
    *(macstorage + i) = (int )tmp___3;
#line 384
    i ++;
  }
#line 405
  return;
}
}
#line 421 "util.c"
unsigned long long oz_mactoint(char *macstr ) 
{ 
  int i ;
  int x ;
  int retpos ;
  int ret[2] ;
  int mac[6] ;
  unsigned long long retint ;

  {
#line 423
  retpos = 0;
#line 424
  ret[0] = 0;
#line 424
  ret[1] = 0;
#line 429
  oz_macsplit(macstr, mac);
#line 432
  i = 0;
#line 432
  while (i < 6) {
#line 434
    if (i == 4) {
#line 435
      retpos = 0;
    }
#line 438
    x = 0;
#line 438
    while (x < 8) {
#line 439
      if (mac[i] & (1 << x)) {
#line 440
        if (i <= 3) {
#line 441
          ret[0] |= 1 << retpos;
        } else {
#line 443
          ret[1] |= 1 << retpos;
        }
      }
#line 438
      x ++;
#line 438
      retpos ++;
    }
#line 432
    i ++;
  }
#line 448
  memcpy((void * __restrict  )(& retint), (void const   * __restrict  )(ret), sizeof(retint));
#line 450
  return (retint);
}
}
#line 467 "util.c"
char *oz_inttomac(unsigned long long mac , char *macbuf , size_t macbuf_size ) 
{ 
  int i ;
  int x ;
  int c ;
  int ret[2] ;
  char *p ;
  size_t tmp ;
  size_t tmp___0 ;

  {
#line 474
  memmove((void *)(ret), (void const   *)(& mac), sizeof(ret));
#line 477
  memset((void *)macbuf, '\000', macbuf_size);
#line 480
  i = 0;
#line 480
  while (i < 48) {
#line 481
    c = 0;
#line 483
    x = 0;
#line 483
    while (1) {
#line 483
      if (x < 8) {
#line 483
        if (! (i < 48)) {
#line 483
          break;
        }
      } else {
#line 483
        break;
      }
#line 484
      if (i < 32) {
#line 484
        if (ret[0] & (1 << i)) {
#line 485
          c |= 1 << x;
        } else {
#line 484
          goto _L;
        }
      } else
      _L: 
#line 487
      if (i >= 32) {
#line 487
        if (ret[1] & (1 << i)) {
#line 488
          c |= 1 << x;
        }
      }
#line 483
      x ++;
#line 483
      i ++;
    }
#line 492
    tmp = strlen((char const   *)macbuf);
#line 492
    tmp___0 = strlen((char const   *)macbuf);
#line 492
    snprintf((char * __restrict  )(macbuf + tmp___0), macbuf_size - tmp * sizeof(char ),
             (char const   * __restrict  )"%.2X:", c);
  }
#line 496
  p = strrchr((char const   *)macbuf, ':');
#line 496
  if ((unsigned long )p != (unsigned long )((void *)0)) {
#line 496
    if ((int )*(p + 1) == 0) {
#line 497
      *p = (char )'\000';
    }
  }
#line 499
  return (macbuf);
}
}
#line 1 "config.o"
#pragma merger("0","/tmp/cil-3NRW1Mpf.i","-Wall,-O3")
#line 828 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__warn_unused_result__,
__leaf__)) feof)(FILE *__stream ) ;
#line 1301 "/usr/include/x86_64-linux-gnu/bits/string2.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) __strdup)(char const   *__string )  __attribute__((__malloc__)) ;
#line 62 "ozzylib.h"
int oz_confinit(oz_conf **z ) ;
#line 63
void oz_conffree(oz_conf *z ) ;
#line 64
int oz_confp(oz_conf *z , FILE *f ) ;
#line 19 "config.c"
int oz_confinit(oz_conf **z ) 
{ 
  oz_conf *x ;
  void *tmp ;
  void *tmp___0 ;

  {
#line 23
  tmp = malloc(sizeof(oz_conf ));
#line 23
  x = (oz_conf *)tmp;
#line 25
  if ((unsigned long )x == (unsigned long )((void *)0)) {
#line 26
    return (-2);
  }
#line 29
  x->param_use = 0U;
#line 30
  x->key = (char *)((void *)0);
#line 31
  tmp___0 = malloc(sizeof(char *));
#line 31
  x->param = (char **)tmp___0;
#line 32
  x->next = (struct toz_conf *)((void *)0);
#line 35
  if ((unsigned long )x->param == (unsigned long )((void *)0)) {
#line 36
    return (-2);
  }
#line 38
  *(x->param + x->param_use) = (char *)((void *)0);
#line 40
  *z = x;
#line 41
  return (0);
}
}
#line 59 "config.c"
static oz_conf *oz_confnewnode(oz_conf *z ) 
{ 
  oz_conf *x ;
  void *tmp ;
  void *tmp___0 ;

  {
#line 62
  if ((unsigned long )z == (unsigned long )((void *)0)) {
#line 63
    return ((oz_conf *)((void *)0));
  }
#line 66
  tmp = malloc(sizeof(oz_conf ));
#line 66
  x = (oz_conf *)tmp;
#line 68
  if ((unsigned long )x == (unsigned long )((void *)0)) {
#line 69
    return ((oz_conf *)((void *)0));
  }
#line 72
  x->param_use = 0U;
#line 73
  x->key = (char *)((void *)0);
#line 74
  tmp___0 = malloc(sizeof(char *));
#line 74
  x->param = (char **)tmp___0;
#line 75
  x->next = (struct toz_conf *)((void *)0);
#line 78
  if ((unsigned long )x->param == (unsigned long )((void *)0)) {
#line 79
    return ((oz_conf *)((void *)0));
  }
#line 81
  *(x->param + x->param_use) = (char *)((void *)0);
#line 83
  z->next = x;
#line 85
  return (x);
}
}
#line 102 "config.c"
static int oz_confsetkey(oz_conf *z , char *str ) 
{ 
  char *tmp___4 ;

  {
#line 103
  tmp___4 = __strdup((char const   *)str);
#line 103
  z->key = tmp___4;
#line 105
  if ((unsigned long )z->key == (unsigned long )((void *)0)) {
#line 106
    return (-2);
  }
#line 108
  return (0);
}
}
#line 125 "config.c"
static int oz_confnewsub(oz_conf *z , char *str ) 
{ 
  unsigned int str_len ;
  char **bluff ;
  size_t tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
#line 126
  str_len = 0U;
#line 129
  tmp = strlen((char const   *)str);
#line 129
  str_len = (unsigned int )(tmp + 4UL);
#line 131
  tmp___0 = realloc((void *)z->param, (unsigned long )(z->param_use + 1U) * sizeof(char *));
#line 131
  bluff = (char **)tmp___0;
#line 133
  if ((unsigned long )bluff == (unsigned long )((void *)0)) {
#line 134
    return (-2);
  }
#line 136
  z->param = bluff;
#line 137
  tmp___1 = malloc((unsigned long )str_len * sizeof(char ));
#line 137
  *(z->param + z->param_use) = (char *)tmp___1;
#line 139
  if ((unsigned long )*(z->param + z->param_use) == (unsigned long )((void *)0)) {
#line 140
    return (-2);
  }
#line 142
  strncpy((char * __restrict  )*(z->param + z->param_use), (char const   * __restrict  )str,
          (unsigned long )str_len * sizeof(char ));
#line 143
  (z->param_use) ++;
#line 145
  return (0);
}
}
#line 161 "config.c"
void oz_conffree(oz_conf *z ) 
{ 
  unsigned int i ;
  oz_conf *x ;

  {
#line 162
  i = 0U;
#line 165
  if ((unsigned long )z == (unsigned long )((void *)0)) {
#line 166
    return;
  }
#line 169
  while (1) {
#line 169
    x = z;
#line 169
    if (! ((unsigned long )x != (unsigned long )((void *)0))) {
#line 169
      break;
    }
#line 170
    z = z->next;
#line 171
    i = 0U;
#line 173
    if ((unsigned long )x->key != (unsigned long )((void *)0)) {
#line 174
      free((void *)x->key);
    }
#line 176
    while (1) {
#line 176
      if (x->param_use > 0U) {
#line 176
        if (! (i < x->param_use)) {
#line 176
          break;
        }
      } else {
#line 176
        break;
      }
#line 177
      free((void *)*(x->param + i));
#line 178
      i ++;
    }
#line 181
    free((void *)x);
  }
#line 183
  return;
}
}
#line 198 "config.c"
static char *buffer_reset(char *buffer , unsigned int *buffer_len , unsigned int *buffer_use ) 
{ 
  void *tmp ;

  {
#line 199
  tmp = realloc((void *)buffer, 10UL * sizeof(char ));
#line 199
  buffer = (char *)tmp;
#line 201
  if ((unsigned long )buffer == (unsigned long )((void *)0)) {
#line 202
    return ((char *)((void *)0));
  }
#line 204
  memset((void *)buffer, '\000', 10UL * sizeof(char ));
#line 205
  *buffer_len = 10U;
#line 206
  *buffer_use = 0U;
#line 208
  return (buffer);
}
}
#line 224 "config.c"
static char *buffer_enlarge(char *buffer , unsigned int *buffer_len ) 
{ 
  unsigned int i ;
  void *tmp ;

  {
#line 225
  i = 0U;
#line 226
  i = *buffer_len;
#line 228
  *buffer_len += 10U;
#line 230
  tmp = realloc((void *)buffer, (unsigned long )*buffer_len * sizeof(char ));
#line 230
  buffer = (char *)tmp;
#line 232
  if ((unsigned long )buffer == (unsigned long )((void *)0)) {
#line 233
    return ((char *)((void *)0));
  }
#line 235
  while (i < *buffer_len) {
#line 236
    *(buffer + i) = (char )'\000';
#line 235
    i ++;
  }
#line 238
  return (buffer);
}
}
#line 255 "config.c"
int oz_confp(oz_conf *z , FILE *f ) 
{ 
  oz_conf *x ;
  int chr ;
  char *buffer ;
  unsigned int buffer_len ;
  unsigned int buffer_use ;
  unsigned int have_key ;
  unsigned int line_no ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  unsigned int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  unsigned int tmp___6 ;
  int tmp___7 ;

  {
#line 257
  chr = 0;
#line 260
  buffer_len = 0U;
#line 261
  buffer_use = 0U;
#line 263
  have_key = 0U;
#line 264
  line_no = 1U;
#line 266
  x = z;
#line 268
  tmp = malloc(10UL * sizeof(char ));
#line 268
  buffer = (char *)tmp;
#line 269
  if ((unsigned long )buffer == (unsigned long )((void *)0)) {
#line 270
    return (-2);
  } else {
#line 269
    buffer = buffer_reset(buffer, & buffer_len, & buffer_use);
#line 269
    if ((unsigned long )buffer == (unsigned long )((void *)0)) {
#line 270
      return (-2);
    }
  }
#line 272
  while (1) {
#line 272
    tmp___7 = feof(f);
#line 272
    if (tmp___7) {
#line 272
      break;
    }
#line 273
    chr = fgetc(f);
#line 275
    if (chr == 10) {
#line 277
      if (have_key == 0U) {
#line 278
        tmp___0 = oz_confsetkey(x, buffer);
#line 278
        if (tmp___0 == -2) {
#line 279
          return (-2);
        }
      } else
#line 282
      if (have_key == 1U) {
#line 283
        tmp___1 = oz_confnewsub(x, buffer);
#line 283
        if (tmp___1 == -2) {
#line 284
          return (-2);
        }
      }
#line 287
      tmp___2 = line_no;
#line 287
      line_no ++;
#line 287
      x->line_no = tmp___2;
#line 288
      x = oz_confnewnode(x);
#line 290
      if ((unsigned long )x == (unsigned long )((void *)0)) {
#line 291
        return (-2);
      }
#line 293
      have_key = 0U;
#line 295
      buffer = buffer_reset(buffer, & buffer_len, & buffer_use);
#line 295
      if ((unsigned long )buffer == (unsigned long )((void *)0)) {
#line 296
        return (-2);
      }
#line 298
      continue;
    } else
#line 301
    if (chr == 35) {
#line 302
      while (1) {
#line 302
        tmp___3 = feof(f);
#line 302
        if (tmp___3) {
#line 302
          break;
        } else
#line 302
        if (! (chr != 10)) {
#line 302
          break;
        }
#line 303
        chr = fgetc(f);
      }
#line 306
      line_no ++;
    } else
#line 310
    if (chr == 32) {
#line 310
      if (have_key == 0U) {
#line 311
        have_key = 1U;
#line 313
        tmp___4 = oz_confsetkey(x, buffer);
#line 313
        if (tmp___4 == -2) {
#line 314
          return (-2);
        }
#line 316
        buffer = buffer_reset(buffer, & buffer_len, & buffer_use);
#line 316
        if ((unsigned long )buffer == (unsigned long )((void *)0)) {
#line 317
          return (-2);
        }
#line 319
        continue;
      } else {
#line 310
        goto _L___0;
      }
    } else
    _L___0: 
#line 323
    if (chr == 32) {
#line 323
      if (have_key == 1U) {
#line 324
        tmp___5 = oz_confnewsub(x, buffer);
#line 324
        if (tmp___5 == -2) {
#line 325
          return (-2);
        }
#line 327
        buffer = buffer_reset(buffer, & buffer_len, & buffer_use);
#line 327
        if ((unsigned long )buffer == (unsigned long )((void *)0)) {
#line 328
          return (-2);
        }
#line 330
        continue;
      } else {
#line 323
        goto _L;
      }
    } else {
      _L: 
#line 334
      if (buffer_use > 2U) {
#line 334
        if (buffer_use == buffer_len - 2U) {
#line 335
          buffer = buffer_enlarge(buffer, & buffer_len);
#line 335
          if ((unsigned long )buffer == (unsigned long )((void *)0)) {
#line 336
            return (-2);
          }
        }
      }
#line 339
      tmp___6 = buffer_use;
#line 339
      buffer_use ++;
#line 339
      *(buffer + tmp___6) = (char )chr;
    }
  }
#line 343
  free((void *)buffer);
#line 345
  return (0);
}
}
#line 1 "uniq.o"
#pragma merger("0","/tmp/cil-XGeWwuFX.i","-Wall,-O3")
#line 237 "/usr/include/stdio.h"
extern int fclose(FILE *__stream ) ;
#line 272
extern FILE *( __attribute__((__warn_unused_result__)) fopen)(char const   * __restrict  __filename ,
                                                              char const   * __restrict  __modes ) ;
#line 374 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) rand)(void) ;
#line 36 "ozzylib.h"
int oz_rand_fix(int number ) ;
#line 50
void oz_rand_str(char *str , size_t str_len ) ;
#line 5 "uniq.c"
static FILE *oz_rand_f(void) 
{ 
  FILE *f ;

  {
#line 8
  f = fopen((char const   * __restrict  )"/dev/urandom", (char const   * __restrict  )"r");
#line 9
  return (f);
}
}
#line 12 "uniq.c"
static void oz_rand_c(FILE *f ) 
{ 


  {
#line 13
  if (f) {
#line 14
    fclose(f);
  }
#line 15
  return;
}
}
#line 17 "uniq.c"
static int oz_rand_myrand(FILE *f ) 
{ 
  long j ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 20
  if (! f) {
#line 21
    tmp = rand();
#line 21
    tmp___0 = rand();
#line 21
    j = (long )(tmp * tmp___0);
  } else {
#line 24
    fgets((char * __restrict  )((char *)(& j)), (int )sizeof(j), (FILE * __restrict  )f);
  }
#line 26
  if (j < 1L) {
#line 27
    tmp___1 = oz_rand_myrand(f);
#line 27
    j = (long )tmp___1;
  } else {
#line 29
    while (j > 256L) {
#line 30
      if (j < 1L) {
#line 31
        tmp___2 = oz_rand_myrand(f);
#line 31
        j = (long )tmp___2;
      } else {
#line 33
        j /= 2L;
      }
    }
  }
#line 37
  return ((int )j);
}
}
#line 57 "uniq.c"
int oz_rand_fix(int number ) 
{ 
  FILE *f ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 60
  f = oz_rand_f();
#line 62
  if (number >= 65) {
#line 62
    if (number <= 90) {
#line 63
      return (number);
    } else {
#line 62
      goto _L___1;
    }
  } else
  _L___1: 
#line 62
  if (number >= 97) {
#line 62
    if (number <= 122) {
#line 63
      return (number);
    } else {
#line 62
      goto _L___0;
    }
  } else {
    _L___0: 
#line 66
    while (1) {
#line 66
      if (number >= 65) {
#line 66
        if (number <= 90) {
#line 66
          break;
        } else {
#line 66
          goto _L;
        }
      } else
      _L: 
#line 66
      if (number >= 97) {
#line 66
        if (number <= 122) {
#line 66
          break;
        }
      }
#line 67
      if (number > 90) {
#line 68
        tmp = oz_rand_myrand(f);
#line 68
        number -= tmp;
      } else
#line 69
      if (number < 65) {
#line 70
        tmp___0 = oz_rand_myrand(f);
#line 70
        number += tmp___0;
      } else
#line 71
      if (number > 122) {
#line 72
        tmp___1 = oz_rand_myrand(f);
#line 72
        number -= tmp___1;
      } else
#line 73
      if (number < 97) {
#line 74
        tmp___2 = oz_rand_myrand(f);
#line 74
        number += tmp___2;
      }
    }
  }
#line 78
  oz_rand_c(f);
#line 80
  return (number);
}
}
#line 98 "uniq.c"
void oz_rand_str(char *str , size_t str_len ) 
{ 
  time_t t_timest ;
  struct tm t ;
  unsigned int r1 ;
  unsigned int r2 ;
  unsigned int r3 ;
  unsigned int r4 ;
  unsigned int r5 ;
  unsigned int r6 ;
  struct tm *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
#line 101
  r6 = 0U;
#line 103
  time(& t_timest);
#line 104
  tmp = localtime((time_t const   *)(& t_timest));
#line 104
  t = *tmp;
#line 106
  t.tm_mday = oz_rand_fix(t.tm_mday);
#line 107
  t.tm_mon = oz_rand_fix(t.tm_mon);
#line 108
  t.tm_year = oz_rand_fix(t.tm_year + 1900);
#line 109
  t.tm_hour = oz_rand_fix(t.tm_hour);
#line 110
  t.tm_min = oz_rand_fix(t.tm_min);
#line 111
  t.tm_sec = oz_rand_fix(t.tm_sec);
#line 113
  tmp___0 = oz_rand_fix(0);
#line 113
  r1 = (unsigned int )tmp___0;
#line 114
  tmp___1 = oz_rand_fix(0);
#line 114
  r2 = (unsigned int )tmp___1;
#line 115
  tmp___2 = oz_rand_fix(0);
#line 115
  r3 = (unsigned int )tmp___2;
#line 116
  tmp___3 = oz_rand_fix(0);
#line 116
  r4 = (unsigned int )tmp___3;
#line 117
  tmp___4 = oz_rand_fix(0);
#line 117
  r5 = (unsigned int )tmp___4;
#line 118
  tmp___5 = oz_rand_fix(0);
#line 118
  r6 = (unsigned int )tmp___5;
#line 120
  snprintf((char * __restrict  )str, str_len * sizeof(char ), (char const   * __restrict  )"%lu-%c%c%c%c%c%c%c%c%c%c%c%c",
           t_timest, t.tm_mday, t.tm_mon, t.tm_year, t.tm_hour, t.tm_min, t.tm_sec,
           r1, r2, r3, r4, r5, r6);
#line 122
  return;
}
}
#line 1 "passwd.o"
#pragma merger("0","/tmp/cil-NDGc5As_.i","-Wall,-O3")
#line 73 "/usr/include/strings.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) index)(char const   *__s ,
                                                                                              int __c )  __attribute__((__pure__)) ;
#line 20 "passwd.c"
static struct pwinfo *pi_newkey(struct pwinfo *old , struct passwd *p ) 
{ 
  struct pwinfo *new ;
  void *tmp ;
  char *tmp___0 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___13 ;
  char *tmp___14 ;
  char *tmp___20 ;
  char *tmp___21 ;
  char *tmp___27 ;
  char *tmp___28 ;
  char *tmp___34 ;

  {
#line 23
  tmp = malloc(sizeof(struct pwinfo ));
#line 23
  new = (struct pwinfo *)tmp;
#line 25
  if ((unsigned long )new == (unsigned long )((void *)0)) {
#line 26
    return ((struct pwinfo *)((void *)0));
  }
#line 28
  memset((void *)new, '\000', sizeof(struct pwinfo ));
#line 30
  if ((unsigned long )old != (unsigned long )((void *)0)) {
#line 31
    old->pi_next = new;
  }
#line 33
  if ((unsigned long )p->pw_name != (unsigned long )((void *)0)) {
#line 34
    tmp___6 = __strdup((char const   *)p->pw_name);
#line 34
    tmp___0 = tmp___6;
#line 34
    new->pw.pw_name = tmp___0;
#line 34
    if ((unsigned long )tmp___0 == (unsigned long )((void *)0)) {
#line 35
      return ((struct pwinfo *)((void *)0));
    }
  }
#line 37
  if ((unsigned long )p->pw_passwd != (unsigned long )((void *)0)) {
#line 38
    tmp___13 = __strdup((char const   *)p->pw_passwd);
#line 38
    tmp___7 = tmp___13;
#line 38
    new->pw.pw_passwd = tmp___7;
#line 38
    if ((unsigned long )tmp___7 == (unsigned long )((void *)0)) {
#line 39
      return ((struct pwinfo *)((void *)0));
    }
  }
#line 41
  new->pw.pw_uid = p->pw_uid;
#line 42
  new->pw.pw_gid = p->pw_gid;
#line 44
  if ((unsigned long )p->pw_gecos != (unsigned long )((void *)0)) {
#line 45
    tmp___20 = __strdup((char const   *)p->pw_gecos);
#line 45
    tmp___14 = tmp___20;
#line 45
    new->pw.pw_gecos = tmp___14;
#line 45
    if ((unsigned long )tmp___14 == (unsigned long )((void *)0)) {
#line 46
      return ((struct pwinfo *)((void *)0));
    }
  }
#line 48
  if ((unsigned long )p->pw_dir != (unsigned long )((void *)0)) {
#line 49
    tmp___27 = __strdup((char const   *)p->pw_dir);
#line 49
    tmp___21 = tmp___27;
#line 49
    new->pw.pw_dir = tmp___21;
#line 49
    if ((unsigned long )tmp___21 == (unsigned long )((void *)0)) {
#line 50
      return ((struct pwinfo *)((void *)0));
    }
  }
#line 52
  if ((unsigned long )p->pw_shell != (unsigned long )((void *)0)) {
#line 53
    tmp___34 = __strdup((char const   *)p->pw_shell);
#line 53
    tmp___28 = tmp___34;
#line 53
    new->pw.pw_shell = tmp___28;
#line 53
    if ((unsigned long )tmp___28 == (unsigned long )((void *)0)) {
#line 54
      return ((struct pwinfo *)((void *)0));
    }
  }
#line 56
  return (new);
}
}
#line 73 "passwd.c"
static int pi_chksyntax(char *line ) 
{ 
  int i ;

  {
#line 74
  i = 0;
#line 76
  while (1) {
#line 76
    line = index((char const   *)line, ':');
#line 76
    if (! ((unsigned long )line != (unsigned long )((void *)0))) {
#line 76
      break;
    }
#line 77
    line ++;
#line 78
    i ++;
  }
#line 81
  if (i == 6) {
#line 82
    return (0);
  }
#line 84
  return (-1);
}
}
#line 105 "passwd.c"
static int pi_parseline(char *pw_line , struct passwd *res ) 
{ 
  char *pw_uid ;
  char *pw_gid ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
#line 110
  res->pw_name = pw_line;
#line 111
  tmp = index((char const   *)res->pw_name, ':');
#line 111
  res->pw_passwd = tmp;
#line 111
  *(tmp + 0) = (char )'\000';
#line 112
  (res->pw_passwd) ++;
#line 112
  pw_uid = index((char const   *)res->pw_passwd, ':');
#line 112
  *(pw_uid + 0) = (char )'\000';
#line 113
  pw_uid ++;
#line 113
  pw_gid = index((char const   *)pw_uid, ':');
#line 113
  *(pw_gid + 0) = (char )'\000';
#line 114
  pw_gid ++;
#line 114
  tmp___0 = index((char const   *)pw_gid, ':');
#line 114
  res->pw_gecos = tmp___0;
#line 114
  *(tmp___0 + 0) = (char )'\000';
#line 115
  (res->pw_gecos) ++;
#line 115
  tmp___1 = index((char const   *)res->pw_gecos, ':');
#line 115
  res->pw_dir = tmp___1;
#line 115
  *(tmp___1 + 0) = (char )'\000';
#line 116
  (res->pw_dir) ++;
#line 116
  tmp___2 = index((char const   *)res->pw_dir, ':');
#line 116
  res->pw_shell = tmp___2;
#line 116
  *(tmp___2 + 0) = (char )'\000';
#line 117
  (res->pw_shell) ++;
#line 117
  res->pw_shell = res->pw_shell;
#line 119
  tmp___5 = is_digits((char const   *)pw_uid);
#line 119
  if (tmp___5 != 0) {
#line 120
    return (-1);
  } else {
#line 119
    tmp___6 = is_digits((char const   *)pw_gid);
#line 119
    if (tmp___6 != 0) {
#line 120
      return (-1);
    } else {
#line 123
      tmp___3 = atoi((char const   *)pw_uid);
#line 123
      res->pw_uid = (__uid_t )tmp___3;
#line 124
      tmp___4 = atoi((char const   *)pw_gid);
#line 124
      res->pw_gid = (__gid_t )tmp___4;
    }
  }
#line 127
  return (0);
}
}
#line 155 "passwd.c"
int getpwinfo(char const   *pwfile , struct passwd *h , struct pwinfo **res ) 
{ 
  struct passwd pw_tmp ;
  struct pwinfo *pi_pos ;
  struct pwinfo *pi_first ;
  char pw_line[2048] ;
  int rev ;
  FILE *f ;
  int tmp ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___1 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___8 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  size_t __s1_len___1 ;
  size_t __s2_len___1 ;
  int tmp___15 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  size_t __s1_len___2 ;
  size_t __s2_len___2 ;
  int tmp___22 ;
  int tmp___25 ;
  int tmp___26 ;
  int tmp___27 ;
  size_t __s1_len___3 ;
  size_t __s2_len___3 ;
  int tmp___29 ;
  int tmp___32 ;
  int tmp___33 ;
  int tmp___34 ;
  int tmp___35 ;
  char *tmp___36 ;

  {
#line 157
  pi_pos = (struct pwinfo *)((void *)0);
#line 158
  pi_first = (struct pwinfo *)((void *)0);
#line 160
  rev = -1;
#line 163
  if ((unsigned long )pwfile == (unsigned long )((void *)0)) {
#line 164
    f = fopen((char const   * __restrict  )"/etc/passwd", (char const   * __restrict  )"r");
  } else {
#line 167
    f = fopen((char const   * __restrict  )pwfile, (char const   * __restrict  )"r");
  }
#line 169
  if (! f) {
#line 170
    return (-1);
  }
#line 172
  while (1) {
#line 172
    tmp___36 = fgets((char * __restrict  )(pw_line), (int )sizeof(pw_line), (FILE * __restrict  )f);
#line 172
    if (! ((unsigned long )tmp___36 != (unsigned long )((void *)0))) {
#line 172
      break;
    }
#line 173
    tmp___35 = pi_chksyntax(pw_line);
#line 173
    if (tmp___35 != 0) {
#line 174
      continue;
    } else {
#line 177
      str_chop(pw_line);
#line 178
      memset((void *)(& pw_tmp), '\000', sizeof(pw_tmp));
#line 180
      tmp = pi_parseline(pw_line, & pw_tmp);
#line 180
      if (tmp == -1) {
#line 181
        continue;
      }
#line 183
      if ((unsigned long )h->pw_name != (unsigned long )((void *)0)) {
#line 184
        if (0) {
#line 184
          __s1_len = __builtin_strlen((char const   *)h->pw_name);
#line 184
          __s2_len = __builtin_strlen((char const   *)pw_tmp.pw_name);
#line 184
          if (! ((size_t )((void const   *)(h->pw_name + 1)) - (size_t )((void const   *)h->pw_name) == 1UL)) {
#line 184
            goto _L___0;
          } else
#line 184
          if (__s1_len >= 4UL) {
            _L___0: 
#line 184
            if (! ((size_t )((void const   *)(pw_tmp.pw_name + 1)) - (size_t )((void const   *)pw_tmp.pw_name) == 1UL)) {
#line 184
              tmp___6 = 1;
            } else
#line 184
            if (__s2_len >= 4UL) {
#line 184
              tmp___6 = 1;
            } else {
#line 184
              tmp___6 = 0;
            }
          } else {
#line 184
            tmp___6 = 0;
          }
#line 184
          if (tmp___6) {
#line 184
            tmp___1 = __builtin_strcmp((char const   *)h->pw_name, (char const   *)pw_tmp.pw_name);
#line 184
            tmp___5 = tmp___1;
          } else {
#line 184
            tmp___4 = __builtin_strcmp((char const   *)h->pw_name, (char const   *)pw_tmp.pw_name);
#line 184
            tmp___5 = tmp___4;
          }
        } else {
#line 184
          tmp___4 = __builtin_strcmp((char const   *)h->pw_name, (char const   *)pw_tmp.pw_name);
#line 184
          tmp___5 = tmp___4;
        }
#line 184
        if (tmp___5 != 0) {
#line 185
          continue;
        }
      }
#line 187
      if ((unsigned long )h->pw_passwd != (unsigned long )((void *)0)) {
#line 188
        if (0) {
#line 188
          __s1_len___0 = __builtin_strlen((char const   *)h->pw_passwd);
#line 188
          __s2_len___0 = __builtin_strlen((char const   *)pw_tmp.pw_passwd);
#line 188
          if (! ((size_t )((void const   *)(h->pw_passwd + 1)) - (size_t )((void const   *)h->pw_passwd) == 1UL)) {
#line 188
            goto _L___2;
          } else
#line 188
          if (__s1_len___0 >= 4UL) {
            _L___2: 
#line 188
            if (! ((size_t )((void const   *)(pw_tmp.pw_passwd + 1)) - (size_t )((void const   *)pw_tmp.pw_passwd) == 1UL)) {
#line 188
              tmp___13 = 1;
            } else
#line 188
            if (__s2_len___0 >= 4UL) {
#line 188
              tmp___13 = 1;
            } else {
#line 188
              tmp___13 = 0;
            }
          } else {
#line 188
            tmp___13 = 0;
          }
#line 188
          if (tmp___13) {
#line 188
            tmp___8 = __builtin_strcmp((char const   *)h->pw_passwd, (char const   *)pw_tmp.pw_passwd);
#line 188
            tmp___12 = tmp___8;
          } else {
#line 188
            tmp___11 = __builtin_strcmp((char const   *)h->pw_passwd, (char const   *)pw_tmp.pw_passwd);
#line 188
            tmp___12 = tmp___11;
          }
        } else {
#line 188
          tmp___11 = __builtin_strcmp((char const   *)h->pw_passwd, (char const   *)pw_tmp.pw_passwd);
#line 188
          tmp___12 = tmp___11;
        }
#line 188
        if (tmp___12 != 0) {
#line 189
          continue;
        }
      }
#line 191
      if ((unsigned long )h->pw_gecos != (unsigned long )((void *)0)) {
#line 192
        if (0) {
#line 192
          __s1_len___1 = __builtin_strlen((char const   *)h->pw_gecos);
#line 192
          __s2_len___1 = __builtin_strlen((char const   *)pw_tmp.pw_gecos);
#line 192
          if (! ((size_t )((void const   *)(h->pw_gecos + 1)) - (size_t )((void const   *)h->pw_gecos) == 1UL)) {
#line 192
            goto _L___4;
          } else
#line 192
          if (__s1_len___1 >= 4UL) {
            _L___4: 
#line 192
            if (! ((size_t )((void const   *)(pw_tmp.pw_gecos + 1)) - (size_t )((void const   *)pw_tmp.pw_gecos) == 1UL)) {
#line 192
              tmp___20 = 1;
            } else
#line 192
            if (__s2_len___1 >= 4UL) {
#line 192
              tmp___20 = 1;
            } else {
#line 192
              tmp___20 = 0;
            }
          } else {
#line 192
            tmp___20 = 0;
          }
#line 192
          if (tmp___20) {
#line 192
            tmp___15 = __builtin_strcmp((char const   *)h->pw_gecos, (char const   *)pw_tmp.pw_gecos);
#line 192
            tmp___19 = tmp___15;
          } else {
#line 192
            tmp___18 = __builtin_strcmp((char const   *)h->pw_gecos, (char const   *)pw_tmp.pw_gecos);
#line 192
            tmp___19 = tmp___18;
          }
        } else {
#line 192
          tmp___18 = __builtin_strcmp((char const   *)h->pw_gecos, (char const   *)pw_tmp.pw_gecos);
#line 192
          tmp___19 = tmp___18;
        }
#line 192
        if (tmp___19 != 0) {
#line 193
          continue;
        }
      }
#line 195
      if ((unsigned long )h->pw_dir != (unsigned long )((void *)0)) {
#line 196
        if (0) {
#line 196
          __s1_len___2 = __builtin_strlen((char const   *)h->pw_dir);
#line 196
          __s2_len___2 = __builtin_strlen((char const   *)pw_tmp.pw_dir);
#line 196
          if (! ((size_t )((void const   *)(h->pw_dir + 1)) - (size_t )((void const   *)h->pw_dir) == 1UL)) {
#line 196
            goto _L___6;
          } else
#line 196
          if (__s1_len___2 >= 4UL) {
            _L___6: 
#line 196
            if (! ((size_t )((void const   *)(pw_tmp.pw_dir + 1)) - (size_t )((void const   *)pw_tmp.pw_dir) == 1UL)) {
#line 196
              tmp___27 = 1;
            } else
#line 196
            if (__s2_len___2 >= 4UL) {
#line 196
              tmp___27 = 1;
            } else {
#line 196
              tmp___27 = 0;
            }
          } else {
#line 196
            tmp___27 = 0;
          }
#line 196
          if (tmp___27) {
#line 196
            tmp___22 = __builtin_strcmp((char const   *)h->pw_dir, (char const   *)pw_tmp.pw_dir);
#line 196
            tmp___26 = tmp___22;
          } else {
#line 196
            tmp___25 = __builtin_strcmp((char const   *)h->pw_dir, (char const   *)pw_tmp.pw_dir);
#line 196
            tmp___26 = tmp___25;
          }
        } else {
#line 196
          tmp___25 = __builtin_strcmp((char const   *)h->pw_dir, (char const   *)pw_tmp.pw_dir);
#line 196
          tmp___26 = tmp___25;
        }
#line 196
        if (tmp___26 != 0) {
#line 197
          continue;
        }
      }
#line 199
      if ((unsigned long )h->pw_shell != (unsigned long )((void *)0)) {
#line 200
        if (0) {
#line 200
          __s1_len___3 = __builtin_strlen((char const   *)h->pw_shell);
#line 200
          __s2_len___3 = __builtin_strlen((char const   *)pw_tmp.pw_shell);
#line 200
          if (! ((size_t )((void const   *)(h->pw_shell + 1)) - (size_t )((void const   *)h->pw_shell) == 1UL)) {
#line 200
            goto _L___8;
          } else
#line 200
          if (__s1_len___3 >= 4UL) {
            _L___8: 
#line 200
            if (! ((size_t )((void const   *)(pw_tmp.pw_shell + 1)) - (size_t )((void const   *)pw_tmp.pw_shell) == 1UL)) {
#line 200
              tmp___34 = 1;
            } else
#line 200
            if (__s2_len___3 >= 4UL) {
#line 200
              tmp___34 = 1;
            } else {
#line 200
              tmp___34 = 0;
            }
          } else {
#line 200
            tmp___34 = 0;
          }
#line 200
          if (tmp___34) {
#line 200
            tmp___29 = __builtin_strcmp((char const   *)h->pw_shell, (char const   *)pw_tmp.pw_shell);
#line 200
            tmp___33 = tmp___29;
          } else {
#line 200
            tmp___32 = __builtin_strcmp((char const   *)h->pw_shell, (char const   *)pw_tmp.pw_shell);
#line 200
            tmp___33 = tmp___32;
          }
        } else {
#line 200
          tmp___32 = __builtin_strcmp((char const   *)h->pw_shell, (char const   *)pw_tmp.pw_shell);
#line 200
          tmp___33 = tmp___32;
        }
#line 200
        if (tmp___33 != 0) {
#line 201
          continue;
        }
      }
#line 203
      if (h->pw_uid != 4294967295U) {
#line 204
        if (h->pw_uid != pw_tmp.pw_uid) {
#line 205
          continue;
        }
      }
#line 207
      if (h->pw_gid != 4294967295U) {
#line 208
        if (h->pw_gid != pw_tmp.pw_gid) {
#line 209
          continue;
        }
      }
#line 215
      pi_pos = pi_newkey(pi_pos, & pw_tmp);
#line 217
      if ((unsigned long )pi_pos == (unsigned long )((void *)0)) {
#line 218
        fclose(f);
#line 219
        return (-2);
      }
#line 223
      if ((unsigned long )pi_first == (unsigned long )((void *)0)) {
#line 224
        pi_first = pi_pos;
#line 224
        *res = pi_first;
      }
#line 226
      rev = 0;
    }
  }
#line 230
  fclose(f);
#line 232
  return (rev);
}
}
#line 249 "passwd.c"
void freepwinfo(struct pwinfo *pi ) 
{ 
  struct pwinfo *tmp ;
  struct pwinfo *old ;

  {
#line 253
  if ((unsigned long )pi == (unsigned long )((void *)0)) {
#line 254
    return;
  }
#line 256
  tmp = pi;
#line 258
  while (1) {
#line 259
    if ((unsigned long )tmp->pw.pw_name != (unsigned long )((void *)0)) {
#line 260
      free((void *)tmp->pw.pw_name);
    }
#line 262
    if ((unsigned long )tmp->pw.pw_passwd != (unsigned long )((void *)0)) {
#line 263
      free((void *)tmp->pw.pw_passwd);
    }
#line 265
    if ((unsigned long )tmp->pw.pw_gecos != (unsigned long )((void *)0)) {
#line 266
      free((void *)tmp->pw.pw_gecos);
    }
#line 268
    if ((unsigned long )tmp->pw.pw_dir != (unsigned long )((void *)0)) {
#line 269
      free((void *)tmp->pw.pw_dir);
    }
#line 271
    if ((unsigned long )tmp->pw.pw_shell != (unsigned long )((void *)0)) {
#line 272
      free((void *)tmp->pw.pw_shell);
    }
#line 258
    tmp = tmp->pi_next;
#line 258
    if (! ((unsigned long )tmp != (unsigned long )((void *)0))) {
#line 258
      break;
    }
  }
#line 275
  tmp = pi;
#line 275
  old = tmp;
#line 277
  while (1) {
#line 278
    tmp = tmp->pi_next;
#line 279
    free((void *)old);
#line 277
    old = tmp;
#line 277
    if (! ((unsigned long )old != (unsigned long )((void *)0))) {
#line 277
      break;
    }
  }
#line 281
  return;
}
}
#line 1 "errno.o"
#pragma merger("0","/tmp/cil-09WB9813.i","-Wall,-O3")
#line 409 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) strerror)(int __errnum ) ;
#line 74 "ozzylib.h"
char *oz_err(int errorcode ) ;
#line 6 "errno.c"
static struct oz_errno_t  const  oz_errno_codes[124]  = 
#line 6 "errno.c"
  {      {1, (char *)"Operation not permitted"}, 
        {2, (char *)"No such file or directory"}, 
        {3, (char *)"No such process"}, 
        {4, (char *)"Interrupted system call"}, 
        {5, (char *)"Input/output error"}, 
        {6, (char *)"No such device or address"}, 
        {7, (char *)"Argument list too long"}, 
        {8, (char *)"Exec format error"}, 
        {9, (char *)"Bad file descriptor"}, 
        {10, (char *)"No child processes"}, 
        {11, (char *)"Resource temporarily unavailable"}, 
        {12, (char *)"Cannot allocate memory"}, 
        {13, (char *)"Permission denied"}, 
        {14, (char *)"Bad address"}, 
        {15, (char *)"Block device required"}, 
        {16, (char *)"Device or resource busy"}, 
        {17, (char *)"File exists"}, 
        {18, (char *)"Invalid cross-device link"}, 
        {19, (char *)"No such device"}, 
        {20, (char *)"Not a directory"}, 
        {21, (char *)"Is a directory"}, 
        {22, (char *)"Invalid argument"}, 
        {23, (char *)"Too many open files in system"}, 
        {24, (char *)"Too many open files"}, 
        {25, (char *)"Inappropriate ioctl for device"}, 
        {26, (char *)"Text file busy"}, 
        {27, (char *)"File too large"}, 
        {28, (char *)"No space left on device"}, 
        {29, (char *)"Illegal seek"}, 
        {30, (char *)"Read-only file system"}, 
        {31, (char *)"Too many links"}, 
        {32, (char *)"Broken pipe"}, 
        {33, (char *)"Numerical argument out of domain"}, 
        {34, (char *)"Numerical result out of range"}, 
        {35, (char *)"Resource deadlock avoided"}, 
        {36, (char *)"File name too long"}, 
        {37, (char *)"No locks available"}, 
        {38, (char *)"Function not implemented"}, 
        {39, (char *)"Directory not empty"}, 
        {40, (char *)"Too many levels of symbolic links"}, 
        {11, (char *)"Unknown error 41"}, 
        {42, (char *)"No message of desired type"}, 
        {43, (char *)"Identifier removed"}, 
        {44, (char *)"Channel number out of range"}, 
        {45, (char *)"Level 2 not synchronized"}, 
        {46, (char *)"Level 3 halted"}, 
        {47, (char *)"Level 3 reset"}, 
        {48, (char *)"Link number out of range"}, 
        {49, (char *)"Protocol driver not attached"}, 
        {50, (char *)"No CSI structure available"}, 
        {51, (char *)"Level 2 halted"}, 
        {52, (char *)"Invalid exchange"}, 
        {53, (char *)"Invalid request descriptor"}, 
        {54, (char *)"Exchange full"}, 
        {55, (char *)"No anode"}, 
        {56, (char *)"Invalid request code"}, 
        {57, (char *)"Invalid slot"}, 
        {59, (char *)"Bad font file format"}, 
        {60, (char *)"Device not a stream"}, 
        {61, (char *)"No data available"}, 
        {62, (char *)"Timer expired"}, 
        {63, (char *)"Out of streams resources"}, 
        {64, (char *)"Machine is not on the network"}, 
        {65, (char *)"Package not installed"}, 
        {66, (char *)"Object is remote"}, 
        {67, (char *)"Link has been severed"}, 
        {68, (char *)"Advertise error"}, 
        {69, (char *)"Srmount error"}, 
        {70, (char *)"Communication error on send"}, 
        {71, (char *)"Protocol error"}, 
        {72, (char *)"Multihop attempted"}, 
        {73, (char *)"RFS specific error"}, 
        {74, (char *)"Bad message"}, 
        {75, (char *)"Value too large for defined data type"}, 
        {76, (char *)"Name not unique on network"}, 
        {77, (char *)"File descriptor in bad state"}, 
        {78, (char *)"Remote address changed"}, 
        {79, (char *)"Can not access a needed shared library"}, 
        {80, (char *)"Accessing a corrupted shared library"}, 
        {81, (char *)".lib section in a.out corrupted"}, 
        {82, (char *)"Attempting to link in too many shared libraries"}, 
        {83, (char *)"Cannot exec a shared library directly"}, 
        {84, (char *)"Invalid or incomplete multibyte or wide character"}, 
        {85, (char *)"Interrupted system call should be restarted"}, 
        {86, (char *)"Streams pipe error"}, 
        {87, (char *)"Too many users"}, 
        {88, (char *)"Socket operation on non-socket"}, 
        {89, (char *)"Destination address required"}, 
        {90, (char *)"Message too long"}, 
        {91, (char *)"Protocol wrong type for socket"}, 
        {92, (char *)"Protocol not available"}, 
        {93, (char *)"Protocol not supported"}, 
        {94, (char *)"Socket type not supported"}, 
        {95, (char *)"Operation not supported"}, 
        {96, (char *)"Protocol family not supported"}, 
        {97, (char *)"Address family not supported by protocol"}, 
        {98, (char *)"Address already in use"}, 
        {99, (char *)"Cannot assign requested address"}, 
        {100, (char *)"Network is down"}, 
        {101, (char *)"Network is unreachable"}, 
        {102, (char *)"Network dropped connection on reset"}, 
        {103, (char *)"Software caused connection abort"}, 
        {104, (char *)"Connection reset by peer"}, 
        {105, (char *)"No buffer space available"}, 
        {106, (char *)"Transport endpoint is already connected"}, 
        {107, (char *)"Transport endpoint is not connected"}, 
        {108, (char *)"Cannot send after transport endpoint shutdown"}, 
        {109, (char *)"Too many references: cannot splice"}, 
        {110, (char *)"Connection timed out"}, 
        {111, (char *)"Connection refused"}, 
        {112, (char *)"Host is down"}, 
        {113, (char *)"No route to host"}, 
        {114, (char *)"Operation already in progress"}, 
        {115, (char *)"Operation now in progress"}, 
        {116, (char *)"Stale NFS file handle"}, 
        {117, (char *)"Structure needs cleaning"}, 
        {118, (char *)"Not a XENIX named type file"}, 
        {119, (char *)"No XENIX semaphores available"}, 
        {120, (char *)"Is a named type file"}, 
        {121, (char *)"Remote I/O error"}, 
        {122, (char *)"Disk quota exceeded"}, 
        {123, (char *)"No medium found"}, 
        {124, (char *)"Wrong medium type"}, 
        {0, (char *)"Success"}};
#line 149 "errno.c"
char *oz_err(int errorcode ) 
{ 
  int i ;
  char *tmp ;

  {
#line 153
  i = 0;
#line 153
  while (1) {
#line 154
    if (oz_errno_codes[i].error_code == (int const   )errorcode) {
#line 155
      return ((char *)oz_errno_codes[i].error_message);
    }
#line 157
    if (oz_errno_codes[i].error_code == 0) {
#line 158
      break;
    }
#line 153
    i ++;
  }
#line 162
  tmp = strerror(errorcode);
#line 162
  return (tmp);
}
}
#line 1 "config.o"
#pragma merger("0","/tmp/cil-Wz5PXQeQ.i","-Wall,-O3")
#line 550 "/usr/include/stdio.h"
__inline extern int getc_unlocked(FILE *__fp ) ;
#line 602
__inline extern int putc_unlocked(int __c , FILE *__stream ) ;
#line 563 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__warn_unused_result__,
__nonnull__(1), __leaf__)) getenv)(char const   *__name ) ;
#line 697 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) __uid_t ( __attribute__((__leaf__)) getuid)(void) ;
#line 133 "supervixen.h"
struct commands_st commands_st  ;
#line 154 "supervixen.h"
tthreads threads[101]  ;
#line 155 "supervixen.h"
tservers servers[51]  ;
#line 156 "supervixen.h"
tcommands *commands  ;
#line 157 "supervixen.h"
tlisten_socks *listen_socks  ;
#line 158 "supervixen.h"
tsettings settings  ;
#line 160 "supervixen.h"
char *channels[501]  ;
#line 161 "supervixen.h"
char **linecache  ;
#line 164 "supervixen.h"
pthread_mutex_t threads_lock  ;
#line 165 "supervixen.h"
pthread_mutex_t lcache_lock  ;
#line 166 "supervixen.h"
pthread_mutex_t channels_lock  ;
#line 167 "supervixen.h"
pthread_mutex_t commands_lock  ;
#line 169
unsigned int servers_cnt ;
#line 172
unsigned int listen_socks_no ;
#line 181
void sp_parse_config(void) ;
#line 26 "config.c"
void sp_parse_config(void) 
{ 
  int rev ;
  char *homedir ;
  char *tmp ;
  FILE *f ;
  int have_nickname ;
  int have_realname ;
  int have_username ;
  int have_listen_addr ;
  int have_auth_user ;
  int have_auth_pass ;
  int have_server ;
  oz_conf *c ;
  oz_conf *d ;
  size_t tmp_len ;
  unsigned int i ;
  char spacechr ;
  char *tmp___5 ;
  size_t tmp___6 ;
  void *tmp___7 ;
  int *tmp___8 ;
  char *tmp___9 ;
  int *tmp___10 ;
  char *tmp___11 ;
  int *tmp___12 ;
  char *tmp___13 ;
  size_t tmp___14 ;
  size_t tmp___15 ;
  size_t tmp___16 ;
  int tmp___17 ;
  void *tmp___18 ;
  void *tmp___19 ;
  int *tmp___20 ;
  char *tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  size_t tmp___24 ;
  size_t tmp___25 ;
  size_t tmp___26 ;
  int tmp___27 ;
  int tmp___28 ;
  int tmp___29 ;
  int tmp___30 ;
  size_t tmp___31 ;
  size_t tmp___32 ;
  size_t tmp___33 ;
  size_t tmp___34 ;
  size_t tmp___35 ;
  size_t tmp___36 ;
  size_t tmp___37 ;
  size_t tmp___38 ;
  size_t tmp___39 ;
  size_t tmp___40 ;
  size_t tmp___41 ;
  size_t tmp___42 ;
  size_t tmp___43 ;
  size_t tmp___44 ;
  size_t tmp___45 ;
  __uid_t tmp___46 ;
  __uid_t tmp___47 ;

  {
#line 27
  rev = 0;
#line 28
  homedir = (char *)((void *)0);
#line 29
  tmp = (char *)((void *)0);
#line 32
  have_nickname = 0;
#line 33
  have_realname = 0;
#line 34
  have_username = 0;
#line 35
  have_listen_addr = 0;
#line 36
  have_auth_user = 0;
#line 37
  have_auth_pass = 0;
#line 38
  have_server = 0;
#line 41
  tmp_len = (size_t )0;
#line 42
  i = 0U;
#line 45
  rev = gethostname(settings.hostname, sizeof(settings.hostname) - sizeof(char ));
#line 47
  if (rev == -1) {
#line 48
    sysexit("Unable to get my hostname!");
  }
#line 54
  f = fopen((char const   * __restrict  )".supervixenrc", (char const   * __restrict  )"r");
#line 56
  if (! f) {
#line 57
    homedir = getenv("HOME");
#line 59
    if ((unsigned long )homedir == (unsigned long )((void *)0)) {
#line 60
      sysexit("I was unable to find any configuration file to use, please put it in this directory named \".supervixenrc\"! ");
    } else {
#line 64
      tmp___5 = __strdup((char const   *)homedir);
#line 64
      tmp = tmp___5;
#line 66
      if ((unsigned long )tmp != (unsigned long )((void *)0)) {
#line 67
        tmp___6 = strlen((char const   *)tmp);
#line 67
        tmp___7 = realloc((void *)tmp, (tmp___6 + 30UL) * sizeof(char ));
#line 67
        tmp = (char *)tmp___7;
      }
#line 69
      if ((unsigned long )tmp == (unsigned long )((void *)0)) {
#line 70
        tmp___8 = __errno_location();
#line 70
        tmp___9 = strerror(*tmp___8);
#line 70
        sysexit("Unable to allocate memory while initalizing configfile parsing, system error=%s.",
                tmp___9);
      }
#line 72
      strcat((char * __restrict  )tmp, (char const   * __restrict  )"/.supervixenrc");
#line 74
      f = fopen((char const   * __restrict  )tmp, (char const   * __restrict  )"r");
#line 76
      if (! f) {
#line 77
        sysexit("I was unable to find any configuration file to use, please put it in your homedirectory named \".supervixenrc\", or in this directory named \".supervixenrc\"!");
      }
#line 79
      free((void *)tmp);
    }
  }
#line 87
  rev = oz_confinit(& c);
#line 89
  if (rev != 0) {
#line 90
    tmp___10 = __errno_location();
#line 90
    tmp___11 = strerror(*tmp___10);
#line 90
    sysexit("Unable to parse configuration file, error=%s.", tmp___11);
  }
#line 92
  rev = oz_confp(c, f);
#line 94
  if (rev != 0) {
#line 95
    tmp___12 = __errno_location();
#line 95
    tmp___13 = strerror(*tmp___12);
#line 95
    sysexit("Unable to parse configuration file, error=%s.", tmp___13);
  }
#line 97
  d = c;
#line 99
  while (! ((unsigned long )d == (unsigned long )((void *)0))) {
#line 103
    if ((unsigned long )*(d->param + 0) == (unsigned long )((void *)0)) {
#line 104
      goto __Cont;
    } else
#line 103
    if ((unsigned long )d->key == (unsigned long )((void *)0)) {
#line 104
      goto __Cont;
    }
#line 109
    i = 0U;
#line 109
    while (i < d->param_use) {
#line 109
      i ++;
    }
#line 114
    tmp___45 = str_comp((char const   *)d->key, "username");
#line 114
    if (tmp___45 == 0UL) {
#line 115
      have_username = 1;
#line 116
      snprintf((char * __restrict  )(settings.username), sizeof(settings.username) - sizeof(char ),
               (char const   * __restrict  )"%s", *(d->param + 0));
    } else {
#line 119
      tmp___44 = str_comp((char const   *)d->key, "realname");
#line 119
      if (tmp___44 == 0UL) {
#line 120
        have_realname = 1;
#line 122
        i = 0U;
#line 123
        spacechr = (char )' ';
#line 124
        tmp_len = (size_t )0;
#line 126
        memset((void *)(settings.realname), '\000', sizeof(settings.realname));
#line 128
        while (1) {
#line 128
          if (i < d->param_use) {
#line 128
            tmp___16 = strlen((char const   *)*(d->param + i));
#line 128
            if (! (((tmp_len + tmp___16) + 1UL) * sizeof(char ) < sizeof(settings.realname) / sizeof(char ))) {
#line 128
              break;
            }
          } else {
#line 128
            break;
          }
#line 129
          tmp___14 = strlen((char const   *)*(d->param + i));
#line 129
          strncat((char * __restrict  )(settings.realname), (char const   * __restrict  )*(d->param + i),
                  tmp___14);
#line 130
          tmp___15 = strlen((char const   *)*(d->param + i));
#line 130
          tmp_len += tmp___15;
#line 132
          strncat((char * __restrict  )(settings.realname), (char const   * __restrict  )(& spacechr),
                  (size_t )1);
#line 133
          tmp_len ++;
#line 135
          str_chop(settings.realname);
#line 137
          i ++;
        }
      } else {
#line 141
        tmp___43 = str_comp((char const   *)d->key, "listen");
#line 141
        if (tmp___43 == 0UL) {
#line 142
          if (d->param_use < 2U) {
#line 143
            logit("Syntax error on line %i in your configuration file, listen takes two parameters!",
                  d->line_no);
#line 144
            goto __Cont;
          }
#line 147
          tmp___17 = is_digits((char const   *)*(d->param + 1));
#line 147
          if (tmp___17 != 0) {
#line 148
            logit("Syntax error on line %i in your configuration file, the port is not an digit!",
                  d->line_no);
#line 149
            goto __Cont;
          }
#line 152
          if (listen_socks_no == 0U) {
#line 153
            tmp___18 = malloc(sizeof(tlisten_socks ));
#line 153
            listen_socks = (tlisten_socks *)tmp___18;
          } else {
#line 155
            tmp___19 = realloc((void *)listen_socks, (unsigned long )(listen_socks_no + 1U) * sizeof(tlisten_socks ));
#line 155
            listen_socks = (tlisten_socks *)tmp___19;
          }
#line 157
          if ((unsigned long )listen_socks == (unsigned long )((void *)0)) {
#line 158
            tmp___20 = __errno_location();
#line 158
            tmp___21 = strerror(*tmp___20);
#line 158
            sysexit("Could not allocate memory for listening sockets array, error=%s.",
                    tmp___21);
          }
#line 160
          snprintf((char * __restrict  )((listen_socks + listen_socks_no)->address),
                   sizeof((listen_socks + listen_socks_no)->address) - sizeof(char ),
                   (char const   * __restrict  )"%s", *(d->param + 0));
#line 161
          tmp___22 = atoi((char const   *)*(d->param + 1));
#line 161
          (listen_socks + listen_socks_no)->port = (unsigned int )tmp___22;
#line 162
          listen_socks_no ++;
#line 164
          have_listen_addr = 1;
        } else {
#line 167
          tmp___42 = str_comp((char const   *)d->key, "auth_user");
#line 167
          if (tmp___42 == 0UL) {
#line 168
            have_auth_user = 1;
#line 169
            snprintf((char * __restrict  )(settings.auth_user), sizeof(settings.auth_user) - sizeof(char ),
                     (char const   * __restrict  )"%s", *(d->param + 0));
          } else {
#line 172
            tmp___41 = str_comp((char const   *)d->key, "auth_pass");
#line 172
            if (tmp___41 == 0UL) {
#line 173
              have_auth_pass = 1;
#line 174
              snprintf((char * __restrict  )(settings.auth_pass), sizeof(settings.auth_pass) - sizeof(char ),
                       (char const   * __restrict  )"%s", *(d->param + 0));
            } else {
#line 177
              tmp___40 = str_comp((char const   *)d->key, "nickname");
#line 177
              if (tmp___40 == 0UL) {
#line 178
                have_nickname = 1;
#line 179
                snprintf((char * __restrict  )(settings.nickname), sizeof(settings.nickname) - sizeof(char ),
                         (char const   * __restrict  )"%s", *(d->param + 0));
              } else {
#line 182
                tmp___39 = str_comp((char const   *)d->key, "server");
#line 182
                if (tmp___39 == 0UL) {
#line 182
                  if (servers_cnt < 50U) {
#line 183
                    servers_cnt ++;
#line 185
                    strncat((char * __restrict  )(servers[have_server].address), (char const   * __restrict  )*(d->param + 0),
                            sizeof(servers[have_server].address));
#line 187
                    if ((unsigned long )*(d->param + 1) == (unsigned long )((void *)0)) {
#line 188
                      logit("Syntax error on line %i in your configuration file, the port is invalid, using 6667 insted.",
                            d->line_no);
#line 189
                      servers[have_server].port = 6667;
                    } else {
#line 187
                      tmp___23 = is_digits((char const   *)*(d->param + 1));
#line 187
                      if (tmp___23 != 0) {
#line 188
                        logit("Syntax error on line %i in your configuration file, the port is invalid, using 6667 insted.",
                              d->line_no);
#line 189
                        servers[have_server].port = 6667;
                      } else {
#line 193
                        servers[have_server].port = atoi((char const   *)*(d->param + 1));
                      }
                    }
#line 195
                    have_server ++;
                  } else {
#line 182
                    goto _L___0;
                  }
                } else {
                  _L___0: /* CIL Label */ 
#line 198
                  tmp___38 = str_comp((char const   *)d->key, "server");
#line 198
                  if (tmp___38 == 0UL) {
#line 198
                    if (servers_cnt >= 50U) {
#line 199
                      if ((unsigned long )*(d->param + 1) == (unsigned long )((void *)0)) {
#line 200
                        logit("Config: Too many servers in configfile, ignoring %s",
                              *(d->param + 0));
                      } else {
#line 202
                        logit("Config: Too many servers in configfile, ignoring %s:%s",
                              *(d->param + 0), *(d->param + 1));
                      }
                    } else {
#line 198
                      goto _L;
                    }
                  } else {
                    _L: /* CIL Label */ 
#line 205
                    tmp___37 = str_comp((char const   *)d->key, "syslog");
#line 205
                    if (tmp___37 == 0UL) {
#line 206
                      tmp___24 = str_comp((char const   *)*(d->param + 0), "on");
#line 206
                      if (tmp___24 == 0UL) {
#line 207
                        syslog_on = 1U;
                      } else {
#line 209
                        syslog_on = 0U;
                      }
                    } else {
#line 212
                      tmp___36 = str_comp((char const   *)d->key, "consolelog");
#line 212
                      if (tmp___36 == 0UL) {
#line 213
                        tmp___25 = str_comp((char const   *)*(d->param + 0), "on");
#line 213
                        if (tmp___25 == 0UL) {
#line 214
                          consolelog_on = 1U;
                        } else {
#line 216
                          consolelog_on = 0U;
                        }
                      } else {
#line 219
                        tmp___35 = str_comp((char const   *)d->key, "logtime");
#line 219
                        if (tmp___35 == 0UL) {
#line 220
                          tmp___26 = str_comp((char const   *)*(d->param + 0), "on");
#line 220
                          if (tmp___26 == 0UL) {
#line 221
                            logtime_on = 1U;
                          } else {
#line 223
                            logtime_on = 0U;
                          }
                        } else {
#line 226
                          tmp___34 = str_comp((char const   *)d->key, "max_unauth_time");
#line 226
                          if (tmp___34 == 0UL) {
#line 227
                            tmp___27 = is_digits((char const   *)*(d->param + 0));
#line 227
                            if (tmp___27 == 0) {
#line 228
                              settings.max_unauth_time = atoi((char const   *)*(d->param + 0));
                            } else {
#line 230
                              logit("Syntax error on line %i in your configuration file, the parameter to max_unauth_time must be a digit!",
                                    d->line_no);
                            }
                          } else {
#line 233
                            tmp___33 = str_comp((char const   *)d->key, "max_auth_tries");
#line 233
                            if (tmp___33 == 0UL) {
#line 234
                              tmp___28 = is_digits((char const   *)*(d->param + 0));
#line 234
                              if (tmp___28 == 0) {
#line 235
                                settings.max_auth_tries = atoi((char const   *)*(d->param + 0));
                              } else {
#line 237
                                logit("Syntax error on line %i in your configuration file, the parameter to max_auth_tries must be a digits!",
                                      d->line_no);
                              }
                            } else {
#line 240
                              tmp___32 = str_comp((char const   *)d->key, "cli_pingsend");
#line 240
                              if (tmp___32 == 0UL) {
#line 241
                                tmp___29 = is_digits((char const   *)*(d->param + 0));
#line 241
                                if (tmp___29 == 0) {
#line 242
                                  settings.cli_pingsend = atoi((char const   *)*(d->param + 0));
                                } else {
#line 244
                                  logit("Syntax error on line %i in your configuration file, the parameter to cli-pingsend must be a digit!",
                                        d->line_no);
                                }
                              } else {
#line 247
                                tmp___31 = str_comp((char const   *)d->key, "cli_pingtimeout");
#line 247
                                if (tmp___31 == 0UL) {
#line 248
                                  tmp___30 = is_digits((char const   *)*(d->param + 0));
#line 248
                                  if (tmp___30 == 0) {
#line 249
                                    settings.cli_pingtimeout = atoi((char const   *)*(d->param + 0));
                                  } else {
#line 251
                                    logit("Syntax error on line %i in your configuration file, the parameter to cli-pingtimeout must be a digit!",
                                          d->line_no);
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
    __Cont: /* CIL Label */ 
#line 99
    if ((unsigned long )d != (unsigned long )((void *)0)) {
#line 99
      if ((unsigned long )d->next != (unsigned long )((void *)0)) {
#line 99
        d = d->next;
#line 99
        if (! d) {
#line 99
          break;
        }
      } else {
#line 99
        break;
      }
    } else {
#line 99
      break;
    }
  }
#line 257
  if (have_auth_user == 0) {
#line 258
    sysexit("You have not configured auth_user and/or auth_pass in your configuration file!");
  } else
#line 257
  if (have_auth_pass == 0) {
#line 258
    sysexit("You have not configured auth_user and/or auth_pass in your configuration file!");
  }
#line 260
  if (have_server == 0) {
#line 261
    sysexit("You have not configured any server in your configuration file!");
  }
#line 263
  if (have_nickname == 0) {
#line 264
    sysexit("You have not configured the nickname to use in the configuration file!");
  }
#line 266
  if (have_listen_addr == 0) {
#line 267
    sysexit("No addresses specified to listen on in your configfile!");
  }
#line 269
  if (have_username == 0) {
#line 270
    tmp___46 = getuid();
#line 270
    getusername(tmp___46, settings.username, sizeof(settings.username) - sizeof(char ));
  }
#line 272
  if (have_realname == 0) {
#line 273
    tmp___47 = getuid();
#line 273
    getrealname(tmp___47, settings.realname, sizeof(settings.realname) - sizeof(char ));
  }
#line 275
  if (settings.cli_pingsend == 0) {
#line 276
    settings.cli_pingsend = 600;
  }
#line 278
  if (settings.cli_pingtimeout == 0) {
#line 279
    settings.cli_pingtimeout = 1200;
  } else
#line 281
  if (settings.cli_pingtimeout < settings.cli_pingsend) {
#line 282
    settings.cli_pingtimeout += settings.cli_pingsend;
  }
#line 284
  if (settings.max_unauth_time == 0) {
#line 285
    settings.max_unauth_time = 60;
  }
#line 287
  if (settings.max_auth_tries == 0) {
#line 288
    settings.max_auth_tries = 3;
  }
#line 290
  fclose(f);
#line 291
  oz_conffree(c);
#line 292
  return;
}
}
#line 1 "main.o"
#pragma merger("0","/tmp/cil-b15bR5oW.i","-Wall,-O3")
#line 244 "/usr/include/x86_64-linux-gnu/sys/socket.h"
extern int accept(int __fd , struct sockaddr * __restrict  __addr , socklen_t * __restrict  __addr_len ) ;
#line 232 "/usr/include/pthread.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,3))) pthread_create)(pthread_t * __restrict  __newthread ,
                                                                                             pthread_attr_t const   * __restrict  __attr ,
                                                                                             void *(*__start_routine)(void * ) ,
                                                                                             void * __restrict  __arg ) ;
#line 740
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) pthread_mutex_init)(pthread_mutex_t *__mutex ,
                                                                                                         pthread_mutexattr_t const   *__mutexattr ) ;
#line 700 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) __uid_t ( __attribute__((__leaf__)) geteuid)(void) ;
#line 151 "/usr/include/getopt.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) getopt)(int ___argc ,
                                                                             char * const  *___argv ,
                                                                             char const   *__shortopts ) ;
#line 102 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) __sighandler_t ( __attribute__((__leaf__)) signal)(int __sig ,
                                                                                        void (*__handler)(int  ) ) ;
#line 170 "supervixen.h"
unsigned int curconn ;
#line 171
time_t startuptime ;
#line 179
void sp_irc_servconn(tthreads *thread ) ;
#line 189
void process_args(int const   argc , char const   **argv ) ;
#line 190
void show_usage(char const   *progname ) ;
#line 192
int thread_register(int kind ) ;
#line 194
void thread_unregister(int id ) ;
#line 195
int commands_init(void) ;
#line 205
int sp_lcache_init(void) ;
#line 214
int sp_handle_servconn(tthreads *thread ) ;
#line 216
void sp_sleep(void) ;
#line 218
void sp_management(tthreads *thread ) ;
#line 64 "main.c"
unsigned int syslog_on  =    0U;
#line 65 "main.c"
unsigned int consolelog_on  =    1U;
#line 66 "main.c"
unsigned int logtime_on  =    1U;
#line 67 "main.c"
unsigned int oz_readmax  =    20000U;
#line 69 "main.c"
unsigned int curconn  =    0U;
#line 70 "main.c"
unsigned int servers_cnt  =    0U;
#line 71 "main.c"
unsigned int listen_socks_no  =    0U;
#line 72 "main.c"
time_t startuptime  =    (time_t )0;
#line 74 "main.c"
int main(int argc , char const   **argv , char const   **envp ) 
{ 
  int new_fd ;
  int rev ;
  int i ;
  __uid_t tmp ;
  __uid_t tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  int *tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;
  char *tmp___7 ;
  int tmp___8 ;
  char *tmp___9 ;
  int tmp___10 ;
  int *tmp___11 ;
  char *tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int *tmp___15 ;
  char *tmp___16 ;
  char *tmp___17 ;

  {
#line 75
  new_fd = 0;
#line 76
  rev = 0;
#line 77
  i = 0;
#line 80
  tmp = getuid();
#line 80
  if (tmp == 0U) {
#line 81
    sysexit("Fatal error: I will *NOT* run as root!");
  } else {
#line 80
    tmp___0 = geteuid();
#line 80
    if (tmp___0 == 0U) {
#line 81
      sysexit("Fatal error: I will *NOT* run as root!");
    }
  }
#line 84
  memset((void *)(& settings), '\000', sizeof(settings));
#line 85
  settings.version = (char *)"0.7";
#line 88
  signal(13, (void (*)(int  ))1);
#line 91
  pthread_mutex_init(& threads_lock, (pthread_mutexattr_t const   *)((void *)0));
#line 92
  pthread_mutex_init(& lcache_lock, (pthread_mutexattr_t const   *)((void *)0));
#line 93
  pthread_mutex_init(& channels_lock, (pthread_mutexattr_t const   *)((void *)0));
#line 94
  pthread_mutex_init(& commands_lock, (pthread_mutexattr_t const   *)((void *)0));
#line 97
  i = 0;
#line 97
  while (i < 100) {
#line 98
    threads[i].id = -1;
#line 97
    i ++;
  }
#line 100
  i = 0;
#line 100
  while (i < 50) {
#line 101
    memset((void *)(servers[i].address), '\000', sizeof(servers[i].address));
#line 102
    servers[i].port = 0;
#line 100
    i ++;
  }
#line 105
  i = 0;
#line 105
  while (i < 500) {
#line 106
    channels[i] = (char *)((void *)0);
#line 105
    i ++;
  }
#line 109
  tmp___3 = commands_init();
#line 109
  if (tmp___3 != 0) {
#line 110
    tmp___1 = __errno_location();
#line 110
    tmp___2 = strerror(*tmp___1);
#line 110
    sysexit("Initialization of the command-queue system failed; %s.", tmp___2);
  }
#line 113
  startuptime = time((time_t *)((void *)0));
#line 116
  tmp___6 = sp_lcache_init();
#line 116
  if (tmp___6 == -1) {
#line 117
    tmp___4 = __errno_location();
#line 117
    tmp___5 = strerror(*tmp___4);
#line 117
    sysexit("Failed to allocate memory, error=%s.", tmp___5);
  }
#line 120
  sp_parse_config();
#line 123
  process_args((int const   )argc, argv);
#line 126
  i = thread_register(1);
#line 128
  if (i == -1) {
#line 129
    sysexit("Main: The IRC server-connection thread could not be started, too many threads running!");
  } else {
#line 132
    tmp___8 = pthread_create((pthread_t * __restrict  )(& threads[i].thread), (pthread_attr_t const   * __restrict  )((void *)0),
                             (void *(*)(void * ))((void *)(& sp_irc_servconn)), (void * __restrict  )(& threads[i]));
#line 132
    if (tmp___8 != 0) {
#line 133
      tmp___7 = strerror(rev);
#line 133
      sysexit("Main: The IRC server-connection thread could not be started, error=%s",
              tmp___7);
    }
  }
#line 137
  i = thread_register(3);
#line 139
  if (i == -1) {
#line 140
    sysexit("Main: The management thread could not be started, too many threads running!");
  } else {
#line 143
    tmp___10 = pthread_create((pthread_t * __restrict  )(& threads[i].thread), (pthread_attr_t const   * __restrict  )((void *)0),
                              (void *(*)(void * ))((void *)(& sp_management)), (void * __restrict  )(& threads[i]));
#line 143
    if (tmp___10 != 0) {
#line 144
      tmp___9 = strerror(rev);
#line 144
      sysexit("Main: The management thread could not be started, error=%s.", tmp___9);
    }
  }
#line 148
  i = 0;
#line 148
  while ((unsigned int )i < listen_socks_no) {
#line 149
    tmp___13 = oz_listen(& (listen_socks + i)->sockfd, 1, (int )(listen_socks + i)->port,
                         (char const   *)((listen_socks + i)->address));
#line 149
    if (tmp___13 == -1) {
#line 150
      tmp___11 = __errno_location();
#line 150
      tmp___12 = strerror(*tmp___11);
#line 150
      logit("Could not listen on address=%s:%i, error=%s.", (listen_socks + i)->address,
            (listen_socks + i)->port, tmp___12);
#line 151
      (listen_socks + i)->sockfd = -1;
    } else {
#line 155
      logit("SuperVixen listening on address=%s:%i.", (listen_socks + i)->address,
            (listen_socks + i)->port);
    }
#line 148
    i ++;
  }
#line 159
  logit("SuperVixen up!");
#line 161
  while (1) {
#line 162
    new_fd = -2;
#line 164
    i = 0;
#line 164
    while ((unsigned int )i < listen_socks_no) {
#line 165
      if ((listen_socks + i)->sockfd == -1) {
#line 166
        goto __Cont;
      }
#line 168
      tmp___14 = oz_isdatawaiting(& (listen_socks + i)->sockfd);
#line 168
      if (tmp___14 == 1) {
#line 169
        new_fd = accept((listen_socks + i)->sockfd, (struct sockaddr * __restrict  )((void *)0),
                        (socklen_t * __restrict  )((void *)0));
#line 170
        break;
      }
      __Cont: /* CIL Label */ 
#line 164
      i ++;
    }
#line 174
    if (! (new_fd == -2)) {
#line 176
      if (new_fd == -1) {
#line 177
        tmp___15 = __errno_location();
#line 177
        tmp___16 = strerror(*tmp___15);
#line 177
        logit("Server: .. could not accept connection, error=%s.", tmp___16);
      } else {
#line 181
        logit("Server: Got connection ..");
#line 183
        i = thread_register(0);
#line 185
        if (i == -1) {
#line 187
          logit("Server: .. could not find free slot for new thread, error=Too many threads running!");
#line 188
          oz_writefl(& new_fd, ":%s 372 Anon :Too may clients are currently connected to this server, disconnecting!",
                     settings.hostname);
#line 189
          close(new_fd);
        } else {
#line 194
          threads[i].sockfd = new_fd;
#line 195
          rev = pthread_create((pthread_t * __restrict  )(& threads[i].thread), (pthread_attr_t const   * __restrict  )((void *)0),
                               (void *(*)(void * ))((void *)(& sp_handle_servconn)),
                               (void * __restrict  )(& threads[i]));
#line 197
          if (rev != 0) {
#line 199
            oz_writefl(& new_fd, ":%s 372 Anon: Unable to create thread.", settings.hostname);
#line 200
            tmp___17 = strerror(rev);
#line 200
            logit("Server: .. could not create a new thread, error=%s.", tmp___17);
#line 201
            close(new_fd);
#line 202
            thread_unregister(i);
          } else {
#line 206
            curconn ++;
          }
        }
      }
    }
#line 210
    sp_sleep();
  }
#line 213
  return (0);
}
}
#line 216 "main.c"
void process_args(int const   argc , char const   **argv ) 
{ 
  int flag ;
  char const   *args ;

  {
#line 218
  args = "vh";
#line 220
  while (1) {
#line 220
    flag = getopt((int )argc, (char * const  *)((char **)argv), args);
#line 220
    if (! (flag != -1)) {
#line 220
      break;
    }
#line 221
    switch (flag) {
    case 104: 
#line 223
    show_usage(*(argv + 0));
#line 224
    exit(0);
#line 225
    break;
    case 118: 
#line 228
    textout("This is SuperVixen version %s !", settings.version);
#line 229
    exit(0);
#line 230
    break;
    }
  }
#line 233
  return;
}
}
#line 235 "main.c"
void show_usage(char const   *progname ) 
{ 


  {
#line 236
  textout("Usage: %s [ -v ] [ -h ]", progname);
#line 237
  textout("\t -v\t Show version info");
#line 238
  textout("\t -h\t Show this help");
#line 239
  textout("");
#line 240
  textout("#########");
#line 242
  textout("No other options are available. ");
#line 243
  textout("The configfile is located in ~/.supervixenrc or .supervixenrc\n");
#line 245
  textout("The options available there are: ");
#line 246
  textout("");
#line 247
  textout("\tnickname\t\t[nickname]\t\tSpecify the nickname to use. (required)");
#line 248
  textout("\tlisten\t\t\t[address] [port]\tSpecify a address and a port to listen on. (required & multiple supported)");
#line 249
  textout("\tusername\t\t[username]\t\tThe username to show the IRC server. (optional)");
#line 250
  textout("\trealname\t\t[realname]\t\tThe realname to show the IRC server. (optional)");
#line 251
  textout("\tauth_user\t\t[username]\t\tThe valid username which is used when clients try to authenticate. (required)");
#line 252
  textout("\tauth_pass\t\t[password]\t\tThe valid password which is used when clients try to authenticate. (required)");
#line 253
  textout("\tserver\t\t\t[server] [port]\t\tA server record, which is used when trying to connect to a server, you can specify more than one. (one required)");
#line 254
  textout("\tmax_unauth_time\t\t[seconds]\t\tThe time which a client may be connected to the server without being authenticated, default is 60 seconds.");
#line 255
  textout("\tmax_auth_tries\t\t[seconds]\t\tThe number of attempts that a client may use to authenticate it self, default is 3.");
#line 256
  textout("\tsyslog\t\t\t[on|off]\t\tSpecify if the program should log to syslog. (default off)");
#line 257
  textout("\tconsolelog\t\t[on|off]\t\tSpecify if the program should log to console. (default on)");
#line 258
  textout("\tlogtime\t\t\t[on|off]\t\tSpecify if the program should timestamp the messages to console. (default on)");
#line 259
  textout("\tcli_pingsend\t\t[seconds]\t\tSpecify how long time may pass between a IRC server message and till we send a PING (default 600)");
#line 260
  textout("\tcli_pingtimeout\t\t[seconds]\t\t--  and till it\'s declaired stoned and we disconnect and try another server. (default 1200)");
#line 262
  textout("");
#line 263
  textout("When clients connect, they must authenticate like this: PASS auth_user auth_pass, if the check failes, the client is disconnected, else shown the connection info.");
#line 264
  textout("#########");
#line 265
  textout("");
#line 267
  textout("Bug reports should go to gdh@binhex.EU.org.");
#line 268
  textout("Reports regarding security and other related should be encrypted ");
#line 269
  textout("with PGP key ADD4C933, available at the next keyserver, or at http://vlug.eyjar.is/gdh/gpgkey.asc");
#line 270
  textout("");
#line 271
  return;
}
}
#line 1 "server.o"
#pragma merger("0","/tmp/cil-enBbCPHv.i","-Wall,-O3")
#line 241 "/usr/include/pthread.h"
extern  __attribute__((__noreturn__)) void pthread_exit(void *__retval ) ;
#line 270
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) pthread_detach)(pthread_t __th ) ;
#line 274
extern  __attribute__((__nothrow__)) pthread_t ( __attribute__((__leaf__)) pthread_self)(void)  __attribute__((__const__)) ;
#line 628 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) __pid_t ( __attribute__((__leaf__)) getpid)(void) ;
#line 183 "supervixen.h"
int sp_verifyuser(char const   *txt ) ;
#line 197
void commands_groupmsg(int kind , int from , int cmdid , void *param1 , void *param2 ,
                       void *param3 , void *param4 ) ;
#line 199
int commands_fetch(int id , tcommands *command ) ;
#line 201
int queue_add_globalmessage(int kind , int from , char const   *txt ) ;
#line 202
int queue_add_fmessage(int global , int dest , int from , char *format  , ...) ;
#line 203
int queue_fetchmessages(int id , int *sockfd ) ;
#line 208
int sp_lcache_fetch(int *sockfd ) ;
#line 211
int cache_spitchannels(int id , int *sockfd ) ;
#line 23 "server.c"
int sp_handle_servconn(tthreads *thread ) 
{ 
  int rev ;
  int sysrev ;
  int *sockfd ;
  int authenticated ;
  int data_waiting ;
  int auth_tries ;
  size_t fbuffer_size ;
  time_t connect_time ;
  char *buf ;
  char *fbuffer ;
  tcommands command ;
  pthread_t tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  size_t tmp___6 ;
  size_t tmp___7 ;
  time_t tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  size_t tmp___11 ;
  size_t tmp___12 ;
  size_t tmp___13 ;
  size_t tmp___14 ;
  void *tmp___15 ;
  int *tmp___16 ;
  char *tmp___17 ;
  size_t tmp___18 ;
  size_t tmp___19 ;
  size_t tmp___20 ;
  size_t tmp___21 ;
  size_t tmp___22 ;
  size_t tmp___23 ;
  size_t tmp___24 ;
  size_t tmp___25 ;
  size_t tmp___26 ;
  size_t tmp___27 ;
  size_t tmp___28 ;
  int *tmp___29 ;
  char *tmp___30 ;
  time_t tmp___31 ;
  int *tmp___32 ;
  char *tmp___33 ;
  int *tmp___34 ;
  char *tmp___35 ;
  int tmp___36 ;

  {
#line 24
  rev = 0;
#line 25
  sysrev = 0;
#line 26
  sockfd = (int *)((void *)0);
#line 27
  authenticated = 0;
#line 28
  data_waiting = 0;
#line 29
  auth_tries = 0;
#line 30
  fbuffer_size = (size_t )0;
#line 31
  connect_time = (time_t )0;
#line 37
  tmp = pthread_self();
#line 37
  pthread_detach(tmp);
#line 38
  thread->pid = getpid();
#line 39
  sockfd = & thread->sockfd;
#line 40
  connect_time = time((time_t *)((void *)0));
#line 42
  logit("Server: .. connection accepted!");
#line 44
  tmp___1 = oz_readinit(& buf);
#line 44
  if (tmp___1 != 0) {
#line 45
    sysrev = -1;
  } else {
#line 48
    tmp___0 = oz_writefl(sockfd, ":%s 372 Anon :This is SuperVixen %s, authenticate please.",
                         settings.hostname, settings.version);
#line 48
    sysrev -= tmp___0;
  }
#line 51
  while (1) {
#line 51
    if (sysrev == 0) {
#line 51
      if (authenticated == 0) {
#line 51
        tmp___8 = time((time_t *)((void *)0));
#line 51
        if (tmp___8 < connect_time + (time_t )settings.max_unauth_time) {
#line 51
          if (! (auth_tries < settings.max_auth_tries)) {
#line 51
            break;
          }
        } else {
#line 51
          break;
        }
      } else {
#line 51
        break;
      }
    } else {
#line 51
      break;
    }
#line 52
    data_waiting = oz_isdatawaiting(sockfd);
#line 55
    if (data_waiting == 0) {
#line 56
      sp_sleep();
#line 57
      continue;
    } else
#line 61
    if (data_waiting != 1) {
#line 62
      sysrev = -1;
#line 63
      break;
    }
#line 66
    sysrev = oz_read(sockfd, & buf, (char const   )'\n');
#line 69
    if (sysrev == 0) {
#line 69
      tmp___7 = strn_comp((char const   *)buf, "PASS ");
#line 69
      if (tmp___7 == 0UL) {
#line 70
        rev = sp_verifyuser((char const   *)buf);
#line 72
        if (rev == 1) {
#line 73
          authenticated = 1;
#line 74
          logit("Server: Sucessfully authenticated client!");
#line 76
          tmp___2 = oz_writefl(sockfd, ":%s 372 %s :Login correct. Welcome... ", settings.hostname,
                               settings.nickname);
#line 76
          sysrev -= tmp___2;
#line 77
          tmp___3 = oz_writefl(sockfd, ":%s 372 %s :Your host is SuperVixen, faking version 2.10.3p3 of IRCd.",
                               settings.hostname, settings.nickname);
#line 77
          sysrev -= tmp___3;
#line 79
          tmp___4 = sp_lcache_fetch(sockfd);
#line 79
          sysrev -= tmp___4;
#line 80
          queue_add_globalmessage(1, thread->id, "MOTD");
#line 82
          cache_spitchannels(thread->id, sockfd);
        } else
#line 85
        if (rev == 0) {
#line 86
          logit("Server: .. authentication failure!");
#line 87
          tmp___5 = oz_writefl(sockfd, ":%s 372 Anon :Login incorrect!", settings.hostname);
#line 87
          sysrev -= tmp___5;
        }
#line 90
        auth_tries ++;
      } else {
#line 69
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 93
    if (sysrev == 0) {
#line 93
      tmp___6 = strn_comp((char const   *)buf, "QUIT");
#line 93
      if (tmp___6 == 0UL) {
#line 94
        break;
      }
    }
  }
#line 100
  while (1) {
#line 100
    if (sysrev == 0) {
#line 100
      if (! (authenticated == 1)) {
#line 100
        break;
      }
    } else {
#line 100
      break;
    }
#line 102
    tmp___9 = queue_fetchmessages(thread->id, sockfd);
#line 102
    sysrev -= tmp___9;
#line 105
    while (1) {
#line 105
      tmp___10 = commands_fetch(thread->id, & command);
#line 105
      if (! (tmp___10 == 0)) {
#line 105
        break;
      }
#line 106
      logit("Server: Got a command through the command-queue, but we don\'t support it! to=%i, from=%i.",
            command.id, command.from);
    }
#line 108
    data_waiting = oz_isdatawaiting(sockfd);
#line 111
    if (sysrev != 0) {
#line 112
      sysrev = -1;
#line 113
      break;
    } else
#line 111
    if (data_waiting != 1) {
#line 111
      if (data_waiting != 0) {
#line 112
        sysrev = -1;
#line 113
        break;
      }
    }
#line 116
    if (data_waiting == 0) {
#line 117
      sp_sleep();
#line 118
      continue;
    }
#line 121
    sysrev = oz_read(sockfd, & buf, (char const   )'\n');
#line 124
    tmp___28 = strn_comp((char const   *)buf, "PONG ");
#line 124
    if (! (tmp___28 == 0UL)) {
#line 128
      tmp___27 = strn_comp((char const   *)buf, "PING ");
#line 128
      if (tmp___27 == 0UL) {
#line 129
        sysrev = oz_writefl(sockfd, "PONG :%s", settings.hostname);
      } else {
#line 131
        tmp___26 = strn_comp((char const   *)buf, "USER ");
#line 131
        if (tmp___26 == 0UL) {
#line 132
          sysrev = oz_writefl(sockfd, ":%s 372 %s :Already authenticated.", settings.hostname,
                              settings.nickname);
        } else {
#line 134
          tmp___25 = strn_comp((char const   *)buf, "QUIT");
#line 134
          if (tmp___25 == 0UL) {
#line 136
            sysrev = oz_writel(sockfd, "ERROR :Closing Link: Requested.");
#line 137
            break;
          } else {
#line 140
            tmp___24 = strn_comp((char const   *)buf, "SPINFO");
#line 140
            if (tmp___24 == 0UL) {
#line 140
              if (authenticated) {
#line 141
                commands_groupmsg(3, thread->id, 1, (void *)0, (void *)0, (void *)0,
                                  (void *)0);
              } else {
#line 140
                goto _L___5;
              }
            } else {
              _L___5: /* CIL Label */ 
#line 143
              tmp___23 = strn_comp((char const   *)buf, "SPDIE");
#line 143
              if (tmp___23 == 0UL) {
#line 143
                if (authenticated) {
#line 144
                  commands_groupmsg(3, thread->id, 3, (void *)0, (void *)0, (void *)0,
                                    (void *)0);
                } else {
#line 143
                  goto _L___4;
                }
              } else {
                _L___4: /* CIL Label */ 
#line 146
                tmp___22 = strn_comp((char const   *)buf, "SPVERSION");
#line 146
                if (tmp___22 == 0UL) {
#line 146
                  if (authenticated) {
#line 147
                    commands_groupmsg(3, thread->id, 4, (void *)0, (void *)0, (void *)0,
                                      (void *)0);
                  } else {
#line 146
                    goto _L___3;
                  }
                } else {
                  _L___3: /* CIL Label */ 
#line 149
                  tmp___21 = strn_comp((char const   *)buf, "SPHELP");
#line 149
                  if (tmp___21 == 0UL) {
#line 149
                    if (authenticated) {
#line 150
                      commands_groupmsg(3, thread->id, 5, (void *)0, (void *)0, (void *)0,
                                        (void *)0);
                    } else {
#line 149
                      goto _L___2;
                    }
                  } else {
                    _L___2: /* CIL Label */ 
#line 152
                    tmp___20 = strn_comp((char const   *)buf, "SPTHREADS");
#line 152
                    if (tmp___20 == 0UL) {
#line 152
                      if (authenticated) {
#line 153
                        commands_groupmsg(3, thread->id, 7, (void *)0, (void *)0,
                                          (void *)0, (void *)0);
                      } else {
#line 152
                        goto _L___1;
                      }
                    } else {
                      _L___1: /* CIL Label */ 
#line 155
                      tmp___19 = strn_comp((char const   *)buf, "SPDISCONNECT");
#line 155
                      if (tmp___19 == 0UL) {
#line 155
                        if (authenticated) {
#line 156
                          logit("Client: Disconnecting from server by user request!");
#line 157
                          queue_add_fmessage(1, 0, thread->id, (char *)"Disconnecting from server by user request!");
#line 158
                          commands_groupmsg(1, thread->id, 2, (void *)0, (void *)0,
                                            (void *)0, (void *)0);
                        } else {
#line 155
                          goto _L___0;
                        }
                      } else {
                        _L___0: /* CIL Label */ 
#line 161
                        tmp___18 = strn_comp((char const   *)buf, "PRIVMSG #");
#line 161
                        if (tmp___18 == 0UL) {
#line 161
                          if (authenticated) {
#line 163
                            queue_add_globalmessage(1, thread->id, (char const   *)buf);
#line 166
                            tmp___11 = strlen((char const   *)(settings.nickname));
#line 166
                            tmp___12 = strlen((char const   *)(settings.username));
#line 166
                            tmp___13 = strlen((char const   *)(settings.fake_hostname));
#line 166
                            tmp___14 = strlen((char const   *)buf);
#line 166
                            fbuffer_size = ((((tmp___11 + tmp___12) + tmp___13) + tmp___14) + 30UL) * sizeof(char );
#line 167
                            tmp___15 = malloc(fbuffer_size);
#line 167
                            fbuffer = (char *)tmp___15;
#line 169
                            if ((unsigned long )fbuffer == (unsigned long )((void *)0)) {
#line 170
                              tmp___16 = __errno_location();
#line 170
                              tmp___17 = strerror(*tmp___16);
#line 170
                              logit("Server: Could not allocate memory for buffer, privmsg lost, error=%s.",
                                    tmp___17);
                            } else {
#line 173
                              snprintf((char * __restrict  )fbuffer, fbuffer_size,
                                       (char const   * __restrict  )":%s!%s@%s %s",
                                       settings.nickname, settings.username, settings.fake_hostname,
                                       buf);
#line 174
                              queue_add_globalmessage(0, thread->id, (char const   *)fbuffer);
#line 176
                              free((void *)fbuffer);
                            }
                          } else {
#line 181
                            queue_add_globalmessage(1, thread->id, (char const   *)buf);
                          }
                        } else {
#line 181
                          queue_add_globalmessage(1, thread->id, (char const   *)buf);
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
#line 183
    sp_sleep();
  }
#line 187
  if (authenticated == 0) {
#line 187
    tmp___31 = time((time_t *)((void *)0));
#line 187
    if (tmp___31 >= connect_time + (time_t )settings.max_unauth_time) {
#line 188
      logit("Server: Disconnecting unauthenticated client, authentication time timed out.");
#line 189
      oz_writefl(sockfd, ":%s 372 Anon :You have been connected for too long without being authenticated, closing connection.",
                 settings.hostname);
    } else {
#line 187
      goto _L___8;
    }
  } else
  _L___8: /* CIL Label */ 
#line 192
  if (authenticated == 0) {
#line 192
    if (auth_tries >= settings.max_auth_tries) {
#line 193
      logit("Server: Disconnecting unauthenticated client, maximum authentication retry limit reached.");
#line 194
      oz_writefl(sockfd, ":%s 372 Anon: Too many authentication retries, closing connection.",
                 settings.hostname);
    } else {
#line 192
      goto _L___7;
    }
  } else
  _L___7: /* CIL Label */ 
#line 197
  if (authenticated == 0) {
#line 197
    if (sysrev != 0) {
#line 198
      tmp___29 = __errno_location();
#line 198
      tmp___30 = strerror(*tmp___29);
#line 198
      logit("Server: Disconnecting client from authentication loop, system error occured=%s.",
            tmp___30);
#line 199
      oz_writefl(sockfd, ":%s 372 Anon: Disconnecting due to system error!", settings.hostname);
    } else {
#line 197
      goto _L___6;
    }
  } else
  _L___6: /* CIL Label */ 
#line 202
  if (authenticated == 0) {
#line 203
    logit("Server: Disconnecting client, due to request!");
  }
#line 206
  if (authenticated == 1) {
#line 206
    if (sysrev != 0) {
#line 207
      tmp___32 = __errno_location();
#line 207
      tmp___33 = strerror(*tmp___32);
#line 207
      logit("Server: Disconnecting client due to system error; %s.", tmp___33);
#line 208
      tmp___34 = __errno_location();
#line 208
      tmp___35 = strerror(*tmp___34);
#line 208
      tmp___36 = oz_writefl(sockfd, ":%s 372 %s :Disconnecting you due to system error=%s.",
                            settings.hostname, settings.nickname, tmp___35);
#line 208
      sysrev -= tmp___36;
    } else {
#line 206
      goto _L___9;
    }
  } else
  _L___9: /* CIL Label */ 
#line 211
  if (authenticated == 1) {
#line 212
    logit("Server: Disconnecting client due to request!");
  }
#line 216
  oz_readend(& buf);
#line 217
  oz_close(sockfd);
#line 218
  curconn --;
#line 219
  thread_unregister(thread->id);
#line 220
  pthread_exit((void *)0);
}
}
#line 1 "client.o"
#pragma merger("0","/tmp/cil-c_aU6gJb.i","-Wall,-O3")
#line 444 "/usr/include/unistd.h"
extern unsigned int sleep(unsigned int __seconds ) ;
#line 185 "supervixen.h"
void sp_parse_server_msg(irc_actions *ic , char *txt ) ;
#line 186
char **sp_ircsplit(char const   *str ) ;
#line 187
void sp_ircsplit_end(char **str ) ;
#line 204
char *queue_fetchmessagess(int id ) ;
#line 206
int sp_lcache(char const   *line ) ;
#line 207
void sp_lcache_flush(void) ;
#line 209
int cache_addchannel(char const   *chan ) ;
#line 210
void cache_delchannel(char const   *chan ) ;
#line 212
int cache_chan_reconnect(int *sockfd ) ;
#line 23 "client.c"
static void sp_irc_handlenick(char const   *ostr ) 
{ 
  char **split ;
  char **str ;
  int strback ;
  int splitback ;
  int *tmp ;
  char *tmp___0 ;
  size_t tmp___1 ;

  {
#line 26
  strback = 0;
#line 26
  splitback = 0;
#line 29
  str = oz_splitmsg(ostr);
#line 31
  if ((unsigned long )str == (unsigned long )((void *)0)) {
#line 32
    logit("WARNING: SuperVixen was unable to allocate memory, some things may be wrong!");
#line 32
    return;
  }
#line 34
  split = sp_ircsplit((char const   *)*(str + 0));
#line 36
  if ((unsigned long )split == (unsigned long )((void *)0)) {
#line 37
    tmp = __errno_location();
#line 37
    tmp___0 = strerror(*tmp);
#line 37
    logit("Client: Could not allocate memory while parsing nick change string from server, this could be a malformed string, error=%s.",
          tmp___0);
#line 38
    oz_splitfree(str);
#line 39
    return;
  } else
#line 42
  if ((unsigned long )*(str + 0) == (unsigned long )((void *)0)) {
#line 44
    logit("Client: Evil server detected, sp_irc_handlenick got incomplete parameters, the string is=%s",
          ostr);
#line 45
    sp_ircsplit_end(split);
#line 46
    oz_splitfree(str);
#line 47
    return;
  } else
#line 42
  if ((unsigned long )*(str + 1) == (unsigned long )((void *)0)) {
#line 44
    logit("Client: Evil server detected, sp_irc_handlenick got incomplete parameters, the string is=%s",
          ostr);
#line 45
    sp_ircsplit_end(split);
#line 46
    oz_splitfree(str);
#line 47
    return;
  } else
#line 42
  if ((unsigned long )*(str + 2) == (unsigned long )((void *)0)) {
#line 44
    logit("Client: Evil server detected, sp_irc_handlenick got incomplete parameters, the string is=%s",
          ostr);
#line 45
    sp_ircsplit_end(split);
#line 46
    oz_splitfree(str);
#line 47
    return;
  }
#line 51
  if ((int )*(*(split + 0) + 0) == 58) {
#line 52
    (*(split + 0)) ++;
#line 53
    splitback = 1;
  }
#line 56
  if ((int )*(*(str + 2) + 0) == 58) {
#line 57
    (*(str + 2)) ++;
#line 58
    strback = 1;
  }
#line 62
  tmp___1 = str_comp((char const   *)*(split + 0), (char const   *)(settings.nickname));
#line 62
  if (tmp___1 == 0UL) {
#line 64
    snprintf((char * __restrict  )(settings.nickname), sizeof(settings.nickname) - sizeof(char ),
             (char const   * __restrict  )"%s", *(str + 2));
#line 65
    sp_lcache(ostr);
  }
#line 68
  if (splitback == 1) {
#line 69
    (*(split + 0)) --;
  }
#line 71
  if (strback == 1) {
#line 72
    (*(str + 2)) --;
  }
#line 74
  sp_ircsplit_end(split);
#line 75
  oz_splitfree(str);
#line 76
  return;
}
}
#line 93 "client.c"
static int check_regline(char const   *str ) 
{ 
  size_t str_len ;
  size_t i ;
  int hostfound ;
  int atfound ;
  int markfound ;

  {
#line 94
  str_len = (size_t )0;
#line 95
  i = (size_t )0;
#line 96
  hostfound = 0;
#line 96
  atfound = 0;
#line 96
  markfound = 0;
#line 100
  str_len = strlen(str);
#line 102
  while (i < str_len) {
#line 103
    switch ((int const   )*(str + i)) {
    case 33: 
#line 105
    if (markfound == 1) {
#line 106
      markfound = 0;
    } else {
#line 108
      markfound = 1;
    }
#line 109
    break;
    case 64: 
#line 112
    if (atfound == 1) {
#line 113
      atfound = 0;
    } else {
#line 115
      atfound = 1;
    }
#line 116
    break;
    }
#line 119
    i ++;
  }
#line 122
  if ((int const   )*(str + str_len) != 64) {
#line 122
    if ((int const   )*(str + str_len) != 33) {
#line 123
      hostfound = 1;
    }
  }
#line 125
  if (markfound == 1) {
#line 125
    if (atfound == 1) {
#line 125
      if (hostfound == 1) {
#line 126
        return (0);
      } else {
#line 128
        return (-1);
      }
    } else {
#line 128
      return (-1);
    }
  } else {
#line 128
    return (-1);
  }
}
}
#line 152 "client.c"
static void sp_irc_handleregister(int *registerd , char const   *ostr ) 
{ 
  char **str ;
  char **split ;
  size_t i ;
  size_t foundparam ;
  int tmp ;
  int *tmp___0 ;
  char *tmp___1 ;

  {
#line 155
  i = (size_t )0;
#line 155
  foundparam = (size_t )0;
#line 157
  *registerd = 1;
#line 160
  str = oz_splitmsg(ostr);
#line 163
  if ((unsigned long )str == (unsigned long )((void *)0)) {
#line 164
    logit("WARNING: SuperVixen was unable to allocate memory, some things may be wrong!");
#line 164
    return;
  }
#line 167
  while ((unsigned long )*(str + i) != (unsigned long )((void *)0)) {
#line 168
    tmp = check_regline((char const   *)*(str + i));
#line 168
    if (tmp == 0) {
#line 170
      split = sp_ircsplit((char const   *)*(str + i));
#line 171
      foundparam = (size_t )1;
#line 172
      break;
    }
#line 175
    i ++;
  }
#line 179
  if (foundparam == 0UL) {
#line 180
    logit("WARNING: Could not find the correct nick!username@host string in the connection info, some things might be broken!");
#line 181
    oz_splitfree(str);
#line 182
    return;
  }
#line 185
  if ((unsigned long )split == (unsigned long )((void *)0)) {
#line 186
    tmp___0 = __errno_location();
#line 186
    tmp___1 = strerror(*tmp___0);
#line 186
    logit("Client: Could not allocate memory while parsing register string from server, error=%s.",
          tmp___1);
#line 187
    oz_splitfree(str);
#line 188
    return;
  }
#line 192
  snprintf((char * __restrict  )(settings.fake_hostname), sizeof(settings.fake_hostname) - sizeof(char ),
           (char const   * __restrict  )"%s", *(split + 2));
#line 194
  sp_ircsplit_end(split);
#line 195
  oz_splitfree(str);
#line 196
  return;
}
}
#line 212 "client.c"
static void sp_irc_handlepong(long *lastping , long *pingsent ) 
{ 


  {
#line 213
  *pingsent = 0L;
#line 214
  *lastping = time((time_t *)((void *)0));
#line 215
  return;
}
}
#line 238
static void sp_irc_handlenickinuse(int *sockfd , int *registerd ) ;
#line 238 "client.c"
static char lastchr  =    (char )'k';
#line 237 "client.c"
static void sp_irc_handlenickinuse(int *sockfd , int *registerd ) 
{ 
  size_t tmp ;

  {
#line 245
  if (*registerd == 1) {
#line 246
    return;
  }
#line 252
  switch ((int )lastchr) {
  case 95: 
#line 254
  lastchr = (char )'9';
#line 255
  break;
  case 57: 
#line 258
  lastchr = (char )'4';
#line 259
  break;
  case 52: 
#line 262
  lastchr = (char )'1';
#line 263
  break;
  case 49: 
#line 266
  lastchr = (char )'-';
#line 267
  break;
  case 45: 
#line 270
  lastchr = (char )'s';
#line 271
  break;
  case 115: 
#line 274
  lastchr = (char )'k';
#line 275
  break;
  case 107: 
#line 278
  lastchr = (char )'_';
#line 279
  break;
  }
#line 282
  tmp = strlen((char const   *)(settings.nickname));
#line 282
  settings.nickname[tmp - 1UL] = lastchr;
#line 284
  oz_writefl(sockfd, "NICK %s", & settings.nickname);
#line 285
  logit("Client: Nickname was in use, changed to=%s.", settings.nickname);
#line 286
  return;
}
}
#line 304 "client.c"
static void sp_irc_handlejpk(char const   *ostr ) 
{ 
  char **str ;
  char **split ;
  char *nickname ;
  char *channel ;
  int *tmp ;
  char *tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  size_t tmp___5 ;
  size_t tmp___6 ;

  {
#line 313
  str = oz_splitmsg(ostr);
#line 315
  if ((unsigned long )str == (unsigned long )((void *)0)) {
#line 316
    logit("WARNING: SuperVixen was unable to allocate memory, some things may be wrong!");
#line 316
    return;
  }
#line 318
  split = sp_ircsplit((char const   *)*(str + 0));
#line 320
  if ((unsigned long )split == (unsigned long )((void *)0)) {
#line 321
    tmp = __errno_location();
#line 321
    tmp___0 = strerror(*tmp);
#line 321
    logit("Client: Could not allocate memory while parsing join string from server, error=%s.",
          tmp___0);
#line 322
    oz_splitfree(str);
#line 323
    return;
  } else
#line 326
  if ((unsigned long )*(str + 0) == (unsigned long )((void *)0)) {
#line 328
    logit("Client: Evil server detected, sp_irc_handlejpk got incomplete parameters, the string is=%s",
          ostr);
#line 329
    oz_splitfree(str);
#line 330
    return;
  } else
#line 326
  if ((unsigned long )*(str + 1) == (unsigned long )((void *)0)) {
#line 328
    logit("Client: Evil server detected, sp_irc_handlejpk got incomplete parameters, the string is=%s",
          ostr);
#line 329
    oz_splitfree(str);
#line 330
    return;
  } else
#line 326
  if ((unsigned long )*(str + 2) == (unsigned long )((void *)0)) {
#line 328
    logit("Client: Evil server detected, sp_irc_handlejpk got incomplete parameters, the string is=%s",
          ostr);
#line 329
    oz_splitfree(str);
#line 330
    return;
  }
#line 333
  nickname = *(split + 0);
#line 334
  if ((int )*(nickname + 0) == 58) {
#line 335
    nickname ++;
  }
#line 337
  channel = *(str + 2);
#line 338
  if ((int )*(channel + 0) == 58) {
#line 339
    channel ++;
  }
#line 342
  tmp___3 = strn_comp((char const   *)*(str + 1), "KICK");
#line 342
  if (tmp___3 == 0UL) {
#line 343
    if ((unsigned long )*(str + 3) == (unsigned long )((void *)0)) {
#line 344
      sp_ircsplit_end(split);
#line 345
      oz_splitfree(str);
#line 346
      return;
    } else {
#line 343
      tmp___1 = str_comp((char const   *)(settings.nickname), (char const   *)*(str + 3));
#line 343
      if (tmp___1 != 0UL) {
#line 344
        sp_ircsplit_end(split);
#line 345
        oz_splitfree(str);
#line 346
        return;
      }
    }
  } else {
#line 351
    tmp___2 = str_comp((char const   *)(settings.nickname), (char const   *)nickname);
#line 351
    if (tmp___2 != 0UL) {
#line 352
      sp_ircsplit_end(split);
#line 353
      oz_splitfree(str);
#line 354
      return;
    }
  }
#line 361
  tmp___6 = strn_comp((char const   *)*(str + 1), "JOIN");
#line 361
  if (tmp___6 == 0UL) {
#line 362
    cache_addchannel((char const   *)channel);
  } else {
#line 366
    tmp___5 = strn_comp((char const   *)*(str + 1), "PART");
#line 366
    if (tmp___5 == 0UL) {
#line 367
      cache_delchannel((char const   *)channel);
    } else {
#line 371
      tmp___4 = strn_comp((char const   *)*(str + 1), "KICK");
#line 371
      if (tmp___4 == 0UL) {
#line 372
        cache_delchannel((char const   *)channel);
      }
    }
  }
#line 375
  sp_ircsplit_end(split);
#line 376
  oz_splitfree(str);
#line 377
  return;
}
}
#line 395 "client.c"
void sp_irc_servconn(tthreads *thread ) 
{ 
  int *sockfd ;
  int rev ;
  unsigned int c ;
  unsigned int curserver ;
  int pingsent ;
  int registerd ;
  time_t lastretry ;
  time_t lastping ;
  char *buf ;
  char *queue_buf ;
  char port[10] ;
  tcommands command ;
  irc_actions ic[19] ;
  pthread_t tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  int *tmp___2 ;
  time_t tmp___3 ;
  int *tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;
  size_t tmp___7 ;
  size_t tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  time_t tmp___11 ;
  time_t tmp___12 ;
  int *tmp___13 ;
  char *tmp___14 ;
  int *tmp___15 ;

  {
#line 397
  rev = 0;
#line 398
  c = 0U;
#line 399
  curserver = 0U;
#line 400
  pingsent = 0;
#line 401
  registerd = 0;
#line 402
  lastretry = (time_t )0;
#line 403
  lastping = (time_t )0;
#line 409
  ic[0].code = 251;
#line 409
  ic[0].handler = (void *)(& sp_lcache);
#line 409
  ic[0].param1 = (void *)buf;
#line 409
  ic[0].param2 = (void *)0;
#line 409
  ic[0].param3 = (void *)0;
#line 409
  ic[0].param4 = (void *)0;
#line 409
  ic[1].code = 252;
#line 409
  ic[1].handler = (void *)(& sp_lcache);
#line 409
  ic[1].param1 = (void *)buf;
#line 409
  ic[1].param2 = (void *)0;
#line 409
  ic[1].param3 = (void *)0;
#line 409
  ic[1].param4 = (void *)0;
#line 409
  ic[2].code = 254;
#line 409
  ic[2].handler = (void *)(& sp_lcache);
#line 409
  ic[2].param1 = (void *)buf;
#line 409
  ic[2].param2 = (void *)0;
#line 409
  ic[2].param3 = (void *)0;
#line 409
  ic[2].param4 = (void *)0;
#line 409
  ic[3].code = 255;
#line 409
  ic[3].handler = (void *)(& sp_lcache);
#line 409
  ic[3].param1 = (void *)buf;
#line 409
  ic[3].param2 = (void *)0;
#line 409
  ic[3].param3 = (void *)0;
#line 409
  ic[3].param4 = (void *)0;
#line 409
  ic[4].code = 265;
#line 409
  ic[4].handler = (void *)(& sp_lcache);
#line 409
  ic[4].param1 = (void *)buf;
#line 409
  ic[4].param2 = (void *)0;
#line 409
  ic[4].param3 = (void *)0;
#line 409
  ic[4].param4 = (void *)0;
#line 409
  ic[5].code = 266;
#line 409
  ic[5].handler = (void *)(& sp_lcache);
#line 409
  ic[5].param1 = (void *)buf;
#line 409
  ic[5].param2 = (void *)0;
#line 409
  ic[5].param3 = (void *)0;
#line 409
  ic[5].param4 = (void *)0;
#line 409
  ic[6].code = 1;
#line 409
  ic[6].handler = (void *)(& sp_lcache);
#line 409
  ic[6].param1 = (void *)buf;
#line 409
  ic[6].param2 = (void *)0;
#line 409
  ic[6].param3 = (void *)0;
#line 409
  ic[6].param4 = (void *)0;
#line 409
  ic[7].code = 2;
#line 409
  ic[7].handler = (void *)(& sp_lcache);
#line 409
  ic[7].param1 = (void *)buf;
#line 409
  ic[7].param2 = (void *)0;
#line 409
  ic[7].param3 = (void *)0;
#line 409
  ic[7].param4 = (void *)0;
#line 409
  ic[8].code = 3;
#line 409
  ic[8].handler = (void *)(& sp_lcache);
#line 409
  ic[8].param1 = (void *)buf;
#line 409
  ic[8].param2 = (void *)0;
#line 409
  ic[8].param3 = (void *)0;
#line 409
  ic[8].param4 = (void *)0;
#line 409
  ic[9].code = 4;
#line 409
  ic[9].handler = (void *)(& sp_lcache);
#line 409
  ic[9].param1 = (void *)buf;
#line 409
  ic[9].param2 = (void *)0;
#line 409
  ic[9].param3 = (void *)0;
#line 409
  ic[9].param4 = (void *)0;
#line 409
  ic[10].code = 1;
#line 409
  ic[10].handler = (void *)(& sp_irc_handleregister);
#line 409
  ic[10].param1 = (void *)(& registerd);
#line 409
  ic[10].param2 = (void *)buf;
#line 409
  ic[10].param3 = (void *)0;
#line 409
  ic[10].param4 = (void *)0;
#line 409
  ic[11].code = 1103;
#line 409
  ic[11].handler = (void *)(& sp_irc_handlenick);
#line 409
  ic[11].param1 = (void *)buf;
#line 409
  ic[11].param2 = (void *)0;
#line 409
  ic[11].param3 = (void *)0;
#line 409
  ic[11].param4 = (void *)0;
#line 409
  ic[12].code = 1104;
#line 409
  ic[12].handler = (void *)(& sp_irc_handlejpk);
#line 409
  ic[12].param1 = (void *)buf;
#line 409
  ic[12].param2 = (void *)0;
#line 409
  ic[12].param3 = (void *)0;
#line 409
  ic[12].param4 = (void *)0;
#line 409
  ic[13].code = 1106;
#line 409
  ic[13].handler = (void *)(& sp_irc_handlejpk);
#line 409
  ic[13].param1 = (void *)buf;
#line 409
  ic[13].param2 = (void *)0;
#line 409
  ic[13].param3 = (void *)0;
#line 409
  ic[13].param4 = (void *)0;
#line 409
  ic[14].code = 1105;
#line 409
  ic[14].handler = (void *)(& sp_irc_handlejpk);
#line 409
  ic[14].param1 = (void *)buf;
#line 409
  ic[14].param2 = (void *)0;
#line 409
  ic[14].param3 = (void *)0;
#line 409
  ic[14].param4 = (void *)0;
#line 409
  ic[15].code = 1101;
#line 409
  ic[15].handler = (void *)(& sp_irc_handlepong);
#line 409
  ic[15].param1 = (void *)(& lastping);
#line 409
  ic[15].param2 = (void *)(& pingsent);
#line 409
  ic[15].param3 = (void *)0;
#line 409
  ic[15].param4 = (void *)0;
#line 409
  ic[16].code = 433;
#line 409
  ic[16].handler = (void *)(& sp_irc_handlenickinuse);
#line 409
  ic[16].param1 = (void *)(& thread->sockfd);
#line 409
  ic[16].param2 = (void *)(& registerd);
#line 409
  ic[16].param3 = (void *)0;
#line 409
  ic[16].param4 = (void *)0;
#line 409
  ic[17].code = 1;
#line 409
  ic[17].handler = (void *)(& cache_chan_reconnect);
#line 409
  ic[17].param1 = (void *)(& thread->sockfd);
#line 409
  ic[17].param2 = (void *)0;
#line 409
  ic[17].param3 = (void *)0;
#line 409
  ic[17].param4 = (void *)0;
#line 409
  ic[18].code = -1;
#line 409
  ic[18].handler = (void *)0;
#line 409
  ic[18].param1 = (void *)0;
#line 409
  ic[18].param2 = (void *)0;
#line 409
  ic[18].param3 = (void *)0;
#line 409
  ic[18].param4 = (void *)0;
#line 431
  tmp = pthread_self();
#line 431
  pthread_detach(tmp);
#line 432
  thread->pid = getpid();
#line 433
  sockfd = & thread->sockfd;
#line 435
  oz_readinit(& buf);
#line 437
  if ((unsigned long )buf == (unsigned long )((void *)0)) {
#line 438
    tmp___0 = __errno_location();
#line 438
    tmp___1 = strerror(*tmp___0);
#line 438
    sysexit("Client: Unable to allocate memory for buffer, error=%s.", tmp___1);
  }
#line 440
  while (1) {
#line 445
    sp_lcache_flush();
#line 451
    while (1) {
#line 451
      queue_buf = queue_fetchmessagess(thread->id);
#line 451
      if (queue_buf) {
#line 451
        if (! ((unsigned long )queue_buf != (unsigned long )((void *)0))) {
#line 451
          break;
        }
      } else {
#line 451
        break;
      }
#line 452
      free((void *)queue_buf);
    }
#line 458
    pingsent = 0;
#line 459
    registerd = 0;
#line 460
    lastretry = time((time_t *)((void *)0));
#line 461
    lastping = time((time_t *)((void *)0));
#line 462
    tmp___2 = __errno_location();
#line 462
    *tmp___2 = 0;
#line 470
    if (curserver >= servers_cnt) {
#line 471
      tmp___3 = time((time_t *)((void *)0));
#line 471
      if (lastretry + 20L > tmp___3) {
#line 472
        logit("Client: All the servers are unavailable, sleeping for 30 seconds.");
#line 473
        queue_add_fmessage(1, 0, thread->id, (char *)"All servers unavailable, sleeping for 30 seconds.");
#line 475
        sleep(30U);
#line 476
        lastretry = time((time_t *)((void *)0));
      }
#line 479
      curserver = 0U;
    }
#line 487
    logit("Client: Connecting to %s:%i ... ", servers[curserver].address, servers[curserver].port);
#line 489
    snprintf((char * __restrict  )(port), sizeof(port) - sizeof(char ), (char const   * __restrict  )"%i",
             servers[curserver].port);
#line 492
    if (servers[curserver].port == 0) {
#line 493
      rev = oz_clisock(sockfd, (char const   *)(servers[curserver].address), (char *)((void *)0));
    } else {
#line 495
      rev = oz_clisock(sockfd, (char const   *)(servers[curserver].address), port);
    }
#line 497
    curserver ++;
#line 499
    if (rev == -1) {
#line 500
      tmp___4 = __errno_location();
#line 500
      tmp___5 = strerror(*tmp___4);
#line 500
      logit("Client: .. unable to connect to IRC server, error=%s.", tmp___5);
    } else
#line 502
    if (rev == -2) {
#line 503
      logit("Client: .. unable to resolve IRC server address!");
    } else {
#line 507
      logit("Client: .. connected!");
#line 509
      rev = oz_writefl(sockfd, "USER %s \"\" \"%s\" :%s", settings.username, settings.hostname,
                       settings.realname);
#line 510
      rev = oz_writefl(sockfd, "NICK %s", settings.nickname);
#line 513
      queue_add_fmessage(1, 0, thread->id, (char *)"Connected to %s:%i", servers[curserver - 1U].address,
                         servers[curserver - 1U].port);
#line 515
      while (rev == 0) {
#line 517
        while (rev == 0) {
#line 518
          tmp___6 = oz_isdatawaiting(sockfd);
#line 518
          if (tmp___6 == 0) {
#line 519
            break;
          }
#line 521
          rev = oz_read(sockfd, & buf, (char const   )'\n');
#line 523
          if (rev == -1) {
#line 524
            break;
          }
#line 532
          tmp___8 = strn_comp((char const   *)buf, "PING");
#line 532
          if (tmp___8 == 0UL) {
#line 533
            rev = oz_writefl(sockfd, "PONG :%s", & settings.hostname);
#line 535
            lastping = time((time_t *)((void *)0));
#line 536
            pingsent = 0;
          } else {
#line 539
            tmp___7 = strn_comp((char const   *)buf, "ERROR :Closing Link: ");
#line 539
            if (tmp___7 == 0UL) {
#line 540
              logit("Client: ... disconnected from server, reconnection in progress!");
#line 541
              logit("Client: ... message from server=%s", buf);
#line 542
              queue_add_fmessage(1, 0, thread->id, (char *)"Disconnected from server, reconnection in progress!");
#line 543
              rev = -1;
            } else {
#line 551
              pingsent = 0;
#line 552
              lastping = time((time_t *)((void *)0));
#line 560
              queue_add_globalmessage(0, thread->id, (char const   *)buf);
#line 561
              queue_add_globalmessage(3, thread->id, (char const   *)buf);
#line 567
              c = 0U;
#line 567
              while (c < 10U) {
#line 568
                ic[c].param1 = (void *)buf;
#line 567
                c ++;
              }
#line 570
              c = 11U;
#line 570
              while (c < 15U) {
#line 571
                ic[c].param1 = (void *)buf;
#line 570
                c ++;
              }
#line 573
              ic[10].param2 = (void *)buf;
#line 576
              sp_parse_server_msg(ic, buf);
            }
          }
        }
#line 581
        tmp___9 = queue_fetchmessages(thread->id, sockfd);
#line 581
        rev -= tmp___9;
#line 584
        while (1) {
#line 584
          tmp___10 = commands_fetch(thread->id, & command);
#line 584
          if (! (tmp___10 == 0)) {
#line 584
            break;
          }
#line 585
          if (command.cmdid == 2) {
#line 586
            rev = oz_writefl(sockfd, "QUIT :Requested");
#line 587
            rev = -1;
#line 588
            sleep(2U);
          }
        }
#line 593
        if (pingsent == 0) {
#line 593
          tmp___12 = time((time_t *)((void *)0));
#line 593
          if (lastping + (time_t )settings.cli_pingsend < tmp___12) {
#line 595
            rev = oz_writefl(sockfd, "PING :%s", settings.hostname);
#line 596
            pingsent = 1;
          } else {
#line 593
            goto _L;
          }
        } else
        _L: /* CIL Label */ 
#line 599
        if (pingsent == 1) {
#line 599
          tmp___11 = time((time_t *)((void *)0));
#line 599
          if (lastping + (time_t )settings.cli_pingtimeout < tmp___11) {
#line 600
            logit("Self ping check failed, reconnecting to server!");
#line 601
            queue_add_fmessage(1, 0, thread->id, (char *)"Self ping check failed, reconnecting to server!");
#line 602
            rev = -1;
          }
        }
#line 605
        sp_sleep();
      }
#line 609
      tmp___15 = __errno_location();
#line 609
      if (*tmp___15 == 0) {
#line 610
        logit("Client: .. closing connection to server!");
      } else {
#line 612
        tmp___13 = __errno_location();
#line 612
        tmp___14 = strerror(*tmp___13);
#line 612
        logit("Client: .. closing connection to server, system error=%s.", tmp___14);
      }
#line 614
      oz_close(sockfd);
    }
  }
#line 619
  oz_readend(& buf);
#line 620
  thread_unregister(thread->id);
#line 621
  pthread_exit((void *)0);
}
}
#line 1 "util.o"
#pragma merger("0","/tmp/cil-8TFO2Btk.i","-Wall,-O3")
#line 460 "/usr/include/unistd.h"
extern int usleep(__useconds_t __useconds ) ;
#line 18 "util.c"
void sp_sleep(void) 
{ 


  {
#line 19
  usleep((__useconds_t )50);
#line 20
  return;
}
}
#line 1 "queues.o"
#pragma merger("0","/tmp/cil-Pi9CRREY.i","-Wall,-O3")
#line 753 "/usr/include/pthread.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) pthread_mutex_lock)(pthread_mutex_t *__mutex ) ;
#line 764
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) pthread_mutex_unlock)(pthread_mutex_t *__mutex ) ;
#line 193 "supervixen.h"
int thread_info(int *pos , tthreads *thread ) ;
#line 196
int commands_add(int to , int from , int cmdid , void *param1 , void *param2 , void *param3 ,
                 void *param4 ) ;
#line 198
void commands_del(tcommands *p ) ;
#line 200
int queue_addmessage(int to , int from , char const   *txt ) ;
#line 5 "queues.c"
static size_t linecache_size  ;
#line 6 "queues.c"
static size_t linecache_pos  ;
#line 23 "queues.c"
int thread_register(int kind ) 
{ 
  unsigned int i ;

  {
#line 24
  i = 0U;
#line 26
  pthread_mutex_lock(& threads_lock);
#line 28
  i = 0U;
#line 28
  while (i < 100U) {
#line 29
    if (threads[i].id == -1) {
#line 30
      threads[i].id = (int )i;
#line 31
      threads[i].pid = 0;
#line 32
      threads[i].kind = kind;
#line 33
      pthread_mutex_unlock(& threads_lock);
#line 34
      return ((int )i);
    }
#line 28
    i ++;
  }
#line 37
  pthread_mutex_unlock(& threads_lock);
#line 39
  return (-1);
}
}
#line 58 "queues.c"
int thread_info(int *pos , tthreads *thread ) 
{ 
  int tmp ;

  {
#line 59
  pthread_mutex_lock(& threads_lock);
#line 61
  if (*pos < 100) {
#line 62
    tmp = *pos;
#line 62
    (*pos) ++;
#line 62
    *thread = threads[tmp];
#line 63
    pthread_mutex_unlock(& threads_lock);
#line 64
    return (0);
  }
#line 67
  pthread_mutex_unlock(& threads_lock);
#line 68
  return (-1);
}
}
#line 95 "queues.c"
void thread_unregister(int id ) 
{ 
  unsigned int i ;
  tcommands *tmpcmd ;
  tcommands *tmpq ;

  {
#line 96
  i = 0U;
#line 98
  tmpq = (tcommands *)((void *)0);
#line 102
  pthread_mutex_lock(& threads_lock);
#line 104
  i = 0U;
#line 104
  while (i < 100U) {
#line 105
    if (threads[i].id == id) {
#line 106
      threads[i].id = -1;
    }
#line 104
    i ++;
  }
#line 109
  pthread_mutex_lock(& commands_lock);
#line 111
  if ((unsigned long )commands != (unsigned long )((void *)0)) {
#line 112
    tmpcmd = commands;
#line 114
    while (1) {
#line 115
      if (tmpcmd->id == id) {
#line 116
        if ((unsigned long )tmpq != (unsigned long )((void *)0)) {
#line 117
          commands_del(tmpq);
#line 118
          tmpq = (tcommands *)((void *)0);
        }
#line 121
        if ((unsigned long )tmpcmd->param1 != (unsigned long )((void *)0)) {
#line 122
          free(tmpcmd->param1);
        }
#line 124
        if ((unsigned long )tmpcmd->param2 != (unsigned long )((void *)0)) {
#line 125
          free(tmpcmd->param2);
        }
#line 127
        if ((unsigned long )tmpcmd->param3 != (unsigned long )((void *)0)) {
#line 128
          free(tmpcmd->param3);
        }
#line 130
        if ((unsigned long )tmpcmd->param4 != (unsigned long )((void *)0)) {
#line 131
          free(tmpcmd->param4);
        }
#line 133
        tmpq = tmpcmd;
      }
#line 114
      tmpcmd = tmpcmd->next;
#line 114
      if (! ((unsigned long )tmpcmd != (unsigned long )((void *)0))) {
#line 114
        break;
      }
    }
  }
#line 138
  if ((unsigned long )tmpq != (unsigned long )((void *)0)) {
#line 139
    commands_del(tmpq);
  }
#line 141
  pthread_mutex_unlock(& commands_lock);
#line 142
  pthread_mutex_unlock(& threads_lock);
#line 143
  return;
}
}
#line 158 "queues.c"
int commands_init(void) 
{ 


  {
#line 159
  pthread_mutex_lock(& commands_lock);
#line 161
  commands = (tcommands *)((void *)0);
#line 163
  pthread_mutex_unlock(& commands_lock);
#line 165
  return (0);
}
}
#line 184 "queues.c"
static tcommands *commands_cmdalloc(void) 
{ 
  tcommands *p ;
  tcommands *last ;
  void *tmp ;
  struct commands_st *tmp___0 ;
  void *tmp___1 ;

  {
#line 186
  last = (tcommands *)((void *)0);
#line 191
  if ((unsigned long )commands == (unsigned long )((void *)0)) {
#line 192
    tmp = malloc(sizeof(tcommands ));
#line 192
    commands = (tcommands *)tmp;
#line 192
    p = commands;
  } else {
#line 196
    p = commands;
#line 196
    last = p;
#line 199
    while ((unsigned long )p->next != (unsigned long )((void *)0)) {
#line 200
      p = p->next;
#line 200
      last = p;
    }
#line 203
    tmp___1 = malloc(sizeof(tcommands ));
#line 203
    tmp___0 = (struct commands_st *)tmp___1;
#line 203
    p->next = tmp___0;
#line 203
    p = tmp___0;
  }
#line 207
  if ((unsigned long )p == (unsigned long )((void *)0)) {
#line 208
    return ((tcommands *)((void *)0));
  } else {
#line 212
    memset((void *)p, '\000', sizeof(tcommands ));
#line 213
    p->prev = last;
  }
#line 216
  return (p);
}
}
#line 233 "queues.c"
int commands_add(int to , int from , int cmdid , void *param1 , void *param2 , void *param3 ,
                 void *param4 ) 
{ 
  tcommands *cmd ;

  {
#line 238
  pthread_mutex_lock(& commands_lock);
#line 240
  cmd = commands_cmdalloc();
#line 240
  if ((unsigned long )cmd == (unsigned long )((void *)0)) {
#line 241
    pthread_mutex_unlock(& commands_lock);
#line 242
    logit("WARNING: SuperVixen was unable to allocate memory, some things may be wrong!");
#line 242
    return (-1);
  }
#line 245
  cmd->id = to;
#line 246
  cmd->from = from;
#line 247
  cmd->cmdid = cmdid;
#line 248
  cmd->param1 = param1;
#line 249
  cmd->param2 = param2;
#line 250
  cmd->param3 = param3;
#line 251
  cmd->param4 = param4;
#line 253
  pthread_mutex_unlock(& commands_lock);
#line 255
  return (0);
}
}
#line 271 "queues.c"
void commands_groupmsg(int kind , int from , int cmdid , void *param1 , void *param2 ,
                       void *param3 , void *param4 ) 
{ 
  unsigned int i ;

  {
#line 272
  i = 0U;
#line 274
  pthread_mutex_lock(& threads_lock);
#line 276
  i = 0U;
#line 276
  while (i < 100U) {
#line 277
    if (threads[i].id != -1) {
#line 277
      if (threads[i].kind == kind) {
#line 278
        commands_add(threads[i].id, from, cmdid, param1, param2, param3, param4);
      } else
#line 277
      if (kind == 2) {
#line 278
        commands_add(threads[i].id, from, cmdid, param1, param2, param3, param4);
      }
    }
#line 276
    i ++;
  }
#line 281
  pthread_mutex_unlock(& threads_lock);
#line 283
  return;
}
}
#line 303 "queues.c"
void commands_del(tcommands *p ) 
{ 


  {
#line 307
  if ((unsigned long )p->next == (unsigned long )commands->next) {
#line 307
    if ((unsigned long )p->prev == (unsigned long )commands->prev) {
#line 308
      if ((unsigned long )commands->next != (unsigned long )((void *)0)) {
#line 309
        commands = commands->next;
      } else {
#line 311
        commands = (tcommands *)((void *)0);
      }
    }
  }
#line 315
  if ((unsigned long )p->next != (unsigned long )((void *)0)) {
#line 316
    (p->next)->prev = p->prev;
  }
#line 318
  if ((unsigned long )p->prev != (unsigned long )((void *)0)) {
#line 319
    (p->prev)->next = p->next;
  }
#line 322
  free((void *)p);
#line 323
  return;
}
}
#line 340 "queues.c"
int commands_fetch(int id , tcommands *command ) 
{ 
  tcommands *tmpcmd ;

  {
#line 343
  pthread_mutex_lock(& commands_lock);
#line 345
  if ((unsigned long )commands == (unsigned long )((void *)0)) {
#line 346
    pthread_mutex_unlock(& commands_lock);
#line 347
    return (-1);
  } else {
#line 351
    tmpcmd = commands;
  }
#line 353
  while (1) {
#line 354
    if (tmpcmd->id == id) {
#line 354
      if (tmpcmd->cmdid != 6) {
#line 355
        command->id = tmpcmd->id;
#line 356
        command->from = tmpcmd->from;
#line 357
        command->cmdid = tmpcmd->cmdid;
#line 358
        command->param1 = tmpcmd->param1;
#line 359
        command->param2 = tmpcmd->param2;
#line 360
        command->param3 = tmpcmd->param3;
#line 361
        command->param4 = tmpcmd->param4;
#line 363
        commands_del(tmpcmd);
#line 364
        pthread_mutex_unlock(& commands_lock);
#line 365
        return (0);
      }
    }
#line 353
    tmpcmd = tmpcmd->next;
#line 353
    if (! ((unsigned long )tmpcmd != (unsigned long )((void *)0))) {
#line 353
      break;
    }
  }
#line 369
  pthread_mutex_unlock(& commands_lock);
#line 371
  return (-1);
}
}
#line 395 "queues.c"
int queue_addmessage(int to , int from , char const   *txt ) 
{ 
  char *newtxt ;
  char *tmp___4 ;
  int tmp___5 ;

  {
#line 400
  tmp___4 = __strdup(txt);
#line 400
  newtxt = tmp___4;
#line 402
  if ((unsigned long )newtxt == (unsigned long )((void *)0)) {
#line 403
    logit("WARNING: SuperVixen was unable to allocate memory, some things may be wrong!");
#line 403
    return (-1);
  }
#line 406
  tmp___5 = commands_add(to, from, 6, (void *)newtxt, (void *)0, (void *)0, (void *)0);
#line 406
  return (tmp___5);
}
}
#line 429 "queues.c"
int queue_add_globalmessage(int kind , int from , char const   *txt ) 
{ 
  unsigned int i ;

  {
#line 430
  i = 0U;
#line 434
  pthread_mutex_lock(& threads_lock);
#line 436
  i = 0U;
#line 436
  while (i < 100U) {
#line 437
    if (threads[i].id != -1) {
#line 437
      if (threads[i].id != from) {
#line 437
        if (threads[i].kind == kind) {
#line 438
          queue_addmessage(threads[i].id, from, txt);
        } else
#line 437
        if (kind == 2) {
#line 438
          queue_addmessage(threads[i].id, from, txt);
        }
      }
    }
#line 436
    i ++;
  }
#line 441
  pthread_mutex_unlock(& threads_lock);
#line 445
  return (0);
}
}
#line 464 "queues.c"
int queue_add_fmessage(int global , int dest , int from , char *format  , ...) 
{ 
  char msg1[5000] ;
  char msg2[5000] ;
  va_list ap ;
  int tmp ;
  int tmp___0 ;

  {
#line 469
  memset((void *)(msg1), '\000', sizeof(msg1));
#line 470
  memset((void *)(msg2), '\000', sizeof(msg2));
#line 472
  __builtin_va_start(ap, format);
#line 473
  vsnprintf((char * __restrict  )(msg1), sizeof(msg1) - sizeof(char ), (char const   * __restrict  )format,
            ap);
#line 474
  __builtin_va_end(ap);
#line 476
  snprintf((char * __restrict  )(msg2), sizeof(msg2) - sizeof(char ), (char const   * __restrict  )":%s 372 %s :%s",
           settings.hostname, settings.nickname, msg1);
#line 478
  if (global == 1) {
#line 479
    tmp = queue_add_globalmessage(dest, from, (char const   *)(msg2));
#line 479
    return (tmp);
  } else {
#line 482
    tmp___0 = queue_addmessage(dest, from, (char const   *)(msg2));
#line 482
    return (tmp___0);
  }
}
}
#line 501 "queues.c"
int queue_fetchmessages(int id , int *sockfd ) 
{ 
  int rev ;
  char *txt ;

  {
#line 502
  rev = 0;
#line 505
  while (1) {
#line 505
    if (rev == 0) {
#line 505
      txt = queue_fetchmessagess(id);
#line 505
      if (! ((unsigned long )txt != (unsigned long )((void *)0))) {
#line 505
        break;
      }
    } else {
#line 505
      break;
    }
#line 506
    rev = oz_writel(sockfd, (char const   *)txt);
#line 507
    free((void *)txt);
  }
#line 510
  return (rev);
}
}
#line 532 "queues.c"
char *queue_fetchmessagess(int id ) 
{ 
  tcommands *tmpcmd ;
  char *txt ;

  {
#line 536
  pthread_mutex_lock(& commands_lock);
#line 538
  if ((unsigned long )commands != (unsigned long )((void *)0)) {
#line 539
    tmpcmd = commands;
#line 541
    while (1) {
#line 542
      if (tmpcmd->id == id) {
#line 542
        if (tmpcmd->cmdid == 6) {
#line 543
          txt = (char *)tmpcmd->param1;
#line 544
          commands_del(tmpcmd);
#line 545
          pthread_mutex_unlock(& commands_lock);
#line 546
          return (txt);
        }
      }
#line 541
      tmpcmd = tmpcmd->next;
#line 541
      if (! ((unsigned long )tmpcmd != (unsigned long )((void *)0))) {
#line 541
        break;
      }
    }
  }
#line 551
  pthread_mutex_unlock(& commands_lock);
#line 553
  return ((char *)((void *)0));
}
}
#line 571 "queues.c"
int sp_lcache_init(void) 
{ 
  void *tmp ;

  {
#line 574
  pthread_mutex_lock(& lcache_lock);
#line 576
  linecache_pos = (size_t )0;
#line 577
  linecache_size = (size_t )1;
#line 579
  tmp = malloc(linecache_size * sizeof(char *));
#line 579
  linecache = (char **)tmp;
#line 581
  if ((unsigned long )linecache == (unsigned long )((void *)0)) {
#line 582
    pthread_mutex_unlock(& lcache_lock);
#line 583
    logit("WARNING: SuperVixen was unable to allocate memory, some things may be wrong!");
#line 583
    return (-1);
  } else {
#line 587
    *(linecache + linecache_pos) = (char *)((void *)0);
  }
#line 589
  pthread_mutex_unlock(& lcache_lock);
#line 591
  return (0);
}
}
#line 608 "queues.c"
int sp_lcache(char const   *line ) 
{ 
  char **linecache_tmp ;
  char *line_tmp ;
  void *tmp ;
  char *tmp___5 ;
  size_t tmp___6 ;

  {
#line 614
  if ((unsigned long )line == (unsigned long )((void *)0)) {
#line 615
    return (-1);
  }
#line 617
  pthread_mutex_lock(& lcache_lock);
#line 619
  linecache_size ++;
#line 619
  tmp = realloc((void *)linecache, linecache_size * sizeof(char *));
#line 619
  linecache_tmp = (char **)tmp;
#line 620
  tmp___5 = __strdup(line);
#line 620
  line_tmp = tmp___5;
#line 623
  if ((unsigned long )linecache_tmp == (unsigned long )((void *)0)) {
#line 624
    pthread_mutex_unlock(& lcache_lock);
#line 625
    logit("WARNING: SuperVixen was unable to allocate memory, some things may be wrong!");
#line 625
    return (-1);
  } else
#line 623
  if ((unsigned long )line_tmp == (unsigned long )((void *)0)) {
#line 624
    pthread_mutex_unlock(& lcache_lock);
#line 625
    logit("WARNING: SuperVixen was unable to allocate memory, some things may be wrong!");
#line 625
    return (-1);
  }
#line 629
  linecache = linecache_tmp;
#line 630
  *(linecache + (linecache_size - 1UL)) = (char *)((void *)0);
#line 631
  tmp___6 = linecache_pos;
#line 631
  linecache_pos ++;
#line 631
  *(linecache + tmp___6) = line_tmp;
#line 633
  pthread_mutex_unlock(& lcache_lock);
#line 635
  return (0);
}
}
#line 651 "queues.c"
void sp_lcache_flush(void) 
{ 
  size_t i ;
  char **tmp ;
  void *tmp___0 ;

  {
#line 652
  i = (size_t )0;
#line 657
  pthread_mutex_lock(& lcache_lock);
#line 660
  while (linecache_size <= i) {
#line 661
    if ((unsigned long )*(linecache + i) != (unsigned long )((void *)0)) {
#line 662
      free((void *)*(linecache + i));
    }
#line 663
    i ++;
  }
#line 667
  linecache_pos = (size_t )0;
#line 668
  linecache_size = (size_t )1;
#line 671
  tmp___0 = realloc((void *)linecache, linecache_size * sizeof(char *));
#line 671
  tmp = (char **)tmp___0;
#line 673
  if ((unsigned long )tmp != (unsigned long )((void *)0)) {
#line 674
    linecache = tmp;
  }
#line 676
  *(linecache + linecache_pos) = (char *)((void *)0);
#line 678
  pthread_mutex_unlock(& lcache_lock);
#line 679
  return;
}
}
#line 696 "queues.c"
int sp_lcache_fetch(int *sockfd ) 
{ 
  unsigned int i ;
  int rev ;

  {
#line 697
  i = 0U;
#line 698
  rev = 0;
#line 700
  pthread_mutex_lock(& lcache_lock);
#line 702
  while ((size_t )i < linecache_size) {
#line 703
    if ((unsigned long )*(linecache + i) != (unsigned long )((void *)0)) {
#line 706
      rev = oz_writel(sockfd, (char const   *)*(linecache + i));
#line 708
      if (rev != 0) {
#line 709
        pthread_mutex_unlock(& lcache_lock);
#line 710
        return (rev);
      }
    }
#line 714
    i ++;
  }
#line 717
  pthread_mutex_unlock(& lcache_lock);
#line 719
  return (0);
}
}
#line 735 "queues.c"
int cache_addchannel(char const   *chan ) 
{ 
  unsigned int i ;
  char *tmp___4 ;

  {
#line 736
  i = 0U;
#line 740
  cache_delchannel(chan);
#line 742
  pthread_mutex_lock(& channels_lock);
#line 744
  i = 0U;
#line 744
  while (i < 500U) {
#line 745
    if ((unsigned long )channels[i] == (unsigned long )((void *)0)) {
#line 746
      tmp___4 = __strdup(chan);
#line 746
      channels[i] = tmp___4;
#line 748
      if ((unsigned long )channels[i] == (unsigned long )((void *)0)) {
#line 749
        pthread_mutex_unlock(& channels_lock);
#line 750
        logit("WARNING: SuperVixen was unable to allocate memory, some things may be wrong!");
#line 750
        return (-1);
      }
#line 753
      pthread_mutex_unlock(& channels_lock);
#line 754
      return (0);
    }
#line 744
    i ++;
  }
#line 758
  pthread_mutex_unlock(& channels_lock);
#line 759
  return (-1);
}
}
#line 777 "queues.c"
void cache_delchannel(char const   *chan ) 
{ 
  unsigned int i ;
  size_t tmp ;

  {
#line 778
  i = 0U;
#line 782
  pthread_mutex_lock(& channels_lock);
#line 784
  i = 0U;
#line 784
  while (i < 500U) {
#line 785
    if ((unsigned long )channels[i] != (unsigned long )((void *)0)) {
#line 785
      tmp = str_comp((char const   *)channels[i], chan);
#line 785
      if (tmp == 0UL) {
#line 786
        free((void *)channels[i]);
#line 787
        channels[i] = (char *)((void *)0);
      }
    }
#line 784
    i ++;
  }
#line 791
  pthread_mutex_unlock(& channels_lock);
#line 792
  return;
}
}
#line 809 "queues.c"
int cache_spitchannels(int id , int *sockfd ) 
{ 
  size_t fbuffer_size ;
  unsigned int i ;
  char *fbuffer ;
  size_t tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  void *tmp___3 ;

  {
#line 810
  fbuffer_size = (size_t )0;
#line 811
  i = 0U;
#line 814
  pthread_mutex_lock(& channels_lock);
#line 816
  i = 0U;
#line 816
  while (i < 500U) {
#line 817
    if ((unsigned long )channels[i] != (unsigned long )((void *)0)) {
#line 821
      tmp = strlen((char const   *)(settings.nickname));
#line 821
      tmp___0 = strlen((char const   *)(settings.username));
#line 821
      tmp___1 = strlen((char const   *)(settings.fake_hostname));
#line 821
      tmp___2 = strlen((char const   *)channels[i]);
#line 821
      fbuffer_size = ((((tmp + tmp___0) + tmp___1) + tmp___2) + 30UL) * sizeof(char );
#line 822
      tmp___3 = malloc(fbuffer_size);
#line 822
      fbuffer = (char *)tmp___3;
#line 824
      if ((unsigned long )fbuffer == (unsigned long )((void *)0)) {
#line 825
        pthread_mutex_unlock(& channels_lock);
#line 826
        logit("WARNING: SuperVixen was unable to allocate memory, some things may be wrong!");
#line 826
        return (-1);
      }
#line 829
      snprintf((char * __restrict  )fbuffer, fbuffer_size, (char const   * __restrict  )":%s!%s@%s JOIN :%s",
               settings.nickname, settings.username, settings.fake_hostname, channels[i]);
#line 830
      oz_writel(sockfd, (char const   *)fbuffer);
#line 832
      snprintf((char * __restrict  )fbuffer, fbuffer_size, (char const   * __restrict  )"NAMES %s",
               channels[i]);
#line 833
      queue_add_globalmessage(1, id, (char const   *)fbuffer);
#line 835
      snprintf((char * __restrict  )fbuffer, fbuffer_size, (char const   * __restrict  )"TOPIC %s",
               channels[i]);
#line 836
      queue_add_globalmessage(1, id, (char const   *)fbuffer);
#line 838
      free((void *)fbuffer);
    }
#line 816
    i ++;
  }
#line 842
  pthread_mutex_unlock(& channels_lock);
#line 844
  return (0);
}
}
#line 862 "queues.c"
int cache_chan_reconnect(int *sockfd ) 
{ 
  int i ;
  int rev ;
  int tmp ;

  {
#line 863
  i = 0;
#line 864
  rev = 0;
#line 866
  pthread_mutex_lock(& channels_lock);
#line 868
  while (i < 500) {
#line 869
    if ((unsigned long )channels[i] != (unsigned long )((void *)0)) {
#line 870
      tmp = oz_writefl(sockfd, "JOIN %s", channels[i]);
#line 870
      rev -= tmp;
#line 871
      free((void *)channels[i]);
#line 872
      channels[i] = (char *)((void *)0);
    }
#line 875
    i ++;
  }
#line 878
  pthread_mutex_unlock(& channels_lock);
#line 880
  return (rev);
}
}
#line 1 "irc.o"
#pragma merger("0","/tmp/cil-gMn7XQ_j.i","-Wall,-O3")
#line 184 "supervixen.h"
int sp_parse_membcnt(char **msg ) ;
#line 19 "irc.c"
int sp_verifyuser(char const   *txt ) 
{ 
  char **split ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___0 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___7 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;

  {
#line 22
  split = oz_splitmsg(txt);
#line 24
  if ((unsigned long )split == (unsigned long )((void *)0)) {
#line 25
    logit("WARNING: SuperVixen was unable to allocate memory, some things may be wrong!");
#line 25
    return (-1);
  }
#line 28
  if ((unsigned long )*(split + 0) == (unsigned long )((void *)0)) {
#line 29
    oz_splitfree(split);
#line 30
    return (0);
  } else
#line 28
  if ((unsigned long )*(split + 1) == (unsigned long )((void *)0)) {
#line 29
    oz_splitfree(split);
#line 30
    return (0);
  } else
#line 28
  if ((unsigned long )*(split + 2) == (unsigned long )((void *)0)) {
#line 29
    oz_splitfree(split);
#line 30
    return (0);
  }
#line 34
  if (0) {
#line 34
    __s1_len = __builtin_strlen((char const   *)*(split + 1));
#line 34
    __s2_len = __builtin_strlen((char const   *)(settings.auth_user));
#line 34
    if (! ((size_t )((void const   *)(*(split + 1) + 1)) - (size_t )((void const   *)*(split + 1)) == 1UL)) {
#line 34
      goto _L___0;
    } else
#line 34
    if (__s1_len >= 4UL) {
      _L___0: /* CIL Label */ 
#line 34
      if (! ((size_t )((void const   *)(settings.auth_user + 1)) - (size_t )((void const   *)(settings.auth_user)) == 1UL)) {
#line 34
        tmp___5 = 1;
      } else
#line 34
      if (__s2_len >= 4UL) {
#line 34
        tmp___5 = 1;
      } else {
#line 34
        tmp___5 = 0;
      }
    } else {
#line 34
      tmp___5 = 0;
    }
#line 34
    if (tmp___5) {
#line 34
      tmp___0 = __builtin_strcmp((char const   *)*(split + 1), (char const   *)(settings.auth_user));
#line 34
      tmp___4 = tmp___0;
    } else {
#line 34
      tmp___3 = __builtin_strcmp((char const   *)*(split + 1), (char const   *)(settings.auth_user));
#line 34
      tmp___4 = tmp___3;
    }
  } else {
#line 34
    tmp___3 = __builtin_strcmp((char const   *)*(split + 1), (char const   *)(settings.auth_user));
#line 34
    tmp___4 = tmp___3;
  }
#line 34
  if (tmp___4 == 0) {
#line 34
    if (0) {
#line 34
      __s1_len___0 = __builtin_strlen((char const   *)*(split + 2));
#line 34
      __s2_len___0 = __builtin_strlen((char const   *)(settings.auth_pass));
#line 34
      if (! ((size_t )((void const   *)(*(split + 2) + 1)) - (size_t )((void const   *)*(split + 2)) == 1UL)) {
#line 34
        goto _L___2;
      } else
#line 34
      if (__s1_len___0 >= 4UL) {
        _L___2: /* CIL Label */ 
#line 34
        if (! ((size_t )((void const   *)(settings.auth_pass + 1)) - (size_t )((void const   *)(settings.auth_pass)) == 1UL)) {
#line 34
          tmp___12 = 1;
        } else
#line 34
        if (__s2_len___0 >= 4UL) {
#line 34
          tmp___12 = 1;
        } else {
#line 34
          tmp___12 = 0;
        }
      } else {
#line 34
        tmp___12 = 0;
      }
#line 34
      if (tmp___12) {
#line 34
        tmp___7 = __builtin_strcmp((char const   *)*(split + 2), (char const   *)(settings.auth_pass));
#line 34
        tmp___11 = tmp___7;
      } else {
#line 34
        tmp___10 = __builtin_strcmp((char const   *)*(split + 2), (char const   *)(settings.auth_pass));
#line 34
        tmp___11 = tmp___10;
      }
    } else {
#line 34
      tmp___10 = __builtin_strcmp((char const   *)*(split + 2), (char const   *)(settings.auth_pass));
#line 34
      tmp___11 = tmp___10;
    }
#line 34
    if (tmp___11 == 0) {
#line 35
      oz_splitfree(split);
#line 36
      return (1);
    } else {
#line 40
      oz_splitfree(split);
#line 41
      return (0);
    }
  } else {
#line 40
    oz_splitfree(split);
#line 41
    return (0);
  }
#line 44
  return (-1);
}
}
#line 62 "irc.c"
int sp_parse_membcnt(char **msg ) 
{ 
  size_t i ;
  char **tmp ;

  {
#line 63
  i = (size_t )0;
#line 65
  while (*msg) {
#line 66
    i ++;
#line 67
    tmp = msg;
#line 67
    msg ++;
  }
#line 70
  return ((int )i);
}
}
#line 87 "irc.c"
void sp_parse_server_msg(irc_actions *ic , char *txt ) 
{ 
  char **msg ;
  char **tmsg ;
  unsigned int code ;
  size_t i ;
  int x ;
  int (*fp)(void * , void * , void * , void * ) ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  size_t tmp___5 ;
  size_t tmp___6 ;
  size_t tmp___7 ;
  int tmp___8 ;

  {
#line 90
  code = 0U;
#line 91
  i = (size_t )0;
#line 92
  x = 0;
#line 95
  tmsg = oz_splitmsg((char const   *)txt);
#line 96
  msg = tmsg;
#line 98
  if ((unsigned long )msg == (unsigned long )((void *)0)) {
#line 99
    tmp = __errno_location();
#line 99
    tmp___0 = strerror(*tmp);
#line 99
    logit("Error parsing message from server, error=%s.", tmp___0);
#line 100
    return;
  }
#line 103
  tmp___1 = sp_parse_membcnt(msg);
#line 103
  i = (size_t )tmp___1;
#line 105
  if (i < 3UL) {
#line 106
    oz_splitfree(tmsg);
#line 107
    return;
  }
#line 111
  if ((int )*(*(msg + 0) + 0) == 58) {
#line 111
    tmp___8 = is_digits((char const   *)*(msg + 1));
#line 111
    if (tmp___8 == 0) {
#line 112
      tmp___2 = atoi((char const   *)*(msg + 1));
#line 112
      code = (unsigned int )tmp___2;
#line 114
      x = 0;
#line 114
      while ((ic + x)->code != -1) {
#line 115
        if (code == (unsigned int )(ic + x)->code) {
#line 116
          fp = (int (*)(void * , void * , void * , void * ))(ic + x)->handler;
#line 117
          (*fp)((ic + x)->param1, (ic + x)->param2, (ic + x)->param3, (ic + x)->param4);
        }
#line 114
        x ++;
      }
    } else {
#line 111
      goto _L___3;
    }
  } else
  _L___3: /* CIL Label */ 
#line 124
  if ((int )*(*(msg + 0) + 0) == 58) {
#line 124
    tmp___7 = strn_comp((char const   *)*(msg + 1), "PONG");
#line 124
    if (tmp___7 == 0UL) {
#line 125
      code = 1101U;
#line 127
      x = 0;
#line 127
      while ((ic + x)->code != -1) {
#line 128
        if (code == (unsigned int )(ic + x)->code) {
#line 129
          fp = (int (*)(void * , void * , void * , void * ))(ic + x)->handler;
#line 130
          (*fp)((ic + x)->param1, (ic + x)->param2, (ic + x)->param3, (ic + x)->param4);
        }
#line 127
        x ++;
      }
    } else {
#line 124
      goto _L___2;
    }
  } else
  _L___2: /* CIL Label */ 
#line 135
  if ((int )*(*(msg + 0) + 0) == 58) {
#line 135
    tmp___6 = strn_comp((char const   *)*(msg + 1), "NICK");
#line 135
    if (tmp___6 == 0UL) {
#line 136
      code = 1103U;
#line 138
      x = 0;
#line 138
      while ((ic + x)->code != -1) {
#line 139
        if (code == (unsigned int )(ic + x)->code) {
#line 140
          fp = (int (*)(void * , void * , void * , void * ))(ic + x)->handler;
#line 141
          (*fp)((ic + x)->param1, (ic + x)->param2, (ic + x)->param3, (ic + x)->param4);
        }
#line 138
        x ++;
      }
    } else {
#line 135
      goto _L___1;
    }
  } else
  _L___1: /* CIL Label */ 
#line 146
  if ((int )*(*(msg + 0) + 0) == 58) {
#line 146
    tmp___5 = strn_comp((char const   *)*(msg + 1), "KICK");
#line 146
    if (tmp___5 == 0UL) {
#line 147
      code = 1105U;
#line 149
      x = 0;
#line 149
      while ((ic + x)->code != -1) {
#line 150
        if (code == (unsigned int )(ic + x)->code) {
#line 151
          fp = (int (*)(void * , void * , void * , void * ))(ic + x)->handler;
#line 152
          (*fp)((ic + x)->param1, (ic + x)->param2, (ic + x)->param3, (ic + x)->param4);
        }
#line 149
        x ++;
      }
    } else {
#line 146
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
#line 157
  if ((int )*(*(msg + 0) + 0) == 58) {
#line 157
    tmp___4 = strn_comp((char const   *)*(msg + 1), "JOIN");
#line 157
    if (tmp___4 == 0UL) {
#line 158
      code = 1104U;
#line 160
      x = 0;
#line 160
      while ((ic + x)->code != -1) {
#line 161
        if (code == (unsigned int )(ic + x)->code) {
#line 162
          fp = (int (*)(void * , void * , void * , void * ))(ic + x)->handler;
#line 163
          (*fp)((ic + x)->param1, (ic + x)->param2, (ic + x)->param3, (ic + x)->param4);
        }
#line 160
        x ++;
      }
    } else {
#line 157
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 168
  if ((int )*(*(msg + 0) + 0) == 58) {
#line 168
    tmp___3 = strn_comp((char const   *)*(msg + 1), "PART");
#line 168
    if (tmp___3 == 0UL) {
#line 169
      code = 1106U;
#line 171
      x = 0;
#line 171
      while ((ic + x)->code != -1) {
#line 172
        if (code == (unsigned int )(ic + x)->code) {
#line 173
          fp = (int (*)(void * , void * , void * , void * ))(ic + x)->handler;
#line 174
          (*fp)((ic + x)->param1, (ic + x)->param2, (ic + x)->param3, (ic + x)->param4);
        }
#line 171
        x ++;
      }
    }
  }
#line 179
  oz_splitfree(tmsg);
#line 180
  return;
}
}
#line 197 "irc.c"
char **sp_ircsplit(char const   *str ) 
{ 
  char **split ;
  size_t str_len ;
  size_t str_pos ;
  unsigned int i ;
  int got_nick ;
  int got_username ;
  int got_hostname ;
  void *tmp ;
  void *tmp___0 ;

  {
#line 199
  str_len = (size_t )0;
#line 200
  str_pos = (size_t )0;
#line 201
  i = 0U;
#line 202
  got_nick = 0;
#line 203
  got_username = 0;
#line 204
  got_hostname = 0;
#line 206
  if ((unsigned long )str == (unsigned long )((void *)0)) {
#line 207
    return ((char **)((void *)0));
  }
#line 209
  str_len = strlen(str);
#line 211
  tmp = malloc(5UL * sizeof(char *));
#line 211
  split = (char **)tmp;
#line 213
  if ((unsigned long )split == (unsigned long )((void *)0)) {
#line 214
    return ((char **)((void *)0));
  }
#line 216
  i = 0U;
#line 216
  while (i < 4U) {
#line 217
    tmp___0 = malloc((str_len + 4UL) * sizeof(char ));
#line 217
    *(split + i) = (char *)tmp___0;
#line 219
    if ((unsigned long )*(split + i) == (unsigned long )((void *)0)) {
#line 220
      return ((char **)((void *)0));
    }
#line 222
    memset((void *)*(split + i), '\000', (str_len + 4UL) * sizeof(char ));
#line 216
    i ++;
  }
#line 225
  str_pos = (size_t )0;
#line 225
  while (str_pos < str_len) {
#line 226
    if (got_nick == 0) {
#line 227
      if ((int const   )*(str + str_pos) == 33) {
#line 228
        got_nick = 1;
      } else {
#line 230
        strncat((char * __restrict  )*(split + 0), (char const   * __restrict  )(str + str_pos),
                (size_t )1);
      }
    } else
#line 233
    if (got_nick == 1) {
#line 233
      if (got_username == 0) {
#line 234
        if ((int const   )*(str + str_pos) == 64) {
#line 235
          got_username = 1;
        } else {
#line 237
          strncat((char * __restrict  )*(split + 1), (char const   * __restrict  )(str + str_pos),
                  (size_t )1);
        }
      } else {
#line 233
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 240
    if (got_nick == 1) {
#line 240
      if (got_username == 1) {
#line 240
        if (got_hostname == 0) {
#line 241
          if ((int const   )*(str + str_pos) == 0) {
#line 242
            got_hostname = 1;
#line 243
            break;
          } else {
#line 247
            strncat((char * __restrict  )*(split + 2), (char const   * __restrict  )(str + str_pos),
                    (size_t )1);
          }
        }
      }
    }
#line 225
    str_pos ++;
  }
#line 251
  return (split);
}
}
#line 267 "irc.c"
void sp_ircsplit_end(char **str ) 
{ 


  {
#line 268
  if ((unsigned long )*(str + 0) != (unsigned long )((void *)0)) {
#line 269
    free((void *)*(str + 0));
  }
#line 270
  if ((unsigned long )*(str + 1) != (unsigned long )((void *)0)) {
#line 271
    free((void *)*(str + 1));
  }
#line 272
  if ((unsigned long )*(str + 2) != (unsigned long )((void *)0)) {
#line 273
    free((void *)*(str + 2));
  }
#line 274
  if ((unsigned long )*(str + 3) != (unsigned long )((void *)0)) {
#line 275
    free((void *)*(str + 3));
  }
#line 277
  free((void *)str);
#line 278
  return;
}
}
#line 1 "management.o"
#pragma merger("0","/tmp/cil-GSvglXOz.i","-Wall,-O3")
#line 22 "management.c"
static void list_threads(int from , int id ) 
{ 
  int pos ;
  char *type ;
  tthreads t_info ;
  int tmp ;

  {
#line 23
  pos = 0;
#line 27
  queue_add_fmessage(0, id, from, (char *)"Currently running threads:");
#line 28
  queue_add_fmessage(0, id, from, (char *)"Id:\t Pid:\t Type:");
#line 30
  while (1) {
#line 30
    tmp = thread_info(& pos, & t_info);
#line 30
    if (! (tmp != -1)) {
#line 30
      break;
    }
#line 31
    if (t_info.id == -1) {
#line 32
      continue;
    }
#line 34
    if (t_info.kind == 0) {
#line 35
      type = (char *)"Client";
    } else
#line 37
    if (t_info.kind == 3) {
#line 38
      type = (char *)"Management thread";
    } else
#line 40
    if (t_info.kind == 1) {
#line 41
      type = (char *)"IRC server-connection thread";
    } else {
#line 44
      type = (char *)"Unknown!";
    }
#line 46
    queue_add_fmessage(0, id, from, (char *)"%i\t%i\t%s", t_info.id, t_info.pid, type);
  }
#line 49
  queue_add_fmessage(0, id, from, (char *)"End of listing.");
#line 50
  return;
}
}
#line 66 "management.c"
void sp_management(tthreads *thread ) 
{ 
  tcommands command ;
  int rev ;
  unsigned long servermessages ;
  char *msg ;
  pthread_t tmp ;
  time_t tmp___0 ;

  {
#line 68
  rev = 0;
#line 69
  servermessages = 0UL;
#line 72
  tmp = pthread_self();
#line 72
  pthread_detach(tmp);
#line 73
  thread->pid = getpid();
#line 77
  while (1) {
#line 82
    while (1) {
#line 82
      msg = queue_fetchmessagess(thread->id);
#line 82
      if (msg) {
#line 82
        if (! ((unsigned long )msg != (unsigned long )((void *)0))) {
#line 82
          break;
        }
      } else {
#line 82
        break;
      }
#line 83
      if ((int )*(msg + 0) == 58) {
#line 84
        servermessages ++;
      }
#line 86
      free((void *)msg);
    }
#line 90
    rev = commands_fetch(thread->id, & command);
#line 92
    if (rev == -1) {
#line 93
      sp_sleep();
#line 94
      continue;
    }
#line 97
    switch (command.cmdid) {
    case 1: 
#line 99
    tmp___0 = time((time_t *)((void *)0));
#line 99
    queue_add_fmessage(0, command.from, thread->id, (char *)"SuperVixen statistics; Server messages=%lu; number of clients connected=%i; uptime=%lu",
                       servermessages, curconn, tmp___0 - startuptime);
#line 100
    break;
    case 3: 
#line 103
    queue_add_fmessage(1, 0, thread->id, (char *)"A exit request message was recieved. Exiting in ~5 seconds.");
#line 104
    queue_add_fmessage(1, 0, thread->id, (char *)"ERROR :Closing Link: Bouncer exiting.");
#line 105
    sleep(5U);
#line 107
    commands_groupmsg(1, thread->id, 2, (void *)0, (void *)0, (void *)0, (void *)0);
#line 108
    sysexit("Management: Recieved request to exit.");
#line 109
    break;
    case 4: 
#line 112
    queue_add_fmessage(0, command.from, thread->id, (char *)"This is SuperVixen version %s.",
                       settings.version);
#line 113
    break;
    case 7: 
#line 116
    list_threads(thread->id, command.from);
#line 117
    break;
    case 5: 
#line 120
    queue_add_fmessage(0, command.from, thread->id, (char *)"The following commands are possible to use:");
#line 121
    queue_add_fmessage(0, command.from, thread->id, (char *)"\tSPINFO -- gives some statistics.");
#line 122
    queue_add_fmessage(0, command.from, thread->id, (char *)"\tSPDIE -- causes the boncer to disconnect from servers and exit.");
#line 123
    queue_add_fmessage(0, command.from, thread->id, (char *)"\tSPVERSION -- sends out the bouncers version info.");
#line 124
    queue_add_fmessage(0, command.from, thread->id, (char *)"\tSPDISCONNECT -- disconnects from IRC server and connects to the next one.");
#line 125
    queue_add_fmessage(0, command.from, thread->id, (char *)"\tSPTHREADS -- shows a list of currently running threads inside the program.");
#line 126
    queue_add_fmessage(0, command.from, thread->id, (char *)"\tSPHELP -- sends out this info.");
#line 127
    break;
    }
  }
#line 131
  thread_unregister(thread->id);
#line 132
  pthread_exit((void *)0);
}
}
