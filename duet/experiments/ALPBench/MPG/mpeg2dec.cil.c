/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is true */

#line 213 "/usr/lib/gcc/x86_64-linux-gnu/4.7/include/stddef.h"
typedef unsigned long size_t;
#line 135 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __gid_t;
#line 140 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 141 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 181 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __ssize_t;
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 40 "/usr/lib/gcc/x86_64-linux-gnu/4.7/include/stdarg.h"
typedef __builtin_va_list __gnuc_va_list;
#line 155 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 161 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 246 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 316 "/usr/include/libio.h"
typedef struct _IO_FILE _IO_FILE;
#line 102 "/usr/include/stdio.h"
typedef __ssize_t ssize_t;
#line 325 "/usr/lib/gcc/x86_64-linux-gnu/4.7/include/stddef.h"
typedef int wchar_t;
#line 515 "src/global.h"
struct layer_data {
   int Infile ;
   unsigned char Rdbfr[2048] ;
   unsigned char *Rdptr ;
   unsigned char Inbfr[16] ;
   unsigned int Bfr ;
   unsigned char *Rdmax ;
   int Incnt ;
   int Bitcnt ;
   int intra_quantizer_matrix[64] ;
   int non_intra_quantizer_matrix[64] ;
   int chroma_intra_quantizer_matrix[64] ;
   int chroma_non_intra_quantizer_matrix[64] ;
   int load_intra_quantizer_matrix ;
   int load_non_intra_quantizer_matrix ;
   int load_chroma_intra_quantizer_matrix ;
   int load_chroma_non_intra_quantizer_matrix ;
   int MPEG2_Flag ;
   int scalable_mode ;
   int q_scale_type ;
   int alternate_scan ;
   int pict_scal ;
   int priority_breakpoint ;
   int quantizer_scale ;
   int intra_slice ;
   short block[12][64] ;
};
#line 600 "src/global.h"
struct __anonstruct_thrd_buf_info_27 {
   unsigned char *frame_buf ;
   unsigned int frame_buf_size ;
   unsigned int frame_buf_offset ;
   unsigned char padding[20] ;
};
#line 600 "src/global.h"
typedef struct __anonstruct_thrd_buf_info_27 thrd_buf_info;
#line 624 "src/global.h"
struct thrd_layer_data {
   int pict_scal ;
   int priority_breakpoint ;
   int quantizer_scale ;
   int intra_slice ;
   short block[12][64] ;
};
#line 88 "src/getblk.c"
struct __anonstruct_DCTtab_8 {
   char run ;
   char level ;
   char len ;
};
#line 88 "src/getblk.c"
typedef struct __anonstruct_DCTtab_8 DCTtab;
#line 60 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef unsigned long pthread_t;
#line 63 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
union pthread_attr_t {
   char __size[56] ;
   long __align ;
};
#line 69 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef union pthread_attr_t pthread_attr_t;
#line 610 "src/global.h"
struct __anonstruct_Thrd_Args_38 {
   int id ;
   int num_slices ;
   int framenum ;
   int MBAmax ;
};
#line 610 "src/global.h"
typedef struct __anonstruct_Thrd_Args_38 Thrd_Args;
#line 89 "src/getvlc.h"
struct __anonstruct_VLCtab_26 {
   char val ;
   char len ;
};
#line 89 "src/getvlc.h"
typedef struct __anonstruct_VLCtab_26 VLCtab;
#line 153 "/usr/include/x86_64-linux-gnu/bits/mathinline.h"
union __anonunion___u_3 {
   long double __l ;
   int __i[3] ;
};
#line 153 "/usr/include/x86_64-linux-gnu/bits/mathinline.h"
union __anonunion___u_3___0 {
   long double __l ;
   int __i[3] ;
};
#line 40 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __int32_t;
#line 1 "display.o"
#pragma merger("0","/tmp/cil-qNefo8XD.i","-g,-O4")
/* compiler builtin: 
   int __builtin___vsprintf_chk(char * , int  , unsigned long  , char const   * ,
                                __builtin_va_list  ) ;  */
/* compiler builtin: 
   unsigned long __builtin_object_size(void * , int  ) ;  */
/* compiler builtin: 
   int __builtin___sprintf_chk(char * , int  , unsigned long  , char const   *  , ...) ;  */
/* compiler builtin: 
   int __builtin___snprintf_chk(char * , unsigned long  , int  , unsigned long  ,
                                char const   *  , ...) ;  */
/* compiler builtin: 
   int __builtin___vsnprintf_chk(char * , unsigned long  , int  , unsigned long  ,
                                 char const   * , __builtin_va_list  ) ;  */
/* compiler builtin: 
   long __builtin_expect(long  , long  ) ;  */
/* compiler builtin: 
   int __builtin_va_arg_pack(void) ;  */
#line 1 "getbits.o"
#pragma merger("0","/tmp/cil-NyMHw9JY.i","-g,-O4")
#line 392 "/usr/include/libio.h"
extern int __uflow(_IO_FILE * ) ;
#line 393
extern int __overflow(_IO_FILE * , int  ) ;
#line 435
extern int _IO_getc(_IO_FILE *__fp ) ;
#line 436
extern int _IO_putc(int __c , _IO_FILE *__fp ) ;
#line 168 "/usr/include/stdio.h"
extern struct _IO_FILE *stdin ;
#line 169
extern struct _IO_FILE *stdout ;
#line 356
__inline extern int ( __attribute__((__artificial__, __always_inline__)) fprintf)(FILE * __restrict  __stream ,
                                                                                  char const   * __restrict  __fmt 
                                                                                  , ...) ;
#line 362
__inline extern int ( __attribute__((__artificial__, __always_inline__)) printf)(char const   * __restrict  __fmt 
                                                                                 , ...) ;
#line 364
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__, __artificial__,
__always_inline__)) sprintf)(char * __restrict  __s , char const   * __restrict  __fmt 
                             , ...) ;
#line 371
__inline extern int ( __attribute__((__artificial__, __always_inline__)) vfprintf)(FILE * __restrict  __stream ,
                                                                                   char const   * __restrict  __fmt ,
                                                                                   __gnuc_va_list __ap ) ;
#line 377
__inline extern int ( __attribute__((__artificial__, __always_inline__)) vprintf)(char const   * __restrict  __fmt ,
                                                                                  __gnuc_va_list __ap ) ;
#line 379
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__, __artificial__,
__always_inline__)) vsprintf)(char * __restrict  __s , char const   * __restrict  __fmt ,
                              __gnuc_va_list __ap ) ;
#line 386
__inline extern  __attribute__((__nothrow__)) int ( /* format attribute */ __attribute__((__leaf__,
__artificial__, __always_inline__)) snprintf)(char * __restrict  __s , size_t __n ,
                                              char const   * __restrict  __fmt  , ...) ;
#line 390
__inline extern  __attribute__((__nothrow__)) int ( /* format attribute */ __attribute__((__leaf__,
__artificial__, __always_inline__)) vsnprintf)(char * __restrict  __s , size_t __n ,
                                               char const   * __restrict  __fmt ,
                                               __gnuc_va_list __ap ) ;
#line 412
__inline extern int ( /* format attribute */ __attribute__((__artificial__, __always_inline__)) vdprintf)(int __fd ,
                                                                                                          char const   * __restrict  __fmt ,
                                                                                                          __gnuc_va_list __ap ) ;
#line 415
__inline extern int ( /* format attribute */ __attribute__((__artificial__, __always_inline__)) dprintf)(int __fd ,
                                                                                                         char const   * __restrict  __fmt 
                                                                                                         , ...) ;
#line 538
__inline extern int getchar(void) ;
#line 550
__inline extern int getc_unlocked(FILE *__fp ) ;
#line 551
__inline extern int getchar_unlocked(void) ;
#line 561
__inline extern int fgetc_unlocked(FILE *__fp ) ;
#line 580
__inline extern int putchar(int __c ) ;
#line 594
__inline extern int fputc_unlocked(int __c , FILE *__stream ) ;
#line 602
__inline extern int putc_unlocked(int __c , FILE *__stream ) ;
#line 603
__inline extern int putchar_unlocked(int __c ) ;
#line 622
__inline extern char *( __attribute__((__warn_unused_result__, __artificial__, __always_inline__)) fgets)(char * __restrict  __s ,
                                                                                                          int __n ,
                                                                                                          FILE * __restrict  __stream ) ;
#line 638
__inline extern char *( __attribute__((__warn_unused_result__, __artificial__, __always_inline__)) gets)(char *__str )  __attribute__((__deprecated__)) ;
#line 709
__inline extern size_t ( __attribute__((__warn_unused_result__, __artificial__, __always_inline__)) fread)(void * __restrict  __ptr ,
                                                                                                           size_t __size ,
                                                                                                           size_t __n ,
                                                                                                           FILE * __restrict  __stream ) ;
#line 737
__inline extern size_t ( __attribute__((__warn_unused_result__, __artificial__, __always_inline__)) fread_unlocked)(void * __restrict  __ptr ,
                                                                                                                    size_t __size ,
                                                                                                                    size_t __n ,
                                                                                                                    FILE * __restrict  __stream ) ;
#line 836
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__warn_unused_result__,
__leaf__)) feof_unlocked)(FILE *__stream ) ;
#line 837
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__warn_unused_result__,
__leaf__)) ferror_unlocked)(FILE *__stream ) ;
#line 43 "/usr/include/x86_64-linux-gnu/bits/stdio.h"
__inline extern int getchar(void) 
{ 
  int tmp ;

  {
#line 46
  tmp = _IO_getc(stdin);
#line 46
  return (tmp);
}
}
#line 52 "/usr/include/x86_64-linux-gnu/bits/stdio.h"
__inline extern int fgetc_unlocked(FILE *__fp ) 
{ 
  int tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  long tmp___3 ;

  {
#line 55
  tmp___3 = __builtin_expect((long )((unsigned long )__fp->_IO_read_ptr >= (unsigned long )__fp->_IO_read_end),
                             0L);
#line 55
  if (tmp___3) {
#line 55
    tmp___0 = __uflow(__fp);
#line 55
    tmp___2 = tmp___0;
  } else {
#line 55
    tmp___1 = __fp->_IO_read_ptr;
#line 55
    (__fp->_IO_read_ptr) ++;
#line 55
    tmp___2 = (int )*((unsigned char *)tmp___1);
  }
#line 55
  return (tmp___2);
}
}
#line 69 "/usr/include/x86_64-linux-gnu/bits/stdio.h"
__inline extern int getchar_unlocked(void) 
{ 
  int tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  long tmp___3 ;

  {
#line 72
  tmp___3 = __builtin_expect((long )((unsigned long )stdin->_IO_read_ptr >= (unsigned long )stdin->_IO_read_end),
                             0L);
#line 72
  if (tmp___3) {
#line 72
    tmp___0 = __uflow(stdin);
#line 72
    tmp___2 = tmp___0;
  } else {
#line 72
    tmp___1 = stdin->_IO_read_ptr;
#line 72
    (stdin->_IO_read_ptr) ++;
#line 72
    tmp___2 = (int )*((unsigned char *)tmp___1);
  }
#line 72
  return (tmp___2);
}
}
#line 78 "/usr/include/x86_64-linux-gnu/bits/stdio.h"
__inline extern int putchar(int __c ) 
{ 
  int tmp ;

  {
#line 81
  tmp = _IO_putc(__c, stdout);
#line 81
  return (tmp);
}
}
#line 87 "/usr/include/x86_64-linux-gnu/bits/stdio.h"
__inline extern int fputc_unlocked(int __c , FILE *__stream ) 
{ 
  int tmp___0 ;
  char *tmp___1 ;
  char tmp___2 ;
  int tmp___3 ;
  long tmp___4 ;

  {
#line 90
  tmp___4 = __builtin_expect((long )((unsigned long )__stream->_IO_write_ptr >= (unsigned long )__stream->_IO_write_end),
                             0L);
#line 90
  if (tmp___4) {
#line 90
    tmp___0 = __overflow(__stream, (int )((unsigned char )__c));
#line 90
    tmp___3 = tmp___0;
  } else {
#line 90
    tmp___1 = __stream->_IO_write_ptr;
#line 90
    (__stream->_IO_write_ptr) ++;
#line 90
    tmp___2 = (char )__c;
#line 90
    *tmp___1 = tmp___2;
#line 90
    tmp___3 = (int )((unsigned char )tmp___2);
  }
#line 90
  return (tmp___3);
}
}
#line 104 "/usr/include/x86_64-linux-gnu/bits/stdio.h"
__inline extern int putchar_unlocked(int __c ) 
{ 
  int tmp___0 ;
  char *tmp___1 ;
  char tmp___2 ;
  int tmp___3 ;
  long tmp___4 ;

  {
#line 107
  tmp___4 = __builtin_expect((long )((unsigned long )stdout->_IO_write_ptr >= (unsigned long )stdout->_IO_write_end),
                             0L);
#line 107
  if (tmp___4) {
#line 107
    tmp___0 = __overflow(stdout, (int )((unsigned char )__c));
#line 107
    tmp___3 = tmp___0;
  } else {
#line 107
    tmp___1 = stdout->_IO_write_ptr;
#line 107
    (stdout->_IO_write_ptr) ++;
#line 107
    tmp___2 = (char )__c;
#line 107
    *tmp___1 = tmp___2;
#line 107
    tmp___3 = (int )((unsigned char )tmp___2);
  }
#line 107
  return (tmp___3);
}
}
#line 124
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__warn_unused_result__,
__leaf__)) feof_unlocked)(FILE *__stream ) ;
#line 124 "/usr/include/x86_64-linux-gnu/bits/stdio.h"
__inline extern int ( __attribute__((__warn_unused_result__, __leaf__)) feof_unlocked)(FILE *__stream ) 
{ 


  {
#line 127
  return ((__stream->_flags & 16) != 0);
}
}
#line 131
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__warn_unused_result__,
__leaf__)) ferror_unlocked)(FILE *__stream ) ;
#line 131 "/usr/include/x86_64-linux-gnu/bits/stdio.h"
__inline extern int ( __attribute__((__warn_unused_result__, __leaf__)) ferror_unlocked)(FILE *__stream ) 
{ 


  {
#line 134
  return ((__stream->_flags & 32) != 0);
}
}
#line 30 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__, __artificial__,
__always_inline__)) sprintf)(char * __restrict  __s , char const   * __restrict  __fmt 
                             , ...) ;
#line 30 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern int ( __attribute__((__leaf__, __artificial__, __always_inline__)) sprintf)(char * __restrict  __s ,
                                                                                            char const   * __restrict  __fmt 
                                                                                            , ...) 
{ 
  unsigned long tmp ;
  int tmp___0 ;

  {
#line 33
  tmp = __builtin_object_size((void *)__s, 1);
#line 33
  tmp___0 = __builtin___sprintf_chk((char *)__s, 1, tmp, (char const   *)__fmt, __builtin_va_arg_pack());
#line 33
  return (tmp___0);
}
}
#line 42
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__, __artificial__,
__always_inline__)) vsprintf)(char * __restrict  __s , char const   * __restrict  __fmt ,
                              __gnuc_va_list __ap ) ;
#line 42 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern int ( __attribute__((__leaf__, __artificial__, __always_inline__)) vsprintf)(char * __restrict  __s ,
                                                                                             char const   * __restrict  __fmt ,
                                                                                             __gnuc_va_list __ap ) 
{ 
  unsigned long tmp ;
  int tmp___0 ;

  {
#line 46
  tmp = __builtin_object_size((void *)__s, 1);
#line 46
  tmp___0 = __builtin___vsprintf_chk((char *)__s, 1, tmp, (char const   *)__fmt, __ap);
#line 46
  return (tmp___0);
}
}
#line 60
__inline extern  __attribute__((__nothrow__)) int ( /* format attribute */ __attribute__((__leaf__,
__artificial__, __always_inline__)) snprintf)(char * __restrict  __s , size_t __n ,
                                              char const   * __restrict  __fmt  , ...) ;
#line 60 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern int ( /* format attribute */ __attribute__((__leaf__, __artificial__,
__always_inline__)) snprintf)(char * __restrict  __s , size_t __n , char const   * __restrict  __fmt 
                              , ...) 
{ 
  unsigned long tmp ;
  int tmp___0 ;

  {
#line 64
  tmp = __builtin_object_size((void *)__s, 1);
#line 64
  tmp___0 = __builtin___snprintf_chk((char *)__s, __n, 1, tmp, (char const   *)__fmt,
                                     __builtin_va_arg_pack());
#line 64
  return (tmp___0);
}
}
#line 73
__inline extern  __attribute__((__nothrow__)) int ( /* format attribute */ __attribute__((__leaf__,
__artificial__, __always_inline__)) vsnprintf)(char * __restrict  __s , size_t __n ,
                                               char const   * __restrict  __fmt ,
                                               __gnuc_va_list __ap ) ;
#line 73 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern int ( /* format attribute */ __attribute__((__leaf__, __artificial__,
__always_inline__)) vsnprintf)(char * __restrict  __s , size_t __n , char const   * __restrict  __fmt ,
                               __gnuc_va_list __ap ) 
{ 
  unsigned long tmp ;
  int tmp___0 ;

  {
#line 77
  tmp = __builtin_object_size((void *)__s, 1);
#line 77
  tmp___0 = __builtin___vsnprintf_chk((char *)__s, __n, 1, tmp, (char const   *)__fmt,
                                      __ap);
#line 77
  return (tmp___0);
}
}
#line 85
extern int __fprintf_chk(FILE * __restrict  __stream , int __flag , char const   * __restrict  __format 
                         , ...) ;
#line 87
extern int __printf_chk(int __flag , char const   * __restrict  __format  , ...) ;
#line 88
extern int __vfprintf_chk(FILE * __restrict  __stream , int __flag , char const   * __restrict  __format ,
                          __gnuc_va_list __ap ) ;
#line 94 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern int ( __attribute__((__artificial__, __always_inline__)) fprintf)(FILE * __restrict  __stream ,
                                                                                  char const   * __restrict  __fmt 
                                                                                  , ...) 
{ 
  int tmp ;

  {
#line 97
  tmp = __fprintf_chk(__stream, 1, __fmt, __builtin_va_arg_pack());
#line 97
  return (tmp);
}
}
#line 101 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern int ( __attribute__((__artificial__, __always_inline__)) printf)(char const   * __restrict  __fmt 
                                                                                 , ...) 
{ 
  int tmp ;

  {
#line 104
  tmp = __printf_chk(1, __fmt, __builtin_va_arg_pack());
#line 104
  return (tmp);
}
}
#line 113 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern int ( __attribute__((__artificial__, __always_inline__)) vprintf)(char const   * __restrict  __fmt ,
                                                                                  __gnuc_va_list __ap ) 
{ 
  int tmp ;

  {
#line 117
  tmp = __vfprintf_chk((FILE * __restrict  )stdout, 1, __fmt, __ap);
#line 117
  return (tmp);
}
}
#line 123 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern int ( __attribute__((__artificial__, __always_inline__)) vfprintf)(FILE * __restrict  __stream ,
                                                                                   char const   * __restrict  __fmt ,
                                                                                   __gnuc_va_list __ap ) 
{ 
  int tmp ;

  {
#line 127
  tmp = __vfprintf_chk(__stream, 1, __fmt, __ap);
#line 127
  return (tmp);
}
}
#line 131
extern int ( /* format attribute */  __dprintf_chk)(int __fd , int __flag , char const   * __restrict  __fmt 
                                                    , ...) ;
#line 133
extern int ( /* format attribute */  __vdprintf_chk)(int __fd , int __flag , char const   * __restrict  __fmt ,
                                                     __gnuc_va_list __arg ) ;
#line 138 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern int ( /* format attribute */ __attribute__((__artificial__, __always_inline__)) dprintf)(int __fd ,
                                                                                                         char const   * __restrict  __fmt 
                                                                                                         , ...) 
{ 
  int tmp ;

  {
#line 141
  tmp = __dprintf_chk(__fd, 1, __fmt, __builtin_va_arg_pack());
#line 141
  return (tmp);
}
}
#line 149 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern int ( /* format attribute */ __attribute__((__artificial__, __always_inline__)) vdprintf)(int __fd ,
                                                                                                          char const   * __restrict  __fmt ,
                                                                                                          __gnuc_va_list __ap ) 
{ 
  int tmp ;

  {
#line 152
  tmp = __vdprintf_chk(__fd, 1, __fmt, __ap);
#line 152
  return (tmp);
}
}
#line 227
extern char *( __attribute__((__warn_unused_result__)) __gets_chk)(char *__str , size_t  ) ;
#line 228
extern char *( __attribute__((__warn_unused_result__)) __gets_warn)(char *__str )  __asm__("gets") __attribute__((__warning__("please use fgets or getline instead, gets can\'t specify buffer size"))) ;
#line 232
__inline extern char *( __attribute__((__warn_unused_result__, __artificial__, __always_inline__)) gets)(char *__str )  __attribute__((__deprecated__)) ;
#line 232 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern char *( __attribute__((__warn_unused_result__, __artificial__, __always_inline__)) gets)(char *__str ) 
{ 
  unsigned long tmp ;
  char *tmp___0 ;
  unsigned long tmp___1 ;
  char *tmp___2 ;

  {
#line 235
  tmp___1 = __builtin_object_size((void *)__str, 1);
#line 235
  if (tmp___1 != 0xffffffffffffffffUL) {
#line 236
    tmp = __builtin_object_size((void *)__str, 1);
#line 236
    tmp___0 = __gets_chk(__str, tmp);
#line 236
    return (tmp___0);
  }
#line 237
  tmp___2 = __gets_warn(__str);
#line 237
  return (tmp___2);
}
}
#line 241
extern char *( __attribute__((__warn_unused_result__)) __fgets_chk)(char * __restrict  __s ,
                                                                    size_t __size ,
                                                                    int __n , FILE * __restrict  __stream ) ;
#line 243
extern char *( __attribute__((__warn_unused_result__)) __fgets_alias)(char * __restrict  __s ,
                                                                      int __n , FILE * __restrict  __stream )  __asm__("fgets")  ;
#line 246
extern char *( __attribute__((__warn_unused_result__)) __fgets_chk_warn)(char * __restrict  __s ,
                                                                         size_t __size ,
                                                                         int __n ,
                                                                         FILE * __restrict  __stream )  __asm__("__fgets_chk") __attribute__((__warning__("fgets called with bigger size than length of destination buffer"))) ;
#line 252 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern char *( __attribute__((__warn_unused_result__, __artificial__, __always_inline__)) fgets)(char * __restrict  __s ,
                                                                                                          int __n ,
                                                                                                          FILE * __restrict  __stream ) 
{ 
  unsigned long tmp ;
  char *tmp___0 ;
  unsigned long tmp___1 ;
  char *tmp___2 ;
  unsigned long tmp___3 ;
  unsigned long tmp___4 ;
  char *tmp___5 ;

  {
#line 255
  tmp___4 = __builtin_object_size((void *)__s, 1);
#line 255
  if (tmp___4 != 0xffffffffffffffffUL) {
#line 258
    tmp = __builtin_object_size((void *)__s, 1);
#line 258
    tmp___0 = __fgets_chk(__s, tmp, __n, __stream);
#line 258
    return (tmp___0);
#line 260
    tmp___3 = __builtin_object_size((void *)__s, 1);
#line 260
    if ((size_t )__n > tmp___3) {
#line 261
      tmp___1 = __builtin_object_size((void *)__s, 1);
#line 261
      tmp___2 = __fgets_chk_warn(__s, tmp___1, __n, __stream);
#line 261
      return (tmp___2);
    }
  }
#line 263
  tmp___5 = __fgets_alias(__s, __n, __stream);
#line 263
  return (tmp___5);
}
}
#line 266
extern size_t ( __attribute__((__warn_unused_result__)) __fread_chk)(void * __restrict  __ptr ,
                                                                     size_t __ptrlen ,
                                                                     size_t __size ,
                                                                     size_t __n ,
                                                                     FILE * __restrict  __stream ) ;
#line 269
extern size_t ( __attribute__((__warn_unused_result__)) __fread_alias)(void * __restrict  __ptr ,
                                                                       size_t __size ,
                                                                       size_t __n ,
                                                                       FILE * __restrict  __stream )  __asm__("fread")  ;
#line 273
extern size_t ( __attribute__((__warn_unused_result__)) __fread_chk_warn)(void * __restrict  __ptr ,
                                                                          size_t __ptrlen ,
                                                                          size_t __size ,
                                                                          size_t __n ,
                                                                          FILE * __restrict  __stream )  __asm__("__fread_chk") __attribute__((__warning__("fread called with bigger size * nmemb than length of destination buffer"))) ;
#line 281 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern size_t ( __attribute__((__warn_unused_result__, __artificial__, __always_inline__)) fread)(void * __restrict  __ptr ,
                                                                                                           size_t __size ,
                                                                                                           size_t __n ,
                                                                                                           FILE * __restrict  __stream ) 
{ 
  unsigned long tmp ;
  size_t tmp___0 ;
  unsigned long tmp___1 ;
  size_t tmp___2 ;
  unsigned long tmp___3 ;
  unsigned long tmp___4 ;
  size_t tmp___5 ;

  {
#line 285
  tmp___4 = __builtin_object_size((void *)__ptr, 0);
#line 285
  if (tmp___4 != 0xffffffffffffffffUL) {
#line 290
    tmp = __builtin_object_size((void *)__ptr, 0);
#line 290
    tmp___0 = __fread_chk(__ptr, tmp, __size, __n, __stream);
#line 290
    return (tmp___0);
#line 292
    tmp___3 = __builtin_object_size((void *)__ptr, 0);
#line 292
    if (__size * __n > tmp___3) {
#line 293
      tmp___1 = __builtin_object_size((void *)__ptr, 0);
#line 293
      tmp___2 = __fread_chk_warn(__ptr, tmp___1, __size, __n, __stream);
#line 293
      return (tmp___2);
    }
  }
#line 295
  tmp___5 = __fread_alias(__ptr, __size, __n, __stream);
#line 295
  return (tmp___5);
}
}
#line 327
extern size_t ( __attribute__((__warn_unused_result__)) __fread_unlocked_chk)(void * __restrict  __ptr ,
                                                                              size_t __ptrlen ,
                                                                              size_t __size ,
                                                                              size_t __n ,
                                                                              FILE * __restrict  __stream ) ;
#line 330
extern size_t ( __attribute__((__warn_unused_result__)) __fread_unlocked_alias)(void * __restrict  __ptr ,
                                                                                size_t __size ,
                                                                                size_t __n ,
                                                                                FILE * __restrict  __stream )  __asm__("fread_unlocked")  ;
#line 334
extern size_t ( __attribute__((__warn_unused_result__)) __fread_unlocked_chk_warn)(void * __restrict  __ptr ,
                                                                                   size_t __ptrlen ,
                                                                                   size_t __size ,
                                                                                   size_t __n ,
                                                                                   FILE * __restrict  __stream )  __asm__("__fread_unlocked_chk") __attribute__((__warning__("fread_unlocked called with bigger size * nmemb than length of destination buffer"))) ;
#line 342 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern size_t ( __attribute__((__warn_unused_result__, __artificial__, __always_inline__)) fread_unlocked)(void * __restrict  __ptr ,
                                                                                                                    size_t __size ,
                                                                                                                    size_t __n ,
                                                                                                                    FILE * __restrict  __stream ) 
{ 
  unsigned long tmp ;
  size_t tmp___0 ;
  unsigned long tmp___1 ;
  size_t tmp___2 ;
  unsigned long tmp___3 ;
  unsigned long tmp___4 ;
  size_t tmp___11 ;

  {
#line 346
  tmp___4 = __builtin_object_size((void *)__ptr, 0);
#line 346
  if (tmp___4 != 0xffffffffffffffffUL) {
#line 351
    tmp = __builtin_object_size((void *)__ptr, 0);
#line 351
    tmp___0 = __fread_unlocked_chk(__ptr, tmp, __size, __n, __stream);
#line 351
    return (tmp___0);
#line 354
    tmp___3 = __builtin_object_size((void *)__ptr, 0);
#line 354
    if (__size * __n > tmp___3) {
#line 355
      tmp___1 = __builtin_object_size((void *)__ptr, 0);
#line 355
      tmp___2 = __fread_unlocked_chk_warn(__ptr, tmp___1, __size, __n, __stream);
#line 355
      return (tmp___2);
    }
  }
#line 380
  tmp___11 = __fread_unlocked_alias(__ptr, __size, __n, __stream);
#line 380
  return (tmp___11);
}
}
#line 144 "/usr/include/stdlib.h"
__inline extern  __attribute__((__nothrow__)) double ( __attribute__((__warn_unused_result__,
__nonnull__(1), __leaf__)) atof)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 147
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__warn_unused_result__,
__nonnull__(1), __leaf__)) atoi)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 150
__inline extern  __attribute__((__nothrow__)) long ( __attribute__((__warn_unused_result__,
__nonnull__(1), __leaf__)) atol)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 157
__inline extern  __attribute__((__nothrow__)) long long ( __attribute__((__warn_unused_result__,
__nonnull__(1), __leaf__)) atoll)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 164
extern  __attribute__((__nothrow__)) double ( __attribute__((__nonnull__(1), __leaf__)) strtod)(char const   * __restrict  __nptr ,
                                                                                                char ** __restrict  __endptr ) ;
#line 183
extern  __attribute__((__nothrow__)) long ( __attribute__((__nonnull__(1), __leaf__)) strtol)(char const   * __restrict  __nptr ,
                                                                                              char ** __restrict  __endptr ,
                                                                                              int __base ) ;
#line 209
extern  __attribute__((__nothrow__)) long long ( __attribute__((__nonnull__(1), __leaf__)) strtoll)(char const   * __restrict  __nptr ,
                                                                                                    char ** __restrict  __endptr ,
                                                                                                    int __base ) ;
#line 277
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__warn_unused_result__,
__nonnull__(1), __leaf__)) atoi)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 277 "/usr/include/stdlib.h"
__inline extern int ( __attribute__((__warn_unused_result__, __nonnull__(1), __leaf__)) atoi)(char const   *__nptr ) 
{ 
  long tmp ;

  {
#line 280
  tmp = strtol((char const   * __restrict  )__nptr, (char ** __restrict  )((char **)((void *)0)),
               10);
#line 280
  return ((int )tmp);
}
}
#line 282
__inline extern  __attribute__((__nothrow__)) long ( __attribute__((__warn_unused_result__,
__nonnull__(1), __leaf__)) atol)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 282 "/usr/include/stdlib.h"
__inline extern long ( __attribute__((__warn_unused_result__, __nonnull__(1), __leaf__)) atol)(char const   *__nptr ) 
{ 
  long tmp ;

  {
#line 285
  tmp = strtol((char const   * __restrict  )__nptr, (char ** __restrict  )((char **)((void *)0)),
               10);
#line 285
  return (tmp);
}
}
#line 291
__inline extern  __attribute__((__nothrow__)) long long ( __attribute__((__warn_unused_result__,
__nonnull__(1), __leaf__)) atoll)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 291 "/usr/include/stdlib.h"
__inline extern long long ( __attribute__((__warn_unused_result__, __nonnull__(1),
__leaf__)) atoll)(char const   *__nptr ) 
{ 
  long long tmp ;

  {
#line 294
  tmp = strtoll((char const   * __restrict  )__nptr, (char ** __restrict  )((char **)((void *)0)),
                10);
#line 294
  return (tmp);
}
}
#line 32 "/usr/include/x86_64-linux-gnu/sys/sysmacros.h"
__inline extern  __attribute__((__nothrow__)) unsigned int ( __attribute__((__leaf__)) gnu_dev_major)(unsigned long long __dev )  __attribute__((__const__)) ;
#line 35
__inline extern  __attribute__((__nothrow__)) unsigned int ( __attribute__((__leaf__)) gnu_dev_minor)(unsigned long long __dev )  __attribute__((__const__)) ;
#line 38
__inline extern  __attribute__((__nothrow__)) unsigned long long ( __attribute__((__leaf__)) gnu_dev_makedev)(unsigned int __major ,
                                                                                                              unsigned int __minor )  __attribute__((__const__)) ;
#line 43
__inline extern  __attribute__((__nothrow__)) unsigned int ( __attribute__((__leaf__)) gnu_dev_major)(unsigned long long __dev )  __attribute__((__const__)) ;
#line 43 "/usr/include/x86_64-linux-gnu/sys/sysmacros.h"
__inline extern unsigned int ( __attribute__((__leaf__)) gnu_dev_major)(unsigned long long __dev ) 
{ 


  {
#line 46
  return ((unsigned int )(((__dev >> 8) & 4095ULL) | (unsigned long long )((unsigned int )(__dev >> 32) & 4294963200U)));
}
}
#line 49
__inline extern  __attribute__((__nothrow__)) unsigned int ( __attribute__((__leaf__)) gnu_dev_minor)(unsigned long long __dev )  __attribute__((__const__)) ;
#line 49 "/usr/include/x86_64-linux-gnu/sys/sysmacros.h"
__inline extern unsigned int ( __attribute__((__leaf__)) gnu_dev_minor)(unsigned long long __dev ) 
{ 


  {
#line 52
  return ((unsigned int )((__dev & 255ULL) | (unsigned long long )((unsigned int )(__dev >> 12) & 4294967040U)));
}
}
#line 55
__inline extern  __attribute__((__nothrow__)) unsigned long long ( __attribute__((__leaf__)) gnu_dev_makedev)(unsigned int __major ,
                                                                                                              unsigned int __minor )  __attribute__((__const__)) ;
#line 55 "/usr/include/x86_64-linux-gnu/sys/sysmacros.h"
__inline extern unsigned long long ( __attribute__((__leaf__)) gnu_dev_makedev)(unsigned int __major ,
                                                                                unsigned int __minor ) 
{ 


  {
#line 58
  return (((unsigned long long )((__minor & 255U) | ((__major & 4095U) << 8)) | ((unsigned long long )(__minor & 4294967040U) << 12)) | ((unsigned long long )(__major & 4294963200U) << 32));
}
}
#line 733 "/usr/include/stdlib.h"
__inline extern  __attribute__((__nothrow__)) char *( __attribute__((__warn_unused_result__,
__leaf__, __artificial__, __always_inline__)) realpath)(char const   * __restrict  __name ,
                                                        char * __restrict  __resolved ) ;
#line 866
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__warn_unused_result__,
__leaf__, __artificial__, __always_inline__)) wctomb)(char *__s , wchar_t __wchar ) ;
#line 870
__inline extern  __attribute__((__nothrow__)) size_t ( __attribute__((__leaf__, __artificial__,
__always_inline__)) mbstowcs)(wchar_t * __restrict  __dst , char const   * __restrict  __src ,
                              size_t __len ) ;
#line 873
__inline extern  __attribute__((__nothrow__)) size_t ( __attribute__((__leaf__, __artificial__,
__always_inline__)) wcstombs)(char * __restrict  __dst , wchar_t const   * __restrict  __src ,
                              size_t __len ) ;
#line 25 "/usr/include/x86_64-linux-gnu/bits/stdlib-float.h"
__inline extern  __attribute__((__nothrow__)) double ( __attribute__((__warn_unused_result__,
__nonnull__(1), __leaf__)) atof)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 25 "/usr/include/x86_64-linux-gnu/bits/stdlib-float.h"
__inline extern double ( __attribute__((__warn_unused_result__, __nonnull__(1), __leaf__)) atof)(char const   *__nptr ) 
{ 
  double tmp ;

  {
#line 28
  tmp = strtod((char const   * __restrict  )__nptr, (char ** __restrict  )((char **)((void *)0)));
#line 28
  return (tmp);
}
}
#line 23 "/usr/include/x86_64-linux-gnu/bits/stdlib.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__warn_unused_result__,
__leaf__)) __realpath_chk)(char const   * __restrict  __name , char * __restrict  __resolved ,
                           size_t __resolvedlen ) ;
#line 26
extern  __attribute__((__nothrow__)) char *( __attribute__((__warn_unused_result__,
__leaf__)) __realpath_alias)(char const   * __restrict  __name , char * __restrict  __resolved )  __asm__("realpath")  ;
#line 36
__inline extern  __attribute__((__nothrow__)) char *( __attribute__((__warn_unused_result__,
__leaf__, __artificial__, __always_inline__)) realpath)(char const   * __restrict  __name ,
                                                        char * __restrict  __resolved ) ;
#line 36 "/usr/include/x86_64-linux-gnu/bits/stdlib.h"
__inline extern char *( __attribute__((__warn_unused_result__, __leaf__, __artificial__,
__always_inline__)) realpath)(char const   * __restrict  __name , char * __restrict  __resolved ) 
{ 
  unsigned long tmp ;
  char *tmp___0 ;
  unsigned long tmp___1 ;
  char *tmp___2 ;

  {
#line 39
  tmp___1 = __builtin_object_size((void *)__resolved, 1);
#line 39
  if (tmp___1 != 0xffffffffffffffffUL) {
#line 45
    tmp = __builtin_object_size((void *)__resolved, 1);
#line 45
    tmp___0 = __realpath_chk(__name, __resolved, tmp);
#line 45
    return (tmp___0);
  }
#line 48
  tmp___2 = __realpath_alias(__name, __resolved);
#line 48
  return (tmp___2);
}
}
#line 52
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2), __leaf__)) __ptsname_r_chk)(int __fd ,
                                                                                                      char *__buf ,
                                                                                                      size_t __buflen ,
                                                                                                      size_t __nreal ) ;
#line 54
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2), __leaf__)) __ptsname_r_alias)(int __fd ,
                                                                                                        char *__buf ,
                                                                                                        size_t __buflen )  __asm__("ptsname_r")  ;
#line 57
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2), __leaf__)) __ptsname_r_chk_warn)(int __fd ,
                                                                                                           char *__buf ,
                                                                                                           size_t __buflen ,
                                                                                                           size_t __nreal )  __asm__("__ptsname_r_chk") __attribute__((__warning__("ptsname_r called with buflen bigger than size of buf"))) ;
#line 63
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__, __artificial__,
__always_inline__)) ptsname_r)(int __fd , char *__buf , size_t __buflen ) ;
#line 63 "/usr/include/x86_64-linux-gnu/bits/stdlib.h"
__inline extern int ( __attribute__((__leaf__, __artificial__, __always_inline__)) ptsname_r)(int __fd ,
                                                                                              char *__buf ,
                                                                                              size_t __buflen ) 
{ 
  unsigned long tmp ;
  int tmp___0 ;
  unsigned long tmp___1 ;
  int tmp___2 ;
  unsigned long tmp___3 ;
  unsigned long tmp___4 ;
  int tmp___5 ;

  {
#line 66
  tmp___4 = __builtin_object_size((void *)__buf, 1);
#line 66
  if (tmp___4 != 0xffffffffffffffffUL) {
#line 69
    tmp = __builtin_object_size((void *)__buf, 1);
#line 69
    tmp___0 = __ptsname_r_chk(__fd, __buf, __buflen, tmp);
#line 69
    return (tmp___0);
#line 70
    tmp___3 = __builtin_object_size((void *)__buf, 1);
#line 70
    if (__buflen > tmp___3) {
#line 71
      tmp___1 = __builtin_object_size((void *)__buf, 1);
#line 71
      tmp___2 = __ptsname_r_chk_warn(__fd, __buf, __buflen, tmp___1);
#line 71
      return (tmp___2);
    }
  }
#line 73
  tmp___5 = __ptsname_r_alias(__fd, __buf, __buflen);
#line 73
  return (tmp___5);
}
}
#line 77
extern  __attribute__((__nothrow__)) int ( __attribute__((__warn_unused_result__,
__leaf__)) __wctomb_chk)(char *__s , wchar_t __wchar , size_t __buflen ) ;
#line 79
extern  __attribute__((__nothrow__)) int ( __attribute__((__warn_unused_result__,
__leaf__)) __wctomb_alias)(char *__s , wchar_t __wchar )  __asm__("wctomb")  ;
#line 82
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__warn_unused_result__,
__leaf__, __artificial__, __always_inline__)) wctomb)(char *__s , wchar_t __wchar ) ;
#line 82 "/usr/include/x86_64-linux-gnu/bits/stdlib.h"
__inline extern int ( __attribute__((__warn_unused_result__, __leaf__, __artificial__,
__always_inline__)) wctomb)(char *__s , wchar_t __wchar ) 
{ 
  unsigned long tmp ;
  int tmp___0 ;
  unsigned long tmp___1 ;
  unsigned long tmp___2 ;
  int tmp___3 ;

  {
#line 92
  tmp___1 = __builtin_object_size((void *)__s, 1);
#line 92
  if (tmp___1 != 0xffffffffffffffffUL) {
#line 92
    tmp___2 = __builtin_object_size((void *)__s, 1);
#line 92
    if (16UL > tmp___2) {
#line 93
      tmp = __builtin_object_size((void *)__s, 1);
#line 93
      tmp___0 = __wctomb_chk(__s, __wchar, tmp);
#line 93
      return (tmp___0);
    }
  }
#line 94
  tmp___3 = __wctomb_alias(__s, __wchar);
#line 94
  return (tmp___3);
}
}
#line 98
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__leaf__)) __mbstowcs_chk)(wchar_t * __restrict  __dst ,
                                                                                        char const   * __restrict  __src ,
                                                                                        size_t __len ,
                                                                                        size_t __dstlen ) ;
#line 101
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__leaf__)) __mbstowcs_alias)(wchar_t * __restrict  __dst ,
                                                                                          char const   * __restrict  __src ,
                                                                                          size_t __len )  __asm__("mbstowcs")  ;
#line 105
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__leaf__)) __mbstowcs_chk_warn)(wchar_t * __restrict  __dst ,
                                                                                             char const   * __restrict  __src ,
                                                                                             size_t __len ,
                                                                                             size_t __dstlen )  __asm__("__mbstowcs_chk") __attribute__((__warning__("mbstowcs called with dst buffer smaller than len * sizeof (wchar_t)"))) ;
#line 112
__inline extern  __attribute__((__nothrow__)) size_t ( __attribute__((__leaf__, __artificial__,
__always_inline__)) mbstowcs)(wchar_t * __restrict  __dst , char const   * __restrict  __src ,
                              size_t __len ) ;
#line 112 "/usr/include/x86_64-linux-gnu/bits/stdlib.h"
__inline extern size_t ( __attribute__((__leaf__, __artificial__, __always_inline__)) mbstowcs)(wchar_t * __restrict  __dst ,
                                                                                                char const   * __restrict  __src ,
                                                                                                size_t __len ) 
{ 
  unsigned long tmp ;
  size_t tmp___0 ;
  unsigned long tmp___1 ;
  size_t tmp___2 ;
  unsigned long tmp___3 ;
  unsigned long tmp___4 ;
  size_t tmp___5 ;

  {
#line 116
  tmp___4 = __builtin_object_size((void *)__dst, 1);
#line 116
  if (tmp___4 != 0xffffffffffffffffUL) {
#line 119
    tmp = __builtin_object_size((void *)__dst, 1);
#line 119
    tmp___0 = __mbstowcs_chk(__dst, __src, __len, tmp / sizeof(wchar_t ));
#line 119
    return (tmp___0);
#line 122
    tmp___3 = __builtin_object_size((void *)__dst, 1);
#line 122
    if (__len > tmp___3 / sizeof(wchar_t )) {
#line 123
      tmp___1 = __builtin_object_size((void *)__dst, 1);
#line 123
      tmp___2 = __mbstowcs_chk_warn(__dst, __src, __len, tmp___1 / sizeof(wchar_t ));
#line 123
      return (tmp___2);
    }
  }
#line 126
  tmp___5 = __mbstowcs_alias(__dst, __src, __len);
#line 126
  return (tmp___5);
}
}
#line 130
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__leaf__)) __wcstombs_chk)(char * __restrict  __dst ,
                                                                                        wchar_t const   * __restrict  __src ,
                                                                                        size_t __len ,
                                                                                        size_t __dstlen ) ;
#line 133
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__leaf__)) __wcstombs_alias)(char * __restrict  __dst ,
                                                                                          wchar_t const   * __restrict  __src ,
                                                                                          size_t __len )  __asm__("wcstombs")  ;
#line 137
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__leaf__)) __wcstombs_chk_warn)(char * __restrict  __dst ,
                                                                                             wchar_t const   * __restrict  __src ,
                                                                                             size_t __len ,
                                                                                             size_t __dstlen )  __asm__("__wcstombs_chk") __attribute__((__warning__("wcstombs called with dst buffer smaller than len"))) ;
#line 143
__inline extern  __attribute__((__nothrow__)) size_t ( __attribute__((__leaf__, __artificial__,
__always_inline__)) wcstombs)(char * __restrict  __dst , wchar_t const   * __restrict  __src ,
                              size_t __len ) ;
#line 143 "/usr/include/x86_64-linux-gnu/bits/stdlib.h"
__inline extern size_t ( __attribute__((__leaf__, __artificial__, __always_inline__)) wcstombs)(char * __restrict  __dst ,
                                                                                                wchar_t const   * __restrict  __src ,
                                                                                                size_t __len ) 
{ 
  unsigned long tmp ;
  size_t tmp___0 ;
  unsigned long tmp___1 ;
  size_t tmp___2 ;
  unsigned long tmp___3 ;
  unsigned long tmp___4 ;
  size_t tmp___5 ;

  {
#line 147
  tmp___4 = __builtin_object_size((void *)__dst, 1);
#line 147
  if (tmp___4 != 0xffffffffffffffffUL) {
#line 150
    tmp = __builtin_object_size((void *)__dst, 1);
#line 150
    tmp___0 = __wcstombs_chk(__dst, __src, __len, tmp);
#line 150
    return (tmp___0);
#line 151
    tmp___3 = __builtin_object_size((void *)__dst, 1);
#line 151
    if (__len > tmp___3) {
#line 152
      tmp___1 = __builtin_object_size((void *)__dst, 1);
#line 152
      tmp___2 = __wcstombs_chk_warn(__dst, __src, __len, tmp___1);
#line 152
      return (tmp___2);
    }
  }
#line 154
  tmp___5 = __wcstombs_alias(__dst, __src, __len);
#line 154
  return (tmp___5);
}
}
#line 360 "/usr/include/unistd.h"
__inline extern ssize_t ( __attribute__((__warn_unused_result__, __artificial__, __always_inline__)) read)(int __fd ,
                                                                                                           void *__buf ,
                                                                                                           size_t __nbytes ) ;
#line 511
__inline extern  __attribute__((__nothrow__)) char *( __attribute__((__warn_unused_result__,
__leaf__, __artificial__, __always_inline__)) getcwd)(char *__buf , size_t __size ) ;
#line 525
__inline extern  __attribute__((__nothrow__)) char __attribute__((__deprecated__))  *( __attribute__((__warn_unused_result__,
__nonnull__(1), __leaf__, __artificial__, __always_inline__)) getwd)(char *__buf )  __attribute__((__deprecated__)) ;
#line 623
__inline extern  __attribute__((__nothrow__)) size_t ( __attribute__((__leaf__, __artificial__,
__always_inline__)) confstr)(int __name , char *__buf , size_t __len ) ;
#line 711
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__warn_unused_result__,
__leaf__, __artificial__, __always_inline__)) getgroups)(int __size , __gid_t *__list ) ;
#line 796
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__warn_unused_result__,
__nonnull__(2), __leaf__, __artificial__, __always_inline__)) ttyname_r)(int __fd ,
                                                                         char *__buf ,
                                                                         size_t __buflen ) ;
#line 831
__inline extern  __attribute__((__nothrow__)) ssize_t ( __attribute__((__warn_unused_result__,
__nonnull__(1,2), __leaf__, __artificial__, __always_inline__)) readlink)(char const   * __restrict  __path ,
                                                                          char * __restrict  __buf ,
                                                                          size_t __len ) ;
#line 842
__inline extern  __attribute__((__nothrow__)) ssize_t ( __attribute__((__warn_unused_result__,
__nonnull__(2,3), __leaf__, __artificial__, __always_inline__)) readlinkat)(int __fd ,
                                                                            char const   * __restrict  __path ,
                                                                            char * __restrict  __buf ,
                                                                            size_t __len ) ;
#line 879
__inline extern int ( __attribute__((__nonnull__(1), __artificial__, __always_inline__)) getlogin_r)(char *__buf ,
                                                                                                     size_t __buflen ) ;
#line 901
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1),
__leaf__, __artificial__, __always_inline__)) gethostname)(char *__buf , size_t __buflen ) ;
#line 919
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__warn_unused_result__,
__nonnull__(1), __leaf__, __artificial__, __always_inline__)) getdomainname)(char *__buf ,
                                                                             size_t __buflen ) ;
#line 23 "/usr/include/x86_64-linux-gnu/bits/unistd.h"
extern ssize_t ( __attribute__((__warn_unused_result__)) __read_chk)(int __fd , void *__buf ,
                                                                     size_t __nbytes ,
                                                                     size_t __buflen ) ;
#line 25
extern ssize_t ( __attribute__((__warn_unused_result__)) __read_alias)(int __fd ,
                                                                       void *__buf ,
                                                                       size_t __nbytes )  __asm__("read")  ;
#line 27
extern ssize_t ( __attribute__((__warn_unused_result__)) __read_chk_warn)(int __fd ,
                                                                          void *__buf ,
                                                                          size_t __nbytes ,
                                                                          size_t __buflen )  __asm__("__read_chk") __attribute__((__warning__("read called with bigger length than size of the destination buffer"))) ;
#line 33 "/usr/include/x86_64-linux-gnu/bits/unistd.h"
__inline extern ssize_t ( __attribute__((__warn_unused_result__, __artificial__, __always_inline__)) read)(int __fd ,
                                                                                                           void *__buf ,
                                                                                                           size_t __nbytes ) 
{ 
  unsigned long tmp ;
  ssize_t tmp___0 ;
  unsigned long tmp___1 ;
  ssize_t tmp___2 ;
  unsigned long tmp___3 ;
  unsigned long tmp___4 ;
  ssize_t tmp___5 ;

  {
#line 36
  tmp___4 = __builtin_object_size(__buf, 0);
#line 36
  if (tmp___4 != 0xffffffffffffffffUL) {
#line 39
    tmp = __builtin_object_size(__buf, 0);
#line 39
    tmp___0 = __read_chk(__fd, __buf, __nbytes, tmp);
#line 39
    return (tmp___0);
#line 41
    tmp___3 = __builtin_object_size(__buf, 0);
#line 41
    if (__nbytes > tmp___3) {
#line 42
      tmp___1 = __builtin_object_size(__buf, 0);
#line 42
      tmp___2 = __read_chk_warn(__fd, __buf, __nbytes, tmp___1);
#line 42
      return (tmp___2);
    }
  }
#line 44
  tmp___5 = __read_alias(__fd, __buf, __nbytes);
#line 44
  return (tmp___5);
}
}
#line 123
extern  __attribute__((__nothrow__)) ssize_t ( __attribute__((__warn_unused_result__,
__nonnull__(1,2), __leaf__)) __readlink_chk)(char const   * __restrict  __path , char * __restrict  __buf ,
                                             size_t __len , size_t __buflen ) ;
#line 127
extern  __attribute__((__nothrow__)) ssize_t ( __attribute__((__warn_unused_result__,
__nonnull__(1,2), __leaf__)) __readlink_alias)(char const   * __restrict  __path ,
                                               char * __restrict  __buf , size_t __len )  __asm__("readlink")  ;
#line 131
extern  __attribute__((__nothrow__)) ssize_t ( __attribute__((__warn_unused_result__,
__nonnull__(1,2), __leaf__)) __readlink_chk_warn)(char const   * __restrict  __path ,
                                                  char * __restrict  __buf , size_t __len ,
                                                  size_t __buflen )  __asm__("__readlink_chk") __attribute__((__warning__("readlink called with bigger length than size of destination buffer"))) ;
#line 138
__inline extern  __attribute__((__nothrow__)) ssize_t ( __attribute__((__warn_unused_result__,
__nonnull__(1,2), __leaf__, __artificial__, __always_inline__)) readlink)(char const   * __restrict  __path ,
                                                                          char * __restrict  __buf ,
                                                                          size_t __len ) ;
#line 138 "/usr/include/x86_64-linux-gnu/bits/unistd.h"
__inline extern ssize_t ( __attribute__((__warn_unused_result__, __nonnull__(1,2),
__leaf__, __artificial__, __always_inline__)) readlink)(char const   * __restrict  __path ,
                                                        char * __restrict  __buf ,
                                                        size_t __len ) 
{ 
  unsigned long tmp ;
  ssize_t tmp___0 ;
  unsigned long tmp___1 ;
  ssize_t tmp___2 ;
  unsigned long tmp___3 ;
  unsigned long tmp___4 ;
  ssize_t tmp___5 ;

  {
#line 142
  tmp___4 = __builtin_object_size((void *)__buf, 1);
#line 142
  if (tmp___4 != 0xffffffffffffffffUL) {
#line 145
    tmp = __builtin_object_size((void *)__buf, 1);
#line 145
    tmp___0 = __readlink_chk(__path, __buf, __len, tmp);
#line 145
    return (tmp___0);
#line 147
    tmp___3 = __builtin_object_size((void *)__buf, 1);
#line 147
    if (__len > tmp___3) {
#line 148
      tmp___1 = __builtin_object_size((void *)__buf, 1);
#line 148
      tmp___2 = __readlink_chk_warn(__path, __buf, __len, tmp___1);
#line 148
      return (tmp___2);
    }
  }
#line 150
  tmp___5 = __readlink_alias(__path, __buf, __len);
#line 150
  return (tmp___5);
}
}
#line 155
extern  __attribute__((__nothrow__)) ssize_t ( __attribute__((__warn_unused_result__,
__nonnull__(2,3), __leaf__)) __readlinkat_chk)(int __fd , char const   * __restrict  __path ,
                                               char * __restrict  __buf , size_t __len ,
                                               size_t __buflen ) ;
#line 159
extern  __attribute__((__nothrow__)) ssize_t ( __attribute__((__warn_unused_result__,
__nonnull__(2,3), __leaf__)) __readlinkat_alias)(int __fd , char const   * __restrict  __path ,
                                                 char * __restrict  __buf , size_t __len )  __asm__("readlinkat")  ;
#line 164
extern  __attribute__((__nothrow__)) ssize_t ( __attribute__((__warn_unused_result__,
__nonnull__(2,3), __leaf__)) __readlinkat_chk_warn)(int __fd , char const   * __restrict  __path ,
                                                    char * __restrict  __buf , size_t __len ,
                                                    size_t __buflen )  __asm__("__readlinkat_chk") __attribute__((__warning__("readlinkat called with bigger length than size of destination buffer"))) ;
#line 172
__inline extern  __attribute__((__nothrow__)) ssize_t ( __attribute__((__warn_unused_result__,
__nonnull__(2,3), __leaf__, __artificial__, __always_inline__)) readlinkat)(int __fd ,
                                                                            char const   * __restrict  __path ,
                                                                            char * __restrict  __buf ,
                                                                            size_t __len ) ;
#line 172 "/usr/include/x86_64-linux-gnu/bits/unistd.h"
__inline extern ssize_t ( __attribute__((__warn_unused_result__, __nonnull__(2,3),
__leaf__, __artificial__, __always_inline__)) readlinkat)(int __fd , char const   * __restrict  __path ,
                                                          char * __restrict  __buf ,
                                                          size_t __len ) 
{ 
  unsigned long tmp ;
  ssize_t tmp___0 ;
  unsigned long tmp___1 ;
  ssize_t tmp___2 ;
  unsigned long tmp___3 ;
  unsigned long tmp___4 ;
  ssize_t tmp___5 ;

  {
#line 176
  tmp___4 = __builtin_object_size((void *)__buf, 1);
#line 176
  if (tmp___4 != 0xffffffffffffffffUL) {
#line 179
    tmp = __builtin_object_size((void *)__buf, 1);
#line 179
    tmp___0 = __readlinkat_chk(__fd, __path, __buf, __len, tmp);
#line 179
    return (tmp___0);
#line 181
    tmp___3 = __builtin_object_size((void *)__buf, 1);
#line 181
    if (__len > tmp___3) {
#line 182
      tmp___1 = __builtin_object_size((void *)__buf, 1);
#line 182
      tmp___2 = __readlinkat_chk_warn(__fd, __path, __buf, __len, tmp___1);
#line 182
      return (tmp___2);
    }
  }
#line 185
  tmp___5 = __readlinkat_alias(__fd, __path, __buf, __len);
#line 185
  return (tmp___5);
}
}
#line 189
extern  __attribute__((__nothrow__)) char *( __attribute__((__warn_unused_result__,
__leaf__)) __getcwd_chk)(char *__buf , size_t __size , size_t __buflen ) ;
#line 191
extern  __attribute__((__nothrow__)) char *( __attribute__((__warn_unused_result__,
__leaf__)) __getcwd_alias)(char *__buf , size_t __size )  __asm__("getcwd")  ;
#line 193
extern  __attribute__((__nothrow__)) char *( __attribute__((__warn_unused_result__,
__leaf__)) __getcwd_chk_warn)(char *__buf , size_t __size , size_t __buflen )  __asm__("__getcwd_chk") __attribute__((__warning__("getcwd caller with bigger length than size of destination buffer"))) ;
#line 199
__inline extern  __attribute__((__nothrow__)) char *( __attribute__((__warn_unused_result__,
__leaf__, __artificial__, __always_inline__)) getcwd)(char *__buf , size_t __size ) ;
#line 199 "/usr/include/x86_64-linux-gnu/bits/unistd.h"
__inline extern char *( __attribute__((__warn_unused_result__, __leaf__, __artificial__,
__always_inline__)) getcwd)(char *__buf , size_t __size ) 
{ 
  unsigned long tmp ;
  char *tmp___0 ;
  unsigned long tmp___1 ;
  char *tmp___2 ;
  unsigned long tmp___3 ;
  unsigned long tmp___4 ;
  char *tmp___5 ;

  {
#line 202
  tmp___4 = __builtin_object_size((void *)__buf, 1);
#line 202
  if (tmp___4 != 0xffffffffffffffffUL) {
#line 205
    tmp = __builtin_object_size((void *)__buf, 1);
#line 205
    tmp___0 = __getcwd_chk(__buf, __size, tmp);
#line 205
    return (tmp___0);
#line 207
    tmp___3 = __builtin_object_size((void *)__buf, 1);
#line 207
    if (__size > tmp___3) {
#line 208
      tmp___1 = __builtin_object_size((void *)__buf, 1);
#line 208
      tmp___2 = __getcwd_chk_warn(__buf, __size, tmp___1);
#line 208
      return (tmp___2);
    }
  }
#line 210
  tmp___5 = __getcwd_alias(__buf, __size);
#line 210
  return (tmp___5);
}
}
#line 214
extern  __attribute__((__nothrow__)) char *( __attribute__((__warn_unused_result__,
__nonnull__(1), __leaf__)) __getwd_chk)(char *__buf , size_t buflen ) ;
#line 216
extern  __attribute__((__nothrow__)) char *( __attribute__((__warn_unused_result__,
__nonnull__(1), __leaf__)) __getwd_warn)(char *__buf )  __asm__("getwd") __attribute__((__warning__("please use getcwd instead, as getwd doesn\'t specify buffer size"))) ;
#line 220
__inline extern  __attribute__((__nothrow__)) char __attribute__((__deprecated__))  *( __attribute__((__warn_unused_result__,
__nonnull__(1), __leaf__, __artificial__, __always_inline__)) getwd)(char *__buf )  __attribute__((__deprecated__)) ;
#line 220 "/usr/include/x86_64-linux-gnu/bits/unistd.h"
__inline extern char __attribute__((__deprecated__))  *( __attribute__((__warn_unused_result__,
__nonnull__(1), __leaf__, __artificial__, __always_inline__)) getwd)(char *__buf ) 
{ 
  unsigned long tmp ;
  char *tmp___0 ;
  unsigned long tmp___1 ;
  char *tmp___2 ;

  {
#line 223
  tmp___1 = __builtin_object_size((void *)__buf, 1);
#line 223
  if (tmp___1 != 0xffffffffffffffffUL) {
#line 224
    tmp = __builtin_object_size((void *)__buf, 1);
#line 224
    tmp___0 = __getwd_chk(__buf, tmp);
#line 224
    return ((char __attribute__((__deprecated__))  *)tmp___0);
  }
#line 225
  tmp___2 = __getwd_warn(__buf);
#line 225
  return ((char __attribute__((__deprecated__))  *)tmp___2);
}
}
#line 229
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__leaf__)) __confstr_chk)(int __name ,
                                                                                       char *__buf ,
                                                                                       size_t __len ,
                                                                                       size_t __buflen ) ;
#line 231
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__leaf__)) __confstr_alias)(int __name ,
                                                                                         char *__buf ,
                                                                                         size_t __len )  __asm__("confstr")  ;
#line 233
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__leaf__)) __confstr_chk_warn)(int __name ,
                                                                                            char *__buf ,
                                                                                            size_t __len ,
                                                                                            size_t __buflen )  __asm__("__confstr_chk") __attribute__((__warning__("confstr called with bigger length than size of destination buffer"))) ;
#line 239
__inline extern  __attribute__((__nothrow__)) size_t ( __attribute__((__leaf__, __artificial__,
__always_inline__)) confstr)(int __name , char *__buf , size_t __len ) ;
#line 239 "/usr/include/x86_64-linux-gnu/bits/unistd.h"
__inline extern size_t ( __attribute__((__leaf__, __artificial__, __always_inline__)) confstr)(int __name ,
                                                                                               char *__buf ,
                                                                                               size_t __len ) 
{ 
  unsigned long tmp ;
  size_t tmp___0 ;
  unsigned long tmp___1 ;
  size_t tmp___2 ;
  unsigned long tmp___3 ;
  unsigned long tmp___4 ;
  size_t tmp___5 ;

  {
#line 242
  tmp___4 = __builtin_object_size((void *)__buf, 1);
#line 242
  if (tmp___4 != 0xffffffffffffffffUL) {
#line 245
    tmp = __builtin_object_size((void *)__buf, 1);
#line 245
    tmp___0 = __confstr_chk(__name, __buf, __len, tmp);
#line 245
    return (tmp___0);
#line 247
    tmp___3 = __builtin_object_size((void *)__buf, 1);
#line 247
    if (tmp___3 < __len) {
#line 248
      tmp___1 = __builtin_object_size((void *)__buf, 1);
#line 248
      tmp___2 = __confstr_chk_warn(__name, __buf, __len, tmp___1);
#line 248
      return (tmp___2);
    }
  }
#line 250
  tmp___5 = __confstr_alias(__name, __buf, __len);
#line 250
  return (tmp___5);
}
}
#line 254
extern  __attribute__((__nothrow__)) int ( __attribute__((__warn_unused_result__,
__leaf__)) __getgroups_chk)(int __size , __gid_t *__list , size_t __listlen ) ;
#line 256
extern  __attribute__((__nothrow__)) int ( __attribute__((__warn_unused_result__,
__leaf__)) __getgroups_alias)(int __size , __gid_t *__list )  __asm__("getgroups")  ;
#line 258
extern  __attribute__((__nothrow__)) int ( __attribute__((__warn_unused_result__,
__leaf__)) __getgroups_chk_warn)(int __size , __gid_t *__list , size_t __listlen )  __asm__("__getgroups_chk") __attribute__((__warning__("getgroups called with bigger group count than what can fit into destination buffer"))) ;
#line 264
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__warn_unused_result__,
__leaf__, __artificial__, __always_inline__)) getgroups)(int __size , __gid_t *__list ) ;
#line 264 "/usr/include/x86_64-linux-gnu/bits/unistd.h"
__inline extern int ( __attribute__((__warn_unused_result__, __leaf__, __artificial__,
__always_inline__)) getgroups)(int __size , __gid_t *__list ) 
{ 
  unsigned long tmp ;
  int tmp___0 ;
  unsigned long tmp___1 ;
  int tmp___2 ;
  unsigned long tmp___3 ;
  unsigned long tmp___4 ;
  int tmp___5 ;

  {
#line 267
  tmp___4 = __builtin_object_size((void *)__list, 1);
#line 267
  if (tmp___4 != 0xffffffffffffffffUL) {
#line 270
    tmp = __builtin_object_size((void *)__list, 1);
#line 270
    tmp___0 = __getgroups_chk(__size, __list, tmp);
#line 270
    return (tmp___0);
#line 272
    tmp___3 = __builtin_object_size((void *)__list, 1);
#line 272
    if ((unsigned long )__size * sizeof(__gid_t ) > tmp___3) {
#line 273
      tmp___1 = __builtin_object_size((void *)__list, 1);
#line 273
      tmp___2 = __getgroups_chk_warn(__size, __list, tmp___1);
#line 273
      return (tmp___2);
    }
  }
#line 275
  tmp___5 = __getgroups_alias(__size, __list);
#line 275
  return (tmp___5);
}
}
#line 279
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2), __leaf__)) __ttyname_r_chk)(int __fd ,
                                                                                                      char *__buf ,
                                                                                                      size_t __buflen ,
                                                                                                      size_t __nreal ) ;
#line 281
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2), __leaf__)) __ttyname_r_alias)(int __fd ,
                                                                                                        char *__buf ,
                                                                                                        size_t __buflen )  __asm__("ttyname_r")  ;
#line 284
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2), __leaf__)) __ttyname_r_chk_warn)(int __fd ,
                                                                                                           char *__buf ,
                                                                                                           size_t __buflen ,
                                                                                                           size_t __nreal )  __asm__("__ttyname_r_chk") __attribute__((__warning__("ttyname_r called with bigger buflen than size of destination buffer"))) ;
#line 290
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__warn_unused_result__,
__nonnull__(2), __leaf__, __artificial__, __always_inline__)) ttyname_r)(int __fd ,
                                                                         char *__buf ,
                                                                         size_t __buflen ) ;
#line 290 "/usr/include/x86_64-linux-gnu/bits/unistd.h"
__inline extern int ( __attribute__((__warn_unused_result__, __nonnull__(2), __leaf__,
__artificial__, __always_inline__)) ttyname_r)(int __fd , char *__buf , size_t __buflen ) 
{ 
  unsigned long tmp ;
  int tmp___0 ;
  unsigned long tmp___1 ;
  int tmp___2 ;
  unsigned long tmp___3 ;
  unsigned long tmp___4 ;
  int tmp___5 ;

  {
#line 293
  tmp___4 = __builtin_object_size((void *)__buf, 1);
#line 293
  if (tmp___4 != 0xffffffffffffffffUL) {
#line 296
    tmp = __builtin_object_size((void *)__buf, 1);
#line 296
    tmp___0 = __ttyname_r_chk(__fd, __buf, __buflen, tmp);
#line 296
    return (tmp___0);
#line 298
    tmp___3 = __builtin_object_size((void *)__buf, 1);
#line 298
    if (__buflen > tmp___3) {
#line 299
      tmp___1 = __builtin_object_size((void *)__buf, 1);
#line 299
      tmp___2 = __ttyname_r_chk_warn(__fd, __buf, __buflen, tmp___1);
#line 299
      return (tmp___2);
    }
  }
#line 301
  tmp___5 = __ttyname_r_alias(__fd, __buf, __buflen);
#line 301
  return (tmp___5);
}
}
#line 306
extern int ( __attribute__((__nonnull__(1))) __getlogin_r_chk)(char *__buf , size_t __buflen ,
                                                               size_t __nreal ) ;
#line 308
extern int ( __attribute__((__nonnull__(1))) __getlogin_r_alias)(char *__buf , size_t __buflen )  __asm__("getlogin_r")  ;
#line 310
extern int ( __attribute__((__nonnull__(1))) __getlogin_r_chk_warn)(char *__buf ,
                                                                    size_t __buflen ,
                                                                    size_t __nreal )  __asm__("__getlogin_r_chk") __attribute__((__warning__("getlogin_r called with bigger buflen than size of destination buffer"))) ;
#line 316 "/usr/include/x86_64-linux-gnu/bits/unistd.h"
__inline extern int ( __attribute__((__nonnull__(1), __artificial__, __always_inline__)) getlogin_r)(char *__buf ,
                                                                                                     size_t __buflen ) 
{ 
  unsigned long tmp ;
  int tmp___0 ;
  unsigned long tmp___1 ;
  int tmp___2 ;
  unsigned long tmp___3 ;
  unsigned long tmp___4 ;
  int tmp___5 ;

  {
#line 319
  tmp___4 = __builtin_object_size((void *)__buf, 1);
#line 319
  if (tmp___4 != 0xffffffffffffffffUL) {
#line 322
    tmp = __builtin_object_size((void *)__buf, 1);
#line 322
    tmp___0 = __getlogin_r_chk(__buf, __buflen, tmp);
#line 322
    return (tmp___0);
#line 324
    tmp___3 = __builtin_object_size((void *)__buf, 1);
#line 324
    if (__buflen > tmp___3) {
#line 325
      tmp___1 = __builtin_object_size((void *)__buf, 1);
#line 325
      tmp___2 = __getlogin_r_chk_warn(__buf, __buflen, tmp___1);
#line 325
      return (tmp___2);
    }
  }
#line 327
  tmp___5 = __getlogin_r_alias(__buf, __buflen);
#line 327
  return (tmp___5);
}
}
#line 333
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) __gethostname_chk)(char *__buf ,
                                                                                                        size_t __buflen ,
                                                                                                        size_t __nreal ) ;
#line 335
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) __gethostname_alias)(char *__buf ,
                                                                                                          size_t __buflen )  __asm__("gethostname")  ;
#line 337
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) __gethostname_chk_warn)(char *__buf ,
                                                                                                             size_t __buflen ,
                                                                                                             size_t __nreal )  __asm__("__gethostname_chk") __attribute__((__warning__("gethostname called with bigger buflen than size of destination buffer"))) ;
#line 343
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1),
__leaf__, __artificial__, __always_inline__)) gethostname)(char *__buf , size_t __buflen ) ;
#line 343 "/usr/include/x86_64-linux-gnu/bits/unistd.h"
__inline extern int ( __attribute__((__nonnull__(1), __leaf__, __artificial__, __always_inline__)) gethostname)(char *__buf ,
                                                                                                                size_t __buflen ) 
{ 
  unsigned long tmp ;
  int tmp___0 ;
  unsigned long tmp___1 ;
  int tmp___2 ;
  unsigned long tmp___3 ;
  unsigned long tmp___4 ;
  int tmp___5 ;

  {
#line 346
  tmp___4 = __builtin_object_size((void *)__buf, 1);
#line 346
  if (tmp___4 != 0xffffffffffffffffUL) {
#line 349
    tmp = __builtin_object_size((void *)__buf, 1);
#line 349
    tmp___0 = __gethostname_chk(__buf, __buflen, tmp);
#line 349
    return (tmp___0);
#line 351
    tmp___3 = __builtin_object_size((void *)__buf, 1);
#line 351
    if (__buflen > tmp___3) {
#line 352
      tmp___1 = __builtin_object_size((void *)__buf, 1);
#line 352
      tmp___2 = __gethostname_chk_warn(__buf, __buflen, tmp___1);
#line 352
      return (tmp___2);
    }
  }
#line 354
  tmp___5 = __gethostname_alias(__buf, __buflen);
#line 354
  return (tmp___5);
}
}
#line 360
extern  __attribute__((__nothrow__)) int ( __attribute__((__warn_unused_result__,
__nonnull__(1), __leaf__)) __getdomainname_chk)(char *__buf , size_t __buflen , size_t __nreal ) ;
#line 362
extern  __attribute__((__nothrow__)) int ( __attribute__((__warn_unused_result__,
__nonnull__(1), __leaf__)) __getdomainname_alias)(char *__buf , size_t __buflen )  __asm__("getdomainname")  ;
#line 365
extern  __attribute__((__nothrow__)) int ( __attribute__((__warn_unused_result__,
__nonnull__(1), __leaf__)) __getdomainname_chk_warn)(char *__buf , size_t __buflen ,
                                                     size_t __nreal )  __asm__("__getdomainname_chk") __attribute__((__warning__("getdomainname called with bigger buflen than size of destination buffer"))) ;
#line 372
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__warn_unused_result__,
__nonnull__(1), __leaf__, __artificial__, __always_inline__)) getdomainname)(char *__buf ,
                                                                             size_t __buflen ) ;
#line 372 "/usr/include/x86_64-linux-gnu/bits/unistd.h"
__inline extern int ( __attribute__((__warn_unused_result__, __nonnull__(1), __leaf__,
__artificial__, __always_inline__)) getdomainname)(char *__buf , size_t __buflen ) 
{ 
  unsigned long tmp ;
  int tmp___0 ;
  unsigned long tmp___1 ;
  int tmp___2 ;
  unsigned long tmp___3 ;
  unsigned long tmp___4 ;
  int tmp___5 ;

  {
#line 375
  tmp___4 = __builtin_object_size((void *)__buf, 1);
#line 375
  if (tmp___4 != 0xffffffffffffffffUL) {
#line 378
    tmp = __builtin_object_size((void *)__buf, 1);
#line 378
    tmp___0 = __getdomainname_chk(__buf, __buflen, tmp);
#line 378
    return (tmp___0);
#line 380
    tmp___3 = __builtin_object_size((void *)__buf, 1);
#line 380
    if (__buflen > tmp___3) {
#line 381
      tmp___1 = __builtin_object_size((void *)__buf, 1);
#line 381
      tmp___2 = __getdomainname_chk_warn(__buf, __buflen, tmp___1);
#line 381
      return (tmp___2);
    }
  }
#line 383
  tmp___5 = __getdomainname_alias(__buf, __buflen);
#line 383
  return (tmp___5);
}
}
#line 70 "/usr/include/assert.h"
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) __assert_fail)(char const   *__assertion ,
                                                                                                   char const   *__file ,
                                                                                                   unsigned int __line ,
                                                                                                   char const   *__function ) ;
#line 100 "src/global.h"
void Initialize_Buffer(void) ;
#line 101
void Fill_Buffer(void) ;
#line 102
unsigned int Show_Bits(int N ) ;
#line 103
unsigned int Get_Bits1(void) ;
#line 104
void Flush_Buffer(int N ) ;
#line 105
unsigned int Get_Bits(int N ) ;
#line 106
int Get_Byte(void) ;
#line 107
int Get_Word(void) ;
#line 109
void Thrd_Initialize_Buffer(int t ) ;
#line 110
unsigned int Thrd_Show_Bits(int t , int N ) ;
#line 111
unsigned int Thrd_Get_Bits1(int t ) ;
#line 112
void Thrd_Flush_Buffer(int t , int N ) ;
#line 113
unsigned int Thrd_Get_Bits(int t , int N ) ;
#line 114
int Thrd_Get_Byte(int t ) ;
#line 115
int Thrd_Get_Word(int t ) ;
#line 119
void Next_Packet(void) ;
#line 348
int System_Stream_Flag ;
#line 515
struct layer_data *ld ;
#line 585 "src/global.h"
unsigned char *frame_buffer  ;
#line 586 "src/global.h"
unsigned char *frame_buf_ptr  ;
#line 587 "src/global.h"
unsigned int frame_buf_size  ;
#line 588 "src/global.h"
unsigned int frame_buf_offset  ;
#line 590 "src/global.h"
unsigned char *thrd_ptr[2]  ;
#line 591 "src/global.h"
unsigned int thrd_buf[2]  ;
#line 592 "src/global.h"
int thrd_Incnt[2]  ;
#line 607 "src/global.h"
thrd_buf_info tb[2]  ;
#line 624 "src/global.h"
struct thrd_layer_data thrd_ld[2]  ;
#line 96 "src/getbits.c"
void Initialize_Buffer(void) 
{ 


  {
#line 98
  ld->Incnt = 0;
#line 99
  ld->Rdptr = ld->Rdbfr + 2048;
#line 100
  ld->Rdmax = ld->Rdptr;
#line 111
  ld->Bfr = 0U;
#line 112
  Flush_Buffer(0);
#line 113
  return;
}
}
#line 115 "src/getbits.c"
void Fill_Buffer(void) 
{ 
  int Buffer_Level ;
  ssize_t tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 119
  tmp = read(ld->Infile, (void *)(ld->Rdbfr), (size_t )2048);
#line 119
  Buffer_Level = (int )tmp;
#line 120
  ld->Rdptr = ld->Rdbfr;
#line 122
  if (System_Stream_Flag) {
#line 123
    ld->Rdmax -= 2048;
  }
#line 127
  if (Buffer_Level < 2048) {
#line 130
    if (Buffer_Level < 0) {
#line 131
      Buffer_Level = 0;
    }
#line 134
    while (Buffer_Level & 3) {
#line 135
      tmp___0 = Buffer_Level;
#line 135
      Buffer_Level ++;
#line 135
      ld->Rdbfr[tmp___0] = (unsigned char)0;
    }
#line 138
    while (Buffer_Level < 2048) {
#line 140
      tmp___1 = Buffer_Level;
#line 140
      Buffer_Level ++;
#line 140
      ld->Rdbfr[tmp___1] = (unsigned char )(439 >> 24);
#line 141
      tmp___2 = Buffer_Level;
#line 141
      Buffer_Level ++;
#line 141
      ld->Rdbfr[tmp___2] = (unsigned char )(439 >> 16);
#line 142
      tmp___3 = Buffer_Level;
#line 142
      Buffer_Level ++;
#line 142
      ld->Rdbfr[tmp___3] = (unsigned char )(439 >> 8);
#line 143
      tmp___4 = Buffer_Level;
#line 143
      Buffer_Level ++;
#line 143
      ld->Rdbfr[tmp___4] = (unsigned char)183;
    }
  }
#line 146
  return;
}
}
#line 151 "src/getbits.c"
int Get_Byte(void) 
{ 
  unsigned char *tmp ;

  {
#line 153
  while ((unsigned long )ld->Rdptr >= (unsigned long )(ld->Rdbfr + 2048)) {
#line 155
    read(ld->Infile, (void *)(ld->Rdbfr), (size_t )2048);
#line 156
    ld->Rdptr -= 2048;
#line 157
    ld->Rdmax -= 2048;
  }
#line 159
  tmp = ld->Rdptr;
#line 159
  (ld->Rdptr) ++;
#line 159
  return ((int )*tmp);
}
}
#line 163 "src/getbits.c"
int Get_Word(void) 
{ 
  int Val ;
  int tmp ;

  {
#line 167
  Val = Get_Byte();
#line 168
  tmp = Get_Byte();
#line 168
  return ((Val << 8) | tmp);
}
}
#line 174 "src/getbits.c"
unsigned int Show_Bits(int N ) 
{ 


  {
#line 177
  return (ld->Bfr >> (32 - N));
}
}
#line 183 "src/getbits.c"
unsigned int Get_Bits1(void) 
{ 
  unsigned int tmp ;

  {
#line 185
  tmp = Get_Bits(1);
#line 185
  return (tmp);
}
}
#line 191 "src/getbits.c"
void Flush_Buffer(int N ) 
{ 
  int Incnt ;
  int tmp ;
  int tmp___0 ;
  unsigned char *tmp___1 ;
  unsigned char *tmp___2 ;

  {
#line 196
  ld->Bfr <<= N;
#line 198
  tmp = ld->Incnt - N;
#line 198
  ld->Incnt = tmp;
#line 198
  Incnt = tmp;
#line 200
  if (Incnt <= 24) {
#line 202
    if (System_Stream_Flag) {
#line 202
      if ((unsigned long )ld->Rdptr >= (unsigned long )(ld->Rdmax - 4)) {
#line 204
        while (1) {
#line 206
          if ((unsigned long )ld->Rdptr >= (unsigned long )ld->Rdmax) {
#line 207
            Next_Packet();
          }
#line 208
          tmp___0 = Get_Byte();
#line 208
          ld->Bfr |= (unsigned int )(tmp___0 << (24 - Incnt));
#line 209
          Incnt += 8;
#line 204
          if (! (Incnt <= 24)) {
#line 204
            break;
          }
        }
      } else {
#line 202
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 213
    if ((unsigned long )ld->Rdptr < (unsigned long )(ld->Rdbfr + 2044)) {
#line 215
      while (1) {
#line 217
        tmp___1 = ld->Rdptr;
#line 217
        (ld->Rdptr) ++;
#line 217
        ld->Bfr |= (unsigned int )((int )*tmp___1 << (24 - Incnt));
#line 218
        Incnt += 8;
#line 215
        if (! (Incnt <= 24)) {
#line 215
          break;
        }
      }
    } else {
#line 224
      while (1) {
#line 226
        if ((unsigned long )ld->Rdptr >= (unsigned long )(ld->Rdbfr + 2048)) {
#line 227
          Fill_Buffer();
        }
#line 228
        tmp___2 = ld->Rdptr;
#line 228
        (ld->Rdptr) ++;
#line 228
        ld->Bfr |= (unsigned int )((int )*tmp___2 << (24 - Incnt));
#line 229
        Incnt += 8;
#line 224
        if (! (Incnt <= 24)) {
#line 224
          break;
        }
      }
    }
#line 233
    ld->Incnt = Incnt;
  }
#line 240
  return;
}
}
#line 245 "src/getbits.c"
unsigned int Get_Bits(int N ) 
{ 
  unsigned int Val ;

  {
#line 250
  Val = Show_Bits(N);
#line 251
  Flush_Buffer(N);
#line 253
  return (Val);
}
}
#line 261 "src/getbits.c"
void Thrd_Initialize_Buffer(int t ) 
{ 


  {
#line 264
  thrd_buf[t] = 0U;
#line 265
  Thrd_Flush_Buffer(t, 0);
#line 266
  return;
}
}
#line 271 "src/getbits.c"
int Thrd_Get_Byte(int t ) 
{ 
  unsigned char *tmp ;

  {
#line 273
  tmp = thrd_ptr[t];
#line 273
  (thrd_ptr[t]) ++;
#line 273
  return ((int )*tmp);
}
}
#line 277 "src/getbits.c"
int Thrd_Get_Word(int t ) 
{ 
  int Val ;
  int tmp ;

  {
#line 281
  Val = Thrd_Get_Byte(t);
#line 282
  tmp = Thrd_Get_Byte(t);
#line 282
  return ((Val << 8) | tmp);
}
}
#line 288 "src/getbits.c"
unsigned int Thrd_Show_Bits(int t , int N ) 
{ 


  {
#line 292
  return (thrd_buf[t] >> (32 - N));
}
}
#line 298 "src/getbits.c"
unsigned int Thrd_Get_Bits1(int t ) 
{ 
  unsigned int tmp ;

  {
#line 300
  tmp = Thrd_Get_Bits(t, 1);
#line 300
  return (tmp);
}
}
#line 306 "src/getbits.c"
void Thrd_Flush_Buffer(int t , int N ) 
{ 
  int Incnt ;
  int tmp ;
  int tmp___0 ;
  unsigned char *tmp___1 ;

  {
#line 312
  thrd_buf[t] <<= N;
#line 314
  tmp = thrd_Incnt[t] - N;
#line 314
  thrd_Incnt[t] = tmp;
#line 314
  Incnt = tmp;
#line 316
  if (Incnt <= 24) {
#line 317
    if (System_Stream_Flag) {
#line 317
      if ((unsigned long )ld->Rdptr >= (unsigned long )(ld->Rdmax - 4)) {
#line 318
        __assert_fail("0&&\"System_Strem_Flag is 1\\n\"", "src/getbits.c", 318U, "Thrd_Flush_Buffer");
#line 319
        while (1) {
#line 320
          if ((unsigned long )ld->Rdptr >= (unsigned long )ld->Rdmax) {
#line 321
            Next_Packet();
          }
#line 322
          tmp___0 = Get_Byte();
#line 322
          ld->Bfr |= (unsigned int )(tmp___0 << (24 - Incnt));
#line 323
          Incnt += 8;
#line 319
          if (! (Incnt <= 24)) {
#line 319
            break;
          }
        }
      } else {
#line 317
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
#line 326
      while (1) {
#line 327
        tmp___1 = thrd_ptr[t];
#line 327
        (thrd_ptr[t]) ++;
#line 327
        thrd_buf[t] |= (unsigned int )((int )*tmp___1 << (24 - Incnt));
#line 328
        Incnt += 8;
#line 326
        if (! (Incnt <= 24)) {
#line 326
          break;
        }
      }
    }
#line 331
    thrd_Incnt[t] = Incnt;
  }
#line 334
  return;
}
}
#line 339 "src/getbits.c"
unsigned int Thrd_Get_Bits(int t , int N ) 
{ 
  unsigned int Val ;

  {
#line 344
  Val = Thrd_Show_Bits(t, N);
#line 345
  Thrd_Flush_Buffer(t, N);
#line 347
  return (Val);
}
}
#line 1 "getblk.o"
#pragma merger("0","/tmp/cil-h03QAqAu.i","-g,-O4")
#line 170 "/usr/include/stdio.h"
extern struct _IO_FILE *stderr ;
#line 132 "src/global.h"
void Decode_MPEG1_Intra_Block(int comp , int *dc_dct_pred ) ;
#line 133
void Decode_MPEG1_Non_Intra_Block(int comp ) ;
#line 134
void Decode_MPEG2_Intra_Block(int comp , int *dc_dct_pred ) ;
#line 135
void Decode_MPEG2_Non_Intra_Block(int comp ) ;
#line 154
int Get_Luma_DC_dct_diff(void) ;
#line 155
int Get_Chroma_DC_dct_diff(void) ;
#line 209
int Thrd_Get_Luma_DC_dct_diff(int t ) ;
#line 210
int Thrd_Get_Chroma_DC_dct_diff(int t ) ;
#line 221
void Thrd_Decode_MPEG2_Non_Intra_Block(int t , int comp ) ;
#line 222
void Thrd_Decode_MPEG2_Intra_Block(int t , int comp , int *dc_dct_pred ) ;
#line 242
unsigned char scan[2][64] ;
#line 340
int Quiet_Flag ;
#line 342
int Fault_Flag ;
#line 419
int chroma_format ;
#line 435
int picture_coding_type ;
#line 445
int intra_dc_precision ;
#line 451
int intra_vlc_format ;
#line 515
struct layer_data base ;
#line 515
struct layer_data enhan ;
#line 92 "src/getblk.c"
DCTtab DCTtabfirst[12] ;
#line 92
DCTtab DCTtabnext[12] ;
#line 92
DCTtab DCTtab0[60] ;
#line 92
DCTtab DCTtab1[8] ;
#line 93
DCTtab DCTtab2[16] ;
#line 93
DCTtab DCTtab3[16] ;
#line 93
DCTtab DCTtab4[16] ;
#line 93
DCTtab DCTtab5[16] ;
#line 93
DCTtab DCTtab6[16] ;
#line 94
DCTtab DCTtab0a[252] ;
#line 94
DCTtab DCTtab1a[8] ;
#line 99 "src/getblk.c"
void Decode_MPEG1_Intra_Block(int comp , int *dc_dct_pred ) 
{ 
  int val ;
  int i ;
  int j ;
  int sign ;
  unsigned int code ;
  DCTtab *tab ;
  short *bp ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  unsigned int tmp___5 ;
  unsigned int tmp___6 ;
  unsigned int tmp___7 ;
  unsigned int tmp___8 ;
  unsigned int tmp___9 ;

  {
#line 108
  bp = ld->block[comp];
#line 112
  if (comp < 4) {
#line 113
    tmp = Get_Luma_DC_dct_diff();
#line 113
    tmp___0 = *(dc_dct_pred + 0) + tmp;
#line 113
    *(dc_dct_pred + 0) = tmp___0;
#line 113
    *(bp + 0) = (short )(tmp___0 << 3);
  } else
#line 114
  if (comp == 4) {
#line 115
    tmp___1 = Get_Chroma_DC_dct_diff();
#line 115
    tmp___2 = *(dc_dct_pred + 1) + tmp___1;
#line 115
    *(dc_dct_pred + 1) = tmp___2;
#line 115
    *(bp + 0) = (short )(tmp___2 << 3);
  } else {
#line 117
    tmp___3 = Get_Chroma_DC_dct_diff();
#line 117
    tmp___4 = *(dc_dct_pred + 2) + tmp___3;
#line 117
    *(dc_dct_pred + 2) = tmp___4;
#line 117
    *(bp + 0) = (short )(tmp___4 << 3);
  }
#line 119
  if (Fault_Flag) {
#line 119
    return;
  }
#line 122
  if (picture_coding_type == 4) {
#line 123
    return;
  }
#line 126
  i = 1;
#line 126
  while (1) {
#line 128
    code = Show_Bits(16);
#line 129
    if (code >= 16384U) {
#line 130
      tab = & DCTtabnext[(code >> 12) - 4U];
    } else
#line 131
    if (code >= 1024U) {
#line 132
      tab = & DCTtab0[(code >> 8) - 4U];
    } else
#line 133
    if (code >= 512U) {
#line 134
      tab = & DCTtab1[(code >> 6) - 8U];
    } else
#line 135
    if (code >= 256U) {
#line 136
      tab = & DCTtab2[(code >> 4) - 16U];
    } else
#line 137
    if (code >= 128U) {
#line 138
      tab = & DCTtab3[(code >> 3) - 16U];
    } else
#line 139
    if (code >= 64U) {
#line 140
      tab = & DCTtab4[(code >> 2) - 16U];
    } else
#line 141
    if (code >= 32U) {
#line 142
      tab = & DCTtab5[(code >> 1) - 16U];
    } else
#line 143
    if (code >= 16U) {
#line 144
      tab = & DCTtab6[code - 16U];
    } else {
#line 147
      if (! Quiet_Flag) {
#line 148
        printf((char const   * __restrict  )"invalid Huffman code in Decode_MPEG1_Intra_Block()\n");
      }
#line 149
      Fault_Flag = 1;
#line 150
      return;
    }
#line 153
    Flush_Buffer((int )tab->len);
#line 155
    if ((int )tab->run == 64) {
#line 156
      return;
    }
#line 158
    if ((int )tab->run == 65) {
#line 160
      tmp___5 = Get_Bits(6);
#line 160
      i = (int )((unsigned int )i + tmp___5);
#line 162
      tmp___6 = Get_Bits(8);
#line 162
      val = (int )tmp___6;
#line 163
      if (val == 0) {
#line 164
        tmp___7 = Get_Bits(8);
#line 164
        val = (int )tmp___7;
      } else
#line 165
      if (val == 128) {
#line 166
        tmp___8 = Get_Bits(8);
#line 166
        val = (int )(tmp___8 - 256U);
      } else
#line 167
      if (val > 128) {
#line 168
        val -= 256;
      }
#line 170
      sign = val < 0;
#line 170
      if (sign) {
#line 171
        val = - val;
      }
    } else {
#line 175
      i += (int )tab->run;
#line 176
      val = (int )tab->level;
#line 177
      tmp___9 = Get_Bits(1);
#line 177
      sign = (int )tmp___9;
    }
#line 180
    if (i >= 64) {
#line 182
      if (! Quiet_Flag) {
#line 183
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"DCT coeff index (i) out of bounds (intra)\n");
      }
#line 184
      Fault_Flag = 1;
#line 185
      return;
    }
#line 188
    j = (int )scan[0][i];
#line 189
    val = (val * ld->quantizer_scale) * ld->intra_quantizer_matrix[j] >> 3;
#line 192
    if (val != 0) {
#line 193
      val = (val - 1) | 1;
    }
#line 196
    if (! sign) {
#line 197
      if (val > 2047) {
#line 197
        *(bp + j) = (short)2047;
      } else {
#line 197
        *(bp + j) = (short )val;
      }
    } else
#line 199
    if (val > 2048) {
#line 199
      *(bp + j) = (short)-2048;
    } else {
#line 199
      *(bp + j) = (short )(- val);
    }
#line 126
    i ++;
  }
}
}
#line 206 "src/getblk.c"
void Decode_MPEG1_Non_Intra_Block(int comp ) 
{ 
  int val ;
  int i ;
  int j ;
  int sign ;
  unsigned int code ;
  DCTtab *tab ;
  short *bp ;
  unsigned int tmp ;
  unsigned int tmp___0 ;
  unsigned int tmp___1 ;
  unsigned int tmp___2 ;
  unsigned int tmp___3 ;

  {
#line 214
  bp = ld->block[comp];
#line 217
  i = 0;
#line 217
  while (1) {
#line 219
    code = Show_Bits(16);
#line 220
    if (code >= 16384U) {
#line 222
      if (i == 0) {
#line 223
        tab = & DCTtabfirst[(code >> 12) - 4U];
      } else {
#line 225
        tab = & DCTtabnext[(code >> 12) - 4U];
      }
    } else
#line 227
    if (code >= 1024U) {
#line 228
      tab = & DCTtab0[(code >> 8) - 4U];
    } else
#line 229
    if (code >= 512U) {
#line 230
      tab = & DCTtab1[(code >> 6) - 8U];
    } else
#line 231
    if (code >= 256U) {
#line 232
      tab = & DCTtab2[(code >> 4) - 16U];
    } else
#line 233
    if (code >= 128U) {
#line 234
      tab = & DCTtab3[(code >> 3) - 16U];
    } else
#line 235
    if (code >= 64U) {
#line 236
      tab = & DCTtab4[(code >> 2) - 16U];
    } else
#line 237
    if (code >= 32U) {
#line 238
      tab = & DCTtab5[(code >> 1) - 16U];
    } else
#line 239
    if (code >= 16U) {
#line 240
      tab = & DCTtab6[code - 16U];
    } else {
#line 243
      if (! Quiet_Flag) {
#line 244
        printf((char const   * __restrict  )"invalid Huffman code in Decode_MPEG1_Non_Intra_Block()\n");
      }
#line 245
      Fault_Flag = 1;
#line 246
      return;
    }
#line 249
    Flush_Buffer((int )tab->len);
#line 251
    if ((int )tab->run == 64) {
#line 252
      return;
    }
#line 254
    if ((int )tab->run == 65) {
#line 256
      tmp = Get_Bits(6);
#line 256
      i = (int )((unsigned int )i + tmp);
#line 258
      tmp___0 = Get_Bits(8);
#line 258
      val = (int )tmp___0;
#line 259
      if (val == 0) {
#line 260
        tmp___1 = Get_Bits(8);
#line 260
        val = (int )tmp___1;
      } else
#line 261
      if (val == 128) {
#line 262
        tmp___2 = Get_Bits(8);
#line 262
        val = (int )(tmp___2 - 256U);
      } else
#line 263
      if (val > 128) {
#line 264
        val -= 256;
      }
#line 266
      sign = val < 0;
#line 266
      if (sign) {
#line 267
        val = - val;
      }
    } else {
#line 271
      i += (int )tab->run;
#line 272
      val = (int )tab->level;
#line 273
      tmp___3 = Get_Bits(1);
#line 273
      sign = (int )tmp___3;
    }
#line 276
    if (i >= 64) {
#line 278
      if (! Quiet_Flag) {
#line 279
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"DCT coeff index (i) out of bounds (inter)\n");
      }
#line 280
      Fault_Flag = 1;
#line 281
      return;
    }
#line 284
    j = (int )scan[0][i];
#line 285
    val = (((val << 1) + 1) * ld->quantizer_scale) * ld->non_intra_quantizer_matrix[j] >> 4;
#line 288
    if (val != 0) {
#line 289
      val = (val - 1) | 1;
    }
#line 292
    if (! sign) {
#line 293
      if (val > 2047) {
#line 293
        *(bp + j) = (short)2047;
      } else {
#line 293
        *(bp + j) = (short )val;
      }
    } else
#line 295
    if (val > 2048) {
#line 295
      *(bp + j) = (short)-2048;
    } else {
#line 295
      *(bp + j) = (short )(- val);
    }
#line 217
    i ++;
  }
}
}
#line 302 "src/getblk.c"
void Decode_MPEG2_Intra_Block(int comp , int *dc_dct_pred ) 
{ 
  int val ;
  int i ;
  int j ;
  int sign ;
  int nc ;
  int cc ;
  int run ;
  unsigned int code ;
  DCTtab *tab ;
  short *bp ;
  int *qmat ;
  struct layer_data *ld1 ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  unsigned int tmp___5 ;
  unsigned int tmp___6 ;
  unsigned int tmp___7 ;

  {
#line 314
  if (ld->scalable_mode == 1) {
#line 314
    ld1 = & base;
  } else {
#line 314
    ld1 = ld;
  }
#line 315
  bp = ld1->block[comp];
#line 317
  if (base.scalable_mode == 1) {
#line 318
    if (base.priority_breakpoint < 64) {
#line 319
      ld = & enhan;
    } else {
#line 321
      ld = & base;
    }
  }
#line 324
  if (comp < 4) {
#line 324
    cc = 0;
  } else {
#line 324
    cc = (comp & 1) + 1;
  }
#line 326
  if (comp < 4) {
#line 326
    qmat = ld1->intra_quantizer_matrix;
  } else
#line 326
  if (chroma_format == 1) {
#line 326
    qmat = ld1->intra_quantizer_matrix;
  } else {
#line 326
    qmat = ld1->chroma_intra_quantizer_matrix;
  }
#line 331
  if (cc == 0) {
#line 332
    tmp = Get_Luma_DC_dct_diff();
#line 332
    tmp___0 = *(dc_dct_pred + 0) + tmp;
#line 332
    *(dc_dct_pred + 0) = tmp___0;
#line 332
    val = tmp___0;
  } else
#line 333
  if (cc == 1) {
#line 334
    tmp___1 = Get_Chroma_DC_dct_diff();
#line 334
    tmp___2 = *(dc_dct_pred + 1) + tmp___1;
#line 334
    *(dc_dct_pred + 1) = tmp___2;
#line 334
    val = tmp___2;
  } else {
#line 336
    tmp___3 = Get_Chroma_DC_dct_diff();
#line 336
    tmp___4 = *(dc_dct_pred + 2) + tmp___3;
#line 336
    *(dc_dct_pred + 2) = tmp___4;
#line 336
    val = tmp___4;
  }
#line 338
  if (Fault_Flag) {
#line 338
    return;
  }
#line 340
  *(bp + 0) = (short )(val << (3 - intra_dc_precision));
#line 342
  nc = 0;
#line 350
  i = 1;
#line 350
  while (1) {
#line 352
    code = Show_Bits(16);
#line 353
    if (code >= 16384U) {
#line 353
      if (! intra_vlc_format) {
#line 354
        tab = & DCTtabnext[(code >> 12) - 4U];
      } else {
#line 353
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 355
    if (code >= 1024U) {
#line 357
      if (intra_vlc_format) {
#line 358
        tab = & DCTtab0a[(code >> 8) - 4U];
      } else {
#line 360
        tab = & DCTtab0[(code >> 8) - 4U];
      }
    } else
#line 362
    if (code >= 512U) {
#line 364
      if (intra_vlc_format) {
#line 365
        tab = & DCTtab1a[(code >> 6) - 8U];
      } else {
#line 367
        tab = & DCTtab1[(code >> 6) - 8U];
      }
    } else
#line 369
    if (code >= 256U) {
#line 370
      tab = & DCTtab2[(code >> 4) - 16U];
    } else
#line 371
    if (code >= 128U) {
#line 372
      tab = & DCTtab3[(code >> 3) - 16U];
    } else
#line 373
    if (code >= 64U) {
#line 374
      tab = & DCTtab4[(code >> 2) - 16U];
    } else
#line 375
    if (code >= 32U) {
#line 376
      tab = & DCTtab5[(code >> 1) - 16U];
    } else
#line 377
    if (code >= 16U) {
#line 378
      tab = & DCTtab6[code - 16U];
    } else {
#line 381
      if (! Quiet_Flag) {
#line 382
        printf((char const   * __restrict  )"invalid Huffman code in Decode_MPEG2_Intra_Block()\n");
      }
#line 383
      Fault_Flag = 1;
#line 384
      return;
    }
#line 387
    Flush_Buffer((int )tab->len);
#line 397
    if ((int )tab->run == 64) {
#line 403
      return;
    }
#line 406
    if ((int )tab->run == 65) {
#line 416
      tmp___5 = Get_Bits(6);
#line 416
      run = (int )tmp___5;
#line 416
      i += run;
#line 426
      tmp___6 = Get_Bits(12);
#line 426
      val = (int )tmp___6;
#line 427
      if ((val & 2047) == 0) {
#line 429
        if (! Quiet_Flag) {
#line 430
          printf((char const   * __restrict  )"invalid escape in Decode_MPEG2_Intra_Block()\n");
        }
#line 431
        Fault_Flag = 1;
#line 432
        return;
      }
#line 434
      sign = val >= 2048;
#line 434
      if (sign) {
#line 435
        val = 4096 - val;
      }
    } else {
#line 439
      run = (int )tab->run;
#line 439
      i += run;
#line 440
      val = (int )tab->level;
#line 441
      tmp___7 = Get_Bits(1);
#line 441
      sign = (int )tmp___7;
    }
#line 449
    if (i >= 64) {
#line 451
      if (! Quiet_Flag) {
#line 452
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"DCT coeff index (i) out of bounds (intra2)\n");
      }
#line 453
      Fault_Flag = 1;
#line 454
      return;
    }
#line 462
    j = (int )scan[ld1->alternate_scan][i];
#line 463
    val = (val * ld1->quantizer_scale) * *(qmat + j) >> 4;
#line 464
    if (sign) {
#line 464
      *(bp + j) = (short )(- val);
    } else {
#line 464
      *(bp + j) = (short )val;
    }
#line 465
    nc ++;
#line 467
    if (base.scalable_mode == 1) {
#line 467
      if (nc == base.priority_breakpoint - 63) {
#line 468
        ld = & enhan;
      }
    }
#line 350
    i ++;
  }
}
}
#line 475 "src/getblk.c"
void Decode_MPEG2_Non_Intra_Block(int comp ) 
{ 
  int val ;
  int i ;
  int j ;
  int sign ;
  int nc ;
  int run ;
  unsigned int code ;
  DCTtab *tab ;
  short *bp ;
  int *qmat ;
  struct layer_data *ld1 ;
  unsigned int tmp ;
  unsigned int tmp___0 ;
  unsigned int tmp___1 ;

  {
#line 486
  if (ld->scalable_mode == 1) {
#line 486
    ld1 = & base;
  } else {
#line 486
    ld1 = ld;
  }
#line 487
  bp = ld1->block[comp];
#line 489
  if (base.scalable_mode == 1) {
#line 490
    if (base.priority_breakpoint < 64) {
#line 491
      ld = & enhan;
    } else {
#line 493
      ld = & base;
    }
  }
#line 496
  if (comp < 4) {
#line 496
    qmat = ld1->non_intra_quantizer_matrix;
  } else
#line 496
  if (chroma_format == 1) {
#line 496
    qmat = ld1->non_intra_quantizer_matrix;
  } else {
#line 496
    qmat = ld1->chroma_non_intra_quantizer_matrix;
  }
#line 500
  nc = 0;
#line 508
  i = 0;
#line 508
  while (1) {
#line 510
    code = Show_Bits(16);
#line 511
    if (code >= 16384U) {
#line 513
      if (i == 0) {
#line 514
        tab = & DCTtabfirst[(code >> 12) - 4U];
      } else {
#line 516
        tab = & DCTtabnext[(code >> 12) - 4U];
      }
    } else
#line 518
    if (code >= 1024U) {
#line 519
      tab = & DCTtab0[(code >> 8) - 4U];
    } else
#line 520
    if (code >= 512U) {
#line 521
      tab = & DCTtab1[(code >> 6) - 8U];
    } else
#line 522
    if (code >= 256U) {
#line 523
      tab = & DCTtab2[(code >> 4) - 16U];
    } else
#line 524
    if (code >= 128U) {
#line 525
      tab = & DCTtab3[(code >> 3) - 16U];
    } else
#line 526
    if (code >= 64U) {
#line 527
      tab = & DCTtab4[(code >> 2) - 16U];
    } else
#line 528
    if (code >= 32U) {
#line 529
      tab = & DCTtab5[(code >> 1) - 16U];
    } else
#line 530
    if (code >= 16U) {
#line 531
      tab = & DCTtab6[code - 16U];
    } else {
#line 534
      if (! Quiet_Flag) {
#line 535
        printf((char const   * __restrict  )"invalid Huffman code in Decode_MPEG2_Non_Intra_Block()\n");
      }
#line 536
      Fault_Flag = 1;
#line 537
      return;
    }
#line 540
    Flush_Buffer((int )tab->len);
#line 550
    if ((int )tab->run == 64) {
#line 556
      return;
    }
#line 559
    if ((int )tab->run == 65) {
#line 569
      tmp = Get_Bits(6);
#line 569
      run = (int )tmp;
#line 569
      i += run;
#line 579
      tmp___0 = Get_Bits(12);
#line 579
      val = (int )tmp___0;
#line 580
      if ((val & 2047) == 0) {
#line 582
        if (! Quiet_Flag) {
#line 583
          printf((char const   * __restrict  )"invalid escape in Decode_MPEG2_Intra_Block()\n");
        }
#line 584
        Fault_Flag = 1;
#line 585
        return;
      }
#line 587
      sign = val >= 2048;
#line 587
      if (sign) {
#line 588
        val = 4096 - val;
      }
    } else {
#line 592
      run = (int )tab->run;
#line 592
      i += run;
#line 593
      val = (int )tab->level;
#line 594
      tmp___1 = Get_Bits(1);
#line 594
      sign = (int )tmp___1;
    }
#line 602
    if (i >= 64) {
#line 604
      if (! Quiet_Flag) {
#line 605
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"DCT coeff index (i) out of bounds (inter2)\n");
      }
#line 606
      Fault_Flag = 1;
#line 607
      return;
    }
#line 615
    j = (int )scan[ld1->alternate_scan][i];
#line 616
    val = (((val << 1) + 1) * ld1->quantizer_scale) * *(qmat + j) >> 5;
#line 617
    if (sign) {
#line 617
      *(bp + j) = (short )(- val);
    } else {
#line 617
      *(bp + j) = (short )val;
    }
#line 618
    nc ++;
#line 620
    if (base.scalable_mode == 1) {
#line 620
      if (nc == base.priority_breakpoint - 63) {
#line 621
        ld = & enhan;
      }
    }
#line 508
    i ++;
  }
}
}
#line 626 "src/getblk.c"
void Thrd_Decode_MPEG2_Intra_Block(int t , int comp , int *dc_dct_pred ) 
{ 
  int val ;
  int i ;
  int j ;
  int sign ;
  int nc ;
  int cc ;
  int run ;
  unsigned int code ;
  DCTtab *tab ;
  short *bp ;
  int *qmat ;
  struct layer_data *ld1 ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  unsigned int tmp___5 ;
  unsigned int tmp___6 ;
  unsigned int tmp___7 ;

  {
#line 639
  bp = thrd_ld[t].block[comp];
#line 640
  ld1 = ld;
#line 642
  if (comp < 4) {
#line 642
    cc = 0;
  } else {
#line 642
    cc = (comp & 1) + 1;
  }
#line 644
  if (comp < 4) {
#line 644
    qmat = ld1->intra_quantizer_matrix;
  } else
#line 644
  if (chroma_format == 1) {
#line 644
    qmat = ld1->intra_quantizer_matrix;
  } else {
#line 644
    qmat = ld1->chroma_intra_quantizer_matrix;
  }
#line 649
  if (cc == 0) {
#line 650
    tmp = Thrd_Get_Luma_DC_dct_diff(t);
#line 650
    tmp___0 = *(dc_dct_pred + 0) + tmp;
#line 650
    *(dc_dct_pred + 0) = tmp___0;
#line 650
    val = tmp___0;
  } else
#line 651
  if (cc == 1) {
#line 652
    tmp___1 = Thrd_Get_Chroma_DC_dct_diff(t);
#line 652
    tmp___2 = *(dc_dct_pred + 1) + tmp___1;
#line 652
    *(dc_dct_pred + 1) = tmp___2;
#line 652
    val = tmp___2;
  } else {
#line 654
    tmp___3 = Thrd_Get_Chroma_DC_dct_diff(t);
#line 654
    tmp___4 = *(dc_dct_pred + 2) + tmp___3;
#line 654
    *(dc_dct_pred + 2) = tmp___4;
#line 654
    val = tmp___4;
  }
#line 656
  if (Fault_Flag) {
#line 656
    return;
  }
#line 658
  *(bp + 0) = (short )(val << (3 - intra_dc_precision));
#line 660
  nc = 0;
#line 663
  i = 1;
#line 663
  while (1) {
#line 665
    code = Thrd_Show_Bits(t, 16);
#line 666
    if (code >= 16384U) {
#line 666
      if (! intra_vlc_format) {
#line 667
        tab = & DCTtabnext[(code >> 12) - 4U];
      } else {
#line 666
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 668
    if (code >= 1024U) {
#line 670
      if (intra_vlc_format) {
#line 671
        tab = & DCTtab0a[(code >> 8) - 4U];
      } else {
#line 673
        tab = & DCTtab0[(code >> 8) - 4U];
      }
    } else
#line 675
    if (code >= 512U) {
#line 677
      if (intra_vlc_format) {
#line 678
        tab = & DCTtab1a[(code >> 6) - 8U];
      } else {
#line 680
        tab = & DCTtab1[(code >> 6) - 8U];
      }
    } else
#line 682
    if (code >= 256U) {
#line 683
      tab = & DCTtab2[(code >> 4) - 16U];
    } else
#line 684
    if (code >= 128U) {
#line 685
      tab = & DCTtab3[(code >> 3) - 16U];
    } else
#line 686
    if (code >= 64U) {
#line 687
      tab = & DCTtab4[(code >> 2) - 16U];
    } else
#line 688
    if (code >= 32U) {
#line 689
      tab = & DCTtab5[(code >> 1) - 16U];
    } else
#line 690
    if (code >= 16U) {
#line 691
      tab = & DCTtab6[code - 16U];
    } else {
#line 694
      if (! Quiet_Flag) {
#line 695
        printf((char const   * __restrict  )"invalid Huffman code in Decode_MPEG2_Intra_Block()\n");
      }
#line 696
      Fault_Flag = 1;
#line 697
      return;
    }
#line 700
    Thrd_Flush_Buffer(t, (int )tab->len);
#line 702
    if ((int )tab->run == 64) {
#line 704
      return;
    }
#line 707
    if ((int )tab->run == 65) {
#line 709
      tmp___5 = Thrd_Get_Bits(t, 6);
#line 709
      run = (int )tmp___5;
#line 709
      i += run;
#line 711
      tmp___6 = Thrd_Get_Bits(t, 12);
#line 711
      val = (int )tmp___6;
#line 712
      if ((val & 2047) == 0) {
#line 714
        if (! Quiet_Flag) {
#line 715
          printf((char const   * __restrict  )"invalid escape in Decode_MPEG2_Intra_Block()\n");
        }
#line 716
        Fault_Flag = 1;
#line 717
        return;
      }
#line 719
      sign = val >= 2048;
#line 719
      if (sign) {
#line 720
        val = 4096 - val;
      }
    } else {
#line 724
      run = (int )tab->run;
#line 724
      i += run;
#line 725
      val = (int )tab->level;
#line 726
      tmp___7 = Thrd_Get_Bits(t, 1);
#line 726
      sign = (int )tmp___7;
    }
#line 730
    if (i >= 64) {
#line 732
      if (! Quiet_Flag) {
#line 733
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"DCT coeff index (i) out of bounds (intra2)\n");
      }
#line 734
      Fault_Flag = 1;
#line 735
      return;
    }
#line 738
    j = (int )scan[ld1->alternate_scan][i];
#line 739
    val = (val * thrd_ld[t].quantizer_scale) * *(qmat + j) >> 4;
#line 740
    if (sign) {
#line 740
      *(bp + j) = (short )(- val);
    } else {
#line 740
      *(bp + j) = (short )val;
    }
#line 741
    nc ++;
#line 743
    if (base.scalable_mode == 1) {
#line 743
      if (nc == base.priority_breakpoint - 63) {
#line 744
        ld = & enhan;
      }
    }
#line 663
    i ++;
  }
}
}
#line 751 "src/getblk.c"
void Thrd_Decode_MPEG2_Non_Intra_Block(int t , int comp ) 
{ 
  int val ;
  int i ;
  int j ;
  int sign ;
  int nc ;
  int run ;
  unsigned int code ;
  DCTtab *tab ;
  short *bp ;
  int *qmat ;
  struct layer_data *ld1 ;
  unsigned int tmp ;
  unsigned int tmp___0 ;
  unsigned int tmp___1 ;

  {
#line 763
  ld1 = ld;
#line 764
  bp = thrd_ld[t].block[comp];
#line 766
  if (base.scalable_mode == 1) {
#line 767
    if (base.priority_breakpoint < 64) {
#line 768
      ld = & enhan;
    } else {
#line 770
      ld = & base;
    }
  }
#line 772
  if (comp < 4) {
#line 772
    qmat = ld1->non_intra_quantizer_matrix;
  } else
#line 772
  if (chroma_format == 1) {
#line 772
    qmat = ld1->non_intra_quantizer_matrix;
  } else {
#line 772
    qmat = ld1->chroma_non_intra_quantizer_matrix;
  }
#line 776
  nc = 0;
#line 779
  i = 0;
#line 779
  while (1) {
#line 781
    code = Thrd_Show_Bits(t, 16);
#line 782
    if (code >= 16384U) {
#line 784
      if (i == 0) {
#line 785
        tab = & DCTtabfirst[(code >> 12) - 4U];
      } else {
#line 787
        tab = & DCTtabnext[(code >> 12) - 4U];
      }
    } else
#line 789
    if (code >= 1024U) {
#line 790
      tab = & DCTtab0[(code >> 8) - 4U];
    } else
#line 791
    if (code >= 512U) {
#line 792
      tab = & DCTtab1[(code >> 6) - 8U];
    } else
#line 793
    if (code >= 256U) {
#line 794
      tab = & DCTtab2[(code >> 4) - 16U];
    } else
#line 795
    if (code >= 128U) {
#line 796
      tab = & DCTtab3[(code >> 3) - 16U];
    } else
#line 797
    if (code >= 64U) {
#line 798
      tab = & DCTtab4[(code >> 2) - 16U];
    } else
#line 799
    if (code >= 32U) {
#line 800
      tab = & DCTtab5[(code >> 1) - 16U];
    } else
#line 801
    if (code >= 16U) {
#line 802
      tab = & DCTtab6[code - 16U];
    } else {
#line 805
      if (! Quiet_Flag) {
#line 806
        printf((char const   * __restrict  )"invalid Huffman code in Decode_MPEG2_Non_Intra_Block()\n");
      }
#line 807
      Fault_Flag = 1;
#line 808
      return;
    }
#line 811
    Thrd_Flush_Buffer(t, (int )tab->len);
#line 813
    if ((int )tab->run == 64) {
#line 815
      return;
    }
#line 818
    if ((int )tab->run == 65) {
#line 820
      tmp = Thrd_Get_Bits(t, 6);
#line 820
      run = (int )tmp;
#line 820
      i += run;
#line 822
      tmp___0 = Thrd_Get_Bits(t, 12);
#line 822
      val = (int )tmp___0;
#line 823
      if ((val & 2047) == 0) {
#line 825
        if (! Quiet_Flag) {
#line 826
          printf((char const   * __restrict  )"invalid escape in Decode_MPEG2_Intra_Block()\n");
        }
#line 827
        Fault_Flag = 1;
#line 828
        return;
      }
#line 830
      sign = val >= 2048;
#line 830
      if (sign) {
#line 831
        val = 4096 - val;
      }
    } else {
#line 835
      run = (int )tab->run;
#line 835
      i += run;
#line 836
      val = (int )tab->level;
#line 837
      tmp___1 = Thrd_Get_Bits(t, 1);
#line 837
      sign = (int )tmp___1;
    }
#line 841
    if (i >= 64) {
#line 843
      if (! Quiet_Flag) {
#line 844
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"DCT coeff index (i) out of bounds (inter2)\n");
      }
#line 845
      Fault_Flag = 1;
#line 846
      return;
    }
#line 849
    j = (int )scan[ld1->alternate_scan][i];
#line 850
    val = (((val << 1) + 1) * thrd_ld[t].quantizer_scale) * *(qmat + j) >> 5;
#line 851
    if (sign) {
#line 851
      *(bp + j) = (short )(- val);
    } else {
#line 851
      *(bp + j) = (short )val;
    }
#line 852
    nc ++;
#line 854
    if (base.scalable_mode == 1) {
#line 854
      if (nc == base.priority_breakpoint - 63) {
#line 855
        ld = & enhan;
      }
    }
#line 779
    i ++;
  }
}
}
#line 1 "gethdr.o"
#pragma merger("0","/tmp/cil-coGGbFTr.i","-g,-O4")
#line 542 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 121 "src/global.h"
void Flush_Buffer32(void) ;
#line 122
unsigned int Get_Bits32(void) ;
#line 138
int Get_Hdr(void) ;
#line 139
void next_start_code(void) ;
#line 140
int slice_header(void) ;
#line 141
void marker_bit(char *text ) ;
#line 181
void Error(char *text ) ;
#line 216
void Thrd_next_start_code(int t ) ;
#line 217
int Thrd_slice_header(int t ) ;
#line 263
unsigned char default_intra_quantizer_matrix[64] ;
#line 280
unsigned char Non_Linear_quantizer_scale[32] ;
#line 343
int Verbose_Flag ;
#line 395
int profile ;
#line 395
int level ;
#line 398
int horizontal_size ;
#line 399
int vertical_size ;
#line 402
double bit_rate ;
#line 403
double frame_rate ;
#line 410
int aspect_ratio_information ;
#line 411
int frame_rate_code ;
#line 412
int bit_rate_value ;
#line 413
int vbv_buffer_size ;
#line 414
int constrained_parameters_flag ;
#line 417
int profile_and_level_indication ;
#line 418
int progressive_sequence ;
#line 420
int low_delay ;
#line 421
int frame_rate_extension_n ;
#line 422
int frame_rate_extension_d ;
#line 425
int video_format ;
#line 426
int color_description ;
#line 427
int color_primaries ;
#line 428
int transfer_characteristics ;
#line 429
int matrix_coefficients ;
#line 430
int display_horizontal_size ;
#line 431
int display_vertical_size ;
#line 434
int temporal_reference ;
#line 436
int vbv_delay ;
#line 437
int full_pel_forward_vector ;
#line 438
int forward_f_code ;
#line 439
int full_pel_backward_vector ;
#line 440
int backward_f_code ;
#line 444
int f_code[2][2] ;
#line 446
int picture_structure ;
#line 447
int top_field_first ;
#line 448
int frame_pred_frame_dct ;
#line 449
int concealment_motion_vectors ;
#line 453
int repeat_first_field ;
#line 455
int chroma_420_type ;
#line 456
int progressive_frame ;
#line 457
int composite_display_flag ;
#line 458
int v_axis ;
#line 459
int field_sequence ;
#line 460
int sub_carrier ;
#line 461
int burst_amplitude ;
#line 462
int sub_carrier_phase ;
#line 467
int frame_center_horizontal_offset[3] ;
#line 468
int frame_center_vertical_offset[3] ;
#line 473
int layer_id ;
#line 474
int lower_layer_prediction_horizontal_size ;
#line 475
int lower_layer_prediction_vertical_size ;
#line 476
int horizontal_subsampling_factor_m ;
#line 477
int horizontal_subsampling_factor_n ;
#line 478
int vertical_subsampling_factor_m ;
#line 479
int vertical_subsampling_factor_n ;
#line 483
int lower_layer_temporal_reference ;
#line 484
int lower_layer_horizontal_offset ;
#line 485
int lower_layer_vertical_offset ;
#line 486
int spatial_temporal_weight_code_table_index ;
#line 487
int lower_layer_progressive_frame ;
#line 488
int lower_layer_deinterlaced_field_select ;
#line 496
int copyright_flag ;
#line 497
int copyright_identifier ;
#line 498
int original_or_copy ;
#line 499
int copyright_number_1 ;
#line 500
int copyright_number_2 ;
#line 501
int copyright_number_3 ;
#line 504
int drop_flag ;
#line 505
int hour ;
#line 506
int minute ;
#line 507
int sec ;
#line 508
int frame ;
#line 509
int closed_gop ;
#line 510
int broken_link ;
#line 582
int True_Framenum ;
#line 89 "src/gethdr.c"
static void sequence_header(void) ;
#line 90
static void group_of_pictures_header(void) ;
#line 91
static void picture_header(void) ;
#line 92
static void extension_and_user_data(void) ;
#line 93
static void sequence_extension(void) ;
#line 94
static void sequence_display_extension(void) ;
#line 95
static void quant_matrix_extension(void) ;
#line 96
static void sequence_scalable_extension(void) ;
#line 97
static void picture_display_extension(void) ;
#line 98
static void picture_coding_extension(void) ;
#line 99
static void picture_spatial_scalable_extension(void) ;
#line 100
static void picture_temporal_scalable_extension(void) ;
#line 101
static int extra_bit_information(void) ;
#line 102
static void copyright_extension(void) ;
#line 103
static void user_data(void) ;
#line 106
static int Thrd_extra_bit_information(int t ) ;
#line 112
static void Update_Temporal_Reference_Tacking_Data(void) ;
#line 114 "src/gethdr.c"
static int Temporal_Reference_Base  =    0;
#line 115 "src/gethdr.c"
static int True_Framenum_max  =    -1;
#line 116 "src/gethdr.c"
static int Temporal_Reference_GOP_Reset  =    0;
#line 119 "src/gethdr.c"
static double frame_rate_Table[16]  = 
#line 119
  {      0.0,      (23.0 * 1000.0) / 1001.0,      24.0,      25.0, 
        (30.0 * 1000.0) / 1001.0,      30.0,      50.0,      (60.0 * 1000.0) / 1001.0, 
        60.0,      (double )-1,      (double )-1,      (double )-1, 
        (double )-1,      (double )-1,      (double )-1,      (double )-1};
#line 145 "src/gethdr.c"
int Get_Hdr(void) 
{ 
  unsigned int code ;

  {
#line 149
  while (1) {
#line 152
    next_start_code();
#line 153
    code = Get_Bits32();
#line 155
    switch (code) {
    case 435U: 
#line 158
    sequence_header();
#line 159
    break;
    case 440U: 
#line 161
    group_of_pictures_header();
#line 162
    break;
    case 256U: 
#line 164
    picture_header();
#line 165
    return (1);
#line 166
    break;
    case 439U: 
#line 168
    return (0);
#line 169
    break;
    default: 
#line 171
    if (! Quiet_Flag) {
#line 172
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Unexpected next_start_code %08x (ignored)\n",
              code);
    }
#line 173
    break;
    }
  }
}
}
#line 181 "src/gethdr.c"
void next_start_code(void) 
{ 
  unsigned int tmp ;

  {
#line 184
  Flush_Buffer(ld->Incnt & 7);
#line 185
  while (1) {
#line 185
    tmp = Show_Bits(24);
#line 185
    if (! ((long )tmp != 1L)) {
#line 185
      break;
    }
#line 186
    Flush_Buffer(8);
  }
#line 187
  return;
}
}
#line 190 "src/gethdr.c"
void Thrd_next_start_code(int t ) 
{ 
  unsigned int tmp ;

  {
#line 193
  Thrd_Flush_Buffer(t, thrd_Incnt[t] & 7);
#line 194
  while (1) {
#line 194
    tmp = Thrd_Show_Bits(t, 24);
#line 194
    if (! ((long )tmp != 1L)) {
#line 194
      break;
    }
#line 195
    Thrd_Flush_Buffer(t, 8);
  }
#line 196
  return;
}
}
#line 198 "src/gethdr.c"
int Thrd_slice_header(int t ) 
{ 
  int slice_vertical_position_extension ;
  int quantizer_scale_code ;
  int slice_picture_id_enable ;
  int slice_picture_id ;
  int extra_information_slice ;
  unsigned int tmp ;
  unsigned int tmp___0 ;
  unsigned int tmp___1 ;
  int tmp___2 ;
  unsigned int tmp___3 ;
  unsigned int tmp___4 ;
  unsigned int tmp___5 ;
  unsigned int tmp___6 ;

  {
#line 203
  slice_picture_id_enable = 0;
#line 204
  slice_picture_id = 0;
#line 205
  extra_information_slice = 0;
#line 208
  if (ld->MPEG2_Flag) {
#line 208
    if (vertical_size > 2800) {
#line 208
      tmp = Thrd_Get_Bits(t, 3);
#line 208
      slice_vertical_position_extension = (int )tmp;
    } else {
#line 208
      slice_vertical_position_extension = 0;
    }
  } else {
#line 208
    slice_vertical_position_extension = 0;
  }
#line 211
  if (ld->scalable_mode == 1) {
#line 212
    printf((char const   * __restrict  )"scalable_mode==SC_DP\n");
#line 212
    exit(-1);
#line 213
    tmp___0 = Get_Bits(7);
#line 213
    ld->priority_breakpoint = (int )tmp___0;
  }
#line 216
  tmp___1 = Thrd_Get_Bits(t, 5);
#line 216
  quantizer_scale_code = (int )tmp___1;
#line 217
  if (ld->MPEG2_Flag) {
#line 217
    if (ld->q_scale_type) {
#line 217
      tmp___2 = (int )Non_Linear_quantizer_scale[quantizer_scale_code];
    } else {
#line 217
      tmp___2 = quantizer_scale_code << 1;
    }
#line 217
    thrd_ld[t].quantizer_scale = tmp___2;
  } else {
#line 217
    thrd_ld[t].quantizer_scale = quantizer_scale_code;
  }
#line 222
  tmp___6 = Thrd_Get_Bits(t, 1);
#line 222
  if (tmp___6) {
#line 223
    tmp___3 = Thrd_Get_Bits(t, 1);
#line 223
    thrd_ld[t].intra_slice = (int )tmp___3;
#line 225
    tmp___4 = Thrd_Get_Bits(t, 1);
#line 225
    slice_picture_id_enable = (int )tmp___4;
#line 226
    tmp___5 = Thrd_Get_Bits(t, 6);
#line 226
    slice_picture_id = (int )tmp___5;
#line 228
    extra_information_slice = Thrd_extra_bit_information(t);
  } else {
#line 231
    thrd_ld[t].intra_slice = 0;
  }
#line 233
  return (slice_vertical_position_extension);
}
}
#line 236 "src/gethdr.c"
static int Thrd_extra_bit_information(int t ) 
{ 
  int Byte_Count ;
  unsigned int tmp ;

  {
#line 239
  Byte_Count = 0;
#line 241
  while (1) {
#line 241
    tmp = Thrd_Get_Bits1(t);
#line 241
    if (! tmp) {
#line 241
      break;
    }
#line 243
    Thrd_Flush_Buffer(t, 8);
#line 244
    Byte_Count ++;
  }
#line 247
  return (Byte_Count);
}
}
#line 255 "src/gethdr.c"
static void sequence_header(void) 
{ 
  int i ;
  int pos ;
  unsigned int tmp ;
  unsigned int tmp___0 ;
  unsigned int tmp___1 ;
  unsigned int tmp___2 ;
  unsigned int tmp___3 ;
  unsigned int tmp___4 ;
  unsigned int tmp___5 ;
  unsigned int tmp___6 ;
  int tmp___7 ;
  unsigned int tmp___8 ;
  unsigned int tmp___9 ;
  int tmp___10 ;
  unsigned int tmp___11 ;

  {
#line 260
  pos = ld->Bitcnt;
#line 261
  tmp = Get_Bits(12);
#line 261
  horizontal_size = (int )tmp;
#line 262
  tmp___0 = Get_Bits(12);
#line 262
  vertical_size = (int )tmp___0;
#line 263
  tmp___1 = Get_Bits(4);
#line 263
  aspect_ratio_information = (int )tmp___1;
#line 264
  tmp___2 = Get_Bits(4);
#line 264
  frame_rate_code = (int )tmp___2;
#line 265
  tmp___3 = Get_Bits(18);
#line 265
  bit_rate_value = (int )tmp___3;
#line 266
  marker_bit((char *)"sequence_header()");
#line 267
  tmp___4 = Get_Bits(10);
#line 267
  vbv_buffer_size = (int )tmp___4;
#line 268
  tmp___5 = Get_Bits(1);
#line 268
  constrained_parameters_flag = (int )tmp___5;
#line 270
  tmp___8 = Get_Bits(1);
#line 270
  tmp___7 = (int )tmp___8;
#line 270
  ld->load_intra_quantizer_matrix = tmp___7;
#line 270
  if (tmp___7) {
#line 272
    i = 0;
#line 272
    while (i < 64) {
#line 273
      tmp___6 = Get_Bits(8);
#line 273
      ld->intra_quantizer_matrix[scan[0][i]] = (int )tmp___6;
#line 272
      i ++;
    }
  } else {
#line 277
    i = 0;
#line 277
    while (i < 64) {
#line 278
      ld->intra_quantizer_matrix[i] = (int )default_intra_quantizer_matrix[i];
#line 277
      i ++;
    }
  }
#line 281
  tmp___11 = Get_Bits(1);
#line 281
  tmp___10 = (int )tmp___11;
#line 281
  ld->load_non_intra_quantizer_matrix = tmp___10;
#line 281
  if (tmp___10) {
#line 283
    i = 0;
#line 283
    while (i < 64) {
#line 284
      tmp___9 = Get_Bits(8);
#line 284
      ld->non_intra_quantizer_matrix[scan[0][i]] = (int )tmp___9;
#line 283
      i ++;
    }
  } else {
#line 288
    i = 0;
#line 288
    while (i < 64) {
#line 289
      ld->non_intra_quantizer_matrix[i] = 16;
#line 288
      i ++;
    }
  }
#line 293
  i = 0;
#line 293
  while (i < 64) {
#line 295
    ld->chroma_intra_quantizer_matrix[i] = ld->intra_quantizer_matrix[i];
#line 298
    ld->chroma_non_intra_quantizer_matrix[i] = ld->non_intra_quantizer_matrix[i];
#line 293
    i ++;
  }
#line 325
  extension_and_user_data();
#line 326
  return;
}
}
#line 332 "src/gethdr.c"
static void group_of_pictures_header(void) 
{ 
  int pos ;
  unsigned int tmp ;
  unsigned int tmp___0 ;
  unsigned int tmp___1 ;
  unsigned int tmp___2 ;
  unsigned int tmp___3 ;
  unsigned int tmp___4 ;
  unsigned int tmp___5 ;

  {
#line 336
  if ((unsigned long )ld == (unsigned long )(& base)) {
#line 338
    Temporal_Reference_Base = True_Framenum_max + 1;
#line 339
    Temporal_Reference_GOP_Reset = 1;
  }
#line 341
  pos = ld->Bitcnt;
#line 342
  tmp = Get_Bits(1);
#line 342
  drop_flag = (int )tmp;
#line 343
  tmp___0 = Get_Bits(5);
#line 343
  hour = (int )tmp___0;
#line 344
  tmp___1 = Get_Bits(6);
#line 344
  minute = (int )tmp___1;
#line 345
  marker_bit((char *)"group_of_pictures_header()");
#line 346
  tmp___2 = Get_Bits(6);
#line 346
  sec = (int )tmp___2;
#line 347
  tmp___3 = Get_Bits(6);
#line 347
  frame = (int )tmp___3;
#line 348
  tmp___4 = Get_Bits(1);
#line 348
  closed_gop = (int )tmp___4;
#line 349
  tmp___5 = Get_Bits(1);
#line 349
  broken_link = (int )tmp___5;
#line 369
  extension_and_user_data();
#line 371
  return;
}
}
#line 377 "src/gethdr.c"
static void picture_header(void) 
{ 
  int pos ;
  int Extra_Information_Byte_Count ;
  unsigned int tmp ;
  unsigned int tmp___0 ;
  unsigned int tmp___1 ;
  unsigned int tmp___2 ;
  unsigned int tmp___3 ;
  unsigned int tmp___4 ;
  unsigned int tmp___5 ;

  {
#line 383
  ld->pict_scal = 0;
#line 385
  pos = ld->Bitcnt;
#line 386
  tmp = Get_Bits(10);
#line 386
  temporal_reference = (int )tmp;
#line 387
  tmp___0 = Get_Bits(3);
#line 387
  picture_coding_type = (int )tmp___0;
#line 388
  tmp___1 = Get_Bits(16);
#line 388
  vbv_delay = (int )tmp___1;
#line 391
  if (picture_coding_type == 2) {
#line 393
    tmp___2 = Get_Bits(1);
#line 393
    full_pel_forward_vector = (int )tmp___2;
#line 394
    tmp___3 = Get_Bits(3);
#line 394
    forward_f_code = (int )tmp___3;
  } else
#line 391
  if (picture_coding_type == 3) {
#line 393
    tmp___2 = Get_Bits(1);
#line 393
    full_pel_forward_vector = (int )tmp___2;
#line 394
    tmp___3 = Get_Bits(3);
#line 394
    forward_f_code = (int )tmp___3;
  }
#line 396
  if (picture_coding_type == 3) {
#line 398
    tmp___4 = Get_Bits(1);
#line 398
    full_pel_backward_vector = (int )tmp___4;
#line 399
    tmp___5 = Get_Bits(3);
#line 399
    backward_f_code = (int )tmp___5;
  }
#line 429
  Extra_Information_Byte_Count = extra_bit_information();
#line 432
  extension_and_user_data();
#line 435
  Update_Temporal_Reference_Tacking_Data();
#line 436
  return;
}
}
#line 441 "src/gethdr.c"
int slice_header(void) 
{ 
  int slice_vertical_position_extension ;
  int quantizer_scale_code ;
  int pos ;
  int slice_picture_id_enable ;
  int slice_picture_id ;
  int extra_information_slice ;
  unsigned int tmp ;
  unsigned int tmp___0 ;
  unsigned int tmp___1 ;
  int tmp___2 ;
  unsigned int tmp___3 ;
  unsigned int tmp___4 ;
  unsigned int tmp___5 ;
  unsigned int tmp___6 ;

  {
#line 446
  slice_picture_id_enable = 0;
#line 447
  slice_picture_id = 0;
#line 448
  extra_information_slice = 0;
#line 450
  pos = ld->Bitcnt;
#line 452
  if (ld->MPEG2_Flag) {
#line 452
    if (vertical_size > 2800) {
#line 452
      tmp = Get_Bits(3);
#line 452
      slice_vertical_position_extension = (int )tmp;
    } else {
#line 452
      slice_vertical_position_extension = 0;
    }
  } else {
#line 452
    slice_vertical_position_extension = 0;
  }
#line 455
  if (ld->scalable_mode == 1) {
#line 456
    tmp___0 = Get_Bits(7);
#line 456
    ld->priority_breakpoint = (int )tmp___0;
  }
#line 458
  tmp___1 = Get_Bits(5);
#line 458
  quantizer_scale_code = (int )tmp___1;
#line 459
  if (ld->MPEG2_Flag) {
#line 459
    if (ld->q_scale_type) {
#line 459
      tmp___2 = (int )Non_Linear_quantizer_scale[quantizer_scale_code];
    } else {
#line 459
      tmp___2 = quantizer_scale_code << 1;
    }
#line 459
    ld->quantizer_scale = tmp___2;
  } else {
#line 459
    ld->quantizer_scale = quantizer_scale_code;
  }
#line 464
  tmp___6 = Get_Bits(1);
#line 464
  if (tmp___6) {
#line 466
    tmp___3 = Get_Bits(1);
#line 466
    ld->intra_slice = (int )tmp___3;
#line 468
    tmp___4 = Get_Bits(1);
#line 468
    slice_picture_id_enable = (int )tmp___4;
#line 469
    tmp___5 = Get_Bits(6);
#line 469
    slice_picture_id = (int )tmp___5;
#line 471
    extra_information_slice = extra_bit_information();
  } else {
#line 474
    ld->intra_slice = 0;
  }
#line 504
  return (slice_vertical_position_extension);
}
}
#line 510 "src/gethdr.c"
static void extension_and_user_data(void) 
{ 
  int code ;
  int ext_ID ;
  unsigned int tmp ;
  unsigned int tmp___0 ;

  {
#line 514
  next_start_code();
#line 516
  while (1) {
#line 516
    tmp___0 = Show_Bits(32);
#line 516
    code = (int )tmp___0;
#line 516
    if (! (code == 437)) {
#line 516
      if (! (code == 434)) {
#line 516
        break;
      }
    }
#line 518
    if (code == 437) {
#line 520
      Flush_Buffer32();
#line 521
      tmp = Get_Bits(4);
#line 521
      ext_ID = (int )tmp;
#line 522
      switch (ext_ID) {
      case 1: 
#line 525
      sequence_extension();
#line 526
      break;
      case 2: 
#line 528
      sequence_display_extension();
#line 529
      break;
      case 3: 
#line 531
      quant_matrix_extension();
#line 532
      break;
      case 5: 
#line 534
      sequence_scalable_extension();
#line 535
      break;
      case 7: 
#line 537
      picture_display_extension();
#line 538
      break;
      case 8: 
#line 540
      picture_coding_extension();
#line 541
      break;
      case 9: 
#line 543
      picture_spatial_scalable_extension();
#line 544
      break;
      case 10: 
#line 546
      picture_temporal_scalable_extension();
#line 547
      break;
      case 4: 
#line 549
      copyright_extension();
#line 550
      break;
      default: 
#line 552
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"reserved extension start code ID %d\n",
              ext_ID);
#line 553
      break;
      }
#line 555
      next_start_code();
    } else {
#line 563
      Flush_Buffer32();
#line 564
      user_data();
    }
  }
#line 567
  return;
}
}
#line 573 "src/gethdr.c"
static void sequence_extension(void) 
{ 
  int horizontal_size_extension ;
  int vertical_size_extension ;
  int bit_rate_extension ;
  int vbv_buffer_size_extension ;
  unsigned int tmp ;
  unsigned int tmp___0 ;
  unsigned int tmp___1 ;
  unsigned int tmp___2 ;
  unsigned int tmp___3 ;
  unsigned int tmp___4 ;
  unsigned int tmp___5 ;
  unsigned int tmp___6 ;
  unsigned int tmp___7 ;
  unsigned int tmp___8 ;

  {
#line 587
  ld->MPEG2_Flag = 1;
#line 589
  ld->scalable_mode = 0;
#line 590
  layer_id = 0;
#line 592
  tmp = Get_Bits(8);
#line 592
  profile_and_level_indication = (int )tmp;
#line 593
  tmp___0 = Get_Bits(1);
#line 593
  progressive_sequence = (int )tmp___0;
#line 594
  tmp___1 = Get_Bits(2);
#line 594
  chroma_format = (int )tmp___1;
#line 595
  tmp___2 = Get_Bits(2);
#line 595
  horizontal_size_extension = (int )tmp___2;
#line 596
  tmp___3 = Get_Bits(2);
#line 596
  vertical_size_extension = (int )tmp___3;
#line 597
  tmp___4 = Get_Bits(12);
#line 597
  bit_rate_extension = (int )tmp___4;
#line 598
  marker_bit((char *)"sequence_extension");
#line 599
  tmp___5 = Get_Bits(8);
#line 599
  vbv_buffer_size_extension = (int )tmp___5;
#line 600
  tmp___6 = Get_Bits(1);
#line 600
  low_delay = (int )tmp___6;
#line 601
  tmp___7 = Get_Bits(2);
#line 601
  frame_rate_extension_n = (int )tmp___7;
#line 602
  tmp___8 = Get_Bits(5);
#line 602
  frame_rate_extension_d = (int )tmp___8;
#line 604
  frame_rate = frame_rate_Table[frame_rate_code] * (double )((frame_rate_extension_n + 1) / (frame_rate_extension_d + 1));
#line 608
  if ((profile_and_level_indication >> 7) & 1) {
#line 612
    if ((profile_and_level_indication & 15) == 5) {
#line 614
      profile = 133;
#line 615
      level = 8;
    }
  } else {
#line 620
    profile = profile_and_level_indication >> 4;
#line 621
    level = profile_and_level_indication & 15;
  }
#line 625
  horizontal_size = (horizontal_size_extension << 12) | (horizontal_size & 4095);
#line 626
  vertical_size = (vertical_size_extension << 12) | (vertical_size & 4095);
#line 635
  bit_rate_value += bit_rate_extension << 18;
#line 636
  bit_rate = (double )bit_rate_value * 400.0;
#line 637
  vbv_buffer_size += vbv_buffer_size_extension << 10;
#line 671
  return;
}
}
#line 676 "src/gethdr.c"
static void sequence_display_extension(void) 
{ 
  int pos ;
  unsigned int tmp ;
  unsigned int tmp___0 ;
  unsigned int tmp___1 ;
  unsigned int tmp___2 ;
  unsigned int tmp___3 ;
  unsigned int tmp___4 ;
  unsigned int tmp___5 ;

  {
#line 680
  pos = ld->Bitcnt;
#line 681
  tmp = Get_Bits(3);
#line 681
  video_format = (int )tmp;
#line 682
  tmp___0 = Get_Bits(1);
#line 682
  color_description = (int )tmp___0;
#line 684
  if (color_description) {
#line 686
    tmp___1 = Get_Bits(8);
#line 686
    color_primaries = (int )tmp___1;
#line 687
    tmp___2 = Get_Bits(8);
#line 687
    transfer_characteristics = (int )tmp___2;
#line 688
    tmp___3 = Get_Bits(8);
#line 688
    matrix_coefficients = (int )tmp___3;
  }
#line 691
  tmp___4 = Get_Bits(14);
#line 691
  display_horizontal_size = (int )tmp___4;
#line 692
  marker_bit((char *)"sequence_display_extension");
#line 693
  tmp___5 = Get_Bits(14);
#line 693
  display_vertical_size = (int )tmp___5;
#line 721
  return;
}
}
#line 726 "src/gethdr.c"
static void quant_matrix_extension(void) 
{ 
  int i ;
  int pos ;
  int tmp ;
  unsigned int tmp___0 ;
  int tmp___1 ;
  unsigned int tmp___2 ;
  int tmp___3 ;
  unsigned int tmp___4 ;
  int tmp___5 ;
  unsigned int tmp___6 ;
  unsigned int tmp___7 ;
  int tmp___8 ;
  unsigned int tmp___9 ;
  unsigned int tmp___10 ;
  int tmp___11 ;
  unsigned int tmp___12 ;

  {
#line 731
  pos = ld->Bitcnt;
#line 733
  tmp___2 = Get_Bits(1);
#line 733
  tmp___1 = (int )tmp___2;
#line 733
  ld->load_intra_quantizer_matrix = tmp___1;
#line 733
  if (tmp___1) {
#line 735
    i = 0;
#line 735
    while (i < 64) {
#line 737
      tmp___0 = Get_Bits(8);
#line 737
      tmp = (int )tmp___0;
#line 737
      ld->intra_quantizer_matrix[scan[0][i]] = tmp;
#line 737
      ld->chroma_intra_quantizer_matrix[scan[0][i]] = tmp;
#line 735
      i ++;
    }
  }
#line 743
  tmp___6 = Get_Bits(1);
#line 743
  tmp___5 = (int )tmp___6;
#line 743
  ld->load_non_intra_quantizer_matrix = tmp___5;
#line 743
  if (tmp___5) {
#line 745
    i = 0;
#line 745
    while (i < 64) {
#line 747
      tmp___4 = Get_Bits(8);
#line 747
      tmp___3 = (int )tmp___4;
#line 747
      ld->non_intra_quantizer_matrix[scan[0][i]] = tmp___3;
#line 747
      ld->chroma_non_intra_quantizer_matrix[scan[0][i]] = tmp___3;
#line 745
      i ++;
    }
  }
#line 753
  tmp___9 = Get_Bits(1);
#line 753
  tmp___8 = (int )tmp___9;
#line 753
  ld->load_chroma_intra_quantizer_matrix = tmp___8;
#line 753
  if (tmp___8) {
#line 755
    i = 0;
#line 755
    while (i < 64) {
#line 756
      tmp___7 = Get_Bits(8);
#line 756
      ld->chroma_intra_quantizer_matrix[scan[0][i]] = (int )tmp___7;
#line 755
      i ++;
    }
  }
#line 759
  tmp___12 = Get_Bits(1);
#line 759
  tmp___11 = (int )tmp___12;
#line 759
  ld->load_chroma_non_intra_quantizer_matrix = tmp___11;
#line 759
  if (tmp___11) {
#line 761
    i = 0;
#line 761
    while (i < 64) {
#line 762
      tmp___10 = Get_Bits(8);
#line 762
      ld->chroma_non_intra_quantizer_matrix[scan[0][i]] = (int )tmp___10;
#line 761
      i ++;
    }
  }
#line 784
  return;
}
}
#line 789 "src/gethdr.c"
static void sequence_scalable_extension(void) 
{ 
  int pos ;
  unsigned int tmp ;
  unsigned int tmp___0 ;
  unsigned int tmp___1 ;
  unsigned int tmp___2 ;
  unsigned int tmp___3 ;
  unsigned int tmp___4 ;
  unsigned int tmp___5 ;
  unsigned int tmp___6 ;

  {
#line 793
  pos = ld->Bitcnt;
#line 797
  tmp = Get_Bits(2);
#line 797
  ld->scalable_mode = (int )(tmp + 1U);
#line 799
  tmp___0 = Get_Bits(4);
#line 799
  layer_id = (int )tmp___0;
#line 801
  if (ld->scalable_mode == 2) {
#line 803
    tmp___1 = Get_Bits(14);
#line 803
    lower_layer_prediction_horizontal_size = (int )tmp___1;
#line 804
    marker_bit((char *)"sequence_scalable_extension()");
#line 805
    tmp___2 = Get_Bits(14);
#line 805
    lower_layer_prediction_vertical_size = (int )tmp___2;
#line 806
    tmp___3 = Get_Bits(5);
#line 806
    horizontal_subsampling_factor_m = (int )tmp___3;
#line 807
    tmp___4 = Get_Bits(5);
#line 807
    horizontal_subsampling_factor_n = (int )tmp___4;
#line 808
    tmp___5 = Get_Bits(5);
#line 808
    vertical_subsampling_factor_m = (int )tmp___5;
#line 809
    tmp___6 = Get_Bits(5);
#line 809
    vertical_subsampling_factor_n = (int )tmp___6;
  }
#line 812
  if (ld->scalable_mode == 4) {
#line 813
    Error((char *)"temporal scalability not implemented\n");
  }
#line 846
  return;
}
}
#line 851 "src/gethdr.c"
static void picture_display_extension(void) 
{ 
  int i ;
  int number_of_frame_center_offsets ;
  int pos ;
  unsigned int tmp ;
  unsigned int tmp___0 ;

  {
#line 857
  pos = ld->Bitcnt;
#line 862
  if (progressive_sequence) {
#line 864
    if (repeat_first_field) {
#line 866
      if (top_field_first) {
#line 867
        number_of_frame_center_offsets = 3;
      } else {
#line 869
        number_of_frame_center_offsets = 2;
      }
    } else {
#line 873
      number_of_frame_center_offsets = 1;
    }
  } else
#line 878
  if (picture_structure != 3) {
#line 880
    number_of_frame_center_offsets = 1;
  } else
#line 884
  if (repeat_first_field) {
#line 885
    number_of_frame_center_offsets = 3;
  } else {
#line 887
    number_of_frame_center_offsets = 2;
  }
#line 893
  i = 0;
#line 893
  while (i < number_of_frame_center_offsets) {
#line 895
    tmp = Get_Bits(16);
#line 895
    frame_center_horizontal_offset[i] = (int )tmp;
#line 896
    marker_bit((char *)"picture_display_extension, first marker bit");
#line 898
    tmp___0 = Get_Bits(16);
#line 898
    frame_center_vertical_offset[i] = (int )tmp___0;
#line 899
    marker_bit((char *)"picture_display_extension, second marker bit");
#line 893
    i ++;
  }
#line 924
  return;
}
}
#line 928 "src/gethdr.c"
static void picture_coding_extension(void) 
{ 
  int pos ;
  unsigned int tmp ;
  unsigned int tmp___0 ;
  unsigned int tmp___1 ;
  unsigned int tmp___2 ;
  unsigned int tmp___3 ;
  unsigned int tmp___4 ;
  unsigned int tmp___5 ;
  unsigned int tmp___6 ;
  unsigned int tmp___7 ;
  unsigned int tmp___8 ;
  unsigned int tmp___9 ;
  unsigned int tmp___10 ;
  unsigned int tmp___11 ;
  unsigned int tmp___12 ;
  unsigned int tmp___13 ;
  unsigned int tmp___14 ;
  unsigned int tmp___15 ;
  unsigned int tmp___16 ;
  unsigned int tmp___17 ;
  unsigned int tmp___18 ;
  unsigned int tmp___19 ;

  {
#line 932
  pos = ld->Bitcnt;
#line 934
  tmp = Get_Bits(4);
#line 934
  f_code[0][0] = (int )tmp;
#line 935
  tmp___0 = Get_Bits(4);
#line 935
  f_code[0][1] = (int )tmp___0;
#line 936
  tmp___1 = Get_Bits(4);
#line 936
  f_code[1][0] = (int )tmp___1;
#line 937
  tmp___2 = Get_Bits(4);
#line 937
  f_code[1][1] = (int )tmp___2;
#line 939
  tmp___3 = Get_Bits(2);
#line 939
  intra_dc_precision = (int )tmp___3;
#line 940
  tmp___4 = Get_Bits(2);
#line 940
  picture_structure = (int )tmp___4;
#line 941
  tmp___5 = Get_Bits(1);
#line 941
  top_field_first = (int )tmp___5;
#line 942
  tmp___6 = Get_Bits(1);
#line 942
  frame_pred_frame_dct = (int )tmp___6;
#line 943
  tmp___7 = Get_Bits(1);
#line 943
  concealment_motion_vectors = (int )tmp___7;
#line 944
  tmp___8 = Get_Bits(1);
#line 944
  ld->q_scale_type = (int )tmp___8;
#line 945
  tmp___9 = Get_Bits(1);
#line 945
  intra_vlc_format = (int )tmp___9;
#line 946
  tmp___10 = Get_Bits(1);
#line 946
  ld->alternate_scan = (int )tmp___10;
#line 947
  tmp___11 = Get_Bits(1);
#line 947
  repeat_first_field = (int )tmp___11;
#line 948
  tmp___12 = Get_Bits(1);
#line 948
  chroma_420_type = (int )tmp___12;
#line 949
  tmp___13 = Get_Bits(1);
#line 949
  progressive_frame = (int )tmp___13;
#line 950
  tmp___14 = Get_Bits(1);
#line 950
  composite_display_flag = (int )tmp___14;
#line 952
  if (composite_display_flag) {
#line 954
    tmp___15 = Get_Bits(1);
#line 954
    v_axis = (int )tmp___15;
#line 955
    tmp___16 = Get_Bits(3);
#line 955
    field_sequence = (int )tmp___16;
#line 956
    tmp___17 = Get_Bits(1);
#line 956
    sub_carrier = (int )tmp___17;
#line 957
    tmp___18 = Get_Bits(7);
#line 957
    burst_amplitude = (int )tmp___18;
#line 958
    tmp___19 = Get_Bits(8);
#line 958
    sub_carrier_phase = (int )tmp___19;
  }
#line 999
  return;
}
}
#line 1004 "src/gethdr.c"
static void picture_spatial_scalable_extension(void) 
{ 
  int pos ;
  unsigned int tmp ;
  unsigned int tmp___0 ;
  unsigned int tmp___1 ;
  unsigned int tmp___2 ;
  unsigned int tmp___3 ;
  unsigned int tmp___4 ;

  {
#line 1008
  pos = ld->Bitcnt;
#line 1010
  ld->pict_scal = 1;
#line 1012
  tmp = Get_Bits(10);
#line 1012
  lower_layer_temporal_reference = (int )tmp;
#line 1013
  marker_bit((char *)"picture_spatial_scalable_extension(), first marker bit");
#line 1014
  tmp___0 = Get_Bits(15);
#line 1014
  lower_layer_horizontal_offset = (int )tmp___0;
#line 1015
  if (lower_layer_horizontal_offset >= 16384) {
#line 1016
    lower_layer_horizontal_offset -= 32768;
  }
#line 1017
  marker_bit((char *)"picture_spatial_scalable_extension(), second marker bit");
#line 1018
  tmp___1 = Get_Bits(15);
#line 1018
  lower_layer_vertical_offset = (int )tmp___1;
#line 1019
  if (lower_layer_vertical_offset >= 16384) {
#line 1020
    lower_layer_vertical_offset -= 32768;
  }
#line 1021
  tmp___2 = Get_Bits(2);
#line 1021
  spatial_temporal_weight_code_table_index = (int )tmp___2;
#line 1022
  tmp___3 = Get_Bits(1);
#line 1022
  lower_layer_progressive_frame = (int )tmp___3;
#line 1023
  tmp___4 = Get_Bits(1);
#line 1023
  lower_layer_deinterlaced_field_select = (int )tmp___4;
#line 1046
  return;
}
}
#line 1054 "src/gethdr.c"
static void picture_temporal_scalable_extension(void) 
{ 


  {
#line 1056
  Error((char *)"temporal scalability not supported\n");
#line 1061
  return;
}
}
#line 1066 "src/gethdr.c"
static int extra_bit_information(void) 
{ 
  int Byte_Count ;
  unsigned int tmp ;

  {
#line 1068
  Byte_Count = 0;
#line 1070
  while (1) {
#line 1070
    tmp = Get_Bits1();
#line 1070
    if (! tmp) {
#line 1070
      break;
    }
#line 1072
    Flush_Buffer(8);
#line 1073
    Byte_Count ++;
  }
#line 1076
  return (Byte_Count);
}
}
#line 1084 "src/gethdr.c"
void marker_bit(char *text ) 
{ 
  int marker ;
  unsigned int tmp ;

  {
#line 1089
  tmp = Get_Bits(1);
#line 1089
  marker = (int )tmp;
#line 1095
  return;
}
}
#line 1099 "src/gethdr.c"
static void user_data(void) 
{ 


  {
#line 1102
  next_start_code();
#line 1103
  return;
}
}
#line 1112 "src/gethdr.c"
static void copyright_extension(void) 
{ 
  int pos ;
  int reserved_data ;
  unsigned int tmp ;
  unsigned int tmp___0 ;
  unsigned int tmp___1 ;
  unsigned int tmp___2 ;
  unsigned int tmp___3 ;
  unsigned int tmp___4 ;
  unsigned int tmp___5 ;

  {
#line 1117
  pos = ld->Bitcnt;
#line 1120
  tmp = Get_Bits(1);
#line 1120
  copyright_flag = (int )tmp;
#line 1121
  tmp___0 = Get_Bits(8);
#line 1121
  copyright_identifier = (int )tmp___0;
#line 1122
  tmp___1 = Get_Bits(1);
#line 1122
  original_or_copy = (int )tmp___1;
#line 1125
  tmp___2 = Get_Bits(7);
#line 1125
  reserved_data = (int )tmp___2;
#line 1127
  marker_bit((char *)"copyright_extension(), first marker bit");
#line 1128
  tmp___3 = Get_Bits(20);
#line 1128
  copyright_number_1 = (int )tmp___3;
#line 1129
  marker_bit((char *)"copyright_extension(), second marker bit");
#line 1130
  tmp___4 = Get_Bits(22);
#line 1130
  copyright_number_2 = (int )tmp___4;
#line 1131
  marker_bit((char *)"copyright_extension(), third marker bit");
#line 1132
  tmp___5 = Get_Bits(22);
#line 1132
  copyright_number_3 = (int )tmp___5;
#line 1134
  if (Verbose_Flag > 0) {
#line 1136
    printf((char const   * __restrict  )"copyright_extension (byte %d)\n", (pos >> 3) - 4);
#line 1137
    if (Verbose_Flag > 1) {
#line 1139
      printf((char const   * __restrict  )"  copyright_flag =%d\n", copyright_flag);
#line 1141
      printf((char const   * __restrict  )"  copyright_identifier=%d\n", copyright_identifier);
#line 1143
      printf((char const   * __restrict  )"  original_or_copy = %d (original=1, copy=0)\n",
             original_or_copy);
#line 1146
      printf((char const   * __restrict  )"  copyright_number_1=%d\n", copyright_number_1);
#line 1147
      printf((char const   * __restrict  )"  copyright_number_2=%d\n", copyright_number_2);
#line 1148
      printf((char const   * __restrict  )"  copyright_number_3=%d\n", copyright_number_3);
    }
  }
#line 1155
  return;
}
}
#line 1162 "src/gethdr.c"
static int temporal_reference_wrap  =    0;
#line 1163 "src/gethdr.c"
static int temporal_reference_old  =    0;
#line 1160 "src/gethdr.c"
static void Update_Temporal_Reference_Tacking_Data(void) 
{ 


  {
#line 1165
  if ((unsigned long )ld == (unsigned long )(& base)) {
#line 1167
    if (picture_coding_type != 3) {
#line 1167
      if (temporal_reference != temporal_reference_old) {
#line 1171
        if (temporal_reference_wrap) {
#line 1175
          Temporal_Reference_Base += 1024;
#line 1176
          temporal_reference_wrap = 0;
        }
#line 1180
        if (temporal_reference < temporal_reference_old) {
#line 1180
          if (! Temporal_Reference_GOP_Reset) {
#line 1181
            temporal_reference_wrap = 1;
          }
        }
#line 1183
        temporal_reference_old = temporal_reference;
#line 1184
        Temporal_Reference_GOP_Reset = 0;
      }
    }
#line 1187
    True_Framenum = Temporal_Reference_Base + temporal_reference;
#line 1190
    if (temporal_reference_wrap) {
#line 1190
      if (temporal_reference <= temporal_reference_old) {
#line 1191
        True_Framenum += 1024;
      }
    }
#line 1193
    if (True_Framenum > True_Framenum_max) {
#line 1193
      True_Framenum_max = True_Framenum;
    } else {
#line 1193
      True_Framenum_max = True_Framenum_max;
    }
  }
#line 1196
  return;
}
}
#line 1 "getpic.o"
#pragma merger("0","/tmp/cil-Y6KmLdfk.i","-g,-O4")
#line 479 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__warn_unused_result__,
__leaf__)) realloc)(void *__ptr , size_t __size ) ;
#line 232 "/usr/include/pthread.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,3))) pthread_create)(pthread_t * __restrict  __newthread ,
                                                                                             pthread_attr_t const   * __restrict  __attr ,
                                                                                             void *(*__start_routine)(void * ) ,
                                                                                             void * __restrict  __arg ) ;
#line 249
extern int pthread_join(pthread_t __th , void **__thread_return ) ;
#line 277
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) pthread_equal)(pthread_t __thread1 ,
                                                                                             pthread_t __thread2 )  __attribute__((__const__)) ;
#line 286
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) pthread_attr_init)(pthread_attr_t *__attr ) ;
#line 298
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) pthread_attr_setdetachstate)(pthread_attr_t *__attr ,
                                                                                                                  int __detachstate ) ;
#line 1143
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) pthread_equal)(pthread_t __thread1 ,
                                                                                             pthread_t __thread2 )  __attribute__((__const__)) ;
#line 1143 "/usr/include/pthread.h"
__inline extern int ( __attribute__((__leaf__)) pthread_equal)(pthread_t __thread1 ,
                                                               pthread_t __thread2 ) 
{ 


  {
#line 1146
  return (__thread1 == __thread2);
}
}
#line 96 "src/global.h"
void Substitute_Frame_Buffer(int bitstream_framenum , int sequence_framenum ) ;
#line 125
void Thrd_Flush_Buffer32(int t ) ;
#line 144
void Decode_Picture(int bitstream_framenum , int sequence_framenum ) ;
#line 146
void Output_Last_Frame_of_Sequence(int Framenum ) ;
#line 149
int Get_macroblock_type(void) ;
#line 152
int Get_coded_block_pattern(void) ;
#line 153
int Get_macroblock_address_increment(void) ;
#line 158
void Fast_IDCT(short *block ) ;
#line 163
void Reference_IDCT(short *block ) ;
#line 173
void Thrd_motion_vectors(int t , int (*PMV)[2][2] , int *dmvector , int (*motion_vertical_field_select)[2] ,
                         int s , int motion_vector_count , int mv_format , int h_r_size ,
                         int v_r_size , int dmv , int mvscale ) ;
#line 176
void Thrd_motion_vector(int t , int *PMV , int *dmvector , int h_r_size , int v_r_size ,
                        int dmv , int mvscale , int full_pel_vector ) ;
#line 186
void form_predictions(int bx , int by , int macroblock_type , int motion_type , int (*PMV)[2][2] ,
                      int (*motion_vertical_field_select)[2] , int *dmvector , int stwtype ) ;
#line 191
void Spatial_Prediction(void) ;
#line 194
void Write_Frame(unsigned char **src , int frame___0 ) ;
#line 208
int Thrd_Get_macroblock_type(int t ) ;
#line 211
int Thrd_Get_coded_block_pattern(int t ) ;
#line 215
int Thrd_Get_macroblock_address_increment(int t ) ;
#line 344
int Two_Streams ;
#line 346
int Reference_IDCT_Flag ;
#line 350
int Ersatz_Flag ;
#line 370
unsigned char *backward_reference_frame[3] ;
#line 371
unsigned char *forward_reference_frame[3] ;
#line 373
unsigned char *auxframe[3] ;
#line 374
unsigned char *current_frame[3] ;
#line 389
int Coded_Picture_Width ;
#line 391
int Chroma_Width ;
#line 393
int block_count ;
#line 394
int Second_Field ;
#line 400
int mb_width ;
#line 401
int mb_height ;
#line 95 "src/getpic.c"
static void picture_data(int framenum ) ;
#line 96
static void macroblock_modes(int *pmacroblock_type , int *pstwtype , int *pstwclass ,
                             int *pmotion_type , int *pmotion_vector_count , int *pmv_format ,
                             int *pdmv , int *pmvscale , int *pdct_type ) ;
#line 99
static void Clear_Block(int comp ) ;
#line 100
static void Sum_Block(int comp ) ;
#line 101
static void Saturate(short *Block_Ptr ) ;
#line 104
static void Update_Picture_Buffers(void) ;
#line 105
static void frame_reorder(int Bitstream_Framenum , int Sequence_Framenum ) ;
#line 107
static void Decode_SNR_Macroblock(int *SNRMBA , int *SNRMBAinc , int MBA , int MBAmax ,
                                  int *dct_type ) ;
#line 128
static int Thrd_start_of_slice(int t , int MBAmax , int *MBA , int *MBAinc , int *dc_dct_pred ,
                               int (*PMV)[2][2] ) ;
#line 131
static int Thrd_decode_macroblock(int t , int *macroblock_type , int *stwtype , int *stwclass ,
                                  int *motion_type , int *dct_type , int (*PMV)[2][2] ,
                                  int *dc_dct_pred , int (*motion_vertical_field_select)[2] ,
                                  int *dmvector ) ;
#line 136
static void Thrd_skipped_macroblock(int t , int *dc_dct_pred , int (*PMV)[2][2] ,
                                    int *motion_type , int (*motion_vertical_field_select)[2] ,
                                    int *stwtype , int *macroblock_type ) ;
#line 140
static void Thrd_motion_compensation(int t , int MBA , int macroblock_type , int motion_type ,
                                     int (*PMV)[2][2] , int (*motion_vertical_field_select)[2] ,
                                     int *dmvector , int stwtype , int dct_type ) ;
#line 144
static int new_slice(int framenum , int MBAmax ) ;
#line 145
static void Thrd_macroblock_modes(int t , int *pmacroblock_type , int *pstwtype ,
                                  int *pstwclass , int *pmotion_type , int *pmotion_vector_count ,
                                  int *pmv_format , int *pdmv , int *pmvscale , int *pdct_type ) ;
#line 148
static void Thrd_Clear_Block(int t , int comp ) ;
#line 149
static void Thrd_Add_Block(int t , int comp , int bx , int by , int dct_type , int addflag ) ;
#line 155 "src/getpic.c"
void Decode_Picture(int bitstream_framenum , int sequence_framenum ) 
{ 


  {
#line 159
  if (picture_structure == 3) {
#line 159
    if (Second_Field) {
#line 162
      printf((char const   * __restrict  )"odd number of field pictures\n");
#line 163
      Second_Field = 0;
    }
  }
#line 167
  Update_Picture_Buffers();
#line 176
  if (Ersatz_Flag) {
#line 177
    Substitute_Frame_Buffer(bitstream_framenum, sequence_framenum);
  }
#line 183
  if (base.pict_scal) {
#line 183
    if (! Second_Field) {
#line 185
      Spatial_Prediction();
    }
  }
#line 189
  picture_data(bitstream_framenum);
#line 193
  frame_reorder(bitstream_framenum, sequence_framenum);
#line 195
  if (picture_structure != 3) {
#line 196
    Second_Field = ! Second_Field;
  }
#line 197
  return;
}
}
#line 201 "src/getpic.c"
static void picture_data(int framenum ) 
{ 
  int MBAmax ;
  int ret ;
  int slice_num ;

  {
#line 208
  slice_num = 0;
#line 212
  MBAmax = mb_width * mb_height;
#line 214
  if (picture_structure != 3) {
#line 215
    MBAmax >>= 1;
  }
#line 217
  while (1) {
#line 221
    slice_num ++;
#line 222
    ret = new_slice(framenum, MBAmax);
#line 222
    if (ret < 0) {
#line 226
      return;
    }
  }
}
}
#line 374 "src/getpic.c"
static unsigned char stwc_table[3][4]  = { {        (unsigned char)6,        (unsigned char)3,        (unsigned char)7,        (unsigned char)4}, 
   {        (unsigned char)2,        (unsigned char)1,        (unsigned char)5,        (unsigned char)4}, 
   {        (unsigned char)2,        (unsigned char)5,        (unsigned char)7,        (unsigned char)4}};
#line 376 "src/getpic.c"
static unsigned char stwclass_table[9]  = 
#line 376
  {      (unsigned char)0,      (unsigned char)1,      (unsigned char)2,      (unsigned char)1, 
        (unsigned char)1,      (unsigned char)2,      (unsigned char)3,      (unsigned char)3, 
        (unsigned char)4};
#line 363 "src/getpic.c"
static void macroblock_modes(int *pmacroblock_type , int *pstwtype , int *pstwclass ,
                             int *pmotion_type , int *pmotion_vector_count , int *pmv_format ,
                             int *pdmv , int *pmvscale , int *pdct_type ) 
{ 
  int macroblock_type ;
  int stwtype ;
  int stwcode ;
  int stwclass ;
  int motion_type ;
  int motion_vector_count ;
  int mv_format ;
  int dmv ;
  int mvscale ;
  int dct_type ;
  unsigned int tmp ;
  unsigned int tmp___0 ;
  unsigned int tmp___1 ;
  int tmp___2 ;
  unsigned int tmp___3 ;

  {
#line 371
  motion_type = 0;
#line 380
  macroblock_type = Get_macroblock_type();
#line 382
  if (Fault_Flag) {
#line 382
    return;
  }
#line 385
  if (macroblock_type & 32) {
#line 387
    if (spatial_temporal_weight_code_table_index == 0) {
#line 388
      stwtype = 4;
    } else {
#line 391
      tmp = Get_Bits(2);
#line 391
      stwcode = (int )tmp;
#line 400
      stwtype = (int )stwc_table[spatial_temporal_weight_code_table_index - 1][stwcode];
    }
  } else
#line 404
  if (macroblock_type & 64) {
#line 404
    stwtype = 8;
  } else {
#line 404
    stwtype = 0;
  }
#line 407
  stwclass = (int )stwclass_table[stwtype];
#line 410
  if (macroblock_type & 12) {
#line 412
    if (picture_structure == 3) {
#line 414
      if (frame_pred_frame_dct) {
#line 414
        motion_type = 2;
      } else {
#line 414
        tmp___0 = Get_Bits(2);
#line 414
        motion_type = (int )tmp___0;
      }
    } else {
#line 428
      tmp___1 = Get_Bits(2);
#line 428
      motion_type = (int )tmp___1;
    }
  } else
#line 441
  if (macroblock_type & 1) {
#line 441
    if (concealment_motion_vectors) {
#line 444
      if (picture_structure == 3) {
#line 444
        motion_type = 2;
      } else {
#line 444
        motion_type = 1;
      }
    }
  }
#line 455
  if (picture_structure == 3) {
#line 457
    if (motion_type == 1) {
#line 457
      if (stwclass < 2) {
#line 457
        motion_vector_count = 2;
      } else {
#line 457
        motion_vector_count = 1;
      }
    } else {
#line 457
      motion_vector_count = 1;
    }
#line 458
    if (motion_type == 2) {
#line 458
      mv_format = 1;
    } else {
#line 458
      mv_format = 0;
    }
  } else {
#line 462
    if (motion_type == 2) {
#line 462
      motion_vector_count = 2;
    } else {
#line 462
      motion_vector_count = 1;
    }
#line 463
    mv_format = 0;
  }
#line 466
  dmv = motion_type == 3;
#line 477
  if (mv_format == 0) {
#line 477
    if (picture_structure == 3) {
#line 477
      tmp___2 = 1;
    } else {
#line 477
      tmp___2 = 0;
    }
  } else {
#line 477
    tmp___2 = 0;
  }
#line 477
  mvscale = tmp___2;
#line 480
  if (picture_structure == 3) {
#line 480
    if (! frame_pred_frame_dct) {
#line 480
      if (macroblock_type & 3) {
#line 480
        tmp___3 = Get_Bits(1);
#line 480
        dct_type = (int )tmp___3;
      } else {
#line 480
        dct_type = 0;
      }
    } else {
#line 480
      dct_type = 0;
    }
  } else {
#line 480
    dct_type = 0;
  }
#line 494
  *pmacroblock_type = macroblock_type;
#line 495
  *pstwtype = stwtype;
#line 496
  *pstwclass = stwclass;
#line 497
  *pmotion_type = motion_type;
#line 498
  *pmotion_vector_count = motion_vector_count;
#line 499
  *pmv_format = mv_format;
#line 500
  *pdmv = dmv;
#line 501
  *pmvscale = mvscale;
#line 502
  *pdct_type = dct_type;
#line 503
  return;
}
}
#line 616 "src/getpic.c"
static void Decode_SNR_Macroblock(int *SNRMBA , int *SNRMBAinc , int MBA , int MBAmax ,
                                  int *dct_type ) 
{ 
  int SNRmacroblock_type ;
  int SNRcoded_block_pattern ;
  int SNRdct_type ;
  int dummy ;
  int slice_vert_pos_ext ;
  int quantizer_scale_code ;
  int comp ;
  int code ;
  unsigned int tmp ;
  unsigned int tmp___0 ;
  unsigned int tmp___1 ;
  unsigned int tmp___2 ;
  unsigned int tmp___3 ;

  {
#line 624
  ld = & enhan;
#line 626
  if (*SNRMBAinc == 0) {
#line 628
    tmp___0 = Show_Bits(23);
#line 628
    if (tmp___0) {
#line 657
      if (*SNRMBA >= MBAmax) {
#line 659
        if (! Quiet_Flag) {
#line 660
          printf((char const   * __restrict  )"Too many macroblocks in picture\n");
        }
#line 661
        return;
      }
#line 665
      *SNRMBAinc = Get_macroblock_address_increment();
    } else {
#line 630
      next_start_code();
#line 631
      tmp = Show_Bits(32);
#line 631
      code = (int )tmp;
#line 633
      if (code < 257) {
#line 633
        goto _L;
      } else
#line 633
      if (code > 431) {
        _L: /* CIL Label */ 
#line 636
        if (! Quiet_Flag) {
#line 637
          printf((char const   * __restrict  )"SNR: Premature end of picture\n");
        }
#line 638
        return;
      }
#line 641
      Flush_Buffer32();
#line 644
      slice_vert_pos_ext = slice_header();
#line 647
      *SNRMBAinc = Get_macroblock_address_increment();
#line 650
      *SNRMBA = ((((slice_vert_pos_ext << 7) + (code & 255)) - 1) * mb_width + *SNRMBAinc) - 1;
#line 653
      *SNRMBAinc = 1;
    }
  }
#line 669
  if (*SNRMBA != MBA) {
#line 672
    if (! Quiet_Flag) {
#line 673
      printf((char const   * __restrict  )"Cant\'t synchronize streams\n");
    }
#line 674
    return;
  }
#line 677
  if (*SNRMBAinc == 1) {
#line 679
    macroblock_modes(& SNRmacroblock_type, & dummy, & dummy, & dummy, & dummy, & dummy,
                     & dummy, & dummy, & SNRdct_type);
#line 683
    if (SNRmacroblock_type & 2) {
#line 684
      *dct_type = SNRdct_type;
    }
#line 686
    if (SNRmacroblock_type & 16) {
#line 688
      tmp___1 = Get_Bits(5);
#line 688
      quantizer_scale_code = (int )tmp___1;
#line 689
      if (ld->q_scale_type) {
#line 689
        ld->quantizer_scale = (int )Non_Linear_quantizer_scale[quantizer_scale_code];
      } else {
#line 689
        ld->quantizer_scale = quantizer_scale_code << 1;
      }
    }
#line 694
    if (SNRmacroblock_type & 2) {
#line 696
      SNRcoded_block_pattern = Get_coded_block_pattern();
#line 698
      if (chroma_format == 2) {
#line 699
        tmp___2 = Get_Bits(2);
#line 699
        SNRcoded_block_pattern = (int )((unsigned int )(SNRcoded_block_pattern << 2) | tmp___2);
      } else
#line 700
      if (chroma_format == 3) {
#line 701
        tmp___3 = Get_Bits(6);
#line 701
        SNRcoded_block_pattern = (int )((unsigned int )(SNRcoded_block_pattern << 6) | tmp___3);
      }
    } else {
#line 704
      SNRcoded_block_pattern = 0;
    }
#line 707
    comp = 0;
#line 707
    while (comp < block_count) {
#line 709
      Clear_Block(comp);
#line 711
      if (SNRcoded_block_pattern & (1 << ((block_count - 1) - comp))) {
#line 712
        Decode_MPEG2_Non_Intra_Block(comp);
      }
#line 707
      comp ++;
    }
  } else {
#line 717
    comp = 0;
#line 717
    while (comp < block_count) {
#line 718
      Clear_Block(comp);
#line 717
      comp ++;
    }
  }
#line 721
  ld = & base;
#line 722
  return;
}
}
#line 727 "src/getpic.c"
static void Clear_Block(int comp ) 
{ 
  short *Block_Ptr ;
  int i ;

  {
#line 733
  Block_Ptr = ld->block[comp];
#line 747
  i = 0;
#line 747
  while (i < 64) {
#line 749
    *(Block_Ptr + i) = (short)0;
#line 750
    *(Block_Ptr + (i + 1)) = (short)0;
#line 751
    *(Block_Ptr + (i + 2)) = (short)0;
#line 752
    *(Block_Ptr + (i + 3)) = (short)0;
#line 754
    *(Block_Ptr + (i + 4)) = (short)0;
#line 755
    *(Block_Ptr + (i + 5)) = (short)0;
#line 756
    *(Block_Ptr + (i + 6)) = (short)0;
#line 757
    *(Block_Ptr + (i + 7)) = (short)0;
#line 747
    i += 8;
  }
#line 761
  return;
}
}
#line 766 "src/getpic.c"
static void Sum_Block(int comp ) 
{ 
  short *Block_Ptr1 ;
  short *Block_Ptr2 ;
  int i ;
  short *tmp ;
  short *tmp___0 ;

  {
#line 772
  Block_Ptr1 = base.block[comp];
#line 773
  Block_Ptr2 = enhan.block[comp];
#line 775
  i = 0;
#line 775
  while (i < 64) {
#line 776
    tmp = Block_Ptr1;
#line 776
    Block_Ptr1 ++;
#line 776
    tmp___0 = Block_Ptr2;
#line 776
    Block_Ptr2 ++;
#line 776
    *tmp = (short )((int )*tmp + (int )*tmp___0);
#line 775
    i ++;
  }
#line 777
  return;
}
}
#line 783 "src/getpic.c"
static void Saturate(short *Block_Ptr ) 
{ 
  int i ;
  int sum ;
  int val ;
  int j ;

  {
#line 864
  sum = 0;
#line 870
  i = 0;
#line 870
  while (i < 64) {
#line 873
    j = 0;
#line 873
    while (j < 8) {
#line 875
      val = (int )*(Block_Ptr + i);
#line 876
      if (val > 2047) {
#line 877
        val = 2047;
      } else
#line 878
      if (val < -2048) {
#line 879
        val = -2048;
      }
#line 880
      *(Block_Ptr + i) = (short )val;
#line 881
      sum += val;
#line 873
      j ++;
#line 873
      i ++;
    }
  }
#line 888
  if ((sum & 1) == 0) {
#line 889
    *(Block_Ptr + 63) = (short )((int )*(Block_Ptr + 63) ^ 1);
  }
#line 892
  return;
}
}
#line 897 "src/getpic.c"
static void Update_Picture_Buffers(void) 
{ 
  int cc ;
  unsigned char *tmp ;
  int tmp___0 ;

  {
#line 902
  cc = 0;
#line 902
  while (cc < 3) {
#line 905
    if (picture_coding_type == 3) {
#line 907
      current_frame[cc] = auxframe[cc];
    } else {
#line 912
      if (! Second_Field) {
#line 914
        tmp = forward_reference_frame[cc];
#line 920
        forward_reference_frame[cc] = backward_reference_frame[cc];
#line 923
        backward_reference_frame[cc] = tmp;
      }
#line 929
      current_frame[cc] = backward_reference_frame[cc];
    }
#line 936
    if (picture_structure == 2) {
#line 937
      if (cc == 0) {
#line 937
        tmp___0 = Coded_Picture_Width;
      } else {
#line 937
        tmp___0 = Chroma_Width;
      }
#line 937
      current_frame[cc] += tmp___0;
    }
#line 902
    cc ++;
  }
#line 939
  return;
}
}
#line 944 "src/getpic.c"
void Output_Last_Frame_of_Sequence(int Framenum ) 
{ 


  {
#line 947
  if (Second_Field) {
#line 948
    printf((char const   * __restrict  )"last frame incomplete, not stored\n");
  } else {
#line 950
    Write_Frame(backward_reference_frame, Framenum - 1);
  }
#line 951
  return;
}
}
#line 959 "src/getpic.c"
static int Oldref_progressive_frame  ;
#line 959 "src/getpic.c"
static int Newref_progressive_frame  ;
#line 955 "src/getpic.c"
static void frame_reorder(int Bitstream_Framenum , int Sequence_Framenum ) 
{ 


  {
#line 961
  if (Sequence_Framenum != 0) {
#line 963
    if (picture_structure == 3) {
#line 963
      goto _L;
    } else
#line 963
    if (Second_Field) {
      _L: /* CIL Label */ 
#line 965
      if (picture_coding_type == 3) {
#line 966
        Write_Frame(auxframe, Bitstream_Framenum - 1);
      } else {
#line 969
        Newref_progressive_frame = progressive_frame;
#line 970
        progressive_frame = Oldref_progressive_frame;
#line 972
        Write_Frame(forward_reference_frame, Bitstream_Framenum - 1);
#line 974
        progressive_frame = Newref_progressive_frame;
#line 974
        Oldref_progressive_frame = progressive_frame;
      }
    }
  } else {
#line 986
    Oldref_progressive_frame = progressive_frame;
  }
#line 987
  return;
}
}
#line 1428 "src/getpic.c"
void write_frame_buf8(int t , unsigned char data ) 
{ 
  void *tmp ;
  unsigned int tmp___0 ;

  {
#line 1438
  if (tb[t].frame_buf_offset == tb[t].frame_buf_size) {
#line 1439
    tb[t].frame_buf_size <<= 1;
#line 1440
    tmp = realloc((void *)tb[t].frame_buf, sizeof(unsigned char ) * (unsigned long )tb[t].frame_buf_size);
#line 1440
    tb[t].frame_buf = (unsigned char *)tmp;
  }
#line 1444
  tmp___0 = tb[t].frame_buf_offset;
#line 1444
  (tb[t].frame_buf_offset) ++;
#line 1444
  *(tb[t].frame_buf + tmp___0) = data;
#line 1446
  return;
}
}
#line 1448 "src/getpic.c"
void write_frame_buf32(int t , unsigned int data ) 
{ 


  {
#line 1449
  write_frame_buf8(t, (unsigned char )(data >> 24));
#line 1450
  write_frame_buf8(t, (unsigned char )(data >> 16));
#line 1451
  write_frame_buf8(t, (unsigned char )(data >> 8));
#line 1452
  write_frame_buf8(t, (unsigned char )data);
#line 1453
  return;
}
}
#line 1459 "src/getpic.c"
void *Thrd_Work(void *thrd_args ) 
{ 
  Thrd_Args *mydata ;
  int id ;
  int num_slices ;
  int MBAmax ;
  int MBA ;
  int MBAinc ;
  int macroblock_type ;
  int motion_type ;
  int dct_type ;
  int dc_dct_pred[3] ;
  int PMV[2][2][2] ;
  int motion_vertical_field_select[2][2] ;
  int dmvector[2] ;
  int stwtype ;
  int stwclass ;
  int SNRMBA ;
  int SNRMBAinc ;
  int localMBA ;
  int localMBAmax ;
  int ret ;
  unsigned int tmp ;

  {
#line 1460
  mydata = (Thrd_Args *)thrd_args;
#line 1462
  id = mydata->id;
#line 1463
  num_slices = mydata->num_slices;
#line 1467
  MBAmax = mydata->MBAmax;
#line 1478
  MBA = 0;
#line 1479
  MBAinc = 0;
#line 1480
  localMBA = 0;
#line 1481
  localMBAmax = num_slices * mb_width;
  next_slice: 
#line 1488
  ret = Thrd_start_of_slice(id, MBAmax, & MBA, & MBAinc, (int *)(dc_dct_pred), (int (*)[2][2])(PMV));
#line 1488
  if (ret != 1) {
#line 1490
    if (localMBA >= localMBAmax) {
#line 1491
      return ((void *)0);
    }
  }
#line 1497
  if (Two_Streams) {
#line 1497
    if (enhan.scalable_mode == 3) {
#line 1499
      SNRMBA = 0;
#line 1500
      SNRMBAinc = 0;
    }
  }
#line 1503
  Fault_Flag = 0;
#line 1505
  while (1) {
#line 1509
    if (localMBA >= localMBAmax) {
#line 1511
      return ((void *)0);
    }
#line 1525
    ld = & base;
#line 1527
    if (MBAinc == 0) {
#line 1529
      if (base.scalable_mode == 1) {
#line 1529
        if (base.priority_breakpoint == 1) {
#line 1530
          ld = & enhan;
        }
      }
#line 1532
      tmp = Thrd_Show_Bits(id, 23);
#line 1532
      if (tmp) {
#line 1532
        if (Fault_Flag) {
          resync: 
#line 1536
          Fault_Flag = 0;
#line 1537
          goto next_slice;
#line 1538
          return ((void *)0);
        } else {
#line 1542
          if (base.scalable_mode == 1) {
#line 1542
            if (base.priority_breakpoint == 1) {
#line 1543
              ld = & enhan;
            }
          }
#line 1546
          MBAinc = Thrd_Get_macroblock_address_increment(id);
#line 1548
          if (Fault_Flag) {
#line 1548
            goto resync;
          }
        }
      } else {
#line 1532
        goto resync;
      }
    }
#line 1552
    if (MBA >= MBAmax) {
#line 1555
      if (! Quiet_Flag) {
#line 1556
        printf((char const   * __restrict  )"Too many macroblocks in picture\n");
      }
#line 1558
      return ((void *)0);
    }
#line 1561
    if (MBAinc == 1) {
#line 1563
      ret = Thrd_decode_macroblock(id, & macroblock_type, & stwtype, & stwclass, & motion_type,
                                   & dct_type, (int (*)[2][2])(PMV), (int *)(dc_dct_pred),
                                   (int (*)[2])(motion_vertical_field_select), (int *)(dmvector));
#line 1567
      if (ret == -1) {
#line 1569
        return ((void *)0);
      }
#line 1572
      if (ret == 0) {
#line 1574
        goto resync;
      }
    } else {
#line 1581
      Thrd_skipped_macroblock(id, (int *)(dc_dct_pred), (int (*)[2][2])(PMV), & motion_type,
                              (int (*)[2])(motion_vertical_field_select), & stwtype,
                              & macroblock_type);
    }
#line 1588
    if (Two_Streams) {
#line 1588
      if (enhan.scalable_mode == 3) {
#line 1589
        Decode_SNR_Macroblock(& SNRMBA, & SNRMBAinc, MBA, MBAmax, & dct_type);
      }
    }
#line 1592
    Thrd_motion_compensation(id, MBA, macroblock_type, motion_type, (int (*)[2][2])(PMV),
                             (int (*)[2])(motion_vertical_field_select), (int *)(dmvector),
                             stwtype, dct_type);
#line 1599
    localMBA ++;
#line 1600
    MBA ++;
#line 1601
    MBAinc --;
#line 1604
    if (Two_Streams) {
#line 1604
      if (enhan.scalable_mode == 3) {
#line 1606
        SNRMBA ++;
#line 1607
        SNRMBAinc --;
      }
    }
#line 1610
    if (localMBA >= localMBAmax) {
#line 1612
      return ((void *)0);
    }
  }
#line 1616
  return ((void *)0);
}
}
#line 1620 "src/getpic.c"
Thrd_Args thread_data_array[2]  ;
#line 1622 "src/getpic.c"
static int new_slice(int framenum , int MBAmax ) 
{ 
  unsigned int code ;
  unsigned int num_slices ;
  int chunk_size ;
  int remainder ;
  int thrd_num ;
  int num_decode_slice[2] ;
  int t ;
  int next_marker ;
  pthread_t thread[1] ;
  pthread_attr_t attr ;
  int rc ;
  int status ;
  int num_thrds ;
  int tmp___0 ;
  unsigned int tmp___1 ;
  unsigned int tmp___2 ;

  {
#line 1626
  num_slices = 0U;
#line 1629
  thrd_num = 1;
#line 1639
  if (mb_height > 2) {
#line 1639
    tmp___0 = 2;
  } else {
#line 1639
    tmp___0 = mb_height;
  }
#line 1639
  num_thrds = tmp___0;
#line 1644
  pthread_attr_init(& attr);
#line 1645
  pthread_attr_setdetachstate(& attr, 0);
#line 1648
  tb[0].frame_buf_offset = 0U;
#line 1649
  next_start_code();
#line 1650
  code = Show_Bits(32);
#line 1652
  if (code < 257U) {
#line 1652
    __assert_fail("!(code<0x101 || code>0x1AF)&&\"Bad slice start code\\n\"", "src/getpic.c",
                  1652U, "new_slice");
  } else
#line 1652
  if (code > 431U) {
#line 1652
    __assert_fail("!(code<0x101 || code>0x1AF)&&\"Bad slice start code\\n\"", "src/getpic.c",
                  1652U, "new_slice");
  } else
#line 1652
  if (! "Bad slice start code\n") {
#line 1652
    __assert_fail("!(code<0x101 || code>0x1AF)&&\"Bad slice start code\\n\"", "src/getpic.c",
                  1652U, "new_slice");
  }
#line 1653
  write_frame_buf32(0, code);
#line 1654
  Flush_Buffer32();
#line 1656
  num_slices ++;
#line 1658
  chunk_size = mb_height / num_thrds;
#line 1659
  remainder = mb_height % num_thrds;
#line 1664
  if (remainder > 0) {
#line 1664
    num_decode_slice[0] = chunk_size + 1;
  } else {
#line 1664
    num_decode_slice[0] = chunk_size;
  }
#line 1665
  next_marker = num_decode_slice[0];
#line 1667
  while (num_slices <= (unsigned int )mb_height) {
#line 1669
    if (! (ld->Incnt > 24)) {
#line 1669
      __assert_fail("ld->Incnt > 24", "src/getpic.c", 1669U, "new_slice");
    }
#line 1670
    while (1) {
#line 1670
      tmp___2 = Show_Bits(24);
#line 1670
      if (! ((long )tmp___2 != 1L)) {
#line 1670
        break;
      }
#line 1671
      tmp___1 = Show_Bits(8);
#line 1671
      write_frame_buf8(thrd_num - 1, (unsigned char )tmp___1);
#line 1672
      Flush_Buffer(8);
    }
#line 1675
    if (num_slices != (unsigned int )mb_height) {
#line 1676
      code = Show_Bits(32);
#line 1677
      if (code < 257U) {
#line 1677
        __assert_fail("!(code<0x101 || code>0x1AF)&&\"Bad slice start code\\n\"",
                      "src/getpic.c", 1677U, "new_slice");
      } else
#line 1677
      if (code > 431U) {
#line 1677
        __assert_fail("!(code<0x101 || code>0x1AF)&&\"Bad slice start code\\n\"",
                      "src/getpic.c", 1677U, "new_slice");
      } else
#line 1677
      if (! "Bad slice start code\n") {
#line 1677
        __assert_fail("!(code<0x101 || code>0x1AF)&&\"Bad slice start code\\n\"",
                      "src/getpic.c", 1677U, "new_slice");
      }
#line 1679
      if (num_slices == (unsigned int )next_marker) {
#line 1680
        tb[thrd_num].frame_buf_offset = 0U;
#line 1682
        if (remainder > thrd_num) {
#line 1682
          num_decode_slice[thrd_num] = chunk_size + 1;
        } else {
#line 1682
          num_decode_slice[thrd_num] = chunk_size;
        }
#line 1683
        next_marker += num_decode_slice[thrd_num];
#line 1687
        t = thrd_num - 1;
#line 1688
        thread_data_array[t].id = t;
#line 1689
        thread_data_array[t].num_slices = num_decode_slice[t];
#line 1690
        thread_data_array[t].framenum = framenum;
#line 1691
        thread_data_array[t].MBAmax = MBAmax;
#line 1692
        thrd_ptr[t] = tb[t].frame_buf;
#line 1694
        Thrd_Initialize_Buffer(t);
#line 1697
        if (t != num_thrds - 1) {
#line 1698
          rc = pthread_create((pthread_t * __restrict  )(& thread[t]), (pthread_attr_t const   * __restrict  )(& attr),
                              & Thrd_Work, (void * __restrict  )((void *)(& thread_data_array[t])));
#line 1700
          if (rc) {
#line 1701
            printf((char const   * __restrict  )"ERROR; return code from pthread_create() is %d\n",
                   rc);
#line 1702
            exit(-1);
          }
        }
#line 1708
        thrd_num ++;
      }
#line 1711
      write_frame_buf32(thrd_num - 1, code);
#line 1712
      Flush_Buffer32();
    }
#line 1714
    num_slices ++;
  }
#line 1718
  t = thrd_num - 1;
#line 1719
  thread_data_array[t].id = t;
#line 1720
  thread_data_array[t].num_slices = num_decode_slice[t];
#line 1721
  thread_data_array[t].framenum = framenum;
#line 1722
  thread_data_array[t].MBAmax = MBAmax;
#line 1723
  thrd_ptr[t] = tb[t].frame_buf;
#line 1725
  Thrd_Initialize_Buffer(t);
#line 1750
  Thrd_Work((void *)(& thread_data_array[t]));
#line 1753
  t = 0;
#line 1753
  while (t < num_thrds - 1) {
#line 1755
    rc = pthread_join(thread[t], (void **)(& status));
#line 1756
    if (rc) {
#line 1758
      printf((char const   * __restrict  )"ERROR; return code from pthread_join() is %d\n",
             rc);
#line 1759
      exit(-1);
    }
#line 1753
    t ++;
  }
#line 1763
  return (-1);
}
}
#line 1769 "src/getpic.c"
static int Thrd_start_of_slice(int t , int MBAmax , int *MBA , int *MBAinc , int *dc_dct_pred ,
                               int (*PMV)[2][2] ) 
{ 
  unsigned int code ;
  int slice_vert_pos_ext ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
#line 1781
  ld = & base;
#line 1783
  Fault_Flag = 0;
#line 1785
  Thrd_next_start_code(t);
#line 1786
  code = Thrd_Show_Bits(t, 32);
#line 1788
  if (code < 257U) {
#line 1788
    goto _L;
  } else
#line 1788
  if (code > 431U) {
    _L: /* CIL Label */ 
#line 1791
    if (! Quiet_Flag) {
#line 1792
      printf((char const   * __restrict  )"start_of_slice(): Premature end of picture\n");
    }
#line 1794
    return (-1);
  }
#line 1797
  Thrd_Flush_Buffer32(t);
#line 1801
  slice_vert_pos_ext = Thrd_slice_header(t);
#line 1804
  *MBAinc = Thrd_Get_macroblock_address_increment(t);
#line 1806
  if (Fault_Flag) {
#line 1808
    printf((char const   * __restrict  )"start_of_slice(): MBAinc unsuccessful\n");
#line 1809
    return (0);
  }
#line 1816
  *MBA = (int )(((((unsigned int )(slice_vert_pos_ext << 7) + (code & 255U)) - 1U) * (unsigned int )mb_width + (unsigned int )*MBAinc) - 1U);
#line 1817
  *MBAinc = 1;
#line 1822
  tmp___0 = 0;
#line 1822
  *(dc_dct_pred + 2) = tmp___0;
#line 1822
  tmp = tmp___0;
#line 1822
  *(dc_dct_pred + 1) = tmp;
#line 1822
  *(dc_dct_pred + 0) = tmp;
#line 1825
  tmp___3 = 0;
#line 1825
  (*(PMV + 1))[0][1] = tmp___3;
#line 1825
  tmp___2 = tmp___3;
#line 1825
  (*(PMV + 1))[0][0] = tmp___2;
#line 1825
  tmp___1 = tmp___2;
#line 1825
  (*(PMV + 0))[0][1] = tmp___1;
#line 1825
  (*(PMV + 0))[0][0] = tmp___1;
#line 1826
  tmp___6 = 0;
#line 1826
  (*(PMV + 1))[1][1] = tmp___6;
#line 1826
  tmp___5 = tmp___6;
#line 1826
  (*(PMV + 1))[1][0] = tmp___5;
#line 1826
  tmp___4 = tmp___5;
#line 1826
  (*(PMV + 0))[1][1] = tmp___4;
#line 1826
  (*(PMV + 0))[1][0] = tmp___4;
#line 1829
  return (1);
}
}
#line 1833 "src/getpic.c"
static int Thrd_decode_macroblock(int t , int *macroblock_type , int *stwtype , int *stwclass ,
                                  int *motion_type , int *dct_type , int (*PMV)[2][2] ,
                                  int *dc_dct_pred , int (*motion_vertical_field_select)[2] ,
                                  int *dmvector ) 
{ 
  int quantizer_scale_code ;
  int comp ;
  int motion_vector_count ;
  int mv_format ;
  int dmv ;
  int mvscale ;
  int coded_block_pattern ;
  unsigned int tmp ;
  unsigned int tmp___0 ;
  unsigned int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;

  {
#line 1858
  if (base.scalable_mode == 1) {
#line 1860
    if (base.priority_breakpoint <= 2) {
#line 1861
      ld = & enhan;
    } else {
#line 1863
      ld = & base;
    }
  }
#line 1867
  Thrd_macroblock_modes(t, macroblock_type, stwtype, stwclass, motion_type, & motion_vector_count,
                        & mv_format, & dmv, & mvscale, dct_type);
#line 1871
  if (Fault_Flag) {
#line 1871
    return (0);
  }
#line 1873
  if (*macroblock_type & 16) {
#line 1875
    tmp = Thrd_Get_Bits(t, 5);
#line 1875
    quantizer_scale_code = (int )tmp;
#line 1878
    if (ld->MPEG2_Flag) {
#line 1879
      if (ld->q_scale_type) {
#line 1879
        thrd_ld[t].quantizer_scale = (int )Non_Linear_quantizer_scale[quantizer_scale_code];
      } else {
#line 1879
        thrd_ld[t].quantizer_scale = quantizer_scale_code << 1;
      }
    } else {
#line 1883
      thrd_ld[t].quantizer_scale = quantizer_scale_code;
    }
#line 1886
    if (base.scalable_mode == 1) {
#line 1887
      printf((char const   * __restrict  )"DP exiting\n");
#line 1888
      exit(-1);
#line 1890
      base.quantizer_scale = ld->quantizer_scale;
    }
  }
#line 1900
  if (*macroblock_type & 8) {
#line 1900
    goto _L;
  } else
#line 1900
  if (*macroblock_type & 1) {
#line 1900
    if (concealment_motion_vectors) {
      _L: /* CIL Label */ 
#line 1904
      if (ld->MPEG2_Flag) {
#line 1905
        Thrd_motion_vectors(t, PMV, dmvector, motion_vertical_field_select, 0, motion_vector_count,
                            mv_format, f_code[0][0] - 1, f_code[0][1] - 1, dmv, mvscale);
      } else {
#line 1909
        Thrd_motion_vector(t, (*(PMV + 0))[0], (int *)dmvector, forward_f_code - 1,
                           forward_f_code - 1, 0, 0, full_pel_forward_vector);
      }
    }
  }
#line 1913
  if (Fault_Flag) {
#line 1913
    return (0);
  }
#line 1916
  if (*macroblock_type & 4) {
#line 1918
    if (ld->MPEG2_Flag) {
#line 1919
      Thrd_motion_vectors(t, PMV, dmvector, motion_vertical_field_select, 1, motion_vector_count,
                          mv_format, f_code[1][0] - 1, f_code[1][1] - 1, 0, mvscale);
    } else {
#line 1923
      Thrd_motion_vector(t, (*(PMV + 0))[1], (int *)dmvector, backward_f_code - 1,
                         backward_f_code - 1, 0, 0, full_pel_backward_vector);
    }
  }
#line 1927
  if (Fault_Flag) {
#line 1927
    return (0);
  }
#line 1929
  if (*macroblock_type & 1) {
#line 1929
    if (concealment_motion_vectors) {
#line 1930
      Thrd_Flush_Buffer(t, 1);
    }
  }
#line 1932
  if (base.scalable_mode == 1) {
#line 1932
    if (base.priority_breakpoint == 3) {
#line 1933
      printf((char const   * __restrict  )"enhan not supported, exiting...\n");
#line 1934
      exit(-1);
#line 1935
      ld = & enhan;
    }
  }
#line 1940
  if (*macroblock_type & 2) {
#line 1942
    coded_block_pattern = Thrd_Get_coded_block_pattern(t);
#line 1944
    if (chroma_format == 2) {
#line 1947
      tmp___0 = Thrd_Get_Bits(t, 2);
#line 1947
      coded_block_pattern = (int )((unsigned int )(coded_block_pattern << 2) | tmp___0);
    } else
#line 1949
    if (chroma_format == 3) {
#line 1952
      tmp___1 = Thrd_Get_Bits(t, 6);
#line 1952
      coded_block_pattern = (int )((unsigned int )(coded_block_pattern << 6) | tmp___1);
    }
  } else
#line 1956
  if (*macroblock_type & 1) {
#line 1956
    coded_block_pattern = (1 << block_count) - 1;
  } else {
#line 1956
    coded_block_pattern = 0;
  }
#line 1959
  if (Fault_Flag) {
#line 1959
    return (0);
  }
#line 1962
  comp = 0;
#line 1962
  while (comp < block_count) {
#line 1965
    if (base.scalable_mode == 1) {
#line 1966
      ld = & base;
    }
#line 1968
    Thrd_Clear_Block(t, comp);
#line 1970
    if (coded_block_pattern & (1 << ((block_count - 1) - comp))) {
#line 1972
      if (*macroblock_type & 1) {
#line 1974
        if (ld->MPEG2_Flag) {
#line 1975
          Thrd_Decode_MPEG2_Intra_Block(t, comp, (int *)dc_dct_pred);
        } else {
#line 1977
          printf((char const   * __restrict  )"not mpeg2, exiting...\n");
#line 1977
          exit(-1);
#line 1978
          Decode_MPEG1_Intra_Block(comp, (int *)dc_dct_pred);
        }
      } else
#line 1983
      if (ld->MPEG2_Flag) {
#line 1984
        Thrd_Decode_MPEG2_Non_Intra_Block(t, comp);
      } else {
#line 1986
        printf((char const   * __restrict  )"not mpeg2, exiting...\n");
#line 1986
        exit(-1);
#line 1987
        Decode_MPEG1_Non_Intra_Block(comp);
      }
#line 1991
      if (Fault_Flag) {
#line 1991
        return (0);
      }
    }
#line 1962
    comp ++;
  }
#line 1995
  if (picture_coding_type == 4) {
#line 1999
    Thrd_Get_Bits(t, 1);
  }
#line 2004
  if (! (*macroblock_type & 1)) {
#line 2005
    tmp___3 = 0;
#line 2005
    *(dc_dct_pred + 2) = tmp___3;
#line 2005
    tmp___2 = tmp___3;
#line 2005
    *(dc_dct_pred + 1) = tmp___2;
#line 2005
    *(dc_dct_pred + 0) = tmp___2;
  }
#line 2008
  if (*macroblock_type & 1) {
#line 2008
    if (! concealment_motion_vectors) {
#line 2012
      tmp___6 = 0;
#line 2012
      (*(PMV + 1))[0][1] = tmp___6;
#line 2012
      tmp___5 = tmp___6;
#line 2012
      (*(PMV + 1))[0][0] = tmp___5;
#line 2012
      tmp___4 = tmp___5;
#line 2012
      (*(PMV + 0))[0][1] = tmp___4;
#line 2012
      (*(PMV + 0))[0][0] = tmp___4;
#line 2013
      tmp___9 = 0;
#line 2013
      (*(PMV + 1))[1][1] = tmp___9;
#line 2013
      tmp___8 = tmp___9;
#line 2013
      (*(PMV + 1))[1][0] = tmp___8;
#line 2013
      tmp___7 = tmp___8;
#line 2013
      (*(PMV + 0))[1][1] = tmp___7;
#line 2013
      (*(PMV + 0))[1][0] = tmp___7;
    }
  }
#line 2018
  if (picture_coding_type == 2) {
#line 2018
    if (! (*macroblock_type & 9)) {
#line 2023
      tmp___12 = 0;
#line 2023
      (*(PMV + 1))[0][1] = tmp___12;
#line 2023
      tmp___11 = tmp___12;
#line 2023
      (*(PMV + 1))[0][0] = tmp___11;
#line 2023
      tmp___10 = tmp___11;
#line 2023
      (*(PMV + 0))[0][1] = tmp___10;
#line 2023
      (*(PMV + 0))[0][0] = tmp___10;
#line 2027
      if (picture_structure == 3) {
#line 2028
        *motion_type = 2;
      } else {
#line 2031
        *motion_type = 1;
#line 2033
        (*(motion_vertical_field_select + 0))[0] = picture_structure == 2;
      }
    }
  }
#line 2037
  if (*stwclass == 4) {
#line 2041
    tmp___15 = 0;
#line 2041
    (*(PMV + 1))[0][1] = tmp___15;
#line 2041
    tmp___14 = tmp___15;
#line 2041
    (*(PMV + 1))[0][0] = tmp___14;
#line 2041
    tmp___13 = tmp___14;
#line 2041
    (*(PMV + 0))[0][1] = tmp___13;
#line 2041
    (*(PMV + 0))[0][0] = tmp___13;
#line 2042
    tmp___18 = 0;
#line 2042
    (*(PMV + 1))[1][1] = tmp___18;
#line 2042
    tmp___17 = tmp___18;
#line 2042
    (*(PMV + 1))[1][0] = tmp___17;
#line 2042
    tmp___16 = tmp___17;
#line 2042
    (*(PMV + 0))[1][1] = tmp___16;
#line 2042
    (*(PMV + 0))[1][0] = tmp___16;
  }
#line 2046
  return (1);
}
}
#line 2051 "src/getpic.c"
static void Thrd_skipped_macroblock(int t , int *dc_dct_pred , int (*PMV)[2][2] ,
                                    int *motion_type , int (*motion_vertical_field_select)[2] ,
                                    int *stwtype , int *macroblock_type ) 
{ 
  int comp ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 2064
  if (base.scalable_mode == 1) {
#line 2065
    ld = & base;
  }
#line 2067
  comp = 0;
#line 2067
  while (comp < block_count) {
#line 2068
    Thrd_Clear_Block(t, comp);
#line 2067
    comp ++;
  }
#line 2072
  tmp___0 = 0;
#line 2072
  *(dc_dct_pred + 2) = tmp___0;
#line 2072
  tmp = tmp___0;
#line 2072
  *(dc_dct_pred + 1) = tmp;
#line 2072
  *(dc_dct_pred + 0) = tmp;
#line 2076
  if (picture_coding_type == 2) {
#line 2077
    tmp___3 = 0;
#line 2077
    (*(PMV + 1))[0][1] = tmp___3;
#line 2077
    tmp___2 = tmp___3;
#line 2077
    (*(PMV + 1))[0][0] = tmp___2;
#line 2077
    tmp___1 = tmp___2;
#line 2077
    (*(PMV + 0))[0][1] = tmp___1;
#line 2077
    (*(PMV + 0))[0][0] = tmp___1;
  }
#line 2080
  if (picture_structure == 3) {
#line 2081
    *motion_type = 2;
  } else {
#line 2084
    *motion_type = 1;
#line 2089
    tmp___4 = picture_structure == 2;
#line 2089
    (*(motion_vertical_field_select + 0))[1] = tmp___4;
#line 2089
    (*(motion_vertical_field_select + 0))[0] = tmp___4;
  }
#line 2096
  if (picture_coding_type == 1) {
#line 2096
    *stwtype = 8;
  } else {
#line 2096
    *stwtype = 0;
  }
#line 2099
  *macroblock_type &= -2;
#line 2101
  return;
}
}
#line 2103 "src/getpic.c"
static void Thrd_motion_compensation(int t , int MBA , int macroblock_type , int motion_type ,
                                     int (*PMV)[2][2] , int (*motion_vertical_field_select)[2] ,
                                     int *dmvector , int stwtype , int dct_type ) 
{ 
  int bx ;
  int by ;
  int comp ;

  {
#line 2121
  bx = 16 * (MBA % mb_width);
#line 2122
  by = 16 * (MBA / mb_width);
#line 2125
  if (! (macroblock_type & 1)) {
#line 2126
    form_predictions(bx, by, macroblock_type, motion_type, PMV, motion_vertical_field_select,
                     dmvector, stwtype);
  }
#line 2130
  if (base.scalable_mode == 1) {
#line 2131
    ld = & base;
  }
#line 2134
  comp = 0;
#line 2134
  while (comp < block_count) {
#line 2139
    if (Two_Streams) {
#line 2139
      if (enhan.scalable_mode == 3) {
#line 2140
        printf((char const   * __restrict  )"two streams and sc_snr not supported, exiting...\n");
#line 2140
        exit(-1);
#line 2141
        Sum_Block(comp);
      }
    }
#line 2147
    if (Two_Streams) {
#line 2147
      if (enhan.scalable_mode == 3) {
#line 2148
        Saturate(thrd_ld[t].block[comp]);
      } else {
#line 2147
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 2147
    if (ld->MPEG2_Flag) {
#line 2148
      Saturate(thrd_ld[t].block[comp]);
    }
#line 2151
    if (Reference_IDCT_Flag) {
#line 2152
      Reference_IDCT(thrd_ld[t].block[comp]);
    } else {
#line 2154
      Fast_IDCT(thrd_ld[t].block[comp]);
    }
#line 2157
    Thrd_Add_Block(t, comp, bx, by, dct_type, (macroblock_type & 1) == 0);
#line 2134
    comp ++;
  }
#line 2160
  return;
}
}
#line 2174 "src/getpic.c"
static unsigned char stwc_table___0[3][4]  = { {        (unsigned char)6,        (unsigned char)3,        (unsigned char)7,        (unsigned char)4}, 
   {        (unsigned char)2,        (unsigned char)1,        (unsigned char)5,        (unsigned char)4}, 
   {        (unsigned char)2,        (unsigned char)5,        (unsigned char)7,        (unsigned char)4}};
#line 2176 "src/getpic.c"
static unsigned char stwclass_table___0[9]  = 
#line 2176
  {      (unsigned char)0,      (unsigned char)1,      (unsigned char)2,      (unsigned char)1, 
        (unsigned char)1,      (unsigned char)2,      (unsigned char)3,      (unsigned char)3, 
        (unsigned char)4};
#line 2162 "src/getpic.c"
static void Thrd_macroblock_modes(int t , int *pmacroblock_type , int *pstwtype ,
                                  int *pstwclass , int *pmotion_type , int *pmotion_vector_count ,
                                  int *pmv_format , int *pdmv , int *pmvscale , int *pdct_type ) 
{ 
  int macroblock_type ;
  int stwtype ;
  int stwcode ;
  int stwclass ;
  int motion_type ;
  int motion_vector_count ;
  int mv_format ;
  int dmv ;
  int mvscale ;
  int dct_type ;
  unsigned int tmp ;
  unsigned int tmp___0 ;
  unsigned int tmp___1 ;
  int tmp___2 ;
  unsigned int tmp___3 ;

  {
#line 2171
  motion_type = 0;
#line 2180
  macroblock_type = Thrd_Get_macroblock_type(t);
#line 2182
  if (Fault_Flag) {
#line 2182
    return;
  }
#line 2185
  if (macroblock_type & 32) {
#line 2187
    if (spatial_temporal_weight_code_table_index == 0) {
#line 2188
      stwtype = 4;
    } else {
#line 2191
      tmp = Thrd_Get_Bits(t, 2);
#line 2191
      stwcode = (int )tmp;
#line 2192
      stwtype = (int )stwc_table___0[spatial_temporal_weight_code_table_index - 1][stwcode];
    }
  } else
#line 2196
  if (macroblock_type & 64) {
#line 2196
    stwtype = 8;
  } else {
#line 2196
    stwtype = 0;
  }
#line 2199
  stwclass = (int )stwclass_table___0[stwtype];
#line 2202
  if (macroblock_type & 12) {
#line 2204
    if (picture_structure == 3) {
#line 2206
      if (frame_pred_frame_dct) {
#line 2206
        motion_type = 2;
      } else {
#line 2206
        tmp___0 = Thrd_Get_Bits(t, 2);
#line 2206
        motion_type = (int )tmp___0;
      }
    } else {
#line 2210
      tmp___1 = Thrd_Get_Bits(t, 2);
#line 2210
      motion_type = (int )tmp___1;
    }
  } else
#line 2213
  if (macroblock_type & 1) {
#line 2213
    if (concealment_motion_vectors) {
#line 2216
      if (picture_structure == 3) {
#line 2216
        motion_type = 2;
      } else {
#line 2216
        motion_type = 1;
      }
    }
  }
#line 2220
  if (picture_structure == 3) {
#line 2222
    if (motion_type == 1) {
#line 2222
      if (stwclass < 2) {
#line 2222
        motion_vector_count = 2;
      } else {
#line 2222
        motion_vector_count = 1;
      }
    } else {
#line 2222
      motion_vector_count = 1;
    }
#line 2223
    if (motion_type == 2) {
#line 2223
      mv_format = 1;
    } else {
#line 2223
      mv_format = 0;
    }
  } else {
#line 2227
    if (motion_type == 2) {
#line 2227
      motion_vector_count = 2;
    } else {
#line 2227
      motion_vector_count = 1;
    }
#line 2228
    mv_format = 0;
  }
#line 2231
  dmv = motion_type == 3;
#line 2242
  if (mv_format == 0) {
#line 2242
    if (picture_structure == 3) {
#line 2242
      tmp___2 = 1;
    } else {
#line 2242
      tmp___2 = 0;
    }
  } else {
#line 2242
    tmp___2 = 0;
  }
#line 2242
  mvscale = tmp___2;
#line 2245
  if (picture_structure == 3) {
#line 2245
    if (! frame_pred_frame_dct) {
#line 2245
      if (macroblock_type & 3) {
#line 2245
        tmp___3 = Thrd_Get_Bits(t, 1);
#line 2245
        dct_type = (int )tmp___3;
      } else {
#line 2245
        dct_type = 0;
      }
    } else {
#line 2245
      dct_type = 0;
    }
  } else {
#line 2245
    dct_type = 0;
  }
#line 2252
  *pmacroblock_type = macroblock_type;
#line 2253
  *pstwtype = stwtype;
#line 2254
  *pstwclass = stwclass;
#line 2255
  *pmotion_type = motion_type;
#line 2256
  *pmotion_vector_count = motion_vector_count;
#line 2257
  *pmv_format = mv_format;
#line 2258
  *pdmv = dmv;
#line 2259
  *pmvscale = mvscale;
#line 2260
  *pdct_type = dct_type;
#line 2261
  return;
}
}
#line 2263 "src/getpic.c"
static void Thrd_Clear_Block(int t , int comp ) 
{ 
  short *Block_Ptr ;
  int i ;

  {
#line 2270
  Block_Ptr = thrd_ld[t].block[comp];
#line 2285
  i = 0;
#line 2285
  while (i < 64) {
#line 2287
    *(Block_Ptr + i) = (short)0;
#line 2288
    *(Block_Ptr + (i + 1)) = (short)0;
#line 2289
    *(Block_Ptr + (i + 2)) = (short)0;
#line 2290
    *(Block_Ptr + (i + 3)) = (short)0;
#line 2292
    *(Block_Ptr + (i + 4)) = (short)0;
#line 2293
    *(Block_Ptr + (i + 5)) = (short)0;
#line 2294
    *(Block_Ptr + (i + 6)) = (short)0;
#line 2295
    *(Block_Ptr + (i + 7)) = (short)0;
#line 2285
    i += 8;
  }
#line 2300
  return;
}
}
#line 2302 "src/getpic.c"
static void Thrd_Add_Block(int t , int comp , int bx , int by , int dct_type , int addflag ) 
{ 
  int cc ;
  int i ;
  int j ;
  int iincr ;
  unsigned char *rfp ;
  short *bptr ;
  short tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 2311
  if (comp < 4) {
#line 2311
    cc = 0;
  } else {
#line 2311
    cc = (comp & 1) + 1;
  }
#line 2313
  if (cc == 0) {
#line 2317
    if (picture_structure == 3) {
#line 2318
      if (dct_type) {
#line 2321
        rfp = ((current_frame[0] + Coded_Picture_Width * (by + ((comp & 2) >> 1))) + bx) + ((comp & 1) << 3);
#line 2323
        iincr = (Coded_Picture_Width << 1) - 8;
      } else {
#line 2328
        rfp = ((current_frame[0] + Coded_Picture_Width * (by + ((comp & 2) << 2))) + bx) + ((comp & 1) << 3);
#line 2330
        iincr = Coded_Picture_Width - 8;
      }
    } else {
#line 2335
      rfp = ((current_frame[0] + (Coded_Picture_Width << 1) * (by + ((comp & 2) << 2))) + bx) + ((comp & 1) << 3);
#line 2337
      iincr = (Coded_Picture_Width << 1) - 8;
    }
  } else {
#line 2345
    if (chroma_format != 3) {
#line 2346
      bx >>= 1;
    }
#line 2347
    if (chroma_format == 1) {
#line 2348
      by >>= 1;
    }
#line 2349
    if (picture_structure == 3) {
#line 2351
      if (dct_type) {
#line 2351
        if (chroma_format != 1) {
#line 2354
          rfp = ((current_frame[cc] + Chroma_Width * (by + ((comp & 2) >> 1))) + bx) + (comp & 8);
#line 2356
          iincr = (Chroma_Width << 1) - 8;
        } else {
#line 2361
          rfp = ((current_frame[cc] + Chroma_Width * (by + ((comp & 2) << 2))) + bx) + (comp & 8);
#line 2363
          iincr = Chroma_Width - 8;
        }
      } else {
#line 2361
        rfp = ((current_frame[cc] + Chroma_Width * (by + ((comp & 2) << 2))) + bx) + (comp & 8);
#line 2363
        iincr = Chroma_Width - 8;
      }
    } else {
#line 2369
      rfp = ((current_frame[cc] + (Chroma_Width << 1) * (by + ((comp & 2) << 2))) + bx) + (comp & 8);
#line 2371
      iincr = (Chroma_Width << 1) - 8;
    }
  }
#line 2375
  bptr = thrd_ld[t].block[comp];
#line 2377
  if (addflag) {
#line 2440
    i = 0;
#line 2440
    while (i < 4) {
#line 2443
      j = 0;
#line 2443
      while (j < 8) {
#line 2446
        tmp = (short )((int )*bptr + (int )*rfp);
#line 2447
        if ((int )tmp < 0) {
#line 2447
          tmp = (short)0;
        } else {
#line 2447
          if ((int )tmp > 255) {
#line 2447
            tmp___0 = 255;
          } else {
#line 2447
            tmp___0 = (int )tmp;
          }
#line 2447
          tmp = (short )tmp___0;
        }
#line 2448
        *rfp = (unsigned char )tmp;
#line 2449
        bptr ++;
#line 2451
        rfp ++;
#line 2443
        j ++;
      }
#line 2455
      rfp += iincr;
#line 2457
      j = 0;
#line 2457
      while (j < 8) {
#line 2460
        tmp = (short )((int )*bptr + (int )*rfp);
#line 2461
        if ((int )tmp < 0) {
#line 2461
          tmp = (short)0;
        } else {
#line 2461
          if ((int )tmp > 255) {
#line 2461
            tmp___1 = 255;
          } else {
#line 2461
            tmp___1 = (int )tmp;
          }
#line 2461
          tmp = (short )tmp___1;
        }
#line 2462
        *rfp = (unsigned char )tmp;
#line 2463
        bptr ++;
#line 2465
        rfp ++;
#line 2457
        j ++;
      }
#line 2469
      rfp += iincr;
#line 2440
      i ++;
    }
  } else {
#line 2548
    i = 0;
#line 2548
    while (i < 4) {
#line 2551
      j = 0;
#line 2551
      while (j < 8) {
#line 2553
        tmp = (short )((int )*bptr + 128);
#line 2554
        if ((int )tmp < 0) {
#line 2554
          tmp = (short)0;
        } else {
#line 2554
          if ((int )tmp > 255) {
#line 2554
            tmp___2 = 255;
          } else {
#line 2554
            tmp___2 = (int )tmp;
          }
#line 2554
          tmp = (short )tmp___2;
        }
#line 2555
        *rfp = (unsigned char )tmp;
#line 2556
        rfp ++;
#line 2556
        bptr ++;
#line 2551
        j ++;
      }
#line 2558
      rfp += iincr;
#line 2560
      j = 0;
#line 2560
      while (j < 8) {
#line 2562
        tmp = (short )((int )*bptr + 128);
#line 2563
        if ((int )tmp < 0) {
#line 2563
          tmp = (short)0;
        } else {
#line 2563
          if ((int )tmp > 255) {
#line 2563
            tmp___3 = 255;
          } else {
#line 2563
            tmp___3 = (int )tmp;
          }
#line 2563
          tmp = (short )tmp___3;
        }
#line 2564
        *rfp = (unsigned char )tmp;
#line 2565
        rfp ++;
#line 2565
        bptr ++;
#line 2560
        j ++;
      }
#line 2568
      rfp += iincr;
#line 2548
      i ++;
    }
  }
#line 2584
  return;
}
}
#line 1 "getvlc.o"
#pragma merger("0","/tmp/cil-M9WYBxgk.i","-g,-O4")
#line 150 "src/global.h"
int Get_motion_code(void) ;
#line 151
int Get_dmvector(void) ;
#line 212
int Thrd_Get_motion_code(int t ) ;
#line 218
int Thrd_Get_dmvector(int t ) ;
#line 580
int global_MBA ;
#line 581
int global_pic ;
#line 98 "src/getvlc.h"
static VLCtab PMBtab0[8]  = 
#line 98 "src/getvlc.h"
  {      {(char)-1, (char)0}, 
        {(char)8, (char)3}, 
        {(char)2, (char)2}, 
        {(char)2, (char)2}, 
        {(char)10, (char)1}, 
        {(char)10, (char)1}, 
        {(char)10, (char)1}, 
        {(char)10, (char)1}};
#line 109 "src/getvlc.h"
static VLCtab PMBtab1[8]  = 
#line 109
  {      {(char)-1, (char)0}, 
        {(char)17, (char)6}, 
        {(char)18, (char)5}, 
        {(char)18, (char)5}, 
        {(char)26, (char)5}, 
        {(char)26, (char)5}, 
        {(char)1, (char)5}, 
        {(char)1, (char)5}};
#line 118 "src/getvlc.h"
static VLCtab BMBtab0[16]  = 
#line 118
  {      {(char)-1, (char)0}, 
        {(char)-1, (char)0}, 
        {(char)8, (char)4}, 
        {(char)10, (char)4}, 
        {(char)4, (char)3}, 
        {(char)4, (char)3}, 
        {(char)6, (char)3}, 
        {(char)6, (char)3}, 
        {(char)12, (char)2}, 
        {(char)12, (char)2}, 
        {(char)12, (char)2}, 
        {(char)12, (char)2}, 
        {(char)14, (char)2}, 
        {(char)14, (char)2}, 
        {(char)14, (char)2}, 
        {(char)14, (char)2}};
#line 138 "src/getvlc.h"
static VLCtab BMBtab1[8]  = 
#line 138
  {      {(char)-1, (char)0}, 
        {(char)17, (char)6}, 
        {(char)22, (char)6}, 
        {(char)26, (char)6}, 
        {(char)30, (char)5}, 
        {(char)30, (char)5}, 
        {(char)1, (char)5}, 
        {(char)1, (char)5}};
#line 150 "src/getvlc.h"
static VLCtab spIMBtab[16]  = 
#line 150
  {      {(char)-1, (char)0}, 
        {(char)64, (char)4}, 
        {(char)17, (char)4}, 
        {(char)1, (char)4}, 
        {(char)82, (char)2}, 
        {(char)82, (char)2}, 
        {(char)82, (char)2}, 
        {(char)82, (char)2}, 
        {(char)66, (char)1}, 
        {(char)66, (char)1}, 
        {(char)66, (char)1}, 
        {(char)66, (char)1}, 
        {(char)66, (char)1}, 
        {(char)66, (char)1}, 
        {(char)66, (char)1}, 
        {(char)66, (char)1}};
#line 164 "src/getvlc.h"
static VLCtab spPMBtab0[16]  = 
#line 164
  {      {(char)-1, (char)0}, 
        {(char)-1, (char)0}, 
        {(char)8, (char)4}, 
        {(char)40, (char)4}, 
        {(char)26, (char)3}, 
        {(char)26, (char)3}, 
        {(char)42, (char)3}, 
        {(char)42, (char)3}, 
        {(char)10, (char)2}, 
        {(char)10, (char)2}, 
        {(char)10, (char)2}, 
        {(char)10, (char)2}, 
        {(char)58, (char)2}, 
        {(char)58, (char)2}, 
        {(char)58, (char)2}, 
        {(char)58, (char)2}};
#line 183 "src/getvlc.h"
static VLCtab spPMBtab1[16]  = 
#line 183
  {      {(char)-1, (char)0}, 
        {(char)-1, (char)0}, 
        {(char)82, (char)7}, 
        {(char)64, (char)7}, 
        {(char)2, (char)7}, 
        {(char)66, (char)7}, 
        {(char)17, (char)7}, 
        {(char)1, (char)7}, 
        {(char)18, (char)6}, 
        {(char)18, (char)6}, 
        {(char)50, (char)6}, 
        {(char)50, (char)6}, 
        {(char)32, (char)6}, 
        {(char)32, (char)6}, 
        {(char)34, (char)6}, 
        {(char)34, (char)6}};
#line 203 "src/getvlc.h"
static VLCtab spBMBtab0[14]  = 
#line 203
  {      {(char)8, (char)4}, 
        {(char)10, (char)4}, 
        {(char)4, (char)3}, 
        {(char)4, (char)3}, 
        {(char)6, (char)3}, 
        {(char)6, (char)3}, 
        {(char)12, (char)2}, 
        {(char)12, (char)2}, 
        {(char)12, (char)2}, 
        {(char)12, (char)2}, 
        {(char)14, (char)2}, 
        {(char)14, (char)2}, 
        {(char)14, (char)2}, 
        {(char)14, (char)2}};
#line 221 "src/getvlc.h"
static VLCtab spBMBtab1[12]  = 
#line 221
  {      {(char)26, (char)7}, 
        {(char)22, (char)7}, 
        {(char)1, (char)7}, 
        {(char)30, (char)7}, 
        {(char)40, (char)6}, 
        {(char)40, (char)6}, 
        {(char)42, (char)6}, 
        {(char)42, (char)6}, 
        {(char)36, (char)6}, 
        {(char)36, (char)6}, 
        {(char)38, (char)6}, 
        {(char)38, (char)6}};
#line 237 "src/getvlc.h"
static VLCtab spBMBtab2[8]  = 
#line 237
  {      {(char)17, (char)8}, 
        {(char)17, (char)8}, 
        {(char)58, (char)8}, 
        {(char)58, (char)8}, 
        {(char)54, (char)9}, 
        {(char)82, (char)9}, 
        {(char)64, (char)9}, 
        {(char)66, (char)9}};
#line 249 "src/getvlc.h"
static VLCtab SNRMBtab[8]  = 
#line 249
  {      {(char)-1, (char)0}, 
        {(char)0, (char)3}, 
        {(char)18, (char)2}, 
        {(char)18, (char)2}, 
        {(char)2, (char)1}, 
        {(char)2, (char)1}, 
        {(char)2, (char)1}, 
        {(char)2, (char)1}};
#line 261 "src/getvlc.h"
static VLCtab MVtab0[8]  = 
#line 261
  {      {(char)-1, (char)0}, 
        {(char)3, (char)3}, 
        {(char)2, (char)2}, 
        {(char)2, (char)2}, 
        {(char)1, (char)1}, 
        {(char)1, (char)1}, 
        {(char)1, (char)1}, 
        {(char)1, (char)1}};
#line 266 "src/getvlc.h"
static VLCtab MVtab1[8]  = 
#line 266
  {      {(char)-1, (char)0}, 
        {(char)-1, (char)0}, 
        {(char)-1, (char)0}, 
        {(char)7, (char)6}, 
        {(char)6, (char)6}, 
        {(char)5, (char)6}, 
        {(char)4, (char)5}, 
        {(char)4, (char)5}};
#line 271 "src/getvlc.h"
static VLCtab MVtab2[12]  = 
#line 271
  {      {(char)16, (char)9}, 
        {(char)15, (char)9}, 
        {(char)14, (char)9}, 
        {(char)13, (char)9}, 
        {(char)12, (char)9}, 
        {(char)11, (char)9}, 
        {(char)10, (char)8}, 
        {(char)10, (char)8}, 
        {(char)9, (char)8}, 
        {(char)9, (char)8}, 
        {(char)8, (char)8}, 
        {(char)8, (char)8}};
#line 278 "src/getvlc.h"
static VLCtab CBPtab0[32]  = 
#line 278
  {      {(char)-1, (char)0}, 
        {(char)-1, (char)0}, 
        {(char)-1, (char)0}, 
        {(char)-1, (char)0}, 
        {(char)-1, (char)0}, 
        {(char)-1, (char)0}, 
        {(char)-1, (char)0}, 
        {(char)-1, (char)0}, 
        {(char)62, (char)5}, 
        {(char)2, (char)5}, 
        {(char)61, (char)5}, 
        {(char)1, (char)5}, 
        {(char)56, (char)5}, 
        {(char)52, (char)5}, 
        {(char)44, (char)5}, 
        {(char)28, (char)5}, 
        {(char)40, (char)5}, 
        {(char)20, (char)5}, 
        {(char)48, (char)5}, 
        {(char)12, (char)5}, 
        {(char)32, (char)4}, 
        {(char)32, (char)4}, 
        {(char)16, (char)4}, 
        {(char)16, (char)4}, 
        {(char)8, (char)4}, 
        {(char)8, (char)4}, 
        {(char)4, (char)4}, 
        {(char)4, (char)4}, 
        {(char)60, (char)3}, 
        {(char)60, (char)3}, 
        {(char)60, (char)3}, 
        {(char)60, (char)3}};
#line 287 "src/getvlc.h"
static VLCtab CBPtab1[64]  = 
#line 287
  {      {(char)-1, (char)0}, 
        {(char)-1, (char)0}, 
        {(char)-1, (char)0}, 
        {(char)-1, (char)0}, 
        {(char)58, (char)8}, 
        {(char)54, (char)8}, 
        {(char)46, (char)8}, 
        {(char)30, (char)8}, 
        {(char)57, (char)8}, 
        {(char)53, (char)8}, 
        {(char)45, (char)8}, 
        {(char)29, (char)8}, 
        {(char)38, (char)8}, 
        {(char)26, (char)8}, 
        {(char)37, (char)8}, 
        {(char)25, (char)8}, 
        {(char)43, (char)8}, 
        {(char)23, (char)8}, 
        {(char)51, (char)8}, 
        {(char)15, (char)8}, 
        {(char)42, (char)8}, 
        {(char)22, (char)8}, 
        {(char)50, (char)8}, 
        {(char)14, (char)8}, 
        {(char)41, (char)8}, 
        {(char)21, (char)8}, 
        {(char)49, (char)8}, 
        {(char)13, (char)8}, 
        {(char)35, (char)8}, 
        {(char)19, (char)8}, 
        {(char)11, (char)8}, 
        {(char)7, (char)8}, 
        {(char)34, (char)7}, 
        {(char)34, (char)7}, 
        {(char)18, (char)7}, 
        {(char)18, (char)7}, 
        {(char)10, (char)7}, 
        {(char)10, (char)7}, 
        {(char)6, (char)7}, 
        {(char)6, (char)7}, 
        {(char)33, (char)7}, 
        {(char)33, (char)7}, 
        {(char)17, (char)7}, 
        {(char)17, (char)7}, 
        {(char)9, (char)7}, 
        {(char)9, (char)7}, 
        {(char)5, (char)7}, 
        {(char)5, (char)7}, 
        {(char)63, (char)6}, 
        {(char)63, (char)6}, 
        {(char)63, (char)6}, 
        {(char)63, (char)6}, 
        {(char)3, (char)6}, 
        {(char)3, (char)6}, 
        {(char)3, (char)6}, 
        {(char)3, (char)6}, 
        {(char)36, (char)6}, 
        {(char)36, (char)6}, 
        {(char)36, (char)6}, 
        {(char)36, (char)6}, 
        {(char)24, (char)6}, 
        {(char)24, (char)6}, 
        {(char)24, (char)6}, 
        {(char)24, (char)6}};
#line 300 "src/getvlc.h"
static VLCtab CBPtab2[8]  = 
#line 300
  {      {(char)-1, (char)0}, 
        {(char)0, (char)9}, 
        {(char)39, (char)9}, 
        {(char)27, (char)9}, 
        {(char)59, (char)9}, 
        {(char)55, (char)9}, 
        {(char)47, (char)9}, 
        {(char)31, (char)9}};
#line 305 "src/getvlc.h"
static VLCtab MBAtab1[16]  = 
#line 305
  {      {(char)-1, (char)0}, 
        {(char)-1, (char)0}, 
        {(char)7, (char)5}, 
        {(char)6, (char)5}, 
        {(char)5, (char)4}, 
        {(char)5, (char)4}, 
        {(char)4, (char)4}, 
        {(char)4, (char)4}, 
        {(char)3, (char)3}, 
        {(char)3, (char)3}, 
        {(char)3, (char)3}, 
        {(char)3, (char)3}, 
        {(char)2, (char)3}, 
        {(char)2, (char)3}, 
        {(char)2, (char)3}, 
        {(char)2, (char)3}};
#line 311 "src/getvlc.h"
static VLCtab MBAtab2[104]  = 
#line 311
  {      {(char)33, (char)11}, 
        {(char)32, (char)11}, 
        {(char)31, (char)11}, 
        {(char)30, (char)11}, 
        {(char)29, (char)11}, 
        {(char)28, (char)11}, 
        {(char)27, (char)11}, 
        {(char)26, (char)11}, 
        {(char)25, (char)11}, 
        {(char)24, (char)11}, 
        {(char)23, (char)11}, 
        {(char)22, (char)11}, 
        {(char)21, (char)10}, 
        {(char)21, (char)10}, 
        {(char)20, (char)10}, 
        {(char)20, (char)10}, 
        {(char)19, (char)10}, 
        {(char)19, (char)10}, 
        {(char)18, (char)10}, 
        {(char)18, (char)10}, 
        {(char)17, (char)10}, 
        {(char)17, (char)10}, 
        {(char)16, (char)10}, 
        {(char)16, (char)10}, 
        {(char)15, (char)8}, 
        {(char)15, (char)8}, 
        {(char)15, (char)8}, 
        {(char)15, (char)8}, 
        {(char)15, (char)8}, 
        {(char)15, (char)8}, 
        {(char)15, (char)8}, 
        {(char)15, (char)8}, 
        {(char)14, (char)8}, 
        {(char)14, (char)8}, 
        {(char)14, (char)8}, 
        {(char)14, (char)8}, 
        {(char)14, (char)8}, 
        {(char)14, (char)8}, 
        {(char)14, (char)8}, 
        {(char)14, (char)8}, 
        {(char)13, (char)8}, 
        {(char)13, (char)8}, 
        {(char)13, (char)8}, 
        {(char)13, (char)8}, 
        {(char)13, (char)8}, 
        {(char)13, (char)8}, 
        {(char)13, (char)8}, 
        {(char)13, (char)8}, 
        {(char)12, (char)8}, 
        {(char)12, (char)8}, 
        {(char)12, (char)8}, 
        {(char)12, (char)8}, 
        {(char)12, (char)8}, 
        {(char)12, (char)8}, 
        {(char)12, (char)8}, 
        {(char)12, (char)8}, 
        {(char)11, (char)8}, 
        {(char)11, (char)8}, 
        {(char)11, (char)8}, 
        {(char)11, (char)8}, 
        {(char)11, (char)8}, 
        {(char)11, (char)8}, 
        {(char)11, (char)8}, 
        {(char)11, (char)8}, 
        {(char)10, (char)8}, 
        {(char)10, (char)8}, 
        {(char)10, (char)8}, 
        {(char)10, (char)8}, 
        {(char)10, (char)8}, 
        {(char)10, (char)8}, 
        {(char)10, (char)8}, 
        {(char)10, (char)8}, 
        {(char)9, (char)7}, 
        {(char)9, (char)7}, 
        {(char)9, (char)7}, 
        {(char)9, (char)7}, 
        {(char)9, (char)7}, 
        {(char)9, (char)7}, 
        {(char)9, (char)7}, 
        {(char)9, (char)7}, 
        {(char)9, (char)7}, 
        {(char)9, (char)7}, 
        {(char)9, (char)7}, 
        {(char)9, (char)7}, 
        {(char)9, (char)7}, 
        {(char)9, (char)7}, 
        {(char)9, (char)7}, 
        {(char)9, (char)7}, 
        {(char)8, (char)7}, 
        {(char)8, (char)7}, 
        {(char)8, (char)7}, 
        {(char)8, (char)7}, 
        {(char)8, (char)7}, 
        {(char)8, (char)7}, 
        {(char)8, (char)7}, 
        {(char)8, (char)7}, 
        {(char)8, (char)7}, 
        {(char)8, (char)7}, 
        {(char)8, (char)7}, 
        {(char)8, (char)7}, 
        {(char)8, (char)7}, 
        {(char)8, (char)7}, 
        {(char)8, (char)7}, 
        {(char)8, (char)7}};
#line 329 "src/getvlc.h"
static VLCtab DClumtab0[32]  = 
#line 329
  {      {(char)1, (char)2}, 
        {(char)1, (char)2}, 
        {(char)1, (char)2}, 
        {(char)1, (char)2}, 
        {(char)1, (char)2}, 
        {(char)1, (char)2}, 
        {(char)1, (char)2}, 
        {(char)1, (char)2}, 
        {(char)2, (char)2}, 
        {(char)2, (char)2}, 
        {(char)2, (char)2}, 
        {(char)2, (char)2}, 
        {(char)2, (char)2}, 
        {(char)2, (char)2}, 
        {(char)2, (char)2}, 
        {(char)2, (char)2}, 
        {(char)0, (char)3}, 
        {(char)0, (char)3}, 
        {(char)0, (char)3}, 
        {(char)0, (char)3}, 
        {(char)3, (char)3}, 
        {(char)3, (char)3}, 
        {(char)3, (char)3}, 
        {(char)3, (char)3}, 
        {(char)4, (char)3}, 
        {(char)4, (char)3}, 
        {(char)4, (char)3}, 
        {(char)4, (char)3}, 
        {(char)5, (char)4}, 
        {(char)5, (char)4}, 
        {(char)6, (char)5}, 
        {(char)-1, (char)0}};
#line 337 "src/getvlc.h"
static VLCtab DClumtab1[16]  = 
#line 337
  {      {(char)7, (char)6}, 
        {(char)7, (char)6}, 
        {(char)7, (char)6}, 
        {(char)7, (char)6}, 
        {(char)7, (char)6}, 
        {(char)7, (char)6}, 
        {(char)7, (char)6}, 
        {(char)7, (char)6}, 
        {(char)8, (char)7}, 
        {(char)8, (char)7}, 
        {(char)8, (char)7}, 
        {(char)8, (char)7}, 
        {(char)9, (char)8}, 
        {(char)9, (char)8}, 
        {(char)10, (char)9}, 
        {(char)11, (char)9}};
#line 343 "src/getvlc.h"
static VLCtab DCchromtab0[32]  = 
#line 343
  {      {(char)0, (char)2}, 
        {(char)0, (char)2}, 
        {(char)0, (char)2}, 
        {(char)0, (char)2}, 
        {(char)0, (char)2}, 
        {(char)0, (char)2}, 
        {(char)0, (char)2}, 
        {(char)0, (char)2}, 
        {(char)1, (char)2}, 
        {(char)1, (char)2}, 
        {(char)1, (char)2}, 
        {(char)1, (char)2}, 
        {(char)1, (char)2}, 
        {(char)1, (char)2}, 
        {(char)1, (char)2}, 
        {(char)1, (char)2}, 
        {(char)2, (char)2}, 
        {(char)2, (char)2}, 
        {(char)2, (char)2}, 
        {(char)2, (char)2}, 
        {(char)2, (char)2}, 
        {(char)2, (char)2}, 
        {(char)2, (char)2}, 
        {(char)2, (char)2}, 
        {(char)3, (char)3}, 
        {(char)3, (char)3}, 
        {(char)3, (char)3}, 
        {(char)3, (char)3}, 
        {(char)4, (char)4}, 
        {(char)4, (char)4}, 
        {(char)5, (char)5}, 
        {(char)-1, (char)0}};
#line 351 "src/getvlc.h"
static VLCtab DCchromtab1[32]  = 
#line 351
  {      {(char)6, (char)6}, 
        {(char)6, (char)6}, 
        {(char)6, (char)6}, 
        {(char)6, (char)6}, 
        {(char)6, (char)6}, 
        {(char)6, (char)6}, 
        {(char)6, (char)6}, 
        {(char)6, (char)6}, 
        {(char)6, (char)6}, 
        {(char)6, (char)6}, 
        {(char)6, (char)6}, 
        {(char)6, (char)6}, 
        {(char)6, (char)6}, 
        {(char)6, (char)6}, 
        {(char)6, (char)6}, 
        {(char)6, (char)6}, 
        {(char)7, (char)7}, 
        {(char)7, (char)7}, 
        {(char)7, (char)7}, 
        {(char)7, (char)7}, 
        {(char)7, (char)7}, 
        {(char)7, (char)7}, 
        {(char)7, (char)7}, 
        {(char)7, (char)7}, 
        {(char)8, (char)8}, 
        {(char)8, (char)8}, 
        {(char)8, (char)8}, 
        {(char)8, (char)8}, 
        {(char)9, (char)9}, 
        {(char)9, (char)9}, 
        {(char)10, (char)10}, 
        {(char)11, (char)10}};
#line 361 "src/getvlc.h"
DCTtab DCTtabfirst[12]  = 
#line 361
  {      {(char)0, (char)2, (char)4}, 
        {(char)2, (char)1, (char)4}, 
        {(char)1, (char)1, (char)3}, 
        {(char)1, (char)1, (char)3}, 
        {(char)0, (char)1, (char)1}, 
        {(char)0, (char)1, (char)1}, 
        {(char)0, (char)1, (char)1}, 
        {(char)0, (char)1, (char)1}, 
        {(char)0, (char)1, (char)1}, 
        {(char)0, (char)1, (char)1}, 
        {(char)0, (char)1, (char)1}, 
        {(char)0, (char)1, (char)1}};
#line 371 "src/getvlc.h"
DCTtab DCTtabnext[12]  = 
#line 371
  {      {(char)0, (char)2, (char)4}, 
        {(char)2, (char)1, (char)4}, 
        {(char)1, (char)1, (char)3}, 
        {(char)1, (char)1, (char)3}, 
        {(char)64, (char)0, (char)2}, 
        {(char)64, (char)0, (char)2}, 
        {(char)64, (char)0, (char)2}, 
        {(char)64, (char)0, (char)2}, 
        {(char)0, (char)1, (char)2}, 
        {(char)0, (char)1, (char)2}, 
        {(char)0, (char)1, (char)2}, 
        {(char)0, (char)1, (char)2}};
#line 381 "src/getvlc.h"
DCTtab DCTtab0[60]  = 
#line 381
  {      {(char)65, (char)0, (char)6}, 
        {(char)65, (char)0, (char)6}, 
        {(char)65, (char)0, (char)6}, 
        {(char)65, (char)0, (char)6}, 
        {(char)2, (char)2, (char)7}, 
        {(char)2, (char)2, (char)7}, 
        {(char)9, (char)1, (char)7}, 
        {(char)9, (char)1, (char)7}, 
        {(char)0, (char)4, (char)7}, 
        {(char)0, (char)4, (char)7}, 
        {(char)8, (char)1, (char)7}, 
        {(char)8, (char)1, (char)7}, 
        {(char)7, (char)1, (char)6}, 
        {(char)7, (char)1, (char)6}, 
        {(char)7, (char)1, (char)6}, 
        {(char)7, (char)1, (char)6}, 
        {(char)6, (char)1, (char)6}, 
        {(char)6, (char)1, (char)6}, 
        {(char)6, (char)1, (char)6}, 
        {(char)6, (char)1, (char)6}, 
        {(char)1, (char)2, (char)6}, 
        {(char)1, (char)2, (char)6}, 
        {(char)1, (char)2, (char)6}, 
        {(char)1, (char)2, (char)6}, 
        {(char)5, (char)1, (char)6}, 
        {(char)5, (char)1, (char)6}, 
        {(char)5, (char)1, (char)6}, 
        {(char)5, (char)1, (char)6}, 
        {(char)13, (char)1, (char)8}, 
        {(char)0, (char)6, (char)8}, 
        {(char)12, (char)1, (char)8}, 
        {(char)11, (char)1, (char)8}, 
        {(char)3, (char)2, (char)8}, 
        {(char)1, (char)3, (char)8}, 
        {(char)0, (char)5, (char)8}, 
        {(char)10, (char)1, (char)8}, 
        {(char)0, (char)3, (char)5}, 
        {(char)0, (char)3, (char)5}, 
        {(char)0, (char)3, (char)5}, 
        {(char)0, (char)3, (char)5}, 
        {(char)0, (char)3, (char)5}, 
        {(char)0, (char)3, (char)5}, 
        {(char)0, (char)3, (char)5}, 
        {(char)0, (char)3, (char)5}, 
        {(char)4, (char)1, (char)5}, 
        {(char)4, (char)1, (char)5}, 
        {(char)4, (char)1, (char)5}, 
        {(char)4, (char)1, (char)5}, 
        {(char)4, (char)1, (char)5}, 
        {(char)4, (char)1, (char)5}, 
        {(char)4, (char)1, (char)5}, 
        {(char)4, (char)1, (char)5}, 
        {(char)3, (char)1, (char)5}, 
        {(char)3, (char)1, (char)5}, 
        {(char)3, (char)1, (char)5}, 
        {(char)3, (char)1, (char)5}, 
        {(char)3, (char)1, (char)5}, 
        {(char)3, (char)1, (char)5}, 
        {(char)3, (char)1, (char)5}, 
        {(char)3, (char)1, (char)5}};
#line 403 "src/getvlc.h"
DCTtab DCTtab0a[252]  = 
#line 403
  {      {(char)65, (char)0, (char)6}, 
        {(char)65, (char)0, (char)6}, 
        {(char)65, (char)0, (char)6}, 
        {(char)65, (char)0, (char)6}, 
        {(char)7, (char)1, (char)7}, 
        {(char)7, (char)1, (char)7}, 
        {(char)8, (char)1, (char)7}, 
        {(char)8, (char)1, (char)7}, 
        {(char)6, (char)1, (char)7}, 
        {(char)6, (char)1, (char)7}, 
        {(char)2, (char)2, (char)7}, 
        {(char)2, (char)2, (char)7}, 
        {(char)0, (char)7, (char)6}, 
        {(char)0, (char)7, (char)6}, 
        {(char)0, (char)7, (char)6}, 
        {(char)0, (char)7, (char)6}, 
        {(char)0, (char)6, (char)6}, 
        {(char)0, (char)6, (char)6}, 
        {(char)0, (char)6, (char)6}, 
        {(char)0, (char)6, (char)6}, 
        {(char)4, (char)1, (char)6}, 
        {(char)4, (char)1, (char)6}, 
        {(char)4, (char)1, (char)6}, 
        {(char)4, (char)1, (char)6}, 
        {(char)5, (char)1, (char)6}, 
        {(char)5, (char)1, (char)6}, 
        {(char)5, (char)1, (char)6}, 
        {(char)5, (char)1, (char)6}, 
        {(char)1, (char)5, (char)8}, 
        {(char)11, (char)1, (char)8}, 
        {(char)0, (char)11, (char)8}, 
        {(char)0, (char)10, (char)8}, 
        {(char)13, (char)1, (char)8}, 
        {(char)12, (char)1, (char)8}, 
        {(char)3, (char)2, (char)8}, 
        {(char)1, (char)4, (char)8}, 
        {(char)2, (char)1, (char)5}, 
        {(char)2, (char)1, (char)5}, 
        {(char)2, (char)1, (char)5}, 
        {(char)2, (char)1, (char)5}, 
        {(char)2, (char)1, (char)5}, 
        {(char)2, (char)1, (char)5}, 
        {(char)2, (char)1, (char)5}, 
        {(char)2, (char)1, (char)5}, 
        {(char)1, (char)2, (char)5}, 
        {(char)1, (char)2, (char)5}, 
        {(char)1, (char)2, (char)5}, 
        {(char)1, (char)2, (char)5}, 
        {(char)1, (char)2, (char)5}, 
        {(char)1, (char)2, (char)5}, 
        {(char)1, (char)2, (char)5}, 
        {(char)1, (char)2, (char)5}, 
        {(char)3, (char)1, (char)5}, 
        {(char)3, (char)1, (char)5}, 
        {(char)3, (char)1, (char)5}, 
        {(char)3, (char)1, (char)5}, 
        {(char)3, (char)1, (char)5}, 
        {(char)3, (char)1, (char)5}, 
        {(char)3, (char)1, (char)5}, 
        {(char)3, (char)1, (char)5}, 
        {(char)1, (char)1, (char)3}, 
        {(char)1, (char)1, (char)3}, 
        {(char)1, (char)1, (char)3}, 
        {(char)1, (char)1, (char)3}, 
        {(char)1, (char)1, (char)3}, 
        {(char)1, (char)1, (char)3}, 
        {(char)1, (char)1, (char)3}, 
        {(char)1, (char)1, (char)3}, 
        {(char)1, (char)1, (char)3}, 
        {(char)1, (char)1, (char)3}, 
        {(char)1, (char)1, (char)3}, 
        {(char)1, (char)1, (char)3}, 
        {(char)1, (char)1, (char)3}, 
        {(char)1, (char)1, (char)3}, 
        {(char)1, (char)1, (char)3}, 
        {(char)1, (char)1, (char)3}, 
        {(char)1, (char)1, (char)3}, 
        {(char)1, (char)1, (char)3}, 
        {(char)1, (char)1, (char)3}, 
        {(char)1, (char)1, (char)3}, 
        {(char)1, (char)1, (char)3}, 
        {(char)1, (char)1, (char)3}, 
        {(char)1, (char)1, (char)3}, 
        {(char)1, (char)1, (char)3}, 
        {(char)1, (char)1, (char)3}, 
        {(char)1, (char)1, (char)3}, 
        {(char)1, (char)1, (char)3}, 
        {(char)1, (char)1, (char)3}, 
        {(char)1, (char)1, (char)3}, 
        {(char)1, (char)1, (char)3}, 
        {(char)1, (char)1, (char)3}, 
        {(char)1, (char)1, (char)3}, 
        {(char)64, (char)0, (char)4}, 
        {(char)64, (char)0, (char)4}, 
        {(char)64, (char)0, (char)4}, 
        {(char)64, (char)0, (char)4}, 
        {(char)64, (char)0, (char)4}, 
        {(char)64, (char)0, (char)4}, 
        {(char)64, (char)0, (char)4}, 
        {(char)64, (char)0, (char)4}, 
        {(char)64, (char)0, (char)4}, 
        {(char)64, (char)0, (char)4}, 
        {(char)64, (char)0, (char)4}, 
        {(char)64, (char)0, (char)4}, 
        {(char)64, (char)0, (char)4}, 
        {(char)64, (char)0, (char)4}, 
        {(char)64, (char)0, (char)4}, 
        {(char)64, (char)0, (char)4}, 
        {(char)0, (char)3, (char)4}, 
        {(char)0, (char)3, (char)4}, 
        {(char)0, (char)3, (char)4}, 
        {(char)0, (char)3, (char)4}, 
        {(char)0, (char)3, (char)4}, 
        {(char)0, (char)3, (char)4}, 
        {(char)0, (char)3, (char)4}, 
        {(char)0, (char)3, (char)4}, 
        {(char)0, (char)3, (char)4}, 
        {(char)0, (char)3, (char)4}, 
        {(char)0, (char)3, (char)4}, 
        {(char)0, (char)3, (char)4}, 
        {(char)0, (char)3, (char)4}, 
        {(char)0, (char)3, (char)4}, 
        {(char)0, (char)3, (char)4}, 
        {(char)0, (char)3, (char)4}, 
        {(char)0, (char)1, (char)2}, 
        {(char)0, (char)1, (char)2}, 
        {(char)0, (char)1, (char)2}, 
        {(char)0, (char)1, (char)2}, 
        {(char)0, (char)1, (char)2}, 
        {(char)0, (char)1, (char)2}, 
        {(char)0, (char)1, (char)2}, 
        {(char)0, (char)1, (char)2}, 
        {(char)0, (char)1, (char)2}, 
        {(char)0, (char)1, (char)2}, 
        {(char)0, (char)1, (char)2}, 
        {(char)0, (char)1, (char)2}, 
        {(char)0, (char)1, (char)2}, 
        {(char)0, (char)1, (char)2}, 
        {(char)0, (char)1, (char)2}, 
        {(char)0, (char)1, (char)2}, 
        {(char)0, (char)1, (char)2}, 
        {(char)0, (char)1, (char)2}, 
        {(char)0, (char)1, (char)2}, 
        {(char)0, (char)1, (char)2}, 
        {(char)0, (char)1, (char)2}, 
        {(char)0, (char)1, (char)2}, 
        {(char)0, (char)1, (char)2}, 
        {(char)0, (char)1, (char)2}, 
        {(char)0, (char)1, (char)2}, 
        {(char)0, (char)1, (char)2}, 
        {(char)0, (char)1, (char)2}, 
        {(char)0, (char)1, (char)2}, 
        {(char)0, (char)1, (char)2}, 
        {(char)0, (char)1, (char)2}, 
        {(char)0, (char)1, (char)2}, 
        {(char)0, (char)1, (char)2}, 
        {(char)0, (char)1, (char)2}, 
        {(char)0, (char)1, (char)2}, 
        {(char)0, (char)1, (char)2}, 
        {(char)0, (char)1, (char)2}, 
        {(char)0, (char)1, (char)2}, 
        {(char)0, (char)1, (char)2}, 
        {(char)0, (char)1, (char)2}, 
        {(char)0, (char)1, (char)2}, 
        {(char)0, (char)1, (char)2}, 
        {(char)0, (char)1, (char)2}, 
        {(char)0, (char)1, (char)2}, 
        {(char)0, (char)1, (char)2}, 
        {(char)0, (char)1, (char)2}, 
        {(char)0, (char)1, (char)2}, 
        {(char)0, (char)1, (char)2}, 
        {(char)0, (char)1, (char)2}, 
        {(char)0, (char)1, (char)2}, 
        {(char)0, (char)1, (char)2}, 
        {(char)0, (char)1, (char)2}, 
        {(char)0, (char)1, (char)2}, 
        {(char)0, (char)1, (char)2}, 
        {(char)0, (char)1, (char)2}, 
        {(char)0, (char)1, (char)2}, 
        {(char)0, (char)1, (char)2}, 
        {(char)0, (char)1, (char)2}, 
        {(char)0, (char)1, (char)2}, 
        {(char)0, (char)1, (char)2}, 
        {(char)0, (char)1, (char)2}, 
        {(char)0, (char)1, (char)2}, 
        {(char)0, (char)1, (char)2}, 
        {(char)0, (char)1, (char)2}, 
        {(char)0, (char)1, (char)2}, 
        {(char)0, (char)2, (char)3}, 
        {(char)0, (char)2, (char)3}, 
        {(char)0, (char)2, (char)3}, 
        {(char)0, (char)2, (char)3}, 
        {(char)0, (char)2, (char)3}, 
        {(char)0, (char)2, (char)3}, 
        {(char)0, (char)2, (char)3}, 
        {(char)0, (char)2, (char)3}, 
        {(char)0, (char)2, (char)3}, 
        {(char)0, (char)2, (char)3}, 
        {(char)0, (char)2, (char)3}, 
        {(char)0, (char)2, (char)3}, 
        {(char)0, (char)2, (char)3}, 
        {(char)0, (char)2, (char)3}, 
        {(char)0, (char)2, (char)3}, 
        {(char)0, (char)2, (char)3}, 
        {(char)0, (char)2, (char)3}, 
        {(char)0, (char)2, (char)3}, 
        {(char)0, (char)2, (char)3}, 
        {(char)0, (char)2, (char)3}, 
        {(char)0, (char)2, (char)3}, 
        {(char)0, (char)2, (char)3}, 
        {(char)0, (char)2, (char)3}, 
        {(char)0, (char)2, (char)3}, 
        {(char)0, (char)2, (char)3}, 
        {(char)0, (char)2, (char)3}, 
        {(char)0, (char)2, (char)3}, 
        {(char)0, (char)2, (char)3}, 
        {(char)0, (char)2, (char)3}, 
        {(char)0, (char)2, (char)3}, 
        {(char)0, (char)2, (char)3}, 
        {(char)0, (char)2, (char)3}, 
        {(char)0, (char)4, (char)5}, 
        {(char)0, (char)4, (char)5}, 
        {(char)0, (char)4, (char)5}, 
        {(char)0, (char)4, (char)5}, 
        {(char)0, (char)4, (char)5}, 
        {(char)0, (char)4, (char)5}, 
        {(char)0, (char)4, (char)5}, 
        {(char)0, (char)4, (char)5}, 
        {(char)0, (char)5, (char)5}, 
        {(char)0, (char)5, (char)5}, 
        {(char)0, (char)5, (char)5}, 
        {(char)0, (char)5, (char)5}, 
        {(char)0, (char)5, (char)5}, 
        {(char)0, (char)5, (char)5}, 
        {(char)0, (char)5, (char)5}, 
        {(char)0, (char)5, (char)5}, 
        {(char)9, (char)1, (char)7}, 
        {(char)9, (char)1, (char)7}, 
        {(char)1, (char)3, (char)7}, 
        {(char)1, (char)3, (char)7}, 
        {(char)10, (char)1, (char)7}, 
        {(char)10, (char)1, (char)7}, 
        {(char)0, (char)8, (char)7}, 
        {(char)0, (char)8, (char)7}, 
        {(char)0, (char)9, (char)7}, 
        {(char)0, (char)9, (char)7}, 
        {(char)0, (char)12, (char)8}, 
        {(char)0, (char)13, (char)8}, 
        {(char)2, (char)3, (char)8}, 
        {(char)4, (char)2, (char)8}, 
        {(char)0, (char)14, (char)8}, 
        {(char)0, (char)15, (char)8}};
#line 473 "src/getvlc.h"
DCTtab DCTtab1[8]  = 
#line 473
  {      {(char)16, (char)1, (char)10}, 
        {(char)5, (char)2, (char)10}, 
        {(char)0, (char)7, (char)10}, 
        {(char)2, (char)3, (char)10}, 
        {(char)1, (char)4, (char)10}, 
        {(char)15, (char)1, (char)10}, 
        {(char)14, (char)1, (char)10}, 
        {(char)4, (char)2, (char)10}};
#line 482 "src/getvlc.h"
DCTtab DCTtab1a[8]  = 
#line 482
  {      {(char)5, (char)2, (char)9}, 
        {(char)5, (char)2, (char)9}, 
        {(char)14, (char)1, (char)9}, 
        {(char)14, (char)1, (char)9}, 
        {(char)2, (char)4, (char)10}, 
        {(char)16, (char)1, (char)10}, 
        {(char)15, (char)1, (char)9}, 
        {(char)15, (char)1, (char)9}};
#line 491 "src/getvlc.h"
DCTtab DCTtab2[16]  = 
#line 491
  {      {(char)0, (char)11, (char)12}, 
        {(char)8, (char)2, (char)12}, 
        {(char)4, (char)3, (char)12}, 
        {(char)0, (char)10, (char)12}, 
        {(char)2, (char)4, (char)12}, 
        {(char)7, (char)2, (char)12}, 
        {(char)21, (char)1, (char)12}, 
        {(char)20, (char)1, (char)12}, 
        {(char)0, (char)9, (char)12}, 
        {(char)19, (char)1, (char)12}, 
        {(char)18, (char)1, (char)12}, 
        {(char)1, (char)5, (char)12}, 
        {(char)3, (char)3, (char)12}, 
        {(char)0, (char)8, (char)12}, 
        {(char)6, (char)2, (char)12}, 
        {(char)17, (char)1, (char)12}};
#line 502 "src/getvlc.h"
DCTtab DCTtab3[16]  = 
#line 502
  {      {(char)10, (char)2, (char)13}, 
        {(char)9, (char)2, (char)13}, 
        {(char)5, (char)3, (char)13}, 
        {(char)3, (char)4, (char)13}, 
        {(char)2, (char)5, (char)13}, 
        {(char)1, (char)7, (char)13}, 
        {(char)1, (char)6, (char)13}, 
        {(char)0, (char)15, (char)13}, 
        {(char)0, (char)14, (char)13}, 
        {(char)0, (char)13, (char)13}, 
        {(char)0, (char)12, (char)13}, 
        {(char)26, (char)1, (char)13}, 
        {(char)25, (char)1, (char)13}, 
        {(char)24, (char)1, (char)13}, 
        {(char)23, (char)1, (char)13}, 
        {(char)22, (char)1, (char)13}};
#line 513 "src/getvlc.h"
DCTtab DCTtab4[16]  = 
#line 513
  {      {(char)0, (char)31, (char)14}, 
        {(char)0, (char)30, (char)14}, 
        {(char)0, (char)29, (char)14}, 
        {(char)0, (char)28, (char)14}, 
        {(char)0, (char)27, (char)14}, 
        {(char)0, (char)26, (char)14}, 
        {(char)0, (char)25, (char)14}, 
        {(char)0, (char)24, (char)14}, 
        {(char)0, (char)23, (char)14}, 
        {(char)0, (char)22, (char)14}, 
        {(char)0, (char)21, (char)14}, 
        {(char)0, (char)20, (char)14}, 
        {(char)0, (char)19, (char)14}, 
        {(char)0, (char)18, (char)14}, 
        {(char)0, (char)17, (char)14}, 
        {(char)0, (char)16, (char)14}};
#line 524 "src/getvlc.h"
DCTtab DCTtab5[16]  = 
#line 524
  {      {(char)0, (char)40, (char)15}, 
        {(char)0, (char)39, (char)15}, 
        {(char)0, (char)38, (char)15}, 
        {(char)0, (char)37, (char)15}, 
        {(char)0, (char)36, (char)15}, 
        {(char)0, (char)35, (char)15}, 
        {(char)0, (char)34, (char)15}, 
        {(char)0, (char)33, (char)15}, 
        {(char)0, (char)32, (char)15}, 
        {(char)1, (char)14, (char)15}, 
        {(char)1, (char)13, (char)15}, 
        {(char)1, (char)12, (char)15}, 
        {(char)1, (char)11, (char)15}, 
        {(char)1, (char)10, (char)15}, 
        {(char)1, (char)9, (char)15}, 
        {(char)1, (char)8, (char)15}};
#line 535 "src/getvlc.h"
DCTtab DCTtab6[16]  = 
#line 535
  {      {(char)1, (char)18, (char)16}, 
        {(char)1, (char)17, (char)16}, 
        {(char)1, (char)16, (char)16}, 
        {(char)1, (char)15, (char)16}, 
        {(char)6, (char)3, (char)16}, 
        {(char)16, (char)2, (char)16}, 
        {(char)15, (char)2, (char)16}, 
        {(char)14, (char)2, (char)16}, 
        {(char)13, (char)2, (char)16}, 
        {(char)12, (char)2, (char)16}, 
        {(char)11, (char)2, (char)16}, 
        {(char)31, (char)1, (char)16}, 
        {(char)30, (char)1, (char)16}, 
        {(char)29, (char)1, (char)16}, 
        {(char)28, (char)1, (char)16}, 
        {(char)27, (char)1, (char)16}};
#line 89 "src/getvlc.c"
static int Get_I_macroblock_type(void) ;
#line 90
static int Get_P_macroblock_type(void) ;
#line 91
static int Get_B_macroblock_type(void) ;
#line 92
static int Get_D_macroblock_type(void) ;
#line 95
static int Get_I_Spatial_macroblock_type(void) ;
#line 96
static int Get_P_Spatial_macroblock_type(void) ;
#line 97
static int Get_B_Spatial_macroblock_type(void) ;
#line 98
static int Get_SNR_macroblock_type(void) ;
#line 101
static int Thrd_Get_I_macroblock_type(int t ) ;
#line 102
static int Thrd_Get_P_macroblock_type(int t ) ;
#line 103
static int Thrd_Get_B_macroblock_type(int t ) ;
#line 104
static int Thrd_Get_D_macroblock_type(int t ) ;
#line 107 "src/getvlc.c"
int Get_macroblock_type(void) 
{ 
  int macroblock_type ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 109
  macroblock_type = 0;
#line 111
  if (ld->scalable_mode == 3) {
#line 112
    macroblock_type = Get_SNR_macroblock_type();
  } else {
#line 115
    switch (picture_coding_type) {
    case 1: 
#line 118
    if (ld->pict_scal) {
#line 118
      tmp = Get_I_Spatial_macroblock_type();
#line 118
      macroblock_type = tmp;
    } else {
#line 118
      tmp___0 = Get_I_macroblock_type();
#line 118
      macroblock_type = tmp___0;
    }
#line 119
    break;
    case 2: 
#line 121
    if (ld->pict_scal) {
#line 121
      tmp___1 = Get_P_Spatial_macroblock_type();
#line 121
      macroblock_type = tmp___1;
    } else {
#line 121
      tmp___2 = Get_P_macroblock_type();
#line 121
      macroblock_type = tmp___2;
    }
#line 122
    break;
    case 3: 
#line 124
    if (ld->pict_scal) {
#line 124
      tmp___3 = Get_B_Spatial_macroblock_type();
#line 124
      macroblock_type = tmp___3;
    } else {
#line 124
      tmp___4 = Get_B_macroblock_type();
#line 124
      macroblock_type = tmp___4;
    }
#line 125
    break;
    case 4: 
#line 127
    macroblock_type = Get_D_macroblock_type();
#line 128
    break;
    default: 
#line 130
    printf((char const   * __restrict  )"Get_macroblock_type(): unrecognized picture coding type\n");
#line 131
    break;
    }
  }
#line 135
  return (macroblock_type);
}
}
#line 138 "src/getvlc.c"
static int Get_I_macroblock_type(void) 
{ 
  unsigned int tmp ;
  unsigned int tmp___0 ;

  {
#line 145
  tmp = Get_Bits1();
#line 145
  if (tmp) {
#line 151
    return (1);
  }
#line 154
  tmp___0 = Get_Bits1();
#line 154
  if (! tmp___0) {
#line 156
    if (! Quiet_Flag) {
#line 157
      printf((char const   * __restrict  )"Invalid macroblock_type code\n");
    }
#line 158
    Fault_Flag = 1;
  }
#line 166
  return (17);
}
}
#line 182 "src/getvlc.c"
static int Get_P_macroblock_type(void) 
{ 
  int code ;
  unsigned int tmp ;

  {
#line 191
  tmp = Show_Bits(6);
#line 191
  code = (int )tmp;
#line 191
  if (code >= 8) {
#line 193
    code >>= 3;
#line 194
    Flush_Buffer((int )PMBtab0[code].len);
#line 202
    return ((int )PMBtab0[code].val);
  }
#line 205
  if (code == 0) {
#line 207
    if (! Quiet_Flag) {
#line 208
      printf((char const   * __restrict  )"Invalid macroblock_type code\n");
    }
#line 209
    Fault_Flag = 1;
#line 210
    return (0);
  }
#line 213
  Flush_Buffer((int )PMBtab1[code].len);
#line 223
  return ((int )PMBtab1[code].val);
}
}
#line 226 "src/getvlc.c"
static int Get_B_macroblock_type(void) 
{ 
  int code ;
  unsigned int tmp ;

  {
#line 235
  tmp = Show_Bits(6);
#line 235
  code = (int )tmp;
#line 235
  if (code >= 8) {
#line 237
    code >>= 2;
#line 238
    Flush_Buffer((int )BMBtab0[code].len);
#line 248
    return ((int )BMBtab0[code].val);
  }
#line 251
  if (code == 0) {
#line 253
    if (! Quiet_Flag) {
#line 254
      printf((char const   * __restrict  )"Invalid macroblock_type code\n");
    }
#line 255
    Fault_Flag = 1;
#line 256
    return (0);
  }
#line 259
  Flush_Buffer((int )BMBtab1[code].len);
#line 269
  return ((int )BMBtab1[code].val);
}
}
#line 272 "src/getvlc.c"
static int Get_D_macroblock_type(void) 
{ 
  unsigned int tmp ;

  {
#line 274
  tmp = Get_Bits1();
#line 274
  if (! tmp) {
#line 276
    if (! Quiet_Flag) {
#line 277
      printf((char const   * __restrict  )"Invalid macroblock_type code\n");
    }
#line 278
    Fault_Flag = 1;
  }
#line 281
  return (1);
}
}
#line 285 "src/getvlc.c"
static int Get_I_Spatial_macroblock_type(void) 
{ 
  int code ;
  unsigned int tmp ;

  {
#line 294
  tmp = Show_Bits(4);
#line 294
  code = (int )tmp;
#line 296
  if (code == 0) {
#line 298
    if (! Quiet_Flag) {
#line 299
      printf((char const   * __restrict  )"Invalid macroblock_type code\n");
    }
#line 300
    Fault_Flag = 1;
#line 301
    return (0);
  }
#line 312
  Flush_Buffer((int )spIMBtab[code].len);
#line 313
  return ((int )spIMBtab[code].val);
}
}
#line 316 "src/getvlc.c"
static int Get_P_Spatial_macroblock_type(void) 
{ 
  int code ;
  unsigned int tmp ;

  {
#line 325
  tmp = Show_Bits(7);
#line 325
  code = (int )tmp;
#line 327
  if (code < 2) {
#line 329
    if (! Quiet_Flag) {
#line 330
      printf((char const   * __restrict  )"Invalid macroblock_type code\n");
    }
#line 331
    Fault_Flag = 1;
#line 332
    return (0);
  }
#line 335
  if (code >= 16) {
#line 337
    code >>= 3;
#line 338
    Flush_Buffer((int )spPMBtab0[code].len);
#line 348
    return ((int )spPMBtab0[code].val);
  }
#line 351
  Flush_Buffer((int )spPMBtab1[code].len);
#line 361
  return ((int )spPMBtab1[code].val);
}
}
#line 364 "src/getvlc.c"
static int Get_B_Spatial_macroblock_type(void) 
{ 
  int code ;
  VLCtab *p ;
  unsigned int tmp ;

  {
#line 374
  tmp = Show_Bits(9);
#line 374
  code = (int )tmp;
#line 376
  if (code >= 64) {
#line 377
    p = & spBMBtab0[(code >> 5) - 2];
  } else
#line 378
  if (code >= 16) {
#line 379
    p = & spBMBtab1[(code >> 2) - 4];
  } else
#line 380
  if (code >= 8) {
#line 381
    p = & spBMBtab2[code - 8];
  } else {
#line 384
    if (! Quiet_Flag) {
#line 385
      printf((char const   * __restrict  )"Invalid macroblock_type code\n");
    }
#line 386
    Fault_Flag = 1;
#line 387
    return (0);
  }
#line 390
  Flush_Buffer((int )p->len);
#line 400
  return ((int )p->val);
}
}
#line 403 "src/getvlc.c"
static int Get_SNR_macroblock_type(void) 
{ 
  int code ;
  unsigned int tmp ;

  {
#line 412
  tmp = Show_Bits(3);
#line 412
  code = (int )tmp;
#line 414
  if (code == 0) {
#line 416
    if (! Quiet_Flag) {
#line 417
      printf((char const   * __restrict  )"Invalid macroblock_type code\n");
    }
#line 418
    Fault_Flag = 1;
#line 419
    return (0);
  }
#line 422
  Flush_Buffer((int )SNRMBtab[code].len);
#line 433
  return ((int )SNRMBtab[code].val);
}
}
#line 436 "src/getvlc.c"
int Get_motion_code(void) 
{ 
  int code ;
  unsigned int tmp ;
  int tmp___1 ;
  unsigned int tmp___2 ;
  unsigned int tmp___3 ;
  int tmp___5 ;
  unsigned int tmp___6 ;
  int tmp___8 ;
  unsigned int tmp___9 ;

  {
#line 445
  tmp = Get_Bits1();
#line 445
  if (tmp) {
#line 451
    return (0);
  }
#line 454
  tmp___3 = Show_Bits(9);
#line 454
  code = (int )tmp___3;
#line 454
  if (code >= 64) {
#line 456
    code >>= 6;
#line 457
    Flush_Buffer((int )MVtab0[code].len);
#line 468
    tmp___2 = Get_Bits1();
#line 468
    if (tmp___2) {
#line 468
      tmp___1 = - ((int )MVtab0[code].val);
    } else {
#line 468
      tmp___1 = (int )MVtab0[code].val;
    }
#line 468
    return (tmp___1);
  }
#line 471
  if (code >= 24) {
#line 473
    code >>= 3;
#line 474
    Flush_Buffer((int )MVtab1[code].len);
#line 485
    tmp___6 = Get_Bits1();
#line 485
    if (tmp___6) {
#line 485
      tmp___5 = - ((int )MVtab1[code].val);
    } else {
#line 485
      tmp___5 = (int )MVtab1[code].val;
    }
#line 485
    return (tmp___5);
  }
#line 488
  code -= 12;
#line 488
  if (code < 0) {
#line 490
    if (! Quiet_Flag) {
#line 492
      printf((char const   * __restrict  )"Invalid motion_vector code (MBA %d, pic %d)\n",
             global_MBA, global_pic);
    }
#line 493
    Fault_Flag = 1;
#line 494
    return (0);
  }
#line 497
  Flush_Buffer((int )MVtab2[code].len);
#line 508
  tmp___9 = Get_Bits1();
#line 508
  if (tmp___9) {
#line 508
    tmp___8 = - ((int )MVtab2[code].val);
  } else {
#line 508
    tmp___8 = (int )MVtab2[code].val;
  }
#line 508
  return (tmp___8);
}
}
#line 512 "src/getvlc.c"
int Get_dmvector(void) 
{ 
  int tmp___0 ;
  unsigned int tmp___1 ;
  unsigned int tmp___2 ;

  {
#line 519
  tmp___2 = Get_Bits(1);
#line 519
  if (tmp___2) {
#line 525
    tmp___1 = Get_Bits(1);
#line 525
    if (tmp___1) {
#line 525
      tmp___0 = -1;
    } else {
#line 525
      tmp___0 = 1;
    }
#line 525
    return (tmp___0);
  } else {
#line 533
    return (0);
  }
}
}
#line 537 "src/getvlc.c"
int Get_coded_block_pattern(void) 
{ 
  int code ;
  unsigned int tmp ;

  {
#line 546
  tmp = Show_Bits(9);
#line 546
  code = (int )tmp;
#line 546
  if (code >= 128) {
#line 548
    code >>= 4;
#line 549
    Flush_Buffer((int )CBPtab0[code].len);
#line 561
    return ((int )CBPtab0[code].val);
  }
#line 564
  if (code >= 8) {
#line 566
    code >>= 1;
#line 567
    Flush_Buffer((int )CBPtab1[code].len);
#line 579
    return ((int )CBPtab1[code].val);
  }
#line 582
  if (code < 1) {
#line 584
    if (! Quiet_Flag) {
#line 585
      printf((char const   * __restrict  )"Invalid coded_block_pattern code\n");
    }
#line 586
    Fault_Flag = 1;
#line 587
    return (0);
  }
#line 590
  Flush_Buffer((int )CBPtab2[code].len);
#line 602
  return ((int )CBPtab2[code].val);
}
}
#line 606 "src/getvlc.c"
int Get_macroblock_address_increment(void) 
{ 
  int code ;
  int val ;
  unsigned int tmp ;

  {
#line 615
  val = 0;
#line 617
  while (1) {
#line 617
    tmp = Show_Bits(11);
#line 617
    code = (int )tmp;
#line 617
    if (! (code < 24)) {
#line 617
      break;
    }
#line 619
    if (code != 15) {
#line 621
      if (code == 8) {
#line 628
        val += 33;
      } else {
#line 632
        if (! Quiet_Flag) {
#line 633
          printf((char const   * __restrict  )"Invalid macroblock_address_increment code\n");
        }
#line 635
        Fault_Flag = 1;
#line 636
        return (1);
      }
    }
#line 647
    Flush_Buffer(11);
  }
#line 652
  if (code >= 1024) {
#line 654
    Flush_Buffer(1);
#line 659
    return (val + 1);
  }
#line 663
  if (code >= 128) {
#line 666
    code >>= 6;
#line 667
    Flush_Buffer((int )MBAtab1[code].len);
#line 678
    return (val + (int )MBAtab1[code].val);
  }
#line 682
  code -= 24;
#line 683
  Flush_Buffer((int )MBAtab2[code].len);
#line 693
  return (val + (int )MBAtab2[code].val);
}
}
#line 706 "src/getvlc.c"
int Get_Luma_DC_dct_diff(void) 
{ 
  int code ;
  int size ;
  int dct_diff ;
  unsigned int tmp ;
  unsigned int tmp___0 ;
  unsigned int tmp___1 ;

  {
#line 718
  tmp = Show_Bits(5);
#line 718
  code = (int )tmp;
#line 720
  if (code < 31) {
#line 722
    size = (int )DClumtab0[code].val;
#line 723
    Flush_Buffer((int )DClumtab0[code].len);
  } else {
#line 736
    tmp___0 = Show_Bits(9);
#line 736
    code = (int )(tmp___0 - 496U);
#line 737
    size = (int )DClumtab1[code].val;
#line 738
    Flush_Buffer((int )DClumtab1[code].len);
  }
#line 758
  if (size == 0) {
#line 759
    dct_diff = 0;
  } else {
#line 762
    tmp___1 = Get_Bits(size);
#line 762
    dct_diff = (int )tmp___1;
#line 769
    if ((dct_diff & (1 << (size - 1))) == 0) {
#line 770
      dct_diff -= (1 << size) - 1;
    }
  }
#line 780
  return (dct_diff);
}
}
#line 784 "src/getvlc.c"
int Get_Chroma_DC_dct_diff(void) 
{ 
  int code ;
  int size ;
  int dct_diff ;
  unsigned int tmp ;
  unsigned int tmp___0 ;
  unsigned int tmp___1 ;

  {
#line 796
  tmp = Show_Bits(5);
#line 796
  code = (int )tmp;
#line 798
  if (code < 31) {
#line 800
    size = (int )DCchromtab0[code].val;
#line 801
    Flush_Buffer((int )DCchromtab0[code].len);
  } else {
#line 815
    tmp___0 = Show_Bits(10);
#line 815
    code = (int )(tmp___0 - 992U);
#line 816
    size = (int )DCchromtab1[code].val;
#line 817
    Flush_Buffer((int )DCchromtab1[code].len);
  }
#line 837
  if (size == 0) {
#line 838
    dct_diff = 0;
  } else {
#line 841
    tmp___1 = Get_Bits(size);
#line 841
    dct_diff = (int )tmp___1;
#line 848
    if ((dct_diff & (1 << (size - 1))) == 0) {
#line 849
      dct_diff -= (1 << size) - 1;
    }
  }
#line 859
  return (dct_diff);
}
}
#line 864 "src/getvlc.c"
int Thrd_Get_macroblock_type(int t ) 
{ 
  int macroblock_type ;

  {
#line 867
  macroblock_type = 0;
#line 869
  if (ld->scalable_mode == 3) {
#line 870
    printf((char const   * __restrict  )"not supported macroblock type");
#line 871
    exit(-1);
  } else
#line 869
  if (ld->pict_scal != 0) {
#line 870
    printf((char const   * __restrict  )"not supported macroblock type");
#line 871
    exit(-1);
  }
#line 873
  switch (picture_coding_type) {
  case 1: 
#line 876
  macroblock_type = Thrd_Get_I_macroblock_type(t);
#line 877
  break;
  case 2: 
#line 879
  macroblock_type = Thrd_Get_P_macroblock_type(t);
#line 880
  break;
  case 3: 
#line 882
  macroblock_type = Thrd_Get_B_macroblock_type(t);
#line 883
  break;
  case 4: 
#line 885
  macroblock_type = Thrd_Get_D_macroblock_type(t);
#line 886
  break;
  default: 
#line 888
  printf((char const   * __restrict  )"Get_macroblock_type(): unrecognized picture coding type\n");
#line 889
  break;
  }
#line 892
  return (macroblock_type);
}
}
#line 895 "src/getvlc.c"
static int Thrd_Get_I_macroblock_type(int t ) 
{ 
  unsigned int tmp ;
  unsigned int tmp___0 ;

  {
#line 898
  tmp = Thrd_Get_Bits1(t);
#line 898
  if (tmp) {
#line 900
    return (1);
  }
#line 903
  tmp___0 = Thrd_Get_Bits1(t);
#line 903
  if (! tmp___0) {
#line 905
    if (! Quiet_Flag) {
#line 906
      printf((char const   * __restrict  )"Invalid macroblock_type code\n");
    }
#line 907
    Fault_Flag = 1;
  }
#line 910
  return (17);
}
}
#line 913 "src/getvlc.c"
static int Thrd_Get_P_macroblock_type(int t ) 
{ 
  int code ;
  unsigned int tmp ;

  {
#line 918
  tmp = Thrd_Show_Bits(t, 6);
#line 918
  code = (int )tmp;
#line 918
  if (code >= 8) {
#line 920
    code >>= 3;
#line 921
    Thrd_Flush_Buffer(t, (int )PMBtab0[code].len);
#line 923
    return ((int )PMBtab0[code].val);
  }
#line 926
  if (code == 0) {
#line 928
    if (! Quiet_Flag) {
#line 929
      printf((char const   * __restrict  )"Invalid macroblock_type code\n");
    }
#line 930
    Fault_Flag = 1;
#line 931
    return (0);
  }
#line 934
  Thrd_Flush_Buffer(t, (int )PMBtab1[code].len);
#line 936
  return ((int )PMBtab1[code].val);
}
}
#line 939 "src/getvlc.c"
static int Thrd_Get_B_macroblock_type(int t ) 
{ 
  int code ;
  unsigned int tmp ;

  {
#line 944
  tmp = Thrd_Show_Bits(t, 6);
#line 944
  code = (int )tmp;
#line 944
  if (code >= 8) {
#line 946
    code >>= 2;
#line 947
    Thrd_Flush_Buffer(t, (int )BMBtab0[code].len);
#line 949
    return ((int )BMBtab0[code].val);
  }
#line 952
  if (code == 0) {
#line 954
    if (! Quiet_Flag) {
#line 955
      printf((char const   * __restrict  )"Invalid macroblock_type code\n");
    }
#line 956
    Fault_Flag = 1;
#line 957
    return (0);
  }
#line 960
  Thrd_Flush_Buffer(t, (int )BMBtab1[code].len);
#line 962
  return ((int )BMBtab1[code].val);
}
}
#line 965 "src/getvlc.c"
static int Thrd_Get_D_macroblock_type(int t ) 
{ 
  unsigned int tmp ;

  {
#line 968
  tmp = Thrd_Get_Bits1(t);
#line 968
  if (! tmp) {
#line 970
    if (! Quiet_Flag) {
#line 971
      printf((char const   * __restrict  )"Invalid macroblock_type code\n");
    }
#line 972
    Fault_Flag = 1;
  }
#line 975
  return (1);
}
}
#line 979 "src/getvlc.c"
int Thrd_Get_macroblock_address_increment(int t ) 
{ 
  int code ;
  int val ;
  unsigned int tmp ;

  {
#line 984
  val = 0;
#line 986
  while (1) {
#line 986
    tmp = Thrd_Show_Bits(t, 11);
#line 986
    code = (int )tmp;
#line 986
    if (! (code < 24)) {
#line 986
      break;
    }
#line 988
    if (code != 15) {
#line 990
      if (code == 8) {
#line 992
        val += 33;
      } else {
#line 996
        if (! Quiet_Flag) {
#line 997
          printf((char const   * __restrict  )"Invalid macroblock_address_increment code\n");
        }
#line 999
        Fault_Flag = 1;
#line 1000
        return (1);
      }
    }
#line 1004
    Thrd_Flush_Buffer(t, 11);
  }
#line 1009
  if (code >= 1024) {
#line 1011
    Thrd_Flush_Buffer(t, 1);
#line 1012
    return (val + 1);
  }
#line 1016
  if (code >= 128) {
#line 1019
    code >>= 6;
#line 1020
    Thrd_Flush_Buffer(t, (int )MBAtab1[code].len);
#line 1022
    return (val + (int )MBAtab1[code].val);
  }
#line 1026
  code -= 24;
#line 1027
  Thrd_Flush_Buffer(t, (int )MBAtab2[code].len);
#line 1029
  return (val + (int )MBAtab2[code].val);
}
}
#line 1032 "src/getvlc.c"
int Thrd_Get_motion_code(int t ) 
{ 
  int code ;
  unsigned int tmp ;
  int tmp___1 ;
  unsigned int tmp___2 ;
  unsigned int tmp___3 ;
  int tmp___5 ;
  unsigned int tmp___6 ;
  int tmp___8 ;
  unsigned int tmp___9 ;

  {
#line 1037
  tmp = Thrd_Get_Bits1(t);
#line 1037
  if (tmp) {
#line 1039
    return (0);
  }
#line 1042
  tmp___3 = Thrd_Show_Bits(t, 9);
#line 1042
  code = (int )tmp___3;
#line 1042
  if (code >= 64) {
#line 1044
    code >>= 6;
#line 1045
    Thrd_Flush_Buffer(t, (int )MVtab0[code].len);
#line 1047
    tmp___2 = Thrd_Get_Bits1(t);
#line 1047
    if (tmp___2) {
#line 1047
      tmp___1 = - ((int )MVtab0[code].val);
    } else {
#line 1047
      tmp___1 = (int )MVtab0[code].val;
    }
#line 1047
    return (tmp___1);
  }
#line 1050
  if (code >= 24) {
#line 1052
    code >>= 3;
#line 1053
    Thrd_Flush_Buffer(t, (int )MVtab1[code].len);
#line 1055
    tmp___6 = Thrd_Get_Bits1(t);
#line 1055
    if (tmp___6) {
#line 1055
      tmp___5 = - ((int )MVtab1[code].val);
    } else {
#line 1055
      tmp___5 = (int )MVtab1[code].val;
    }
#line 1055
    return (tmp___5);
  }
#line 1058
  code -= 12;
#line 1058
  if (code < 0) {
#line 1060
    if (! Quiet_Flag) {
#line 1062
      printf((char const   * __restrict  )"Invalid motion_vector code (MBA %d, pic %d)\n",
             global_MBA, global_pic);
    }
#line 1063
    Fault_Flag = 1;
#line 1064
    return (0);
  }
#line 1067
  Thrd_Flush_Buffer(t, (int )MVtab2[code].len);
#line 1069
  tmp___9 = Thrd_Get_Bits1(t);
#line 1069
  if (tmp___9) {
#line 1069
    tmp___8 = - ((int )MVtab2[code].val);
  } else {
#line 1069
    tmp___8 = (int )MVtab2[code].val;
  }
#line 1069
  return (tmp___8);
}
}
#line 1073 "src/getvlc.c"
int Thrd_Get_dmvector(int t ) 
{ 
  int tmp___0 ;
  unsigned int tmp___1 ;
  unsigned int tmp___2 ;

  {
#line 1076
  tmp___2 = Thrd_Get_Bits(t, 1);
#line 1076
  if (tmp___2) {
#line 1078
    tmp___1 = Thrd_Get_Bits(t, 1);
#line 1078
    if (tmp___1) {
#line 1078
      tmp___0 = -1;
    } else {
#line 1078
      tmp___0 = 1;
    }
#line 1078
    return (tmp___0);
  } else {
#line 1082
    return (0);
  }
}
}
#line 1086 "src/getvlc.c"
int Thrd_Get_coded_block_pattern(int t ) 
{ 
  int code ;
  unsigned int tmp ;

  {
#line 1091
  tmp = Thrd_Show_Bits(t, 9);
#line 1091
  code = (int )tmp;
#line 1091
  if (code >= 128) {
#line 1093
    code >>= 4;
#line 1094
    Thrd_Flush_Buffer(t, (int )CBPtab0[code].len);
#line 1096
    return ((int )CBPtab0[code].val);
  }
#line 1099
  if (code >= 8) {
#line 1101
    code >>= 1;
#line 1102
    Thrd_Flush_Buffer(t, (int )CBPtab1[code].len);
#line 1104
    return ((int )CBPtab1[code].val);
  }
#line 1107
  if (code < 1) {
#line 1109
    if (! Quiet_Flag) {
#line 1110
      printf((char const   * __restrict  )"Invalid coded_block_pattern code\n");
    }
#line 1111
    Fault_Flag = 1;
#line 1112
    return (0);
  }
#line 1115
  Thrd_Flush_Buffer(t, (int )CBPtab2[code].len);
#line 1117
  return ((int )CBPtab2[code].val);
}
}
#line 1120 "src/getvlc.c"
int Thrd_Get_Luma_DC_dct_diff(int t ) 
{ 
  int code ;
  int size ;
  int dct_diff ;
  unsigned int tmp ;
  unsigned int tmp___0 ;
  unsigned int tmp___1 ;

  {
#line 1126
  tmp = Thrd_Show_Bits(t, 5);
#line 1126
  code = (int )tmp;
#line 1128
  if (code < 31) {
#line 1130
    size = (int )DClumtab0[code].val;
#line 1131
    Thrd_Flush_Buffer(t, (int )DClumtab0[code].len);
  } else {
#line 1135
    tmp___0 = Thrd_Show_Bits(t, 9);
#line 1135
    code = (int )(tmp___0 - 496U);
#line 1136
    size = (int )DClumtab1[code].val;
#line 1137
    Thrd_Flush_Buffer(t, (int )DClumtab1[code].len);
  }
#line 1140
  if (size == 0) {
#line 1141
    dct_diff = 0;
  } else {
#line 1144
    tmp___1 = Thrd_Get_Bits(t, size);
#line 1144
    dct_diff = (int )tmp___1;
#line 1146
    if ((dct_diff & (1 << (size - 1))) == 0) {
#line 1147
      dct_diff -= (1 << size) - 1;
    }
  }
#line 1150
  return (dct_diff);
}
}
#line 1154 "src/getvlc.c"
int Thrd_Get_Chroma_DC_dct_diff(int t ) 
{ 
  int code ;
  int size ;
  int dct_diff ;
  unsigned int tmp ;
  unsigned int tmp___0 ;
  unsigned int tmp___1 ;

  {
#line 1160
  tmp = Thrd_Show_Bits(t, 5);
#line 1160
  code = (int )tmp;
#line 1162
  if (code < 31) {
#line 1164
    size = (int )DCchromtab0[code].val;
#line 1165
    Thrd_Flush_Buffer(t, (int )DCchromtab0[code].len);
  } else {
#line 1169
    tmp___0 = Thrd_Show_Bits(t, 10);
#line 1169
    code = (int )(tmp___0 - 992U);
#line 1170
    size = (int )DCchromtab1[code].val;
#line 1171
    Thrd_Flush_Buffer(t, (int )DCchromtab1[code].len);
  }
#line 1174
  if (size == 0) {
#line 1175
    dct_diff = 0;
  } else {
#line 1178
    tmp___1 = Thrd_Get_Bits(t, size);
#line 1178
    dct_diff = (int )tmp___1;
#line 1180
    if ((dct_diff & (1 << (size - 1))) == 0) {
#line 1181
      dct_diff -= (1 << size) - 1;
    }
  }
#line 1184
  return (dct_diff);
}
}
#line 1 "idct.o"
#pragma merger("0","/tmp/cil-mRCL_Wk7.i","-g,-O4")
#line 350 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h"
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__, __always_inline__)) __signbit)(double __x )  __attribute__((__const__)) ;
#line 350
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__, __always_inline__)) __signbitf)(float __x )  __attribute__((__const__)) ;
#line 350
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__, __always_inline__)) __signbitl)(long double __x )  __attribute__((__const__)) ;
#line 126 "/usr/include/x86_64-linux-gnu/bits/mathinline.h"
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__, __always_inline__)) __signbitf)(float __x )  __attribute__((__const__)) ;
#line 126 "/usr/include/x86_64-linux-gnu/bits/mathinline.h"
__inline extern int ( __attribute__((__leaf__, __always_inline__)) __signbitf)(float __x ) 
{ 
  int __m ;

  {
#line 131
  __asm__  ("pmovmskb %1, %0": "=r" (__m): "x" (__x));
#line 132
  return ((__m & 8) != 0);
}
}
#line 138
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__, __always_inline__)) __signbit)(double __x )  __attribute__((__const__)) ;
#line 138 "/usr/include/x86_64-linux-gnu/bits/mathinline.h"
__inline extern int ( __attribute__((__leaf__, __always_inline__)) __signbit)(double __x ) 
{ 
  int __m ;

  {
#line 143
  __asm__  ("pmovmskb %1, %0": "=r" (__m): "x" (__x));
#line 144
  return ((__m & 128) != 0);
}
}
#line 150
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__, __always_inline__)) __signbitl)(long double __x )  __attribute__((__const__)) ;
#line 150 "/usr/include/x86_64-linux-gnu/bits/mathinline.h"
__inline extern int ( __attribute__((__leaf__, __always_inline__)) __signbitl)(long double __x ) 
{ 
  union __anonunion___u_3 __u ;

  {
#line 153
  __u.__l = __x;
#line 154
  return ((__u.__i[2] & 32768) != 0);
}
}
#line 159 "src/global.h"
void Initialize_Fast_IDCT(void) ;
#line 145 "src/idct.c"
short ic[8][8]  ;
#line 290 "src/idct.c"
short const   RND_INV_ROW  =    (short const   )2048;
#line 292 "src/idct.c"
short const   RND_INV_CORR  =    (short const   )15;
#line 574 "src/idct.c"
short tab_i_04[32]  = 
#line 574
  {      (short)16384,      (short)21407,      (short)16384,      (short)8867, 
        (short)16384,      (short)8867,      (short)-16384,      (short)-21407, 
        (short)16384,      (short)-8867,      (short)-16384,      (short)21407, 
        (short)16384,      (short)-21407,      (short)16384,      (short)-8867, 
        (short)22725,      (short)19266,      (short)12873,      (short)4520, 
        (short)19266,      (short)-4520,      (short)-22725,      (short)-12873, 
        (short)12873,      (short)-22725,      (short)4520,      (short)19266, 
        (short)4520,      (short)-12873,      (short)19266,      (short)-22725};
#line 588 "src/idct.c"
short tab_i_17[32]  = 
#line 588
  {      (short)22725,      (short)29692,      (short)22725,      (short)12299, 
        (short)22725,      (short)12299,      (short)-22725,      (short)-29692, 
        (short)22725,      (short)-12299,      (short)-22725,      (short)29692, 
        (short)22725,      (short)-29692,      (short)22725,      (short)-12299, 
        (short)31521,      (short)26722,      (short)17855,      (short)6270, 
        (short)26722,      (short)-6270,      (short)-31521,      (short)-17855, 
        (short)17855,      (short)-31521,      (short)6270,      (short)26722, 
        (short)6270,      (short)-17855,      (short)26722,      (short)-31521};
#line 602 "src/idct.c"
short tab_i_26[32]  = 
#line 602
  {      (short)21407,      (short)27969,      (short)21407,      (short)11585, 
        (short)21407,      (short)11585,      (short)-21407,      (short)-27969, 
        (short)21407,      (short)-11585,      (short)-21407,      (short)27969, 
        (short)21407,      (short)-27969,      (short)21407,      (short)-11585, 
        (short)29692,      (short)25172,      (short)16819,      (short)5906, 
        (short)25172,      (short)-5906,      (short)-29692,      (short)-16819, 
        (short)16819,      (short)-29692,      (short)5906,      (short)25172, 
        (short)5906,      (short)-16819,      (short)25172,      (short)-29692};
#line 616 "src/idct.c"
short tab_i_35[32]  = 
#line 616
  {      (short)19266,      (short)25172,      (short)19266,      (short)10426, 
        (short)19266,      (short)10426,      (short)-19266,      (short)-25172, 
        (short)19266,      (short)-10426,      (short)-19266,      (short)25172, 
        (short)19266,      (short)-25172,      (short)19266,      (short)-10426, 
        (short)26722,      (short)22654,      (short)15137,      (short)5315, 
        (short)22654,      (short)-5315,      (short)-26722,      (short)-15137, 
        (short)15137,      (short)-26722,      (short)5315,      (short)22654, 
        (short)5315,      (short)-15137,      (short)22654,      (short)-26722};
#line 750 "src/idct.c"
static void idct_M128ASM_scalar(short *src ) 
{ 
  int a0 ;
  int a1 ;
  int a2 ;
  int a3 ;
  int b0 ;
  int b1 ;
  int b2 ;
  int b3 ;
  int a0___0 ;
  int a1___0 ;
  int a2___0 ;
  int a3___0 ;
  int b0___0 ;
  int b1___0 ;
  int b2___0 ;
  int b3___0 ;
  int a0___1 ;
  int a1___1 ;
  int a2___1 ;
  int a3___1 ;
  int b0___1 ;
  int b1___1 ;
  int b2___1 ;
  int b3___1 ;
  int a0___2 ;
  int a1___2 ;
  int a2___2 ;
  int a3___2 ;
  int b0___2 ;
  int b1___2 ;
  int b2___2 ;
  int b3___2 ;
  int a0___3 ;
  int a1___3 ;
  int a2___3 ;
  int a3___3 ;
  int b0___3 ;
  int b1___3 ;
  int b2___3 ;
  int b3___3 ;
  int a0___4 ;
  int a1___4 ;
  int a2___4 ;
  int a3___4 ;
  int b0___4 ;
  int b1___4 ;
  int b2___4 ;
  int b3___4 ;
  int a0___5 ;
  int a1___5 ;
  int a2___5 ;
  int a3___5 ;
  int b0___5 ;
  int b1___5 ;
  int b2___5 ;
  int b3___5 ;
  int a0___6 ;
  int a1___6 ;
  int a2___6 ;
  int a3___6 ;
  int b0___6 ;
  int b1___6 ;
  int b2___6 ;
  int b3___6 ;
  int t0 ;
  int t1 ;
  int t2 ;
  int t3 ;
  int t4 ;
  int t5 ;
  int t6 ;
  int t7 ;
  int tp03 ;
  int tm03 ;
  int tp12 ;
  int tm12 ;
  int tp65 ;
  int tm65 ;
  int tp465 ;
  int tm465 ;
  int tp765 ;
  int tm765 ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int t0___0 ;
  int t1___0 ;
  int t2___0 ;
  int t3___0 ;
  int t4___0 ;
  int t5___0 ;
  int t6___0 ;
  int t7___0 ;
  int tp03___0 ;
  int tm03___0 ;
  int tp12___0 ;
  int tm12___0 ;
  int tp65___0 ;
  int tm65___0 ;
  int tp465___0 ;
  int tm465___0 ;
  int tp765___0 ;
  int tm765___0 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;
  int tmp___25 ;
  int tmp___26 ;
  int tmp___27 ;
  int tmp___28 ;
  int tmp___29 ;
  int tmp___30 ;
  int t0___1 ;
  int t1___1 ;
  int t2___1 ;
  int t3___1 ;
  int t4___1 ;
  int t5___1 ;
  int t6___1 ;
  int t7___1 ;
  int tp03___1 ;
  int tm03___1 ;
  int tp12___1 ;
  int tm12___1 ;
  int tp65___1 ;
  int tm65___1 ;
  int tp465___1 ;
  int tm465___1 ;
  int tp765___1 ;
  int tm765___1 ;
  int tmp___31 ;
  int tmp___32 ;
  int tmp___33 ;
  int tmp___34 ;
  int tmp___35 ;
  int tmp___36 ;
  int tmp___37 ;
  int tmp___38 ;
  int tmp___39 ;
  int tmp___40 ;
  int tmp___41 ;
  int tmp___42 ;
  int tmp___43 ;
  int tmp___44 ;
  int tmp___45 ;
  int tmp___46 ;
  int t0___2 ;
  int t1___2 ;
  int t2___2 ;
  int t3___2 ;
  int t4___2 ;
  int t5___2 ;
  int t6___2 ;
  int t7___2 ;
  int tp03___2 ;
  int tm03___2 ;
  int tp12___2 ;
  int tm12___2 ;
  int tp65___2 ;
  int tm65___2 ;
  int tp465___2 ;
  int tm465___2 ;
  int tp765___2 ;
  int tm765___2 ;
  int tmp___47 ;
  int tmp___48 ;
  int tmp___49 ;
  int tmp___50 ;
  int tmp___51 ;
  int tmp___52 ;
  int tmp___53 ;
  int tmp___54 ;
  int tmp___55 ;
  int tmp___56 ;
  int tmp___57 ;
  int tmp___58 ;
  int tmp___59 ;
  int tmp___60 ;
  int tmp___61 ;
  int tmp___62 ;
  int t0___3 ;
  int t1___3 ;
  int t2___3 ;
  int t3___3 ;
  int t4___3 ;
  int t5___3 ;
  int t6___3 ;
  int t7___3 ;
  int tp03___3 ;
  int tm03___3 ;
  int tp12___3 ;
  int tm12___3 ;
  int tp65___3 ;
  int tm65___3 ;
  int tp465___3 ;
  int tm465___3 ;
  int tp765___3 ;
  int tm765___3 ;
  int tmp___63 ;
  int tmp___64 ;
  int tmp___65 ;
  int tmp___66 ;
  int tmp___67 ;
  int tmp___68 ;
  int tmp___69 ;
  int tmp___70 ;
  int tmp___71 ;
  int tmp___72 ;
  int tmp___73 ;
  int tmp___74 ;
  int tmp___75 ;
  int tmp___76 ;
  int tmp___77 ;
  int tmp___78 ;
  int t0___4 ;
  int t1___4 ;
  int t2___4 ;
  int t3___4 ;
  int t4___4 ;
  int t5___4 ;
  int t6___4 ;
  int t7___4 ;
  int tp03___4 ;
  int tm03___4 ;
  int tp12___4 ;
  int tm12___4 ;
  int tp65___4 ;
  int tm65___4 ;
  int tp465___4 ;
  int tm465___4 ;
  int tp765___4 ;
  int tm765___4 ;
  int tmp___79 ;
  int tmp___80 ;
  int tmp___81 ;
  int tmp___82 ;
  int tmp___83 ;
  int tmp___84 ;
  int tmp___85 ;
  int tmp___86 ;
  int tmp___87 ;
  int tmp___88 ;
  int tmp___89 ;
  int tmp___90 ;
  int tmp___91 ;
  int tmp___92 ;
  int tmp___93 ;
  int tmp___94 ;
  int t0___5 ;
  int t1___5 ;
  int t2___5 ;
  int t3___5 ;
  int t4___5 ;
  int t5___5 ;
  int t6___5 ;
  int t7___5 ;
  int tp03___5 ;
  int tm03___5 ;
  int tp12___5 ;
  int tm12___5 ;
  int tp65___5 ;
  int tm65___5 ;
  int tp465___5 ;
  int tm465___5 ;
  int tp765___5 ;
  int tm765___5 ;
  int tmp___95 ;
  int tmp___96 ;
  int tmp___97 ;
  int tmp___98 ;
  int tmp___99 ;
  int tmp___100 ;
  int tmp___101 ;
  int tmp___102 ;
  int tmp___103 ;
  int tmp___104 ;
  int tmp___105 ;
  int tmp___106 ;
  int tmp___107 ;
  int tmp___108 ;
  int tmp___109 ;
  int tmp___110 ;
  int t0___6 ;
  int t1___6 ;
  int t2___6 ;
  int t3___6 ;
  int t4___6 ;
  int t5___6 ;
  int t6___6 ;
  int t7___6 ;
  int tp03___6 ;
  int tm03___6 ;
  int tp12___6 ;
  int tm12___6 ;
  int tp65___6 ;
  int tm65___6 ;
  int tp465___6 ;
  int tm465___6 ;
  int tp765___6 ;
  int tm765___6 ;
  int tmp___111 ;
  int tmp___112 ;
  int tmp___113 ;
  int tmp___114 ;
  int tmp___115 ;
  int tmp___116 ;
  int tmp___117 ;
  int tmp___118 ;
  int tmp___119 ;
  int tmp___120 ;
  int tmp___121 ;
  int tmp___122 ;
  int tmp___123 ;
  int tmp___124 ;
  int tmp___125 ;
  int tmp___126 ;

  {
#line 753
  a0 = (((int )*(src + 0) * (int )tab_i_04[0] + (int )*(src + 2) * (int )tab_i_04[1]) + (int )*(src + 4) * (int )tab_i_04[2]) + (int )*(src + 6) * (int )tab_i_04[3];
#line 753
  a1 = (((int )*(src + 0) * (int )tab_i_04[4] + (int )*(src + 2) * (int )tab_i_04[5]) + (int )*(src + 4) * (int )tab_i_04[6]) + (int )*(src + 6) * (int )tab_i_04[7];
#line 753
  a2 = (((int )*(src + 0) * (int )tab_i_04[8] + (int )*(src + 2) * (int )tab_i_04[9]) + (int )*(src + 4) * (int )tab_i_04[10]) + (int )*(src + 6) * (int )tab_i_04[11];
#line 753
  a3 = (((int )*(src + 0) * (int )tab_i_04[12] + (int )*(src + 2) * (int )tab_i_04[13]) + (int )*(src + 4) * (int )tab_i_04[14]) + (int )*(src + 6) * (int )tab_i_04[15];
#line 753
  b0 = (((int )*(src + 1) * (int )tab_i_04[16] + (int )*(src + 3) * (int )tab_i_04[17]) + (int )*(src + 5) * (int )tab_i_04[18]) + (int )*(src + 7) * (int )tab_i_04[19];
#line 753
  b1 = (((int )*(src + 1) * (int )tab_i_04[20] + (int )*(src + 3) * (int )tab_i_04[21]) + (int )*(src + 5) * (int )tab_i_04[22]) + (int )*(src + 7) * (int )tab_i_04[23];
#line 753
  b2 = (((int )*(src + 1) * (int )tab_i_04[24] + (int )*(src + 3) * (int )tab_i_04[25]) + (int )*(src + 5) * (int )tab_i_04[26]) + (int )*(src + 7) * (int )tab_i_04[27];
#line 753
  b3 = (((int )*(src + 1) * (int )tab_i_04[28] + (int )*(src + 3) * (int )tab_i_04[29]) + (int )*(src + 5) * (int )tab_i_04[30]) + (int )*(src + 7) * (int )tab_i_04[31];
#line 753
  *(src + 0) = (short )(((a0 + b0) + (int )RND_INV_ROW) >> 12);
#line 753
  *(src + 1) = (short )(((a1 + b1) + (int )RND_INV_ROW) >> 12);
#line 753
  *(src + 2) = (short )(((a2 + b2) + (int )RND_INV_ROW) >> 12);
#line 753
  *(src + 3) = (short )(((a3 + b3) + (int )RND_INV_ROW) >> 12);
#line 753
  *(src + 4) = (short )(((a3 - b3) + (int )RND_INV_ROW) >> 12);
#line 753
  *(src + 5) = (short )(((a2 - b2) + (int )RND_INV_ROW) >> 12);
#line 753
  *(src + 6) = (short )(((a1 - b1) + (int )RND_INV_ROW) >> 12);
#line 753
  *(src + 7) = (short )(((a0 - b0) + (int )RND_INV_ROW) >> 12);
#line 754
  a0___0 = (((int )*((src + 32) + 0) * (int )tab_i_04[0] + (int )*((src + 32) + 2) * (int )tab_i_04[1]) + (int )*((src + 32) + 4) * (int )tab_i_04[2]) + (int )*((src + 32) + 6) * (int )tab_i_04[3];
#line 754
  a1___0 = (((int )*((src + 32) + 0) * (int )tab_i_04[4] + (int )*((src + 32) + 2) * (int )tab_i_04[5]) + (int )*((src + 32) + 4) * (int )tab_i_04[6]) + (int )*((src + 32) + 6) * (int )tab_i_04[7];
#line 754
  a2___0 = (((int )*((src + 32) + 0) * (int )tab_i_04[8] + (int )*((src + 32) + 2) * (int )tab_i_04[9]) + (int )*((src + 32) + 4) * (int )tab_i_04[10]) + (int )*((src + 32) + 6) * (int )tab_i_04[11];
#line 754
  a3___0 = (((int )*((src + 32) + 0) * (int )tab_i_04[12] + (int )*((src + 32) + 2) * (int )tab_i_04[13]) + (int )*((src + 32) + 4) * (int )tab_i_04[14]) + (int )*((src + 32) + 6) * (int )tab_i_04[15];
#line 754
  b0___0 = (((int )*((src + 32) + 1) * (int )tab_i_04[16] + (int )*((src + 32) + 3) * (int )tab_i_04[17]) + (int )*((src + 32) + 5) * (int )tab_i_04[18]) + (int )*((src + 32) + 7) * (int )tab_i_04[19];
#line 754
  b1___0 = (((int )*((src + 32) + 1) * (int )tab_i_04[20] + (int )*((src + 32) + 3) * (int )tab_i_04[21]) + (int )*((src + 32) + 5) * (int )tab_i_04[22]) + (int )*((src + 32) + 7) * (int )tab_i_04[23];
#line 754
  b2___0 = (((int )*((src + 32) + 1) * (int )tab_i_04[24] + (int )*((src + 32) + 3) * (int )tab_i_04[25]) + (int )*((src + 32) + 5) * (int )tab_i_04[26]) + (int )*((src + 32) + 7) * (int )tab_i_04[27];
#line 754
  b3___0 = (((int )*((src + 32) + 1) * (int )tab_i_04[28] + (int )*((src + 32) + 3) * (int )tab_i_04[29]) + (int )*((src + 32) + 5) * (int )tab_i_04[30]) + (int )*((src + 32) + 7) * (int )tab_i_04[31];
#line 754
  *((src + 32) + 0) = (short )(((a0___0 + b0___0) + (int )RND_INV_ROW) >> 12);
#line 754
  *((src + 32) + 1) = (short )(((a1___0 + b1___0) + (int )RND_INV_ROW) >> 12);
#line 754
  *((src + 32) + 2) = (short )(((a2___0 + b2___0) + (int )RND_INV_ROW) >> 12);
#line 754
  *((src + 32) + 3) = (short )(((a3___0 + b3___0) + (int )RND_INV_ROW) >> 12);
#line 754
  *((src + 32) + 4) = (short )(((a3___0 - b3___0) + (int )RND_INV_ROW) >> 12);
#line 754
  *((src + 32) + 5) = (short )(((a2___0 - b2___0) + (int )RND_INV_ROW) >> 12);
#line 754
  *((src + 32) + 6) = (short )(((a1___0 - b1___0) + (int )RND_INV_ROW) >> 12);
#line 754
  *((src + 32) + 7) = (short )(((a0___0 - b0___0) + (int )RND_INV_ROW) >> 12);
#line 756
  a0___1 = (((int )*((src + 8) + 0) * (int )tab_i_17[0] + (int )*((src + 8) + 2) * (int )tab_i_17[1]) + (int )*((src + 8) + 4) * (int )tab_i_17[2]) + (int )*((src + 8) + 6) * (int )tab_i_17[3];
#line 756
  a1___1 = (((int )*((src + 8) + 0) * (int )tab_i_17[4] + (int )*((src + 8) + 2) * (int )tab_i_17[5]) + (int )*((src + 8) + 4) * (int )tab_i_17[6]) + (int )*((src + 8) + 6) * (int )tab_i_17[7];
#line 756
  a2___1 = (((int )*((src + 8) + 0) * (int )tab_i_17[8] + (int )*((src + 8) + 2) * (int )tab_i_17[9]) + (int )*((src + 8) + 4) * (int )tab_i_17[10]) + (int )*((src + 8) + 6) * (int )tab_i_17[11];
#line 756
  a3___1 = (((int )*((src + 8) + 0) * (int )tab_i_17[12] + (int )*((src + 8) + 2) * (int )tab_i_17[13]) + (int )*((src + 8) + 4) * (int )tab_i_17[14]) + (int )*((src + 8) + 6) * (int )tab_i_17[15];
#line 756
  b0___1 = (((int )*((src + 8) + 1) * (int )tab_i_17[16] + (int )*((src + 8) + 3) * (int )tab_i_17[17]) + (int )*((src + 8) + 5) * (int )tab_i_17[18]) + (int )*((src + 8) + 7) * (int )tab_i_17[19];
#line 756
  b1___1 = (((int )*((src + 8) + 1) * (int )tab_i_17[20] + (int )*((src + 8) + 3) * (int )tab_i_17[21]) + (int )*((src + 8) + 5) * (int )tab_i_17[22]) + (int )*((src + 8) + 7) * (int )tab_i_17[23];
#line 756
  b2___1 = (((int )*((src + 8) + 1) * (int )tab_i_17[24] + (int )*((src + 8) + 3) * (int )tab_i_17[25]) + (int )*((src + 8) + 5) * (int )tab_i_17[26]) + (int )*((src + 8) + 7) * (int )tab_i_17[27];
#line 756
  b3___1 = (((int )*((src + 8) + 1) * (int )tab_i_17[28] + (int )*((src + 8) + 3) * (int )tab_i_17[29]) + (int )*((src + 8) + 5) * (int )tab_i_17[30]) + (int )*((src + 8) + 7) * (int )tab_i_17[31];
#line 756
  *((src + 8) + 0) = (short )(((a0___1 + b0___1) + (int )RND_INV_ROW) >> 12);
#line 756
  *((src + 8) + 1) = (short )(((a1___1 + b1___1) + (int )RND_INV_ROW) >> 12);
#line 756
  *((src + 8) + 2) = (short )(((a2___1 + b2___1) + (int )RND_INV_ROW) >> 12);
#line 756
  *((src + 8) + 3) = (short )(((a3___1 + b3___1) + (int )RND_INV_ROW) >> 12);
#line 756
  *((src + 8) + 4) = (short )(((a3___1 - b3___1) + (int )RND_INV_ROW) >> 12);
#line 756
  *((src + 8) + 5) = (short )(((a2___1 - b2___1) + (int )RND_INV_ROW) >> 12);
#line 756
  *((src + 8) + 6) = (short )(((a1___1 - b1___1) + (int )RND_INV_ROW) >> 12);
#line 756
  *((src + 8) + 7) = (short )(((a0___1 - b0___1) + (int )RND_INV_ROW) >> 12);
#line 757
  a0___2 = (((int )*((src + 56) + 0) * (int )tab_i_17[0] + (int )*((src + 56) + 2) * (int )tab_i_17[1]) + (int )*((src + 56) + 4) * (int )tab_i_17[2]) + (int )*((src + 56) + 6) * (int )tab_i_17[3];
#line 757
  a1___2 = (((int )*((src + 56) + 0) * (int )tab_i_17[4] + (int )*((src + 56) + 2) * (int )tab_i_17[5]) + (int )*((src + 56) + 4) * (int )tab_i_17[6]) + (int )*((src + 56) + 6) * (int )tab_i_17[7];
#line 757
  a2___2 = (((int )*((src + 56) + 0) * (int )tab_i_17[8] + (int )*((src + 56) + 2) * (int )tab_i_17[9]) + (int )*((src + 56) + 4) * (int )tab_i_17[10]) + (int )*((src + 56) + 6) * (int )tab_i_17[11];
#line 757
  a3___2 = (((int )*((src + 56) + 0) * (int )tab_i_17[12] + (int )*((src + 56) + 2) * (int )tab_i_17[13]) + (int )*((src + 56) + 4) * (int )tab_i_17[14]) + (int )*((src + 56) + 6) * (int )tab_i_17[15];
#line 757
  b0___2 = (((int )*((src + 56) + 1) * (int )tab_i_17[16] + (int )*((src + 56) + 3) * (int )tab_i_17[17]) + (int )*((src + 56) + 5) * (int )tab_i_17[18]) + (int )*((src + 56) + 7) * (int )tab_i_17[19];
#line 757
  b1___2 = (((int )*((src + 56) + 1) * (int )tab_i_17[20] + (int )*((src + 56) + 3) * (int )tab_i_17[21]) + (int )*((src + 56) + 5) * (int )tab_i_17[22]) + (int )*((src + 56) + 7) * (int )tab_i_17[23];
#line 757
  b2___2 = (((int )*((src + 56) + 1) * (int )tab_i_17[24] + (int )*((src + 56) + 3) * (int )tab_i_17[25]) + (int )*((src + 56) + 5) * (int )tab_i_17[26]) + (int )*((src + 56) + 7) * (int )tab_i_17[27];
#line 757
  b3___2 = (((int )*((src + 56) + 1) * (int )tab_i_17[28] + (int )*((src + 56) + 3) * (int )tab_i_17[29]) + (int )*((src + 56) + 5) * (int )tab_i_17[30]) + (int )*((src + 56) + 7) * (int )tab_i_17[31];
#line 757
  *((src + 56) + 0) = (short )(((a0___2 + b0___2) + (int )RND_INV_ROW) >> 12);
#line 757
  *((src + 56) + 1) = (short )(((a1___2 + b1___2) + (int )RND_INV_ROW) >> 12);
#line 757
  *((src + 56) + 2) = (short )(((a2___2 + b2___2) + (int )RND_INV_ROW) >> 12);
#line 757
  *((src + 56) + 3) = (short )(((a3___2 + b3___2) + (int )RND_INV_ROW) >> 12);
#line 757
  *((src + 56) + 4) = (short )(((a3___2 - b3___2) + (int )RND_INV_ROW) >> 12);
#line 757
  *((src + 56) + 5) = (short )(((a2___2 - b2___2) + (int )RND_INV_ROW) >> 12);
#line 757
  *((src + 56) + 6) = (short )(((a1___2 - b1___2) + (int )RND_INV_ROW) >> 12);
#line 757
  *((src + 56) + 7) = (short )(((a0___2 - b0___2) + (int )RND_INV_ROW) >> 12);
#line 759
  a0___3 = (((int )*((src + 16) + 0) * (int )tab_i_26[0] + (int )*((src + 16) + 2) * (int )tab_i_26[1]) + (int )*((src + 16) + 4) * (int )tab_i_26[2]) + (int )*((src + 16) + 6) * (int )tab_i_26[3];
#line 759
  a1___3 = (((int )*((src + 16) + 0) * (int )tab_i_26[4] + (int )*((src + 16) + 2) * (int )tab_i_26[5]) + (int )*((src + 16) + 4) * (int )tab_i_26[6]) + (int )*((src + 16) + 6) * (int )tab_i_26[7];
#line 759
  a2___3 = (((int )*((src + 16) + 0) * (int )tab_i_26[8] + (int )*((src + 16) + 2) * (int )tab_i_26[9]) + (int )*((src + 16) + 4) * (int )tab_i_26[10]) + (int )*((src + 16) + 6) * (int )tab_i_26[11];
#line 759
  a3___3 = (((int )*((src + 16) + 0) * (int )tab_i_26[12] + (int )*((src + 16) + 2) * (int )tab_i_26[13]) + (int )*((src + 16) + 4) * (int )tab_i_26[14]) + (int )*((src + 16) + 6) * (int )tab_i_26[15];
#line 759
  b0___3 = (((int )*((src + 16) + 1) * (int )tab_i_26[16] + (int )*((src + 16) + 3) * (int )tab_i_26[17]) + (int )*((src + 16) + 5) * (int )tab_i_26[18]) + (int )*((src + 16) + 7) * (int )tab_i_26[19];
#line 759
  b1___3 = (((int )*((src + 16) + 1) * (int )tab_i_26[20] + (int )*((src + 16) + 3) * (int )tab_i_26[21]) + (int )*((src + 16) + 5) * (int )tab_i_26[22]) + (int )*((src + 16) + 7) * (int )tab_i_26[23];
#line 759
  b2___3 = (((int )*((src + 16) + 1) * (int )tab_i_26[24] + (int )*((src + 16) + 3) * (int )tab_i_26[25]) + (int )*((src + 16) + 5) * (int )tab_i_26[26]) + (int )*((src + 16) + 7) * (int )tab_i_26[27];
#line 759
  b3___3 = (((int )*((src + 16) + 1) * (int )tab_i_26[28] + (int )*((src + 16) + 3) * (int )tab_i_26[29]) + (int )*((src + 16) + 5) * (int )tab_i_26[30]) + (int )*((src + 16) + 7) * (int )tab_i_26[31];
#line 759
  *((src + 16) + 0) = (short )(((a0___3 + b0___3) + (int )RND_INV_ROW) >> 12);
#line 759
  *((src + 16) + 1) = (short )(((a1___3 + b1___3) + (int )RND_INV_ROW) >> 12);
#line 759
  *((src + 16) + 2) = (short )(((a2___3 + b2___3) + (int )RND_INV_ROW) >> 12);
#line 759
  *((src + 16) + 3) = (short )(((a3___3 + b3___3) + (int )RND_INV_ROW) >> 12);
#line 759
  *((src + 16) + 4) = (short )(((a3___3 - b3___3) + (int )RND_INV_ROW) >> 12);
#line 759
  *((src + 16) + 5) = (short )(((a2___3 - b2___3) + (int )RND_INV_ROW) >> 12);
#line 759
  *((src + 16) + 6) = (short )(((a1___3 - b1___3) + (int )RND_INV_ROW) >> 12);
#line 759
  *((src + 16) + 7) = (short )(((a0___3 - b0___3) + (int )RND_INV_ROW) >> 12);
#line 760
  a0___4 = (((int )*((src + 48) + 0) * (int )tab_i_26[0] + (int )*((src + 48) + 2) * (int )tab_i_26[1]) + (int )*((src + 48) + 4) * (int )tab_i_26[2]) + (int )*((src + 48) + 6) * (int )tab_i_26[3];
#line 760
  a1___4 = (((int )*((src + 48) + 0) * (int )tab_i_26[4] + (int )*((src + 48) + 2) * (int )tab_i_26[5]) + (int )*((src + 48) + 4) * (int )tab_i_26[6]) + (int )*((src + 48) + 6) * (int )tab_i_26[7];
#line 760
  a2___4 = (((int )*((src + 48) + 0) * (int )tab_i_26[8] + (int )*((src + 48) + 2) * (int )tab_i_26[9]) + (int )*((src + 48) + 4) * (int )tab_i_26[10]) + (int )*((src + 48) + 6) * (int )tab_i_26[11];
#line 760
  a3___4 = (((int )*((src + 48) + 0) * (int )tab_i_26[12] + (int )*((src + 48) + 2) * (int )tab_i_26[13]) + (int )*((src + 48) + 4) * (int )tab_i_26[14]) + (int )*((src + 48) + 6) * (int )tab_i_26[15];
#line 760
  b0___4 = (((int )*((src + 48) + 1) * (int )tab_i_26[16] + (int )*((src + 48) + 3) * (int )tab_i_26[17]) + (int )*((src + 48) + 5) * (int )tab_i_26[18]) + (int )*((src + 48) + 7) * (int )tab_i_26[19];
#line 760
  b1___4 = (((int )*((src + 48) + 1) * (int )tab_i_26[20] + (int )*((src + 48) + 3) * (int )tab_i_26[21]) + (int )*((src + 48) + 5) * (int )tab_i_26[22]) + (int )*((src + 48) + 7) * (int )tab_i_26[23];
#line 760
  b2___4 = (((int )*((src + 48) + 1) * (int )tab_i_26[24] + (int )*((src + 48) + 3) * (int )tab_i_26[25]) + (int )*((src + 48) + 5) * (int )tab_i_26[26]) + (int )*((src + 48) + 7) * (int )tab_i_26[27];
#line 760
  b3___4 = (((int )*((src + 48) + 1) * (int )tab_i_26[28] + (int )*((src + 48) + 3) * (int )tab_i_26[29]) + (int )*((src + 48) + 5) * (int )tab_i_26[30]) + (int )*((src + 48) + 7) * (int )tab_i_26[31];
#line 760
  *((src + 48) + 0) = (short )(((a0___4 + b0___4) + (int )RND_INV_ROW) >> 12);
#line 760
  *((src + 48) + 1) = (short )(((a1___4 + b1___4) + (int )RND_INV_ROW) >> 12);
#line 760
  *((src + 48) + 2) = (short )(((a2___4 + b2___4) + (int )RND_INV_ROW) >> 12);
#line 760
  *((src + 48) + 3) = (short )(((a3___4 + b3___4) + (int )RND_INV_ROW) >> 12);
#line 760
  *((src + 48) + 4) = (short )(((a3___4 - b3___4) + (int )RND_INV_ROW) >> 12);
#line 760
  *((src + 48) + 5) = (short )(((a2___4 - b2___4) + (int )RND_INV_ROW) >> 12);
#line 760
  *((src + 48) + 6) = (short )(((a1___4 - b1___4) + (int )RND_INV_ROW) >> 12);
#line 760
  *((src + 48) + 7) = (short )(((a0___4 - b0___4) + (int )RND_INV_ROW) >> 12);
#line 762
  a0___5 = (((int )*((src + 24) + 0) * (int )tab_i_35[0] + (int )*((src + 24) + 2) * (int )tab_i_35[1]) + (int )*((src + 24) + 4) * (int )tab_i_35[2]) + (int )*((src + 24) + 6) * (int )tab_i_35[3];
#line 762
  a1___5 = (((int )*((src + 24) + 0) * (int )tab_i_35[4] + (int )*((src + 24) + 2) * (int )tab_i_35[5]) + (int )*((src + 24) + 4) * (int )tab_i_35[6]) + (int )*((src + 24) + 6) * (int )tab_i_35[7];
#line 762
  a2___5 = (((int )*((src + 24) + 0) * (int )tab_i_35[8] + (int )*((src + 24) + 2) * (int )tab_i_35[9]) + (int )*((src + 24) + 4) * (int )tab_i_35[10]) + (int )*((src + 24) + 6) * (int )tab_i_35[11];
#line 762
  a3___5 = (((int )*((src + 24) + 0) * (int )tab_i_35[12] + (int )*((src + 24) + 2) * (int )tab_i_35[13]) + (int )*((src + 24) + 4) * (int )tab_i_35[14]) + (int )*((src + 24) + 6) * (int )tab_i_35[15];
#line 762
  b0___5 = (((int )*((src + 24) + 1) * (int )tab_i_35[16] + (int )*((src + 24) + 3) * (int )tab_i_35[17]) + (int )*((src + 24) + 5) * (int )tab_i_35[18]) + (int )*((src + 24) + 7) * (int )tab_i_35[19];
#line 762
  b1___5 = (((int )*((src + 24) + 1) * (int )tab_i_35[20] + (int )*((src + 24) + 3) * (int )tab_i_35[21]) + (int )*((src + 24) + 5) * (int )tab_i_35[22]) + (int )*((src + 24) + 7) * (int )tab_i_35[23];
#line 762
  b2___5 = (((int )*((src + 24) + 1) * (int )tab_i_35[24] + (int )*((src + 24) + 3) * (int )tab_i_35[25]) + (int )*((src + 24) + 5) * (int )tab_i_35[26]) + (int )*((src + 24) + 7) * (int )tab_i_35[27];
#line 762
  b3___5 = (((int )*((src + 24) + 1) * (int )tab_i_35[28] + (int )*((src + 24) + 3) * (int )tab_i_35[29]) + (int )*((src + 24) + 5) * (int )tab_i_35[30]) + (int )*((src + 24) + 7) * (int )tab_i_35[31];
#line 762
  *((src + 24) + 0) = (short )(((a0___5 + b0___5) + (int )RND_INV_ROW) >> 12);
#line 762
  *((src + 24) + 1) = (short )(((a1___5 + b1___5) + (int )RND_INV_ROW) >> 12);
#line 762
  *((src + 24) + 2) = (short )(((a2___5 + b2___5) + (int )RND_INV_ROW) >> 12);
#line 762
  *((src + 24) + 3) = (short )(((a3___5 + b3___5) + (int )RND_INV_ROW) >> 12);
#line 762
  *((src + 24) + 4) = (short )(((a3___5 - b3___5) + (int )RND_INV_ROW) >> 12);
#line 762
  *((src + 24) + 5) = (short )(((a2___5 - b2___5) + (int )RND_INV_ROW) >> 12);
#line 762
  *((src + 24) + 6) = (short )(((a1___5 - b1___5) + (int )RND_INV_ROW) >> 12);
#line 762
  *((src + 24) + 7) = (short )(((a0___5 - b0___5) + (int )RND_INV_ROW) >> 12);
#line 763
  a0___6 = (((int )*((src + 40) + 0) * (int )tab_i_35[0] + (int )*((src + 40) + 2) * (int )tab_i_35[1]) + (int )*((src + 40) + 4) * (int )tab_i_35[2]) + (int )*((src + 40) + 6) * (int )tab_i_35[3];
#line 763
  a1___6 = (((int )*((src + 40) + 0) * (int )tab_i_35[4] + (int )*((src + 40) + 2) * (int )tab_i_35[5]) + (int )*((src + 40) + 4) * (int )tab_i_35[6]) + (int )*((src + 40) + 6) * (int )tab_i_35[7];
#line 763
  a2___6 = (((int )*((src + 40) + 0) * (int )tab_i_35[8] + (int )*((src + 40) + 2) * (int )tab_i_35[9]) + (int )*((src + 40) + 4) * (int )tab_i_35[10]) + (int )*((src + 40) + 6) * (int )tab_i_35[11];
#line 763
  a3___6 = (((int )*((src + 40) + 0) * (int )tab_i_35[12] + (int )*((src + 40) + 2) * (int )tab_i_35[13]) + (int )*((src + 40) + 4) * (int )tab_i_35[14]) + (int )*((src + 40) + 6) * (int )tab_i_35[15];
#line 763
  b0___6 = (((int )*((src + 40) + 1) * (int )tab_i_35[16] + (int )*((src + 40) + 3) * (int )tab_i_35[17]) + (int )*((src + 40) + 5) * (int )tab_i_35[18]) + (int )*((src + 40) + 7) * (int )tab_i_35[19];
#line 763
  b1___6 = (((int )*((src + 40) + 1) * (int )tab_i_35[20] + (int )*((src + 40) + 3) * (int )tab_i_35[21]) + (int )*((src + 40) + 5) * (int )tab_i_35[22]) + (int )*((src + 40) + 7) * (int )tab_i_35[23];
#line 763
  b2___6 = (((int )*((src + 40) + 1) * (int )tab_i_35[24] + (int )*((src + 40) + 3) * (int )tab_i_35[25]) + (int )*((src + 40) + 5) * (int )tab_i_35[26]) + (int )*((src + 40) + 7) * (int )tab_i_35[27];
#line 763
  b3___6 = (((int )*((src + 40) + 1) * (int )tab_i_35[28] + (int )*((src + 40) + 3) * (int )tab_i_35[29]) + (int )*((src + 40) + 5) * (int )tab_i_35[30]) + (int )*((src + 40) + 7) * (int )tab_i_35[31];
#line 763
  *((src + 40) + 0) = (short )(((a0___6 + b0___6) + (int )RND_INV_ROW) >> 12);
#line 763
  *((src + 40) + 1) = (short )(((a1___6 + b1___6) + (int )RND_INV_ROW) >> 12);
#line 763
  *((src + 40) + 2) = (short )(((a2___6 + b2___6) + (int )RND_INV_ROW) >> 12);
#line 763
  *((src + 40) + 3) = (short )(((a3___6 + b3___6) + (int )RND_INV_ROW) >> 12);
#line 763
  *((src + 40) + 4) = (short )(((a3___6 - b3___6) + (int )RND_INV_ROW) >> 12);
#line 763
  *((src + 40) + 5) = (short )(((a2___6 - b2___6) + (int )RND_INV_ROW) >> 12);
#line 763
  *((src + 40) + 6) = (short )(((a1___6 - b1___6) + (int )RND_INV_ROW) >> 12);
#line 763
  *((src + 40) + 7) = (short )(((a0___6 - b0___6) + (int )RND_INV_ROW) >> 12);
#line 765
  tp765 = (int )*(src + 8) + ((int )*(src + 56) * 13036 >> 16);
#line 765
  tp465 = ((int )*(src + 8) * 13036 >> 16) - (int )*(src + 56);
#line 765
  tm765 = (((int )*(src + 40) * -21746 >> 16) + (int )*(src + 40)) + (int )*(src + 24);
#line 765
  tm465 = ((int )*(src + 40) - ((int )*(src + 24) * -21746 >> 16)) - (int )*(src + 24);
#line 765
  t7 = (tp765 + tm765) + 1;
#line 765
  tp65 = tp765 - tm765;
#line 765
  t4 = tp465 + tm465;
#line 765
  tm65 = (tp465 - tm465) + 1;
#line 765
  t6 = ((tp65 + tm65) * -19195 >> 16) | 1;
#line 765
  t6 += tp65 + tm65;
#line 765
  t5 = ((tp65 - tm65) * -19195 >> 16) | 1;
#line 765
  t5 += tp65 - tm65;
#line 765
  tp03 = (int )*(src + 0) + (int )*(src + 32);
#line 765
  tp12 = (int )*(src + 0) - (int )*(src + 32);
#line 765
  tm03 = (int )*(src + 16) + ((int )*(src + 48) * 27146 >> 16);
#line 765
  tm12 = ((int )*(src + 16) * 27146 >> 16) - (int )*(src + 48);
#line 765
  t0 = (tp03 + tm03) + 16;
#line 765
  t3 = (tp03 - tm03) + (int )RND_INV_CORR;
#line 765
  t1 = (tp12 + tm12) + 16;
#line 765
  t2 = (tp12 - tm12) + (int )RND_INV_CORR;
#line 765
  if (t0 + t7 > 32767) {
#line 765
    tmp___0 = 32767;
  } else {
#line 765
    if (t0 + t7 < -32768) {
#line 765
      tmp = -32768;
    } else {
#line 765
      tmp = t0 + t7;
    }
#line 765
    tmp___0 = tmp;
  }
#line 765
  *(src + 0) = (short )(tmp___0 >> 5);
#line 765
  if (t0 - t7 > 32767) {
#line 765
    tmp___2 = 32767;
  } else {
#line 765
    if (t0 - t7 < -32768) {
#line 765
      tmp___1 = -32768;
    } else {
#line 765
      tmp___1 = t0 - t7;
    }
#line 765
    tmp___2 = tmp___1;
  }
#line 765
  *(src + 56) = (short )(tmp___2 >> 5);
#line 765
  if (t1 + t6 > 32767) {
#line 765
    tmp___4 = 32767;
  } else {
#line 765
    if (t1 + t6 < -32768) {
#line 765
      tmp___3 = -32768;
    } else {
#line 765
      tmp___3 = t1 + t6;
    }
#line 765
    tmp___4 = tmp___3;
  }
#line 765
  *(src + 8) = (short )(tmp___4 >> 5);
#line 765
  if (t1 - t6 > 32767) {
#line 765
    tmp___6 = 32767;
  } else {
#line 765
    if (t1 - t6 < -32768) {
#line 765
      tmp___5 = -32768;
    } else {
#line 765
      tmp___5 = t1 - t6;
    }
#line 765
    tmp___6 = tmp___5;
  }
#line 765
  *(src + 48) = (short )(tmp___6 >> 5);
#line 765
  if (t2 + t5 > 32767) {
#line 765
    tmp___8 = 32767;
  } else {
#line 765
    if (t2 + t5 < -32768) {
#line 765
      tmp___7 = -32768;
    } else {
#line 765
      tmp___7 = t2 + t5;
    }
#line 765
    tmp___8 = tmp___7;
  }
#line 765
  *(src + 16) = (short )(tmp___8 >> 5);
#line 765
  if (t2 - t5 > 32767) {
#line 765
    tmp___10 = 32767;
  } else {
#line 765
    if (t2 - t5 < -32768) {
#line 765
      tmp___9 = -32768;
    } else {
#line 765
      tmp___9 = t2 - t5;
    }
#line 765
    tmp___10 = tmp___9;
  }
#line 765
  *(src + 40) = (short )(tmp___10 >> 5);
#line 765
  if (t3 + t4 > 32767) {
#line 765
    tmp___12 = 32767;
  } else {
#line 765
    if (t3 + t4 < -32768) {
#line 765
      tmp___11 = -32768;
    } else {
#line 765
      tmp___11 = t3 + t4;
    }
#line 765
    tmp___12 = tmp___11;
  }
#line 765
  *(src + 24) = (short )(tmp___12 >> 5);
#line 765
  if (t3 - t4 > 32767) {
#line 765
    tmp___14 = 32767;
  } else {
#line 765
    if (t3 - t4 < -32768) {
#line 765
      tmp___13 = -32768;
    } else {
#line 765
      tmp___13 = t3 - t4;
    }
#line 765
    tmp___14 = tmp___13;
  }
#line 765
  *(src + 32) = (short )(tmp___14 >> 5);
#line 766
  tp765___0 = (int )*((src + 1) + 8) + ((int )*((src + 1) + 56) * 13036 >> 16);
#line 766
  tp465___0 = ((int )*((src + 1) + 8) * 13036 >> 16) - (int )*((src + 1) + 56);
#line 766
  tm765___0 = (((int )*((src + 1) + 40) * -21746 >> 16) + (int )*((src + 1) + 40)) + (int )*((src + 1) + 24);
#line 766
  tm465___0 = ((int )*((src + 1) + 40) - ((int )*((src + 1) + 24) * -21746 >> 16)) - (int )*((src + 1) + 24);
#line 766
  t7___0 = (tp765___0 + tm765___0) + 1;
#line 766
  tp65___0 = tp765___0 - tm765___0;
#line 766
  t4___0 = tp465___0 + tm465___0;
#line 766
  tm65___0 = (tp465___0 - tm465___0) + 1;
#line 766
  t6___0 = ((tp65___0 + tm65___0) * -19195 >> 16) | 1;
#line 766
  t6___0 += tp65___0 + tm65___0;
#line 766
  t5___0 = ((tp65___0 - tm65___0) * -19195 >> 16) | 1;
#line 766
  t5___0 += tp65___0 - tm65___0;
#line 766
  tp03___0 = (int )*((src + 1) + 0) + (int )*((src + 1) + 32);
#line 766
  tp12___0 = (int )*((src + 1) + 0) - (int )*((src + 1) + 32);
#line 766
  tm03___0 = (int )*((src + 1) + 16) + ((int )*((src + 1) + 48) * 27146 >> 16);
#line 766
  tm12___0 = ((int )*((src + 1) + 16) * 27146 >> 16) - (int )*((src + 1) + 48);
#line 766
  t0___0 = (tp03___0 + tm03___0) + 16;
#line 766
  t3___0 = (tp03___0 - tm03___0) + (int )RND_INV_CORR;
#line 766
  t1___0 = (tp12___0 + tm12___0) + 16;
#line 766
  t2___0 = (tp12___0 - tm12___0) + (int )RND_INV_CORR;
#line 766
  if (t0___0 + t7___0 > 32767) {
#line 766
    tmp___16 = 32767;
  } else {
#line 766
    if (t0___0 + t7___0 < -32768) {
#line 766
      tmp___15 = -32768;
    } else {
#line 766
      tmp___15 = t0___0 + t7___0;
    }
#line 766
    tmp___16 = tmp___15;
  }
#line 766
  *((src + 1) + 0) = (short )(tmp___16 >> 5);
#line 766
  if (t0___0 - t7___0 > 32767) {
#line 766
    tmp___18 = 32767;
  } else {
#line 766
    if (t0___0 - t7___0 < -32768) {
#line 766
      tmp___17 = -32768;
    } else {
#line 766
      tmp___17 = t0___0 - t7___0;
    }
#line 766
    tmp___18 = tmp___17;
  }
#line 766
  *((src + 1) + 56) = (short )(tmp___18 >> 5);
#line 766
  if (t1___0 + t6___0 > 32767) {
#line 766
    tmp___20 = 32767;
  } else {
#line 766
    if (t1___0 + t6___0 < -32768) {
#line 766
      tmp___19 = -32768;
    } else {
#line 766
      tmp___19 = t1___0 + t6___0;
    }
#line 766
    tmp___20 = tmp___19;
  }
#line 766
  *((src + 1) + 8) = (short )(tmp___20 >> 5);
#line 766
  if (t1___0 - t6___0 > 32767) {
#line 766
    tmp___22 = 32767;
  } else {
#line 766
    if (t1___0 - t6___0 < -32768) {
#line 766
      tmp___21 = -32768;
    } else {
#line 766
      tmp___21 = t1___0 - t6___0;
    }
#line 766
    tmp___22 = tmp___21;
  }
#line 766
  *((src + 1) + 48) = (short )(tmp___22 >> 5);
#line 766
  if (t2___0 + t5___0 > 32767) {
#line 766
    tmp___24 = 32767;
  } else {
#line 766
    if (t2___0 + t5___0 < -32768) {
#line 766
      tmp___23 = -32768;
    } else {
#line 766
      tmp___23 = t2___0 + t5___0;
    }
#line 766
    tmp___24 = tmp___23;
  }
#line 766
  *((src + 1) + 16) = (short )(tmp___24 >> 5);
#line 766
  if (t2___0 - t5___0 > 32767) {
#line 766
    tmp___26 = 32767;
  } else {
#line 766
    if (t2___0 - t5___0 < -32768) {
#line 766
      tmp___25 = -32768;
    } else {
#line 766
      tmp___25 = t2___0 - t5___0;
    }
#line 766
    tmp___26 = tmp___25;
  }
#line 766
  *((src + 1) + 40) = (short )(tmp___26 >> 5);
#line 766
  if (t3___0 + t4___0 > 32767) {
#line 766
    tmp___28 = 32767;
  } else {
#line 766
    if (t3___0 + t4___0 < -32768) {
#line 766
      tmp___27 = -32768;
    } else {
#line 766
      tmp___27 = t3___0 + t4___0;
    }
#line 766
    tmp___28 = tmp___27;
  }
#line 766
  *((src + 1) + 24) = (short )(tmp___28 >> 5);
#line 766
  if (t3___0 - t4___0 > 32767) {
#line 766
    tmp___30 = 32767;
  } else {
#line 766
    if (t3___0 - t4___0 < -32768) {
#line 766
      tmp___29 = -32768;
    } else {
#line 766
      tmp___29 = t3___0 - t4___0;
    }
#line 766
    tmp___30 = tmp___29;
  }
#line 766
  *((src + 1) + 32) = (short )(tmp___30 >> 5);
#line 767
  tp765___1 = (int )*((src + 2) + 8) + ((int )*((src + 2) + 56) * 13036 >> 16);
#line 767
  tp465___1 = ((int )*((src + 2) + 8) * 13036 >> 16) - (int )*((src + 2) + 56);
#line 767
  tm765___1 = (((int )*((src + 2) + 40) * -21746 >> 16) + (int )*((src + 2) + 40)) + (int )*((src + 2) + 24);
#line 767
  tm465___1 = ((int )*((src + 2) + 40) - ((int )*((src + 2) + 24) * -21746 >> 16)) - (int )*((src + 2) + 24);
#line 767
  t7___1 = (tp765___1 + tm765___1) + 1;
#line 767
  tp65___1 = tp765___1 - tm765___1;
#line 767
  t4___1 = tp465___1 + tm465___1;
#line 767
  tm65___1 = (tp465___1 - tm465___1) + 1;
#line 767
  t6___1 = ((tp65___1 + tm65___1) * -19195 >> 16) | 1;
#line 767
  t6___1 += tp65___1 + tm65___1;
#line 767
  t5___1 = ((tp65___1 - tm65___1) * -19195 >> 16) | 1;
#line 767
  t5___1 += tp65___1 - tm65___1;
#line 767
  tp03___1 = (int )*((src + 2) + 0) + (int )*((src + 2) + 32);
#line 767
  tp12___1 = (int )*((src + 2) + 0) - (int )*((src + 2) + 32);
#line 767
  tm03___1 = (int )*((src + 2) + 16) + ((int )*((src + 2) + 48) * 27146 >> 16);
#line 767
  tm12___1 = ((int )*((src + 2) + 16) * 27146 >> 16) - (int )*((src + 2) + 48);
#line 767
  t0___1 = (tp03___1 + tm03___1) + 16;
#line 767
  t3___1 = (tp03___1 - tm03___1) + (int )RND_INV_CORR;
#line 767
  t1___1 = (tp12___1 + tm12___1) + 16;
#line 767
  t2___1 = (tp12___1 - tm12___1) + (int )RND_INV_CORR;
#line 767
  if (t0___1 + t7___1 > 32767) {
#line 767
    tmp___32 = 32767;
  } else {
#line 767
    if (t0___1 + t7___1 < -32768) {
#line 767
      tmp___31 = -32768;
    } else {
#line 767
      tmp___31 = t0___1 + t7___1;
    }
#line 767
    tmp___32 = tmp___31;
  }
#line 767
  *((src + 2) + 0) = (short )(tmp___32 >> 5);
#line 767
  if (t0___1 - t7___1 > 32767) {
#line 767
    tmp___34 = 32767;
  } else {
#line 767
    if (t0___1 - t7___1 < -32768) {
#line 767
      tmp___33 = -32768;
    } else {
#line 767
      tmp___33 = t0___1 - t7___1;
    }
#line 767
    tmp___34 = tmp___33;
  }
#line 767
  *((src + 2) + 56) = (short )(tmp___34 >> 5);
#line 767
  if (t1___1 + t6___1 > 32767) {
#line 767
    tmp___36 = 32767;
  } else {
#line 767
    if (t1___1 + t6___1 < -32768) {
#line 767
      tmp___35 = -32768;
    } else {
#line 767
      tmp___35 = t1___1 + t6___1;
    }
#line 767
    tmp___36 = tmp___35;
  }
#line 767
  *((src + 2) + 8) = (short )(tmp___36 >> 5);
#line 767
  if (t1___1 - t6___1 > 32767) {
#line 767
    tmp___38 = 32767;
  } else {
#line 767
    if (t1___1 - t6___1 < -32768) {
#line 767
      tmp___37 = -32768;
    } else {
#line 767
      tmp___37 = t1___1 - t6___1;
    }
#line 767
    tmp___38 = tmp___37;
  }
#line 767
  *((src + 2) + 48) = (short )(tmp___38 >> 5);
#line 767
  if (t2___1 + t5___1 > 32767) {
#line 767
    tmp___40 = 32767;
  } else {
#line 767
    if (t2___1 + t5___1 < -32768) {
#line 767
      tmp___39 = -32768;
    } else {
#line 767
      tmp___39 = t2___1 + t5___1;
    }
#line 767
    tmp___40 = tmp___39;
  }
#line 767
  *((src + 2) + 16) = (short )(tmp___40 >> 5);
#line 767
  if (t2___1 - t5___1 > 32767) {
#line 767
    tmp___42 = 32767;
  } else {
#line 767
    if (t2___1 - t5___1 < -32768) {
#line 767
      tmp___41 = -32768;
    } else {
#line 767
      tmp___41 = t2___1 - t5___1;
    }
#line 767
    tmp___42 = tmp___41;
  }
#line 767
  *((src + 2) + 40) = (short )(tmp___42 >> 5);
#line 767
  if (t3___1 + t4___1 > 32767) {
#line 767
    tmp___44 = 32767;
  } else {
#line 767
    if (t3___1 + t4___1 < -32768) {
#line 767
      tmp___43 = -32768;
    } else {
#line 767
      tmp___43 = t3___1 + t4___1;
    }
#line 767
    tmp___44 = tmp___43;
  }
#line 767
  *((src + 2) + 24) = (short )(tmp___44 >> 5);
#line 767
  if (t3___1 - t4___1 > 32767) {
#line 767
    tmp___46 = 32767;
  } else {
#line 767
    if (t3___1 - t4___1 < -32768) {
#line 767
      tmp___45 = -32768;
    } else {
#line 767
      tmp___45 = t3___1 - t4___1;
    }
#line 767
    tmp___46 = tmp___45;
  }
#line 767
  *((src + 2) + 32) = (short )(tmp___46 >> 5);
#line 768
  tp765___2 = (int )*((src + 3) + 8) + ((int )*((src + 3) + 56) * 13036 >> 16);
#line 768
  tp465___2 = ((int )*((src + 3) + 8) * 13036 >> 16) - (int )*((src + 3) + 56);
#line 768
  tm765___2 = (((int )*((src + 3) + 40) * -21746 >> 16) + (int )*((src + 3) + 40)) + (int )*((src + 3) + 24);
#line 768
  tm465___2 = ((int )*((src + 3) + 40) - ((int )*((src + 3) + 24) * -21746 >> 16)) - (int )*((src + 3) + 24);
#line 768
  t7___2 = (tp765___2 + tm765___2) + 1;
#line 768
  tp65___2 = tp765___2 - tm765___2;
#line 768
  t4___2 = tp465___2 + tm465___2;
#line 768
  tm65___2 = (tp465___2 - tm465___2) + 1;
#line 768
  t6___2 = ((tp65___2 + tm65___2) * -19195 >> 16) | 1;
#line 768
  t6___2 += tp65___2 + tm65___2;
#line 768
  t5___2 = ((tp65___2 - tm65___2) * -19195 >> 16) | 1;
#line 768
  t5___2 += tp65___2 - tm65___2;
#line 768
  tp03___2 = (int )*((src + 3) + 0) + (int )*((src + 3) + 32);
#line 768
  tp12___2 = (int )*((src + 3) + 0) - (int )*((src + 3) + 32);
#line 768
  tm03___2 = (int )*((src + 3) + 16) + ((int )*((src + 3) + 48) * 27146 >> 16);
#line 768
  tm12___2 = ((int )*((src + 3) + 16) * 27146 >> 16) - (int )*((src + 3) + 48);
#line 768
  t0___2 = (tp03___2 + tm03___2) + 16;
#line 768
  t3___2 = (tp03___2 - tm03___2) + (int )RND_INV_CORR;
#line 768
  t1___2 = (tp12___2 + tm12___2) + 16;
#line 768
  t2___2 = (tp12___2 - tm12___2) + (int )RND_INV_CORR;
#line 768
  if (t0___2 + t7___2 > 32767) {
#line 768
    tmp___48 = 32767;
  } else {
#line 768
    if (t0___2 + t7___2 < -32768) {
#line 768
      tmp___47 = -32768;
    } else {
#line 768
      tmp___47 = t0___2 + t7___2;
    }
#line 768
    tmp___48 = tmp___47;
  }
#line 768
  *((src + 3) + 0) = (short )(tmp___48 >> 5);
#line 768
  if (t0___2 - t7___2 > 32767) {
#line 768
    tmp___50 = 32767;
  } else {
#line 768
    if (t0___2 - t7___2 < -32768) {
#line 768
      tmp___49 = -32768;
    } else {
#line 768
      tmp___49 = t0___2 - t7___2;
    }
#line 768
    tmp___50 = tmp___49;
  }
#line 768
  *((src + 3) + 56) = (short )(tmp___50 >> 5);
#line 768
  if (t1___2 + t6___2 > 32767) {
#line 768
    tmp___52 = 32767;
  } else {
#line 768
    if (t1___2 + t6___2 < -32768) {
#line 768
      tmp___51 = -32768;
    } else {
#line 768
      tmp___51 = t1___2 + t6___2;
    }
#line 768
    tmp___52 = tmp___51;
  }
#line 768
  *((src + 3) + 8) = (short )(tmp___52 >> 5);
#line 768
  if (t1___2 - t6___2 > 32767) {
#line 768
    tmp___54 = 32767;
  } else {
#line 768
    if (t1___2 - t6___2 < -32768) {
#line 768
      tmp___53 = -32768;
    } else {
#line 768
      tmp___53 = t1___2 - t6___2;
    }
#line 768
    tmp___54 = tmp___53;
  }
#line 768
  *((src + 3) + 48) = (short )(tmp___54 >> 5);
#line 768
  if (t2___2 + t5___2 > 32767) {
#line 768
    tmp___56 = 32767;
  } else {
#line 768
    if (t2___2 + t5___2 < -32768) {
#line 768
      tmp___55 = -32768;
    } else {
#line 768
      tmp___55 = t2___2 + t5___2;
    }
#line 768
    tmp___56 = tmp___55;
  }
#line 768
  *((src + 3) + 16) = (short )(tmp___56 >> 5);
#line 768
  if (t2___2 - t5___2 > 32767) {
#line 768
    tmp___58 = 32767;
  } else {
#line 768
    if (t2___2 - t5___2 < -32768) {
#line 768
      tmp___57 = -32768;
    } else {
#line 768
      tmp___57 = t2___2 - t5___2;
    }
#line 768
    tmp___58 = tmp___57;
  }
#line 768
  *((src + 3) + 40) = (short )(tmp___58 >> 5);
#line 768
  if (t3___2 + t4___2 > 32767) {
#line 768
    tmp___60 = 32767;
  } else {
#line 768
    if (t3___2 + t4___2 < -32768) {
#line 768
      tmp___59 = -32768;
    } else {
#line 768
      tmp___59 = t3___2 + t4___2;
    }
#line 768
    tmp___60 = tmp___59;
  }
#line 768
  *((src + 3) + 24) = (short )(tmp___60 >> 5);
#line 768
  if (t3___2 - t4___2 > 32767) {
#line 768
    tmp___62 = 32767;
  } else {
#line 768
    if (t3___2 - t4___2 < -32768) {
#line 768
      tmp___61 = -32768;
    } else {
#line 768
      tmp___61 = t3___2 - t4___2;
    }
#line 768
    tmp___62 = tmp___61;
  }
#line 768
  *((src + 3) + 32) = (short )(tmp___62 >> 5);
#line 769
  tp765___3 = (int )*((src + 4) + 8) + ((int )*((src + 4) + 56) * 13036 >> 16);
#line 769
  tp465___3 = ((int )*((src + 4) + 8) * 13036 >> 16) - (int )*((src + 4) + 56);
#line 769
  tm765___3 = (((int )*((src + 4) + 40) * -21746 >> 16) + (int )*((src + 4) + 40)) + (int )*((src + 4) + 24);
#line 769
  tm465___3 = ((int )*((src + 4) + 40) - ((int )*((src + 4) + 24) * -21746 >> 16)) - (int )*((src + 4) + 24);
#line 769
  t7___3 = (tp765___3 + tm765___3) + 1;
#line 769
  tp65___3 = tp765___3 - tm765___3;
#line 769
  t4___3 = tp465___3 + tm465___3;
#line 769
  tm65___3 = (tp465___3 - tm465___3) + 1;
#line 769
  t6___3 = ((tp65___3 + tm65___3) * -19195 >> 16) | 1;
#line 769
  t6___3 += tp65___3 + tm65___3;
#line 769
  t5___3 = ((tp65___3 - tm65___3) * -19195 >> 16) | 1;
#line 769
  t5___3 += tp65___3 - tm65___3;
#line 769
  tp03___3 = (int )*((src + 4) + 0) + (int )*((src + 4) + 32);
#line 769
  tp12___3 = (int )*((src + 4) + 0) - (int )*((src + 4) + 32);
#line 769
  tm03___3 = (int )*((src + 4) + 16) + ((int )*((src + 4) + 48) * 27146 >> 16);
#line 769
  tm12___3 = ((int )*((src + 4) + 16) * 27146 >> 16) - (int )*((src + 4) + 48);
#line 769
  t0___3 = (tp03___3 + tm03___3) + 16;
#line 769
  t3___3 = (tp03___3 - tm03___3) + (int )RND_INV_CORR;
#line 769
  t1___3 = (tp12___3 + tm12___3) + 16;
#line 769
  t2___3 = (tp12___3 - tm12___3) + (int )RND_INV_CORR;
#line 769
  if (t0___3 + t7___3 > 32767) {
#line 769
    tmp___64 = 32767;
  } else {
#line 769
    if (t0___3 + t7___3 < -32768) {
#line 769
      tmp___63 = -32768;
    } else {
#line 769
      tmp___63 = t0___3 + t7___3;
    }
#line 769
    tmp___64 = tmp___63;
  }
#line 769
  *((src + 4) + 0) = (short )(tmp___64 >> 5);
#line 769
  if (t0___3 - t7___3 > 32767) {
#line 769
    tmp___66 = 32767;
  } else {
#line 769
    if (t0___3 - t7___3 < -32768) {
#line 769
      tmp___65 = -32768;
    } else {
#line 769
      tmp___65 = t0___3 - t7___3;
    }
#line 769
    tmp___66 = tmp___65;
  }
#line 769
  *((src + 4) + 56) = (short )(tmp___66 >> 5);
#line 769
  if (t1___3 + t6___3 > 32767) {
#line 769
    tmp___68 = 32767;
  } else {
#line 769
    if (t1___3 + t6___3 < -32768) {
#line 769
      tmp___67 = -32768;
    } else {
#line 769
      tmp___67 = t1___3 + t6___3;
    }
#line 769
    tmp___68 = tmp___67;
  }
#line 769
  *((src + 4) + 8) = (short )(tmp___68 >> 5);
#line 769
  if (t1___3 - t6___3 > 32767) {
#line 769
    tmp___70 = 32767;
  } else {
#line 769
    if (t1___3 - t6___3 < -32768) {
#line 769
      tmp___69 = -32768;
    } else {
#line 769
      tmp___69 = t1___3 - t6___3;
    }
#line 769
    tmp___70 = tmp___69;
  }
#line 769
  *((src + 4) + 48) = (short )(tmp___70 >> 5);
#line 769
  if (t2___3 + t5___3 > 32767) {
#line 769
    tmp___72 = 32767;
  } else {
#line 769
    if (t2___3 + t5___3 < -32768) {
#line 769
      tmp___71 = -32768;
    } else {
#line 769
      tmp___71 = t2___3 + t5___3;
    }
#line 769
    tmp___72 = tmp___71;
  }
#line 769
  *((src + 4) + 16) = (short )(tmp___72 >> 5);
#line 769
  if (t2___3 - t5___3 > 32767) {
#line 769
    tmp___74 = 32767;
  } else {
#line 769
    if (t2___3 - t5___3 < -32768) {
#line 769
      tmp___73 = -32768;
    } else {
#line 769
      tmp___73 = t2___3 - t5___3;
    }
#line 769
    tmp___74 = tmp___73;
  }
#line 769
  *((src + 4) + 40) = (short )(tmp___74 >> 5);
#line 769
  if (t3___3 + t4___3 > 32767) {
#line 769
    tmp___76 = 32767;
  } else {
#line 769
    if (t3___3 + t4___3 < -32768) {
#line 769
      tmp___75 = -32768;
    } else {
#line 769
      tmp___75 = t3___3 + t4___3;
    }
#line 769
    tmp___76 = tmp___75;
  }
#line 769
  *((src + 4) + 24) = (short )(tmp___76 >> 5);
#line 769
  if (t3___3 - t4___3 > 32767) {
#line 769
    tmp___78 = 32767;
  } else {
#line 769
    if (t3___3 - t4___3 < -32768) {
#line 769
      tmp___77 = -32768;
    } else {
#line 769
      tmp___77 = t3___3 - t4___3;
    }
#line 769
    tmp___78 = tmp___77;
  }
#line 769
  *((src + 4) + 32) = (short )(tmp___78 >> 5);
#line 770
  tp765___4 = (int )*((src + 5) + 8) + ((int )*((src + 5) + 56) * 13036 >> 16);
#line 770
  tp465___4 = ((int )*((src + 5) + 8) * 13036 >> 16) - (int )*((src + 5) + 56);
#line 770
  tm765___4 = (((int )*((src + 5) + 40) * -21746 >> 16) + (int )*((src + 5) + 40)) + (int )*((src + 5) + 24);
#line 770
  tm465___4 = ((int )*((src + 5) + 40) - ((int )*((src + 5) + 24) * -21746 >> 16)) - (int )*((src + 5) + 24);
#line 770
  t7___4 = (tp765___4 + tm765___4) + 1;
#line 770
  tp65___4 = tp765___4 - tm765___4;
#line 770
  t4___4 = tp465___4 + tm465___4;
#line 770
  tm65___4 = (tp465___4 - tm465___4) + 1;
#line 770
  t6___4 = ((tp65___4 + tm65___4) * -19195 >> 16) | 1;
#line 770
  t6___4 += tp65___4 + tm65___4;
#line 770
  t5___4 = ((tp65___4 - tm65___4) * -19195 >> 16) | 1;
#line 770
  t5___4 += tp65___4 - tm65___4;
#line 770
  tp03___4 = (int )*((src + 5) + 0) + (int )*((src + 5) + 32);
#line 770
  tp12___4 = (int )*((src + 5) + 0) - (int )*((src + 5) + 32);
#line 770
  tm03___4 = (int )*((src + 5) + 16) + ((int )*((src + 5) + 48) * 27146 >> 16);
#line 770
  tm12___4 = ((int )*((src + 5) + 16) * 27146 >> 16) - (int )*((src + 5) + 48);
#line 770
  t0___4 = (tp03___4 + tm03___4) + 16;
#line 770
  t3___4 = (tp03___4 - tm03___4) + (int )RND_INV_CORR;
#line 770
  t1___4 = (tp12___4 + tm12___4) + 16;
#line 770
  t2___4 = (tp12___4 - tm12___4) + (int )RND_INV_CORR;
#line 770
  if (t0___4 + t7___4 > 32767) {
#line 770
    tmp___80 = 32767;
  } else {
#line 770
    if (t0___4 + t7___4 < -32768) {
#line 770
      tmp___79 = -32768;
    } else {
#line 770
      tmp___79 = t0___4 + t7___4;
    }
#line 770
    tmp___80 = tmp___79;
  }
#line 770
  *((src + 5) + 0) = (short )(tmp___80 >> 5);
#line 770
  if (t0___4 - t7___4 > 32767) {
#line 770
    tmp___82 = 32767;
  } else {
#line 770
    if (t0___4 - t7___4 < -32768) {
#line 770
      tmp___81 = -32768;
    } else {
#line 770
      tmp___81 = t0___4 - t7___4;
    }
#line 770
    tmp___82 = tmp___81;
  }
#line 770
  *((src + 5) + 56) = (short )(tmp___82 >> 5);
#line 770
  if (t1___4 + t6___4 > 32767) {
#line 770
    tmp___84 = 32767;
  } else {
#line 770
    if (t1___4 + t6___4 < -32768) {
#line 770
      tmp___83 = -32768;
    } else {
#line 770
      tmp___83 = t1___4 + t6___4;
    }
#line 770
    tmp___84 = tmp___83;
  }
#line 770
  *((src + 5) + 8) = (short )(tmp___84 >> 5);
#line 770
  if (t1___4 - t6___4 > 32767) {
#line 770
    tmp___86 = 32767;
  } else {
#line 770
    if (t1___4 - t6___4 < -32768) {
#line 770
      tmp___85 = -32768;
    } else {
#line 770
      tmp___85 = t1___4 - t6___4;
    }
#line 770
    tmp___86 = tmp___85;
  }
#line 770
  *((src + 5) + 48) = (short )(tmp___86 >> 5);
#line 770
  if (t2___4 + t5___4 > 32767) {
#line 770
    tmp___88 = 32767;
  } else {
#line 770
    if (t2___4 + t5___4 < -32768) {
#line 770
      tmp___87 = -32768;
    } else {
#line 770
      tmp___87 = t2___4 + t5___4;
    }
#line 770
    tmp___88 = tmp___87;
  }
#line 770
  *((src + 5) + 16) = (short )(tmp___88 >> 5);
#line 770
  if (t2___4 - t5___4 > 32767) {
#line 770
    tmp___90 = 32767;
  } else {
#line 770
    if (t2___4 - t5___4 < -32768) {
#line 770
      tmp___89 = -32768;
    } else {
#line 770
      tmp___89 = t2___4 - t5___4;
    }
#line 770
    tmp___90 = tmp___89;
  }
#line 770
  *((src + 5) + 40) = (short )(tmp___90 >> 5);
#line 770
  if (t3___4 + t4___4 > 32767) {
#line 770
    tmp___92 = 32767;
  } else {
#line 770
    if (t3___4 + t4___4 < -32768) {
#line 770
      tmp___91 = -32768;
    } else {
#line 770
      tmp___91 = t3___4 + t4___4;
    }
#line 770
    tmp___92 = tmp___91;
  }
#line 770
  *((src + 5) + 24) = (short )(tmp___92 >> 5);
#line 770
  if (t3___4 - t4___4 > 32767) {
#line 770
    tmp___94 = 32767;
  } else {
#line 770
    if (t3___4 - t4___4 < -32768) {
#line 770
      tmp___93 = -32768;
    } else {
#line 770
      tmp___93 = t3___4 - t4___4;
    }
#line 770
    tmp___94 = tmp___93;
  }
#line 770
  *((src + 5) + 32) = (short )(tmp___94 >> 5);
#line 771
  tp765___5 = (int )*((src + 6) + 8) + ((int )*((src + 6) + 56) * 13036 >> 16);
#line 771
  tp465___5 = ((int )*((src + 6) + 8) * 13036 >> 16) - (int )*((src + 6) + 56);
#line 771
  tm765___5 = (((int )*((src + 6) + 40) * -21746 >> 16) + (int )*((src + 6) + 40)) + (int )*((src + 6) + 24);
#line 771
  tm465___5 = ((int )*((src + 6) + 40) - ((int )*((src + 6) + 24) * -21746 >> 16)) - (int )*((src + 6) + 24);
#line 771
  t7___5 = (tp765___5 + tm765___5) + 1;
#line 771
  tp65___5 = tp765___5 - tm765___5;
#line 771
  t4___5 = tp465___5 + tm465___5;
#line 771
  tm65___5 = (tp465___5 - tm465___5) + 1;
#line 771
  t6___5 = ((tp65___5 + tm65___5) * -19195 >> 16) | 1;
#line 771
  t6___5 += tp65___5 + tm65___5;
#line 771
  t5___5 = ((tp65___5 - tm65___5) * -19195 >> 16) | 1;
#line 771
  t5___5 += tp65___5 - tm65___5;
#line 771
  tp03___5 = (int )*((src + 6) + 0) + (int )*((src + 6) + 32);
#line 771
  tp12___5 = (int )*((src + 6) + 0) - (int )*((src + 6) + 32);
#line 771
  tm03___5 = (int )*((src + 6) + 16) + ((int )*((src + 6) + 48) * 27146 >> 16);
#line 771
  tm12___5 = ((int )*((src + 6) + 16) * 27146 >> 16) - (int )*((src + 6) + 48);
#line 771
  t0___5 = (tp03___5 + tm03___5) + 16;
#line 771
  t3___5 = (tp03___5 - tm03___5) + (int )RND_INV_CORR;
#line 771
  t1___5 = (tp12___5 + tm12___5) + 16;
#line 771
  t2___5 = (tp12___5 - tm12___5) + (int )RND_INV_CORR;
#line 771
  if (t0___5 + t7___5 > 32767) {
#line 771
    tmp___96 = 32767;
  } else {
#line 771
    if (t0___5 + t7___5 < -32768) {
#line 771
      tmp___95 = -32768;
    } else {
#line 771
      tmp___95 = t0___5 + t7___5;
    }
#line 771
    tmp___96 = tmp___95;
  }
#line 771
  *((src + 6) + 0) = (short )(tmp___96 >> 5);
#line 771
  if (t0___5 - t7___5 > 32767) {
#line 771
    tmp___98 = 32767;
  } else {
#line 771
    if (t0___5 - t7___5 < -32768) {
#line 771
      tmp___97 = -32768;
    } else {
#line 771
      tmp___97 = t0___5 - t7___5;
    }
#line 771
    tmp___98 = tmp___97;
  }
#line 771
  *((src + 6) + 56) = (short )(tmp___98 >> 5);
#line 771
  if (t1___5 + t6___5 > 32767) {
#line 771
    tmp___100 = 32767;
  } else {
#line 771
    if (t1___5 + t6___5 < -32768) {
#line 771
      tmp___99 = -32768;
    } else {
#line 771
      tmp___99 = t1___5 + t6___5;
    }
#line 771
    tmp___100 = tmp___99;
  }
#line 771
  *((src + 6) + 8) = (short )(tmp___100 >> 5);
#line 771
  if (t1___5 - t6___5 > 32767) {
#line 771
    tmp___102 = 32767;
  } else {
#line 771
    if (t1___5 - t6___5 < -32768) {
#line 771
      tmp___101 = -32768;
    } else {
#line 771
      tmp___101 = t1___5 - t6___5;
    }
#line 771
    tmp___102 = tmp___101;
  }
#line 771
  *((src + 6) + 48) = (short )(tmp___102 >> 5);
#line 771
  if (t2___5 + t5___5 > 32767) {
#line 771
    tmp___104 = 32767;
  } else {
#line 771
    if (t2___5 + t5___5 < -32768) {
#line 771
      tmp___103 = -32768;
    } else {
#line 771
      tmp___103 = t2___5 + t5___5;
    }
#line 771
    tmp___104 = tmp___103;
  }
#line 771
  *((src + 6) + 16) = (short )(tmp___104 >> 5);
#line 771
  if (t2___5 - t5___5 > 32767) {
#line 771
    tmp___106 = 32767;
  } else {
#line 771
    if (t2___5 - t5___5 < -32768) {
#line 771
      tmp___105 = -32768;
    } else {
#line 771
      tmp___105 = t2___5 - t5___5;
    }
#line 771
    tmp___106 = tmp___105;
  }
#line 771
  *((src + 6) + 40) = (short )(tmp___106 >> 5);
#line 771
  if (t3___5 + t4___5 > 32767) {
#line 771
    tmp___108 = 32767;
  } else {
#line 771
    if (t3___5 + t4___5 < -32768) {
#line 771
      tmp___107 = -32768;
    } else {
#line 771
      tmp___107 = t3___5 + t4___5;
    }
#line 771
    tmp___108 = tmp___107;
  }
#line 771
  *((src + 6) + 24) = (short )(tmp___108 >> 5);
#line 771
  if (t3___5 - t4___5 > 32767) {
#line 771
    tmp___110 = 32767;
  } else {
#line 771
    if (t3___5 - t4___5 < -32768) {
#line 771
      tmp___109 = -32768;
    } else {
#line 771
      tmp___109 = t3___5 - t4___5;
    }
#line 771
    tmp___110 = tmp___109;
  }
#line 771
  *((src + 6) + 32) = (short )(tmp___110 >> 5);
#line 772
  tp765___6 = (int )*((src + 7) + 8) + ((int )*((src + 7) + 56) * 13036 >> 16);
#line 772
  tp465___6 = ((int )*((src + 7) + 8) * 13036 >> 16) - (int )*((src + 7) + 56);
#line 772
  tm765___6 = (((int )*((src + 7) + 40) * -21746 >> 16) + (int )*((src + 7) + 40)) + (int )*((src + 7) + 24);
#line 772
  tm465___6 = ((int )*((src + 7) + 40) - ((int )*((src + 7) + 24) * -21746 >> 16)) - (int )*((src + 7) + 24);
#line 772
  t7___6 = (tp765___6 + tm765___6) + 1;
#line 772
  tp65___6 = tp765___6 - tm765___6;
#line 772
  t4___6 = tp465___6 + tm465___6;
#line 772
  tm65___6 = (tp465___6 - tm465___6) + 1;
#line 772
  t6___6 = ((tp65___6 + tm65___6) * -19195 >> 16) | 1;
#line 772
  t6___6 += tp65___6 + tm65___6;
#line 772
  t5___6 = ((tp65___6 - tm65___6) * -19195 >> 16) | 1;
#line 772
  t5___6 += tp65___6 - tm65___6;
#line 772
  tp03___6 = (int )*((src + 7) + 0) + (int )*((src + 7) + 32);
#line 772
  tp12___6 = (int )*((src + 7) + 0) - (int )*((src + 7) + 32);
#line 772
  tm03___6 = (int )*((src + 7) + 16) + ((int )*((src + 7) + 48) * 27146 >> 16);
#line 772
  tm12___6 = ((int )*((src + 7) + 16) * 27146 >> 16) - (int )*((src + 7) + 48);
#line 772
  t0___6 = (tp03___6 + tm03___6) + 16;
#line 772
  t3___6 = (tp03___6 - tm03___6) + (int )RND_INV_CORR;
#line 772
  t1___6 = (tp12___6 + tm12___6) + 16;
#line 772
  t2___6 = (tp12___6 - tm12___6) + (int )RND_INV_CORR;
#line 772
  if (t0___6 + t7___6 > 32767) {
#line 772
    tmp___112 = 32767;
  } else {
#line 772
    if (t0___6 + t7___6 < -32768) {
#line 772
      tmp___111 = -32768;
    } else {
#line 772
      tmp___111 = t0___6 + t7___6;
    }
#line 772
    tmp___112 = tmp___111;
  }
#line 772
  *((src + 7) + 0) = (short )(tmp___112 >> 5);
#line 772
  if (t0___6 - t7___6 > 32767) {
#line 772
    tmp___114 = 32767;
  } else {
#line 772
    if (t0___6 - t7___6 < -32768) {
#line 772
      tmp___113 = -32768;
    } else {
#line 772
      tmp___113 = t0___6 - t7___6;
    }
#line 772
    tmp___114 = tmp___113;
  }
#line 772
  *((src + 7) + 56) = (short )(tmp___114 >> 5);
#line 772
  if (t1___6 + t6___6 > 32767) {
#line 772
    tmp___116 = 32767;
  } else {
#line 772
    if (t1___6 + t6___6 < -32768) {
#line 772
      tmp___115 = -32768;
    } else {
#line 772
      tmp___115 = t1___6 + t6___6;
    }
#line 772
    tmp___116 = tmp___115;
  }
#line 772
  *((src + 7) + 8) = (short )(tmp___116 >> 5);
#line 772
  if (t1___6 - t6___6 > 32767) {
#line 772
    tmp___118 = 32767;
  } else {
#line 772
    if (t1___6 - t6___6 < -32768) {
#line 772
      tmp___117 = -32768;
    } else {
#line 772
      tmp___117 = t1___6 - t6___6;
    }
#line 772
    tmp___118 = tmp___117;
  }
#line 772
  *((src + 7) + 48) = (short )(tmp___118 >> 5);
#line 772
  if (t2___6 + t5___6 > 32767) {
#line 772
    tmp___120 = 32767;
  } else {
#line 772
    if (t2___6 + t5___6 < -32768) {
#line 772
      tmp___119 = -32768;
    } else {
#line 772
      tmp___119 = t2___6 + t5___6;
    }
#line 772
    tmp___120 = tmp___119;
  }
#line 772
  *((src + 7) + 16) = (short )(tmp___120 >> 5);
#line 772
  if (t2___6 - t5___6 > 32767) {
#line 772
    tmp___122 = 32767;
  } else {
#line 772
    if (t2___6 - t5___6 < -32768) {
#line 772
      tmp___121 = -32768;
    } else {
#line 772
      tmp___121 = t2___6 - t5___6;
    }
#line 772
    tmp___122 = tmp___121;
  }
#line 772
  *((src + 7) + 40) = (short )(tmp___122 >> 5);
#line 772
  if (t3___6 + t4___6 > 32767) {
#line 772
    tmp___124 = 32767;
  } else {
#line 772
    if (t3___6 + t4___6 < -32768) {
#line 772
      tmp___123 = -32768;
    } else {
#line 772
      tmp___123 = t3___6 + t4___6;
    }
#line 772
    tmp___124 = tmp___123;
  }
#line 772
  *((src + 7) + 24) = (short )(tmp___124 >> 5);
#line 772
  if (t3___6 - t4___6 > 32767) {
#line 772
    tmp___126 = 32767;
  } else {
#line 772
    if (t3___6 - t4___6 < -32768) {
#line 772
      tmp___125 = -32768;
    } else {
#line 772
      tmp___125 = t3___6 - t4___6;
    }
#line 772
    tmp___126 = tmp___125;
  }
#line 772
  *((src + 7) + 32) = (short )(tmp___126 >> 5);
#line 773
  return;
}
}
#line 786 "src/idct.c"
void Fast_IDCT(short *block ) 
{ 


  {
#line 1014
  idct_M128ASM_scalar(block);
#line 1017
  return;
}
}
#line 1020 "src/idct.c"
void Initialize_Fast_IDCT(void) 
{ 


  {
#line 1040
  return;
}
}
#line 1 "idctref.o"
#pragma merger("0","/tmp/cil-utAwrIkD.i","-g,-O4")
#line 63 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h"
extern  __attribute__((__nothrow__)) double ( __attribute__((__leaf__)) cos)(double __x ) ;
#line 157
extern  __attribute__((__nothrow__)) double ( __attribute__((__leaf__)) sqrt)(double __x ) ;
#line 185
extern  __attribute__((__nothrow__)) double ( __attribute__((__leaf__)) floor)(double __x )  __attribute__((__const__)) ;
#line 150 "/usr/include/x86_64-linux-gnu/bits/mathinline.h"
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__, __always_inline__)) __signbitl)(long double __x )  __attribute__((__const__)) ;
#line 150 "/usr/include/x86_64-linux-gnu/bits/mathinline.h"
__inline extern int ( __attribute__((__leaf__, __always_inline__)) __signbitl)(long double __x ) 
{ 
  union __anonunion___u_3___0 __u ;

  {
#line 153
  __u.__l = __x;
#line 154
  return ((__u.__i[2] & 32768) != 0);
}
}
#line 108 "src/idctref.c"
static double c[8][8]  ;
#line 112 "src/idctref.c"
void Initialize_Reference_IDCT(void) 
{ 
  int freq ;
  int time ;
  double scale ;
  double tmp ;
  double tmp___0 ;

  {
#line 117
  freq = 0;
#line 117
  while (freq < 8) {
#line 119
    if (freq == 0) {
#line 119
      tmp = sqrt(0.125);
#line 119
      scale = tmp;
    } else {
#line 119
      scale = 0.5;
    }
#line 120
    time = 0;
#line 120
    while (time < 8) {
#line 121
      tmp___0 = cos(((3.14159265358979323846 / 8.0) * (double )freq) * ((double )time + 0.5));
#line 121
      c[freq][time] = scale * tmp___0;
#line 120
      time ++;
    }
#line 117
    freq ++;
  }
#line 123
  return;
}
}
#line 127 "src/idctref.c"
void Reference_IDCT(short *block ) 
{ 
  int i ;
  int j ;
  int k ;
  int v ;
  double partial_product ;
  double tmp[64] ;
  double tmp___0 ;
  int tmp___1 ;

  {
#line 134
  i = 0;
#line 134
  while (i < 8) {
#line 135
    j = 0;
#line 135
    while (j < 8) {
#line 137
      partial_product = 0.0;
#line 139
      k = 0;
#line 139
      while (k < 8) {
#line 140
        partial_product += c[k][j] * (double )*(block + (8 * i + k));
#line 139
        k ++;
      }
#line 142
      tmp[8 * i + j] = partial_product;
#line 135
      j ++;
    }
#line 134
    i ++;
  }
#line 148
  j = 0;
#line 148
  while (j < 8) {
#line 149
    i = 0;
#line 149
    while (i < 8) {
#line 151
      partial_product = 0.0;
#line 153
      k = 0;
#line 153
      while (k < 8) {
#line 154
        partial_product += c[k][i] * tmp[8 * k + j];
#line 153
        k ++;
      }
#line 156
      tmp___0 = floor(partial_product + 0.5);
#line 156
      v = (int )tmp___0;
#line 157
      if (v < -256) {
#line 157
        *(block + (8 * i + j)) = (short)-256;
      } else {
#line 157
        if (v > 255) {
#line 157
          tmp___1 = 255;
        } else {
#line 157
          tmp___1 = v;
        }
#line 157
        *(block + (8 * i + j)) = (short )tmp___1;
      }
#line 149
      i ++;
    }
#line 148
    j ++;
  }
#line 159
  return;
}
}
#line 1 "motion.o"
#pragma merger("0","/tmp/cil-sGUgrv1q.i","-g,-O4")
#line 166 "src/global.h"
void motion_vectors(int (*PMV)[2][2] , int *dmvector , int (*motion_vertical_field_select)[2] ,
                    int s , int motion_vector_count , int mv_format , int h_r_size ,
                    int v_r_size , int dmv , int mvscale ) ;
#line 169
void motion_vector(int *PMV , int *dmvector , int h_r_size , int v_r_size , int dmv ,
                   int mvscale , int full_pel_vector ) ;
#line 171
void Dual_Prime_Arithmetic(int (*DMV)[2] , int *dmvector , int mvx , int mvy ) ;
#line 87 "src/motion.c"
static void decode_motion_vector(int *pred , int r_size , int motion_code , int motion_residual ,
                                 int full_pel_vector ) ;
#line 91 "src/motion.c"
void motion_vectors(int (*PMV)[2][2] , int *dmvector , int (*motion_vertical_field_select)[2] ,
                    int s , int motion_vector_count , int mv_format , int h_r_size ,
                    int v_r_size , int dmv , int mvscale ) 
{ 
  int tmp ;
  unsigned int tmp___0 ;
  unsigned int tmp___1 ;
  unsigned int tmp___2 ;

  {
#line 98
  if (motion_vector_count == 1) {
#line 100
    if (mv_format == 0) {
#line 100
      if (! dmv) {
#line 102
        tmp___0 = Get_Bits(1);
#line 102
        tmp = (int )tmp___0;
#line 102
        (*(motion_vertical_field_select + 0))[s] = tmp;
#line 102
        (*(motion_vertical_field_select + 1))[s] = tmp;
      }
    }
#line 112
    motion_vector((*(PMV + 0))[s], (int *)dmvector, h_r_size, v_r_size, dmv, mvscale,
                  0);
#line 115
    (*(PMV + 1))[s][0] = (*(PMV + 0))[s][0];
#line 116
    (*(PMV + 1))[s][1] = (*(PMV + 0))[s][1];
  } else {
#line 120
    tmp___1 = Get_Bits(1);
#line 120
    (*(motion_vertical_field_select + 0))[s] = (int )tmp___1;
#line 128
    motion_vector((*(PMV + 0))[s], (int *)dmvector, h_r_size, v_r_size, dmv, mvscale,
                  0);
#line 130
    tmp___2 = Get_Bits(1);
#line 130
    (*(motion_vertical_field_select + 1))[s] = (int )tmp___2;
#line 138
    motion_vector((*(PMV + 1))[s], (int *)dmvector, h_r_size, v_r_size, dmv, mvscale,
                  0);
  }
#line 140
  return;
}
}
#line 144 "src/motion.c"
void motion_vector(int *PMV , int *dmvector , int h_r_size , int v_r_size , int dmv ,
                   int mvscale , int full_pel_vector ) 
{ 
  int motion_code ;
  int motion_residual ;
  unsigned int tmp ;
  unsigned int tmp___0 ;

  {
#line 158
  motion_code = Get_motion_code();
#line 160
  if (h_r_size != 0) {
#line 160
    if (motion_code != 0) {
#line 160
      tmp = Get_Bits(h_r_size);
#line 160
      motion_residual = (int )tmp;
    } else {
#line 160
      motion_residual = 0;
    }
  } else {
#line 160
    motion_residual = 0;
  }
#line 175
  decode_motion_vector(PMV + 0, h_r_size, motion_code, motion_residual, full_pel_vector);
#line 177
  if (dmv) {
#line 178
    *(dmvector + 0) = Get_dmvector();
  }
#line 182
  motion_code = Get_motion_code();
#line 183
  if (v_r_size != 0) {
#line 183
    if (motion_code != 0) {
#line 183
      tmp___0 = Get_Bits(v_r_size);
#line 183
      motion_residual = (int )tmp___0;
    } else {
#line 183
      motion_residual = 0;
    }
  } else {
#line 183
    motion_residual = 0;
  }
#line 197
  if (mvscale) {
#line 198
    *(PMV + 1) >>= 1;
  }
#line 200
  decode_motion_vector(PMV + 1, v_r_size, motion_code, motion_residual, full_pel_vector);
#line 202
  if (mvscale) {
#line 203
    *(PMV + 1) <<= 1;
  }
#line 205
  if (dmv) {
#line 206
    *(dmvector + 1) = Get_dmvector();
  }
#line 212
  return;
}
}
#line 219 "src/motion.c"
static void decode_motion_vector(int *pred , int r_size , int motion_code , int motion_residual ,
                                 int full_pel_vector ) 
{ 
  int lim ;
  int vec ;

  {
#line 226
  lim = 16 << r_size;
#line 227
  if (full_pel_vector) {
#line 227
    vec = *pred >> 1;
  } else {
#line 227
    vec = *pred;
  }
#line 229
  if (motion_code > 0) {
#line 231
    vec += (((motion_code - 1) << r_size) + motion_residual) + 1;
#line 232
    if (vec >= lim) {
#line 233
      vec -= lim + lim;
    }
  } else
#line 235
  if (motion_code < 0) {
#line 237
    vec -= (((- motion_code - 1) << r_size) + motion_residual) + 1;
#line 238
    if (vec < - lim) {
#line 239
      vec += lim + lim;
    }
  }
#line 241
  if (full_pel_vector) {
#line 241
    *pred = vec << 1;
  } else {
#line 241
    *pred = vec;
  }
#line 242
  return;
}
}
#line 246 "src/motion.c"
void Dual_Prime_Arithmetic(int (*DMV)[2] , int *dmvector , int mvx , int mvy ) 
{ 


  {
#line 251
  if (picture_structure == 3) {
#line 253
    if (top_field_first) {
#line 256
      (*(DMV + 0))[0] = ((mvx + (mvx > 0)) >> 1) + *(dmvector + 0);
#line 257
      (*(DMV + 0))[1] = (((mvy + (mvy > 0)) >> 1) + *(dmvector + 1)) - 1;
#line 260
      (*(DMV + 1))[0] = ((3 * mvx + (mvx > 0)) >> 1) + *(dmvector + 0);
#line 261
      (*(DMV + 1))[1] = (((3 * mvy + (mvy > 0)) >> 1) + *(dmvector + 1)) + 1;
    } else {
#line 266
      (*(DMV + 0))[0] = ((3 * mvx + (mvx > 0)) >> 1) + *(dmvector + 0);
#line 267
      (*(DMV + 0))[1] = (((3 * mvy + (mvy > 0)) >> 1) + *(dmvector + 1)) - 1;
#line 270
      (*(DMV + 1))[0] = ((mvx + (mvx > 0)) >> 1) + *(dmvector + 0);
#line 271
      (*(DMV + 1))[1] = (((mvy + (mvy > 0)) >> 1) + *(dmvector + 1)) + 1;
    }
  } else {
#line 277
    (*(DMV + 0))[0] = ((mvx + (mvx > 0)) >> 1) + *(dmvector + 0);
#line 278
    (*(DMV + 0))[1] = ((mvy + (mvy > 0)) >> 1) + *(dmvector + 1);
#line 281
    if (picture_structure == 1) {
#line 282
      ((*(DMV + 0))[1]) --;
    } else {
#line 284
      ((*(DMV + 0))[1]) ++;
    }
  }
#line 286
  return;
}
}
#line 289 "src/motion.c"
void Thrd_motion_vectors(int t , int (*PMV)[2][2] , int *dmvector , int (*motion_vertical_field_select)[2] ,
                         int s , int motion_vector_count , int mv_format , int h_r_size ,
                         int v_r_size , int dmv , int mvscale ) 
{ 
  int tmp ;
  unsigned int tmp___0 ;
  unsigned int tmp___1 ;
  unsigned int tmp___2 ;

  {
#line 297
  if (motion_vector_count == 1) {
#line 299
    if (mv_format == 0) {
#line 299
      if (! dmv) {
#line 301
        tmp___0 = Thrd_Get_Bits(t, 1);
#line 301
        tmp = (int )tmp___0;
#line 301
        (*(motion_vertical_field_select + 0))[s] = tmp;
#line 301
        (*(motion_vertical_field_select + 1))[s] = tmp;
      }
    }
#line 304
    Thrd_motion_vector(t, (*(PMV + 0))[s], (int *)dmvector, h_r_size, v_r_size, dmv,
                       mvscale, 0);
#line 307
    (*(PMV + 1))[s][0] = (*(PMV + 0))[s][0];
#line 308
    (*(PMV + 1))[s][1] = (*(PMV + 0))[s][1];
  } else {
#line 312
    tmp___1 = Thrd_Get_Bits(t, 1);
#line 312
    (*(motion_vertical_field_select + 0))[s] = (int )tmp___1;
#line 313
    Thrd_motion_vector(t, (*(PMV + 0))[s], (int *)dmvector, h_r_size, v_r_size, dmv,
                       mvscale, 0);
#line 315
    tmp___2 = Thrd_Get_Bits(t, 1);
#line 315
    (*(motion_vertical_field_select + 1))[s] = (int )tmp___2;
#line 316
    Thrd_motion_vector(t, (*(PMV + 1))[s], (int *)dmvector, h_r_size, v_r_size, dmv,
                       mvscale, 0);
  }
#line 318
  return;
}
}
#line 322 "src/motion.c"
void Thrd_motion_vector(int t , int *PMV , int *dmvector , int h_r_size , int v_r_size ,
                        int dmv , int mvscale , int full_pel_vector ) 
{ 
  int motion_code ;
  int motion_residual ;
  unsigned int tmp ;
  unsigned int tmp___0 ;

  {
#line 337
  motion_code = Thrd_Get_motion_code(t);
#line 339
  if (h_r_size != 0) {
#line 339
    if (motion_code != 0) {
#line 339
      tmp = Thrd_Get_Bits(t, h_r_size);
#line 339
      motion_residual = (int )tmp;
    } else {
#line 339
      motion_residual = 0;
    }
  } else {
#line 339
    motion_residual = 0;
  }
#line 341
  decode_motion_vector(PMV + 0, h_r_size, motion_code, motion_residual, full_pel_vector);
#line 343
  if (dmv) {
#line 344
    *(dmvector + 0) = Thrd_Get_dmvector(t);
  }
#line 348
  motion_code = Thrd_Get_motion_code(t);
#line 349
  if (v_r_size != 0) {
#line 349
    if (motion_code != 0) {
#line 349
      tmp___0 = Thrd_Get_Bits(t, v_r_size);
#line 349
      motion_residual = (int )tmp___0;
    } else {
#line 349
      motion_residual = 0;
    }
  } else {
#line 349
    motion_residual = 0;
  }
#line 351
  if (mvscale) {
#line 352
    *(PMV + 1) >>= 1;
  }
#line 354
  decode_motion_vector(PMV + 1, v_r_size, motion_code, motion_residual, full_pel_vector);
#line 356
  if (mvscale) {
#line 357
    *(PMV + 1) <<= 1;
  }
#line 359
  if (dmv) {
#line 360
    *(dmvector + 1) = Thrd_Get_dmvector(t);
  }
#line 362
  return;
}
}
/* compiler builtin: 
   int __builtin_va_arg_pack_len(void) ;  */
#line 1 "mpeg2dec.o"
#pragma merger("0","/tmp/cil-7tMx95DE.i","-g,-O4")
#line 465 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__warn_unused_result__,
__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 482
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 82 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) __int32_t const   **( __attribute__((__leaf__)) __ctype_tolower_loc)(void)  __attribute__((__const__)) ;
#line 84
extern  __attribute__((__nothrow__)) __int32_t const   **( __attribute__((__leaf__)) __ctype_toupper_loc)(void)  __attribute__((__const__)) ;
#line 125
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) tolower)(int __c ) ;
#line 128
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) toupper)(int __c ) ;
#line 215
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) tolower)(int __c ) ;
#line 215 "/usr/include/ctype.h"
__inline extern int ( __attribute__((__leaf__)) tolower)(int __c ) 
{ 
  __int32_t const   **tmp ;
  __int32_t tmp___0 ;

  {
#line 218
  if (__c >= -128) {
#line 218
    if (__c < 256) {
#line 218
      tmp = __ctype_tolower_loc();
#line 218
      tmp___0 = *(*tmp + __c);
    } else {
#line 218
      tmp___0 = (__int32_t const   )__c;
    }
  } else {
#line 218
    tmp___0 = (__int32_t const   )__c;
  }
#line 218
  return ((int )tmp___0);
}
}
#line 221
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) toupper)(int __c ) ;
#line 221 "/usr/include/ctype.h"
__inline extern int ( __attribute__((__leaf__)) toupper)(int __c ) 
{ 
  __int32_t const   **tmp ;
  __int32_t tmp___0 ;

  {
#line 224
  if (__c >= -128) {
#line 224
    if (__c < 256) {
#line 224
      tmp = __ctype_toupper_loc();
#line 224
      tmp___0 = *(*tmp + __c);
    } else {
#line 224
      tmp___0 = (__int32_t const   )__c;
    }
  } else {
#line 224
    tmp___0 = (__int32_t const   )__c;
  }
#line 224
  return ((int )tmp___0);
}
}
#line 146 "/usr/include/fcntl.h"
__inline extern int ( __attribute__((__nonnull__(1), __artificial__, __always_inline__)) open)(char const   *__path ,
                                                                                               int __oflag 
                                                                                               , ...) ;
#line 170
__inline extern int ( __attribute__((__nonnull__(2), __artificial__, __always_inline__)) openat)(int __fd ,
                                                                                                 char const   *__path ,
                                                                                                 int __oflag 
                                                                                                 , ...) ;
#line 26 "/usr/include/x86_64-linux-gnu/bits/fcntl2.h"
extern int ( __attribute__((__nonnull__(1))) __open_2)(char const   *__path , int __oflag ) ;
#line 27
extern int ( __attribute__((__nonnull__(1))) __open_alias)(char const   *__path ,
                                                           int __oflag  , ...)  __asm__("open")  ;
#line 35
extern void __open_too_many_args(void)  __attribute__((__error__("open can be called either with 2 or 3 arguments, not more"))) ;
#line 40 "/usr/include/x86_64-linux-gnu/bits/fcntl2.h"
__inline extern int ( __attribute__((__nonnull__(1), __artificial__, __always_inline__)) open)(char const   *__path ,
                                                                                               int __oflag 
                                                                                               , ...) 
{ 
  int tmp ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
#line 43
  tmp = __builtin_va_arg_pack_len();
#line 43
  if (tmp > 1) {
#line 44
    __open_too_many_args();
  }
#line 56
  tmp___4 = __builtin_va_arg_pack_len();
#line 56
  if (tmp___4 < 1) {
#line 57
    tmp___3 = __open_2(__path, __oflag);
#line 57
    return (tmp___3);
  }
#line 59
  tmp___5 = __open_alias(__path, __oflag, __builtin_va_arg_pack());
#line 59
  return (tmp___5);
}
}
#line 98
extern int ( __attribute__((__nonnull__(2))) __openat_2)(int __fd , char const   *__path ,
                                                         int __oflag ) ;
#line 100
extern int ( __attribute__((__nonnull__(2))) __openat_alias)(int __fd , char const   *__path ,
                                                             int __oflag  , ...)  __asm__("openat")  ;
#line 111
extern void __openat_too_many_args(void)  __attribute__((__error__("openat can be called either with 3 or 4 arguments, not more"))) ;
#line 116 "/usr/include/x86_64-linux-gnu/bits/fcntl2.h"
__inline extern int ( __attribute__((__nonnull__(2), __artificial__, __always_inline__)) openat)(int __fd ,
                                                                                                 char const   *__path ,
                                                                                                 int __oflag 
                                                                                                 , ...) 
{ 
  int tmp ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
#line 119
  tmp = __builtin_va_arg_pack_len();
#line 119
  if (tmp > 1) {
#line 120
    __openat_too_many_args();
  }
#line 132
  tmp___4 = __builtin_va_arg_pack_len();
#line 132
  if (tmp___4 < 1) {
#line 133
    tmp___3 = __openat_2(__fd, __path, __oflag);
#line 133
    return (tmp___3);
  }
#line 135
  tmp___5 = __openat_alias(__fd, __path, __oflag, __builtin_va_arg_pack());
#line 135
  return (tmp___5);
}
}
#line 334 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) __off_t ( __attribute__((__leaf__)) lseek)(int __fd ,
                                                                                __off_t __offset ,
                                                                                int __whence ) ;
#line 353
extern int close(int __fd ) ;
#line 183 "src/global.h"
void Print_Bits(int code , int bits , int len ) ;
#line 228 "src/global.h"
char Version[28]  = 
#line 228
  {      (char )'m',      (char )'p',      (char )'e',      (char )'g', 
        (char )'2',      (char )'d',      (char )'e',      (char )'c', 
        (char )'o',      (char )'d',      (char )'e',      (char )' ', 
        (char )'V',      (char )'1',      (char )'.',      (char )'2', 
        (char )'a',      (char )',',      (char )' ',      (char )'9', 
        (char )'6',      (char )'/',      (char )'0',      (char )'7', 
        (char )'/',      (char )'1',      (char )'9',      (char )'\000'};
#line 234 "src/global.h"
char Author[41]  = 
#line 234
  {      (char )'(',      (char )'C',      (char )')',      (char )' ', 
        (char )'1',      (char )'9',      (char )'9',      (char )'6', 
        (char )',',      (char )' ',      (char )'M',      (char )'P', 
        (char )'E',      (char )'G',      (char )' ',      (char )'S', 
        (char )'o',      (char )'f',      (char )'t',      (char )'w', 
        (char )'a',      (char )'r',      (char )'e',      (char )' ', 
        (char )'S',      (char )'i',      (char )'m',      (char )'u', 
        (char )'l',      (char )'a',      (char )'t',      (char )'i', 
        (char )'o',      (char )'n',      (char )' ',      (char )'G', 
        (char )'r',      (char )'o',      (char )'u',      (char )'p', 
        (char )'\000'};
#line 242 "src/global.h"
unsigned char scan[2][64]  = { {        (unsigned char)0,        (unsigned char)1,        (unsigned char)8,        (unsigned char)16, 
            (unsigned char)9,        (unsigned char)2,        (unsigned char)3,        (unsigned char)10, 
            (unsigned char)17,        (unsigned char)24,        (unsigned char)32,        (unsigned char)25, 
            (unsigned char)18,        (unsigned char)11,        (unsigned char)4,        (unsigned char)5, 
            (unsigned char)12,        (unsigned char)19,        (unsigned char)26,        (unsigned char)33, 
            (unsigned char)40,        (unsigned char)48,        (unsigned char)41,        (unsigned char)34, 
            (unsigned char)27,        (unsigned char)20,        (unsigned char)13,        (unsigned char)6, 
            (unsigned char)7,        (unsigned char)14,        (unsigned char)21,        (unsigned char)28, 
            (unsigned char)35,        (unsigned char)42,        (unsigned char)49,        (unsigned char)56, 
            (unsigned char)57,        (unsigned char)50,        (unsigned char)43,        (unsigned char)36, 
            (unsigned char)29,        (unsigned char)22,        (unsigned char)15,        (unsigned char)23, 
            (unsigned char)30,        (unsigned char)37,        (unsigned char)44,        (unsigned char)51, 
            (unsigned char)58,        (unsigned char)59,        (unsigned char)52,        (unsigned char)45, 
            (unsigned char)38,        (unsigned char)31,        (unsigned char)39,        (unsigned char)46, 
            (unsigned char)53,        (unsigned char)60,        (unsigned char)61,        (unsigned char)54, 
            (unsigned char)47,        (unsigned char)55,        (unsigned char)62,        (unsigned char)63}, 
   {        (unsigned char)0,        (unsigned char)8,        (unsigned char)16,        (unsigned char)24, 
            (unsigned char)1,        (unsigned char)9,        (unsigned char)2,        (unsigned char)10, 
            (unsigned char)17,        (unsigned char)25,        (unsigned char)32,        (unsigned char)40, 
            (unsigned char)48,        (unsigned char)56,        (unsigned char)57,        (unsigned char)49, 
            (unsigned char)41,        (unsigned char)33,        (unsigned char)26,        (unsigned char)18, 
            (unsigned char)3,        (unsigned char)11,        (unsigned char)4,        (unsigned char)12, 
            (unsigned char)19,        (unsigned char)27,        (unsigned char)34,        (unsigned char)42, 
            (unsigned char)50,        (unsigned char)58,        (unsigned char)35,        (unsigned char)43, 
            (unsigned char)51,        (unsigned char)59,        (unsigned char)20,        (unsigned char)28, 
            (unsigned char)5,        (unsigned char)13,        (unsigned char)6,        (unsigned char)14, 
            (unsigned char)21,        (unsigned char)29,        (unsigned char)36,        (unsigned char)44, 
            (unsigned char)52,        (unsigned char)60,        (unsigned char)37,        (unsigned char)45, 
            (unsigned char)53,        (unsigned char)61,        (unsigned char)22,        (unsigned char)30, 
            (unsigned char)7,        (unsigned char)15,        (unsigned char)23,        (unsigned char)31, 
            (unsigned char)38,        (unsigned char)46,        (unsigned char)54,        (unsigned char)62, 
            (unsigned char)39,        (unsigned char)47,        (unsigned char)55,        (unsigned char)63}};
#line 263 "src/global.h"
unsigned char default_intra_quantizer_matrix[64]  = 
#line 263
  {      (unsigned char)8,      (unsigned char)16,      (unsigned char)19,      (unsigned char)22, 
        (unsigned char)26,      (unsigned char)27,      (unsigned char)29,      (unsigned char)34, 
        (unsigned char)16,      (unsigned char)16,      (unsigned char)22,      (unsigned char)24, 
        (unsigned char)27,      (unsigned char)29,      (unsigned char)34,      (unsigned char)37, 
        (unsigned char)19,      (unsigned char)22,      (unsigned char)26,      (unsigned char)27, 
        (unsigned char)29,      (unsigned char)34,      (unsigned char)34,      (unsigned char)38, 
        (unsigned char)22,      (unsigned char)22,      (unsigned char)26,      (unsigned char)27, 
        (unsigned char)29,      (unsigned char)34,      (unsigned char)37,      (unsigned char)40, 
        (unsigned char)22,      (unsigned char)26,      (unsigned char)27,      (unsigned char)29, 
        (unsigned char)32,      (unsigned char)35,      (unsigned char)40,      (unsigned char)48, 
        (unsigned char)26,      (unsigned char)27,      (unsigned char)29,      (unsigned char)32, 
        (unsigned char)35,      (unsigned char)40,      (unsigned char)48,      (unsigned char)58, 
        (unsigned char)26,      (unsigned char)27,      (unsigned char)29,      (unsigned char)34, 
        (unsigned char)38,      (unsigned char)46,      (unsigned char)56,      (unsigned char)69, 
        (unsigned char)27,      (unsigned char)29,      (unsigned char)35,      (unsigned char)38, 
        (unsigned char)46,      (unsigned char)56,      (unsigned char)69,      (unsigned char)83};
#line 280 "src/global.h"
unsigned char Non_Linear_quantizer_scale[32]  = 
#line 280
  {      (unsigned char)0,      (unsigned char)1,      (unsigned char)2,      (unsigned char)3, 
        (unsigned char)4,      (unsigned char)5,      (unsigned char)6,      (unsigned char)7, 
        (unsigned char)8,      (unsigned char)10,      (unsigned char)12,      (unsigned char)14, 
        (unsigned char)16,      (unsigned char)18,      (unsigned char)20,      (unsigned char)22, 
        (unsigned char)24,      (unsigned char)28,      (unsigned char)32,      (unsigned char)36, 
        (unsigned char)40,      (unsigned char)44,      (unsigned char)48,      (unsigned char)52, 
        (unsigned char)56,      (unsigned char)64,      (unsigned char)72,      (unsigned char)80, 
        (unsigned char)88,      (unsigned char)96,      (unsigned char)104,      (unsigned char)112};
#line 307 "src/global.h"
int Inverse_Table_6_9[8][4]  = 
#line 307
  { {        117504,        138453,        13954,        34903}, 
   {        117504,        138453,        13954,        34903}, 
   {        104597,        132201,        25675,        53279}, 
   {        104597,        132201,        25675,        53279}, 
   {        104448,        132798,        24759,        53109}, 
   {        104597,        132201,        25675,        53279}, 
   {        104597,        132201,        25675,        53279}, 
   {        117579,        136230,        16907,        35559}};
#line 336 "src/global.h"
int Output_Type  ;
#line 337 "src/global.h"
int hiQdither  ;
#line 340 "src/global.h"
int Quiet_Flag  ;
#line 341 "src/global.h"
int Trace_Flag  ;
#line 342 "src/global.h"
int Fault_Flag  ;
#line 343 "src/global.h"
int Verbose_Flag  ;
#line 344 "src/global.h"
int Two_Streams  ;
#line 345 "src/global.h"
int Spatial_Flag  ;
#line 346 "src/global.h"
int Reference_IDCT_Flag  ;
#line 347 "src/global.h"
int Frame_Store_Flag  ;
#line 348 "src/global.h"
int System_Stream_Flag  ;
#line 349 "src/global.h"
int Display_Progressive_Flag  ;
#line 350 "src/global.h"
int Ersatz_Flag  ;
#line 351 "src/global.h"
int Big_Picture_Flag  ;
#line 352 "src/global.h"
int Verify_Flag  ;
#line 353 "src/global.h"
int Stats_Flag  ;
#line 354 "src/global.h"
int User_Data_Flag  ;
#line 355 "src/global.h"
int Main_Bitstream_Flag  ;
#line 359 "src/global.h"
char *Output_Picture_Filename  ;
#line 360 "src/global.h"
char *Substitute_Picture_Filename  ;
#line 361 "src/global.h"
char *Main_Bitstream_Filename  ;
#line 362 "src/global.h"
char *Enhancement_Layer_Bitstream_Filename  ;
#line 366 "src/global.h"
char Error_Text[256]  ;
#line 367 "src/global.h"
unsigned char *Clip  ;
#line 370 "src/global.h"
unsigned char *backward_reference_frame[3]  ;
#line 371 "src/global.h"
unsigned char *forward_reference_frame[3]  ;
#line 373 "src/global.h"
unsigned char *auxframe[3]  ;
#line 374 "src/global.h"
unsigned char *current_frame[3]  ;
#line 375 "src/global.h"
unsigned char *substitute_frame[3]  ;
#line 379 "src/global.h"
unsigned char *llframe0[3]  ;
#line 380 "src/global.h"
unsigned char *llframe1[3]  ;
#line 382 "src/global.h"
short *lltmp  ;
#line 383 "src/global.h"
char *Lower_Layer_Picture_Filename  ;
#line 389 "src/global.h"
int Coded_Picture_Width  ;
#line 390 "src/global.h"
int Coded_Picture_Height  ;
#line 391 "src/global.h"
int Chroma_Width  ;
#line 392 "src/global.h"
int Chroma_Height  ;
#line 393 "src/global.h"
int block_count  ;
#line 394 "src/global.h"
int Second_Field  ;
#line 395 "src/global.h"
int profile  ;
#line 395 "src/global.h"
int level  ;
#line 398 "src/global.h"
int horizontal_size  ;
#line 399 "src/global.h"
int vertical_size  ;
#line 400 "src/global.h"
int mb_width  ;
#line 401 "src/global.h"
int mb_height  ;
#line 402 "src/global.h"
double bit_rate  ;
#line 403 "src/global.h"
double frame_rate  ;
#line 410 "src/global.h"
int aspect_ratio_information  ;
#line 411 "src/global.h"
int frame_rate_code  ;
#line 412 "src/global.h"
int bit_rate_value  ;
#line 413 "src/global.h"
int vbv_buffer_size  ;
#line 414 "src/global.h"
int constrained_parameters_flag  ;
#line 417 "src/global.h"
int profile_and_level_indication  ;
#line 418 "src/global.h"
int progressive_sequence  ;
#line 419 "src/global.h"
int chroma_format  ;
#line 420 "src/global.h"
int low_delay  ;
#line 421 "src/global.h"
int frame_rate_extension_n  ;
#line 422 "src/global.h"
int frame_rate_extension_d  ;
#line 425 "src/global.h"
int video_format  ;
#line 426 "src/global.h"
int color_description  ;
#line 427 "src/global.h"
int color_primaries  ;
#line 428 "src/global.h"
int transfer_characteristics  ;
#line 429 "src/global.h"
int matrix_coefficients  ;
#line 430 "src/global.h"
int display_horizontal_size  ;
#line 431 "src/global.h"
int display_vertical_size  ;
#line 434 "src/global.h"
int temporal_reference  ;
#line 435 "src/global.h"
int picture_coding_type  ;
#line 436 "src/global.h"
int vbv_delay  ;
#line 437 "src/global.h"
int full_pel_forward_vector  ;
#line 438 "src/global.h"
int forward_f_code  ;
#line 439 "src/global.h"
int full_pel_backward_vector  ;
#line 440 "src/global.h"
int backward_f_code  ;
#line 444 "src/global.h"
int f_code[2][2]  ;
#line 445 "src/global.h"
int intra_dc_precision  ;
#line 446 "src/global.h"
int picture_structure  ;
#line 447 "src/global.h"
int top_field_first  ;
#line 448 "src/global.h"
int frame_pred_frame_dct  ;
#line 449 "src/global.h"
int concealment_motion_vectors  ;
#line 451 "src/global.h"
int intra_vlc_format  ;
#line 453 "src/global.h"
int repeat_first_field  ;
#line 455 "src/global.h"
int chroma_420_type  ;
#line 456 "src/global.h"
int progressive_frame  ;
#line 457 "src/global.h"
int composite_display_flag  ;
#line 458 "src/global.h"
int v_axis  ;
#line 459 "src/global.h"
int field_sequence  ;
#line 460 "src/global.h"
int sub_carrier  ;
#line 461 "src/global.h"
int burst_amplitude  ;
#line 462 "src/global.h"
int sub_carrier_phase  ;
#line 467 "src/global.h"
int frame_center_horizontal_offset[3]  ;
#line 468 "src/global.h"
int frame_center_vertical_offset[3]  ;
#line 473 "src/global.h"
int layer_id  ;
#line 474 "src/global.h"
int lower_layer_prediction_horizontal_size  ;
#line 475 "src/global.h"
int lower_layer_prediction_vertical_size  ;
#line 476 "src/global.h"
int horizontal_subsampling_factor_m  ;
#line 477 "src/global.h"
int horizontal_subsampling_factor_n  ;
#line 478 "src/global.h"
int vertical_subsampling_factor_m  ;
#line 479 "src/global.h"
int vertical_subsampling_factor_n  ;
#line 483 "src/global.h"
int lower_layer_temporal_reference  ;
#line 484 "src/global.h"
int lower_layer_horizontal_offset  ;
#line 485 "src/global.h"
int lower_layer_vertical_offset  ;
#line 486 "src/global.h"
int spatial_temporal_weight_code_table_index  ;
#line 487 "src/global.h"
int lower_layer_progressive_frame  ;
#line 488 "src/global.h"
int lower_layer_deinterlaced_field_select  ;
#line 496 "src/global.h"
int copyright_flag  ;
#line 497 "src/global.h"
int copyright_identifier  ;
#line 498 "src/global.h"
int original_or_copy  ;
#line 499 "src/global.h"
int copyright_number_1  ;
#line 500 "src/global.h"
int copyright_number_2  ;
#line 501 "src/global.h"
int copyright_number_3  ;
#line 504 "src/global.h"
int drop_flag  ;
#line 505 "src/global.h"
int hour  ;
#line 506 "src/global.h"
int minute  ;
#line 507 "src/global.h"
int sec  ;
#line 508 "src/global.h"
int frame  ;
#line 509 "src/global.h"
int closed_gop  ;
#line 510 "src/global.h"
int broken_link  ;
#line 515 "src/global.h"
struct layer_data base  ;
#line 515 "src/global.h"
struct layer_data enhan  ;
#line 515 "src/global.h"
struct layer_data *ld  ;
#line 571 "src/global.h"
int Decode_Layer  ;
#line 580 "src/global.h"
int global_MBA  ;
#line 581 "src/global.h"
int global_pic  ;
#line 582 "src/global.h"
int True_Framenum  ;
#line 94 "src/mpeg2dec.c"
static int video_sequence(int *Bitstream_Framenumber ) ;
#line 95
static int Decode_Bitstream(void) ;
#line 96
static int Headers(void) ;
#line 97
static void Initialize_Sequence(void) ;
#line 98
static void Initialize_Decoder(void) ;
#line 99
static void Deinitialize_Sequence(void) ;
#line 100
static void Process_Options(int argc , char **argv ) ;
#line 102
static void Initialize_Frame_Buffer(void) ;
#line 111
static void Clear_Options(void) ;
#line 116 "src/mpeg2dec.c"
int main(int argc , char **argv ) 
{ 
  int ret ;
  int code ;
  unsigned int tmp ;
  unsigned int tmp___0 ;

  {
#line 122
  Clear_Options();
#line 125
  Process_Options(argc, argv);
#line 131
  ld = & base;
#line 135
  base.Infile = open((char const   *)Main_Bitstream_Filename, 0);
#line 135
  if (base.Infile < 0) {
#line 137
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Base layer input file %s not found\n",
            Main_Bitstream_Filename);
#line 138
    exit(1);
  }
#line 142
  if (base.Infile != 0) {
#line 144
    Initialize_Buffer();
#line 146
    tmp = Show_Bits(8);
#line 146
    if (tmp == 71U) {
#line 148
      sprintf((char * __restrict  )(Error_Text), (char const   * __restrict  )"Decoder currently does not parse transport streams\n");
#line 149
      Error(Error_Text);
    }
#line 152
    next_start_code();
#line 153
    tmp___0 = Show_Bits(32);
#line 153
    code = (int )tmp___0;
#line 155
    switch (code) {
    case 435: 
#line 158
    break;
    case 442: 
#line 160
    System_Stream_Flag = 1;
    case 480: 
#line 162
    System_Stream_Flag = 1;
#line 163
    break;
    default: 
#line 165
    sprintf((char * __restrict  )(Error_Text), (char const   * __restrict  )"Unable to recognize stream type\n");
#line 166
    Error(Error_Text);
#line 167
    break;
    }
#line 170
    lseek(base.Infile, 0L, 0);
#line 171
    Initialize_Buffer();
  }
#line 173
  if (! (! System_Stream_Flag)) {
#line 173
    __assert_fail("!System_Stream_Flag", "src/mpeg2dec.c", 173U, "main");
  }
#line 175
  if (base.Infile != 0) {
#line 177
    lseek(base.Infile, 0L, 0);
  }
#line 180
  Initialize_Buffer();
#line 182
  if (! Two_Streams) {
#line 182
    if (! "I don\'t support two streams\n") {
#line 182
      __assert_fail("!Two_Streams&&\"I don\'t support two streams\\n\"", "src/mpeg2dec.c",
                    182U, "main");
    }
  } else {
#line 182
    __assert_fail("!Two_Streams&&\"I don\'t support two streams\\n\"", "src/mpeg2dec.c",
                  182U, "main");
  }
#line 183
  if (Two_Streams) {
#line 185
    ld = & enhan;
#line 187
    enhan.Infile = open((char const   *)Enhancement_Layer_Bitstream_Filename, 0);
#line 187
    if (enhan.Infile < 0) {
#line 189
      sprintf((char * __restrict  )(Error_Text), (char const   * __restrict  )"enhancment layer bitstream file %s not found\n",
              Enhancement_Layer_Bitstream_Filename);
#line 192
      Error(Error_Text);
    }
#line 195
    Initialize_Buffer();
#line 196
    ld = & base;
  }
#line 199
  Initialize_Decoder();
#line 201
  Initialize_Frame_Buffer();
#line 204
  ret = Decode_Bitstream();
#line 206
  close(base.Infile);
#line 208
  if (Two_Streams) {
#line 209
    close(enhan.Infile);
  }
#line 211
  return (0);
}
}
#line 215 "src/mpeg2dec.c"
static void Initialize_Frame_Buffer(void) 
{ 
  int i ;
  void *tmp ;

  {
#line 222
  i = 0;
#line 222
  while (i < 2) {
#line 223
    tb[i].frame_buf_size = 2048U;
#line 224
    tmp = malloc(sizeof(unsigned char ) * 2048UL);
#line 224
    tb[i].frame_buf = (unsigned char *)tmp;
#line 222
    i ++;
  }
#line 228
  return;
}
}
#line 232 "src/mpeg2dec.c"
static void Initialize_Decoder(void) 
{ 
  int i ;
  void *tmp ;
  int tmp___0 ;

  {
#line 237
  tmp = malloc((size_t )1024);
#line 237
  Clip = (unsigned char *)tmp;
#line 237
  if (! Clip) {
#line 238
    Error((char *)"Clip[] malloc failed\n");
  }
#line 240
  Clip += 384;
#line 242
  i = -384;
#line 242
  while (i < 640) {
#line 243
    if (i < 0) {
#line 243
      *(Clip + i) = (unsigned char)0;
    } else {
#line 243
      if (i > 255) {
#line 243
        tmp___0 = 255;
      } else {
#line 243
        tmp___0 = i;
      }
#line 243
      *(Clip + i) = (unsigned char )tmp___0;
    }
#line 242
    i ++;
  }
#line 246
  if (Reference_IDCT_Flag) {
#line 247
    Initialize_Reference_IDCT();
  } else {
#line 249
    Initialize_Fast_IDCT();
  }
#line 251
  return;
}
}
#line 257 "src/mpeg2dec.c"
static int Table_6_20[3]  = {      6,      8,      12};
#line 254 "src/mpeg2dec.c"
static void Initialize_Sequence(void) 
{ 
  int cc ;
  int size ;
  unsigned char *tmp ;
  void *tmp___0 ;
  unsigned char *tmp___1 ;
  void *tmp___2 ;
  unsigned char *tmp___3 ;
  void *tmp___4 ;
  unsigned char *tmp___5 ;
  void *tmp___6 ;
  unsigned char *tmp___7 ;
  int tmp___8 ;
  void *tmp___9 ;
  unsigned char *tmp___10 ;
  int tmp___11 ;
  void *tmp___12 ;
  void *tmp___13 ;

  {
#line 260
  if (Two_Streams) {
#line 260
    if (enhan.scalable_mode != 3) {
#line 260
      if (base.scalable_mode != 1) {
#line 261
        Error((char *)"unsupported scalability mode\n");
      }
    }
  }
#line 265
  if (! base.MPEG2_Flag) {
#line 267
    progressive_sequence = 1;
#line 268
    progressive_frame = 1;
#line 269
    picture_structure = 3;
#line 270
    frame_pred_frame_dct = 1;
#line 271
    chroma_format = 1;
#line 272
    matrix_coefficients = 5;
  }
#line 277
  mb_width = (horizontal_size + 15) / 16;
#line 278
  if (base.MPEG2_Flag) {
#line 278
    if (! progressive_sequence) {
#line 278
      mb_height = 2 * ((vertical_size + 31) / 32);
    } else {
#line 278
      mb_height = (vertical_size + 15) / 16;
    }
  } else {
#line 278
    mb_height = (vertical_size + 15) / 16;
  }
#line 281
  Coded_Picture_Width = 16 * mb_width;
#line 282
  Coded_Picture_Height = 16 * mb_height;
#line 284
  printf((char const   * __restrict  )"height %d width %d\n", Coded_Picture_Height,
         Coded_Picture_Width);
#line 287
  if (chroma_format == 3) {
#line 287
    Chroma_Width = Coded_Picture_Width;
  } else {
#line 287
    Chroma_Width = Coded_Picture_Width >> 1;
  }
#line 289
  if (chroma_format != 1) {
#line 289
    Chroma_Height = Coded_Picture_Height;
  } else {
#line 289
    Chroma_Height = Coded_Picture_Height >> 1;
  }
#line 293
  block_count = Table_6_20[chroma_format - 1];
#line 295
  cc = 0;
#line 295
  while (cc < 3) {
#line 297
    if (cc == 0) {
#line 298
      size = Coded_Picture_Width * Coded_Picture_Height;
    } else {
#line 300
      size = Chroma_Width * Chroma_Height;
    }
#line 302
    tmp___0 = malloc((size_t )size);
#line 302
    tmp = (unsigned char *)tmp___0;
#line 302
    backward_reference_frame[cc] = tmp;
#line 302
    if (! tmp) {
#line 303
      Error((char *)"backward_reference_frame[] malloc failed\n");
    }
#line 305
    tmp___2 = malloc((size_t )size);
#line 305
    tmp___1 = (unsigned char *)tmp___2;
#line 305
    forward_reference_frame[cc] = tmp___1;
#line 305
    if (! tmp___1) {
#line 306
      Error((char *)"forward_reference_frame[] malloc failed\n");
    }
#line 308
    tmp___4 = malloc((size_t )size);
#line 308
    tmp___3 = (unsigned char *)tmp___4;
#line 308
    auxframe[cc] = tmp___3;
#line 308
    if (! tmp___3) {
#line 309
      Error((char *)"auxframe[] malloc failed\n");
    }
#line 311
    if (Ersatz_Flag) {
#line 312
      tmp___6 = malloc((size_t )size);
#line 312
      tmp___5 = (unsigned char *)tmp___6;
#line 312
      substitute_frame[cc] = tmp___5;
#line 312
      if (! tmp___5) {
#line 313
        Error((char *)"substitute_frame[] malloc failed\n");
      }
    }
#line 316
    if (base.scalable_mode == 2) {
#line 319
      if (cc) {
#line 319
        tmp___8 = 4;
      } else {
#line 319
        tmp___8 = 1;
      }
#line 319
      tmp___9 = malloc((size_t )((lower_layer_prediction_horizontal_size * lower_layer_prediction_vertical_size) / tmp___8));
#line 319
      tmp___7 = (unsigned char *)tmp___9;
#line 319
      llframe0[cc] = tmp___7;
#line 319
      if (! tmp___7) {
#line 320
        Error((char *)"llframe0 malloc failed\n");
      }
#line 321
      if (cc) {
#line 321
        tmp___11 = 4;
      } else {
#line 321
        tmp___11 = 1;
      }
#line 321
      tmp___12 = malloc((size_t )((lower_layer_prediction_horizontal_size * lower_layer_prediction_vertical_size) / tmp___11));
#line 321
      tmp___10 = (unsigned char *)tmp___12;
#line 321
      llframe1[cc] = tmp___10;
#line 321
      if (! tmp___10) {
#line 322
        Error((char *)"llframe1 malloc failed\n");
      }
    }
#line 295
    cc ++;
  }
#line 327
  if (base.scalable_mode == 2) {
#line 329
    tmp___13 = malloc((unsigned long )(lower_layer_prediction_horizontal_size * ((lower_layer_prediction_vertical_size * vertical_subsampling_factor_n) / vertical_subsampling_factor_m)) * sizeof(short ));
#line 329
    lltmp = (short *)tmp___13;
#line 329
    if (! lltmp) {
#line 330
      Error((char *)"lltmp malloc failed\n");
    }
  }
#line 341
  return;
}
}
#line 343 "src/mpeg2dec.c"
void Error(char *text ) 
{ 


  {
#line 346
  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )text);
#line 347
  exit(1);
}
}
#line 351 "src/mpeg2dec.c"
void Print_Bits(int code , int bits , int len ) 
{ 
  int i ;

  {
#line 355
  i = 0;
#line 355
  while (i < len) {
#line 356
    printf((char const   * __restrict  )"%d", (code >> ((bits - 1) - i)) & 1);
#line 355
    i ++;
  }
#line 357
  return;
}
}
#line 362 "src/mpeg2dec.c"
static void Process_Options(int argc , char **argv ) 
{ 
  int i ;
  int LastArg ;
  int NextArg ;
  int __res ;
  __int32_t const   **tmp___0 ;

  {
#line 369
  if (argc < 2) {
#line 371
    printf((char const   * __restrict  )"\n%s, %s\n", Version, Author);
#line 372
    printf((char const   * __restrict  )"Usage:  mpeg2decode {options}\nOptions: -b  file  main bitstream (base or spatial enhancement layer)\n         -cn file  conformance report (n: level)\n         -e  file  enhancement layer bitstream (SNR or Data Partitioning)\n         -f        store/display interlaced video in frame format\n         -g        concatenated file format for substitution method (-x)\n         -in file  information & statistics report  (n: level)\n         -l  file  file name pattern for lower layer sequence\n                   (for spatial scalability)\n         -on file  output format (0:YUV 1:SIF 2:TGA 3:PPM 4:X11 5:X11HiQ)\n         -q        disable warnings to stderr\n         -r        use double precision reference IDCT\n         -t        enable low level tracing to stdout\n         -u  file  print user_data to stdio or file\n         -vn       verbose output (n: level)\n         -x  file  filename pattern of picture substitution sequence\n\nFile patterns:  for sequential filenames, \"printf\" style, e.g. rec%%d\n                 or rec%%d%%c for fieldwise storage\nLevels:        0:none 1:sequence 2:picture 3:slice 4:macroblock 5:block\n\nExample:       mpeg2decode -b bitstream.mpg -f -r -o0 rec%%d\n         \n");
#line 393
    exit(0);
  }
#line 397
  Output_Type = -1;
#line 398
  i = 1;
#line 402
  while (i < argc) {
#line 405
    LastArg = argc - i == 1;
#line 409
    if (! LastArg) {
#line 410
      NextArg = (int )*(*(argv + (i + 1)) + 0) == 45;
    } else {
#line 412
      NextArg = 0;
    }
#line 415
    if ((int )*(*(argv + i) + 0) == 45) {
#line 417
      if (sizeof(*(*(argv + i) + 1)) > 1UL) {
#line 417
        __res = toupper((int )*(*(argv + i) + 1));
      } else {
#line 417
        tmp___0 = __ctype_toupper_loc();
#line 417
        __res = (int )*(*tmp___0 + (int )*(*(argv + i) + 1));
      }
#line 417
      switch (__res) {
      case 66: 
#line 421
      Main_Bitstream_Flag = 1;
#line 423
      if (NextArg) {
#line 425
        printf((char const   * __restrict  )"ERROR: -b must be followed the main bitstream filename\n");
      } else
#line 423
      if (LastArg) {
#line 425
        printf((char const   * __restrict  )"ERROR: -b must be followed the main bitstream filename\n");
      } else {
#line 428
        i ++;
#line 428
        Main_Bitstream_Filename = *(argv + i);
      }
#line 430
      break;
      case 67: 
#line 445
      printf((char const   * __restrict  )"This program not compiled for Verify_Flag option\n");
#line 447
      break;
      case 69: 
#line 450
      Two_Streams = 1;
#line 452
      if (NextArg) {
#line 454
        printf((char const   * __restrict  )"ERROR: -e must be followed by filename\n");
#line 455
        exit(-1);
      } else
#line 452
      if (LastArg) {
#line 454
        printf((char const   * __restrict  )"ERROR: -e must be followed by filename\n");
#line 455
        exit(-1);
      } else {
#line 458
        i ++;
#line 458
        Enhancement_Layer_Bitstream_Filename = *(argv + i);
      }
#line 460
      break;
      case 70: 
#line 464
      Frame_Store_Flag = 1;
#line 465
      break;
      case 71: 
#line 468
      Big_Picture_Flag = 1;
#line 469
      break;
      case 73: 
#line 476
      printf((char const   * __restrict  )"WARNING: This program not compiled for -i option\n");
#line 478
      break;
      case 76: 
#line 481
      Spatial_Flag = 1;
#line 483
      if (NextArg) {
#line 485
        printf((char const   * __restrict  )"ERROR: -l must be followed by filename\n");
#line 486
        exit(-1);
      } else
#line 483
      if (LastArg) {
#line 485
        printf((char const   * __restrict  )"ERROR: -l must be followed by filename\n");
#line 486
        exit(-1);
      } else {
#line 489
        i ++;
#line 489
        Lower_Layer_Picture_Filename = *(argv + i);
      }
#line 491
      break;
      case 79: 
#line 495
      Output_Type = atoi((char const   *)(*(argv + i) + 2));
#line 497
      if (Output_Type == 4) {
#line 498
        Output_Picture_Filename = (char *)"";
      } else
#line 497
      if (Output_Type == 5) {
#line 498
        Output_Picture_Filename = (char *)"";
      } else
#line 499
      if (NextArg) {
#line 501
        printf((char const   * __restrict  )"ERROR: -o must be followed by filename\n");
#line 502
        exit(-1);
      } else
#line 499
      if (LastArg) {
#line 501
        printf((char const   * __restrict  )"ERROR: -o must be followed by filename\n");
#line 502
        exit(-1);
      } else {
#line 506
        i ++;
#line 506
        Output_Picture_Filename = *(argv + i);
      }
#line 515
      break;
      case 81: 
#line 518
      Quiet_Flag = 1;
#line 519
      break;
      case 82: 
#line 522
      Reference_IDCT_Flag = 1;
#line 523
      break;
      case 84: 
#line 529
      printf((char const   * __restrict  )"WARNING: This program not compiled for -t option\n");
#line 531
      break;
      case 85: 
#line 534
      User_Data_Flag = 1;
      case 86: 
#line 540
      printf((char const   * __restrict  )"This program not compiled for -v option\n");
#line 542
      break;
      case 88: 
#line 546
      Ersatz_Flag = 1;
#line 548
      if (NextArg) {
#line 550
        printf((char const   * __restrict  )"ERROR: -x must be followed by filename\n");
#line 551
        exit(-1);
      } else
#line 548
      if (LastArg) {
#line 550
        printf((char const   * __restrict  )"ERROR: -x must be followed by filename\n");
#line 551
        exit(-1);
      } else {
#line 554
        i ++;
#line 554
        Substitute_Picture_Filename = *(argv + i);
      }
#line 556
      break;
      default: 
#line 561
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"undefined option -%c ignored. Exiting program\n",
              (int )*(*(argv + i) + 1));
#line 564
      exit(-1);
      }
    }
#line 569
    i ++;
  }
#line 579
  if (Main_Bitstream_Flag != 1) {
#line 581
    printf((char const   * __restrict  )"There must be a main bitstream specified (-b filename)\n");
  }
#line 585
  if (Output_Type == 4) {
#line 585
    goto _L;
  } else
#line 585
  if (Output_Type == 5) {
    _L: /* CIL Label */ 
#line 585
    if (Frame_Store_Flag) {
#line 586
      Display_Progressive_Flag = 1;
    } else {
#line 588
      Display_Progressive_Flag = 0;
    }
  } else {
#line 588
    Display_Progressive_Flag = 0;
  }
#line 608
  if (Output_Type == -1) {
#line 610
    Output_Type = 9;
#line 611
    Output_Picture_Filename = (char *)"";
  }
#line 628
  return;
}
}
#line 653 "src/mpeg2dec.c"
static int Headers(void) 
{ 
  int ret ;
  int tmp ;

  {
#line 657
  ld = & base;
#line 663
  ret = Get_Hdr();
#line 666
  if (Two_Streams) {
#line 668
    ld = & enhan;
#line 669
    tmp = Get_Hdr();
#line 669
    if (tmp != ret) {
#line 669
      if (! Quiet_Flag) {
#line 670
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"streams out of sync\n");
      }
    }
#line 671
    ld = & base;
  }
#line 674
  return (ret);
}
}
#line 679 "src/mpeg2dec.c"
static int Decode_Bitstream(void) 
{ 
  int ret ;
  int Bitstream_Framenum ;

  {
#line 684
  Bitstream_Framenum = 0;
#line 686
  while (1) {
#line 693
    ret = Headers();
#line 695
    if (ret == 1) {
#line 697
      ret = video_sequence(& Bitstream_Framenum);
    } else {
#line 700
      return (ret);
    }
  }
}
}
#line 706 "src/mpeg2dec.c"
static void Deinitialize_Sequence(void) 
{ 
  int i ;

  {
#line 711
  base.MPEG2_Flag = 0;
#line 713
  i = 0;
#line 713
  while (i < 3) {
#line 715
    free((void *)backward_reference_frame[i]);
#line 716
    free((void *)forward_reference_frame[i]);
#line 717
    free((void *)auxframe[i]);
#line 719
    if (base.scalable_mode == 2) {
#line 721
      free((void *)llframe0[i]);
#line 722
      free((void *)llframe1[i]);
    }
#line 713
    i ++;
  }
#line 726
  if (base.scalable_mode == 2) {
#line 727
    free((void *)lltmp);
  }
#line 733
  return;
}
}
#line 736 "src/mpeg2dec.c"
static int video_sequence(int *Bitstream_Framenumber ) 
{ 
  int Bitstream_Framenum ;
  int Sequence_Framenum ;
  int Return_Value ;

  {
#line 743
  Bitstream_Framenum = *Bitstream_Framenumber;
#line 744
  Sequence_Framenum = 0;
#line 746
  Initialize_Sequence();
#line 752
  Decode_Picture(Bitstream_Framenum, Sequence_Framenum);
#line 755
  if (! Second_Field) {
#line 757
    Bitstream_Framenum ++;
#line 758
    Sequence_Framenum ++;
  }
#line 762
  while (1) {
#line 762
    Return_Value = Headers();
#line 762
    if (! Return_Value) {
#line 762
      break;
    }
#line 764
    Decode_Picture(Bitstream_Framenum, Sequence_Framenum);
#line 766
    if (! Second_Field) {
#line 768
      Bitstream_Framenum ++;
#line 769
      Sequence_Framenum ++;
    }
  }
#line 774
  if (Sequence_Framenum != 0) {
#line 776
    Output_Last_Frame_of_Sequence(Bitstream_Framenum);
  }
#line 779
  Deinitialize_Sequence();
#line 785
  *Bitstream_Framenumber = Bitstream_Framenum;
#line 786
  return (Return_Value);
}
}
#line 791 "src/mpeg2dec.c"
static void Clear_Options(void) 
{ 


  {
#line 793
  Verbose_Flag = 0;
#line 794
  Output_Type = 0;
#line 795
  Output_Picture_Filename = (char *)" ";
#line 796
  hiQdither = 0;
#line 797
  Output_Type = 0;
#line 798
  Frame_Store_Flag = 0;
#line 799
  Spatial_Flag = 0;
#line 800
  Lower_Layer_Picture_Filename = (char *)" ";
#line 801
  Reference_IDCT_Flag = 0;
#line 802
  Trace_Flag = 0;
#line 803
  Quiet_Flag = 0;
#line 804
  Ersatz_Flag = 0;
#line 805
  Substitute_Picture_Filename = (char *)" ";
#line 806
  Two_Streams = 0;
#line 807
  Enhancement_Layer_Bitstream_Filename = (char *)" ";
#line 808
  Big_Picture_Flag = 0;
#line 809
  Main_Bitstream_Flag = 0;
#line 810
  Main_Bitstream_Filename = (char *)" ";
#line 811
  Verify_Flag = 0;
#line 812
  Stats_Flag = 0;
#line 813
  User_Data_Flag = 0;
#line 814
  return;
}
}
#line 1 "recon.o"
#pragma merger("0","/tmp/cil-Lcmkuuby.i","-g,-O4")
#line 90 "src/recon.c"
static void form_prediction(unsigned char **src , int sfield , unsigned char **dst ,
                            int dfield , int lx , int lx2 , int w , int h , int x ,
                            int y , int dx , int dy , int average_flag ) ;
#line 95
static void form_component_prediction(unsigned char *src , unsigned char *dst , int lx ,
                                      int lx2 , int w , int h , int x , int y , int dx ,
                                      int dy , int average_flag ) ;
#line 100
static void form_component_prediction2(unsigned char *src , unsigned char *dst , int lx ,
                                       int lx2 , int w , int h , int dx , int dy ,
                                       int average_flag ) ;
#line 111 "src/recon.c"
void form_predictions(int bx , int by , int macroblock_type , int motion_type , int (*PMV)[2][2] ,
                      int (*motion_vertical_field_select)[2] , int *dmvector , int stwtype ) 
{ 
  int currentfield ;
  unsigned char **predframe ;
  int DMV[2][2] ;
  int stwtop ;
  int stwbot ;

  {
#line 125
  stwtop = stwtype % 3;
#line 126
  stwbot = stwtype / 3;
#line 128
  if (macroblock_type & 8) {
#line 128
    goto _L___1;
  } else
#line 128
  if (picture_coding_type == 2) {
    _L___1: /* CIL Label */ 
#line 131
    if (picture_structure == 3) {
#line 133
      if (motion_type == 2) {
#line 133
        goto _L;
      } else
#line 133
      if (! (macroblock_type & 8)) {
        _L: /* CIL Label */ 
#line 138
        if (stwtop < 2) {
#line 139
          form_prediction(forward_reference_frame, 0, current_frame, 0, Coded_Picture_Width,
                          Coded_Picture_Width << 1, 16, 8, bx, by, (*(PMV + 0))[0][0],
                          (*(PMV + 0))[0][1], stwtop);
        }
#line 143
        if (stwbot < 2) {
#line 144
          form_prediction(forward_reference_frame, 1, current_frame, 1, Coded_Picture_Width,
                          Coded_Picture_Width << 1, 16, 8, bx, by, (*(PMV + 0))[0][0],
                          (*(PMV + 0))[0][1], stwbot);
        }
      } else
#line 148
      if (motion_type == 1) {
#line 151
        if (stwtop < 2) {
#line 152
          form_prediction(forward_reference_frame, (*(motion_vertical_field_select + 0))[0],
                          current_frame, 0, Coded_Picture_Width << 1, Coded_Picture_Width << 1,
                          16, 8, bx, by >> 1, (*(PMV + 0))[0][0], (*(PMV + 0))[0][1] >> 1,
                          stwtop);
        }
#line 157
        if (stwbot < 2) {
#line 158
          form_prediction(forward_reference_frame, (*(motion_vertical_field_select + 1))[0],
                          current_frame, 1, Coded_Picture_Width << 1, Coded_Picture_Width << 1,
                          16, 8, bx, by >> 1, (*(PMV + 1))[0][0], (*(PMV + 1))[0][1] >> 1,
                          stwbot);
        }
      } else
#line 162
      if (motion_type == 3) {
#line 165
        Dual_Prime_Arithmetic(DMV, (int *)dmvector, (*(PMV + 0))[0][0], (*(PMV + 0))[0][1] >> 1);
#line 167
        if (stwtop < 2) {
#line 170
          form_prediction(forward_reference_frame, 0, current_frame, 0, Coded_Picture_Width << 1,
                          Coded_Picture_Width << 1, 16, 8, bx, by >> 1, (*(PMV + 0))[0][0],
                          (*(PMV + 0))[0][1] >> 1, 0);
#line 175
          form_prediction(forward_reference_frame, 1, current_frame, 0, Coded_Picture_Width << 1,
                          Coded_Picture_Width << 1, 16, 8, bx, by >> 1, DMV[0][0],
                          DMV[0][1], 1);
        }
#line 180
        if (stwbot < 2) {
#line 183
          form_prediction(forward_reference_frame, 1, current_frame, 1, Coded_Picture_Width << 1,
                          Coded_Picture_Width << 1, 16, 8, bx, by >> 1, (*(PMV + 0))[0][0],
                          (*(PMV + 0))[0][1] >> 1, 0);
#line 188
          form_prediction(forward_reference_frame, 0, current_frame, 1, Coded_Picture_Width << 1,
                          Coded_Picture_Width << 1, 16, 8, bx, by >> 1, DMV[1][0],
                          DMV[1][1], 1);
        }
      } else {
#line 195
        printf((char const   * __restrict  )"invalid motion_type\n");
      }
    } else {
#line 200
      currentfield = picture_structure == 2;
#line 203
      if (picture_coding_type == 2) {
#line 203
        if (Second_Field) {
#line 203
          if (currentfield != (*(motion_vertical_field_select + 0))[0]) {
#line 205
            predframe = backward_reference_frame;
          } else {
#line 207
            predframe = forward_reference_frame;
          }
        } else {
#line 207
          predframe = forward_reference_frame;
        }
      } else {
#line 207
        predframe = forward_reference_frame;
      }
#line 209
      if (motion_type == 1) {
#line 209
        goto _L___0;
      } else
#line 209
      if (! (macroblock_type & 8)) {
        _L___0: /* CIL Label */ 
#line 213
        if (stwtop < 2) {
#line 214
          form_prediction(predframe, (*(motion_vertical_field_select + 0))[0], current_frame,
                          0, Coded_Picture_Width << 1, Coded_Picture_Width << 1, 16,
                          16, bx, by, (*(PMV + 0))[0][0], (*(PMV + 0))[0][1], stwtop);
        }
      } else
#line 218
      if (motion_type == 2) {
#line 220
        if (stwtop < 2) {
#line 222
          form_prediction(predframe, (*(motion_vertical_field_select + 0))[0], current_frame,
                          0, Coded_Picture_Width << 1, Coded_Picture_Width << 1, 16,
                          8, bx, by, (*(PMV + 0))[0][0], (*(PMV + 0))[0][1], stwtop);
#line 227
          if (picture_coding_type == 2) {
#line 227
            if (Second_Field) {
#line 227
              if (currentfield != (*(motion_vertical_field_select + 1))[0]) {
#line 229
                predframe = backward_reference_frame;
              } else {
#line 231
                predframe = forward_reference_frame;
              }
            } else {
#line 231
              predframe = forward_reference_frame;
            }
          } else {
#line 231
            predframe = forward_reference_frame;
          }
#line 233
          form_prediction(predframe, (*(motion_vertical_field_select + 1))[0], current_frame,
                          0, Coded_Picture_Width << 1, Coded_Picture_Width << 1, 16,
                          8, bx, by + 8, (*(PMV + 1))[0][0], (*(PMV + 1))[0][1], stwtop);
        }
      } else
#line 238
      if (motion_type == 3) {
#line 240
        if (Second_Field) {
#line 241
          predframe = backward_reference_frame;
        } else {
#line 243
          predframe = forward_reference_frame;
        }
#line 246
        Dual_Prime_Arithmetic(DMV, (int *)dmvector, (*(PMV + 0))[0][0], (*(PMV + 0))[0][1]);
#line 249
        form_prediction(forward_reference_frame, currentfield, current_frame, 0, Coded_Picture_Width << 1,
                        Coded_Picture_Width << 1, 16, 16, bx, by, (*(PMV + 0))[0][0],
                        (*(PMV + 0))[0][1], 0);
#line 254
        form_prediction(predframe, ! currentfield, current_frame, 0, Coded_Picture_Width << 1,
                        Coded_Picture_Width << 1, 16, 16, bx, by, DMV[0][0], DMV[0][1],
                        1);
      } else {
#line 260
        printf((char const   * __restrict  )"invalid motion_type\n");
      }
    }
#line 262
    stwbot = 1;
#line 262
    stwtop = stwbot;
  }
#line 265
  if (macroblock_type & 4) {
#line 267
    if (picture_structure == 3) {
#line 269
      if (motion_type == 2) {
#line 272
        if (stwtop < 2) {
#line 273
          form_prediction(backward_reference_frame, 0, current_frame, 0, Coded_Picture_Width,
                          Coded_Picture_Width << 1, 16, 8, bx, by, (*(PMV + 0))[1][0],
                          (*(PMV + 0))[1][1], stwtop);
        }
#line 277
        if (stwbot < 2) {
#line 278
          form_prediction(backward_reference_frame, 1, current_frame, 1, Coded_Picture_Width,
                          Coded_Picture_Width << 1, 16, 8, bx, by, (*(PMV + 0))[1][0],
                          (*(PMV + 0))[1][1], stwbot);
        }
      } else {
#line 285
        if (stwtop < 2) {
#line 286
          form_prediction(backward_reference_frame, (*(motion_vertical_field_select + 0))[1],
                          current_frame, 0, Coded_Picture_Width << 1, Coded_Picture_Width << 1,
                          16, 8, bx, by >> 1, (*(PMV + 0))[1][0], (*(PMV + 0))[1][1] >> 1,
                          stwtop);
        }
#line 291
        if (stwbot < 2) {
#line 292
          form_prediction(backward_reference_frame, (*(motion_vertical_field_select + 1))[1],
                          current_frame, 1, Coded_Picture_Width << 1, Coded_Picture_Width << 1,
                          16, 8, bx, by >> 1, (*(PMV + 1))[1][0], (*(PMV + 1))[1][1] >> 1,
                          stwbot);
        }
      }
    } else
#line 300
    if (motion_type == 1) {
#line 303
      form_prediction(backward_reference_frame, (*(motion_vertical_field_select + 0))[1],
                      current_frame, 0, Coded_Picture_Width << 1, Coded_Picture_Width << 1,
                      16, 16, bx, by, (*(PMV + 0))[1][0], (*(PMV + 0))[1][1], stwtop);
    } else
#line 307
    if (motion_type == 2) {
#line 309
      form_prediction(backward_reference_frame, (*(motion_vertical_field_select + 0))[1],
                      current_frame, 0, Coded_Picture_Width << 1, Coded_Picture_Width << 1,
                      16, 8, bx, by, (*(PMV + 0))[1][0], (*(PMV + 0))[1][1], stwtop);
#line 313
      form_prediction(backward_reference_frame, (*(motion_vertical_field_select + 1))[1],
                      current_frame, 0, Coded_Picture_Width << 1, Coded_Picture_Width << 1,
                      16, 8, bx, by + 8, (*(PMV + 1))[1][0], (*(PMV + 1))[1][1], stwtop);
    } else {
#line 319
      printf((char const   * __restrict  )"invalid motion_type\n");
    }
  }
#line 322
  return;
}
}
#line 326 "src/recon.c"
static void form_prediction(unsigned char **src , int sfield , unsigned char **dst ,
                            int dfield , int lx , int lx2 , int w , int h , int x ,
                            int y , int dx , int dy , int average_flag ) 
{ 
  int sf_val ;
  int df_val ;
  int sly_val ;
  int dly_val ;
  int slx_val ;
  int xh ;
  int yh ;
  int tmp ;
  int tmp___0 ;

  {
#line 339
  if (dfield) {
#line 339
    tmp = lx2 >> 1;
  } else {
#line 339
    tmp = 0;
  }
#line 339
  if (sfield) {
#line 339
    tmp___0 = lx2 >> 1;
  } else {
#line 339
    tmp___0 = 0;
  }
#line 339
  form_component_prediction(*(src + 0) + tmp___0, *(dst + 0) + tmp, lx, lx2, w, h,
                            x, y, dx, dy, average_flag);
#line 342
  if (chroma_format != 3) {
#line 344
    lx >>= 1;
#line 344
    lx2 >>= 1;
#line 344
    w >>= 1;
#line 344
    x >>= 1;
#line 344
    dx /= 2;
  }
#line 347
  if (chroma_format == 1) {
#line 349
    h >>= 1;
#line 349
    y >>= 1;
#line 349
    dy /= 2;
  }
#line 352
  if (sfield) {
#line 352
    sf_val = lx2 >> 1;
  } else {
#line 352
    sf_val = 0;
  }
#line 353
  if (dfield) {
#line 353
    df_val = lx2 >> 1;
  } else {
#line 353
    df_val = 0;
  }
#line 354
  sly_val = lx * (y + (dy >> 1));
#line 355
  dly_val = lx * y;
#line 356
  slx_val = x + (dx >> 1);
#line 357
  xh = dx & 1;
#line 358
  yh = dy & 1;
#line 361
  form_component_prediction2(((*(src + 1) + sf_val) + sly_val) + slx_val, ((*(dst + 1) + df_val) + dly_val) + x,
                             lx, lx2, w, h, xh, yh, average_flag);
#line 366
  form_component_prediction2(((*(src + 2) + sf_val) + sly_val) + slx_val, ((*(dst + 2) + df_val) + dly_val) + x,
                             lx, lx2, w, h, xh, yh, average_flag);
#line 370
  return;
}
}
#line 437 "src/recon.c"
static void form_component_prediction(unsigned char *src , unsigned char *dst , int lx ,
                                      int lx2 , int w , int h , int x , int y , int dx ,
                                      int dy , int average_flag ) 
{ 
  int xint ;
  int yint ;
  int xh ;
  int yh ;
  int i ;
  int j ;
  int v ;
  unsigned char *s ;
  unsigned char *d ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 459
  xint = dx >> 1;
#line 460
  yint = dy >> 1;
#line 465
  s = ((src + lx * (y + yint)) + x) + xint;
#line 466
  d = (dst + lx * y) + x;
#line 471
  xh = dx & 1;
#line 472
  yh = dy & 1;
#line 474
  if (! ((unsigned long )s != (unsigned long )d)) {
#line 474
    __assert_fail("s!=d", "src/recon.c", 474U, "form_component_prediction");
  }
#line 476
  if (! xh) {
#line 476
    if (! yh) {
#line 478
      if (average_flag) {
#line 522
        j = 0;
#line 522
        while (j < h) {
#line 525
          i = 0;
#line 525
          while (i < w) {
#line 527
            v = (int )*(d + i) + (int )*(s + i);
#line 528
            if (v >= 0) {
#line 528
              tmp = 1;
            } else {
#line 528
              tmp = 0;
            }
#line 528
            *(d + i) = (unsigned char )((v + tmp) >> 1);
#line 525
            i ++;
          }
#line 531
          s += lx2;
#line 532
          d += lx2;
#line 522
          j ++;
        }
      } else {
#line 581
        j = 0;
#line 581
        while (j < h) {
#line 584
          i = 0;
#line 584
          while (i < w) {
#line 586
            *(d + i) = *(s + i);
#line 584
            i ++;
          }
#line 589
          s += lx2;
#line 590
          d += lx2;
#line 581
          j ++;
        }
      }
    } else {
#line 476
      goto _L___1;
    }
  } else
  _L___1: /* CIL Label */ 
#line 601
  if (! xh) {
#line 601
    if (yh) {
#line 603
      if (average_flag) {
#line 652
        j = 0;
#line 652
        while (j < h) {
#line 654
          i = 0;
#line 654
          while (i < w) {
#line 656
            v = (int )((unsigned int )*(d + i) + ((unsigned int )(((int )*(s + i) + (int )*(s + (i + lx))) + 1) >> 1));
#line 657
            if (v >= 0) {
#line 657
              tmp___0 = 1;
            } else {
#line 657
              tmp___0 = 0;
            }
#line 657
            *(d + i) = (unsigned char )((v + tmp___0) >> 1);
#line 654
            i ++;
          }
#line 660
          s += lx2;
#line 661
          d += lx2;
#line 652
          j ++;
        }
      } else {
#line 712
        j = 0;
#line 712
        while (j < h) {
#line 714
          i = 0;
#line 714
          while (i < w) {
#line 716
            *(d + i) = (unsigned char )((unsigned int )(((int )*(s + i) + (int )*(s + (i + lx))) + 1) >> 1);
#line 714
            i ++;
          }
#line 719
          s += lx2;
#line 720
          d += lx2;
#line 712
          j ++;
        }
      }
    } else {
#line 601
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
#line 730
  if (xh) {
#line 730
    if (! yh) {
#line 732
      if (average_flag) {
#line 779
        j = 0;
#line 779
        while (j < h) {
#line 781
          i = 0;
#line 781
          while (i < w) {
#line 783
            v = (int )((unsigned int )*(d + i) + ((unsigned int )(((int )*(s + i) + (int )*(s + (i + 1))) + 1) >> 1));
#line 784
            if (v >= 0) {
#line 784
              tmp___1 = 1;
            } else {
#line 784
              tmp___1 = 0;
            }
#line 784
            *(d + i) = (unsigned char )((v + tmp___1) >> 1);
#line 781
            i ++;
          }
#line 787
          s += lx2;
#line 788
          d += lx2;
#line 779
          j ++;
        }
      } else {
#line 834
        j = 0;
#line 834
        while (j < h) {
#line 836
          i = 0;
#line 836
          while (i < w) {
#line 838
            *(d + i) = (unsigned char )((unsigned int )(((int )*(s + i) + (int )*(s + (i + 1))) + 1) >> 1);
#line 836
            i ++;
          }
#line 841
          s += lx2;
#line 842
          d += lx2;
#line 834
          j ++;
        }
      }
    } else {
#line 730
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 851
  if (average_flag) {
#line 906
    j = 0;
#line 906
    while (j < h) {
#line 908
      i = 0;
#line 908
      while (i < w) {
#line 910
        v = (int )((unsigned int )*(d + i) + ((unsigned int )(((((int )*(s + i) + (int )*(s + (i + 1))) + (int )*(s + (i + lx))) + (int )*(s + ((i + lx) + 1))) + 2) >> 2));
#line 911
        if (v >= 0) {
#line 911
          tmp___2 = 1;
        } else {
#line 911
          tmp___2 = 0;
        }
#line 911
        *(d + i) = (unsigned char )((v + tmp___2) >> 1);
#line 908
        i ++;
      }
#line 914
      s += lx2;
#line 915
      d += lx2;
#line 906
      j ++;
    }
  } else {
#line 970
    j = 0;
#line 970
    while (j < h) {
#line 972
      i = 0;
#line 972
      while (i < w) {
#line 974
        *(d + i) = (unsigned char )((unsigned int )(((((int )*(s + i) + (int )*(s + (i + 1))) + (int )*(s + (i + lx))) + (int )*(s + ((i + lx) + 1))) + 2) >> 2);
#line 972
        i ++;
      }
#line 977
      s += lx2;
#line 978
      d += lx2;
#line 970
      j ++;
    }
  }
#line 985
  return;
}
}
#line 992 "src/recon.c"
static void form_component_prediction2(unsigned char *src , unsigned char *dst , int lx ,
                                       int lx2 , int w , int h , int dx , int dy ,
                                       int average_flag ) 
{ 
  int xh ;
  int yh ;
  int i ;
  int j ;
  int v ;
  unsigned char *s ;
  unsigned char *d ;
  unsigned char *s1 ;
  unsigned char *d1 ;
  int v1 ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
#line 1027
  s = src;
#line 1028
  d = dst;
#line 1030
  xh = dx;
#line 1031
  yh = dy;
#line 1047
  if (! xh) {
#line 1047
    if (! yh) {
#line 1049
      if (average_flag) {
#line 1111
        j = 0;
#line 1111
        while (j < h) {
#line 1112
          s1 = s + lx2;
#line 1113
          d1 = d + lx2;
#line 1115
          i = 0;
#line 1115
          while (i < w) {
#line 1116
            v = (int )*(d + i) + (int )*(s + i);
#line 1117
            v1 = (int )*(d1 + i) + (int )*(s1 + i);
#line 1118
            if (v >= 0) {
#line 1118
              tmp = 1;
            } else {
#line 1118
              tmp = 0;
            }
#line 1118
            *(d + i) = (unsigned char )((v + tmp) >> 1);
#line 1119
            if (v1 >= 0) {
#line 1119
              tmp___0 = 1;
            } else {
#line 1119
              tmp___0 = 0;
            }
#line 1119
            *(d1 + i) = (unsigned char )((v1 + tmp___0) >> 1);
#line 1115
            i ++;
          }
#line 1121
          s = s1 + lx2;
#line 1122
          d = d1 + lx2;
#line 1111
          j += 2;
        }
      } else {
#line 1187
        j = 0;
#line 1187
        while (j < h) {
#line 1189
          i = 0;
#line 1189
          while (i < w) {
#line 1191
            *(d + i) = *(s + i);
#line 1189
            i ++;
          }
#line 1194
          s += lx2;
#line 1195
          d += lx2;
#line 1197
          i = 0;
#line 1197
          while (i < w) {
#line 1199
            *(d + i) = *(s + i);
#line 1197
            i ++;
          }
#line 1202
          s += lx2;
#line 1203
          d += lx2;
#line 1187
          j += 2;
        }
      }
    } else {
#line 1047
      goto _L___1;
    }
  } else
  _L___1: /* CIL Label */ 
#line 1213
  if (! xh) {
#line 1213
    if (yh) {
#line 1215
      if (average_flag) {
#line 1277
        j = 0;
#line 1277
        while (j < h) {
#line 1279
          i = 0;
#line 1279
          while (i < w) {
#line 1281
            v = (int )((unsigned int )*(d + i) + ((unsigned int )(((int )*(s + i) + (int )*(s + (i + lx))) + 1) >> 1));
#line 1282
            if (v >= 0) {
#line 1282
              tmp___1 = 1;
            } else {
#line 1282
              tmp___1 = 0;
            }
#line 1282
            *(d + i) = (unsigned char )((v + tmp___1) >> 1);
#line 1279
            i ++;
          }
#line 1285
          s += lx2;
#line 1286
          d += lx2;
#line 1288
          i = 0;
#line 1288
          while (i < w) {
#line 1290
            v = (int )((unsigned int )*(d + i) + ((unsigned int )(((int )*(s + i) + (int )*(s + (i + lx))) + 1) >> 1));
#line 1291
            if (v >= 0) {
#line 1291
              tmp___2 = 1;
            } else {
#line 1291
              tmp___2 = 0;
            }
#line 1291
            *(d + i) = (unsigned char )((v + tmp___2) >> 1);
#line 1288
            i ++;
          }
#line 1294
          s += lx2;
#line 1295
          d += lx2;
#line 1277
          j += 2;
        }
      } else {
#line 1357
        j = 0;
#line 1357
        while (j < h) {
#line 1359
          i = 0;
#line 1359
          while (i < w) {
#line 1361
            *(d + i) = (unsigned char )((unsigned int )(((int )*(s + i) + (int )*(s + (i + lx))) + 1) >> 1);
#line 1359
            i ++;
          }
#line 1364
          s += lx2;
#line 1365
          d += lx2;
#line 1367
          i = 0;
#line 1367
          while (i < w) {
#line 1369
            *(d + i) = (unsigned char )((unsigned int )(((int )*(s + i) + (int )*(s + (i + lx))) + 1) >> 1);
#line 1367
            i ++;
          }
#line 1372
          s += lx2;
#line 1373
          d += lx2;
#line 1357
          j += 2;
        }
      }
    } else {
#line 1213
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
#line 1383
  if (xh) {
#line 1383
    if (! yh) {
#line 1385
      if (average_flag) {
#line 1446
        j = 0;
#line 1446
        while (j < h) {
#line 1449
          i = 0;
#line 1449
          while (i < w) {
#line 1451
            v = (int )((unsigned int )*(d + i) + ((unsigned int )(((int )*(s + i) + (int )*(s + (i + 1))) + 1) >> 1));
#line 1452
            if (v >= 0) {
#line 1452
              tmp___3 = 1;
            } else {
#line 1452
              tmp___3 = 0;
            }
#line 1452
            *(d + i) = (unsigned char )((v + tmp___3) >> 1);
#line 1449
            i ++;
          }
#line 1455
          s += lx2;
#line 1456
          d += lx2;
#line 1459
          i = 0;
#line 1459
          while (i < w) {
#line 1461
            v = (int )((unsigned int )*(d + i) + ((unsigned int )(((int )*(s + i) + (int )*(s + (i + 1))) + 1) >> 1));
#line 1462
            if (v >= 0) {
#line 1462
              tmp___4 = 1;
            } else {
#line 1462
              tmp___4 = 0;
            }
#line 1462
            *(d + i) = (unsigned char )((v + tmp___4) >> 1);
#line 1459
            i ++;
          }
#line 1465
          s += lx2;
#line 1466
          d += lx2;
#line 1446
          j += 2;
        }
      } else {
#line 1524
        j = 0;
#line 1524
        while (j < h) {
#line 1526
          i = 0;
#line 1526
          while (i < w) {
#line 1528
            *(d + i) = (unsigned char )((unsigned int )(((int )*(s + i) + (int )*(s + (i + 1))) + 1) >> 1);
#line 1526
            i ++;
          }
#line 1531
          s += lx2;
#line 1532
          d += lx2;
#line 1534
          i = 0;
#line 1534
          while (i < w) {
#line 1536
            *(d + i) = (unsigned char )((unsigned int )(((int )*(s + i) + (int )*(s + (i + 1))) + 1) >> 1);
#line 1534
            i ++;
          }
#line 1539
          s += lx2;
#line 1540
          d += lx2;
#line 1524
          j += 2;
        }
      }
    } else {
#line 1383
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 1550
  if (average_flag) {
#line 1624
    j = 0;
#line 1624
    while (j < h) {
#line 1626
      i = 0;
#line 1626
      while (i < w) {
#line 1628
        v = (int )((unsigned int )*(d + i) + ((unsigned int )(((((int )*(s + i) + (int )*(s + (i + 1))) + (int )*(s + (i + lx))) + (int )*(s + ((i + lx) + 1))) + 2) >> 2));
#line 1629
        if (v >= 0) {
#line 1629
          tmp___5 = 1;
        } else {
#line 1629
          tmp___5 = 0;
        }
#line 1629
        *(d + i) = (unsigned char )((v + tmp___5) >> 1);
#line 1626
        i ++;
      }
#line 1632
      s += lx2;
#line 1633
      d += lx2;
#line 1635
      i = 0;
#line 1635
      while (i < w) {
#line 1637
        v = (int )((unsigned int )*(d + i) + ((unsigned int )(((((int )*(s + i) + (int )*(s + (i + 1))) + (int )*(s + (i + lx))) + (int )*(s + ((i + lx) + 1))) + 2) >> 2));
#line 1638
        if (v >= 0) {
#line 1638
          tmp___6 = 1;
        } else {
#line 1638
          tmp___6 = 0;
        }
#line 1638
        *(d + i) = (unsigned char )((v + tmp___6) >> 1);
#line 1635
        i ++;
      }
#line 1641
      s += lx2;
#line 1642
      d += lx2;
#line 1624
      j += 2;
    }
  } else {
#line 1713
    j = 0;
#line 1713
    while (j < h) {
#line 1715
      i = 0;
#line 1715
      while (i < w) {
#line 1716
        *(d + i) = (unsigned char )((unsigned int )(((((int )*(s + i) + (int )*(s + (i + 1))) + (int )*(s + (i + lx))) + (int )*(s + ((i + lx) + 1))) + 2) >> 2);
#line 1715
        i ++;
      }
#line 1719
      s += lx2;
#line 1720
      d += lx2;
#line 1721
      i = 0;
#line 1721
      while (i < w) {
#line 1722
        *(d + i) = (unsigned char )((unsigned int )(((((int )*(s + i) + (int )*(s + (i + 1))) + (int )*(s + (i + lx))) + (int )*(s + ((i + lx) + 1))) + 2) >> 2);
#line 1721
        i ++;
      }
#line 1725
      s += lx2;
#line 1726
      d += lx2;
#line 1713
      j += 2;
    }
  }
#line 1733
  return;
}
}
#line 1 "spatscal.o"
#pragma merger("0","/tmp/cil-bYOMLmfs.i","-g,-O4")
#line 237 "/usr/include/stdio.h"
extern int fclose(FILE *__stream ) ;
#line 272
extern FILE *( __attribute__((__warn_unused_result__)) fopen)(char const   * __restrict  __filename ,
                                                              char const   * __restrict  __modes ) ;
#line 531
extern int fgetc(FILE *__stream ) ;
#line 59 "src/spatscal.c"
static void Read_Lower_Layer_Component_Framewise(int comp , int lw , int lh ) ;
#line 60
static void Read_Lower_Layer_Component_Fieldwise(int comp , int lw , int lh ) ;
#line 61
static void Make_Spatial_Prediction_Frame(int progressive_frame___0 , int llprogressive_frame ,
                                          unsigned char *fld0 , unsigned char *fld1 ,
                                          short *tmp , unsigned char *dst , int llx0 ,
                                          int lly0 , int llw , int llh , int horizontal_size___0 ,
                                          int vertical_size___0 , int vm , int vn ,
                                          int hm , int hn , int aperture ) ;
#line 66
static void Deinterlace(unsigned char *fld0 , unsigned char *fld1 , int j0 , int lx ,
                        int ly , int aperture ) ;
#line 68
static void Subsample_Vertical(unsigned char *s , short *d , int lx , int lys , int lyd ,
                               int m , int n , int j0 , int dj ) ;
#line 70
static void Subsample_Horizontal(short *s , unsigned char *d , int x0 , int lx , int lxs ,
                                 int lxd , int ly , int m , int n ) ;
#line 76 "src/spatscal.c"
void Spatial_Prediction(void) 
{ 


  {
#line 79
  if (Frame_Store_Flag) {
#line 81
    Read_Lower_Layer_Component_Framewise(0, lower_layer_prediction_horizontal_size,
                                         lower_layer_prediction_vertical_size);
#line 83
    Read_Lower_Layer_Component_Framewise(1, lower_layer_prediction_horizontal_size >> 1,
                                         lower_layer_prediction_vertical_size >> 1);
#line 85
    Read_Lower_Layer_Component_Framewise(2, lower_layer_prediction_horizontal_size >> 1,
                                         lower_layer_prediction_vertical_size >> 1);
  } else {
#line 90
    Read_Lower_Layer_Component_Fieldwise(0, lower_layer_prediction_horizontal_size,
                                         lower_layer_prediction_vertical_size);
#line 92
    Read_Lower_Layer_Component_Fieldwise(1, lower_layer_prediction_horizontal_size >> 1,
                                         lower_layer_prediction_vertical_size >> 1);
#line 94
    Read_Lower_Layer_Component_Fieldwise(2, lower_layer_prediction_horizontal_size >> 1,
                                         lower_layer_prediction_vertical_size >> 1);
  }
#line 99
  Make_Spatial_Prediction_Frame(progressive_frame, lower_layer_progressive_frame,
                                llframe0[0], llframe1[0], lltmp, current_frame[0],
                                lower_layer_horizontal_offset, lower_layer_vertical_offset,
                                lower_layer_prediction_horizontal_size, lower_layer_prediction_vertical_size,
                                horizontal_size, vertical_size, vertical_subsampling_factor_m,
                                vertical_subsampling_factor_n, horizontal_subsampling_factor_m,
                                horizontal_subsampling_factor_n, picture_structure != 3);
#line 110
  Make_Spatial_Prediction_Frame(progressive_frame, lower_layer_progressive_frame,
                                llframe0[1], llframe1[1], lltmp, current_frame[1],
                                lower_layer_horizontal_offset / 2, lower_layer_vertical_offset / 2,
                                lower_layer_prediction_horizontal_size >> 1, lower_layer_prediction_vertical_size >> 1,
                                horizontal_size >> 1, vertical_size >> 1, vertical_subsampling_factor_m,
                                vertical_subsampling_factor_n, horizontal_subsampling_factor_m,
                                horizontal_subsampling_factor_n, 1);
#line 120
  Make_Spatial_Prediction_Frame(progressive_frame, lower_layer_progressive_frame,
                                llframe0[2], llframe1[2], lltmp, current_frame[2],
                                lower_layer_horizontal_offset / 2, lower_layer_vertical_offset / 2,
                                lower_layer_prediction_horizontal_size >> 1, lower_layer_prediction_vertical_size >> 1,
                                horizontal_size >> 1, vertical_size >> 1, vertical_subsampling_factor_m,
                                vertical_subsampling_factor_n, horizontal_subsampling_factor_m,
                                horizontal_subsampling_factor_n, 1);
#line 130
  return;
}
}
#line 143
extern int ( /* missing proto */  strcat)() ;
#line 132 "src/spatscal.c"
static void Read_Lower_Layer_Component_Framewise(int comp , int lw , int lh ) 
{ 
  FILE *fd ;
  char fname[256] ;
  char ext[3][3] ;
  int i ;
  int j ;
  int tmp ;
  int tmp___0 ;

  {
#line 138
  ext[0][0] = (char )'.';
#line 138
  ext[0][1] = (char )'Y';
#line 138
  ext[0][2] = (char )'\000';
#line 138
  ext[1][0] = (char )'.';
#line 138
  ext[1][1] = (char )'U';
#line 138
  ext[1][2] = (char )'\000';
#line 138
  ext[2][0] = (char )'.';
#line 138
  ext[2][1] = (char )'V';
#line 138
  ext[2][2] = (char )'\000';
#line 142
  sprintf((char * __restrict  )(fname), (char const   * __restrict  )Lower_Layer_Picture_Filename,
          True_Framenum);
#line 143
  strcat(fname, ext[comp]);
#line 148
  fd = fopen((char const   * __restrict  )(fname), (char const   * __restrict  )"rb");
#line 149
  if ((unsigned long )fd == (unsigned long )((void *)0)) {
#line 149
    exit(-1);
  }
#line 150
  j = 0;
#line 150
  while (j < lh) {
#line 151
    i = 0;
#line 151
    while (i < lw) {
#line 152
      tmp = fgetc(fd);
#line 152
      *(llframe0[comp] + (lw * j + i)) = (unsigned char )tmp;
#line 151
      i ++;
    }
#line 153
    if (! lower_layer_progressive_frame) {
#line 154
      j ++;
#line 155
      i = 0;
#line 155
      while (i < lw) {
#line 156
        tmp___0 = fgetc(fd);
#line 156
        *(llframe1[comp] + (lw * j + i)) = (unsigned char )tmp___0;
#line 155
        i ++;
      }
    }
#line 150
    j ++;
  }
#line 159
  fclose(fd);
#line 160
  return;
}
}
#line 163 "src/spatscal.c"
static void Read_Lower_Layer_Component_Fieldwise(int comp , int lw , int lh ) 
{ 
  FILE *fd ;
  char fname[256] ;
  char ext[3][3] ;
  int i ;
  int j ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 169
  ext[0][0] = (char )'.';
#line 169
  ext[0][1] = (char )'Y';
#line 169
  ext[0][2] = (char )'\000';
#line 169
  ext[1][0] = (char )'.';
#line 169
  ext[1][1] = (char )'U';
#line 169
  ext[1][2] = (char )'\000';
#line 169
  ext[2][0] = (char )'.';
#line 169
  ext[2][1] = (char )'V';
#line 169
  ext[2][2] = (char )'\000';
#line 173
  if (lower_layer_progressive_frame) {
#line 173
    tmp = 'f';
  } else {
#line 173
    tmp = 'a';
  }
#line 173
  sprintf((char * __restrict  )(fname), (char const   * __restrict  )Lower_Layer_Picture_Filename,
          True_Framenum, tmp);
#line 174
  strcat(fname, ext[comp]);
#line 179
  fd = fopen((char const   * __restrict  )(fname), (char const   * __restrict  )"rb");
#line 180
  if ((unsigned long )fd == (unsigned long )((void *)0)) {
#line 180
    exit(-1);
  }
#line 181
  j = 0;
#line 181
  while (j < lh) {
#line 182
    i = 0;
#line 182
    while (i < lw) {
#line 183
      tmp___1 = fgetc(fd);
#line 183
      *(llframe0[comp] + (lw * j + i)) = (unsigned char )tmp___1;
#line 182
      i ++;
    }
#line 181
    if (lower_layer_progressive_frame) {
#line 181
      tmp___0 = 1;
    } else {
#line 181
      tmp___0 = 2;
    }
#line 181
    j += tmp___0;
  }
#line 184
  fclose(fd);
#line 186
  if (! lower_layer_progressive_frame) {
#line 187
    sprintf((char * __restrict  )(fname), (char const   * __restrict  )Lower_Layer_Picture_Filename,
            True_Framenum, 'b');
#line 188
    strcat(fname, ext[comp]);
#line 193
    fd = fopen((char const   * __restrict  )(fname), (char const   * __restrict  )"rb");
#line 194
    if ((unsigned long )fd == (unsigned long )((void *)0)) {
#line 194
      exit(-1);
    }
#line 195
    j = 1;
#line 195
    while (j < lh) {
#line 196
      i = 0;
#line 196
      while (i < lw) {
#line 197
        tmp___2 = fgetc(fd);
#line 197
        *(llframe1[comp] + (lw * j + i)) = (unsigned char )tmp___2;
#line 196
        i ++;
      }
#line 195
      j += 2;
    }
#line 198
    fclose(fd);
  }
#line 200
  return;
}
}
#line 204 "src/spatscal.c"
static void Make_Spatial_Prediction_Frame(int progressive_frame___0 , int llprogressive_frame ,
                                          unsigned char *fld0 , unsigned char *fld1 ,
                                          short *tmp , unsigned char *dst , int llx0 ,
                                          int lly0 , int llw , int llh , int horizontal_size___0 ,
                                          int vertical_size___0 , int vm , int vn ,
                                          int hm , int hn , int aperture ) 
{ 
  int w ;
  int h ;
  int x0 ;
  int llw2 ;
  int llh2 ;

  {
#line 215
  llw2 = (llw * hn) / hm;
#line 216
  llh2 = (llh * vn) / vm;
#line 218
  if (llprogressive_frame) {
#line 221
    Subsample_Vertical(fld0, tmp, llw, llh, llh2, vm, vn, 0, 1);
  } else
#line 223
  if (progressive_frame___0) {
#line 226
    if (lower_layer_deinterlaced_field_select) {
#line 228
      Deinterlace(fld1, fld0, 0, llw, llh, aperture);
#line 229
      Subsample_Vertical(fld1, tmp, llw, llh, llh2, vm, vn, 0, 1);
    } else {
#line 233
      Deinterlace(fld0, fld1, 1, llw, llh, aperture);
#line 234
      Subsample_Vertical(fld0, tmp, llw, llh, llh2, vm, vn, 0, 1);
    }
  } else {
#line 240
    Deinterlace(fld0, fld1, 1, llw, llh, aperture);
#line 241
    Deinterlace(fld1, fld0, 0, llw, llh, aperture);
#line 242
    Subsample_Vertical(fld0, tmp, llw, llh, llh2, vm, vn, 0, 2);
#line 243
    Subsample_Vertical(fld1, tmp, llw, llh, llh2, vm, vn, 1, 2);
  }
#line 247
  if (lly0 < 0) {
#line 249
    tmp -= llw * lly0;
#line 250
    llh2 += lly0;
#line 251
    if (llh2 < 0) {
#line 252
      llh2 = 0;
    }
#line 253
    if (vertical_size___0 < llh2) {
#line 253
      h = vertical_size___0;
    } else {
#line 253
      h = llh2;
    }
  } else {
#line 257
    dst += horizontal_size___0 * lly0;
#line 258
    h = vertical_size___0 - lly0;
#line 259
    if (h > llh2) {
#line 260
      h = llh2;
    }
  }
#line 264
  if (llx0 < 0) {
#line 266
    x0 = - llx0;
#line 267
    llw2 += llx0;
#line 268
    if (llw2 < 0) {
#line 269
      llw2 = 0;
    }
#line 270
    if (horizontal_size___0 < llw2) {
#line 270
      w = horizontal_size___0;
    } else {
#line 270
      w = llw2;
    }
  } else {
#line 274
    dst += llx0;
#line 275
    x0 = 0;
#line 276
    w = horizontal_size___0 - llx0;
#line 277
    if (w > llw2) {
#line 278
      w = llw2;
    }
  }
#line 281
  Subsample_Horizontal(tmp, dst, x0, w, llw, horizontal_size___0, h, hm, hn);
#line 282
  return;
}
}
#line 298 "src/spatscal.c"
static void Deinterlace(unsigned char *fld0 , unsigned char *fld1 , int j0 , int lx ,
                        int ly , int aperture ) 
{ 
  int i ;
  int j ;
  int v ;
  unsigned char *p0 ;
  unsigned char *p0m1 ;
  unsigned char *p0p1 ;
  unsigned char *p1 ;
  unsigned char *p1m2 ;
  unsigned char *p1p2 ;
  int tmp ;

  {
#line 307
  j = j0;
#line 307
  while (j < ly) {
#line 309
    p0 = fld0 + lx * j;
#line 310
    if (j == 0) {
#line 310
      p0m1 = p0 + lx;
    } else {
#line 310
      p0m1 = p0 - lx;
    }
#line 311
    if (j == ly - 1) {
#line 311
      p0p1 = p0 - lx;
    } else {
#line 311
      p0p1 = p0 + lx;
    }
#line 313
    if (aperture) {
#line 314
      i = 0;
#line 314
      while (i < lx) {
#line 315
        *(p0 + i) = (unsigned char )((unsigned int )(((int )*(p0m1 + i) + (int )*(p0p1 + i)) + 1) >> 1);
#line 314
        i ++;
      }
    } else {
#line 318
      p1 = fld1 + lx * j;
#line 319
      if (j < 2) {
#line 319
        p1m2 = p1;
      } else {
#line 319
        p1m2 = p1 - 2 * lx;
      }
#line 320
      if (j >= ly - 2) {
#line 320
        p1p2 = p1;
      } else {
#line 320
        p1p2 = p1 + 2 * lx;
      }
#line 321
      i = 0;
#line 321
      while (i < lx) {
#line 323
        v = ((8 * ((int )*(p0m1 + i) + (int )*(p0p1 + i)) + 2 * (int )*(p1 + i)) - (int )*(p1m2 + i)) - (int )*(p1p2 + i);
#line 324
        if (v >= 0) {
#line 324
          tmp = 8;
        } else {
#line 324
          tmp = 7;
        }
#line 324
        *(p0 + i) = *(Clip + ((v + tmp) >> 4));
#line 321
        i ++;
      }
    }
#line 307
    j += 2;
  }
#line 328
  return;
}
}
#line 331 "src/spatscal.c"
static void Subsample_Vertical(unsigned char *s , short *d , int lx , int lys , int lyd ,
                               int m , int n , int j0 , int dj ) 
{ 
  int i ;
  int j ;
  int c1 ;
  int c2 ;
  int jd ;
  unsigned char *s1 ;
  unsigned char *s2 ;
  short *d1 ;

  {
#line 340
  j = j0;
#line 340
  while (j < lyd) {
#line 342
    d1 = d + lx * j;
#line 343
    jd = (j * m) / n;
#line 344
    s1 = s + lx * jd;
#line 345
    if (jd < lys - 1) {
#line 345
      s2 = s1 + lx;
    } else {
#line 345
      s2 = s1;
    }
#line 346
    c2 = (16 * ((j * m) % n) + (n >> 1)) / n;
#line 347
    c1 = 16 - c2;
#line 348
    i = 0;
#line 348
    while (i < lx) {
#line 349
      *(d1 + i) = (short )(c1 * (int )*(s1 + i) + c2 * (int )*(s2 + i));
#line 348
      i ++;
    }
#line 340
    j += dj;
  }
#line 351
  return;
}
}
#line 354 "src/spatscal.c"
static void Subsample_Horizontal(short *s , unsigned char *d , int x0 , int lx , int lxs ,
                                 int lxd , int ly , int m , int n ) 
{ 
  int i ;
  int i1 ;
  int j ;
  int id ;
  int c1 ;
  int c2 ;
  int v ;
  short *s1 ;
  short *s2 ;
  unsigned char *d1 ;
  int tmp ;

  {
#line 363
  i1 = 0;
#line 363
  while (i1 < lx) {
#line 365
    d1 = d + i1;
#line 366
    i = x0 + i1;
#line 367
    id = (i * m) / n;
#line 368
    s1 = s + id;
#line 369
    if (id < lxs - 1) {
#line 369
      s2 = s1 + 1;
    } else {
#line 369
      s2 = s1;
    }
#line 370
    c2 = (16 * ((i * m) % n) + (n >> 1)) / n;
#line 371
    c1 = 16 - c2;
#line 372
    j = 0;
#line 372
    while (j < ly) {
#line 374
      v = c1 * (int )*s1 + c2 * (int )*s2;
#line 375
      if (v >= 0) {
#line 375
        tmp = 128;
      } else {
#line 375
        tmp = 127;
      }
#line 375
      *d1 = (unsigned char )((v + tmp) >> 8);
#line 376
      d1 += lxd;
#line 377
      s1 += lxs;
#line 378
      s2 += lxs;
#line 372
      j ++;
    }
#line 363
    i1 ++;
  }
#line 381
  return;
}
}
#line 1 "store.o"
#pragma merger("0","/tmp/cil-66CLArAX.i","-g,-O4")
#line 366 "/usr/include/unistd.h"
extern ssize_t ( __attribute__((__warn_unused_result__)) write)(int __fd , void const   *__buf ,
                                                                size_t __n ) ;
#line 91 "src/store.c"
static void store_one(char *outname , unsigned char **src , int offset , int incr ,
                      int height ) ;
#line 93
static void store_yuv(char *outname , unsigned char **src , int offset , int incr ,
                      int height ) ;
#line 95
static void store_sif(char *outname , unsigned char **src , int offset , int incr ,
                      int height ) ;
#line 97
static void store_ppm_tga(char *outname , unsigned char **src , int offset , int incr ,
                          int height , int tgaflag ) ;
#line 99
static void store_yuv1(char *name , unsigned char *src , int offset , int incr , int width ,
                       int height ) ;
#line 101
static void putbyte(int c___0 ) ;
#line 102
static void putword(int w ) ;
#line 103
static void conv422to444(unsigned char *src , unsigned char *dst ) ;
#line 104
static void conv420to422(unsigned char *src , unsigned char *dst ) ;
#line 106
static void store_yuv_progressive(char *outname , unsigned char **src , int offset ,
                                  int incr , int height ) ;
#line 110 "src/store.c"
static unsigned char obfr[8192]  ;
#line 111 "src/store.c"
static unsigned char *optr  ;
#line 112 "src/store.c"
static int outfile  ;
#line 117 "src/store.c"
void Write_Frame(unsigned char **src , int frame___0 ) 
{ 
  char outname[256] ;

  {
#line 123
  if (progressive_sequence) {
#line 126
    sprintf((char * __restrict  )(outname), (char const   * __restrict  )Output_Picture_Filename,
            frame___0, 'f');
#line 127
    store_one(outname, src, 0, Coded_Picture_Width, vertical_size);
  } else
#line 123
  if (progressive_frame) {
#line 126
    sprintf((char * __restrict  )(outname), (char const   * __restrict  )Output_Picture_Filename,
            frame___0, 'f');
#line 127
    store_one(outname, src, 0, Coded_Picture_Width, vertical_size);
  } else
#line 123
  if (Frame_Store_Flag) {
#line 126
    sprintf((char * __restrict  )(outname), (char const   * __restrict  )Output_Picture_Filename,
            frame___0, 'f');
#line 127
    store_one(outname, src, 0, Coded_Picture_Width, vertical_size);
  } else {
#line 132
    sprintf((char * __restrict  )(outname), (char const   * __restrict  )Output_Picture_Filename,
            frame___0, 'a');
#line 133
    store_one(outname, src, 0, Coded_Picture_Width << 1, vertical_size >> 1);
#line 135
    sprintf((char * __restrict  )(outname), (char const   * __restrict  )Output_Picture_Filename,
            frame___0, 'b');
#line 136
    store_one(outname, src, Coded_Picture_Width, Coded_Picture_Width << 1, vertical_size >> 1);
  }
#line 139
  return;
}
}
#line 144 "src/store.c"
static void store_one(char *outname , unsigned char **src , int offset , int incr ,
                      int height ) 
{ 


  {
#line 149
  switch (Output_Type) {
  case 0: 
#line 152
  if (incr == Coded_Picture_Width) {
#line 153
    store_yuv_progressive(outname, src, offset, incr, height);
  } else {
#line 155
    store_yuv(outname, src, offset, incr, height);
  }
#line 156
  break;
  case 1: 
#line 158
  store_sif(outname, src, offset, incr, height);
#line 159
  break;
  case 2: 
#line 161
  store_ppm_tga(outname, src, offset, incr, height, 1);
#line 162
  break;
  case 3: 
#line 164
  store_ppm_tga(outname, src, offset, incr, height, 0);
#line 165
  break;
  default: 
#line 172
  break;
  }
#line 174
  return;
}
}
#line 176 "src/store.c"
static void store_yuvp(char *name , unsigned char *src , int offset , int incr , int width ,
                       int height ) 
{ 
  ssize_t tmp ;

  {
#line 184
  if (! Quiet_Flag) {
#line 185
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"saving %s\n",
            name);
  }
#line 187
  outfile = open((char const   *)name, 577, 438);
#line 187
  if (outfile == -1) {
#line 189
    sprintf((char * __restrict  )(Error_Text), (char const   * __restrict  )"Couldn\'t create %s\n",
            name);
#line 190
    Error(Error_Text);
  }
#line 193
  tmp = write(outfile, (void const   *)src, (size_t )(width * height));
#line 193
  if (tmp == (ssize_t )(width * height)) {
#line 193
    if (! "frame write problem\n") {
#line 193
      __assert_fail("write(outfile,src,width*height)==width*height && \"frame write problem\\n\"",
                    "src/store.c", 193U, "store_yuvp");
    }
  } else {
#line 193
    __assert_fail("write(outfile,src,width*height)==width*height && \"frame write problem\\n\"",
                  "src/store.c", 193U, "store_yuvp");
  }
#line 194
  close(outfile);
#line 195
  return;
}
}
#line 198 "src/store.c"
static void store_yuv_progressive(char *outname , unsigned char **src , int offset ,
                                  int incr , int height ) 
{ 
  int hsize ;
  char tmpname[256] ;

  {
#line 206
  hsize = horizontal_size;
#line 208
  sprintf((char * __restrict  )(tmpname), (char const   * __restrict  )"%s.Y", outname);
#line 209
  store_yuvp(tmpname, *(src + 0), offset, incr, hsize, height);
#line 211
  if (chroma_format != 3) {
#line 213
    offset >>= 1;
#line 213
    incr >>= 1;
#line 213
    hsize >>= 1;
  }
#line 216
  if (chroma_format == 1) {
#line 218
    height >>= 1;
  }
#line 221
  sprintf((char * __restrict  )(tmpname), (char const   * __restrict  )"%s.U", outname);
#line 222
  store_yuvp(tmpname, *(src + 1), offset, incr, hsize, height);
#line 224
  sprintf((char * __restrict  )(tmpname), (char const   * __restrict  )"%s.V", outname);
#line 225
  store_yuvp(tmpname, *(src + 2), offset, incr, hsize, height);
#line 226
  return;
}
}
#line 229 "src/store.c"
static void store_yuv(char *outname , unsigned char **src , int offset , int incr ,
                      int height ) 
{ 
  int hsize ;
  char tmpname[256] ;

  {
#line 237
  hsize = horizontal_size;
#line 239
  sprintf((char * __restrict  )(tmpname), (char const   * __restrict  )"%s.Y", outname);
#line 240
  store_yuv1(tmpname, *(src + 0), offset, incr, hsize, height);
#line 242
  if (chroma_format != 3) {
#line 244
    offset >>= 1;
#line 244
    incr >>= 1;
#line 244
    hsize >>= 1;
  }
#line 247
  if (chroma_format == 1) {
#line 249
    height >>= 1;
  }
#line 252
  sprintf((char * __restrict  )(tmpname), (char const   * __restrict  )"%s.U", outname);
#line 253
  store_yuv1(tmpname, *(src + 1), offset, incr, hsize, height);
#line 255
  sprintf((char * __restrict  )(tmpname), (char const   * __restrict  )"%s.V", outname);
#line 256
  store_yuv1(tmpname, *(src + 2), offset, incr, hsize, height);
#line 257
  return;
}
}
#line 260 "src/store.c"
static void store_yuv1(char *name , unsigned char *src , int offset , int incr , int width ,
                       int height ) 
{ 
  int i ;
  int j ;
  unsigned char *p ;
  unsigned char *tmp ;

  {
#line 268
  if (! Quiet_Flag) {
#line 269
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"saving %s\n",
            name);
  }
#line 271
  outfile = open((char const   *)name, 577, 438);
#line 271
  if (outfile == -1) {
#line 273
    sprintf((char * __restrict  )(Error_Text), (char const   * __restrict  )"Couldn\'t create %s\n",
            name);
#line 274
    Error(Error_Text);
  }
#line 277
  optr = obfr;
#line 279
  i = 0;
#line 279
  while (i < height) {
#line 281
    p = (src + offset) + incr * i;
#line 282
    j = 0;
#line 282
    while (j < width) {
#line 283
      tmp = p;
#line 283
      p ++;
#line 283
      putbyte((int )*tmp);
#line 282
      j ++;
    }
#line 279
    i ++;
  }
#line 286
  if ((unsigned long )optr != (unsigned long )(obfr)) {
#line 287
    write(outfile, (void const   *)(obfr), (size_t )(optr - obfr));
  }
#line 289
  close(outfile);
#line 290
  return;
}
}
#line 302 "src/store.c"
static unsigned char *u422  ;
#line 302 "src/store.c"
static unsigned char *v422  ;
#line 295 "src/store.c"
static void store_sif(char *outname , unsigned char **src , int offset , int incr ,
                      int height ) 
{ 
  int i ;
  int j ;
  unsigned char *py ;
  unsigned char *pu ;
  unsigned char *pv ;
  void *tmp ;
  void *tmp___0 ;
  unsigned char *tmp___1 ;
  unsigned char *tmp___2 ;
  unsigned char *tmp___3 ;
  unsigned char *tmp___4 ;

  {
#line 304
  if (chroma_format == 3) {
#line 305
    Error((char *)"4:4:4 not supported for SIF format");
  }
#line 307
  if (chroma_format == 2) {
#line 309
    u422 = *(src + 1);
#line 310
    v422 = *(src + 2);
  } else {
#line 314
    if (! u422) {
#line 316
      tmp = malloc((size_t )((Coded_Picture_Width >> 1) * Coded_Picture_Height));
#line 316
      u422 = (unsigned char *)tmp;
#line 316
      if (! u422) {
#line 318
        Error((char *)"malloc failed");
      }
#line 319
      tmp___0 = malloc((size_t )((Coded_Picture_Width >> 1) * Coded_Picture_Height));
#line 319
      v422 = (unsigned char *)tmp___0;
#line 319
      if (! v422) {
#line 321
        Error((char *)"malloc failed");
      }
    }
#line 324
    conv420to422(*(src + 1), u422);
#line 325
    conv420to422(*(src + 2), v422);
  }
#line 328
  strcat(outname, ".SIF");
#line 330
  if (! Quiet_Flag) {
#line 331
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"saving %s\n",
            outname);
  }
#line 333
  outfile = open((char const   *)outname, 577, 438);
#line 333
  if (outfile == -1) {
#line 335
    sprintf((char * __restrict  )(Error_Text), (char const   * __restrict  )"Couldn\'t create %s\n",
            outname);
#line 336
    Error(Error_Text);
  }
#line 339
  optr = obfr;
#line 341
  i = 0;
#line 341
  while (i < height) {
#line 343
    py = (*(src + 0) + offset) + incr * i;
#line 344
    pu = (u422 + (offset >> 1)) + (incr >> 1) * i;
#line 345
    pv = (v422 + (offset >> 1)) + (incr >> 1) * i;
#line 347
    j = 0;
#line 347
    while (j < horizontal_size) {
#line 349
      tmp___1 = pu;
#line 349
      pu ++;
#line 349
      putbyte((int )*tmp___1);
#line 350
      tmp___2 = py;
#line 350
      py ++;
#line 350
      putbyte((int )*tmp___2);
#line 351
      tmp___3 = pv;
#line 351
      pv ++;
#line 351
      putbyte((int )*tmp___3);
#line 352
      tmp___4 = py;
#line 352
      py ++;
#line 352
      putbyte((int )*tmp___4);
#line 347
      j += 2;
    }
#line 341
    i ++;
  }
#line 356
  if ((unsigned long )optr != (unsigned long )(obfr)) {
#line 357
    write(outfile, (void const   *)(obfr), (size_t )(optr - obfr));
  }
#line 359
  close(outfile);
#line 360
  return;
}
}
#line 375 "src/store.c"
static unsigned char tga24[14]  = 
#line 375
  {      (unsigned char)0,      (unsigned char)0,      (unsigned char)2,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)24,      (unsigned char)32};
#line 377 "src/store.c"
static unsigned char *u422___0  ;
#line 377 "src/store.c"
static unsigned char *v422___0  ;
#line 377 "src/store.c"
static unsigned char *u444  ;
#line 377 "src/store.c"
static unsigned char *v444  ;
#line 365 "src/store.c"
static void store_ppm_tga(char *outname , unsigned char **src , int offset , int incr ,
                          int height , int tgaflag ) 
{ 
  int i ;
  int j ;
  int y ;
  int u ;
  int v ;
  int r ;
  int g ;
  int b ;
  int crv ;
  int cbu ;
  int cgu ;
  int cgv ;
  unsigned char *py ;
  unsigned char *pu ;
  unsigned char *pv ;
  char header[256] ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  char const   *tmp___3 ;
  unsigned char *tmp___4 ;
  unsigned char *tmp___5 ;
  unsigned char *tmp___6 ;

  {
#line 379
  if (chroma_format == 3) {
#line 381
    u444 = *(src + 1);
#line 382
    v444 = *(src + 2);
  } else {
#line 386
    if (! u444) {
#line 388
      if (chroma_format == 1) {
#line 390
        tmp = malloc((size_t )((Coded_Picture_Width >> 1) * Coded_Picture_Height));
#line 390
        u422___0 = (unsigned char *)tmp;
#line 390
        if (! u422___0) {
#line 392
          Error((char *)"malloc failed");
        }
#line 393
        tmp___0 = malloc((size_t )((Coded_Picture_Width >> 1) * Coded_Picture_Height));
#line 393
        v422___0 = (unsigned char *)tmp___0;
#line 393
        if (! v422___0) {
#line 395
          Error((char *)"malloc failed");
        }
      }
#line 398
      tmp___1 = malloc((size_t )(Coded_Picture_Width * Coded_Picture_Height));
#line 398
      u444 = (unsigned char *)tmp___1;
#line 398
      if (! u444) {
#line 400
        Error((char *)"malloc failed");
      }
#line 402
      tmp___2 = malloc((size_t )(Coded_Picture_Width * Coded_Picture_Height));
#line 402
      v444 = (unsigned char *)tmp___2;
#line 402
      if (! v444) {
#line 404
        Error((char *)"malloc failed");
      }
    }
#line 407
    if (chroma_format == 1) {
#line 409
      conv420to422(*(src + 1), u422___0);
#line 410
      conv420to422(*(src + 2), v422___0);
#line 411
      conv422to444(u422___0, u444);
#line 412
      conv422to444(v422___0, v444);
    } else {
#line 416
      conv422to444(*(src + 1), u444);
#line 417
      conv422to444(*(src + 2), v444);
    }
  }
#line 421
  if (tgaflag) {
#line 421
    tmp___3 = ".tga";
  } else {
#line 421
    tmp___3 = ".ppm";
  }
#line 421
  strcat(outname, tmp___3);
#line 423
  if (! Quiet_Flag) {
#line 424
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"saving %s\n",
            outname);
  }
#line 426
  outfile = open((char const   *)outname, 577, 438);
#line 426
  if (outfile == -1) {
#line 428
    sprintf((char * __restrict  )(Error_Text), (char const   * __restrict  )"Couldn\'t create %s\n",
            outname);
#line 429
    Error(Error_Text);
  }
#line 432
  optr = obfr;
#line 434
  if (tgaflag) {
#line 437
    i = 0;
#line 437
    while (i < 12) {
#line 438
      putbyte((int )tga24[i]);
#line 437
      i ++;
    }
#line 440
    putword(horizontal_size);
#line 440
    putword(height);
#line 441
    putbyte((int )tga24[12]);
#line 441
    putbyte((int )tga24[13]);
  } else {
#line 446
    sprintf((char * __restrict  )(header), (char const   * __restrict  )"P6\n%d %d\n255\n",
            horizontal_size, height);
#line 448
    i = 0;
#line 448
    while ((int )header[i] != 0) {
#line 449
      putbyte((int )header[i]);
#line 448
      i ++;
    }
  }
#line 453
  crv = Inverse_Table_6_9[matrix_coefficients][0];
#line 454
  cbu = Inverse_Table_6_9[matrix_coefficients][1];
#line 455
  cgu = Inverse_Table_6_9[matrix_coefficients][2];
#line 456
  cgv = Inverse_Table_6_9[matrix_coefficients][3];
#line 458
  i = 0;
#line 458
  while (i < height) {
#line 460
    py = (*(src + 0) + offset) + incr * i;
#line 461
    pu = (u444 + offset) + incr * i;
#line 462
    pv = (v444 + offset) + incr * i;
#line 464
    j = 0;
#line 464
    while (j < horizontal_size) {
#line 466
      tmp___4 = pu;
#line 466
      pu ++;
#line 466
      u = (int )*tmp___4 - 128;
#line 467
      tmp___5 = pv;
#line 467
      pv ++;
#line 467
      v = (int )*tmp___5 - 128;
#line 468
      tmp___6 = py;
#line 468
      py ++;
#line 468
      y = 76309 * ((int )*tmp___6 - 16);
#line 469
      r = (int )*(Clip + (((y + crv * v) + 32768) >> 16));
#line 470
      g = (int )*(Clip + ((((y - cgu * u) - cgv * v) + 32768) >> 16));
#line 471
      b = (int )*(Clip + (((y + cbu * u) + 32786) >> 16));
#line 473
      if (tgaflag) {
#line 475
        putbyte(b);
#line 475
        putbyte(g);
#line 475
        putbyte(r);
      } else {
#line 479
        putbyte(r);
#line 479
        putbyte(g);
#line 479
        putbyte(b);
      }
#line 464
      j ++;
    }
#line 458
    i ++;
  }
#line 484
  if ((unsigned long )optr != (unsigned long )(obfr)) {
#line 485
    write(outfile, (void const   *)(obfr), (size_t )(optr - obfr));
  }
#line 487
  close(outfile);
#line 488
  return;
}
}
#line 490 "src/store.c"
static void putbyte(int c___0 ) 
{ 
  unsigned char *tmp ;

  {
#line 493
  tmp = optr;
#line 493
  optr ++;
#line 493
  *tmp = (unsigned char )c___0;
#line 495
  if ((unsigned long )optr == (unsigned long )(obfr + 8192)) {
#line 497
    write(outfile, (void const   *)(obfr), (size_t )8192);
#line 498
    optr = obfr;
  }
#line 500
  return;
}
}
#line 502 "src/store.c"
static void putword(int w ) 
{ 


  {
#line 505
  putbyte(w);
#line 505
  putbyte(w >> 8);
#line 506
  return;
}
}
#line 509 "src/store.c"
static void conv422to444(unsigned char *src , unsigned char *dst ) 
{ 
  int i ;
  int i2 ;
  int w ;
  int j ;
  int im3 ;
  int im2 ;
  int im1 ;
  int ip1 ;
  int ip2 ;
  int ip3 ;

  {
#line 514
  w = Coded_Picture_Width >> 1;
#line 516
  if (base.MPEG2_Flag) {
#line 518
    j = 0;
#line 518
    while (j < Coded_Picture_Height) {
#line 520
      i = 0;
#line 520
      while (i < w) {
#line 522
        i2 = i << 1;
#line 523
        if (i < 2) {
#line 523
          im2 = 0;
        } else {
#line 523
          im2 = i - 2;
        }
#line 524
        if (i < 1) {
#line 524
          im1 = 0;
        } else {
#line 524
          im1 = i - 1;
        }
#line 525
        if (i < w - 1) {
#line 525
          ip1 = i + 1;
        } else {
#line 525
          ip1 = w - 1;
        }
#line 526
        if (i < w - 2) {
#line 526
          ip2 = i + 2;
        } else {
#line 526
          ip2 = w - 1;
        }
#line 527
        if (i < w - 3) {
#line 527
          ip3 = i + 3;
        } else {
#line 527
          ip3 = w - 1;
        }
#line 531
        *(dst + i2) = *(src + i);
#line 534
        *(dst + (i2 + 1)) = *(Clip + ((((21 * ((int )*(src + im2) + (int )*(src + ip3)) - 52 * ((int )*(src + im1) + (int )*(src + ip2))) + 159 * ((int )*(src + i) + (int )*(src + ip1))) + 128) >> 8));
#line 520
        i ++;
      }
#line 538
      src += w;
#line 539
      dst += Coded_Picture_Width;
#line 518
      j ++;
    }
  } else {
#line 544
    j = 0;
#line 544
    while (j < Coded_Picture_Height) {
#line 546
      i = 0;
#line 546
      while (i < w) {
#line 549
        i2 = i << 1;
#line 550
        if (i < 3) {
#line 550
          im3 = 0;
        } else {
#line 550
          im3 = i - 3;
        }
#line 551
        if (i < 2) {
#line 551
          im2 = 0;
        } else {
#line 551
          im2 = i - 2;
        }
#line 552
        if (i < 1) {
#line 552
          im1 = 0;
        } else {
#line 552
          im1 = i - 1;
        }
#line 553
        if (i < w - 1) {
#line 553
          ip1 = i + 1;
        } else {
#line 553
          ip1 = w - 1;
        }
#line 554
        if (i < w - 2) {
#line 554
          ip2 = i + 2;
        } else {
#line 554
          ip2 = w - 1;
        }
#line 555
        if (i < w - 3) {
#line 555
          ip3 = i + 3;
        } else {
#line 555
          ip3 = w - 1;
        }
#line 558
        *(dst + i2) = *(Clip + (((((((5 * (int )*(src + im3) - 21 * (int )*(src + im2)) + 70 * (int )*(src + im1)) + 228 * (int )*(src + i)) - 37 * (int )*(src + ip1)) + 11 * (int )*(src + ip2)) + 128) >> 8));
#line 565
        *(dst + (i2 + 1)) = *(Clip + (((((((5 * (int )*(src + ip3) - 21 * (int )*(src + ip2)) + 70 * (int )*(src + ip1)) + 228 * (int )*(src + i)) - 37 * (int )*(src + im1)) + 11 * (int )*(src + im2)) + 128) >> 8));
#line 546
        i ++;
      }
#line 572
      src += w;
#line 573
      dst += Coded_Picture_Width;
#line 544
      j ++;
    }
  }
#line 576
  return;
}
}
#line 579 "src/store.c"
static void conv420to422(unsigned char *src , unsigned char *dst ) 
{ 
  int w ;
  int h ;
  int i ;
  int j ;
  int j2 ;
  int jm6 ;
  int jm5 ;
  int jm4 ;
  int jm3 ;
  int jm2 ;
  int jm1 ;
  int jp1 ;
  int jp2 ;
  int jp3 ;
  int jp4 ;
  int jp5 ;
  int jp6 ;
  int jp7 ;

  {
#line 585
  w = Coded_Picture_Width >> 1;
#line 586
  h = Coded_Picture_Height >> 1;
#line 588
  if (progressive_frame) {
#line 591
    i = 0;
#line 591
    while (i < w) {
#line 593
      j = 0;
#line 593
      while (j < h) {
#line 595
        j2 = j << 1;
#line 596
        if (j < 3) {
#line 596
          jm3 = 0;
        } else {
#line 596
          jm3 = j - 3;
        }
#line 597
        if (j < 2) {
#line 597
          jm2 = 0;
        } else {
#line 597
          jm2 = j - 2;
        }
#line 598
        if (j < 1) {
#line 598
          jm1 = 0;
        } else {
#line 598
          jm1 = j - 1;
        }
#line 599
        if (j < h - 1) {
#line 599
          jp1 = j + 1;
        } else {
#line 599
          jp1 = h - 1;
        }
#line 600
        if (j < h - 2) {
#line 600
          jp2 = j + 2;
        } else {
#line 600
          jp2 = h - 1;
        }
#line 601
        if (j < h - 3) {
#line 601
          jp3 = j + 3;
        } else {
#line 601
          jp3 = h - 1;
        }
#line 605
        *(dst + w * j2) = *(Clip + (((((((3 * (int )*(src + w * jm3) - 16 * (int )*(src + w * jm2)) + 67 * (int )*(src + w * jm1)) + 227 * (int )*(src + w * j)) - 32 * (int )*(src + w * jp1)) + 7 * (int )*(src + w * jp2)) + 128) >> 8));
#line 612
        *(dst + w * (j2 + 1)) = *(Clip + (((((((3 * (int )*(src + w * jp3) - 16 * (int )*(src + w * jp2)) + 67 * (int )*(src + w * jp1)) + 227 * (int )*(src + w * j)) - 32 * (int )*(src + w * jm1)) + 7 * (int )*(src + w * jm2)) + 128) >> 8));
#line 593
        j ++;
      }
#line 619
      src ++;
#line 620
      dst ++;
#line 591
      i ++;
    }
  } else {
#line 626
    i = 0;
#line 626
    while (i < w) {
#line 628
      j = 0;
#line 628
      while (j < h) {
#line 630
        j2 = j << 1;
#line 633
        if (j < 6) {
#line 633
          jm6 = 0;
        } else {
#line 633
          jm6 = j - 6;
        }
#line 634
        if (j < 4) {
#line 634
          jm4 = 0;
        } else {
#line 634
          jm4 = j - 4;
        }
#line 635
        if (j < 2) {
#line 635
          jm2 = 0;
        } else {
#line 635
          jm2 = j - 2;
        }
#line 636
        if (j < h - 2) {
#line 636
          jp2 = j + 2;
        } else {
#line 636
          jp2 = h - 2;
        }
#line 637
        if (j < h - 4) {
#line 637
          jp4 = j + 4;
        } else {
#line 637
          jp4 = h - 2;
        }
#line 638
        if (j < h - 6) {
#line 638
          jp6 = j + 6;
        } else {
#line 638
          jp6 = h - 2;
        }
#line 642
        *(dst + w * j2) = *(Clip + ((((((((int )*(src + w * jm6) - 7 * (int )*(src + w * jm4)) + 30 * (int )*(src + w * jm2)) + 248 * (int )*(src + w * j)) - 21 * (int )*(src + w * jp2)) + 5 * (int )*(src + w * jp4)) + 128) >> 8));
#line 651
        *(dst + w * (j2 + 2)) = *(Clip + (((((((7 * (int )*(src + w * jm4) - 35 * (int )*(src + w * jm2)) + 194 * (int )*(src + w * j)) + 110 * (int )*(src + w * jp2)) - 24 * (int )*(src + w * jp4)) + 4 * (int )*(src + w * jp6)) + 128) >> 8));
#line 659
        if (j < 5) {
#line 659
          jm5 = 1;
        } else {
#line 659
          jm5 = j - 5;
        }
#line 660
        if (j < 3) {
#line 660
          jm3 = 1;
        } else {
#line 660
          jm3 = j - 3;
        }
#line 661
        if (j < 1) {
#line 661
          jm1 = 1;
        } else {
#line 661
          jm1 = j - 1;
        }
#line 662
        if (j < h - 1) {
#line 662
          jp1 = j + 1;
        } else {
#line 662
          jp1 = h - 1;
        }
#line 663
        if (j < h - 3) {
#line 663
          jp3 = j + 3;
        } else {
#line 663
          jp3 = h - 1;
        }
#line 664
        if (j < h - 5) {
#line 664
          jp5 = j + 5;
        } else {
#line 664
          jp5 = h - 1;
        }
#line 665
        if (j < h - 7) {
#line 665
          jp7 = j + 7;
        } else {
#line 665
          jp7 = h - 1;
        }
#line 669
        *(dst + w * (j2 + 1)) = *(Clip + (((((((7 * (int )*(src + w * jp5) - 35 * (int )*(src + w * jp3)) + 194 * (int )*(src + w * jp1)) + 110 * (int )*(src + w * jm1)) - 24 * (int )*(src + w * jm3)) + 4 * (int )*(src + w * jm5)) + 128) >> 8));
#line 676
        *(dst + w * (j2 + 3)) = *(Clip + ((((((((int )*(src + w * jp7) - 7 * (int )*(src + w * jp5)) + 30 * (int )*(src + w * jp3)) + 248 * (int )*(src + w * jp1)) - 21 * (int )*(src + w * jm1)) + 5 * (int )*(src + w * jm3)) + 128) >> 8));
#line 628
        j += 2;
      }
#line 683
      src ++;
#line 684
      dst ++;
#line 626
      i ++;
    }
  }
#line 687
  return;
}
}
#line 1 "subspic.o"
#pragma merger("0","/tmp/cil-_v9fDrHL.i","-g,-O4")
#line 749 "/usr/include/stdio.h"
extern int fseek(FILE *__stream , long __off , int __whence ) ;
#line 91 "src/subspic.c"
static void Read_Frame(char *fname , unsigned char **frame___0 , int framenum ) ;
#line 93
static void Copy_Frame(unsigned char *src , unsigned char *dst , int width , int height ,
                       int parity , int field_mode ) ;
#line 95
static int Read_Components(char *filename , unsigned char **frame___0 , int framenum ) ;
#line 97
static int Read_Component(char *Filename , unsigned char *Frame , int Width , int Height ) ;
#line 99
static int Extract_Components(char *filename , unsigned char **frame___0 , int framenum ) ;
#line 109 "src/subspic.c"
static int previous_temporal_reference  ;
#line 110 "src/subspic.c"
static int previous_bitstream_framenum  ;
#line 111 "src/subspic.c"
static int previous_anchor_temporal_reference  ;
#line 112 "src/subspic.c"
static int previous_anchor_bitstream_framenum  ;
#line 113 "src/subspic.c"
static int previous_picture_coding_type  ;
#line 114 "src/subspic.c"
static int bgate  ;
#line 104 "src/subspic.c"
void Substitute_Frame_Buffer(int bitstream_framenum , int sequence_framenum ) 
{ 
  int substitute_display_framenum ;

  {
#line 127
  if (sequence_framenum != 0) {
#line 127
    goto _L___0;
  } else
#line 127
  if (Second_Field) {
    _L___0: /* CIL Label */ 
#line 130
    if (picture_structure == 3) {
#line 130
      goto _L;
    } else
#line 130
    if (! Second_Field) {
      _L: /* CIL Label */ 
#line 132
      if (picture_coding_type == 2) {
#line 135
        substitute_display_framenum = bitstream_framenum - 1;
#line 137
        Read_Frame(Substitute_Picture_Filename, forward_reference_frame, substitute_display_framenum);
      } else
#line 143
      if (picture_coding_type == 3) {
#line 143
        if (bgate != 1) {
#line 145
          substitute_display_framenum = ((previous_temporal_reference - temporal_reference) + bitstream_framenum) - 1;
#line 149
          Read_Frame(Substitute_Picture_Filename, backward_reference_frame, substitute_display_framenum);
        }
      }
    } else
#line 154
    if (Second_Field) {
#line 154
      if (picture_coding_type == 2) {
#line 157
        if (previous_picture_coding_type == 1) {
#line 157
          if (picture_coding_type == 2) {
#line 159
            substitute_display_framenum = bitstream_framenum;
          } else {
#line 163
            substitute_display_framenum = ((temporal_reference - previous_anchor_temporal_reference) + bitstream_framenum) - 1;
          }
        } else {
#line 163
          substitute_display_framenum = ((temporal_reference - previous_anchor_temporal_reference) + bitstream_framenum) - 1;
        }
#line 168
        Read_Frame(Substitute_Picture_Filename, current_frame, substitute_display_framenum);
      }
    }
  }
#line 180
  if (picture_coding_type == 3) {
#line 181
    bgate = 1;
  } else {
#line 183
    bgate = 0;
  }
#line 186
  if (picture_structure == 3) {
#line 188
    previous_temporal_reference = temporal_reference;
#line 189
    previous_bitstream_framenum = bitstream_framenum;
  } else
#line 186
  if (! Second_Field) {
#line 188
    previous_temporal_reference = temporal_reference;
#line 189
    previous_bitstream_framenum = bitstream_framenum;
  }
#line 193
  if (picture_coding_type != 3) {
#line 193
    if (picture_structure == 3) {
#line 196
      previous_anchor_temporal_reference = temporal_reference;
#line 197
      previous_anchor_bitstream_framenum = bitstream_framenum;
    } else
#line 193
    if (Second_Field) {
#line 196
      previous_anchor_temporal_reference = temporal_reference;
#line 197
      previous_anchor_bitstream_framenum = bitstream_framenum;
    }
  }
#line 200
  previous_picture_coding_type = picture_coding_type;
#line 202
  return;
}
}
#line 207 "src/subspic.c"
static void Read_Frame(char *fname , unsigned char **frame___0 , int framenum ) 
{ 
  int parity ;
  int rerr ;
  int field_mode ;

  {
#line 213
  rerr = 0;
#line 216
  if (framenum < 0) {
#line 217
    printf((char const   * __restrict  )"ERROR: framenum (%d) is less than zero\n",
           framenum);
  }
#line 220
  if (Big_Picture_Flag) {
#line 221
    rerr = Extract_Components(fname, (unsigned char **)(substitute_frame), framenum);
  } else {
#line 223
    rerr = Read_Components(fname, (unsigned char **)(substitute_frame), framenum);
  }
#line 225
  if (rerr != 0) {
#line 227
    printf((char const   * __restrict  )"was unable to substitute frame\n");
  }
#line 233
  if (Second_Field) {
#line 233
    if (picture_coding_type == 2) {
#line 235
      if (picture_structure == 1) {
#line 235
        parity = 1;
      } else {
#line 235
        parity = 0;
      }
#line 236
      if (picture_structure == 3) {
#line 236
        field_mode = 0;
      } else {
#line 236
        field_mode = 1;
      }
    } else {
#line 243
      parity = 0;
#line 244
      field_mode = 0;
    }
  } else {
#line 243
    parity = 0;
#line 244
    field_mode = 0;
  }
#line 248
  Copy_Frame(substitute_frame[0], *(frame___0 + 0), Coded_Picture_Width, Coded_Picture_Height,
             parity, field_mode);
#line 251
  Copy_Frame(substitute_frame[1], *(frame___0 + 1), Chroma_Width, Chroma_Height, parity,
             field_mode);
#line 254
  Copy_Frame(substitute_frame[2], *(frame___0 + 2), Chroma_Width, Chroma_Height, parity,
             field_mode);
#line 262
  return;
}
}
#line 267 "src/subspic.c"
static int Read_Components(char *filename , unsigned char **frame___0 , int framenum ) 
{ 
  int err ;
  char outname[256] ;
  char name[256] ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 272
  err = 0;
#line 276
  sprintf((char * __restrict  )(outname), (char const   * __restrict  )filename, framenum);
#line 279
  sprintf((char * __restrict  )(name), (char const   * __restrict  )"%s.Y", outname);
#line 280
  tmp = Read_Component(name, *(frame___0 + 0), Coded_Picture_Width, Coded_Picture_Height);
#line 280
  err += tmp;
#line 283
  sprintf((char * __restrict  )(name), (char const   * __restrict  )"%s.U", outname);
#line 284
  tmp___0 = Read_Component(name, *(frame___0 + 1), Chroma_Width, Chroma_Height);
#line 284
  err += tmp___0;
#line 286
  sprintf((char * __restrict  )(name), (char const   * __restrict  )"%s.V", outname);
#line 287
  tmp___1 = Read_Component(name, *(frame___0 + 2), Chroma_Width, Chroma_Height);
#line 287
  err += tmp___1;
#line 289
  return (err);
}
}
#line 293 "src/subspic.c"
static int Read_Component(char *Filename , unsigned char *Frame , int Width , int Height ) 
{ 
  int Size ;
  int Bytes_Read ;
  int Infile ;
  int tmp ;
  ssize_t tmp___0 ;

  {
#line 303
  Size = Width * Height;
#line 309
  Infile = open((char const   *)Filename, 0);
#line 309
  if (Infile) {
#line 309
    tmp = 0;
  } else {
#line 309
    tmp = 1;
  }
#line 309
  if (tmp < 0) {
#line 311
    printf((char const   * __restrict  )"ERROR: unable to open reference filename (%s)\n",
           Filename);
#line 312
    return (-1);
  }
#line 315
  tmp___0 = read(Infile, (void *)Frame, (size_t )Size);
#line 315
  Bytes_Read = (int )tmp___0;
#line 317
  if (Bytes_Read != Size) {
#line 319
    printf((char const   * __restrict  )"was able to read only %d bytes of %d of file %s\n",
           Bytes_Read, Size, Filename);
  }
#line 323
  close(Infile);
#line 324
  return (0);
}
}
#line 334 "src/subspic.c"
static int Extract_Components(char *filename , unsigned char **frame___0 , int framenum ) 
{ 
  FILE *fd ;
  int line ;
  int size ;
  int offset ;

  {
#line 345
  fd = fopen((char const   * __restrict  )filename, (char const   * __restrict  )"rb");
#line 345
  if (! fd) {
#line 347
    sprintf((char * __restrict  )(Error_Text), (char const   * __restrict  )"Couldn\'t open %s\n",
            filename);
#line 348
    return (-1);
  }
#line 352
  size = Coded_Picture_Width * Coded_Picture_Height;
#line 354
  if (chroma_format == 3) {
#line 355
    size *= 3;
  } else
#line 356
  if (chroma_format == 2) {
#line 357
    size *= 2;
  } else
#line 358
  if (chroma_format == 1) {
#line 359
    size = size * 3 >> 1;
  } else {
#line 361
    printf((char const   * __restrict  )"ERROR: chroma_format (%d) not recognized\n",
           chroma_format);
  }
#line 365
  offset = size * framenum;
#line 375
  fseek(fd, (long )offset, 0);
#line 378
  line = 0;
#line 378
  while (line < Coded_Picture_Height) {
#line 380
    fread((void * __restrict  )(*(frame___0 + 0) + line * Coded_Picture_Width), (size_t )1,
          (size_t )Coded_Picture_Width, (FILE * __restrict  )fd);
#line 378
    line ++;
  }
#line 384
  line = 0;
#line 384
  while (line < Chroma_Height) {
#line 386
    fread((void * __restrict  )(*(frame___0 + 1) + line * Chroma_Width), (size_t )1,
          (size_t )Chroma_Width, (FILE * __restrict  )fd);
#line 384
    line ++;
  }
#line 390
  line = 0;
#line 390
  while (line < Chroma_Height) {
#line 392
    fread((void * __restrict  )(*(frame___0 + 2) + line * Chroma_Width), (size_t )1,
          (size_t )Chroma_Width, (FILE * __restrict  )fd);
#line 390
    line ++;
  }
#line 396
  fclose(fd);
#line 397
  return (0);
}
}
#line 401 "src/subspic.c"
static void Copy_Frame(unsigned char *src , unsigned char *dst , int width , int height ,
                       int parity , int field_mode ) 
{ 
  int row ;
  int col ;
  int s ;
  int d ;
  int incr ;

  {
#line 413
  d = 0;
#line 413
  s = d;
#line 420
  if (field_mode) {
#line 422
    incr = 2;
#line 424
    if (parity == 0) {
#line 425
      s += width;
    }
  } else {
#line 429
    incr = 1;
  }
#line 432
  row = 0;
#line 432
  while (row < height) {
#line 434
    col = 0;
#line 434
    while (col < width) {
#line 436
      *(dst + (d + col)) = *(src + (s + col));
#line 434
      col ++;
    }
#line 439
    d += width * incr;
#line 440
    s += width * incr;
#line 432
    row += incr;
  }
#line 443
  return;
}
}
#line 1 "systems.o"
#pragma merger("0","/tmp/cil-w4Bln8Qr.i","-g,-O4")
#line 120 "src/global.h"
int Get_Long(void) ;
#line 124
int Thrd_Get_Long(int t ) ;
#line 126
unsigned int Thrd_Get_Bits32(int t ) ;
#line 90 "src/systems.c"
void Next_Packet(void) 
{ 
  unsigned int code ;
  int l ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;

  {
#line 95
  while (1) {
#line 97
    tmp = Get_Long();
#line 97
    code = (unsigned int )tmp;
#line 100
    while ((code & 4294967040U) != 256U) {
#line 101
      tmp___0 = Get_Byte();
#line 101
      code = (code << 8) | (unsigned int )tmp___0;
    }
#line 103
    switch (code) {
    case 442U: 
#line 107
    ld->Rdptr += 8;
#line 108
    break;
    case 480U: 
#line 110
    tmp___1 = Get_Word();
#line 110
    code = (unsigned int )tmp___1;
#line 111
    ld->Rdmax = ld->Rdptr + code;
#line 113
    tmp___2 = Get_Byte();
#line 113
    code = (unsigned int )tmp___2;
#line 115
    if (code >> 6 == 2U) {
#line 117
      (ld->Rdptr) ++;
#line 118
      tmp___3 = Get_Byte();
#line 118
      code = (unsigned int )tmp___3;
#line 119
      ld->Rdptr += code;
#line 120
      printf((char const   * __restrict  )"MPEG-2 PES packet\n");
#line 121
      return;
    } else
#line 123
    if (code == 255U) {
#line 126
      while (1) {
#line 126
        tmp___4 = Get_Byte();
#line 126
        code = (unsigned int )tmp___4;
#line 126
        if (! (code == 255U)) {
#line 126
          break;
        }
      }
    }
#line 130
    if (code >= 64U) {
#line 132
      if (code >= 128U) {
#line 134
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Error in packet header\n");
#line 135
        exit(1);
      }
#line 138
      (ld->Rdptr) ++;
#line 139
      tmp___5 = Get_Byte();
#line 139
      code = (unsigned int )tmp___5;
    }
#line 142
    if (code >= 48U) {
#line 144
      if (code >= 64U) {
#line 146
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Error in packet header\n");
#line 147
        exit(1);
      }
#line 150
      ld->Rdptr += 9;
    } else
#line 152
    if (code >= 32U) {
#line 155
      ld->Rdptr += 4;
    } else
#line 157
    if (code != 15U) {
#line 159
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Error in packet header\n");
#line 160
      exit(1);
    }
#line 162
    return;
    case 441U: 
#line 165
    l = 0;
#line 166
    while (l < 2048) {
#line 168
      tmp___6 = l;
#line 168
      l ++;
#line 168
      ld->Rdbfr[tmp___6] = (unsigned char )(439 >> 24);
#line 169
      tmp___7 = l;
#line 169
      l ++;
#line 169
      ld->Rdbfr[tmp___7] = (unsigned char )(439 >> 16);
#line 170
      tmp___8 = l;
#line 170
      l ++;
#line 170
      ld->Rdbfr[tmp___8] = (unsigned char )(439 >> 8);
#line 171
      tmp___9 = l;
#line 171
      l ++;
#line 171
      ld->Rdbfr[tmp___9] = (unsigned char)183;
    }
#line 173
    ld->Rdptr = ld->Rdbfr;
#line 174
    ld->Rdmax = ld->Rdbfr + 2048;
#line 175
    return;
    default: 
#line 177
    if (code >= 443U) {
#line 180
      tmp___10 = Get_Word();
#line 180
      code = (unsigned int )tmp___10;
#line 181
      ld->Rdptr += code;
    } else {
#line 185
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Unexpected startcode %08x in system layer\n",
              code);
#line 186
      exit(1);
    }
#line 188
    break;
    }
  }
}
}
#line 195 "src/systems.c"
void Flush_Buffer32(void) 
{ 
  int Incnt ;
  int tmp ;
  unsigned char *tmp___0 ;

  {
#line 199
  ld->Bfr = 0U;
#line 201
  Incnt = ld->Incnt;
#line 202
  Incnt -= 32;
#line 204
  if (System_Stream_Flag) {
#line 204
    if ((unsigned long )ld->Rdptr >= (unsigned long )(ld->Rdmax - 4)) {
#line 206
      while (Incnt <= 24) {
#line 208
        if ((unsigned long )ld->Rdptr >= (unsigned long )ld->Rdmax) {
#line 209
          Next_Packet();
        }
#line 210
        tmp = Get_Byte();
#line 210
        ld->Bfr |= (unsigned int )(tmp << (24 - Incnt));
#line 211
        Incnt += 8;
      }
    } else {
#line 204
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
#line 216
    while (Incnt <= 24) {
#line 218
      if ((unsigned long )ld->Rdptr >= (unsigned long )(ld->Rdbfr + 2048)) {
#line 219
        Fill_Buffer();
      }
#line 220
      tmp___0 = ld->Rdptr;
#line 220
      (ld->Rdptr) ++;
#line 220
      ld->Bfr |= (unsigned int )((int )*tmp___0 << (24 - Incnt));
#line 221
      Incnt += 8;
    }
  }
#line 224
  ld->Incnt = Incnt;
#line 229
  return;
}
}
#line 232 "src/systems.c"
unsigned int Get_Bits32(void) 
{ 
  unsigned int l ;

  {
#line 236
  l = Show_Bits(32);
#line 237
  Flush_Buffer32();
#line 239
  return (l);
}
}
#line 243 "src/systems.c"
int Get_Long(void) 
{ 
  int i ;
  int tmp ;

  {
#line 247
  i = Get_Word();
#line 248
  tmp = Get_Word();
#line 248
  return ((i << 16) | tmp);
}
}
#line 253 "src/systems.c"
void Thrd_Flush_Buffer32(int t ) 
{ 
  int Incnt ;
  int tmp ;
  unsigned char *tmp___0 ;

  {
#line 257
  thrd_buf[t] = 0U;
#line 259
  Incnt = thrd_Incnt[t];
#line 260
  Incnt -= 32;
#line 262
  if (System_Stream_Flag) {
#line 262
    if ((unsigned long )ld->Rdptr >= (unsigned long )(ld->Rdmax - 4)) {
#line 264
      if (System_Stream_Flag) {
#line 264
        printf((char const   * __restrict  )"System_Stream_Flag is 1\n");
#line 264
        exit(1);
      }
#line 265
      while (Incnt <= 24) {
#line 267
        if ((unsigned long )ld->Rdptr >= (unsigned long )ld->Rdmax) {
#line 268
          Next_Packet();
        }
#line 269
        tmp = Get_Byte();
#line 269
        ld->Bfr |= (unsigned int )(tmp << (24 - Incnt));
#line 270
        Incnt += 8;
      }
    } else {
#line 262
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
#line 275
    while (Incnt <= 24) {
#line 277
      tmp___0 = thrd_ptr[t];
#line 277
      (thrd_ptr[t]) ++;
#line 277
      thrd_buf[t] |= (unsigned int )((int )*tmp___0 << (24 - Incnt));
#line 278
      Incnt += 8;
    }
  }
#line 281
  thrd_Incnt[t] = Incnt;
#line 283
  return;
}
}
#line 286 "src/systems.c"
unsigned int Thrd_Get_Bits32(int t ) 
{ 
  unsigned int l ;

  {
#line 290
  l = Thrd_Show_Bits(t, 32);
#line 291
  Thrd_Flush_Buffer32(t);
#line 293
  return (l);
}
}
#line 297 "src/systems.c"
int Thrd_Get_Long(int t ) 
{ 
  int i ;
  int tmp ;

  {
#line 302
  i = Thrd_Get_Word(t);
#line 303
  tmp = Thrd_Get_Word(t);
#line 303
  return ((i << 16) | tmp);
}
}
#line 1 "verify.o"
#pragma merger("0","/tmp/cil-Kkggsw8k.i","-g,-O4")
