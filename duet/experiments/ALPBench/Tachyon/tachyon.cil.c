/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is true */

#line 213 "/usr/lib/gcc/x86_64-linux-gnu/4.7/include/stddef.h"
typedef unsigned long size_t;
#line 140 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 141 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 40 "/usr/lib/gcc/x86_64-linux-gnu/4.7/include/stdarg.h"
typedef __builtin_va_list __gnuc_va_list;
#line 155 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 161 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 246 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 316 "/usr/include/libio.h"
typedef struct _IO_FILE _IO_FILE;
#line 325 "/usr/lib/gcc/x86_64-linux-gnu/4.7/include/stddef.h"
typedef int wchar_t;
#line 10 "../src/util.h"
typedef void *rt_timerhandle;
#line 28 "../src/rtcommon.h"
typedef double flt;
#line 29 "../src/rtcommon.h"
typedef flt apiflt;
#line 24 "../src/tachyon.h"
typedef void *SceneHandle;
#line 26 "../src/tachyon.h"
struct __anonstruct_apivector_25 {
   apiflt x ;
   apiflt y ;
   apiflt z ;
};
#line 26 "../src/tachyon.h"
typedef struct __anonstruct_apivector_25 apivector;
#line 3 "../demosrc/getargs.h"
struct __anonstruct_argoptions_28 {
   char **filenames ;
   int numfiles ;
   int useoutfilename ;
   char outfilename[4096] ;
   int outimageformat ;
   int verbosemode ;
   int aa_maxsamples ;
   int boundmode ;
   int boundthresh ;
   int usecamfile ;
   char camfilename[4096] ;
   int shadermode ;
   int phongfunc ;
   int transmode ;
   int fogmode ;
   int numthreads ;
   int nosave ;
   int xsize ;
   int ysize ;
   int normalfixupmode ;
   int imgprocess ;
   float imggamma ;
   float rescale_lights ;
   float auto_skylight ;
   float add_skylight ;
   int skylight_samples ;
   char spaceball[4096] ;
   int cropmode ;
   int cropxres ;
   int cropyres ;
   int cropxstart ;
   int cropystart ;
};
#line 3 "../demosrc/getargs.h"
typedef struct __anonstruct_argoptions_28 argoptions;
#line 30 "../demosrc/main.c"
struct __anonstruct_floatvec_29 {
   float x ;
   float y ;
   float z ;
};
#line 30 "../demosrc/main.c"
typedef struct __anonstruct_floatvec_29 floatvec;
#line 37 "../demosrc/main.c"
struct __anonstruct_dispHandle_30 {
   int xsize ;
   int ysize ;
};
#line 37 "../demosrc/main.c"
typedef struct __anonstruct_dispHandle_30 dispHandle;
#line 40 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __int32_t;
#line 32 "../src/tachyon.h"
struct __anonstruct_apicolor_26 {
   float r ;
   float g ;
   float b ;
};
#line 32 "../src/tachyon.h"
typedef struct __anonstruct_apicolor_26 apicolor;
#line 153 "/usr/include/x86_64-linux-gnu/bits/mathinline.h"
union __anonunion___u_8 {
   long double __l ;
   int __i[3] ;
};
#line 15 "../src/hash.h"
struct hash_node_t;
#line 15 "../src/hash.h"
struct rt_hash_t {
   struct hash_node_t **bucket ;
   int size ;
   int entries ;
   int downshift ;
   int mask ;
};
#line 15 "../src/hash.h"
typedef struct rt_hash_t rt_hash_t;
#line 38 "../src/tachyon.h"
struct __anonstruct_apitexture_31 {
   int texturefunc ;
   apicolor col ;
   int shadowcast ;
   apiflt ambient ;
   apiflt diffuse ;
   apiflt specular ;
   apiflt opacity ;
   apivector ctr ;
   apivector rot ;
   apivector scale ;
   apivector uaxs ;
   apivector vaxs ;
   apivector waxs ;
   char imap[96] ;
};
#line 38 "../src/tachyon.h"
typedef struct __anonstruct_apitexture_31 apitexture;
#line 19 "../demosrc/parse.h"
struct __anonstruct_texentry_32 {
   char *name ;
   void *tex ;
};
#line 19 "../demosrc/parse.h"
typedef struct __anonstruct_texentry_32 texentry;
#line 24 "../demosrc/parse.h"
struct __anonstruct_parsehandle_33 {
   FILE *ifp ;
   char const   *filename ;
   texentry *textable ;
   texentry defaulttex ;
   int numtextures ;
   int maxtextures ;
   int numobjectsparsed ;
   rt_hash_t texhash ;
};
#line 24 "../demosrc/parse.h"
typedef struct __anonstruct_parsehandle_33 parsehandle;
#line 35 "../demosrc/parse.h"
struct __anonstruct_RotMat_34 {
   double rx1 ;
   double rx2 ;
   double rx3 ;
   double ry1 ;
   double ry2 ;
   double ry3 ;
   double rz1 ;
   double rz2 ;
   double rz3 ;
};
#line 35 "../demosrc/parse.h"
typedef struct __anonstruct_RotMat_34 RotMat;
#line 41 "../demosrc/parse.h"
typedef unsigned int errcode;
#line 153 "/usr/include/x86_64-linux-gnu/bits/mathinline.h"
union __anonunion___u_8___0 {
   long double __l ;
   int __i[3] ;
};
#line 153 "/usr/include/x86_64-linux-gnu/bits/mathinline.h"
union __anonunion___u_3 {
   long double __l ;
   int __i[3] ;
};
#line 153 "/usr/include/x86_64-linux-gnu/bits/mathinline.h"
union __anonunion___u_8___1 {
   long double __l ;
   int __i[3] ;
};
#line 19 "../demosrc/ac3dparse.h"
typedef float RotMat___0[3][3];
#line 20 "../demosrc/ac3dparse.h"
typedef float TransMat[3];
#line 22 "../demosrc/ac3dparse.h"
struct __anonstruct_texentry_32___0 {
   char name[24] ;
   void *tex ;
};
#line 22 "../demosrc/ac3dparse.h"
typedef struct __anonstruct_texentry_32___0 texentry___0;
#line 27 "../demosrc/ac3dparse.h"
struct tri_list_t {
   int v0 ;
   int v1 ;
   int v2 ;
   int smooth ;
   int texnum ;
   struct tri_list_t *next ;
};
#line 27 "../demosrc/ac3dparse.h"
typedef struct tri_list_t tri_list;
/* compiler builtin: 
   void *__builtin___memmove_chk(void * , void const   * , unsigned long  , unsigned long  ) ;  */
/* compiler builtin: 
   char *__builtin_strchr(char * , int  ) ;  */
/* compiler builtin: 
   void *__builtin___memcpy_chk(void * , void const   * , unsigned long  , unsigned long  ) ;  */
/* compiler builtin: 
   int __builtin___vsprintf_chk(char * , int  , unsigned long  , char const   * ,
                                __builtin_va_list  ) ;  */
/* compiler builtin: 
   char *__builtin___strncpy_chk(char * , char const   * , unsigned long  , unsigned long  ) ;  */
/* compiler builtin: 
   char *__builtin___strcat_chk(char * , char const   * , unsigned long  ) ;  */
/* compiler builtin: 
   unsigned long __builtin_object_size(void * , int  ) ;  */
/* compiler builtin: 
   int __builtin___sprintf_chk(char * , int  , unsigned long  , char const   *  , ...) ;  */
/* compiler builtin: 
   int __builtin___snprintf_chk(char * , unsigned long  , int  , unsigned long  ,
                                char const   *  , ...) ;  */
/* compiler builtin: 
   int __builtin___vsnprintf_chk(char * , unsigned long  , int  , unsigned long  ,
                                 char const   * , __builtin_va_list  ) ;  */
/* compiler builtin: 
   char *__builtin___strcpy_chk(char * , char const   * , unsigned long  ) ;  */
/* compiler builtin: 
   void *__builtin___memset_chk(void * , int  , unsigned long  , unsigned long  ) ;  */
/* compiler builtin: 
   char *__builtin___strncat_chk(char * , char const   * , unsigned long  , unsigned long  ) ;  */
/* compiler builtin: 
   long __builtin_expect(long  , long  ) ;  */
/* compiler builtin: 
   int __builtin_va_arg_pack(void) ;  */
#line 1 "main.o"
#pragma merger("0","/tmp/cil-tByRKCuf.i","-m64,-Wall,-O3,-fomit-frame-pointer,-ffast-math")
#line 392 "/usr/include/libio.h"
extern int __uflow(_IO_FILE * ) ;
#line 393
extern int __overflow(_IO_FILE * , int  ) ;
#line 435
extern int _IO_getc(_IO_FILE *__fp ) ;
#line 436
extern int _IO_putc(int __c , _IO_FILE *__fp ) ;
#line 168 "/usr/include/stdio.h"
extern struct _IO_FILE *stdin ;
#line 169
extern struct _IO_FILE *stdout ;
#line 237
extern int fclose(FILE *__stream ) ;
#line 242
extern int fflush(FILE *__stream ) ;
#line 272
extern FILE *( __attribute__((__warn_unused_result__)) fopen)(char const   * __restrict  __filename ,
                                                              char const   * __restrict  __modes ) ;
#line 356
__inline extern int ( __attribute__((__artificial__, __always_inline__)) fprintf)(FILE * __restrict  __stream ,
                                                                                  char const   * __restrict  __fmt 
                                                                                  , ...) ;
#line 362
__inline extern int ( __attribute__((__artificial__, __always_inline__)) printf)(char const   * __restrict  __fmt 
                                                                                 , ...) ;
#line 364
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__, __artificial__,
__always_inline__)) sprintf)(char * __restrict  __s , char const   * __restrict  __fmt 
                             , ...) ;
#line 371
__inline extern int ( __attribute__((__artificial__, __always_inline__)) vfprintf)(FILE * __restrict  __stream ,
                                                                                   char const   * __restrict  __fmt ,
                                                                                   __gnuc_va_list __ap ) ;
#line 377
__inline extern int ( __attribute__((__artificial__, __always_inline__)) vprintf)(char const   * __restrict  __fmt ,
                                                                                  __gnuc_va_list __ap ) ;
#line 379
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__, __artificial__,
__always_inline__)) vsprintf)(char * __restrict  __s , char const   * __restrict  __fmt ,
                              __gnuc_va_list __ap ) ;
#line 386
__inline extern  __attribute__((__nothrow__)) int ( /* format attribute */ __attribute__((__leaf__,
__artificial__, __always_inline__)) snprintf)(char * __restrict  __s , size_t __n ,
                                              char const   * __restrict  __fmt  , ...) ;
#line 390
__inline extern  __attribute__((__nothrow__)) int ( /* format attribute */ __attribute__((__leaf__,
__artificial__, __always_inline__)) vsnprintf)(char * __restrict  __s , size_t __n ,
                                               char const   * __restrict  __fmt ,
                                               __gnuc_va_list __ap ) ;
#line 412
__inline extern int ( /* format attribute */ __attribute__((__artificial__, __always_inline__)) vdprintf)(int __fd ,
                                                                                                          char const   * __restrict  __fmt ,
                                                                                                          __gnuc_va_list __ap ) ;
#line 415
__inline extern int ( /* format attribute */ __attribute__((__artificial__, __always_inline__)) dprintf)(int __fd ,
                                                                                                         char const   * __restrict  __fmt 
                                                                                                         , ...) ;
#line 425
extern int ( __attribute__((__warn_unused_result__)) fscanf)(FILE * __restrict  __stream ,
                                                             char const   * __restrict  __format 
                                                             , ...)  __asm__("__isoc99_fscanf")  ;
#line 538
__inline extern int getchar(void) ;
#line 550
__inline extern int getc_unlocked(FILE *__fp ) ;
#line 551
__inline extern int getchar_unlocked(void) ;
#line 561
__inline extern int fgetc_unlocked(FILE *__fp ) ;
#line 580
__inline extern int putchar(int __c ) ;
#line 594
__inline extern int fputc_unlocked(int __c , FILE *__stream ) ;
#line 602
__inline extern int putc_unlocked(int __c , FILE *__stream ) ;
#line 603
__inline extern int putchar_unlocked(int __c ) ;
#line 622
__inline extern char *( __attribute__((__warn_unused_result__, __artificial__, __always_inline__)) fgets)(char * __restrict  __s ,
                                                                                                          int __n ,
                                                                                                          FILE * __restrict  __stream ) ;
#line 638
__inline extern char *( __attribute__((__warn_unused_result__, __artificial__, __always_inline__)) gets)(char *__str )  __attribute__((__deprecated__)) ;
#line 709
__inline extern size_t ( __attribute__((__warn_unused_result__, __artificial__, __always_inline__)) fread)(void * __restrict  __ptr ,
                                                                                                           size_t __size ,
                                                                                                           size_t __n ,
                                                                                                           FILE * __restrict  __stream ) ;
#line 737
__inline extern size_t ( __attribute__((__warn_unused_result__, __artificial__, __always_inline__)) fread_unlocked)(void * __restrict  __ptr ,
                                                                                                                    size_t __size ,
                                                                                                                    size_t __n ,
                                                                                                                    FILE * __restrict  __stream ) ;
#line 828
extern  __attribute__((__nothrow__)) int ( __attribute__((__warn_unused_result__,
__leaf__)) feof)(FILE *__stream ) ;
#line 836
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__warn_unused_result__,
__leaf__)) feof_unlocked)(FILE *__stream ) ;
#line 837
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__warn_unused_result__,
__leaf__)) ferror_unlocked)(FILE *__stream ) ;
#line 43 "/usr/include/x86_64-linux-gnu/bits/stdio.h"
__inline extern int getchar(void) 
{ 
  int tmp ;

  {
#line 46
  tmp = _IO_getc(stdin);
#line 46
  return (tmp);
}
}
#line 52 "/usr/include/x86_64-linux-gnu/bits/stdio.h"
__inline extern int fgetc_unlocked(FILE *__fp ) 
{ 
  int tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  long tmp___3 ;

  {
#line 55
  tmp___3 = __builtin_expect((long )((unsigned long )__fp->_IO_read_ptr >= (unsigned long )__fp->_IO_read_end),
                             0L);
#line 55
  if (tmp___3) {
#line 55
    tmp___0 = __uflow(__fp);
#line 55
    tmp___2 = tmp___0;
  } else {
#line 55
    tmp___1 = __fp->_IO_read_ptr;
#line 55
    (__fp->_IO_read_ptr) ++;
#line 55
    tmp___2 = (int )*((unsigned char *)tmp___1);
  }
#line 55
  return (tmp___2);
}
}
#line 69 "/usr/include/x86_64-linux-gnu/bits/stdio.h"
__inline extern int getchar_unlocked(void) 
{ 
  int tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  long tmp___3 ;

  {
#line 72
  tmp___3 = __builtin_expect((long )((unsigned long )stdin->_IO_read_ptr >= (unsigned long )stdin->_IO_read_end),
                             0L);
#line 72
  if (tmp___3) {
#line 72
    tmp___0 = __uflow(stdin);
#line 72
    tmp___2 = tmp___0;
  } else {
#line 72
    tmp___1 = stdin->_IO_read_ptr;
#line 72
    (stdin->_IO_read_ptr) ++;
#line 72
    tmp___2 = (int )*((unsigned char *)tmp___1);
  }
#line 72
  return (tmp___2);
}
}
#line 78 "/usr/include/x86_64-linux-gnu/bits/stdio.h"
__inline extern int putchar(int __c ) 
{ 
  int tmp ;

  {
#line 81
  tmp = _IO_putc(__c, stdout);
#line 81
  return (tmp);
}
}
#line 87 "/usr/include/x86_64-linux-gnu/bits/stdio.h"
__inline extern int fputc_unlocked(int __c , FILE *__stream ) 
{ 
  int tmp___0 ;
  char *tmp___1 ;
  char tmp___2 ;
  int tmp___3 ;
  long tmp___4 ;

  {
#line 90
  tmp___4 = __builtin_expect((long )((unsigned long )__stream->_IO_write_ptr >= (unsigned long )__stream->_IO_write_end),
                             0L);
#line 90
  if (tmp___4) {
#line 90
    tmp___0 = __overflow(__stream, (int )((unsigned char )__c));
#line 90
    tmp___3 = tmp___0;
  } else {
#line 90
    tmp___1 = __stream->_IO_write_ptr;
#line 90
    (__stream->_IO_write_ptr) ++;
#line 90
    tmp___2 = (char )__c;
#line 90
    *tmp___1 = tmp___2;
#line 90
    tmp___3 = (int )((unsigned char )tmp___2);
  }
#line 90
  return (tmp___3);
}
}
#line 104 "/usr/include/x86_64-linux-gnu/bits/stdio.h"
__inline extern int putchar_unlocked(int __c ) 
{ 
  int tmp___0 ;
  char *tmp___1 ;
  char tmp___2 ;
  int tmp___3 ;
  long tmp___4 ;

  {
#line 107
  tmp___4 = __builtin_expect((long )((unsigned long )stdout->_IO_write_ptr >= (unsigned long )stdout->_IO_write_end),
                             0L);
#line 107
  if (tmp___4) {
#line 107
    tmp___0 = __overflow(stdout, (int )((unsigned char )__c));
#line 107
    tmp___3 = tmp___0;
  } else {
#line 107
    tmp___1 = stdout->_IO_write_ptr;
#line 107
    (stdout->_IO_write_ptr) ++;
#line 107
    tmp___2 = (char )__c;
#line 107
    *tmp___1 = tmp___2;
#line 107
    tmp___3 = (int )((unsigned char )tmp___2);
  }
#line 107
  return (tmp___3);
}
}
#line 124
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__warn_unused_result__,
__leaf__)) feof_unlocked)(FILE *__stream ) ;
#line 124 "/usr/include/x86_64-linux-gnu/bits/stdio.h"
__inline extern int ( __attribute__((__warn_unused_result__, __leaf__)) feof_unlocked)(FILE *__stream ) 
{ 


  {
#line 127
  return ((__stream->_flags & 16) != 0);
}
}
#line 131
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__warn_unused_result__,
__leaf__)) ferror_unlocked)(FILE *__stream ) ;
#line 131 "/usr/include/x86_64-linux-gnu/bits/stdio.h"
__inline extern int ( __attribute__((__warn_unused_result__, __leaf__)) ferror_unlocked)(FILE *__stream ) 
{ 


  {
#line 134
  return ((__stream->_flags & 32) != 0);
}
}
#line 30 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__, __artificial__,
__always_inline__)) sprintf)(char * __restrict  __s , char const   * __restrict  __fmt 
                             , ...) ;
#line 30 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern int ( __attribute__((__leaf__, __artificial__, __always_inline__)) sprintf)(char * __restrict  __s ,
                                                                                            char const   * __restrict  __fmt 
                                                                                            , ...) 
{ 
  unsigned long tmp ;
  int tmp___0 ;

  {
#line 33
  tmp = __builtin_object_size((void *)__s, 1);
#line 33
  tmp___0 = __builtin___sprintf_chk((char *)__s, 1, tmp, (char const   *)__fmt, __builtin_va_arg_pack());
#line 33
  return (tmp___0);
}
}
#line 42
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__, __artificial__,
__always_inline__)) vsprintf)(char * __restrict  __s , char const   * __restrict  __fmt ,
                              __gnuc_va_list __ap ) ;
#line 42 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern int ( __attribute__((__leaf__, __artificial__, __always_inline__)) vsprintf)(char * __restrict  __s ,
                                                                                             char const   * __restrict  __fmt ,
                                                                                             __gnuc_va_list __ap ) 
{ 
  unsigned long tmp ;
  int tmp___0 ;

  {
#line 46
  tmp = __builtin_object_size((void *)__s, 1);
#line 46
  tmp___0 = __builtin___vsprintf_chk((char *)__s, 1, tmp, (char const   *)__fmt, __ap);
#line 46
  return (tmp___0);
}
}
#line 60
__inline extern  __attribute__((__nothrow__)) int ( /* format attribute */ __attribute__((__leaf__,
__artificial__, __always_inline__)) snprintf)(char * __restrict  __s , size_t __n ,
                                              char const   * __restrict  __fmt  , ...) ;
#line 60 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern int ( /* format attribute */ __attribute__((__leaf__, __artificial__,
__always_inline__)) snprintf)(char * __restrict  __s , size_t __n , char const   * __restrict  __fmt 
                              , ...) 
{ 
  unsigned long tmp ;
  int tmp___0 ;

  {
#line 64
  tmp = __builtin_object_size((void *)__s, 1);
#line 64
  tmp___0 = __builtin___snprintf_chk((char *)__s, __n, 1, tmp, (char const   *)__fmt,
                                     __builtin_va_arg_pack());
#line 64
  return (tmp___0);
}
}
#line 73
__inline extern  __attribute__((__nothrow__)) int ( /* format attribute */ __attribute__((__leaf__,
__artificial__, __always_inline__)) vsnprintf)(char * __restrict  __s , size_t __n ,
                                               char const   * __restrict  __fmt ,
                                               __gnuc_va_list __ap ) ;
#line 73 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern int ( /* format attribute */ __attribute__((__leaf__, __artificial__,
__always_inline__)) vsnprintf)(char * __restrict  __s , size_t __n , char const   * __restrict  __fmt ,
                               __gnuc_va_list __ap ) 
{ 
  unsigned long tmp ;
  int tmp___0 ;

  {
#line 77
  tmp = __builtin_object_size((void *)__s, 1);
#line 77
  tmp___0 = __builtin___vsnprintf_chk((char *)__s, __n, 1, tmp, (char const   *)__fmt,
                                      __ap);
#line 77
  return (tmp___0);
}
}
#line 85
extern int __fprintf_chk(FILE * __restrict  __stream , int __flag , char const   * __restrict  __format 
                         , ...) ;
#line 87
extern int __printf_chk(int __flag , char const   * __restrict  __format  , ...) ;
#line 88
extern int __vfprintf_chk(FILE * __restrict  __stream , int __flag , char const   * __restrict  __format ,
                          __gnuc_va_list __ap ) ;
#line 94 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern int ( __attribute__((__artificial__, __always_inline__)) fprintf)(FILE * __restrict  __stream ,
                                                                                  char const   * __restrict  __fmt 
                                                                                  , ...) 
{ 
  int tmp ;

  {
#line 97
  tmp = __fprintf_chk(__stream, 1, __fmt, __builtin_va_arg_pack());
#line 97
  return (tmp);
}
}
#line 101 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern int ( __attribute__((__artificial__, __always_inline__)) printf)(char const   * __restrict  __fmt 
                                                                                 , ...) 
{ 
  int tmp ;

  {
#line 104
  tmp = __printf_chk(1, __fmt, __builtin_va_arg_pack());
#line 104
  return (tmp);
}
}
#line 113 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern int ( __attribute__((__artificial__, __always_inline__)) vprintf)(char const   * __restrict  __fmt ,
                                                                                  __gnuc_va_list __ap ) 
{ 
  int tmp ;

  {
#line 117
  tmp = __vfprintf_chk((FILE * __restrict  )stdout, 1, __fmt, __ap);
#line 117
  return (tmp);
}
}
#line 123 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern int ( __attribute__((__artificial__, __always_inline__)) vfprintf)(FILE * __restrict  __stream ,
                                                                                   char const   * __restrict  __fmt ,
                                                                                   __gnuc_va_list __ap ) 
{ 
  int tmp ;

  {
#line 127
  tmp = __vfprintf_chk(__stream, 1, __fmt, __ap);
#line 127
  return (tmp);
}
}
#line 131
extern int ( /* format attribute */  __dprintf_chk)(int __fd , int __flag , char const   * __restrict  __fmt 
                                                    , ...) ;
#line 133
extern int ( /* format attribute */  __vdprintf_chk)(int __fd , int __flag , char const   * __restrict  __fmt ,
                                                     __gnuc_va_list __arg ) ;
#line 138 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern int ( /* format attribute */ __attribute__((__artificial__, __always_inline__)) dprintf)(int __fd ,
                                                                                                         char const   * __restrict  __fmt 
                                                                                                         , ...) 
{ 
  int tmp ;

  {
#line 141
  tmp = __dprintf_chk(__fd, 1, __fmt, __builtin_va_arg_pack());
#line 141
  return (tmp);
}
}
#line 149 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern int ( /* format attribute */ __attribute__((__artificial__, __always_inline__)) vdprintf)(int __fd ,
                                                                                                          char const   * __restrict  __fmt ,
                                                                                                          __gnuc_va_list __ap ) 
{ 
  int tmp ;

  {
#line 152
  tmp = __vdprintf_chk(__fd, 1, __fmt, __ap);
#line 152
  return (tmp);
}
}
#line 227
extern char *( __attribute__((__warn_unused_result__)) __gets_chk)(char *__str , size_t  ) ;
#line 228
extern char *( __attribute__((__warn_unused_result__)) __gets_warn)(char *__str )  __asm__("gets") __attribute__((__warning__("please use fgets or getline instead, gets can\'t specify buffer size"))) ;
#line 232
__inline extern char *( __attribute__((__warn_unused_result__, __artificial__, __always_inline__)) gets)(char *__str )  __attribute__((__deprecated__)) ;
#line 232 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern char *( __attribute__((__warn_unused_result__, __artificial__, __always_inline__)) gets)(char *__str ) 
{ 
  unsigned long tmp ;
  char *tmp___0 ;
  unsigned long tmp___1 ;
  char *tmp___2 ;

  {
#line 235
  tmp___1 = __builtin_object_size((void *)__str, 1);
#line 235
  if (tmp___1 != 0xffffffffffffffffUL) {
#line 236
    tmp = __builtin_object_size((void *)__str, 1);
#line 236
    tmp___0 = __gets_chk(__str, tmp);
#line 236
    return (tmp___0);
  }
#line 237
  tmp___2 = __gets_warn(__str);
#line 237
  return (tmp___2);
}
}
#line 241
extern char *( __attribute__((__warn_unused_result__)) __fgets_chk)(char * __restrict  __s ,
                                                                    size_t __size ,
                                                                    int __n , FILE * __restrict  __stream ) ;
#line 243
extern char *( __attribute__((__warn_unused_result__)) __fgets_alias)(char * __restrict  __s ,
                                                                      int __n , FILE * __restrict  __stream )  __asm__("fgets")  ;
#line 246
extern char *( __attribute__((__warn_unused_result__)) __fgets_chk_warn)(char * __restrict  __s ,
                                                                         size_t __size ,
                                                                         int __n ,
                                                                         FILE * __restrict  __stream )  __asm__("__fgets_chk") __attribute__((__warning__("fgets called with bigger size than length of destination buffer"))) ;
#line 252 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern char *( __attribute__((__warn_unused_result__, __artificial__, __always_inline__)) fgets)(char * __restrict  __s ,
                                                                                                          int __n ,
                                                                                                          FILE * __restrict  __stream ) 
{ 
  unsigned long tmp ;
  char *tmp___0 ;
  unsigned long tmp___1 ;
  char *tmp___2 ;
  unsigned long tmp___3 ;
  unsigned long tmp___4 ;
  char *tmp___5 ;

  {
#line 255
  tmp___4 = __builtin_object_size((void *)__s, 1);
#line 255
  if (tmp___4 != 0xffffffffffffffffUL) {
#line 258
    tmp = __builtin_object_size((void *)__s, 1);
#line 258
    tmp___0 = __fgets_chk(__s, tmp, __n, __stream);
#line 258
    return (tmp___0);
#line 260
    tmp___3 = __builtin_object_size((void *)__s, 1);
#line 260
    if ((size_t )__n > tmp___3) {
#line 261
      tmp___1 = __builtin_object_size((void *)__s, 1);
#line 261
      tmp___2 = __fgets_chk_warn(__s, tmp___1, __n, __stream);
#line 261
      return (tmp___2);
    }
  }
#line 263
  tmp___5 = __fgets_alias(__s, __n, __stream);
#line 263
  return (tmp___5);
}
}
#line 266
extern size_t ( __attribute__((__warn_unused_result__)) __fread_chk)(void * __restrict  __ptr ,
                                                                     size_t __ptrlen ,
                                                                     size_t __size ,
                                                                     size_t __n ,
                                                                     FILE * __restrict  __stream ) ;
#line 269
extern size_t ( __attribute__((__warn_unused_result__)) __fread_alias)(void * __restrict  __ptr ,
                                                                       size_t __size ,
                                                                       size_t __n ,
                                                                       FILE * __restrict  __stream )  __asm__("fread")  ;
#line 273
extern size_t ( __attribute__((__warn_unused_result__)) __fread_chk_warn)(void * __restrict  __ptr ,
                                                                          size_t __ptrlen ,
                                                                          size_t __size ,
                                                                          size_t __n ,
                                                                          FILE * __restrict  __stream )  __asm__("__fread_chk") __attribute__((__warning__("fread called with bigger size * nmemb than length of destination buffer"))) ;
#line 281 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern size_t ( __attribute__((__warn_unused_result__, __artificial__, __always_inline__)) fread)(void * __restrict  __ptr ,
                                                                                                           size_t __size ,
                                                                                                           size_t __n ,
                                                                                                           FILE * __restrict  __stream ) 
{ 
  unsigned long tmp ;
  size_t tmp___0 ;
  unsigned long tmp___1 ;
  size_t tmp___2 ;
  unsigned long tmp___3 ;
  unsigned long tmp___4 ;
  size_t tmp___5 ;

  {
#line 285
  tmp___4 = __builtin_object_size((void *)__ptr, 0);
#line 285
  if (tmp___4 != 0xffffffffffffffffUL) {
#line 290
    tmp = __builtin_object_size((void *)__ptr, 0);
#line 290
    tmp___0 = __fread_chk(__ptr, tmp, __size, __n, __stream);
#line 290
    return (tmp___0);
#line 292
    tmp___3 = __builtin_object_size((void *)__ptr, 0);
#line 292
    if (__size * __n > tmp___3) {
#line 293
      tmp___1 = __builtin_object_size((void *)__ptr, 0);
#line 293
      tmp___2 = __fread_chk_warn(__ptr, tmp___1, __size, __n, __stream);
#line 293
      return (tmp___2);
    }
  }
#line 295
  tmp___5 = __fread_alias(__ptr, __size, __n, __stream);
#line 295
  return (tmp___5);
}
}
#line 327
extern size_t ( __attribute__((__warn_unused_result__)) __fread_unlocked_chk)(void * __restrict  __ptr ,
                                                                              size_t __ptrlen ,
                                                                              size_t __size ,
                                                                              size_t __n ,
                                                                              FILE * __restrict  __stream ) ;
#line 330
extern size_t ( __attribute__((__warn_unused_result__)) __fread_unlocked_alias)(void * __restrict  __ptr ,
                                                                                size_t __size ,
                                                                                size_t __n ,
                                                                                FILE * __restrict  __stream )  __asm__("fread_unlocked")  ;
#line 334
extern size_t ( __attribute__((__warn_unused_result__)) __fread_unlocked_chk_warn)(void * __restrict  __ptr ,
                                                                                   size_t __ptrlen ,
                                                                                   size_t __size ,
                                                                                   size_t __n ,
                                                                                   FILE * __restrict  __stream )  __asm__("__fread_unlocked_chk") __attribute__((__warning__("fread_unlocked called with bigger size * nmemb than length of destination buffer"))) ;
#line 342 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern size_t ( __attribute__((__warn_unused_result__, __artificial__, __always_inline__)) fread_unlocked)(void * __restrict  __ptr ,
                                                                                                                    size_t __size ,
                                                                                                                    size_t __n ,
                                                                                                                    FILE * __restrict  __stream ) 
{ 
  unsigned long tmp ;
  size_t tmp___0 ;
  unsigned long tmp___1 ;
  size_t tmp___2 ;
  unsigned long tmp___3 ;
  unsigned long tmp___4 ;
  size_t tmp___11 ;

  {
#line 346
  tmp___4 = __builtin_object_size((void *)__ptr, 0);
#line 346
  if (tmp___4 != 0xffffffffffffffffUL) {
#line 351
    tmp = __builtin_object_size((void *)__ptr, 0);
#line 351
    tmp___0 = __fread_unlocked_chk(__ptr, tmp, __size, __n, __stream);
#line 351
    return (tmp___0);
#line 354
    tmp___3 = __builtin_object_size((void *)__ptr, 0);
#line 354
    if (__size * __n > tmp___3) {
#line 355
      tmp___1 = __builtin_object_size((void *)__ptr, 0);
#line 355
      tmp___2 = __fread_unlocked_chk_warn(__ptr, tmp___1, __size, __n, __stream);
#line 355
      return (tmp___2);
    }
  }
#line 380
  tmp___11 = __fread_unlocked_alias(__ptr, __size, __n, __stream);
#line 380
  return (tmp___11);
}
}
#line 144 "/usr/include/stdlib.h"
__inline extern  __attribute__((__nothrow__)) double ( __attribute__((__warn_unused_result__,
__nonnull__(1), __leaf__)) atof)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 147
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__warn_unused_result__,
__nonnull__(1), __leaf__)) atoi)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 150
__inline extern  __attribute__((__nothrow__)) long ( __attribute__((__warn_unused_result__,
__nonnull__(1), __leaf__)) atol)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 157
__inline extern  __attribute__((__nothrow__)) long long ( __attribute__((__warn_unused_result__,
__nonnull__(1), __leaf__)) atoll)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 164
extern  __attribute__((__nothrow__)) double ( __attribute__((__nonnull__(1), __leaf__)) strtod)(char const   * __restrict  __nptr ,
                                                                                                char ** __restrict  __endptr ) ;
#line 183
extern  __attribute__((__nothrow__)) long ( __attribute__((__nonnull__(1), __leaf__)) strtol)(char const   * __restrict  __nptr ,
                                                                                              char ** __restrict  __endptr ,
                                                                                              int __base ) ;
#line 209
extern  __attribute__((__nothrow__)) long long ( __attribute__((__nonnull__(1), __leaf__)) strtoll)(char const   * __restrict  __nptr ,
                                                                                                    char ** __restrict  __endptr ,
                                                                                                    int __base ) ;
#line 277
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__warn_unused_result__,
__nonnull__(1), __leaf__)) atoi)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 277 "/usr/include/stdlib.h"
__inline extern int ( __attribute__((__warn_unused_result__, __nonnull__(1), __leaf__)) atoi)(char const   *__nptr ) 
{ 
  long tmp ;

  {
#line 280
  tmp = strtol((char const   * __restrict  )__nptr, (char ** __restrict  )((char **)((void *)0)),
               10);
#line 280
  return ((int )tmp);
}
}
#line 282
__inline extern  __attribute__((__nothrow__)) long ( __attribute__((__warn_unused_result__,
__nonnull__(1), __leaf__)) atol)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 282 "/usr/include/stdlib.h"
__inline extern long ( __attribute__((__warn_unused_result__, __nonnull__(1), __leaf__)) atol)(char const   *__nptr ) 
{ 
  long tmp ;

  {
#line 285
  tmp = strtol((char const   * __restrict  )__nptr, (char ** __restrict  )((char **)((void *)0)),
               10);
#line 285
  return (tmp);
}
}
#line 291
__inline extern  __attribute__((__nothrow__)) long long ( __attribute__((__warn_unused_result__,
__nonnull__(1), __leaf__)) atoll)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 291 "/usr/include/stdlib.h"
__inline extern long long ( __attribute__((__warn_unused_result__, __nonnull__(1),
__leaf__)) atoll)(char const   *__nptr ) 
{ 
  long long tmp ;

  {
#line 294
  tmp = strtoll((char const   * __restrict  )__nptr, (char ** __restrict  )((char **)((void *)0)),
                10);
#line 294
  return (tmp);
}
}
#line 32 "/usr/include/x86_64-linux-gnu/sys/sysmacros.h"
__inline extern  __attribute__((__nothrow__)) unsigned int ( __attribute__((__leaf__)) gnu_dev_major)(unsigned long long __dev )  __attribute__((__const__)) ;
#line 35
__inline extern  __attribute__((__nothrow__)) unsigned int ( __attribute__((__leaf__)) gnu_dev_minor)(unsigned long long __dev )  __attribute__((__const__)) ;
#line 38
__inline extern  __attribute__((__nothrow__)) unsigned long long ( __attribute__((__leaf__)) gnu_dev_makedev)(unsigned int __major ,
                                                                                                              unsigned int __minor )  __attribute__((__const__)) ;
#line 43
__inline extern  __attribute__((__nothrow__)) unsigned int ( __attribute__((__leaf__)) gnu_dev_major)(unsigned long long __dev )  __attribute__((__const__)) ;
#line 43 "/usr/include/x86_64-linux-gnu/sys/sysmacros.h"
__inline extern unsigned int ( __attribute__((__leaf__)) gnu_dev_major)(unsigned long long __dev ) 
{ 


  {
#line 46
  return ((unsigned int )(((__dev >> 8) & 4095ULL) | (unsigned long long )((unsigned int )(__dev >> 32) & 4294963200U)));
}
}
#line 49
__inline extern  __attribute__((__nothrow__)) unsigned int ( __attribute__((__leaf__)) gnu_dev_minor)(unsigned long long __dev )  __attribute__((__const__)) ;
#line 49 "/usr/include/x86_64-linux-gnu/sys/sysmacros.h"
__inline extern unsigned int ( __attribute__((__leaf__)) gnu_dev_minor)(unsigned long long __dev ) 
{ 


  {
#line 52
  return ((unsigned int )((__dev & 255ULL) | (unsigned long long )((unsigned int )(__dev >> 12) & 4294967040U)));
}
}
#line 55
__inline extern  __attribute__((__nothrow__)) unsigned long long ( __attribute__((__leaf__)) gnu_dev_makedev)(unsigned int __major ,
                                                                                                              unsigned int __minor )  __attribute__((__const__)) ;
#line 55 "/usr/include/x86_64-linux-gnu/sys/sysmacros.h"
__inline extern unsigned long long ( __attribute__((__leaf__)) gnu_dev_makedev)(unsigned int __major ,
                                                                                unsigned int __minor ) 
{ 


  {
#line 58
  return (((unsigned long long )((__minor & 255U) | ((__major & 4095U) << 8)) | ((unsigned long long )(__minor & 4294967040U) << 12)) | ((unsigned long long )(__major & 4294963200U) << 32));
}
}
#line 465 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__warn_unused_result__,
__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 542
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 733
__inline extern  __attribute__((__nothrow__)) char *( __attribute__((__warn_unused_result__,
__leaf__, __artificial__, __always_inline__)) realpath)(char const   * __restrict  __name ,
                                                        char * __restrict  __resolved ) ;
#line 866
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__warn_unused_result__,
__leaf__, __artificial__, __always_inline__)) wctomb)(char *__s , wchar_t __wchar ) ;
#line 870
__inline extern  __attribute__((__nothrow__)) size_t ( __attribute__((__leaf__, __artificial__,
__always_inline__)) mbstowcs)(wchar_t * __restrict  __dst , char const   * __restrict  __src ,
                              size_t __len ) ;
#line 873
__inline extern  __attribute__((__nothrow__)) size_t ( __attribute__((__leaf__, __artificial__,
__always_inline__)) wcstombs)(char * __restrict  __dst , wchar_t const   * __restrict  __src ,
                              size_t __len ) ;
#line 25 "/usr/include/x86_64-linux-gnu/bits/stdlib-float.h"
__inline extern  __attribute__((__nothrow__)) double ( __attribute__((__warn_unused_result__,
__nonnull__(1), __leaf__)) atof)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 25 "/usr/include/x86_64-linux-gnu/bits/stdlib-float.h"
__inline extern double ( __attribute__((__warn_unused_result__, __nonnull__(1), __leaf__)) atof)(char const   *__nptr ) 
{ 
  double tmp ;

  {
#line 28
  tmp = strtod((char const   * __restrict  )__nptr, (char ** __restrict  )((char **)((void *)0)));
#line 28
  return (tmp);
}
}
#line 23 "/usr/include/x86_64-linux-gnu/bits/stdlib.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__warn_unused_result__,
__leaf__)) __realpath_chk)(char const   * __restrict  __name , char * __restrict  __resolved ,
                           size_t __resolvedlen ) ;
#line 26
extern  __attribute__((__nothrow__)) char *( __attribute__((__warn_unused_result__,
__leaf__)) __realpath_alias)(char const   * __restrict  __name , char * __restrict  __resolved )  __asm__("realpath")  ;
#line 36
__inline extern  __attribute__((__nothrow__)) char *( __attribute__((__warn_unused_result__,
__leaf__, __artificial__, __always_inline__)) realpath)(char const   * __restrict  __name ,
                                                        char * __restrict  __resolved ) ;
#line 36 "/usr/include/x86_64-linux-gnu/bits/stdlib.h"
__inline extern char *( __attribute__((__warn_unused_result__, __leaf__, __artificial__,
__always_inline__)) realpath)(char const   * __restrict  __name , char * __restrict  __resolved ) 
{ 
  unsigned long tmp ;
  char *tmp___0 ;
  unsigned long tmp___1 ;
  char *tmp___2 ;

  {
#line 39
  tmp___1 = __builtin_object_size((void *)__resolved, 1);
#line 39
  if (tmp___1 != 0xffffffffffffffffUL) {
#line 45
    tmp = __builtin_object_size((void *)__resolved, 1);
#line 45
    tmp___0 = __realpath_chk(__name, __resolved, tmp);
#line 45
    return (tmp___0);
  }
#line 48
  tmp___2 = __realpath_alias(__name, __resolved);
#line 48
  return (tmp___2);
}
}
#line 52
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2), __leaf__)) __ptsname_r_chk)(int __fd ,
                                                                                                      char *__buf ,
                                                                                                      size_t __buflen ,
                                                                                                      size_t __nreal ) ;
#line 54
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2), __leaf__)) __ptsname_r_alias)(int __fd ,
                                                                                                        char *__buf ,
                                                                                                        size_t __buflen )  __asm__("ptsname_r")  ;
#line 57
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2), __leaf__)) __ptsname_r_chk_warn)(int __fd ,
                                                                                                           char *__buf ,
                                                                                                           size_t __buflen ,
                                                                                                           size_t __nreal )  __asm__("__ptsname_r_chk") __attribute__((__warning__("ptsname_r called with buflen bigger than size of buf"))) ;
#line 63
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__, __artificial__,
__always_inline__)) ptsname_r)(int __fd , char *__buf , size_t __buflen ) ;
#line 63 "/usr/include/x86_64-linux-gnu/bits/stdlib.h"
__inline extern int ( __attribute__((__leaf__, __artificial__, __always_inline__)) ptsname_r)(int __fd ,
                                                                                              char *__buf ,
                                                                                              size_t __buflen ) 
{ 
  unsigned long tmp ;
  int tmp___0 ;
  unsigned long tmp___1 ;
  int tmp___2 ;
  unsigned long tmp___3 ;
  unsigned long tmp___4 ;
  int tmp___5 ;

  {
#line 66
  tmp___4 = __builtin_object_size((void *)__buf, 1);
#line 66
  if (tmp___4 != 0xffffffffffffffffUL) {
#line 69
    tmp = __builtin_object_size((void *)__buf, 1);
#line 69
    tmp___0 = __ptsname_r_chk(__fd, __buf, __buflen, tmp);
#line 69
    return (tmp___0);
#line 70
    tmp___3 = __builtin_object_size((void *)__buf, 1);
#line 70
    if (__buflen > tmp___3) {
#line 71
      tmp___1 = __builtin_object_size((void *)__buf, 1);
#line 71
      tmp___2 = __ptsname_r_chk_warn(__fd, __buf, __buflen, tmp___1);
#line 71
      return (tmp___2);
    }
  }
#line 73
  tmp___5 = __ptsname_r_alias(__fd, __buf, __buflen);
#line 73
  return (tmp___5);
}
}
#line 77
extern  __attribute__((__nothrow__)) int ( __attribute__((__warn_unused_result__,
__leaf__)) __wctomb_chk)(char *__s , wchar_t __wchar , size_t __buflen ) ;
#line 79
extern  __attribute__((__nothrow__)) int ( __attribute__((__warn_unused_result__,
__leaf__)) __wctomb_alias)(char *__s , wchar_t __wchar )  __asm__("wctomb")  ;
#line 82
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__warn_unused_result__,
__leaf__, __artificial__, __always_inline__)) wctomb)(char *__s , wchar_t __wchar ) ;
#line 82 "/usr/include/x86_64-linux-gnu/bits/stdlib.h"
__inline extern int ( __attribute__((__warn_unused_result__, __leaf__, __artificial__,
__always_inline__)) wctomb)(char *__s , wchar_t __wchar ) 
{ 
  unsigned long tmp ;
  int tmp___0 ;
  unsigned long tmp___1 ;
  unsigned long tmp___2 ;
  int tmp___3 ;

  {
#line 92
  tmp___1 = __builtin_object_size((void *)__s, 1);
#line 92
  if (tmp___1 != 0xffffffffffffffffUL) {
#line 92
    tmp___2 = __builtin_object_size((void *)__s, 1);
#line 92
    if (16UL > tmp___2) {
#line 93
      tmp = __builtin_object_size((void *)__s, 1);
#line 93
      tmp___0 = __wctomb_chk(__s, __wchar, tmp);
#line 93
      return (tmp___0);
    }
  }
#line 94
  tmp___3 = __wctomb_alias(__s, __wchar);
#line 94
  return (tmp___3);
}
}
#line 98
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__leaf__)) __mbstowcs_chk)(wchar_t * __restrict  __dst ,
                                                                                        char const   * __restrict  __src ,
                                                                                        size_t __len ,
                                                                                        size_t __dstlen ) ;
#line 101
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__leaf__)) __mbstowcs_alias)(wchar_t * __restrict  __dst ,
                                                                                          char const   * __restrict  __src ,
                                                                                          size_t __len )  __asm__("mbstowcs")  ;
#line 105
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__leaf__)) __mbstowcs_chk_warn)(wchar_t * __restrict  __dst ,
                                                                                             char const   * __restrict  __src ,
                                                                                             size_t __len ,
                                                                                             size_t __dstlen )  __asm__("__mbstowcs_chk") __attribute__((__warning__("mbstowcs called with dst buffer smaller than len * sizeof (wchar_t)"))) ;
#line 112
__inline extern  __attribute__((__nothrow__)) size_t ( __attribute__((__leaf__, __artificial__,
__always_inline__)) mbstowcs)(wchar_t * __restrict  __dst , char const   * __restrict  __src ,
                              size_t __len ) ;
#line 112 "/usr/include/x86_64-linux-gnu/bits/stdlib.h"
__inline extern size_t ( __attribute__((__leaf__, __artificial__, __always_inline__)) mbstowcs)(wchar_t * __restrict  __dst ,
                                                                                                char const   * __restrict  __src ,
                                                                                                size_t __len ) 
{ 
  unsigned long tmp ;
  size_t tmp___0 ;
  unsigned long tmp___1 ;
  size_t tmp___2 ;
  unsigned long tmp___3 ;
  unsigned long tmp___4 ;
  size_t tmp___5 ;

  {
#line 116
  tmp___4 = __builtin_object_size((void *)__dst, 1);
#line 116
  if (tmp___4 != 0xffffffffffffffffUL) {
#line 119
    tmp = __builtin_object_size((void *)__dst, 1);
#line 119
    tmp___0 = __mbstowcs_chk(__dst, __src, __len, tmp / sizeof(wchar_t ));
#line 119
    return (tmp___0);
#line 122
    tmp___3 = __builtin_object_size((void *)__dst, 1);
#line 122
    if (__len > tmp___3 / sizeof(wchar_t )) {
#line 123
      tmp___1 = __builtin_object_size((void *)__dst, 1);
#line 123
      tmp___2 = __mbstowcs_chk_warn(__dst, __src, __len, tmp___1 / sizeof(wchar_t ));
#line 123
      return (tmp___2);
    }
  }
#line 126
  tmp___5 = __mbstowcs_alias(__dst, __src, __len);
#line 126
  return (tmp___5);
}
}
#line 130
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__leaf__)) __wcstombs_chk)(char * __restrict  __dst ,
                                                                                        wchar_t const   * __restrict  __src ,
                                                                                        size_t __len ,
                                                                                        size_t __dstlen ) ;
#line 133
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__leaf__)) __wcstombs_alias)(char * __restrict  __dst ,
                                                                                          wchar_t const   * __restrict  __src ,
                                                                                          size_t __len )  __asm__("wcstombs")  ;
#line 137
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__leaf__)) __wcstombs_chk_warn)(char * __restrict  __dst ,
                                                                                             wchar_t const   * __restrict  __src ,
                                                                                             size_t __len ,
                                                                                             size_t __dstlen )  __asm__("__wcstombs_chk") __attribute__((__warning__("wcstombs called with dst buffer smaller than len"))) ;
#line 143
__inline extern  __attribute__((__nothrow__)) size_t ( __attribute__((__leaf__, __artificial__,
__always_inline__)) wcstombs)(char * __restrict  __dst , wchar_t const   * __restrict  __src ,
                              size_t __len ) ;
#line 143 "/usr/include/x86_64-linux-gnu/bits/stdlib.h"
__inline extern size_t ( __attribute__((__leaf__, __artificial__, __always_inline__)) wcstombs)(char * __restrict  __dst ,
                                                                                                wchar_t const   * __restrict  __src ,
                                                                                                size_t __len ) 
{ 
  unsigned long tmp ;
  size_t tmp___0 ;
  unsigned long tmp___1 ;
  size_t tmp___2 ;
  unsigned long tmp___3 ;
  unsigned long tmp___4 ;
  size_t tmp___5 ;

  {
#line 147
  tmp___4 = __builtin_object_size((void *)__dst, 1);
#line 147
  if (tmp___4 != 0xffffffffffffffffUL) {
#line 150
    tmp = __builtin_object_size((void *)__dst, 1);
#line 150
    tmp___0 = __wcstombs_chk(__dst, __src, __len, tmp);
#line 150
    return (tmp___0);
#line 151
    tmp___3 = __builtin_object_size((void *)__dst, 1);
#line 151
    if (__len > tmp___3) {
#line 152
      tmp___1 = __builtin_object_size((void *)__dst, 1);
#line 152
      tmp___2 = __wcstombs_chk_warn(__dst, __src, __len, tmp___1);
#line 152
      return (tmp___2);
    }
  }
#line 154
  tmp___5 = __wcstombs_alias(__dst, __src, __len);
#line 154
  return (tmp___5);
}
}
#line 42 "/usr/include/string.h"
__inline extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2),
__leaf__, __artificial__, __always_inline__)) memcpy)(void * __restrict  __dest ,
                                                      void const   * __restrict  __src ,
                                                      size_t __len ) ;
#line 46
__inline extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2),
__leaf__, __artificial__, __always_inline__)) memmove)(void *__dest , void const   *__src ,
                                                       size_t __len ) ;
#line 62
__inline extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1),
__leaf__, __artificial__, __always_inline__)) memset)(void *__dest , int __ch , size_t __len ) ;
#line 125
__inline extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2),
__leaf__, __artificial__, __always_inline__)) strcpy)(char * __restrict  __dest ,
                                                      char const   * __restrict  __src ) ;
#line 128
__inline extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2),
__leaf__, __artificial__, __always_inline__)) strncpy)(char * __restrict  __dest ,
                                                       char const   * __restrict  __src ,
                                                       size_t __len ) ;
#line 133
__inline extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2),
__leaf__, __artificial__, __always_inline__)) strcat)(char * __restrict  __dest ,
                                                      char const   * __restrict  __src ) ;
#line 136
__inline extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2),
__leaf__, __artificial__, __always_inline__)) strncat)(char * __restrict  __dest ,
                                                       char const   * __restrict  __src ,
                                                       size_t __len ) ;
#line 338
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strstr)(char const   *__haystack ,
                                                                                                 char const   *__needle )  __attribute__((__pure__)) ;
#line 395
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 451
__inline extern  __attribute__((__nothrow__)) void ( __attribute__((__nonnull__(1,2),
__leaf__, __artificial__, __always_inline__)) bcopy)(void const   *__src , void *__dest ,
                                                     size_t __len ) ;
#line 455
__inline extern  __attribute__((__nothrow__)) void ( __attribute__((__nonnull__(1),
__leaf__, __artificial__, __always_inline__)) bzero)(void *__dest , size_t __len ) ;
#line 575
__inline extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2),
__leaf__, __artificial__, __always_inline__)) stpncpy)(char * __restrict  __dest ,
                                                       char const   * __restrict  __src ,
                                                       size_t __n ) ;
#line 968 "/usr/include/x86_64-linux-gnu/bits/string2.h"
__inline extern size_t __strcspn_c1(char const   *__s , int __reject ) ;
#line 969 "/usr/include/x86_64-linux-gnu/bits/string2.h"
__inline extern size_t __strcspn_c1(char const   *__s , int __reject ) 
{ 
  register size_t __result ;

  {
#line 972
  __result = (size_t )0;
#line 973
  while (1) {
#line 973
    if ((int const   )*(__s + __result) != 0) {
#line 973
      if (! ((int const   )*(__s + __result) != (int const   )__reject)) {
#line 973
        break;
      }
    } else {
#line 973
      break;
    }
#line 974
    __result ++;
  }
#line 975
  return (__result);
}
}
#line 978
__inline extern size_t __strcspn_c2(char const   *__s , int __reject1 , int __reject2 ) ;
#line 980 "/usr/include/x86_64-linux-gnu/bits/string2.h"
__inline extern size_t __strcspn_c2(char const   *__s , int __reject1 , int __reject2 ) 
{ 
  register size_t __result ;

  {
#line 983
  __result = (size_t )0;
#line 984
  while (1) {
#line 984
    if ((int const   )*(__s + __result) != 0) {
#line 984
      if ((int const   )*(__s + __result) != (int const   )__reject1) {
#line 984
        if (! ((int const   )*(__s + __result) != (int const   )__reject2)) {
#line 984
          break;
        }
      } else {
#line 984
        break;
      }
    } else {
#line 984
      break;
    }
#line 986
    __result ++;
  }
#line 987
  return (__result);
}
}
#line 990
__inline extern size_t __strcspn_c3(char const   *__s , int __reject1 , int __reject2 ,
                                    int __reject3 ) ;
#line 992 "/usr/include/x86_64-linux-gnu/bits/string2.h"
__inline extern size_t __strcspn_c3(char const   *__s , int __reject1 , int __reject2 ,
                                    int __reject3 ) 
{ 
  register size_t __result ;

  {
#line 996
  __result = (size_t )0;
#line 997
  while (1) {
#line 997
    if ((int const   )*(__s + __result) != 0) {
#line 997
      if ((int const   )*(__s + __result) != (int const   )__reject1) {
#line 997
        if ((int const   )*(__s + __result) != (int const   )__reject2) {
#line 997
          if (! ((int const   )*(__s + __result) != (int const   )__reject3)) {
#line 997
            break;
          }
        } else {
#line 997
          break;
        }
      } else {
#line 997
        break;
      }
    } else {
#line 997
      break;
    }
#line 999
    __result ++;
  }
#line 1000
  return (__result);
}
}
#line 1044
__inline extern size_t __strspn_c1(char const   *__s , int __accept ) ;
#line 1045 "/usr/include/x86_64-linux-gnu/bits/string2.h"
__inline extern size_t __strspn_c1(char const   *__s , int __accept ) 
{ 
  register size_t __result ;

  {
#line 1048
  __result = (size_t )0;
#line 1050
  while ((int const   )*(__s + __result) == (int const   )__accept) {
#line 1051
    __result ++;
  }
#line 1052
  return (__result);
}
}
#line 1055
__inline extern size_t __strspn_c2(char const   *__s , int __accept1 , int __accept2 ) ;
#line 1057 "/usr/include/x86_64-linux-gnu/bits/string2.h"
__inline extern size_t __strspn_c2(char const   *__s , int __accept1 , int __accept2 ) 
{ 
  register size_t __result ;

  {
#line 1060
  __result = (size_t )0;
#line 1062
  while (1) {
#line 1062
    if (! ((int const   )*(__s + __result) == (int const   )__accept1)) {
#line 1062
      if (! ((int const   )*(__s + __result) == (int const   )__accept2)) {
#line 1062
        break;
      }
    }
#line 1063
    __result ++;
  }
#line 1064
  return (__result);
}
}
#line 1067
__inline extern size_t __strspn_c3(char const   *__s , int __accept1 , int __accept2 ,
                                   int __accept3 ) ;
#line 1069 "/usr/include/x86_64-linux-gnu/bits/string2.h"
__inline extern size_t __strspn_c3(char const   *__s , int __accept1 , int __accept2 ,
                                   int __accept3 ) 
{ 
  register size_t __result ;

  {
#line 1072
  __result = (size_t )0;
#line 1074
  while (1) {
#line 1074
    if (! ((int const   )*(__s + __result) == (int const   )__accept1)) {
#line 1074
      if (! ((int const   )*(__s + __result) == (int const   )__accept2)) {
#line 1074
        if (! ((int const   )*(__s + __result) == (int const   )__accept3)) {
#line 1074
          break;
        }
      }
    }
#line 1076
    __result ++;
  }
#line 1077
  return (__result);
}
}
#line 1120
__inline extern char *__strpbrk_c2(char const   *__s , int __accept1 , int __accept2 ) ;
#line 1122 "/usr/include/x86_64-linux-gnu/bits/string2.h"
__inline extern char *__strpbrk_c2(char const   *__s , int __accept1 , int __accept2 ) 
{ 
  char *tmp ;

  {
#line 1126
  while (1) {
#line 1126
    if ((int const   )*__s != 0) {
#line 1126
      if ((int const   )*__s != (int const   )__accept1) {
#line 1126
        if (! ((int const   )*__s != (int const   )__accept2)) {
#line 1126
          break;
        }
      } else {
#line 1126
        break;
      }
    } else {
#line 1126
      break;
    }
#line 1127
    __s ++;
  }
#line 1128
  if ((int const   )*__s == 0) {
#line 1128
    tmp = (char *)((void *)0);
  } else {
#line 1128
    tmp = (char *)((size_t )__s);
  }
#line 1128
  return (tmp);
}
}
#line 1131
__inline extern char *__strpbrk_c3(char const   *__s , int __accept1 , int __accept2 ,
                                   int __accept3 ) ;
#line 1133 "/usr/include/x86_64-linux-gnu/bits/string2.h"
__inline extern char *__strpbrk_c3(char const   *__s , int __accept1 , int __accept2 ,
                                   int __accept3 ) 
{ 
  char *tmp ;

  {
#line 1137
  while (1) {
#line 1137
    if ((int const   )*__s != 0) {
#line 1137
      if ((int const   )*__s != (int const   )__accept1) {
#line 1137
        if ((int const   )*__s != (int const   )__accept2) {
#line 1137
          if (! ((int const   )*__s != (int const   )__accept3)) {
#line 1137
            break;
          }
        } else {
#line 1137
          break;
        }
      } else {
#line 1137
        break;
      }
    } else {
#line 1137
      break;
    }
#line 1139
    __s ++;
  }
#line 1140
  if ((int const   )*__s == 0) {
#line 1140
    tmp = (char *)((void *)0);
  } else {
#line 1140
    tmp = (char *)((size_t )__s);
  }
#line 1140
  return (tmp);
}
}
#line 1170
__inline extern char *__strtok_r_1c(char *__s , char __sep , char **__nextp ) ;
#line 1171 "/usr/include/x86_64-linux-gnu/bits/string2.h"
__inline extern char *__strtok_r_1c(char *__s , char __sep , char **__nextp ) 
{ 
  char *__result ;
  char *tmp ;
  char *tmp___0 ;

  {
#line 1175
  if ((unsigned long )__s == (unsigned long )((void *)0)) {
#line 1176
    __s = *__nextp;
  }
#line 1177
  while ((int )*__s == (int )__sep) {
#line 1178
    __s ++;
  }
#line 1179
  __result = (char *)((void *)0);
#line 1180
  if ((int )*__s != 0) {
#line 1182
    tmp = __s;
#line 1182
    __s ++;
#line 1182
    __result = tmp;
#line 1183
    while ((int )*__s != 0) {
#line 1184
      tmp___0 = __s;
#line 1184
      __s ++;
#line 1184
      if ((int )*tmp___0 == (int )__sep) {
#line 1186
        *(__s + -1) = (char )'\000';
#line 1187
        break;
      }
    }
  }
#line 1190
  *__nextp = __s;
#line 1191
  return (__result);
}
}
#line 1220
__inline extern char *__strsep_1c(char **__s , char __reject ) ;
#line 1221 "/usr/include/x86_64-linux-gnu/bits/string2.h"
__inline extern char *__strsep_1c(char **__s , char __reject ) 
{ 
  register char *__retval ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___2 ;

  {
#line 1224
  __retval = *__s;
#line 1225
  if ((unsigned long )__retval != (unsigned long )((void *)0)) {
#line 1225
    tmp___2 = __builtin_strchr(__retval, (int )__reject);
#line 1225
    tmp___0 = tmp___2;
#line 1225
    *__s = tmp___0;
#line 1225
    if ((unsigned long )tmp___0 != (unsigned long )((void *)0)) {
#line 1226
      tmp = *__s;
#line 1226
      (*__s) ++;
#line 1226
      *tmp = (char )'\000';
    }
  }
#line 1227
  return (__retval);
}
}
#line 1230
__inline extern char *__strsep_2c(char **__s , char __reject1 , char __reject2 ) ;
#line 1231 "/usr/include/x86_64-linux-gnu/bits/string2.h"
__inline extern char *__strsep_2c(char **__s , char __reject1 , char __reject2 ) 
{ 
  register char *__retval ;
  register char *__cp ;
  char *tmp ;

  {
#line 1234
  __retval = *__s;
#line 1235
  if ((unsigned long )__retval != (unsigned long )((void *)0)) {
#line 1237
    __cp = __retval;
#line 1238
    while (1) {
#line 1240
      if ((int )*__cp == 0) {
#line 1242
        __cp = (char *)((void *)0);
#line 1243
        break;
      }
#line 1245
      if ((int )*__cp == (int )__reject1) {
#line 1247
        tmp = __cp;
#line 1247
        __cp ++;
#line 1247
        *tmp = (char )'\000';
#line 1248
        break;
      } else
#line 1245
      if ((int )*__cp == (int )__reject2) {
#line 1247
        tmp = __cp;
#line 1247
        __cp ++;
#line 1247
        *tmp = (char )'\000';
#line 1248
        break;
      }
#line 1250
      __cp ++;
    }
#line 1252
    *__s = __cp;
  }
#line 1254
  return (__retval);
}
}
#line 1257
__inline extern char *__strsep_3c(char **__s , char __reject1 , char __reject2 , char __reject3 ) ;
#line 1259 "/usr/include/x86_64-linux-gnu/bits/string2.h"
__inline extern char *__strsep_3c(char **__s , char __reject1 , char __reject2 , char __reject3 ) 
{ 
  register char *__retval ;
  register char *__cp ;
  char *tmp ;

  {
#line 1262
  __retval = *__s;
#line 1263
  if ((unsigned long )__retval != (unsigned long )((void *)0)) {
#line 1265
    __cp = __retval;
#line 1266
    while (1) {
#line 1268
      if ((int )*__cp == 0) {
#line 1270
        __cp = (char *)((void *)0);
#line 1271
        break;
      }
#line 1273
      if ((int )*__cp == (int )__reject1) {
#line 1275
        tmp = __cp;
#line 1275
        __cp ++;
#line 1275
        *tmp = (char )'\000';
#line 1276
        break;
      } else
#line 1273
      if ((int )*__cp == (int )__reject2) {
#line 1275
        tmp = __cp;
#line 1275
        __cp ++;
#line 1275
        *tmp = (char )'\000';
#line 1276
        break;
      } else
#line 1273
      if ((int )*__cp == (int )__reject3) {
#line 1275
        tmp = __cp;
#line 1275
        __cp ++;
#line 1275
        *tmp = (char )'\000';
#line 1276
        break;
      }
#line 1278
      __cp ++;
    }
#line 1280
    *__s = __cp;
  }
#line 1282
  return (__retval);
}
}
#line 47 "/usr/include/x86_64-linux-gnu/bits/string3.h"
__inline extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2),
__leaf__, __artificial__, __always_inline__)) memcpy)(void * __restrict  __dest ,
                                                      void const   * __restrict  __src ,
                                                      size_t __len ) ;
#line 47 "/usr/include/x86_64-linux-gnu/bits/string3.h"
__inline extern void *( __attribute__((__nonnull__(1,2), __leaf__, __artificial__,
__always_inline__)) memcpy)(void * __restrict  __dest , void const   * __restrict  __src ,
                            size_t __len ) 
{ 
  unsigned long tmp ;
  void *tmp___0 ;

  {
#line 51
  tmp = __builtin_object_size((void *)__dest, 0);
#line 51
  tmp___0 = __builtin___memcpy_chk((void *)__dest, (void const   *)__src, __len, tmp);
#line 51
  return (tmp___0);
}
}
#line 54
__inline extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2),
__leaf__, __artificial__, __always_inline__)) memmove)(void *__dest , void const   *__src ,
                                                       size_t __len ) ;
#line 54 "/usr/include/x86_64-linux-gnu/bits/string3.h"
__inline extern void *( __attribute__((__nonnull__(1,2), __leaf__, __artificial__,
__always_inline__)) memmove)(void *__dest , void const   *__src , size_t __len ) 
{ 
  unsigned long tmp ;
  void *tmp___0 ;

  {
#line 57
  tmp = __builtin_object_size(__dest, 0);
#line 57
  tmp___0 = __builtin___memmove_chk(__dest, __src, __len, tmp);
#line 57
  return (tmp___0);
}
}
#line 75
__inline extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1),
__leaf__, __artificial__, __always_inline__)) memset)(void *__dest , int __ch , size_t __len ) ;
#line 75 "/usr/include/x86_64-linux-gnu/bits/string3.h"
__inline extern void *( __attribute__((__nonnull__(1), __leaf__, __artificial__, __always_inline__)) memset)(void *__dest ,
                                                                                                             int __ch ,
                                                                                                             size_t __len ) 
{ 
  unsigned long tmp ;
  void *tmp___0 ;

  {
#line 84
  tmp = __builtin_object_size(__dest, 0);
#line 84
  tmp___0 = __builtin___memset_chk(__dest, __ch, __len, tmp);
#line 84
  return (tmp___0);
}
}
#line 88
__inline extern  __attribute__((__nothrow__)) void ( __attribute__((__nonnull__(1,2),
__leaf__, __artificial__, __always_inline__)) bcopy)(void const   *__src , void *__dest ,
                                                     size_t __len ) ;
#line 88 "/usr/include/x86_64-linux-gnu/bits/string3.h"
__inline extern void ( __attribute__((__nonnull__(1,2), __leaf__, __artificial__,
__always_inline__)) bcopy)(void const   *__src , void *__dest , size_t __len ) 
{ 
  unsigned long tmp ;

  {
#line 91
  tmp = __builtin_object_size(__dest, 0);
#line 91
  __builtin___memmove_chk(__dest, __src, __len, tmp);
#line 92
  return;
}
}
#line 94
__inline extern  __attribute__((__nothrow__)) void ( __attribute__((__nonnull__(1),
__leaf__, __artificial__, __always_inline__)) bzero)(void *__dest , size_t __len ) ;
#line 94 "/usr/include/x86_64-linux-gnu/bits/string3.h"
__inline extern void ( __attribute__((__nonnull__(1), __leaf__, __artificial__, __always_inline__)) bzero)(void *__dest ,
                                                                                                           size_t __len ) 
{ 
  unsigned long tmp ;

  {
#line 97
  tmp = __builtin_object_size(__dest, 0);
#line 97
  __builtin___memset_chk(__dest, '\000', __len, tmp);
#line 98
  return;
}
}
#line 101
__inline extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2),
__leaf__, __artificial__, __always_inline__)) strcpy)(char * __restrict  __dest ,
                                                      char const   * __restrict  __src ) ;
#line 101 "/usr/include/x86_64-linux-gnu/bits/string3.h"
__inline extern char *( __attribute__((__nonnull__(1,2), __leaf__, __artificial__,
__always_inline__)) strcpy)(char * __restrict  __dest , char const   * __restrict  __src ) 
{ 
  unsigned long tmp ;
  char *tmp___0 ;

  {
#line 104
  tmp = __builtin_object_size((void *)__dest, 1);
#line 104
  tmp___0 = __builtin___strcpy_chk((char *)__dest, (char const   *)__src, tmp);
#line 104
  return (tmp___0);
}
}
#line 116
__inline extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2),
__leaf__, __artificial__, __always_inline__)) strncpy)(char * __restrict  __dest ,
                                                       char const   * __restrict  __src ,
                                                       size_t __len ) ;
#line 116 "/usr/include/x86_64-linux-gnu/bits/string3.h"
__inline extern char *( __attribute__((__nonnull__(1,2), __leaf__, __artificial__,
__always_inline__)) strncpy)(char * __restrict  __dest , char const   * __restrict  __src ,
                             size_t __len ) 
{ 
  unsigned long tmp ;
  char *tmp___0 ;

  {
#line 120
  tmp = __builtin_object_size((void *)__dest, 1);
#line 120
  tmp___0 = __builtin___strncpy_chk((char *)__dest, (char const   *)__src, __len,
                                    tmp);
#line 120
  return (tmp___0);
}
}
#line 124
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) __stpncpy_chk)(char *__dest ,
                                                                                      char const   *__src ,
                                                                                      size_t __n ,
                                                                                      size_t __destlen ) ;
#line 126
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) __stpncpy_alias)(char *__dest ,
                                                                                        char const   *__src ,
                                                                                        size_t __n )  __asm__("stpncpy")  ;
#line 129
__inline extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2),
__leaf__, __artificial__, __always_inline__)) stpncpy)(char * __restrict  __dest ,
                                                       char const   * __restrict  __src ,
                                                       size_t __n ) ;
#line 129 "/usr/include/x86_64-linux-gnu/bits/string3.h"
__inline extern char *( __attribute__((__nonnull__(1,2), __leaf__, __artificial__,
__always_inline__)) stpncpy)(char * __restrict  __dest , char const   * __restrict  __src ,
                             size_t __n ) 
{ 
  unsigned long tmp ;
  char *tmp___0 ;
  unsigned long tmp___1 ;
  char *tmp___3 ;

  {
#line 132
  tmp___1 = __builtin_object_size((void *)__dest, 1);
#line 132
  if (tmp___1 != 0xffffffffffffffffUL) {
#line 134
    tmp = __builtin_object_size((void *)__dest, 1);
#line 134
    tmp___0 = __stpncpy_chk((char *)__dest, (char const   *)__src, __n, tmp);
#line 134
    return (tmp___0);
  }
#line 135
  tmp___3 = __stpncpy_alias((char *)__dest, (char const   *)__src, __n);
#line 135
  return (tmp___3);
}
}
#line 139
__inline extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2),
__leaf__, __artificial__, __always_inline__)) strcat)(char * __restrict  __dest ,
                                                      char const   * __restrict  __src ) ;
#line 139 "/usr/include/x86_64-linux-gnu/bits/string3.h"
__inline extern char *( __attribute__((__nonnull__(1,2), __leaf__, __artificial__,
__always_inline__)) strcat)(char * __restrict  __dest , char const   * __restrict  __src ) 
{ 
  unsigned long tmp ;
  char *tmp___0 ;

  {
#line 142
  tmp = __builtin_object_size((void *)__dest, 1);
#line 142
  tmp___0 = __builtin___strcat_chk((char *)__dest, (char const   *)__src, tmp);
#line 142
  return (tmp___0);
}
}
#line 146
__inline extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2),
__leaf__, __artificial__, __always_inline__)) strncat)(char * __restrict  __dest ,
                                                       char const   * __restrict  __src ,
                                                       size_t __len ) ;
#line 146 "/usr/include/x86_64-linux-gnu/bits/string3.h"
__inline extern char *( __attribute__((__nonnull__(1,2), __leaf__, __artificial__,
__always_inline__)) strncat)(char * __restrict  __dest , char const   * __restrict  __src ,
                             size_t __len ) 
{ 
  unsigned long tmp ;
  char *tmp___0 ;

  {
#line 150
  tmp = __builtin_object_size((void *)__dest, 1);
#line 150
  tmp___0 = __builtin___strncat_chk((char *)__dest, (char const   *)__src, __len,
                                    tmp);
#line 150
  return (tmp___0);
}
}
#line 11 "../src/util.h"
extern rt_timerhandle rt_timer_create(void) ;
#line 12
extern void rt_timer_destroy(rt_timerhandle  ) ;
#line 13
extern void rt_timer_start(rt_timerhandle  ) ;
#line 14
extern void rt_timer_stop(rt_timerhandle  ) ;
#line 15
extern double rt_timer_time(rt_timerhandle  ) ;
#line 62 "../src/tachyon.h"
extern void rt_set_ui_message(void (*func)(int  , char * ) ) ;
#line 63
extern void rt_set_ui_progress(void (*func)(int  ) ) ;
#line 75
extern int rt_initialize(int * , char *** ) ;
#line 85
extern void rt_finalize(void) ;
#line 92
extern SceneHandle rt_newscene(void) ;
#line 100
extern void rt_deletescene(SceneHandle  ) ;
#line 107
extern void rt_renderscene(SceneHandle  ) ;
#line 114
extern void rt_outputfile(SceneHandle  , char const   *outname ) ;
#line 131
extern void rt_get_resolution(SceneHandle  , int *hres , int *vres ) ;
#line 317
extern void rt_camera_position(SceneHandle  , apivector  , apivector  , apivector  ) ;
#line 38 "../demosrc/getargs.h"
int getargs(int argc , char **argv , argoptions *opt , int node ) ;
#line 39
int presceneoptions(argoptions *opt , SceneHandle scene ) ;
#line 40
int postsceneoptions(argoptions *opt , SceneHandle scene ) ;
#line 41
void freeoptions(argoptions *opt ) ;
#line 14 "../demosrc/parse.h"
unsigned int readmodel(char const   *modelfile , SceneHandle scene ) ;
#line 12 "../demosrc/nffparse.h"
unsigned int ParseNFF(char *nffname , SceneHandle scene ) ;
#line 13 "../demosrc/ac3dparse.h"
unsigned int ParseAC3D(char *modelfile , SceneHandle scene ) ;
#line 52 "../demosrc/main.c"
static void my_ui_message(int a , char *msg ) 
{ 


  {
#line 53
  printf((char const   * __restrict  )"%s\n", msg);
#line 54
  return;
}
}
#line 56 "../demosrc/main.c"
static void my_ui_progress(int percent ) 
{ 


  {
#line 57
  printf((char const   * __restrict  )"\rRendering Progress:       %3d%% complete            \r",
         percent);
#line 58
  fflush(stdout);
#line 59
  return;
}
}
#line 65 "../demosrc/main.c"
static dispHandle *tachyon_display_create(SceneHandle scene ) 
{ 
  dispHandle *dh ;
  void *tmp ;

  {
#line 68
  tmp = malloc(sizeof(dispHandle ));
#line 68
  dh = (dispHandle *)tmp;
#line 70
  if ((unsigned long )dh != (unsigned long )((void *)0)) {
#line 71
    memset((void *)dh, 0, sizeof(dispHandle ));
#line 73
    rt_get_resolution(scene, & dh->xsize, & dh->ysize);
  }
#line 95
  return (dh);
}
}
#line 98 "../demosrc/main.c"
static void tachyon_display_draw(dispHandle *dh ) 
{ 


  {
#line 108
  return;
}
}
#line 110 "../demosrc/main.c"
static void tachyon_display_delete(dispHandle *dh ) 
{ 


  {
#line 119
  return;
}
}
#line 126 "../demosrc/main.c"
static int fly_scene(argoptions opt , SceneHandle scene , int node ) 
{ 
  dispHandle *dh ;
  int done ;
  int frameno ;
  float fps ;
  rt_timerhandle fpstimer ;
  rt_timerhandle animationtimer ;
  char outfilename[1] ;
  double tmp ;
  double tmp___0 ;
  double tmp___1 ;

  {
#line 127
  dh = (dispHandle *)((void *)0);
#line 128
  done = 0;
#line 129
  frameno = 0;
#line 139
  if (node == 0) {
#line 140
    dh = tachyon_display_create(scene);
  }
#line 142
  rt_set_ui_message((void (*)(int  , char * ))((void *)0));
#line 143
  rt_set_ui_progress((void (*)(int  ))((void *)0));
#line 145
  if (node == 0) {
#line 146
    printf((char const   * __restrict  )"Interactive Camera Flight\n");
  }
#line 148
  outfilename[0] = (char )'\000';
#line 149
  rt_outputfile(scene, (char const   *)(outfilename));
#line 151
  fpstimer = rt_timer_create();
#line 152
  animationtimer = rt_timer_create();
#line 168
  rt_timer_start(animationtimer);
#line 169
  while (! done) {
#line 170
    if (frameno != 0) {
#line 171
      rt_timer_stop(fpstimer);
#line 172
      tmp = rt_timer_time(fpstimer);
#line 172
      fps = (float )((double )1.0f / tmp);
    } else {
#line 174
      fps = (float )0.0;
    }
#line 177
    rt_timer_start(fpstimer);
#line 178
    if (node == 0) {
#line 179
      printf((char const   * __restrict  )"\rRendering Frame: %9d   %10.4f FPS       ",
             frameno, (double )fps);
#line 180
      fflush(stdout);
    }
#line 188
    rt_renderscene(scene);
#line 190
    if ((unsigned long )dh != (unsigned long )((void *)0)) {
#line 191
      tachyon_display_draw(dh);
    }
#line 193
    frameno ++;
  }
#line 196
  rt_timer_stop(animationtimer);
#line 197
  tmp___0 = rt_timer_time(animationtimer);
#line 197
  fps = (float )((double )frameno / tmp___0);
#line 199
  if (node == 0) {
#line 200
    printf((char const   * __restrict  )"\rCompleted animation of %d frames                            \n",
           frameno);
#line 201
    tmp___1 = rt_timer_time(animationtimer);
#line 201
    printf((char const   * __restrict  )"Animation Time: %10.4f seconds  (Averaged %7.4f FPS)\n",
           tmp___1, (double )fps);
  }
#line 204
  rt_timer_destroy(fpstimer);
#line 206
  if (node == 0) {
#line 207
    printf((char const   * __restrict  )"\nFinished Running Camera.\n");
#line 209
    if ((unsigned long )dh != (unsigned long )((void *)0)) {
#line 210
      tachyon_display_delete(dh);
    }
  }
#line 213
  rt_deletescene(scene);
#line 214
  rt_finalize();
#line 216
  return (0);
}
}
#line 224 "../demosrc/main.c"
static int animate_scene(argoptions opt , SceneHandle scene , int node ) 
{ 
  char outfilename[1000] ;
  FILE *camfp ;
  dispHandle *dh ;
  floatvec cv ;
  floatvec cu ;
  floatvec cc ;
  apivector cmv ;
  apivector cmu ;
  apivector cmc ;
  int frameno ;
  float fps ;
  rt_timerhandle fpstimer ;
  rt_timerhandle animationtimer ;
  double tmp ;
  int tmp___0 ;
  double tmp___1 ;
  double tmp___2 ;

  {
#line 227
  dh = (dispHandle *)((void *)0);
#line 229
  if (node == 0) {
#line 230
    dh = tachyon_display_create(scene);
  }
#line 233
  camfp = fopen((char const   * __restrict  )(opt.camfilename), (char const   * __restrict  )"r");
#line 233
  if ((unsigned long )camfp != (unsigned long )((void *)0)) {
#line 236
    frameno = 0;
#line 241
    rt_set_ui_message((void (*)(int  , char * ))((void *)0));
#line 242
    rt_set_ui_progress((void (*)(int  ))((void *)0));
#line 244
    if (node == 0) {
#line 245
      printf((char const   * __restrict  )"Running Camera File: %s\n", opt.camfilename);
    }
#line 247
    fpstimer = rt_timer_create();
#line 248
    animationtimer = rt_timer_create();
#line 250
    rt_timer_start(animationtimer);
#line 252
    while (1) {
#line 252
      tmp___0 = feof(camfp);
#line 252
      if (tmp___0) {
#line 252
        break;
      }
#line 253
      fscanf((FILE * __restrict  )camfp, (char const   * __restrict  )"%f %f %f  %f %f %f  %f %f %f",
             & cv.x, & cv.y, & cv.z, & cu.x, & cu.y, & cu.z, & cc.x, & cc.y, & cc.z);
#line 256
      cmv.x = (apiflt )cv.x;
#line 256
      cmv.y = (apiflt )cv.y;
#line 256
      cmv.z = (apiflt )cv.z;
#line 257
      cmu.x = (apiflt )cu.x;
#line 257
      cmu.y = (apiflt )cu.y;
#line 257
      cmu.z = (apiflt )cu.z;
#line 258
      cmc.x = (apiflt )cc.x;
#line 258
      cmc.y = (apiflt )cc.y;
#line 258
      cmc.z = (apiflt )cc.z;
#line 260
      if (frameno != 0) {
#line 261
        rt_timer_stop(fpstimer);
#line 262
        tmp = rt_timer_time(fpstimer);
#line 262
        fps = (float )((double )1.0f / tmp);
      } else {
#line 264
        fps = (float )0.0;
      }
#line 267
      rt_timer_start(fpstimer);
#line 268
      outfilename[0] = (char )'\000';
#line 269
      if (opt.nosave == 1) {
#line 270
        if (node == 0) {
#line 271
          printf((char const   * __restrict  )"\rRendering Frame: %9d   %10.4f FPS       ",
                 frameno, (double )fps);
#line 272
          fflush(stdout);
        }
      } else {
#line 276
        sprintf((char * __restrict  )(outfilename), (char const   * __restrict  )(opt.outfilename),
                frameno);
#line 277
        if (node == 0) {
#line 278
          printf((char const   * __restrict  )"\rRendering Frame to %s   (%10.4f FPS)       ",
                 outfilename, (double )fps);
#line 279
          fflush(stdout);
        }
      }
#line 283
      rt_outputfile(scene, (char const   *)(outfilename));
#line 284
      rt_camera_position(scene, cmc, cmv, cmu);
#line 286
      rt_renderscene(scene);
#line 288
      if ((unsigned long )dh != (unsigned long )((void *)0)) {
#line 289
        tachyon_display_draw(dh);
      }
#line 291
      frameno ++;
    }
#line 293
    rt_timer_stop(animationtimer);
#line 294
    tmp___1 = rt_timer_time(animationtimer);
#line 294
    fps = (float )((double )frameno / tmp___1);
#line 295
    if (node == 0) {
#line 296
      printf((char const   * __restrict  )"\rCompleted animation of %d frames                            \n",
             frameno);
#line 297
      tmp___2 = rt_timer_time(animationtimer);
#line 297
      printf((char const   * __restrict  )"Animation Time: %10.4f seconds  (Averaged %7.4f FPS)\n",
             tmp___2, (double )fps);
    }
#line 300
    rt_timer_destroy(fpstimer);
#line 301
    fclose(camfp);
  } else {
#line 303
    if (node == 0) {
#line 304
      printf((char const   * __restrict  )"Couldn\'t open camera file: %s\n", opt.camfilename);
#line 305
      printf((char const   * __restrict  )"Aborting render.\n");
    }
#line 307
    rt_deletescene(scene);
#line 308
    rt_finalize();
#line 309
    return (-1);
  }
#line 312
  if (node == 0) {
#line 313
    printf((char const   * __restrict  )"\nFinished Running Camera.\n");
#line 315
    if ((unsigned long )dh != (unsigned long )((void *)0)) {
#line 316
      tachyon_display_delete(dh);
    }
  }
#line 319
  rt_deletescene(scene);
#line 320
  rt_finalize();
#line 322
  return (0);
}
}
#line 331 "../demosrc/main.c"
int main(int argc , char **argv ) 
{ 
  SceneHandle scene ;
  unsigned int rc ;
  argoptions opt ;
  char *filename ;
  int node ;
  int fileindex ;
  rt_timerhandle parsetimer ;
  int tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  double tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  char multioutfilename[4096] ;
  size_t tmp___7 ;

  {
#line 340
  node = rt_initialize(& argc, & argv);
#line 342
  rt_set_ui_message(& my_ui_message);
#line 343
  rt_set_ui_progress(& my_ui_progress);
#line 345
  if (node == 0) {
#line 346
    printf((char const   * __restrict  )"Tachyon Parallel/Multiprocessor Ray Tracer   Version %s   \n",
           "0.98.9");
#line 348
    printf((char const   * __restrict  )"Copyright 1994-2010,    John E. Stone <john.stone@gmail.com> \n");
#line 349
    printf((char const   * __restrict  )"------------------------------------------------------------ \n");
  }
#line 352
  tmp = getargs(argc, argv, & opt, node);
#line 352
  rc = (unsigned int )tmp;
#line 352
  if (rc != 0U) {
#line 353
    rt_finalize();
#line 354
    exit((int )rc);
  }
#line 357
  if (opt.numfiles > 1) {
#line 358
    printf((char const   * __restrict  )"Rendering %d scene files.\n", opt.numfiles);
  }
#line 361
  fileindex = 0;
#line 361
  while (fileindex < opt.numfiles) {
#line 362
    scene = rt_newscene();
#line 365
    presceneoptions(& opt, scene);
#line 367
    filename = *(opt.filenames + fileindex);
#line 369
    if (opt.numfiles > 1) {
#line 370
      printf((char const   * __restrict  )"\nRendering scene file %d of %d, %s\n",
             fileindex + 1, opt.numfiles, filename);
    }
#line 373
    parsetimer = rt_timer_create();
#line 374
    rt_timer_start(parsetimer);
#line 376
    tmp___2 = strstr((char const   *)filename, ".nff");
#line 376
    if (tmp___2) {
#line 377
      rc = ParseNFF(filename, scene);
    } else {
#line 376
      tmp___3 = strstr((char const   *)filename, ".NFF");
#line 376
      if (tmp___3) {
#line 377
        rc = ParseNFF(filename, scene);
      } else {
#line 379
        tmp___0 = strstr((char const   *)filename, ".ac");
#line 379
        if (tmp___0) {
#line 380
          rc = ParseAC3D(filename, scene);
        } else {
#line 379
          tmp___1 = strstr((char const   *)filename, ".AC");
#line 379
          if (tmp___1) {
#line 380
            rc = ParseAC3D(filename, scene);
          } else {
#line 388
            rc = readmodel((char const   *)filename, scene);
          }
        }
      }
    }
#line 391
    rt_timer_stop(parsetimer);
#line 392
    if (rc == 0U) {
#line 392
      if (node == 0) {
#line 393
        tmp___4 = rt_timer_time(parsetimer);
#line 393
        printf((char const   * __restrict  )"Scene Parsing Time: %10.4f seconds\n",
               tmp___4);
      }
    }
#line 394
    rt_timer_destroy(parsetimer);
#line 396
    if (rc != 0U) {
#line 396
      if (node == 0) {
#line 397
        switch (rc) {
        case 1U: 
#line 399
        printf((char const   * __restrict  )"Parser failed due to nonexistent input file: %s\n",
               filename);
#line 400
        break;
        case 2U: 
#line 402
        printf((char const   * __restrict  )"Parser failed due to nonexistent included file.\n");
#line 403
        break;
        case 4U: 
#line 405
        printf((char const   * __restrict  )"Parser failed due to an input file syntax error.\n");
#line 406
        break;
        case 8U: 
#line 408
        printf((char const   * __restrict  )"Parser unexpectedly hit an end of file.\n");
#line 409
        break;
        case 16U: 
#line 411
        printf((char const   * __restrict  )"Parser ran out of memory.\n");
#line 412
        break;
        }
#line 414
        if (fileindex + 1 < opt.numfiles) {
#line 415
          printf((char const   * __restrict  )"Aborting render, continuing with next scene file...\n");
        } else {
#line 417
          printf((char const   * __restrict  )"Aborting render.\n");
        }
#line 419
        rt_deletescene(scene);
#line 420
        goto __Cont;
      }
    }
#line 424
    postsceneoptions(& opt, scene);
#line 427
    if (opt.usecamfile == 1) {
#line 428
      tmp___5 = animate_scene(opt, scene, node);
#line 428
      return (tmp___5);
    } else {
#line 430
      tmp___7 = strlen((char const   *)(opt.spaceball));
#line 430
      if (tmp___7 > 0UL) {
#line 431
        tmp___6 = fly_scene(opt, scene, node);
#line 431
        return (tmp___6);
      } else {
#line 434
        if (opt.numfiles > 1) {
#line 434
          if (opt.nosave != 1) {
#line 436
            sprintf((char * __restrict  )(multioutfilename), (char const   * __restrict  )(opt.outfilename),
                    fileindex);
#line 437
            rt_outputfile(scene, (char const   *)(multioutfilename));
          }
        }
#line 440
        rt_renderscene(scene);
      }
    }
#line 443
    rt_deletescene(scene);
    __Cont: /* CIL Label */ 
#line 361
    fileindex ++;
  }
#line 446
  rt_finalize();
#line 447
  freeoptions(& opt);
#line 449
  return (0);
}
}
/* compiler builtin: 
   int __builtin_strcmp(char const   * , char const   * ) ;  */
/* compiler builtin: 
   unsigned long __builtin_strlen(char const   * ) ;  */
#line 1 "getargs.o"
#pragma merger("0","/tmp/cil-oNi02Rnf.i","-m64,-Wall,-O3,-fomit-frame-pointer,-ffast-math")
#line 433 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) sscanf)(char const   * __restrict  __s ,
                                                                             char const   * __restrict  __format 
                                                                             , ...)  __asm__("__isoc99_sscanf")  ;
#line 479 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__warn_unused_result__,
__leaf__)) realloc)(void *__ptr , size_t __size ) ;
#line 482
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 121 "../src/tachyon.h"
extern void rt_outputformat(SceneHandle  , int format ) ;
#line 130
extern void rt_resolution(SceneHandle  , int hres , int vres ) ;
#line 138
extern void rt_crop_output(SceneHandle  , int hres , int vres , int lx , int ly ) ;
#line 146
extern void rt_aa_maxsamples(SceneHandle  , int maxsamples ) ;
#line 154
extern void rt_verbose(SceneHandle  , int v ) ;
#line 162
extern void rt_normal_fixup_mode(SceneHandle  , int mode ) ;
#line 168
extern void rt_image_clamp(SceneHandle voidscene ) ;
#line 174
extern void rt_image_normalize(SceneHandle voidscene ) ;
#line 180
extern void rt_image_gamma(SceneHandle voidscene , float gamma ) ;
#line 207
extern void rt_set_numthreads(SceneHandle  , int  ) ;
#line 236
extern void rt_fog_rendering_mode(SceneHandle  , int  ) ;
#line 252
extern void rt_trans_mode(SceneHandle  , int  ) ;
#line 262
extern void rt_boundmode(SceneHandle  , int  ) ;
#line 274
extern void rt_boundthresh(SceneHandle  , int  ) ;
#line 284
extern void rt_shadermode(SceneHandle voidscene , int mode ) ;
#line 292
extern void rt_phong_shader(SceneHandle voidscene , int mode ) ;
#line 357
extern void rt_rescale_lights(SceneHandle  , apiflt lightscale ) ;
#line 377
extern void rt_ambient_occlusion(void * , int  , apicolor  ) ;
#line 82 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) __int32_t const   **( __attribute__((__leaf__)) __ctype_tolower_loc)(void)  __attribute__((__const__)) ;
#line 84
extern  __attribute__((__nothrow__)) __int32_t const   **( __attribute__((__leaf__)) __ctype_toupper_loc)(void)  __attribute__((__const__)) ;
#line 125
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) tolower)(int __c ) ;
#line 128
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) toupper)(int __c ) ;
#line 215
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) tolower)(int __c ) ;
#line 215 "/usr/include/ctype.h"
__inline extern int ( __attribute__((__leaf__)) tolower)(int __c ) 
{ 
  __int32_t const   **tmp ;
  __int32_t tmp___0 ;

  {
#line 218
  if (__c >= -128) {
#line 218
    if (__c < 256) {
#line 218
      tmp = __ctype_tolower_loc();
#line 218
      tmp___0 = *(*tmp + __c);
    } else {
#line 218
      tmp___0 = (__int32_t const   )__c;
    }
  } else {
#line 218
    tmp___0 = (__int32_t const   )__c;
  }
#line 218
  return ((int )tmp___0);
}
}
#line 221
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) toupper)(int __c ) ;
#line 221 "/usr/include/ctype.h"
__inline extern int ( __attribute__((__leaf__)) toupper)(int __c ) 
{ 
  __int32_t const   **tmp ;
  __int32_t tmp___0 ;

  {
#line 224
  if (__c >= -128) {
#line 224
    if (__c < 256) {
#line 224
      tmp = __ctype_toupper_loc();
#line 224
      tmp___0 = *(*tmp + __c);
    } else {
#line 224
      tmp___0 = (__int32_t const   )__c;
    }
  } else {
#line 224
    tmp___0 = (__int32_t const   )__c;
  }
#line 224
  return ((int )tmp___0);
}
}
#line 9 "../demosrc/getargs.c"
static int strupncmp(char const   *a , char const   *b , int n ) 
{ 
  int __res ;
  __int32_t const   **tmp___0 ;
  int __res___0 ;
  __int32_t const   **tmp___2 ;
  int __res___1 ;
  __int32_t const   **tmp___4 ;
  int __res___2 ;
  __int32_t const   **tmp___6 ;
  int tmp___7 ;

  {
#line 10
  while (1) {
#line 10
    tmp___7 = n;
#line 10
    n --;
#line 10
    if (! (tmp___7 > 0)) {
#line 10
      break;
    }
#line 11
    if (sizeof(*a) > 1UL) {
#line 11
      __res___1 = toupper((int )*a);
    } else {
#line 11
      tmp___4 = __ctype_toupper_loc();
#line 11
      __res___1 = (int )*(*tmp___4 + (int )*a);
    }
#line 11
    if (sizeof(*b) > 1UL) {
#line 11
      __res___2 = toupper((int )*b);
    } else {
#line 11
      tmp___6 = __ctype_toupper_loc();
#line 11
      __res___2 = (int )*(*tmp___6 + (int )*b);
    }
#line 11
    if (__res___1 != __res___2) {
#line 12
      if (sizeof(*b) > 1UL) {
#line 12
        __res = toupper((int )*b);
      } else {
#line 12
        tmp___0 = __ctype_toupper_loc();
#line 12
        __res = (int )*(*tmp___0 + (int )*b);
      }
#line 12
      if (sizeof(*a) > 1UL) {
#line 12
        __res___0 = toupper((int )*a);
      } else {
#line 12
        tmp___2 = __ctype_toupper_loc();
#line 12
        __res___0 = (int )*(*tmp___2 + (int )*a);
      }
#line 12
      return (__res - __res___0);
    }
#line 14
    if ((int const   )*a == 0) {
#line 14
      return (0);
    }
#line 15
    a ++;
#line 15
    b ++;
  }
#line 17
  return (0);
}
}
#line 20 "../demosrc/getargs.c"
static int compare(char const   *a , char const   *b ) 
{ 
  size_t tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  int tmp___2 ;

  {
#line 21
  tmp = strlen(a);
#line 21
  tmp___0 = strlen(b);
#line 21
  if (tmp != tmp___0) {
#line 22
    return (-1);
  }
#line 24
  tmp___1 = strlen(a);
#line 24
  tmp___2 = strupncmp(a, b, (int )tmp___1);
#line 24
  return (tmp___2);
}
}
#line 27 "../demosrc/getargs.c"
static void printusage(char **argv ) 
{ 


  {
#line 28
  printf((char const   * __restrict  )"Usage: \n");
#line 29
  printf((char const   * __restrict  )"  %s modelfile [options] \n", *(argv + 0));
#line 30
  printf((char const   * __restrict  )"\n");
#line 31
  printf((char const   * __restrict  )"Model file formats supported:\n");
#line 32
  printf((char const   * __restrict  )"  filename.dat -- The model files originated with this package.\n");
#line 33
  printf((char const   * __restrict  )"  filaname.ac  -- AC3D model files.\n");
#line 37
  printf((char const   * __restrict  )"  filename.nff -- The NFF scene format used by Eric Haines\' SPD.\n");
#line 38
  printf((char const   * __restrict  )"\n");
#line 39
  printf((char const   * __restrict  )"Valid options:  (** denotes default behaviour)\n");
#line 40
  printf((char const   * __restrict  )"----------------------------------------------\n");
#line 41
  printf((char const   * __restrict  )"Message Options:\n");
#line 42
  printf((char const   * __restrict  )" +V verbose messages on \n");
#line 43
  printf((char const   * __restrict  )" -V verbose messages off **\n");
#line 44
  printf((char const   * __restrict  )"\n");
#line 45
  printf((char const   * __restrict  )"Speed Tuning Options:\n");
#line 46
  printf((char const   * __restrict  )" -numthreads xxx   (** default is auto-determined)\n");
#line 47
  printf((char const   * __restrict  )" -nobounding\n");
#line 48
  printf((char const   * __restrict  )" -boundthresh xxx  (** default threshold is 16)\n");
#line 49
  printf((char const   * __restrict  )"\n");
#line 50
  printf((char const   * __restrict  )"Shading Options:\n");
#line 51
  printf((char const   * __restrict  )"  -fullshade    best quality rendering (and slowest) **\n");
#line 52
  printf((char const   * __restrict  )"  -mediumshade  good quality rendering, but no shadows\n");
#line 53
  printf((char const   * __restrict  )"  -lowshade     low quality rendering, preview (and fast)\n");
#line 54
  printf((char const   * __restrict  )"  -lowestshade  worst quality rendering, preview (and fastest)\n");
#line 55
  printf((char const   * __restrict  )"\n");
#line 56
  printf((char const   * __restrict  )"Lighting Options:\n");
#line 57
  printf((char const   * __restrict  )"  -rescale_lights xxx rescale light intensity values by\n");
#line 58
  printf((char const   * __restrict  )"                      specified factor (performed before other\n");
#line 59
  printf((char const   * __restrict  )"                      lighting overrides take effect)\n");
#line 60
  printf((char const   * __restrict  )"  -auto_skylight xxx  force use of ambient occlusion lighting,\n");
#line 61
  printf((char const   * __restrict  )"                      auto-rescaling direct light sources to  \n");
#line 62
  printf((char const   * __restrict  )"                      compensate for ambient occlusion factor.\n");
#line 63
  printf((char const   * __restrict  )"                      (use value 0.7 as a good starting point)\n");
#line 64
  printf((char const   * __restrict  )"  -add_skylight xxx   force use of ambient occlusion lighting,\n");
#line 65
  printf((char const   * __restrict  )"                      manually-rescaling direct light sources to\n");
#line 66
  printf((char const   * __restrict  )"                      compensate for ambient occlusion factor.\n");
#line 67
  printf((char const   * __restrict  )"  -skylight_samples xxx number of sample rays to shoot.\n");
#line 68
  printf((char const   * __restrict  )"\n");
#line 69
  printf((char const   * __restrict  )"Specular Highlight Shading Options:\n");
#line 70
  printf((char const   * __restrict  )"  -shade_phong       Phong specular highlights\n");
#line 71
  printf((char const   * __restrict  )"  -shade_blinn       Blinn\'s specular highlights**\n");
#line 72
  printf((char const   * __restrict  )"  -shade_blinn_fast  fast approximation to Blinn\'s highlights\n");
#line 73
  printf((char const   * __restrict  )"  -shade_nullphong   disable specular highlights\n");
#line 74
  printf((char const   * __restrict  )"\n");
#line 75
  printf((char const   * __restrict  )"Transparency Shading Options:\n");
#line 76
  printf((char const   * __restrict  )"  -trans_orig        Original implementation**\n");
#line 77
  printf((char const   * __restrict  )"  -trans_vmd         Opacity post-multiply used by VMD\n");
#line 78
  printf((char const   * __restrict  )"\n");
#line 79
  printf((char const   * __restrict  )"Fog Shading Options:\n");
#line 80
  printf((char const   * __restrict  )"  -fog_radial        Radial fog implementation**\n");
#line 81
  printf((char const   * __restrict  )"  -fog_vmd           Planar OpenGL-like fog used by VMD\n");
#line 82
  printf((char const   * __restrict  )"\n");
#line 83
  printf((char const   * __restrict  )"Surface Normal/Winding Order Fixup Mode:\n");
#line 84
  printf((char const   * __restrict  )"  -normalfixup [off | flip | guess]  (**off is default)\n");
#line 85
  printf((char const   * __restrict  )"\n");
#line 86
  printf((char const   * __restrict  )"Antialiasing Options:\n");
#line 87
  printf((char const   * __restrict  )"  -aasamples xxx  (maximum supersamples taken per pixel)\n");
#line 88
  printf((char const   * __restrict  )"                  (** default is 0, or scene file determined)\n");
#line 89
  printf((char const   * __restrict  )"\n");
#line 90
  printf((char const   * __restrict  )"Output Options:\n");
#line 91
  printf((char const   * __restrict  )"  -res Xres Yres  override scene-defined output image size\n");
#line 92
  printf((char const   * __restrict  )"  -o outfile.tga  set output file name\n");
#line 93
  printf((char const   * __restrict  )"  -clamp          clamp pixel values to [0 to 1) (** default)\n");
#line 94
  printf((char const   * __restrict  )"  -normalize      normalize pixel values to [0 to 1)\n");
#line 95
  printf((char const   * __restrict  )"  -gamma val      normalize apply gamma correction\n");
#line 96
  printf((char const   * __restrict  )"  -format BMP     24-bit Windows BMP  (uncompressed)\n");
#line 100
  printf((char const   * __restrict  )"  -format JPEG    XXX Not compiled into this binary XXX\n");
#line 105
  printf((char const   * __restrict  )"  -format PNG     XXX Not compiled into this binary XXX\n");
#line 107
  printf((char const   * __restrict  )"  -format PPM     24-bit PPM          (uncompressed)\n");
#line 108
  printf((char const   * __restrict  )"  -format PPM48   48-bit PPM          (uncompressed)\n");
#line 109
  printf((char const   * __restrict  )"  -format PSD48   48-bit PSD          (uncompressed)\n");
#line 110
  printf((char const   * __restrict  )"  -format RGB     24-bit SGI RGB      (uncompressed)\n");
#line 111
  printf((char const   * __restrict  )"  -format TARGA   24-bit Targa        (uncompressed) **\n");
#line 112
  printf((char const   * __restrict  )"\n");
#line 113
  printf((char const   * __restrict  )"Animation Related Options:\n");
#line 114
  printf((char const   * __restrict  )" -camfile filename.cam  Animate using file of camera positions.\n");
#line 115
  printf((char const   * __restrict  )" -nosave                Disable writing of output frames to disk\n");
#line 116
  printf((char const   * __restrict  )"                        (only used for doing real-time rendering)\n");
#line 117
  printf((char const   * __restrict  )"\n");
#line 125
  return;
}
}
#line 127 "../demosrc/getargs.c"
static void initoptions(argoptions *opt ) 
{ 
  void *tmp ;

  {
#line 128
  memset((void *)opt, 0, sizeof(argoptions ));
#line 129
  tmp = malloc(sizeof(char *) * 10UL);
#line 129
  opt->filenames = (char **)tmp;
#line 130
  opt->numfiles = 0;
#line 131
  opt->useoutfilename = -1;
#line 132
  opt->outimageformat = -1;
#line 133
  opt->xsize = 0;
#line 134
  opt->ysize = 0;
#line 135
  opt->verbosemode = -1;
#line 136
  opt->aa_maxsamples = -1;
#line 137
  opt->boundmode = -1;
#line 138
  opt->boundthresh = -1;
#line 139
  opt->usecamfile = -1;
#line 140
  opt->shadermode = -1;
#line 141
  opt->phongfunc = -1;
#line 142
  opt->transmode = -1;
#line 143
  opt->fogmode = -1;
#line 144
  opt->normalfixupmode = -1;
#line 145
  opt->imgprocess = -1;
#line 146
  opt->imggamma = (float )1.0;
#line 147
  opt->numthreads = -1;
#line 148
  opt->nosave = -1;
#line 149
  opt->rescale_lights = (float )1.0;
#line 150
  opt->auto_skylight = (float )0.0;
#line 151
  opt->add_skylight = (float )0.0;
#line 152
  opt->skylight_samples = 128;
#line 153
  opt->cropmode = 0;
#line 154
  opt->cropxres = 0;
#line 155
  opt->cropyres = 0;
#line 156
  opt->cropxstart = 0;
#line 157
  opt->cropystart = 0;
#line 158
  return;
}
}
#line 161 "../demosrc/getargs.c"
int presceneoptions(argoptions *opt , SceneHandle scene ) 
{ 


  {
#line 162
  if (opt->normalfixupmode != -1) {
#line 163
    rt_normal_fixup_mode(scene, opt->normalfixupmode);
  }
#line 166
  return (0);
}
}
#line 170 "../demosrc/getargs.c"
int postsceneoptions(argoptions *opt , SceneHandle scene ) 
{ 
  int xs ;
  int ys ;
  apicolor col ;
  float lightscale ;
  apicolor col___0 ;

  {
#line 171
  if (opt->outimageformat == -1) {
#line 172
    opt->outimageformat = 0;
  }
#line 174
  if (opt->xsize > 0) {
#line 174
    if (opt->ysize > 0) {
#line 175
      rt_resolution(scene, opt->xsize, opt->ysize);
    }
  }
#line 178
  if (opt->cropmode != 0) {
#line 179
    if (opt->cropmode == 1) {
#line 180
      rt_crop_output(scene, opt->cropxres, opt->cropyres, opt->cropxstart, opt->cropystart);
    } else {
#line 184
      rt_get_resolution(scene, & xs, & ys);
#line 185
      rt_crop_output(scene, 100, 100, xs / 2 - 50, ys / 2 - 50);
    }
  }
#line 189
  if (opt->useoutfilename == -1) {
#line 190
    if (opt->usecamfile != -1) {
#line 191
      strcpy((char * __restrict  )(opt->outfilename), (char const   * __restrict  )"cam.%04d");
    } else
#line 192
    if (opt->numfiles > 1) {
#line 193
      strcpy((char * __restrict  )(opt->outfilename), (char const   * __restrict  )"outfile.%04d");
    } else {
#line 195
      strcpy((char * __restrict  )(opt->outfilename), (char const   * __restrict  )"outfile");
    }
#line 198
    switch (opt->outimageformat) {
    case 1: 
#line 200
    strcat((char * __restrict  )(opt->outfilename), (char const   * __restrict  )".ppm");
#line 201
    break;
    case 4: 
#line 204
    strcat((char * __restrict  )(opt->outfilename), (char const   * __restrict  )".bmp");
#line 205
    break;
    case 2: 
#line 208
    strcat((char * __restrict  )(opt->outfilename), (char const   * __restrict  )".rgb");
#line 209
    break;
    case 3: 
#line 212
    strcat((char * __restrict  )(opt->outfilename), (char const   * __restrict  )".jpg");
#line 213
    break;
    case 5: 
#line 216
    strcat((char * __restrict  )(opt->outfilename), (char const   * __restrict  )".png");
#line 217
    break;
    case 7: 
#line 220
    strcat((char * __restrict  )(opt->outfilename), (char const   * __restrict  )".psd");
#line 221
    break;
    case 6: 
#line 224
    strcat((char * __restrict  )(opt->outfilename), (char const   * __restrict  )".ppm");
#line 225
    break;
    default: 
#line 229
    strcat((char * __restrict  )(opt->outfilename), (char const   * __restrict  )".tga");
#line 230
    break;
    }
  }
#line 234
  if (opt->nosave == 1) {
#line 235
    strcpy((char * __restrict  )(opt->outfilename), (char const   * __restrict  )"\000");
  }
#line 238
  if ((double )opt->rescale_lights < 1.0) {
#line 240
    rt_rescale_lights(scene, (apiflt )opt->rescale_lights);
  }
#line 243
  if ((double )opt->auto_skylight > 0.0) {
#line 247
    lightscale = (float )(1.0 - (double )opt->auto_skylight);
#line 248
    if ((double )lightscale < 0.0) {
#line 249
      lightscale = (float )0.0;
    }
#line 250
    rt_rescale_lights(scene, (apiflt )lightscale);
#line 252
    col.r = opt->auto_skylight;
#line 253
    col.g = opt->auto_skylight;
#line 254
    col.b = opt->auto_skylight;
#line 255
    rt_ambient_occlusion(scene, opt->skylight_samples, col);
  } else
#line 256
  if ((double )opt->add_skylight > 0.0) {
#line 259
    col___0.r = opt->add_skylight;
#line 260
    col___0.g = opt->add_skylight;
#line 261
    col___0.b = opt->add_skylight;
#line 262
    rt_ambient_occlusion(scene, opt->skylight_samples, col___0);
  }
#line 265
  rt_outputformat(scene, opt->outimageformat);
#line 266
  rt_outputfile(scene, (char const   *)(opt->outfilename));
#line 268
  if (opt->imgprocess != -1) {
#line 269
    switch (opt->imgprocess) {
    case 0: 
#line 271
    rt_image_clamp(scene);
#line 272
    break;
    case 1: 
#line 275
    rt_image_normalize(scene);
#line 276
    break;
    case 2: 
#line 279
    rt_image_gamma(scene, opt->imggamma);
#line 280
    break;
    }
  }
#line 284
  if (opt->verbosemode == 1) {
#line 285
    rt_verbose(scene, 1);
  }
#line 288
  if (opt->verbosemode == 0) {
#line 289
    rt_verbose(scene, 0);
  }
#line 292
  if (opt->aa_maxsamples != -1) {
#line 293
    rt_aa_maxsamples(scene, opt->aa_maxsamples);
  }
#line 296
  if (opt->boundmode != -1) {
#line 297
    rt_boundmode(scene, opt->boundmode);
  }
#line 300
  if (opt->boundthresh != -1) {
#line 301
    rt_boundthresh(scene, opt->boundthresh);
  }
#line 304
  if (opt->shadermode != -1) {
#line 305
    rt_shadermode(scene, opt->shadermode);
  }
#line 308
  if (opt->phongfunc != -1) {
#line 309
    rt_phong_shader(scene, opt->phongfunc);
  }
#line 312
  if (opt->transmode != -1) {
#line 313
    rt_trans_mode(scene, opt->transmode);
  }
#line 316
  if (opt->fogmode != -1) {
#line 317
    rt_fog_rendering_mode(scene, opt->fogmode);
  }
#line 320
  if (opt->numthreads != -1) {
#line 321
    rt_set_numthreads(scene, opt->numthreads);
  }
#line 324
  return (0);
}
}
#line 327 "../demosrc/getargs.c"
static int getparm(int argc , char **argv , int num , argoptions *opt , int node ) 
{ 
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___0 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___7 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  size_t __s1_len___1 ;
  size_t __s2_len___1 ;
  int tmp___14 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  size_t __s1_len___2 ;
  size_t __s2_len___2 ;
  int tmp___21 ;
  int tmp___24 ;
  int tmp___25 ;
  int tmp___26 ;
  char tmp___27[1024] ;
  size_t __s1_len___3 ;
  size_t __s2_len___3 ;
  int tmp___29 ;
  int tmp___32 ;
  int tmp___33 ;
  int tmp___34 ;
  size_t __s1_len___4 ;
  size_t __s2_len___4 ;
  int tmp___36 ;
  int tmp___39 ;
  int tmp___40 ;
  int tmp___41 ;
  size_t __s1_len___5 ;
  size_t __s2_len___5 ;
  int tmp___43 ;
  int tmp___46 ;
  int tmp___47 ;
  int tmp___48 ;
  size_t __s1_len___6 ;
  size_t __s2_len___6 ;
  int tmp___50 ;
  int tmp___53 ;
  int tmp___54 ;
  int tmp___55 ;
  size_t __s1_len___7 ;
  size_t __s2_len___7 ;
  int tmp___57 ;
  int tmp___60 ;
  int tmp___61 ;
  int tmp___62 ;
  size_t __s1_len___8 ;
  size_t __s2_len___8 ;
  int tmp___64 ;
  int tmp___67 ;
  int tmp___68 ;
  int tmp___69 ;
  size_t __s1_len___9 ;
  size_t __s2_len___9 ;
  int tmp___71 ;
  int tmp___74 ;
  int tmp___75 ;
  int tmp___76 ;
  size_t __s1_len___10 ;
  size_t __s2_len___10 ;
  int tmp___78 ;
  int tmp___81 ;
  int tmp___82 ;
  int tmp___83 ;
  size_t __s1_len___11 ;
  size_t __s2_len___11 ;
  int tmp___85 ;
  int tmp___88 ;
  int tmp___89 ;
  int tmp___90 ;
  size_t __s1_len___12 ;
  size_t __s2_len___12 ;
  int tmp___92 ;
  int tmp___95 ;
  int tmp___96 ;
  int tmp___97 ;
  size_t __s1_len___13 ;
  size_t __s2_len___13 ;
  int tmp___99 ;
  int tmp___102 ;
  int tmp___103 ;
  int tmp___104 ;
  size_t __s1_len___14 ;
  size_t __s2_len___14 ;
  int tmp___106 ;
  int tmp___109 ;
  int tmp___110 ;
  int tmp___111 ;
  size_t __s1_len___15 ;
  size_t __s2_len___15 ;
  int tmp___113 ;
  int tmp___116 ;
  int tmp___117 ;
  int tmp___118 ;
  size_t __s1_len___16 ;
  size_t __s2_len___16 ;
  int tmp___120 ;
  int tmp___123 ;
  int tmp___124 ;
  int tmp___125 ;
  size_t __s1_len___17 ;
  size_t __s2_len___17 ;
  int tmp___127 ;
  int tmp___130 ;
  int tmp___131 ;
  int tmp___132 ;
  size_t __s1_len___18 ;
  size_t __s2_len___18 ;
  int tmp___134 ;
  int tmp___137 ;
  int tmp___138 ;
  int tmp___139 ;
  size_t __s1_len___19 ;
  size_t __s2_len___19 ;
  int tmp___141 ;
  int tmp___144 ;
  int tmp___145 ;
  int tmp___146 ;
  size_t __s1_len___20 ;
  size_t __s2_len___20 ;
  int tmp___148 ;
  int tmp___151 ;
  int tmp___152 ;
  int tmp___153 ;
  size_t __s1_len___21 ;
  size_t __s2_len___21 ;
  int tmp___155 ;
  int tmp___158 ;
  int tmp___159 ;
  int tmp___160 ;
  size_t __s1_len___22 ;
  size_t __s2_len___22 ;
  int tmp___162 ;
  int tmp___165 ;
  int tmp___166 ;
  int tmp___167 ;
  size_t __s1_len___23 ;
  size_t __s2_len___23 ;
  int tmp___169 ;
  int tmp___172 ;
  int tmp___173 ;
  int tmp___174 ;
  size_t __s1_len___24 ;
  size_t __s2_len___24 ;
  int tmp___176 ;
  int tmp___179 ;
  int tmp___180 ;
  int tmp___181 ;
  size_t __s1_len___25 ;
  size_t __s2_len___25 ;
  int tmp___183 ;
  int tmp___186 ;
  int tmp___187 ;
  int tmp___188 ;
  size_t __s1_len___26 ;
  size_t __s2_len___26 ;
  int tmp___190 ;
  int tmp___193 ;
  int tmp___194 ;
  int tmp___195 ;
  size_t __s1_len___27 ;
  size_t __s2_len___27 ;
  int tmp___197 ;
  int tmp___200 ;
  int tmp___201 ;
  int tmp___202 ;
  size_t __s1_len___28 ;
  size_t __s2_len___28 ;
  int tmp___204 ;
  int tmp___207 ;
  int tmp___208 ;
  int tmp___209 ;
  size_t __s1_len___29 ;
  size_t __s2_len___29 ;
  int tmp___211 ;
  int tmp___214 ;
  int tmp___215 ;
  int tmp___216 ;
  size_t __s1_len___30 ;
  size_t __s2_len___30 ;
  int tmp___218 ;
  int tmp___221 ;
  int tmp___222 ;
  int tmp___223 ;
  size_t __s1_len___31 ;
  size_t __s2_len___31 ;
  int tmp___225 ;
  int tmp___228 ;
  int tmp___229 ;
  int tmp___230 ;
  size_t __s1_len___32 ;
  size_t __s2_len___32 ;
  int tmp___232 ;
  int tmp___235 ;
  int tmp___236 ;
  int tmp___237 ;
  size_t __s1_len___33 ;
  size_t __s2_len___33 ;
  int tmp___239 ;
  int tmp___242 ;
  int tmp___243 ;
  int tmp___244 ;
  char str[80] ;
  int tmp___245 ;
  int tmp___246 ;
  int tmp___247 ;
  int tmp___248 ;
  int tmp___249 ;
  int tmp___250 ;
  size_t __s1_len___34 ;
  size_t __s2_len___34 ;
  int tmp___252 ;
  int tmp___255 ;
  int tmp___256 ;
  int tmp___257 ;

  {
#line 328
  if (0) {
#line 328
    __s1_len = __builtin_strlen((char const   *)*(argv + num));
#line 328
    __s2_len = __builtin_strlen("-o");
#line 328
    if (! ((size_t )((void const   *)(*(argv + num) + 1)) - (size_t )((void const   *)*(argv + num)) == 1UL)) {
#line 328
      goto _L___0;
    } else
#line 328
    if (__s1_len >= 4UL) {
      _L___0: /* CIL Label */ 
#line 328
      if (! ((size_t )((void const   *)("-o" + 1)) - (size_t )((void const   *)"-o") == 1UL)) {
#line 328
        tmp___5 = 1;
      } else
#line 328
      if (__s2_len >= 4UL) {
#line 328
        tmp___5 = 1;
      } else {
#line 328
        tmp___5 = 0;
      }
    } else {
#line 328
      tmp___5 = 0;
    }
#line 328
    if (tmp___5) {
#line 328
      tmp___0 = __builtin_strcmp((char const   *)*(argv + num), "-o");
#line 328
      tmp___4 = tmp___0;
    } else {
#line 328
      tmp___3 = __builtin_strcmp((char const   *)*(argv + num), "-o");
#line 328
      tmp___4 = tmp___3;
    }
  } else {
#line 328
    tmp___3 = __builtin_strcmp((char const   *)*(argv + num), "-o");
#line 328
    tmp___4 = tmp___3;
  }
#line 328
  if (! tmp___4) {
#line 329
    opt->useoutfilename = 1;
#line 330
    sscanf((char const   * __restrict  )*(argv + (num + 1)), (char const   * __restrict  )"%s",
           (char *)(& opt->outfilename));
#line 331
    return (2);
  }
#line 333
  if (0) {
#line 333
    __s1_len___0 = __builtin_strlen((char const   *)*(argv + num));
#line 333
    __s2_len___0 = __builtin_strlen("-numthreads");
#line 333
    if (! ((size_t )((void const   *)(*(argv + num) + 1)) - (size_t )((void const   *)*(argv + num)) == 1UL)) {
#line 333
      goto _L___2;
    } else
#line 333
    if (__s1_len___0 >= 4UL) {
      _L___2: /* CIL Label */ 
#line 333
      if (! ((size_t )((void const   *)("-numthreads" + 1)) - (size_t )((void const   *)"-numthreads") == 1UL)) {
#line 333
        tmp___12 = 1;
      } else
#line 333
      if (__s2_len___0 >= 4UL) {
#line 333
        tmp___12 = 1;
      } else {
#line 333
        tmp___12 = 0;
      }
    } else {
#line 333
      tmp___12 = 0;
    }
#line 333
    if (tmp___12) {
#line 333
      tmp___7 = __builtin_strcmp((char const   *)*(argv + num), "-numthreads");
#line 333
      tmp___11 = tmp___7;
    } else {
#line 333
      tmp___10 = __builtin_strcmp((char const   *)*(argv + num), "-numthreads");
#line 333
      tmp___11 = tmp___10;
    }
  } else {
#line 333
    tmp___10 = __builtin_strcmp((char const   *)*(argv + num), "-numthreads");
#line 333
    tmp___11 = tmp___10;
  }
#line 333
  if (! tmp___11) {
#line 334
    sscanf((char const   * __restrict  )*(argv + (num + 1)), (char const   * __restrict  )"%d",
           & opt->numthreads);
#line 335
    return (2);
  }
#line 337
  if (0) {
#line 337
    __s1_len___1 = __builtin_strlen((char const   *)*(argv + num));
#line 337
    __s2_len___1 = __builtin_strlen("-camfile");
#line 337
    if (! ((size_t )((void const   *)(*(argv + num) + 1)) - (size_t )((void const   *)*(argv + num)) == 1UL)) {
#line 337
      goto _L___4;
    } else
#line 337
    if (__s1_len___1 >= 4UL) {
      _L___4: /* CIL Label */ 
#line 337
      if (! ((size_t )((void const   *)("-camfile" + 1)) - (size_t )((void const   *)"-camfile") == 1UL)) {
#line 337
        tmp___19 = 1;
      } else
#line 337
      if (__s2_len___1 >= 4UL) {
#line 337
        tmp___19 = 1;
      } else {
#line 337
        tmp___19 = 0;
      }
    } else {
#line 337
      tmp___19 = 0;
    }
#line 337
    if (tmp___19) {
#line 337
      tmp___14 = __builtin_strcmp((char const   *)*(argv + num), "-camfile");
#line 337
      tmp___18 = tmp___14;
    } else {
#line 337
      tmp___17 = __builtin_strcmp((char const   *)*(argv + num), "-camfile");
#line 337
      tmp___18 = tmp___17;
    }
  } else {
#line 337
    tmp___17 = __builtin_strcmp((char const   *)*(argv + num), "-camfile");
#line 337
    tmp___18 = tmp___17;
  }
#line 337
  if (! tmp___18) {
#line 338
    opt->usecamfile = 1;
#line 339
    sscanf((char const   * __restrict  )*(argv + (num + 1)), (char const   * __restrict  )"%s",
           & opt->camfilename[0]);
#line 340
    return (2);
  }
#line 342
  if (0) {
#line 342
    __s1_len___2 = __builtin_strlen((char const   *)*(argv + num));
#line 342
    __s2_len___2 = __builtin_strlen("-nosave");
#line 342
    if (! ((size_t )((void const   *)(*(argv + num) + 1)) - (size_t )((void const   *)*(argv + num)) == 1UL)) {
#line 342
      goto _L___6;
    } else
#line 342
    if (__s1_len___2 >= 4UL) {
      _L___6: /* CIL Label */ 
#line 342
      if (! ((size_t )((void const   *)("-nosave" + 1)) - (size_t )((void const   *)"-nosave") == 1UL)) {
#line 342
        tmp___26 = 1;
      } else
#line 342
      if (__s2_len___2 >= 4UL) {
#line 342
        tmp___26 = 1;
      } else {
#line 342
        tmp___26 = 0;
      }
    } else {
#line 342
      tmp___26 = 0;
    }
#line 342
    if (tmp___26) {
#line 342
      tmp___21 = __builtin_strcmp((char const   *)*(argv + num), "-nosave");
#line 342
      tmp___25 = tmp___21;
    } else {
#line 342
      tmp___24 = __builtin_strcmp((char const   *)*(argv + num), "-nosave");
#line 342
      tmp___25 = tmp___24;
    }
  } else {
#line 342
    tmp___24 = __builtin_strcmp((char const   *)*(argv + num), "-nosave");
#line 342
    tmp___25 = tmp___24;
  }
#line 342
  if (! tmp___25) {
#line 344
    opt->nosave = 1;
#line 345
    return (1);
  }
#line 347
  if (0) {
#line 347
    __s1_len___6 = __builtin_strlen((char const   *)*(argv + num));
#line 347
    __s2_len___6 = __builtin_strlen("-normalfixup");
#line 347
    if (! ((size_t )((void const   *)(*(argv + num) + 1)) - (size_t )((void const   *)*(argv + num)) == 1UL)) {
#line 347
      goto _L___14;
    } else
#line 347
    if (__s1_len___6 >= 4UL) {
      _L___14: /* CIL Label */ 
#line 347
      if (! ((size_t )((void const   *)("-normalfixup" + 1)) - (size_t )((void const   *)"-normalfixup") == 1UL)) {
#line 347
        tmp___55 = 1;
      } else
#line 347
      if (__s2_len___6 >= 4UL) {
#line 347
        tmp___55 = 1;
      } else {
#line 347
        tmp___55 = 0;
      }
    } else {
#line 347
      tmp___55 = 0;
    }
#line 347
    if (tmp___55) {
#line 347
      tmp___50 = __builtin_strcmp((char const   *)*(argv + num), "-normalfixup");
#line 347
      tmp___54 = tmp___50;
    } else {
#line 347
      tmp___53 = __builtin_strcmp((char const   *)*(argv + num), "-normalfixup");
#line 347
      tmp___54 = tmp___53;
    }
  } else {
#line 347
    tmp___53 = __builtin_strcmp((char const   *)*(argv + num), "-normalfixup");
#line 347
    tmp___54 = tmp___53;
  }
#line 347
  if (! tmp___54) {
#line 349
    sscanf((char const   * __restrict  )*(argv + (num + 1)), (char const   * __restrict  )"%s",
           tmp___27);
#line 350
    if (0) {
#line 350
      __s1_len___5 = __builtin_strlen((char const   *)(tmp___27));
#line 350
      __s2_len___5 = __builtin_strlen("off");
#line 350
      if (! ((size_t )((void const   *)(tmp___27 + 1)) - (size_t )((void const   *)(tmp___27)) == 1UL)) {
#line 350
        goto _L___12;
      } else
#line 350
      if (__s1_len___5 >= 4UL) {
        _L___12: /* CIL Label */ 
#line 350
        if (! ((size_t )((void const   *)("off" + 1)) - (size_t )((void const   *)"off") == 1UL)) {
#line 350
          tmp___48 = 1;
        } else
#line 350
        if (__s2_len___5 >= 4UL) {
#line 350
          tmp___48 = 1;
        } else {
#line 350
          tmp___48 = 0;
        }
      } else {
#line 350
        tmp___48 = 0;
      }
#line 350
      if (tmp___48) {
#line 350
        tmp___43 = __builtin_strcmp((char const   *)(tmp___27), "off");
#line 350
        tmp___47 = tmp___43;
      } else {
#line 350
        tmp___46 = __builtin_strcmp((char const   *)(tmp___27), "off");
#line 350
        tmp___47 = tmp___46;
      }
    } else {
#line 350
      tmp___46 = __builtin_strcmp((char const   *)(tmp___27), "off");
#line 350
      tmp___47 = tmp___46;
    }
#line 350
    if (tmp___47) {
#line 352
      if (0) {
#line 352
        __s1_len___4 = __builtin_strlen((char const   *)(tmp___27));
#line 352
        __s2_len___4 = __builtin_strlen("flip");
#line 352
        if (! ((size_t )((void const   *)(tmp___27 + 1)) - (size_t )((void const   *)(tmp___27)) == 1UL)) {
#line 352
          goto _L___10;
        } else
#line 352
        if (__s1_len___4 >= 4UL) {
          _L___10: /* CIL Label */ 
#line 352
          if (! ((size_t )((void const   *)("flip" + 1)) - (size_t )((void const   *)"flip") == 1UL)) {
#line 352
            tmp___41 = 1;
          } else
#line 352
          if (__s2_len___4 >= 4UL) {
#line 352
            tmp___41 = 1;
          } else {
#line 352
            tmp___41 = 0;
          }
        } else {
#line 352
          tmp___41 = 0;
        }
#line 352
        if (tmp___41) {
#line 352
          tmp___36 = __builtin_strcmp((char const   *)(tmp___27), "flip");
#line 352
          tmp___40 = tmp___36;
        } else {
#line 352
          tmp___39 = __builtin_strcmp((char const   *)(tmp___27), "flip");
#line 352
          tmp___40 = tmp___39;
        }
      } else {
#line 352
        tmp___39 = __builtin_strcmp((char const   *)(tmp___27), "flip");
#line 352
        tmp___40 = tmp___39;
      }
#line 352
      if (tmp___40) {
#line 354
        if (0) {
#line 354
          __s1_len___3 = __builtin_strlen((char const   *)(tmp___27));
#line 354
          __s2_len___3 = __builtin_strlen("guess");
#line 354
          if (! ((size_t )((void const   *)(tmp___27 + 1)) - (size_t )((void const   *)(tmp___27)) == 1UL)) {
#line 354
            goto _L___8;
          } else
#line 354
          if (__s1_len___3 >= 4UL) {
            _L___8: /* CIL Label */ 
#line 354
            if (! ((size_t )((void const   *)("guess" + 1)) - (size_t )((void const   *)"guess") == 1UL)) {
#line 354
              tmp___34 = 1;
            } else
#line 354
            if (__s2_len___3 >= 4UL) {
#line 354
              tmp___34 = 1;
            } else {
#line 354
              tmp___34 = 0;
            }
          } else {
#line 354
            tmp___34 = 0;
          }
#line 354
          if (tmp___34) {
#line 354
            tmp___29 = __builtin_strcmp((char const   *)(tmp___27), "guess");
#line 354
            tmp___33 = tmp___29;
          } else {
#line 354
            tmp___32 = __builtin_strcmp((char const   *)(tmp___27), "guess");
#line 354
            tmp___33 = tmp___32;
          }
        } else {
#line 354
          tmp___32 = __builtin_strcmp((char const   *)(tmp___27), "guess");
#line 354
          tmp___33 = tmp___32;
        }
#line 354
        if (! tmp___33) {
#line 355
          opt->normalfixupmode = 2;
        }
      } else {
#line 353
        opt->normalfixupmode = 1;
      }
    } else {
#line 351
      opt->normalfixupmode = 0;
    }
#line 357
    return (2);
  }
#line 359
  if (0) {
#line 359
    __s1_len___7 = __builtin_strlen((char const   *)*(argv + num));
#line 359
    __s2_len___7 = __builtin_strlen("-aasamples");
#line 359
    if (! ((size_t )((void const   *)(*(argv + num) + 1)) - (size_t )((void const   *)*(argv + num)) == 1UL)) {
#line 359
      goto _L___16;
    } else
#line 359
    if (__s1_len___7 >= 4UL) {
      _L___16: /* CIL Label */ 
#line 359
      if (! ((size_t )((void const   *)("-aasamples" + 1)) - (size_t )((void const   *)"-aasamples") == 1UL)) {
#line 359
        tmp___62 = 1;
      } else
#line 359
      if (__s2_len___7 >= 4UL) {
#line 359
        tmp___62 = 1;
      } else {
#line 359
        tmp___62 = 0;
      }
    } else {
#line 359
      tmp___62 = 0;
    }
#line 359
    if (tmp___62) {
#line 359
      tmp___57 = __builtin_strcmp((char const   *)*(argv + num), "-aasamples");
#line 359
      tmp___61 = tmp___57;
    } else {
#line 359
      tmp___60 = __builtin_strcmp((char const   *)*(argv + num), "-aasamples");
#line 359
      tmp___61 = tmp___60;
    }
  } else {
#line 359
    tmp___60 = __builtin_strcmp((char const   *)*(argv + num), "-aasamples");
#line 359
    tmp___61 = tmp___60;
  }
#line 359
  if (! tmp___61) {
#line 360
    sscanf((char const   * __restrict  )*(argv + (num + 1)), (char const   * __restrict  )"%d",
           & opt->aa_maxsamples);
#line 361
    return (2);
  }
#line 363
  if (0) {
#line 363
    __s1_len___8 = __builtin_strlen((char const   *)*(argv + num));
#line 363
    __s2_len___8 = __builtin_strlen("-V");
#line 363
    if (! ((size_t )((void const   *)(*(argv + num) + 1)) - (size_t )((void const   *)*(argv + num)) == 1UL)) {
#line 363
      goto _L___18;
    } else
#line 363
    if (__s1_len___8 >= 4UL) {
      _L___18: /* CIL Label */ 
#line 363
      if (! ((size_t )((void const   *)("-V" + 1)) - (size_t )((void const   *)"-V") == 1UL)) {
#line 363
        tmp___69 = 1;
      } else
#line 363
      if (__s2_len___8 >= 4UL) {
#line 363
        tmp___69 = 1;
      } else {
#line 363
        tmp___69 = 0;
      }
    } else {
#line 363
      tmp___69 = 0;
    }
#line 363
    if (tmp___69) {
#line 363
      tmp___64 = __builtin_strcmp((char const   *)*(argv + num), "-V");
#line 363
      tmp___68 = tmp___64;
    } else {
#line 363
      tmp___67 = __builtin_strcmp((char const   *)*(argv + num), "-V");
#line 363
      tmp___68 = tmp___67;
    }
  } else {
#line 363
    tmp___67 = __builtin_strcmp((char const   *)*(argv + num), "-V");
#line 363
    tmp___68 = tmp___67;
  }
#line 363
  if (! tmp___68) {
#line 365
    opt->verbosemode = 0;
#line 366
    return (1);
  }
#line 368
  if (0) {
#line 368
    __s1_len___9 = __builtin_strlen((char const   *)*(argv + num));
#line 368
    __s2_len___9 = __builtin_strlen("+V");
#line 368
    if (! ((size_t )((void const   *)(*(argv + num) + 1)) - (size_t )((void const   *)*(argv + num)) == 1UL)) {
#line 368
      goto _L___20;
    } else
#line 368
    if (__s1_len___9 >= 4UL) {
      _L___20: /* CIL Label */ 
#line 368
      if (! ((size_t )((void const   *)("+V" + 1)) - (size_t )((void const   *)"+V") == 1UL)) {
#line 368
        tmp___76 = 1;
      } else
#line 368
      if (__s2_len___9 >= 4UL) {
#line 368
        tmp___76 = 1;
      } else {
#line 368
        tmp___76 = 0;
      }
    } else {
#line 368
      tmp___76 = 0;
    }
#line 368
    if (tmp___76) {
#line 368
      tmp___71 = __builtin_strcmp((char const   *)*(argv + num), "+V");
#line 368
      tmp___75 = tmp___71;
    } else {
#line 368
      tmp___74 = __builtin_strcmp((char const   *)*(argv + num), "+V");
#line 368
      tmp___75 = tmp___74;
    }
  } else {
#line 368
    tmp___74 = __builtin_strcmp((char const   *)*(argv + num), "+V");
#line 368
    tmp___75 = tmp___74;
  }
#line 368
  if (! tmp___75) {
#line 370
    opt->verbosemode = 1;
#line 371
    return (1);
  }
#line 373
  if (0) {
#line 373
    __s1_len___10 = __builtin_strlen((char const   *)*(argv + num));
#line 373
    __s2_len___10 = __builtin_strlen("-nobounding");
#line 373
    if (! ((size_t )((void const   *)(*(argv + num) + 1)) - (size_t )((void const   *)*(argv + num)) == 1UL)) {
#line 373
      goto _L___22;
    } else
#line 373
    if (__s1_len___10 >= 4UL) {
      _L___22: /* CIL Label */ 
#line 373
      if (! ((size_t )((void const   *)("-nobounding" + 1)) - (size_t )((void const   *)"-nobounding") == 1UL)) {
#line 373
        tmp___83 = 1;
      } else
#line 373
      if (__s2_len___10 >= 4UL) {
#line 373
        tmp___83 = 1;
      } else {
#line 373
        tmp___83 = 0;
      }
    } else {
#line 373
      tmp___83 = 0;
    }
#line 373
    if (tmp___83) {
#line 373
      tmp___78 = __builtin_strcmp((char const   *)*(argv + num), "-nobounding");
#line 373
      tmp___82 = tmp___78;
    } else {
#line 373
      tmp___81 = __builtin_strcmp((char const   *)*(argv + num), "-nobounding");
#line 373
      tmp___82 = tmp___81;
    }
  } else {
#line 373
    tmp___81 = __builtin_strcmp((char const   *)*(argv + num), "-nobounding");
#line 373
    tmp___82 = tmp___81;
  }
#line 373
  if (! tmp___82) {
#line 375
    opt->boundmode = 0;
#line 376
    return (1);
  }
#line 378
  if (0) {
#line 378
    __s1_len___11 = __builtin_strlen((char const   *)*(argv + num));
#line 378
    __s2_len___11 = __builtin_strlen("-boundthresh");
#line 378
    if (! ((size_t )((void const   *)(*(argv + num) + 1)) - (size_t )((void const   *)*(argv + num)) == 1UL)) {
#line 378
      goto _L___24;
    } else
#line 378
    if (__s1_len___11 >= 4UL) {
      _L___24: /* CIL Label */ 
#line 378
      if (! ((size_t )((void const   *)("-boundthresh" + 1)) - (size_t )((void const   *)"-boundthresh") == 1UL)) {
#line 378
        tmp___90 = 1;
      } else
#line 378
      if (__s2_len___11 >= 4UL) {
#line 378
        tmp___90 = 1;
      } else {
#line 378
        tmp___90 = 0;
      }
    } else {
#line 378
      tmp___90 = 0;
    }
#line 378
    if (tmp___90) {
#line 378
      tmp___85 = __builtin_strcmp((char const   *)*(argv + num), "-boundthresh");
#line 378
      tmp___89 = tmp___85;
    } else {
#line 378
      tmp___88 = __builtin_strcmp((char const   *)*(argv + num), "-boundthresh");
#line 378
      tmp___89 = tmp___88;
    }
  } else {
#line 378
    tmp___88 = __builtin_strcmp((char const   *)*(argv + num), "-boundthresh");
#line 378
    tmp___89 = tmp___88;
  }
#line 378
  if (! tmp___89) {
#line 380
    sscanf((char const   * __restrict  )*(argv + (num + 1)), (char const   * __restrict  )"%d",
           & opt->boundthresh);
#line 381
    return (2);
  }
#line 383
  if (0) {
#line 383
    __s1_len___12 = __builtin_strlen((char const   *)*(argv + num));
#line 383
    __s2_len___12 = __builtin_strlen("-fullshade");
#line 383
    if (! ((size_t )((void const   *)(*(argv + num) + 1)) - (size_t )((void const   *)*(argv + num)) == 1UL)) {
#line 383
      goto _L___26;
    } else
#line 383
    if (__s1_len___12 >= 4UL) {
      _L___26: /* CIL Label */ 
#line 383
      if (! ((size_t )((void const   *)("-fullshade" + 1)) - (size_t )((void const   *)"-fullshade") == 1UL)) {
#line 383
        tmp___97 = 1;
      } else
#line 383
      if (__s2_len___12 >= 4UL) {
#line 383
        tmp___97 = 1;
      } else {
#line 383
        tmp___97 = 0;
      }
    } else {
#line 383
      tmp___97 = 0;
    }
#line 383
    if (tmp___97) {
#line 383
      tmp___92 = __builtin_strcmp((char const   *)*(argv + num), "-fullshade");
#line 383
      tmp___96 = tmp___92;
    } else {
#line 383
      tmp___95 = __builtin_strcmp((char const   *)*(argv + num), "-fullshade");
#line 383
      tmp___96 = tmp___95;
    }
  } else {
#line 383
    tmp___95 = __builtin_strcmp((char const   *)*(argv + num), "-fullshade");
#line 383
    tmp___96 = tmp___95;
  }
#line 383
  if (! tmp___96) {
#line 384
    opt->shadermode = 5;
#line 385
    return (1);
  }
#line 387
  if (0) {
#line 387
    __s1_len___13 = __builtin_strlen((char const   *)*(argv + num));
#line 387
    __s2_len___13 = __builtin_strlen("-mediumshade");
#line 387
    if (! ((size_t )((void const   *)(*(argv + num) + 1)) - (size_t )((void const   *)*(argv + num)) == 1UL)) {
#line 387
      goto _L___28;
    } else
#line 387
    if (__s1_len___13 >= 4UL) {
      _L___28: /* CIL Label */ 
#line 387
      if (! ((size_t )((void const   *)("-mediumshade" + 1)) - (size_t )((void const   *)"-mediumshade") == 1UL)) {
#line 387
        tmp___104 = 1;
      } else
#line 387
      if (__s2_len___13 >= 4UL) {
#line 387
        tmp___104 = 1;
      } else {
#line 387
        tmp___104 = 0;
      }
    } else {
#line 387
      tmp___104 = 0;
    }
#line 387
    if (tmp___104) {
#line 387
      tmp___99 = __builtin_strcmp((char const   *)*(argv + num), "-mediumshade");
#line 387
      tmp___103 = tmp___99;
    } else {
#line 387
      tmp___102 = __builtin_strcmp((char const   *)*(argv + num), "-mediumshade");
#line 387
      tmp___103 = tmp___102;
    }
  } else {
#line 387
    tmp___102 = __builtin_strcmp((char const   *)*(argv + num), "-mediumshade");
#line 387
    tmp___103 = tmp___102;
  }
#line 387
  if (! tmp___103) {
#line 388
    opt->shadermode = 3;
#line 389
    return (1);
  }
#line 391
  if (0) {
#line 391
    __s1_len___14 = __builtin_strlen((char const   *)*(argv + num));
#line 391
    __s2_len___14 = __builtin_strlen("-lowshade");
#line 391
    if (! ((size_t )((void const   *)(*(argv + num) + 1)) - (size_t )((void const   *)*(argv + num)) == 1UL)) {
#line 391
      goto _L___30;
    } else
#line 391
    if (__s1_len___14 >= 4UL) {
      _L___30: /* CIL Label */ 
#line 391
      if (! ((size_t )((void const   *)("-lowshade" + 1)) - (size_t )((void const   *)"-lowshade") == 1UL)) {
#line 391
        tmp___111 = 1;
      } else
#line 391
      if (__s2_len___14 >= 4UL) {
#line 391
        tmp___111 = 1;
      } else {
#line 391
        tmp___111 = 0;
      }
    } else {
#line 391
      tmp___111 = 0;
    }
#line 391
    if (tmp___111) {
#line 391
      tmp___106 = __builtin_strcmp((char const   *)*(argv + num), "-lowshade");
#line 391
      tmp___110 = tmp___106;
    } else {
#line 391
      tmp___109 = __builtin_strcmp((char const   *)*(argv + num), "-lowshade");
#line 391
      tmp___110 = tmp___109;
    }
  } else {
#line 391
    tmp___109 = __builtin_strcmp((char const   *)*(argv + num), "-lowshade");
#line 391
    tmp___110 = tmp___109;
  }
#line 391
  if (! tmp___110) {
#line 392
    opt->shadermode = 2;
#line 393
    return (1);
  }
#line 395
  if (0) {
#line 395
    __s1_len___15 = __builtin_strlen((char const   *)*(argv + num));
#line 395
    __s2_len___15 = __builtin_strlen("-lowestshade");
#line 395
    if (! ((size_t )((void const   *)(*(argv + num) + 1)) - (size_t )((void const   *)*(argv + num)) == 1UL)) {
#line 395
      goto _L___32;
    } else
#line 395
    if (__s1_len___15 >= 4UL) {
      _L___32: /* CIL Label */ 
#line 395
      if (! ((size_t )((void const   *)("-lowestshade" + 1)) - (size_t )((void const   *)"-lowestshade") == 1UL)) {
#line 395
        tmp___118 = 1;
      } else
#line 395
      if (__s2_len___15 >= 4UL) {
#line 395
        tmp___118 = 1;
      } else {
#line 395
        tmp___118 = 0;
      }
    } else {
#line 395
      tmp___118 = 0;
    }
#line 395
    if (tmp___118) {
#line 395
      tmp___113 = __builtin_strcmp((char const   *)*(argv + num), "-lowestshade");
#line 395
      tmp___117 = tmp___113;
    } else {
#line 395
      tmp___116 = __builtin_strcmp((char const   *)*(argv + num), "-lowestshade");
#line 395
      tmp___117 = tmp___116;
    }
  } else {
#line 395
    tmp___116 = __builtin_strcmp((char const   *)*(argv + num), "-lowestshade");
#line 395
    tmp___117 = tmp___116;
  }
#line 395
  if (! tmp___117) {
#line 396
    opt->shadermode = 1;
#line 397
    return (1);
  }
#line 399
  if (0) {
#line 399
    __s1_len___16 = __builtin_strlen((char const   *)*(argv + num));
#line 399
    __s2_len___16 = __builtin_strlen("-rescale_lights");
#line 399
    if (! ((size_t )((void const   *)(*(argv + num) + 1)) - (size_t )((void const   *)*(argv + num)) == 1UL)) {
#line 399
      goto _L___34;
    } else
#line 399
    if (__s1_len___16 >= 4UL) {
      _L___34: /* CIL Label */ 
#line 399
      if (! ((size_t )((void const   *)("-rescale_lights" + 1)) - (size_t )((void const   *)"-rescale_lights") == 1UL)) {
#line 399
        tmp___125 = 1;
      } else
#line 399
      if (__s2_len___16 >= 4UL) {
#line 399
        tmp___125 = 1;
      } else {
#line 399
        tmp___125 = 0;
      }
    } else {
#line 399
      tmp___125 = 0;
    }
#line 399
    if (tmp___125) {
#line 399
      tmp___120 = __builtin_strcmp((char const   *)*(argv + num), "-rescale_lights");
#line 399
      tmp___124 = tmp___120;
    } else {
#line 399
      tmp___123 = __builtin_strcmp((char const   *)*(argv + num), "-rescale_lights");
#line 399
      tmp___124 = tmp___123;
    }
  } else {
#line 399
    tmp___123 = __builtin_strcmp((char const   *)*(argv + num), "-rescale_lights");
#line 399
    tmp___124 = tmp___123;
  }
#line 399
  if (! tmp___124) {
#line 400
    sscanf((char const   * __restrict  )*(argv + (num + 1)), (char const   * __restrict  )"%f",
           & opt->rescale_lights);
#line 401
    return (2);
  }
#line 403
  if (0) {
#line 403
    __s1_len___17 = __builtin_strlen((char const   *)*(argv + num));
#line 403
    __s2_len___17 = __builtin_strlen("-auto_skylight");
#line 403
    if (! ((size_t )((void const   *)(*(argv + num) + 1)) - (size_t )((void const   *)*(argv + num)) == 1UL)) {
#line 403
      goto _L___36;
    } else
#line 403
    if (__s1_len___17 >= 4UL) {
      _L___36: /* CIL Label */ 
#line 403
      if (! ((size_t )((void const   *)("-auto_skylight" + 1)) - (size_t )((void const   *)"-auto_skylight") == 1UL)) {
#line 403
        tmp___132 = 1;
      } else
#line 403
      if (__s2_len___17 >= 4UL) {
#line 403
        tmp___132 = 1;
      } else {
#line 403
        tmp___132 = 0;
      }
    } else {
#line 403
      tmp___132 = 0;
    }
#line 403
    if (tmp___132) {
#line 403
      tmp___127 = __builtin_strcmp((char const   *)*(argv + num), "-auto_skylight");
#line 403
      tmp___131 = tmp___127;
    } else {
#line 403
      tmp___130 = __builtin_strcmp((char const   *)*(argv + num), "-auto_skylight");
#line 403
      tmp___131 = tmp___130;
    }
  } else {
#line 403
    tmp___130 = __builtin_strcmp((char const   *)*(argv + num), "-auto_skylight");
#line 403
    tmp___131 = tmp___130;
  }
#line 403
  if (! tmp___131) {
#line 404
    sscanf((char const   * __restrict  )*(argv + (num + 1)), (char const   * __restrict  )"%f",
           & opt->auto_skylight);
#line 405
    return (2);
  }
#line 407
  if (0) {
#line 407
    __s1_len___18 = __builtin_strlen((char const   *)*(argv + num));
#line 407
    __s2_len___18 = __builtin_strlen("-add_skylight");
#line 407
    if (! ((size_t )((void const   *)(*(argv + num) + 1)) - (size_t )((void const   *)*(argv + num)) == 1UL)) {
#line 407
      goto _L___38;
    } else
#line 407
    if (__s1_len___18 >= 4UL) {
      _L___38: /* CIL Label */ 
#line 407
      if (! ((size_t )((void const   *)("-add_skylight" + 1)) - (size_t )((void const   *)"-add_skylight") == 1UL)) {
#line 407
        tmp___139 = 1;
      } else
#line 407
      if (__s2_len___18 >= 4UL) {
#line 407
        tmp___139 = 1;
      } else {
#line 407
        tmp___139 = 0;
      }
    } else {
#line 407
      tmp___139 = 0;
    }
#line 407
    if (tmp___139) {
#line 407
      tmp___134 = __builtin_strcmp((char const   *)*(argv + num), "-add_skylight");
#line 407
      tmp___138 = tmp___134;
    } else {
#line 407
      tmp___137 = __builtin_strcmp((char const   *)*(argv + num), "-add_skylight");
#line 407
      tmp___138 = tmp___137;
    }
  } else {
#line 407
    tmp___137 = __builtin_strcmp((char const   *)*(argv + num), "-add_skylight");
#line 407
    tmp___138 = tmp___137;
  }
#line 407
  if (! tmp___138) {
#line 408
    sscanf((char const   * __restrict  )*(argv + (num + 1)), (char const   * __restrict  )"%f",
           & opt->add_skylight);
#line 409
    return (2);
  }
#line 411
  if (0) {
#line 411
    __s1_len___19 = __builtin_strlen((char const   *)*(argv + num));
#line 411
    __s2_len___19 = __builtin_strlen("-skylight_samples");
#line 411
    if (! ((size_t )((void const   *)(*(argv + num) + 1)) - (size_t )((void const   *)*(argv + num)) == 1UL)) {
#line 411
      goto _L___40;
    } else
#line 411
    if (__s1_len___19 >= 4UL) {
      _L___40: /* CIL Label */ 
#line 411
      if (! ((size_t )((void const   *)("-skylight_samples" + 1)) - (size_t )((void const   *)"-skylight_samples") == 1UL)) {
#line 411
        tmp___146 = 1;
      } else
#line 411
      if (__s2_len___19 >= 4UL) {
#line 411
        tmp___146 = 1;
      } else {
#line 411
        tmp___146 = 0;
      }
    } else {
#line 411
      tmp___146 = 0;
    }
#line 411
    if (tmp___146) {
#line 411
      tmp___141 = __builtin_strcmp((char const   *)*(argv + num), "-skylight_samples");
#line 411
      tmp___145 = tmp___141;
    } else {
#line 411
      tmp___144 = __builtin_strcmp((char const   *)*(argv + num), "-skylight_samples");
#line 411
      tmp___145 = tmp___144;
    }
  } else {
#line 411
    tmp___144 = __builtin_strcmp((char const   *)*(argv + num), "-skylight_samples");
#line 411
    tmp___145 = tmp___144;
  }
#line 411
  if (! tmp___145) {
#line 412
    sscanf((char const   * __restrict  )*(argv + (num + 1)), (char const   * __restrict  )"%d",
           & opt->skylight_samples);
#line 413
    return (2);
  }
#line 415
  if (0) {
#line 415
    __s1_len___20 = __builtin_strlen((char const   *)*(argv + num));
#line 415
    __s2_len___20 = __builtin_strlen("-shade_phong");
#line 415
    if (! ((size_t )((void const   *)(*(argv + num) + 1)) - (size_t )((void const   *)*(argv + num)) == 1UL)) {
#line 415
      goto _L___42;
    } else
#line 415
    if (__s1_len___20 >= 4UL) {
      _L___42: /* CIL Label */ 
#line 415
      if (! ((size_t )((void const   *)("-shade_phong" + 1)) - (size_t )((void const   *)"-shade_phong") == 1UL)) {
#line 415
        tmp___153 = 1;
      } else
#line 415
      if (__s2_len___20 >= 4UL) {
#line 415
        tmp___153 = 1;
      } else {
#line 415
        tmp___153 = 0;
      }
    } else {
#line 415
      tmp___153 = 0;
    }
#line 415
    if (tmp___153) {
#line 415
      tmp___148 = __builtin_strcmp((char const   *)*(argv + num), "-shade_phong");
#line 415
      tmp___152 = tmp___148;
    } else {
#line 415
      tmp___151 = __builtin_strcmp((char const   *)*(argv + num), "-shade_phong");
#line 415
      tmp___152 = tmp___151;
    }
  } else {
#line 415
    tmp___151 = __builtin_strcmp((char const   *)*(argv + num), "-shade_phong");
#line 415
    tmp___152 = tmp___151;
  }
#line 415
  if (! tmp___152) {
#line 416
    opt->phongfunc = 3;
#line 417
    return (1);
  }
#line 419
  if (0) {
#line 419
    __s1_len___21 = __builtin_strlen((char const   *)*(argv + num));
#line 419
    __s2_len___21 = __builtin_strlen("-shade_blinn");
#line 419
    if (! ((size_t )((void const   *)(*(argv + num) + 1)) - (size_t )((void const   *)*(argv + num)) == 1UL)) {
#line 419
      goto _L___44;
    } else
#line 419
    if (__s1_len___21 >= 4UL) {
      _L___44: /* CIL Label */ 
#line 419
      if (! ((size_t )((void const   *)("-shade_blinn" + 1)) - (size_t )((void const   *)"-shade_blinn") == 1UL)) {
#line 419
        tmp___160 = 1;
      } else
#line 419
      if (__s2_len___21 >= 4UL) {
#line 419
        tmp___160 = 1;
      } else {
#line 419
        tmp___160 = 0;
      }
    } else {
#line 419
      tmp___160 = 0;
    }
#line 419
    if (tmp___160) {
#line 419
      tmp___155 = __builtin_strcmp((char const   *)*(argv + num), "-shade_blinn");
#line 419
      tmp___159 = tmp___155;
    } else {
#line 419
      tmp___158 = __builtin_strcmp((char const   *)*(argv + num), "-shade_blinn");
#line 419
      tmp___159 = tmp___158;
    }
  } else {
#line 419
    tmp___158 = __builtin_strcmp((char const   *)*(argv + num), "-shade_blinn");
#line 419
    tmp___159 = tmp___158;
  }
#line 419
  if (! tmp___159) {
#line 420
    opt->phongfunc = 2;
#line 421
    return (1);
  }
#line 423
  if (0) {
#line 423
    __s1_len___22 = __builtin_strlen((char const   *)*(argv + num));
#line 423
    __s2_len___22 = __builtin_strlen("-shade_blinn_fast");
#line 423
    if (! ((size_t )((void const   *)(*(argv + num) + 1)) - (size_t )((void const   *)*(argv + num)) == 1UL)) {
#line 423
      goto _L___46;
    } else
#line 423
    if (__s1_len___22 >= 4UL) {
      _L___46: /* CIL Label */ 
#line 423
      if (! ((size_t )((void const   *)("-shade_blinn_fast" + 1)) - (size_t )((void const   *)"-shade_blinn_fast") == 1UL)) {
#line 423
        tmp___167 = 1;
      } else
#line 423
      if (__s2_len___22 >= 4UL) {
#line 423
        tmp___167 = 1;
      } else {
#line 423
        tmp___167 = 0;
      }
    } else {
#line 423
      tmp___167 = 0;
    }
#line 423
    if (tmp___167) {
#line 423
      tmp___162 = __builtin_strcmp((char const   *)*(argv + num), "-shade_blinn_fast");
#line 423
      tmp___166 = tmp___162;
    } else {
#line 423
      tmp___165 = __builtin_strcmp((char const   *)*(argv + num), "-shade_blinn_fast");
#line 423
      tmp___166 = tmp___165;
    }
  } else {
#line 423
    tmp___165 = __builtin_strcmp((char const   *)*(argv + num), "-shade_blinn_fast");
#line 423
    tmp___166 = tmp___165;
  }
#line 423
  if (! tmp___166) {
#line 424
    opt->phongfunc = 1;
#line 425
    return (1);
  }
#line 427
  if (0) {
#line 427
    __s1_len___23 = __builtin_strlen((char const   *)*(argv + num));
#line 427
    __s2_len___23 = __builtin_strlen("-shade_nullphong");
#line 427
    if (! ((size_t )((void const   *)(*(argv + num) + 1)) - (size_t )((void const   *)*(argv + num)) == 1UL)) {
#line 427
      goto _L___48;
    } else
#line 427
    if (__s1_len___23 >= 4UL) {
      _L___48: /* CIL Label */ 
#line 427
      if (! ((size_t )((void const   *)("-shade_nullphong" + 1)) - (size_t )((void const   *)"-shade_nullphong") == 1UL)) {
#line 427
        tmp___174 = 1;
      } else
#line 427
      if (__s2_len___23 >= 4UL) {
#line 427
        tmp___174 = 1;
      } else {
#line 427
        tmp___174 = 0;
      }
    } else {
#line 427
      tmp___174 = 0;
    }
#line 427
    if (tmp___174) {
#line 427
      tmp___169 = __builtin_strcmp((char const   *)*(argv + num), "-shade_nullphong");
#line 427
      tmp___173 = tmp___169;
    } else {
#line 427
      tmp___172 = __builtin_strcmp((char const   *)*(argv + num), "-shade_nullphong");
#line 427
      tmp___173 = tmp___172;
    }
  } else {
#line 427
    tmp___172 = __builtin_strcmp((char const   *)*(argv + num), "-shade_nullphong");
#line 427
    tmp___173 = tmp___172;
  }
#line 427
  if (! tmp___173) {
#line 428
    opt->phongfunc = 0;
#line 429
    return (1);
  }
#line 431
  if (0) {
#line 431
    __s1_len___24 = __builtin_strlen((char const   *)*(argv + num));
#line 431
    __s2_len___24 = __builtin_strlen("-trans_orig");
#line 431
    if (! ((size_t )((void const   *)(*(argv + num) + 1)) - (size_t )((void const   *)*(argv + num)) == 1UL)) {
#line 431
      goto _L___50;
    } else
#line 431
    if (__s1_len___24 >= 4UL) {
      _L___50: /* CIL Label */ 
#line 431
      if (! ((size_t )((void const   *)("-trans_orig" + 1)) - (size_t )((void const   *)"-trans_orig") == 1UL)) {
#line 431
        tmp___181 = 1;
      } else
#line 431
      if (__s2_len___24 >= 4UL) {
#line 431
        tmp___181 = 1;
      } else {
#line 431
        tmp___181 = 0;
      }
    } else {
#line 431
      tmp___181 = 0;
    }
#line 431
    if (tmp___181) {
#line 431
      tmp___176 = __builtin_strcmp((char const   *)*(argv + num), "-trans_orig");
#line 431
      tmp___180 = tmp___176;
    } else {
#line 431
      tmp___179 = __builtin_strcmp((char const   *)*(argv + num), "-trans_orig");
#line 431
      tmp___180 = tmp___179;
    }
  } else {
#line 431
    tmp___179 = __builtin_strcmp((char const   *)*(argv + num), "-trans_orig");
#line 431
    tmp___180 = tmp___179;
  }
#line 431
  if (! tmp___180) {
#line 432
    opt->transmode = 0;
#line 433
    return (1);
  }
#line 435
  if (0) {
#line 435
    __s1_len___25 = __builtin_strlen((char const   *)*(argv + num));
#line 435
    __s2_len___25 = __builtin_strlen("-trans_vmd");
#line 435
    if (! ((size_t )((void const   *)(*(argv + num) + 1)) - (size_t )((void const   *)*(argv + num)) == 1UL)) {
#line 435
      goto _L___52;
    } else
#line 435
    if (__s1_len___25 >= 4UL) {
      _L___52: /* CIL Label */ 
#line 435
      if (! ((size_t )((void const   *)("-trans_vmd" + 1)) - (size_t )((void const   *)"-trans_vmd") == 1UL)) {
#line 435
        tmp___188 = 1;
      } else
#line 435
      if (__s2_len___25 >= 4UL) {
#line 435
        tmp___188 = 1;
      } else {
#line 435
        tmp___188 = 0;
      }
    } else {
#line 435
      tmp___188 = 0;
    }
#line 435
    if (tmp___188) {
#line 435
      tmp___183 = __builtin_strcmp((char const   *)*(argv + num), "-trans_vmd");
#line 435
      tmp___187 = tmp___183;
    } else {
#line 435
      tmp___186 = __builtin_strcmp((char const   *)*(argv + num), "-trans_vmd");
#line 435
      tmp___187 = tmp___186;
    }
  } else {
#line 435
    tmp___186 = __builtin_strcmp((char const   *)*(argv + num), "-trans_vmd");
#line 435
    tmp___187 = tmp___186;
  }
#line 435
  if (! tmp___187) {
#line 436
    opt->transmode = 1;
#line 437
    return (1);
  }
#line 439
  if (0) {
#line 439
    __s1_len___26 = __builtin_strlen((char const   *)*(argv + num));
#line 439
    __s2_len___26 = __builtin_strlen("-fog_normal");
#line 439
    if (! ((size_t )((void const   *)(*(argv + num) + 1)) - (size_t )((void const   *)*(argv + num)) == 1UL)) {
#line 439
      goto _L___54;
    } else
#line 439
    if (__s1_len___26 >= 4UL) {
      _L___54: /* CIL Label */ 
#line 439
      if (! ((size_t )((void const   *)("-fog_normal" + 1)) - (size_t )((void const   *)"-fog_normal") == 1UL)) {
#line 439
        tmp___195 = 1;
      } else
#line 439
      if (__s2_len___26 >= 4UL) {
#line 439
        tmp___195 = 1;
      } else {
#line 439
        tmp___195 = 0;
      }
    } else {
#line 439
      tmp___195 = 0;
    }
#line 439
    if (tmp___195) {
#line 439
      tmp___190 = __builtin_strcmp((char const   *)*(argv + num), "-fog_normal");
#line 439
      tmp___194 = tmp___190;
    } else {
#line 439
      tmp___193 = __builtin_strcmp((char const   *)*(argv + num), "-fog_normal");
#line 439
      tmp___194 = tmp___193;
    }
  } else {
#line 439
    tmp___193 = __builtin_strcmp((char const   *)*(argv + num), "-fog_normal");
#line 439
    tmp___194 = tmp___193;
  }
#line 439
  if (! tmp___194) {
#line 440
    opt->fogmode = 0;
#line 441
    return (1);
  }
#line 443
  if (0) {
#line 443
    __s1_len___27 = __builtin_strlen((char const   *)*(argv + num));
#line 443
    __s2_len___27 = __builtin_strlen("-fog_vmd");
#line 443
    if (! ((size_t )((void const   *)(*(argv + num) + 1)) - (size_t )((void const   *)*(argv + num)) == 1UL)) {
#line 443
      goto _L___56;
    } else
#line 443
    if (__s1_len___27 >= 4UL) {
      _L___56: /* CIL Label */ 
#line 443
      if (! ((size_t )((void const   *)("-fog_vmd" + 1)) - (size_t )((void const   *)"-fog_vmd") == 1UL)) {
#line 443
        tmp___202 = 1;
      } else
#line 443
      if (__s2_len___27 >= 4UL) {
#line 443
        tmp___202 = 1;
      } else {
#line 443
        tmp___202 = 0;
      }
    } else {
#line 443
      tmp___202 = 0;
    }
#line 443
    if (tmp___202) {
#line 443
      tmp___197 = __builtin_strcmp((char const   *)*(argv + num), "-fog_vmd");
#line 443
      tmp___201 = tmp___197;
    } else {
#line 443
      tmp___200 = __builtin_strcmp((char const   *)*(argv + num), "-fog_vmd");
#line 443
      tmp___201 = tmp___200;
    }
  } else {
#line 443
    tmp___200 = __builtin_strcmp((char const   *)*(argv + num), "-fog_vmd");
#line 443
    tmp___201 = tmp___200;
  }
#line 443
  if (! tmp___201) {
#line 444
    opt->fogmode = 1;
#line 445
    return (1);
  }
#line 447
  if (0) {
#line 447
    __s1_len___28 = __builtin_strlen((char const   *)*(argv + num));
#line 447
    __s2_len___28 = __builtin_strlen("-res");
#line 447
    if (! ((size_t )((void const   *)(*(argv + num) + 1)) - (size_t )((void const   *)*(argv + num)) == 1UL)) {
#line 447
      goto _L___58;
    } else
#line 447
    if (__s1_len___28 >= 4UL) {
      _L___58: /* CIL Label */ 
#line 447
      if (! ((size_t )((void const   *)("-res" + 1)) - (size_t )((void const   *)"-res") == 1UL)) {
#line 447
        tmp___209 = 1;
      } else
#line 447
      if (__s2_len___28 >= 4UL) {
#line 447
        tmp___209 = 1;
      } else {
#line 447
        tmp___209 = 0;
      }
    } else {
#line 447
      tmp___209 = 0;
    }
#line 447
    if (tmp___209) {
#line 447
      tmp___204 = __builtin_strcmp((char const   *)*(argv + num), "-res");
#line 447
      tmp___208 = tmp___204;
    } else {
#line 447
      tmp___207 = __builtin_strcmp((char const   *)*(argv + num), "-res");
#line 447
      tmp___208 = tmp___207;
    }
  } else {
#line 447
    tmp___207 = __builtin_strcmp((char const   *)*(argv + num), "-res");
#line 447
    tmp___208 = tmp___207;
  }
#line 447
  if (! tmp___208) {
#line 448
    sscanf((char const   * __restrict  )*(argv + (num + 1)), (char const   * __restrict  )"%d",
           & opt->xsize);
#line 449
    sscanf((char const   * __restrict  )*(argv + (num + 2)), (char const   * __restrict  )"%d",
           & opt->ysize);
#line 450
    return (3);
  }
#line 452
  if (0) {
#line 452
    __s1_len___29 = __builtin_strlen((char const   *)*(argv + num));
#line 452
    __s2_len___29 = __builtin_strlen("-cropoutputauto");
#line 452
    if (! ((size_t )((void const   *)(*(argv + num) + 1)) - (size_t )((void const   *)*(argv + num)) == 1UL)) {
#line 452
      goto _L___60;
    } else
#line 452
    if (__s1_len___29 >= 4UL) {
      _L___60: /* CIL Label */ 
#line 452
      if (! ((size_t )((void const   *)("-cropoutputauto" + 1)) - (size_t )((void const   *)"-cropoutputauto") == 1UL)) {
#line 452
        tmp___216 = 1;
      } else
#line 452
      if (__s2_len___29 >= 4UL) {
#line 452
        tmp___216 = 1;
      } else {
#line 452
        tmp___216 = 0;
      }
    } else {
#line 452
      tmp___216 = 0;
    }
#line 452
    if (tmp___216) {
#line 452
      tmp___211 = __builtin_strcmp((char const   *)*(argv + num), "-cropoutputauto");
#line 452
      tmp___215 = tmp___211;
    } else {
#line 452
      tmp___214 = __builtin_strcmp((char const   *)*(argv + num), "-cropoutputauto");
#line 452
      tmp___215 = tmp___214;
    }
  } else {
#line 452
    tmp___214 = __builtin_strcmp((char const   *)*(argv + num), "-cropoutputauto");
#line 452
    tmp___215 = tmp___214;
  }
#line 452
  if (! tmp___215) {
#line 453
    opt->cropmode = 2;
#line 454
    return (1);
  }
#line 456
  if (0) {
#line 456
    __s1_len___30 = __builtin_strlen((char const   *)*(argv + num));
#line 456
    __s2_len___30 = __builtin_strlen("-cropoutput");
#line 456
    if (! ((size_t )((void const   *)(*(argv + num) + 1)) - (size_t )((void const   *)*(argv + num)) == 1UL)) {
#line 456
      goto _L___62;
    } else
#line 456
    if (__s1_len___30 >= 4UL) {
      _L___62: /* CIL Label */ 
#line 456
      if (! ((size_t )((void const   *)("-cropoutput" + 1)) - (size_t )((void const   *)"-cropoutput") == 1UL)) {
#line 456
        tmp___223 = 1;
      } else
#line 456
      if (__s2_len___30 >= 4UL) {
#line 456
        tmp___223 = 1;
      } else {
#line 456
        tmp___223 = 0;
      }
    } else {
#line 456
      tmp___223 = 0;
    }
#line 456
    if (tmp___223) {
#line 456
      tmp___218 = __builtin_strcmp((char const   *)*(argv + num), "-cropoutput");
#line 456
      tmp___222 = tmp___218;
    } else {
#line 456
      tmp___221 = __builtin_strcmp((char const   *)*(argv + num), "-cropoutput");
#line 456
      tmp___222 = tmp___221;
    }
  } else {
#line 456
    tmp___221 = __builtin_strcmp((char const   *)*(argv + num), "-cropoutput");
#line 456
    tmp___222 = tmp___221;
  }
#line 456
  if (! tmp___222) {
#line 457
    opt->cropmode = 1;
#line 458
    sscanf((char const   * __restrict  )*(argv + (num + 1)), (char const   * __restrict  )"%d",
           & opt->cropxres);
#line 459
    sscanf((char const   * __restrict  )*(argv + (num + 2)), (char const   * __restrict  )"%d",
           & opt->cropyres);
#line 460
    sscanf((char const   * __restrict  )*(argv + (num + 3)), (char const   * __restrict  )"%d",
           & opt->cropxstart);
#line 461
    sscanf((char const   * __restrict  )*(argv + (num + 4)), (char const   * __restrict  )"%d",
           & opt->cropystart);
#line 462
    return (5);
  }
#line 464
  if (0) {
#line 464
    __s1_len___31 = __builtin_strlen((char const   *)*(argv + num));
#line 464
    __s2_len___31 = __builtin_strlen("-clamp");
#line 464
    if (! ((size_t )((void const   *)(*(argv + num) + 1)) - (size_t )((void const   *)*(argv + num)) == 1UL)) {
#line 464
      goto _L___64;
    } else
#line 464
    if (__s1_len___31 >= 4UL) {
      _L___64: /* CIL Label */ 
#line 464
      if (! ((size_t )((void const   *)("-clamp" + 1)) - (size_t )((void const   *)"-clamp") == 1UL)) {
#line 464
        tmp___230 = 1;
      } else
#line 464
      if (__s2_len___31 >= 4UL) {
#line 464
        tmp___230 = 1;
      } else {
#line 464
        tmp___230 = 0;
      }
    } else {
#line 464
      tmp___230 = 0;
    }
#line 464
    if (tmp___230) {
#line 464
      tmp___225 = __builtin_strcmp((char const   *)*(argv + num), "-clamp");
#line 464
      tmp___229 = tmp___225;
    } else {
#line 464
      tmp___228 = __builtin_strcmp((char const   *)*(argv + num), "-clamp");
#line 464
      tmp___229 = tmp___228;
    }
  } else {
#line 464
    tmp___228 = __builtin_strcmp((char const   *)*(argv + num), "-clamp");
#line 464
    tmp___229 = tmp___228;
  }
#line 464
  if (! tmp___229) {
#line 465
    opt->imgprocess = 0;
#line 466
    return (1);
  }
#line 468
  if (0) {
#line 468
    __s1_len___32 = __builtin_strlen((char const   *)*(argv + num));
#line 468
    __s2_len___32 = __builtin_strlen("-normalize");
#line 468
    if (! ((size_t )((void const   *)(*(argv + num) + 1)) - (size_t )((void const   *)*(argv + num)) == 1UL)) {
#line 468
      goto _L___66;
    } else
#line 468
    if (__s1_len___32 >= 4UL) {
      _L___66: /* CIL Label */ 
#line 468
      if (! ((size_t )((void const   *)("-normalize" + 1)) - (size_t )((void const   *)"-normalize") == 1UL)) {
#line 468
        tmp___237 = 1;
      } else
#line 468
      if (__s2_len___32 >= 4UL) {
#line 468
        tmp___237 = 1;
      } else {
#line 468
        tmp___237 = 0;
      }
    } else {
#line 468
      tmp___237 = 0;
    }
#line 468
    if (tmp___237) {
#line 468
      tmp___232 = __builtin_strcmp((char const   *)*(argv + num), "-normalize");
#line 468
      tmp___236 = tmp___232;
    } else {
#line 468
      tmp___235 = __builtin_strcmp((char const   *)*(argv + num), "-normalize");
#line 468
      tmp___236 = tmp___235;
    }
  } else {
#line 468
    tmp___235 = __builtin_strcmp((char const   *)*(argv + num), "-normalize");
#line 468
    tmp___236 = tmp___235;
  }
#line 468
  if (! tmp___236) {
#line 469
    opt->imgprocess = 1;
#line 470
    return (1);
  }
#line 472
  if (0) {
#line 472
    __s1_len___33 = __builtin_strlen((char const   *)*(argv + num));
#line 472
    __s2_len___33 = __builtin_strlen("-gamma");
#line 472
    if (! ((size_t )((void const   *)(*(argv + num) + 1)) - (size_t )((void const   *)*(argv + num)) == 1UL)) {
#line 472
      goto _L___68;
    } else
#line 472
    if (__s1_len___33 >= 4UL) {
      _L___68: /* CIL Label */ 
#line 472
      if (! ((size_t )((void const   *)("-gamma" + 1)) - (size_t )((void const   *)"-gamma") == 1UL)) {
#line 472
        tmp___244 = 1;
      } else
#line 472
      if (__s2_len___33 >= 4UL) {
#line 472
        tmp___244 = 1;
      } else {
#line 472
        tmp___244 = 0;
      }
    } else {
#line 472
      tmp___244 = 0;
    }
#line 472
    if (tmp___244) {
#line 472
      tmp___239 = __builtin_strcmp((char const   *)*(argv + num), "-gamma");
#line 472
      tmp___243 = tmp___239;
    } else {
#line 472
      tmp___242 = __builtin_strcmp((char const   *)*(argv + num), "-gamma");
#line 472
      tmp___243 = tmp___242;
    }
  } else {
#line 472
    tmp___242 = __builtin_strcmp((char const   *)*(argv + num), "-gamma");
#line 472
    tmp___243 = tmp___242;
  }
#line 472
  if (! tmp___243) {
#line 473
    opt->imgprocess = 2;
#line 474
    sscanf((char const   * __restrict  )*(argv + (num + 1)), (char const   * __restrict  )"%f",
           & opt->imggamma);
#line 475
    return (2);
  }
#line 477
  if (0) {
#line 477
    __s1_len___34 = __builtin_strlen((char const   *)*(argv + num));
#line 477
    __s2_len___34 = __builtin_strlen("-format");
#line 477
    if (! ((size_t )((void const   *)(*(argv + num) + 1)) - (size_t )((void const   *)*(argv + num)) == 1UL)) {
#line 477
      goto _L___70;
    } else
#line 477
    if (__s1_len___34 >= 4UL) {
      _L___70: /* CIL Label */ 
#line 477
      if (! ((size_t )((void const   *)("-format" + 1)) - (size_t )((void const   *)"-format") == 1UL)) {
#line 477
        tmp___257 = 1;
      } else
#line 477
      if (__s2_len___34 >= 4UL) {
#line 477
        tmp___257 = 1;
      } else {
#line 477
        tmp___257 = 0;
      }
    } else {
#line 477
      tmp___257 = 0;
    }
#line 477
    if (tmp___257) {
#line 477
      tmp___252 = __builtin_strcmp((char const   *)*(argv + num), "-format");
#line 477
      tmp___256 = tmp___252;
    } else {
#line 477
      tmp___255 = __builtin_strcmp((char const   *)*(argv + num), "-format");
#line 477
      tmp___256 = tmp___255;
    }
  } else {
#line 477
    tmp___255 = __builtin_strcmp((char const   *)*(argv + num), "-format");
#line 477
    tmp___256 = tmp___255;
  }
#line 477
  if (! tmp___256) {
#line 479
    sscanf((char const   * __restrict  )*(argv + (num + 1)), (char const   * __restrict  )"%s",
           & str[0]);
#line 481
    tmp___250 = compare((char const   *)(str), "TARGA");
#line 481
    if (tmp___250) {
#line 483
      tmp___249 = compare((char const   *)(str), "BMP");
#line 483
      if (tmp___249) {
#line 485
        tmp___248 = compare((char const   *)(str), "PPM48");
#line 485
        if (tmp___248) {
#line 487
          tmp___247 = compare((char const   *)(str), "PPM");
#line 487
          if (tmp___247) {
#line 489
            tmp___246 = compare((char const   *)(str), "PSD48");
#line 489
            if (tmp___246) {
#line 491
              tmp___245 = compare((char const   *)(str), "RGB");
#line 491
              if (tmp___245) {
#line 502
                if (node == 0) {
#line 503
                  printf((char const   * __restrict  )"Unknown/Unsupported Image Format: %s, defaulting to Targa...\n",
                         str);
                }
              } else {
#line 492
                opt->outimageformat = 2;
              }
            } else {
#line 490
              opt->outimageformat = 7;
            }
          } else {
#line 488
            opt->outimageformat = 1;
          }
        } else {
#line 486
          opt->outimageformat = 6;
        }
      } else {
#line 484
        opt->outimageformat = 4;
      }
    } else {
#line 482
      opt->outimageformat = 0;
    }
#line 505
    return (2);
  }
#line 516
  if (node == 0) {
#line 517
    printf((char const   * __restrict  )"Unrecognized parameter/option flag: %s\n",
           *(argv + num));
  }
#line 519
  return (-1);
}
}
#line 522 "../demosrc/getargs.c"
int getargs(int argc , char **argv , argoptions *opt , int node ) 
{ 
  int i ;
  int rc ;
  void *tmp ;
  size_t tmp___0 ;
  void *tmp___1 ;

  {
#line 525
  if ((unsigned long )opt == (unsigned long )((void *)0)) {
#line 526
    return (-1);
  }
#line 528
  if (argc < 2) {
#line 529
    if (node == 0) {
#line 530
      printusage(argv);
    }
#line 532
    return (-1);
  }
#line 535
  initoptions(opt);
#line 537
  i = 1;
#line 538
  while (i < argc) {
#line 539
    if ((int )*(*(argv + i) + 0) == 45) {
#line 539
      goto _L;
    } else
#line 539
    if ((int )*(*(argv + i) + 0) == 43) {
      _L: /* CIL Label */ 
#line 540
      rc = getparm(argc, argv, i, opt, node);
#line 541
      if (rc != -1) {
#line 542
        i += rc;
      } else {
#line 545
        if (node == 0) {
#line 546
          printusage(argv);
        }
#line 548
        return (-1);
      }
    } else {
#line 552
      tmp = realloc((void *)opt->filenames, sizeof(char *) * (unsigned long )(opt->numfiles + 10));
#line 552
      opt->filenames = (char **)tmp;
#line 553
      tmp___0 = strlen((char const   *)*(argv + i));
#line 553
      tmp___1 = malloc(sizeof(char ) * tmp___0 + 1UL);
#line 553
      *(opt->filenames + opt->numfiles) = (char *)tmp___1;
#line 555
      strcpy((char * __restrict  )*(opt->filenames + opt->numfiles), (char const   * __restrict  )*(argv + i));
#line 565
      (opt->numfiles) ++;
#line 566
      i ++;
    }
  }
#line 570
  if (opt->numfiles == 0) {
#line 571
    if (node == 0) {
#line 572
      printf((char const   * __restrict  )"Missing model file name!\n");
#line 573
      printusage(argv);
    }
#line 575
    return (-1);
  }
#line 578
  return (0);
}
}
#line 581 "../demosrc/getargs.c"
void freeoptions(argoptions *opt ) 
{ 
  int i ;

  {
#line 582
  if ((unsigned long )opt->filenames != (unsigned long )((void *)0)) {
#line 585
    i = 0;
#line 585
    while (i < opt->numfiles) {
#line 586
      if ((unsigned long )*(opt->filenames + i) != (unsigned long )((void *)0)) {
#line 587
        free((void *)*(opt->filenames + i));
      }
#line 585
      i ++;
    }
#line 590
    free((void *)opt->filenames);
  }
#line 592
  return;
}
}
#line 1 "parse.o"
#pragma merger("0","/tmp/cil-SkQ1aEXL.i","-m64,-Wall,-O3,-fomit-frame-pointer,-ffast-math")
#line 531 "/usr/include/stdio.h"
extern int fgetc(FILE *__stream ) ;
#line 749
extern int fseek(FILE *__stream , long __off , int __whence ) ;
#line 754
extern long ( __attribute__((__warn_unused_result__)) ftell)(FILE *__stream ) ;
#line 63 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h"
extern  __attribute__((__nothrow__)) double ( __attribute__((__leaf__)) cos)(double __x ) ;
#line 65
extern  __attribute__((__nothrow__)) double ( __attribute__((__leaf__)) sin)(double __x ) ;
#line 252
__inline extern  __attribute__((__nothrow__)) double ( __attribute__((__leaf__, __always_inline__)) lgamma)(double __d ) ;
#line 259
__inline extern  __attribute__((__nothrow__)) double ( __attribute__((__leaf__, __always_inline__)) tgamma)(double __d ) ;
#line 265
__inline extern  __attribute__((__nothrow__)) double ( __attribute__((__leaf__, __always_inline__)) gamma)(double __d ) ;
#line 272
extern  __attribute__((__nothrow__)) double ( __attribute__((__leaf__)) lgamma_r)(double  ,
                                                                                  int *__signgamp )  __asm__("__lgamma_r_finite")  ;
#line 350
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__, __always_inline__)) __signbit)(double __x )  __attribute__((__const__)) ;
#line 252
__inline extern  __attribute__((__nothrow__)) float ( __attribute__((__leaf__, __always_inline__)) lgammaf)(float __d ) ;
#line 259
__inline extern  __attribute__((__nothrow__)) float ( __attribute__((__leaf__, __always_inline__)) tgammaf)(float __d ) ;
#line 265
__inline extern  __attribute__((__nothrow__)) float ( __attribute__((__leaf__, __always_inline__)) gammaf)(float __d ) ;
#line 272
extern  __attribute__((__nothrow__)) float ( __attribute__((__leaf__)) lgammaf_r)(float  ,
                                                                                  int *__signgamp )  __asm__("__lgammaf_r_finite")  ;
#line 350
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__, __always_inline__)) __signbitf)(float __x )  __attribute__((__const__)) ;
#line 252
__inline extern  __attribute__((__nothrow__)) long double ( __attribute__((__leaf__,
__always_inline__)) lgammal)(long double __d ) ;
#line 259
__inline extern  __attribute__((__nothrow__)) long double ( __attribute__((__leaf__,
__always_inline__)) tgammal)(long double __d ) ;
#line 265
__inline extern  __attribute__((__nothrow__)) long double ( __attribute__((__leaf__,
__always_inline__)) gammal)(long double __d ) ;
#line 272
extern  __attribute__((__nothrow__)) long double ( __attribute__((__leaf__)) lgammal_r)(long double  ,
                                                                                        int *__signgamp )  __asm__("__lgammal_r_finite")  ;
#line 350
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__, __always_inline__)) __signbitl)(long double __x )  __attribute__((__const__)) ;
#line 126 "/usr/include/x86_64-linux-gnu/bits/mathinline.h"
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__, __always_inline__)) __signbitf)(float __x )  __attribute__((__const__)) ;
#line 126 "/usr/include/x86_64-linux-gnu/bits/mathinline.h"
__inline extern int ( __attribute__((__leaf__, __always_inline__)) __signbitf)(float __x ) 
{ 
  int __m ;

  {
#line 131
  __asm__  ("pmovmskb %1, %0": "=r" (__m): "x" (__x));
#line 132
  return ((__m & 8) != 0);
}
}
#line 138
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__, __always_inline__)) __signbit)(double __x )  __attribute__((__const__)) ;
#line 138 "/usr/include/x86_64-linux-gnu/bits/mathinline.h"
__inline extern int ( __attribute__((__leaf__, __always_inline__)) __signbit)(double __x ) 
{ 
  int __m ;

  {
#line 143
  __asm__  ("pmovmskb %1, %0": "=r" (__m): "x" (__x));
#line 144
  return ((__m & 128) != 0);
}
}
#line 150
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__, __always_inline__)) __signbitl)(long double __x )  __attribute__((__const__)) ;
#line 150 "/usr/include/x86_64-linux-gnu/bits/mathinline.h"
__inline extern int ( __attribute__((__leaf__, __always_inline__)) __signbitl)(long double __x ) 
{ 
  union __anonunion___u_8 __u ;

  {
#line 153
  __u.__l = __x;
#line 154
  return ((__u.__i[2] & 32768) != 0);
}
}
#line 256 "/usr/include/x86_64-linux-gnu/bits/math-finite.h"
__inline extern  __attribute__((__nothrow__)) double ( __attribute__((__leaf__, __always_inline__)) lgamma)(double __d ) ;
#line 256 "/usr/include/x86_64-linux-gnu/bits/math-finite.h"
__inline extern double ( __attribute__((__leaf__, __always_inline__)) lgamma)(double __d ) 
{ 
  int __local_signgam ;
  double tmp ;

  {
#line 259
  __local_signgam = 0;
#line 260
  tmp = lgamma_r(__d, & __local_signgam);
#line 260
  return (tmp);
}
}
#line 265
__inline extern  __attribute__((__nothrow__)) float ( __attribute__((__leaf__, __always_inline__)) lgammaf)(float __d ) ;
#line 265 "/usr/include/x86_64-linux-gnu/bits/math-finite.h"
__inline extern float ( __attribute__((__leaf__, __always_inline__)) lgammaf)(float __d ) 
{ 
  int __local_signgam ;
  float tmp ;

  {
#line 268
  __local_signgam = 0;
#line 269
  tmp = lgammaf_r(__d, & __local_signgam);
#line 269
  return (tmp);
}
}
#line 275
__inline extern  __attribute__((__nothrow__)) long double ( __attribute__((__leaf__,
__always_inline__)) lgammal)(long double __d ) ;
#line 275 "/usr/include/x86_64-linux-gnu/bits/math-finite.h"
__inline extern long double ( __attribute__((__leaf__, __always_inline__)) lgammal)(long double __d ) 
{ 
  int __local_signgam ;
  long double tmp ;

  {
#line 278
  __local_signgam = 0;
#line 279
  tmp = lgammal_r(__d, & __local_signgam);
#line 279
  return (tmp);
}
}
#line 427
extern double __gamma_r_finite(double  , int * ) ;
#line 428
__inline extern  __attribute__((__nothrow__)) double ( __attribute__((__leaf__, __always_inline__)) tgamma)(double __d ) ;
#line 428 "/usr/include/x86_64-linux-gnu/bits/math-finite.h"
__inline extern double ( __attribute__((__leaf__, __always_inline__)) tgamma)(double __d ) 
{ 
  int __local_signgam ;
  double __res ;
  double tmp ;
  double tmp___0 ;

  {
#line 430
  __local_signgam = 0;
#line 431
  tmp = __gamma_r_finite(__d, & __local_signgam);
#line 431
  __res = tmp;
#line 432
  if (__local_signgam < 0) {
#line 432
    tmp___0 = - __res;
  } else {
#line 432
    tmp___0 = __res;
  }
#line 432
  return (tmp___0);
}
}
#line 434
extern float __gammaf_r_finite(float  , int * ) ;
#line 435
__inline extern  __attribute__((__nothrow__)) float ( __attribute__((__leaf__, __always_inline__)) tgammaf)(float __d ) ;
#line 435 "/usr/include/x86_64-linux-gnu/bits/math-finite.h"
__inline extern float ( __attribute__((__leaf__, __always_inline__)) tgammaf)(float __d ) 
{ 
  int __local_signgam ;
  float __res ;
  float tmp ;
  float tmp___0 ;

  {
#line 437
  __local_signgam = 0;
#line 438
  tmp = __gammaf_r_finite(__d, & __local_signgam);
#line 438
  __res = tmp;
#line 439
  if (__local_signgam < 0) {
#line 439
    tmp___0 = - __res;
  } else {
#line 439
    tmp___0 = __res;
  }
#line 439
  return (tmp___0);
}
}
#line 442
extern long double __gammal_r_finite(long double  , int * ) ;
#line 443
__inline extern  __attribute__((__nothrow__)) long double ( __attribute__((__leaf__,
__always_inline__)) tgammal)(long double __d ) ;
#line 443 "/usr/include/x86_64-linux-gnu/bits/math-finite.h"
__inline extern long double ( __attribute__((__leaf__, __always_inline__)) tgammal)(long double __d ) 
{ 
  int __local_signgam ;
  long double __res ;
  long double tmp ;
  long double tmp___0 ;

  {
#line 445
  __local_signgam = 0;
#line 449
  tmp = __gammal_r_finite(__d, & __local_signgam);
#line 449
  __res = tmp;
#line 451
  if (__local_signgam < 0) {
#line 451
    tmp___0 = - __res;
  } else {
#line 451
    tmp___0 = __res;
  }
#line 451
  return (tmp___0);
}
}
#line 25 "../src/hash.h"
extern void rt_hash_init(rt_hash_t * , int  ) ;
#line 26
extern int rt_hash_lookup(rt_hash_t * , char const   * ) ;
#line 27
extern int rt_hash_insert(rt_hash_t * , char const   * , int  ) ;
#line 29
extern void rt_hash_destroy(rt_hash_t * ) ;
#line 59 "../src/tachyon.h"
extern apivector rt_vector(apiflt x , apiflt y , apiflt z ) ;
#line 60
extern apicolor rt_color(apiflt r , apiflt g , apiflt b ) ;
#line 214
extern void rt_background(SceneHandle  , apicolor  ) ;
#line 241
extern void rt_fog_mode(SceneHandle  , int  ) ;
#line 246
extern void rt_fog_parms(SceneHandle  , apicolor  , apiflt  , apiflt  , apiflt  ) ;
#line 301
extern void rt_camera_setup(SceneHandle  , apiflt  , apiflt  , int  , int  , apivector  ,
                            apivector  , apivector  ) ;
#line 307
extern void rt_camera_projection(SceneHandle  , int  ) ;
#line 312
extern void rt_camera_dof(SceneHandle voidscene , flt focallength , flt aperture ) ;
#line 327
extern void rt_camera_frustum(SceneHandle  , flt  , flt  , flt  , flt  ) ;
#line 340
extern void *rt_texture(SceneHandle  , apitexture * ) ;
#line 347
extern void rt_define_image(char const   * , int  , int  , int  , unsigned char * ) ;
#line 354
extern void *rt_texture_copy_vcstri(SceneHandle  , void *oldtex ) ;
#line 359
extern void *rt_light(SceneHandle  , void * , apivector  , apiflt  ) ;
#line 363
extern void *rt_directional_light(SceneHandle  , void * , apivector  ) ;
#line 367
extern void *rt_spotlight(SceneHandle  , void * , apivector  , apiflt  , apivector  ,
                          apiflt  , apiflt  ) ;
#line 371
extern void rt_light_attenuation(void * , apiflt  , apiflt  , apiflt  ) ;
#line 379
extern void rt_sphere(SceneHandle  , void * , apivector  , apiflt  ) ;
#line 382
extern void rt_scalarvol(SceneHandle  , void * , apivector  , apivector  , int  ,
                         int  , int  , char const   * , void * ) ;
#line 387
extern void rt_box(SceneHandle  , void * , apivector  , apivector  ) ;
#line 390
extern void rt_plane(SceneHandle  , void * , apivector  , apivector  ) ;
#line 393
extern void rt_ring(SceneHandle  , void * , apivector  , apivector  , apiflt  , apiflt  ) ;
#line 396
extern void rt_tri(SceneHandle  , void * , apivector  , apivector  , apivector  ) ;
#line 399
extern void rt_stri(SceneHandle  , void * , apivector  , apivector  , apivector  ,
                    apivector  , apivector  , apivector  ) ;
#line 403
extern void rt_vcstri(SceneHandle  , void * , apivector  , apivector  , apivector  ,
                      apivector  , apivector  , apivector  , apicolor  , apicolor  ,
                      apicolor  ) ;
#line 416
extern void rt_landscape(SceneHandle  , void * , int  , int  , apivector  , apiflt  ,
                         apiflt  ) ;
#line 421
extern void rt_cylinder(SceneHandle  , void * , apivector  , apivector  , apiflt  ) ;
#line 423
extern void rt_fcylinder(SceneHandle  , void * , apivector  , apivector  , apiflt  ) ;
#line 425
extern void rt_polycylinder(SceneHandle  , void * , apivector * , int  , apiflt  ) ;
#line 428
extern void rt_tex_phong(void *voidtex , apiflt phong , apiflt phongexp , int type ) ;
#line 430
extern void rt_tex_outline(void *voidtex , apiflt outline , apiflt outlinewidth ) ;
#line 433
extern void rt_clip_fv(SceneHandle  , int numplanes , float *planes ) ;
#line 435
extern void rt_clip_off(SceneHandle  ) ;
#line 44 "../demosrc/parse.h"
static void reset_tex_table(parsehandle *ph , SceneHandle scene ) ;
#line 45
static void free_tex_table(parsehandle *ph , SceneHandle scene ) ;
#line 46
static errcode add_texture(parsehandle *ph , void *tex , char const   *name ) ;
#line 47
static void *find_texture(parsehandle *ph , char const   *name ) ;
#line 50
static errcode GetString(parsehandle *ph , char const   *string ) ;
#line 51
static errcode GetScenedefs(parsehandle *ph , SceneHandle scene ) ;
#line 52
static errcode GetCamera(parsehandle *ph , SceneHandle scene ) ;
#line 53
static errcode GetColor(parsehandle *ph , apicolor *c1 ) ;
#line 55
static errcode GetVector(parsehandle *ph , apivector *v1 ) ;
#line 56
static errcode GetTexDef(parsehandle *ph , SceneHandle scene ) ;
#line 57
static errcode GetImageDef(parsehandle *ph , SceneHandle scene ) ;
#line 58
static errcode GetTexAlias(parsehandle *ph ) ;
#line 59
static errcode GetTexture(parsehandle *ph , SceneHandle scene , void **tex ) ;
#line 60
void *GetTexBody(parsehandle *ph , SceneHandle scene , int modeflag ) ;
#line 61
static errcode GetBackGnd(parsehandle *ph , SceneHandle scene ) ;
#line 62
static errcode GetFog(parsehandle *ph , SceneHandle scene ) ;
#line 63
static errcode GetCylinder(parsehandle *ph , SceneHandle scene ) ;
#line 64
static errcode GetFCylinder(parsehandle *ph , SceneHandle scene ) ;
#line 65
static errcode GetPolyCylinder(parsehandle *ph , SceneHandle scene ) ;
#line 66
static errcode GetSphere(parsehandle *ph , SceneHandle scene ) ;
#line 67
static errcode GetPlane(parsehandle *ph , SceneHandle scene ) ;
#line 68
static errcode GetRing(parsehandle *ph , SceneHandle scene ) ;
#line 69
static errcode GetBox(parsehandle *ph , SceneHandle scene ) ;
#line 70
static errcode GetVol(parsehandle *ph , SceneHandle scene ) ;
#line 71
static errcode GetTri(parsehandle *ph , SceneHandle scene ) ;
#line 72
static errcode GetSTri(parsehandle *ph , SceneHandle scene ) ;
#line 73
static errcode GetVCSTri(parsehandle *ph , SceneHandle scene ) ;
#line 74
static errcode GetVertexArray(parsehandle *ph , SceneHandle scene ) ;
#line 75
static errcode GetDirLight(parsehandle *ph , SceneHandle scene ) ;
#line 76
static errcode GetLight(parsehandle *ph , SceneHandle scene ) ;
#line 77
static errcode GetSkyLight(parsehandle *ph , SceneHandle scene ) ;
#line 78
static errcode GetSpotLight(parsehandle *ph , SceneHandle scene ) ;
#line 79
static errcode GetLandScape(parsehandle *ph , SceneHandle scene ) ;
#line 80
static errcode GetTPolyFile(parsehandle *ph , SceneHandle scene ) ;
#line 81
static errcode GetObject(parsehandle *ph , SceneHandle scene ) ;
#line 82
static errcode ReadIncludeFile(parsehandle *ph , char const   *includefile , SceneHandle scene ) ;
#line 83
static errcode GetClipGroup(parsehandle *ph , SceneHandle scene ) ;
#line 84
static errcode GetClipGroupEnd(parsehandle *ph , SceneHandle scene ) ;
#line 28 "../demosrc/parse.c"
static int stringcmp(char const   *a , char const   *b ) 
{ 
  int i ;
  int s ;
  int l ;
  size_t tmp ;
  size_t tmp___0 ;
  int __res ;
  __int32_t const   **tmp___2 ;

  {
#line 31
  tmp = strlen(a);
#line 31
  s = (int )tmp;
#line 32
  tmp___0 = strlen(b);
#line 32
  l = (int )tmp___0;
#line 34
  if (s != l) {
#line 35
    return (1);
  }
#line 37
  i = 0;
#line 37
  while (i < s) {
#line 38
    if (sizeof(*(a + i)) > 1UL) {
#line 38
      __res = toupper((int )*(a + i));
    } else {
#line 38
      tmp___2 = __ctype_toupper_loc();
#line 38
      __res = (int )*(*tmp___2 + (int )*(a + i));
    }
#line 38
    if (__res != (int )*(b + i)) {
#line 39
      return (1);
    }
#line 37
    i ++;
  }
#line 42
  return (0);
}
}
#line 45 "../demosrc/parse.c"
static void reset_tex_table(parsehandle *ph , SceneHandle scene ) 
{ 
  apitexture apitex ;
  void *tmp ;

  {
#line 48
  ph->maxtextures = 512;
#line 49
  ph->numtextures = 0;
#line 50
  tmp = malloc((unsigned long )ph->maxtextures * sizeof(texentry ));
#line 50
  ph->textable = (texentry *)tmp;
#line 51
  memset((void *)ph->textable, 0, (unsigned long )ph->maxtextures * sizeof(texentry ));
#line 53
  apitex.col.r = (float )1.0;
#line 54
  apitex.col.g = (float )1.0;
#line 55
  apitex.col.b = (float )1.0;
#line 56
  apitex.ambient = 0.1;
#line 57
  apitex.diffuse = 0.9;
#line 58
  apitex.specular = 0.0;
#line 59
  apitex.opacity = 1.0;
#line 60
  apitex.texturefunc = 0;
#line 62
  ph->defaulttex.tex = rt_texture(scene, & apitex);
#line 63
  rt_hash_init(& ph->texhash, 1024);
#line 64
  return;
}
}
#line 66 "../demosrc/parse.c"
static void free_tex_table(parsehandle *ph , SceneHandle scene ) 
{ 
  int i ;

  {
#line 69
  rt_hash_destroy(& ph->texhash);
#line 71
  i = 0;
#line 71
  while (i < ph->numtextures) {
#line 72
    free((void *)(ph->textable + i)->name);
#line 71
    i ++;
  }
#line 75
  free((void *)ph->textable);
#line 76
  ph->textable = (texentry *)((void *)0);
#line 78
  ph->numtextures = 0;
#line 79
  return;
}
}
#line 81 "../demosrc/parse.c"
static errcode add_texture(parsehandle *ph , void *tex , char const   *name ) 
{ 
  size_t tmp ;
  void *tmp___0 ;
  texentry *newblock ;
  int newsize ;
  void *tmp___1 ;

  {
#line 82
  (ph->textable + ph->numtextures)->tex = tex;
#line 83
  tmp = strlen(name);
#line 83
  tmp___0 = malloc(tmp + 1UL);
#line 83
  (ph->textable + ph->numtextures)->name = (char *)tmp___0;
#line 84
  strcpy((char * __restrict  )(ph->textable + ph->numtextures)->name, (char const   * __restrict  )name);
#line 85
  rt_hash_insert(& ph->texhash, (char const   *)(ph->textable + ph->numtextures)->name,
                 ph->numtextures);
#line 87
  (ph->numtextures) ++;
#line 88
  if (ph->numtextures >= ph->maxtextures) {
#line 92
    newsize = 2 * ph->maxtextures;
#line 93
    tmp___1 = realloc((void *)ph->textable, (unsigned long )newsize * sizeof(texentry ));
#line 93
    newblock = (texentry *)tmp___1;
#line 94
    if ((unsigned long )newblock != (unsigned long )((void *)0)) {
#line 95
      ph->maxtextures = newsize;
#line 96
      ph->textable = newblock;
#line 97
      return ((errcode )0);
    } else {
#line 99
      printf((char const   * __restrict  )"Parse: %d textures allocated, texture slots full!\n",
             ph->numtextures);
#line 100
      (ph->numtextures) --;
#line 101
      return ((errcode )16);
    }
  }
#line 105
  return ((errcode )0);
}
}
#line 108 "../demosrc/parse.c"
static void *find_texture(parsehandle *ph , char const   *name ) 
{ 
  int i ;

  {
#line 111
  i = rt_hash_lookup(& ph->texhash, name);
#line 112
  if (i != -1) {
#line 113
    return ((ph->textable + i)->tex);
  }
#line 116
  printf((char const   * __restrict  )"Undefined texture \'%s\', using default. \n",
         name);
#line 117
  return (ph->defaulttex.tex);
}
}
#line 120 "../demosrc/parse.c"
apiflt degtorad(apiflt deg ) 
{ 
  apiflt tmp ;

  {
#line 122
  tmp = (deg * 3.1415926) / 180.0;
#line 123
  return (tmp);
}
}
#line 126 "../demosrc/parse.c"
static void degvectoradvec(apivector *degvec ) 
{ 
  apivector tmp ;

  {
#line 129
  tmp.x = degtorad(degvec->x);
#line 130
  tmp.y = degtorad(degvec->y);
#line 131
  tmp.z = degtorad(degvec->z);
#line 132
  *degvec = tmp;
#line 133
  return;
}
}
#line 135 "../demosrc/parse.c"
static void InitRot3d(RotMat *rot , apiflt x , apiflt y , apiflt z ) 
{ 
  double tmp ;
  double tmp___0 ;
  double tmp___1 ;
  double tmp___2 ;
  double tmp___3 ;
  double tmp___4 ;
  double tmp___5 ;
  double tmp___6 ;
  double tmp___7 ;
  double tmp___8 ;
  double tmp___9 ;
  double tmp___10 ;
  double tmp___11 ;
  double tmp___12 ;
  double tmp___13 ;
  double tmp___14 ;
  double tmp___15 ;
  double tmp___16 ;
  double tmp___17 ;
  double tmp___18 ;
  double tmp___19 ;
  double tmp___20 ;
  double tmp___21 ;
  double tmp___22 ;
  double tmp___23 ;
  double tmp___24 ;
  double tmp___25 ;
  double tmp___26 ;

  {
#line 136
  tmp = cos(y);
#line 136
  tmp___0 = cos(z);
#line 136
  rot->rx1 = tmp * tmp___0;
#line 137
  tmp___1 = sin(x);
#line 137
  tmp___2 = sin(y);
#line 137
  tmp___3 = cos(z);
#line 137
  tmp___4 = cos(x);
#line 137
  tmp___5 = sin(z);
#line 137
  rot->rx2 = (tmp___1 * tmp___2) * tmp___3 - tmp___4 * tmp___5;
#line 138
  tmp___6 = sin(x);
#line 138
  tmp___7 = sin(z);
#line 138
  tmp___8 = cos(x);
#line 138
  tmp___9 = cos(z);
#line 138
  tmp___10 = sin(y);
#line 138
  rot->rx3 = tmp___6 * tmp___7 + (tmp___8 * tmp___9) * tmp___10;
#line 140
  tmp___11 = cos(y);
#line 140
  tmp___12 = sin(z);
#line 140
  rot->ry1 = tmp___11 * tmp___12;
#line 141
  tmp___13 = cos(x);
#line 141
  tmp___14 = cos(z);
#line 141
  tmp___15 = sin(x);
#line 141
  tmp___16 = sin(y);
#line 141
  tmp___17 = sin(z);
#line 141
  rot->ry2 = tmp___13 * tmp___14 + (tmp___15 * tmp___16) * tmp___17;
#line 142
  tmp___18 = cos(x);
#line 142
  tmp___19 = sin(y);
#line 142
  tmp___20 = sin(z);
#line 142
  tmp___21 = sin(x);
#line 142
  tmp___22 = cos(z);
#line 142
  rot->ry3 = (tmp___18 * tmp___19) * tmp___20 - tmp___21 * tmp___22;
#line 144
  rot->rz1 = sin(y);
#line 145
  tmp___23 = sin(x);
#line 145
  tmp___24 = cos(y);
#line 145
  rot->rz2 = tmp___23 * tmp___24;
#line 146
  tmp___25 = cos(x);
#line 146
  tmp___26 = cos(y);
#line 146
  rot->rz3 = tmp___25 * tmp___26;
#line 147
  return;
}
}
#line 149 "../demosrc/parse.c"
static void Rotate3d(RotMat *rot , apivector *vec ) 
{ 
  apivector tmp ;

  {
#line 151
  tmp.x = (vec->x * rot->rx1 + vec->y * rot->rx2) + vec->z * rot->rx3;
#line 152
  tmp.y = (vec->x * rot->ry1 + vec->y * rot->ry2) + vec->z * rot->ry3;
#line 153
  tmp.z = (vec->x * rot->rz1 + vec->y * rot->rz2) + vec->z * rot->rz3;
#line 154
  *vec = tmp;
#line 155
  return;
}
}
#line 157 "../demosrc/parse.c"
static void Scale3d(apivector *scale , apivector *vec ) 
{ 


  {
#line 158
  vec->x *= scale->x;
#line 159
  vec->y *= scale->y;
#line 160
  vec->z *= scale->z;
#line 161
  return;
}
}
#line 163 "../demosrc/parse.c"
static void Trans3d(apivector *trans , apivector *vec ) 
{ 


  {
#line 164
  vec->x += trans->x;
#line 165
  vec->y += trans->y;
#line 166
  vec->z += trans->z;
#line 167
  return;
}
}
#line 169 "../demosrc/parse.c"
static void PrintSyntaxError(parsehandle *ph , char const   *string , char const   *found ) 
{ 
  long streampos ;
  long readsize ;
  long i ;
  long j ;
  long linecount ;
  char cbuf[65536] ;

  {
#line 175
  streampos = ftell(ph->ifp);
#line 178
  fseek(ph->ifp, 0L, 0);
#line 180
  i = 0L;
#line 181
  linecount = 0L;
#line 182
  while (i < streampos) {
#line 183
    if (streampos - i > 65536L) {
#line 184
      readsize = 65536L;
    } else {
#line 186
      readsize = streampos - i;
    }
#line 189
    fread((void * __restrict  )(cbuf), (size_t )readsize, (size_t )1, (FILE * __restrict  )ph->ifp);
#line 190
    i += readsize;
#line 191
    j = 0L;
#line 191
    while (j < readsize) {
#line 192
      if ((int )cbuf[j] == 10) {
#line 193
        linecount ++;
      }
#line 191
      j ++;
    }
  }
#line 198
  printf((char const   * __restrict  )"Parse Error:\n");
#line 199
  printf((char const   * __restrict  )"   Encountered a syntax error in file %s\n",
         ph->filename);
#line 200
  printf((char const   * __restrict  )"   Expected to find %s\n", string);
#line 201
  printf((char const   * __restrict  )"   Actually found: %s\n", found);
#line 202
  printf((char const   * __restrict  )"   Error occured at or prior to file offset %ld, line %ld\n",
         streampos, linecount);
#line 204
  printf((char const   * __restrict  )"   Error position is only approximate, but should be close\n\n");
#line 206
  fseek(ph->ifp, streampos, 0);
#line 207
  return;
}
}
#line 209 "../demosrc/parse.c"
static errcode GetString(parsehandle *ph , char const   *string ) 
{ 
  char data[255] ;
  int tmp ;

  {
#line 212
  fscanf((FILE * __restrict  )ph->ifp, (char const   * __restrict  )"%s", data);
#line 213
  tmp = stringcmp((char const   *)(data), string);
#line 213
  if (tmp != 0) {
#line 214
    PrintSyntaxError(ph, string, (char const   *)(data));
#line 215
    return ((errcode )4);
  }
#line 218
  return ((errcode )0);
}
}
#line 221 "../demosrc/parse.c"
unsigned int readmodel(char const   *modelfile , SceneHandle scene ) 
{ 
  parsehandle ph ;
  errcode rc ;
  int done ;
  char tmp[256] ;
  int c ;
  int tmp___0 ;
  int tmp___1 ;
  errcode tmp___2 ;

  {
#line 226
  memset((void *)(& ph), 0, sizeof(ph));
#line 227
  ph.filename = modelfile;
#line 228
  ph.ifp = fopen((char const   * __restrict  )modelfile, (char const   * __restrict  )"r");
#line 229
  if ((unsigned long )ph.ifp == (unsigned long )((void *)0)) {
#line 230
    return (1U);
  }
#line 233
  reset_tex_table(& ph, scene);
#line 235
  rc = (errcode )0;
#line 238
  done = 0;
#line 239
  while (! done) {
#line 241
    fscanf((FILE * __restrict  )ph.ifp, (char const   * __restrict  )"%s", tmp);
#line 243
    tmp___1 = stringcmp((char const   *)(tmp), "BEGIN_SCENE");
#line 243
    if (tmp___1) {
#line 245
      tmp___0 = stringcmp((char const   *)(tmp), "#");
#line 245
      if (tmp___0) {
#line 253
        fclose(ph.ifp);
#line 254
        return (4U);
      } else {
#line 247
        while (1) {
#line 248
          c = fgetc(ph.ifp);
#line 249
          if (c == -1) {
#line 250
            break;
          } else
#line 249
          if (c == 10) {
#line 250
            break;
          }
        }
      }
    } else {
#line 244
      done = 1;
    }
  }
#line 258
  tmp___2 = GetScenedefs(& ph, scene);
#line 258
  rc |= tmp___2;
#line 260
  if (rc == 0U) {
#line 261
    ph.numobjectsparsed = 0;
#line 262
    while (1) {
#line 262
      rc = GetObject(& ph, scene);
#line 262
      if (! (rc == 0U)) {
#line 262
        break;
      }
#line 263
      (ph.numobjectsparsed) ++;
    }
#line 266
    if (rc == 8U) {
#line 267
      rc = (errcode )0;
    }
  }
#line 270
  fclose(ph.ifp);
#line 272
  free_tex_table(& ph, scene);
#line 274
  return (rc);
}
}
#line 277 "../demosrc/parse.c"
static errcode ReadIncludeFile(parsehandle *ph , char const   *includefile , SceneHandle scene ) 
{ 
  errcode rc ;
  char const   *oldfilename ;
  FILE *oldfp ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___0 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
#line 279
  oldfilename = ph->filename;
#line 280
  oldfp = ph->ifp;
#line 282
  if (0) {
#line 282
    __s1_len = __builtin_strlen(includefile);
#line 282
    __s2_len = __builtin_strlen(ph->filename);
#line 282
    if (! ((size_t )((void const   *)(includefile + 1)) - (size_t )((void const   *)includefile) == 1UL)) {
#line 282
      goto _L___0;
    } else
#line 282
    if (__s1_len >= 4UL) {
      _L___0: /* CIL Label */ 
#line 282
      if (! ((size_t )((void const   *)(ph->filename + 1)) - (size_t )((void const   *)ph->filename) == 1UL)) {
#line 282
        tmp___5 = 1;
      } else
#line 282
      if (__s2_len >= 4UL) {
#line 282
        tmp___5 = 1;
      } else {
#line 282
        tmp___5 = 0;
      }
    } else {
#line 282
      tmp___5 = 0;
    }
#line 282
    if (tmp___5) {
#line 282
      tmp___0 = __builtin_strcmp(includefile, ph->filename);
#line 282
      tmp___4 = tmp___0;
    } else {
#line 282
      tmp___3 = __builtin_strcmp(includefile, ph->filename);
#line 282
      tmp___4 = tmp___3;
    }
  } else {
#line 282
    tmp___3 = __builtin_strcmp(includefile, ph->filename);
#line 282
    tmp___4 = tmp___3;
  }
#line 282
  if (tmp___4 == 0) {
#line 283
    printf((char const   * __restrict  )"Warning: possible self-recursive include of file %s\n",
           includefile);
  }
#line 287
  ph->filename = includefile;
#line 288
  ph->ifp = fopen((char const   * __restrict  )includefile, (char const   * __restrict  )"r");
#line 289
  if ((unsigned long )ph->ifp == (unsigned long )((void *)0)) {
#line 290
    printf((char const   * __restrict  )"Parser failed trying to open file: %s\n",
           includefile);
#line 293
    ph->filename = oldfilename;
#line 294
    ph->ifp = oldfp;
#line 296
    return ((errcode )2);
  }
#line 299
  while (1) {
#line 299
    rc = GetObject(ph, scene);
#line 299
    if (! (rc == 0U)) {
#line 299
      break;
    }
#line 300
    (ph->numobjectsparsed) ++;
  }
#line 302
  fclose(ph->ifp);
#line 305
  ph->filename = oldfilename;
#line 306
  ph->ifp = oldfp;
#line 308
  if (rc == 8U) {
#line 309
    rc = (errcode )0;
  }
#line 312
  return (rc);
}
}
#line 315 "../demosrc/parse.c"
static errcode GetScenedefs(parsehandle *ph , SceneHandle scene ) 
{ 
  int xres ;
  int yres ;
  errcode rc ;
  errcode tmp ;

  {
#line 317
  rc = (errcode )0;
#line 319
  tmp = GetString(ph, "RESOLUTION");
#line 319
  rc |= tmp;
#line 320
  fscanf((FILE * __restrict  )ph->ifp, (char const   * __restrict  )"%d %d", & xres,
         & yres);
#line 322
  rt_outputfile(scene, "outfile.tga");
#line 323
  rt_resolution(scene, xres, yres);
#line 324
  rt_verbose(scene, 0);
#line 326
  return (rc);
}
}
#line 329 "../demosrc/parse.c"
static errcode GetShaderMode(parsehandle *ph , SceneHandle scene ) 
{ 
  errcode rc ;
  char data[255] ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int aosamples ;
  float aodirect ;
  apicolor aoambient ;
  errcode tmp___3 ;
  errcode tmp___4 ;
  errcode tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;

  {
#line 330
  rc = (errcode )0;
#line 333
  fscanf((FILE * __restrict  )ph->ifp, (char const   * __restrict  )"%s", data);
#line 334
  tmp___2 = stringcmp((char const   *)(data), "FULL");
#line 334
  if (tmp___2) {
#line 336
    tmp___1 = stringcmp((char const   *)(data), "MEDIUM");
#line 336
    if (tmp___1) {
#line 338
      tmp___0 = stringcmp((char const   *)(data), "LOW");
#line 338
      if (tmp___0) {
#line 340
        tmp = stringcmp((char const   *)(data), "LOWEST");
#line 340
        if (tmp) {
#line 343
          printf((char const   * __restrict  )"Bad token \'%s\' while reading shader mode block\n",
                 data);
#line 344
          return ((errcode )4);
        } else {
#line 341
          rt_shadermode(scene, 1);
        }
      } else {
#line 339
        rt_shadermode(scene, 2);
      }
    } else {
#line 337
      rt_shadermode(scene, 3);
    }
  } else {
#line 335
    rt_shadermode(scene, 5);
  }
#line 347
  while (rc == 0U) {
#line 348
    fscanf((FILE * __restrict  )ph->ifp, (char const   * __restrict  )"%s", data);
#line 349
    tmp___9 = stringcmp((char const   *)(data), "END_SHADER_MODE");
#line 349
    if (tmp___9) {
#line 351
      tmp___8 = stringcmp((char const   *)(data), "TRANS_VMD");
#line 351
      if (tmp___8) {
#line 353
        tmp___7 = stringcmp((char const   *)(data), "FOG_VMD");
#line 353
        if (tmp___7) {
#line 355
          tmp___6 = stringcmp((char const   *)(data), "AMBIENT_OCCLUSION");
#line 355
          if (tmp___6) {
#line 372
            printf((char const   * __restrict  )"Bad token \'%s\' while reading optional shader modes\n",
                   data);
#line 373
            return ((errcode )4);
          } else {
#line 360
            tmp___3 = GetString(ph, "AMBIENT_COLOR");
#line 360
            rc |= tmp___3;
#line 361
            fscanf((FILE * __restrict  )ph->ifp, (char const   * __restrict  )"%f %f %f",
                   & aoambient.r, & aoambient.g, & aoambient.b);
#line 363
            tmp___4 = GetString(ph, "RESCALE_DIRECT");
#line 363
            rc |= tmp___4;
#line 364
            fscanf((FILE * __restrict  )ph->ifp, (char const   * __restrict  )"%f",
                   & aodirect);
#line 366
            tmp___5 = GetString(ph, "SAMPLES");
#line 366
            rc |= tmp___5;
#line 367
            fscanf((FILE * __restrict  )ph->ifp, (char const   * __restrict  )"%d",
                   & aosamples);
#line 369
            rt_rescale_lights(scene, (apiflt )aodirect);
#line 370
            rt_ambient_occlusion(scene, aosamples, aoambient);
          }
        } else {
#line 354
          rt_fog_rendering_mode(scene, 1);
        }
      } else {
#line 352
        rt_trans_mode(scene, 1);
      }
    } else {
#line 350
      return (rc);
    }
  }
#line 377
  return (rc);
}
}
#line 380 "../demosrc/parse.c"
static errcode GetCamera(parsehandle *ph , SceneHandle scene ) 
{ 
  apivector Ccenter ;
  apivector Cview ;
  apivector Cup ;
  apiflt zoom ;
  apiflt aspectratio ;
  int raydepth ;
  int antialiasing ;
  float a ;
  float b ;
  float c ;
  float d ;
  errcode rc ;
  char data[255] ;
  errcode tmp ;
  errcode tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  errcode tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  errcode tmp___8 ;
  errcode tmp___9 ;
  errcode tmp___10 ;
  errcode tmp___11 ;
  errcode tmp___12 ;
  errcode tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;

  {
#line 385
  rc = (errcode )0;
#line 388
  fscanf((FILE * __restrict  )ph->ifp, (char const   * __restrict  )"%s", data);
#line 389
  tmp___7 = stringcmp((char const   *)(data), "PROJECTION");
#line 389
  if (tmp___7 == 0) {
#line 390
    fscanf((FILE * __restrict  )ph->ifp, (char const   * __restrict  )"%s", data);
#line 391
    tmp___4 = stringcmp((char const   *)(data), "FISHEYE");
#line 391
    if (tmp___4 == 0) {
#line 392
      rt_camera_projection(scene, 3);
    } else {
#line 393
      tmp___3 = stringcmp((char const   *)(data), "PERSPECTIVE");
#line 393
      if (tmp___3 == 0) {
#line 394
        rt_camera_projection(scene, 0);
      } else {
#line 395
        tmp___2 = stringcmp((char const   *)(data), "PERSPECTIVE_DOF");
#line 395
        if (tmp___2 == 0) {
#line 396
          rt_camera_projection(scene, 2);
#line 398
          tmp = GetString(ph, "FOCALLENGTH");
#line 398
          rc |= tmp;
#line 399
          fscanf((FILE * __restrict  )ph->ifp, (char const   * __restrict  )"%f",
                 & a);
#line 401
          tmp___0 = GetString(ph, "APERTURE");
#line 401
          rc |= tmp___0;
#line 402
          fscanf((FILE * __restrict  )ph->ifp, (char const   * __restrict  )"%f",
                 & b);
#line 404
          rt_camera_dof(scene, (flt )a, (flt )b);
        } else {
#line 405
          tmp___1 = stringcmp((char const   *)(data), "ORTHOGRAPHIC");
#line 405
          if (tmp___1 == 0) {
#line 406
            rt_camera_projection(scene, 1);
          }
        }
      }
    }
#line 409
    tmp___5 = GetString(ph, "ZOOM");
#line 409
    rc |= tmp___5;
#line 410
    fscanf((FILE * __restrict  )ph->ifp, (char const   * __restrict  )"%f", & a);
#line 411
    zoom = (apiflt )a;
  } else {
#line 412
    tmp___6 = stringcmp((char const   *)(data), "ZOOM");
#line 412
    if (tmp___6 == 0) {
#line 413
      fscanf((FILE * __restrict  )ph->ifp, (char const   * __restrict  )"%f", & a);
#line 414
      zoom = (apiflt )a;
    } else {
#line 416
      rc = (errcode )4;
#line 417
      return (rc);
    }
  }
#line 420
  tmp___8 = GetString(ph, "ASPECTRATIO");
#line 420
  rc |= tmp___8;
#line 421
  fscanf((FILE * __restrict  )ph->ifp, (char const   * __restrict  )"%f", & b);
#line 422
  aspectratio = (apiflt )b;
#line 424
  tmp___9 = GetString(ph, "ANTIALIASING");
#line 424
  rc |= tmp___9;
#line 425
  fscanf((FILE * __restrict  )ph->ifp, (char const   * __restrict  )"%d", & antialiasing);
#line 427
  tmp___10 = GetString(ph, "RAYDEPTH");
#line 427
  rc |= tmp___10;
#line 428
  fscanf((FILE * __restrict  )ph->ifp, (char const   * __restrict  )"%d", & raydepth);
#line 430
  tmp___11 = GetString(ph, "CENTER");
#line 430
  rc |= tmp___11;
#line 431
  fscanf((FILE * __restrict  )ph->ifp, (char const   * __restrict  )"%f %f %f", & a,
         & b, & c);
#line 432
  Ccenter.x = (apiflt )a;
#line 433
  Ccenter.y = (apiflt )b;
#line 434
  Ccenter.z = (apiflt )c;
#line 436
  tmp___12 = GetString(ph, "VIEWDIR");
#line 436
  rc |= tmp___12;
#line 437
  fscanf((FILE * __restrict  )ph->ifp, (char const   * __restrict  )"%f %f %f", & a,
         & b, & c);
#line 438
  Cview.x = (apiflt )a;
#line 439
  Cview.y = (apiflt )b;
#line 440
  Cview.z = (apiflt )c;
#line 442
  tmp___13 = GetString(ph, "UPDIR");
#line 442
  rc |= tmp___13;
#line 443
  fscanf((FILE * __restrict  )ph->ifp, (char const   * __restrict  )"%f %f %f", & a,
         & b, & c);
#line 444
  Cup.x = (apiflt )a;
#line 445
  Cup.y = (apiflt )b;
#line 446
  Cup.z = (apiflt )c;
#line 448
  rt_camera_setup(scene, zoom, aspectratio, antialiasing, raydepth, Ccenter, Cview,
                  Cup);
#line 451
  fscanf((FILE * __restrict  )ph->ifp, (char const   * __restrict  )"%s", data);
#line 452
  tmp___16 = stringcmp((char const   *)(data), "FRUSTUM");
#line 452
  if (tmp___16 == 0) {
#line 453
    fscanf((FILE * __restrict  )ph->ifp, (char const   * __restrict  )"%f %f %f %f",
           & a, & b, & c, & d);
#line 454
    rt_camera_frustum(scene, (flt )a, (flt )b, (flt )c, (flt )d);
#line 455
    fscanf((FILE * __restrict  )ph->ifp, (char const   * __restrict  )"%s", data);
#line 456
    tmp___14 = stringcmp((char const   *)(data), "END_CAMERA");
#line 456
    if (tmp___14 != 0) {
#line 457
      rc |= 4U;
#line 458
      return (rc);
    }
  } else {
#line 460
    tmp___15 = stringcmp((char const   *)(data), "END_CAMERA");
#line 460
    if (tmp___15 != 0) {
#line 461
      rc |= 4U;
#line 462
      return (rc);
    }
  }
#line 466
  return (rc);
}
}
#line 469 "../demosrc/parse.c"
static errcode GetObject(parsehandle *ph , SceneHandle scene ) 
{ 
  char objtype[256] ;
  int tmp ;
  errcode tmp___0 ;
  int tmp___1 ;
  errcode tmp___2 ;
  int tmp___3 ;
  errcode tmp___4 ;
  int tmp___5 ;
  errcode tmp___6 ;
  int tmp___7 ;
  errcode tmp___8 ;
  int tmp___9 ;
  errcode tmp___10 ;
  int tmp___11 ;
  errcode tmp___12 ;
  int tmp___13 ;
  errcode tmp___14 ;
  int tmp___15 ;
  errcode tmp___16 ;
  int tmp___17 ;
  errcode tmp___18 ;
  int tmp___19 ;
  errcode tmp___20 ;
  int tmp___21 ;
  errcode tmp___22 ;
  int tmp___23 ;
  errcode tmp___24 ;
  int tmp___25 ;
  errcode tmp___26 ;
  int tmp___27 ;
  errcode tmp___28 ;
  int tmp___29 ;
  errcode tmp___30 ;
  int tmp___31 ;
  errcode tmp___32 ;
  int tmp___33 ;
  errcode tmp___34 ;
  int tmp___35 ;
  errcode tmp___36 ;
  int tmp___37 ;
  errcode tmp___38 ;
  int tmp___39 ;
  errcode tmp___40 ;
  int tmp___41 ;
  errcode tmp___42 ;
  int tmp___43 ;
  errcode tmp___44 ;
  int tmp___45 ;
  int tmp___46 ;
  int c ;
  int tmp___47 ;
  errcode tmp___48 ;
  int tmp___49 ;
  errcode tmp___50 ;
  int tmp___51 ;
  char includefile[4096] ;
  errcode tmp___52 ;
  int tmp___53 ;
  errcode tmp___54 ;
  int tmp___55 ;
  errcode tmp___56 ;
  int tmp___57 ;
  int tmp___58 ;

  {
#line 472
  tmp = fscanf((FILE * __restrict  )ph->ifp, (char const   * __restrict  )"%s", objtype);
#line 472
  if (tmp == -1) {
#line 473
    return ((errcode )8);
  }
#line 475
  tmp___1 = stringcmp((char const   *)(objtype), "TRI");
#line 475
  if (! tmp___1) {
#line 476
    tmp___0 = GetTri(ph, scene);
#line 476
    return (tmp___0);
  }
#line 478
  tmp___3 = stringcmp((char const   *)(objtype), "STRI");
#line 478
  if (! tmp___3) {
#line 479
    tmp___2 = GetSTri(ph, scene);
#line 479
    return (tmp___2);
  }
#line 481
  tmp___5 = stringcmp((char const   *)(objtype), "VCSTRI");
#line 481
  if (! tmp___5) {
#line 482
    tmp___4 = GetVCSTri(ph, scene);
#line 482
    return (tmp___4);
  }
#line 484
  tmp___7 = stringcmp((char const   *)(objtype), "VERTEXARRAY");
#line 484
  if (! tmp___7) {
#line 485
    tmp___6 = GetVertexArray(ph, scene);
#line 485
    return (tmp___6);
  }
#line 487
  tmp___9 = stringcmp((char const   *)(objtype), "SPHERE");
#line 487
  if (! tmp___9) {
#line 488
    tmp___8 = GetSphere(ph, scene);
#line 488
    return (tmp___8);
  }
#line 490
  tmp___11 = stringcmp((char const   *)(objtype), "FCYLINDER");
#line 490
  if (! tmp___11) {
#line 491
    tmp___10 = GetFCylinder(ph, scene);
#line 491
    return (tmp___10);
  }
#line 493
  tmp___13 = stringcmp((char const   *)(objtype), "RING");
#line 493
  if (! tmp___13) {
#line 494
    tmp___12 = GetRing(ph, scene);
#line 494
    return (tmp___12);
  }
#line 496
  tmp___15 = stringcmp((char const   *)(objtype), "POLYCYLINDER");
#line 496
  if (! tmp___15) {
#line 497
    tmp___14 = GetPolyCylinder(ph, scene);
#line 497
    return (tmp___14);
  }
#line 499
  tmp___17 = stringcmp((char const   *)(objtype), "CYLINDER");
#line 499
  if (! tmp___17) {
#line 500
    tmp___16 = GetCylinder(ph, scene);
#line 500
    return (tmp___16);
  }
#line 502
  tmp___19 = stringcmp((char const   *)(objtype), "PLANE");
#line 502
  if (! tmp___19) {
#line 503
    tmp___18 = GetPlane(ph, scene);
#line 503
    return (tmp___18);
  }
#line 505
  tmp___21 = stringcmp((char const   *)(objtype), "BOX");
#line 505
  if (! tmp___21) {
#line 506
    tmp___20 = GetBox(ph, scene);
#line 506
    return (tmp___20);
  }
#line 508
  tmp___23 = stringcmp((char const   *)(objtype), "SCALARVOL");
#line 508
  if (! tmp___23) {
#line 509
    tmp___22 = GetVol(ph, scene);
#line 509
    return (tmp___22);
  }
#line 511
  tmp___25 = stringcmp((char const   *)(objtype), "IMAGEDEF");
#line 511
  if (! tmp___25) {
#line 512
    tmp___24 = GetImageDef(ph, scene);
#line 512
    return (tmp___24);
  }
#line 514
  tmp___27 = stringcmp((char const   *)(objtype), "TEXDEF");
#line 514
  if (! tmp___27) {
#line 515
    tmp___26 = GetTexDef(ph, scene);
#line 515
    return (tmp___26);
  }
#line 517
  tmp___29 = stringcmp((char const   *)(objtype), "TEXALIAS");
#line 517
  if (! tmp___29) {
#line 518
    tmp___28 = GetTexAlias(ph);
#line 518
    return (tmp___28);
  }
#line 520
  tmp___31 = stringcmp((char const   *)(objtype), "LIGHT");
#line 520
  if (! tmp___31) {
#line 521
    tmp___30 = GetLight(ph, scene);
#line 521
    return (tmp___30);
  }
#line 523
  tmp___33 = stringcmp((char const   *)(objtype), "DIRECTIONAL_LIGHT");
#line 523
  if (! tmp___33) {
#line 524
    tmp___32 = GetDirLight(ph, scene);
#line 524
    return (tmp___32);
  }
#line 526
  tmp___35 = stringcmp((char const   *)(objtype), "SKY_LIGHT");
#line 526
  if (! tmp___35) {
#line 527
    tmp___34 = GetSkyLight(ph, scene);
#line 527
    return (tmp___34);
  }
#line 529
  tmp___37 = stringcmp((char const   *)(objtype), "SPOTLIGHT");
#line 529
  if (! tmp___37) {
#line 530
    tmp___36 = GetSpotLight(ph, scene);
#line 530
    return (tmp___36);
  }
#line 532
  tmp___39 = stringcmp((char const   *)(objtype), "SCAPE");
#line 532
  if (! tmp___39) {
#line 533
    tmp___38 = GetLandScape(ph, scene);
#line 533
    return (tmp___38);
  }
#line 535
  tmp___41 = stringcmp((char const   *)(objtype), "SHADER_MODE");
#line 535
  if (! tmp___41) {
#line 536
    tmp___40 = GetShaderMode(ph, scene);
#line 536
    return (tmp___40);
  }
#line 538
  tmp___43 = stringcmp((char const   *)(objtype), "CAMERA");
#line 538
  if (! tmp___43) {
#line 539
    tmp___42 = GetCamera(ph, scene);
#line 539
    return (tmp___42);
  }
#line 541
  tmp___45 = stringcmp((char const   *)(objtype), "TPOLYFILE");
#line 541
  if (! tmp___45) {
#line 542
    tmp___44 = GetTPolyFile(ph, scene);
#line 542
    return (tmp___44);
  }
#line 544
  tmp___46 = stringcmp((char const   *)(objtype), "MGFFILE");
#line 544
  if (! tmp___46) {
#line 548
    printf((char const   * __restrict  )"MGF File Parsing is not available in this build.\n");
#line 549
    return ((errcode )4);
  }
#line 552
  tmp___47 = stringcmp((char const   *)(objtype), "#");
#line 552
  if (! tmp___47) {
#line 554
    while (1) {
#line 555
      c = fgetc(ph->ifp);
#line 556
      if (c == -1) {
#line 557
        return ((errcode )0);
      } else
#line 556
      if (c == 10) {
#line 557
        return ((errcode )0);
      }
    }
  }
#line 560
  tmp___49 = stringcmp((char const   *)(objtype), "BACKGROUND");
#line 560
  if (! tmp___49) {
#line 561
    tmp___48 = GetBackGnd(ph, scene);
#line 561
    return (tmp___48);
  }
#line 563
  tmp___51 = stringcmp((char const   *)(objtype), "FOG");
#line 563
  if (! tmp___51) {
#line 564
    tmp___50 = GetFog(ph, scene);
#line 564
    return (tmp___50);
  }
#line 566
  tmp___53 = stringcmp((char const   *)(objtype), "INCLUDE");
#line 566
  if (! tmp___53) {
#line 568
    fscanf((FILE * __restrict  )ph->ifp, (char const   * __restrict  )"%s", includefile);
#line 569
    tmp___52 = ReadIncludeFile(ph, (char const   *)(includefile), scene);
#line 569
    return (tmp___52);
  }
#line 571
  tmp___55 = stringcmp((char const   *)(objtype), "START_CLIPGROUP");
#line 571
  if (! tmp___55) {
#line 572
    tmp___54 = GetClipGroup(ph, scene);
#line 572
    return (tmp___54);
  }
#line 574
  tmp___57 = stringcmp((char const   *)(objtype), "END_CLIPGROUP");
#line 574
  if (! tmp___57) {
#line 575
    tmp___56 = GetClipGroupEnd(ph, scene);
#line 575
    return (tmp___56);
  }
#line 577
  tmp___58 = stringcmp((char const   *)(objtype), "END_SCENE");
#line 577
  if (! tmp___58) {
#line 578
    return ((errcode )8);
  }
#line 581
  PrintSyntaxError(ph, "an object or other declaration", (char const   *)(objtype));
#line 583
  return ((errcode )4);
}
}
#line 586 "../demosrc/parse.c"
static errcode GetInt(parsehandle *ph , int *i ) 
{ 
  int a ;
  int tmp ;

  {
#line 588
  tmp = fscanf((FILE * __restrict  )ph->ifp, (char const   * __restrict  )"%d", & a);
#line 588
  if (tmp != 1) {
#line 589
    return ((errcode )4);
  }
#line 591
  *i = a;
#line 593
  return ((errcode )0);
}
}
#line 596 "../demosrc/parse.c"
static errcode GetVector(parsehandle *ph , apivector *v1 ) 
{ 
  float a ;
  float b ;
  float c ;
  int tmp ;

  {
#line 599
  tmp = fscanf((FILE * __restrict  )ph->ifp, (char const   * __restrict  )"%f %f %f",
               & a, & b, & c);
#line 599
  if (tmp != 3) {
#line 600
    return ((errcode )4);
  }
#line 602
  v1->x = (apiflt )a;
#line 603
  v1->y = (apiflt )b;
#line 604
  v1->z = (apiflt )c;
#line 606
  return ((errcode )0);
}
}
#line 621 "../demosrc/parse.c"
static errcode GetColor(parsehandle *ph , apicolor *c1 ) 
{ 
  float r ;
  float g ;
  float b ;
  int rc ;
  errcode tmp ;

  {
#line 625
  tmp = GetString(ph, "COLOR");
#line 625
  rc = (int )tmp;
#line 626
  fscanf((FILE * __restrict  )ph->ifp, (char const   * __restrict  )"%f %f %f", & r,
         & g, & b);
#line 627
  c1->r = r;
#line 628
  c1->g = g;
#line 629
  c1->b = b;
#line 631
  return ((errcode )rc);
}
}
#line 634 "../demosrc/parse.c"
static errcode GetImageDef(parsehandle *ph , SceneHandle scene ) 
{ 
  char texname[255] ;
  int x ;
  int y ;
  int z ;
  int rc ;
  unsigned char *rgb ;
  int xres ;
  int yres ;
  int zres ;
  errcode tmp ;
  errcode tmp___0 ;
  errcode tmp___1 ;
  errcode tmp___2 ;
  errcode tmp___3 ;
  errcode tmp___4 ;
  void *tmp___5 ;
  errcode tmp___6 ;
  errcode tmp___7 ;
  char clrstr[1024] ;
  int red ;
  int green ;
  int blue ;
  int addr ;
  int n ;
  size_t tmp___8 ;

  {
#line 638
  rgb = (unsigned char *)((void *)0);
#line 639
  xres = 0;
#line 639
  yres = 0;
#line 639
  zres = 0;
#line 641
  fscanf((FILE * __restrict  )ph->ifp, (char const   * __restrict  )"%s", texname);
#line 643
  tmp = GetString(ph, "FORMAT");
#line 643
  rc = (int )tmp;
#line 644
  tmp___0 = GetString(ph, "RGB24");
#line 644
  rc = (int )((unsigned int )rc | tmp___0);
#line 646
  tmp___1 = GetString(ph, "RESOLUTION");
#line 646
  rc = (int )((unsigned int )rc | tmp___1);
#line 647
  tmp___2 = GetInt(ph, & xres);
#line 647
  rc = (int )((unsigned int )rc | tmp___2);
#line 648
  tmp___3 = GetInt(ph, & yres);
#line 648
  rc = (int )((unsigned int )rc | tmp___3);
#line 649
  tmp___4 = GetInt(ph, & zres);
#line 649
  rc = (int )((unsigned int )rc | tmp___4);
#line 651
  tmp___5 = malloc((size_t )(((xres * yres) * zres) * 3));
#line 651
  rgb = (unsigned char *)tmp___5;
#line 653
  tmp___6 = GetString(ph, "ENCODING");
#line 653
  rc = (int )((unsigned int )rc | tmp___6);
#line 654
  tmp___7 = GetString(ph, "HEX");
#line 654
  rc = (int )((unsigned int )rc | tmp___7);
#line 657
  z = 0;
#line 657
  while (z < zres) {
#line 658
    y = 0;
#line 658
    while (y < yres) {
#line 659
      x = 0;
#line 659
      while (x < xres) {
#line 662
        addr = (((z * xres) * yres + y * xres) + x) * 3;
#line 663
        n = 0;
#line 665
        fscanf((FILE * __restrict  )ph->ifp, (char const   * __restrict  )"%s", clrstr);
#line 670
        tmp___8 = strlen((char const   *)(clrstr));
#line 670
        switch (tmp___8) {
        case 3UL: 
#line 672
        n = sscanf((char const   * __restrict  )(clrstr), (char const   * __restrict  )"%01x%01x%01x",
                   & red, & green, & blue);
#line 673
        red |= red << 4;
#line 674
        green |= green << 4;
#line 675
        blue |= blue << 4;
#line 676
        break;
        case 6UL: 
#line 679
        n = sscanf((char const   * __restrict  )(clrstr), (char const   * __restrict  )"%02x%02x%02x",
                   & red, & green, & blue);
#line 680
        break;
        case 9UL: 
#line 683
        n = sscanf((char const   * __restrict  )(clrstr), (char const   * __restrict  )"%03x%03x%03x",
                   & red, & green, & blue);
#line 684
        red >>= 4;
#line 685
        green >>= 4;
#line 686
        blue >>= 4;
#line 687
        break;
        case 12UL: 
#line 690
        n = sscanf((char const   * __restrict  )(clrstr), (char const   * __restrict  )"%04x%04x%04x",
                   & red, & green, & blue);
#line 691
        red >>= 8;
#line 692
        green >>= 8;
#line 693
        blue >>= 8;
#line 694
        break;
        }
#line 697
        if (n != 3) {
#line 698
          rc |= 4;
        }
#line 702
        *(rgb + addr) = (unsigned char )(red & 255);
#line 703
        *(rgb + (addr + 1)) = (unsigned char )(green & 255);
#line 704
        *(rgb + (addr + 2)) = (unsigned char )(blue & 255);
#line 659
        x ++;
      }
#line 658
      y ++;
    }
#line 657
    z ++;
  }
#line 709
  if (rc == 0) {
#line 710
    rt_define_image((char const   *)(texname), xres, yres, zres, rgb);
  }
#line 713
  return ((errcode )rc);
}
}
#line 716 "../demosrc/parse.c"
static errcode GetTexDef(parsehandle *ph , SceneHandle scene ) 
{ 
  char texname[255] ;
  void *tmp ;

  {
#line 719
  fscanf((FILE * __restrict  )ph->ifp, (char const   * __restrict  )"%s", texname);
#line 720
  tmp = GetTexBody(ph, scene, 0);
#line 720
  add_texture(ph, tmp, (char const   *)(texname));
#line 722
  return ((errcode )0);
}
}
#line 725 "../demosrc/parse.c"
static errcode GetTexAlias(parsehandle *ph ) 
{ 
  char texname[255] ;
  char aliasname[255] ;
  void *tmp ;

  {
#line 729
  fscanf((FILE * __restrict  )ph->ifp, (char const   * __restrict  )"%s", texname);
#line 730
  fscanf((FILE * __restrict  )ph->ifp, (char const   * __restrict  )"%s", aliasname);
#line 731
  tmp = find_texture(ph, (char const   *)(aliasname));
#line 731
  add_texture(ph, tmp, (char const   *)(texname));
#line 733
  return ((errcode )0);
}
}
#line 737 "../demosrc/parse.c"
static errcode GetTexture(parsehandle *ph , SceneHandle scene , void **tex ) 
{ 
  char tmp[255] ;
  errcode rc ;
  int tmp___0 ;

  {
#line 739
  rc = (errcode )0;
#line 741
  fscanf((FILE * __restrict  )ph->ifp, (char const   * __restrict  )"%s", tmp);
#line 742
  tmp___0 = stringcmp((char const   *)(tmp), "TEXTURE");
#line 742
  if (tmp___0) {
#line 746
    *tex = find_texture(ph, (char const   *)(tmp));
  } else {
#line 743
    *tex = GetTexBody(ph, scene, 0);
  }
#line 748
  return (rc);
}
}
#line 751 "../demosrc/parse.c"
void *GetTexBody(parsehandle *ph , SceneHandle scene , int modeflag ) 
{ 
  char tmp[255] ;
  float a ;
  float b ;
  float c ;
  float d ;
  float outline ;
  float outlinewidth ;
  float phong ;
  float phongexp ;
  int phongtype ;
  apitexture tex ;
  void *voidtex ;
  errcode rc ;
  errcode tmp___0 ;
  errcode tmp___1 ;
  errcode tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  errcode tmp___8 ;
  errcode tmp___9 ;
  errcode tmp___10 ;
  errcode tmp___11 ;
  errcode tmp___12 ;
  errcode tmp___13 ;
  errcode tmp___14 ;
  errcode tmp___15 ;
  errcode tmp___16 ;
  errcode tmp___17 ;
  errcode tmp___18 ;
  errcode tmp___19 ;
  errcode tmp___20 ;
  errcode tmp___21 ;
  errcode tmp___22 ;
  errcode tmp___23 ;
  errcode tmp___24 ;
  errcode tmp___25 ;
  errcode tmp___26 ;
  errcode tmp___27 ;
  errcode tmp___28 ;
  errcode tmp___29 ;
  errcode tmp___30 ;
  errcode tmp___31 ;
  errcode tmp___32 ;
  errcode tmp___33 ;
  errcode tmp___34 ;
  errcode tmp___35 ;
  errcode tmp___36 ;
  errcode tmp___37 ;
  errcode tmp___38 ;
  errcode tmp___39 ;
  errcode tmp___40 ;
  errcode tmp___41 ;
  errcode tmp___42 ;
  int tmp___43 ;

  {
#line 761
  outline = 0.0f;
#line 762
  outlinewidth = 0.0f;
#line 763
  phong = 0.0f;
#line 764
  phongexp = 100.0f;
#line 765
  phongtype = 0;
#line 767
  rc = GetString(ph, "AMBIENT");
#line 768
  fscanf((FILE * __restrict  )ph->ifp, (char const   * __restrict  )"%f", & a);
#line 769
  tex.ambient = (apiflt )a;
#line 771
  tmp___0 = GetString(ph, "DIFFUSE");
#line 771
  rc |= tmp___0;
#line 772
  fscanf((FILE * __restrict  )ph->ifp, (char const   * __restrict  )"%f", & b);
#line 773
  tex.diffuse = (apiflt )b;
#line 775
  tmp___1 = GetString(ph, "SPECULAR");
#line 775
  rc |= tmp___1;
#line 776
  fscanf((FILE * __restrict  )ph->ifp, (char const   * __restrict  )"%f", & c);
#line 777
  tex.specular = (apiflt )c;
#line 779
  tmp___2 = GetString(ph, "OPACITY");
#line 779
  rc |= tmp___2;
#line 780
  fscanf((FILE * __restrict  )ph->ifp, (char const   * __restrict  )"%f", & d);
#line 781
  tex.opacity = (apiflt )d;
#line 783
  fscanf((FILE * __restrict  )ph->ifp, (char const   * __restrict  )"%s", tmp);
#line 784
  tmp___3 = stringcmp((char const   *)(tmp), "OUTLINE");
#line 784
  if (! tmp___3) {
#line 785
    fscanf((FILE * __restrict  )ph->ifp, (char const   * __restrict  )"%f", & outline);
#line 786
    GetString(ph, "OUTLINE_WIDTH");
#line 787
    fscanf((FILE * __restrict  )ph->ifp, (char const   * __restrict  )"%f", & outlinewidth);
#line 788
    fscanf((FILE * __restrict  )ph->ifp, (char const   * __restrict  )"%s", tmp);
  }
#line 791
  tmp___6 = stringcmp((char const   *)(tmp), "PHONG");
#line 791
  if (! tmp___6) {
#line 792
    fscanf((FILE * __restrict  )ph->ifp, (char const   * __restrict  )"%s", tmp);
#line 793
    tmp___5 = stringcmp((char const   *)(tmp), "METAL");
#line 793
    if (tmp___5) {
#line 796
      tmp___4 = stringcmp((char const   *)(tmp), "PLASTIC");
#line 796
      if (tmp___4) {
#line 800
        phongtype = 0;
      } else {
#line 797
        phongtype = 0;
      }
    } else {
#line 794
      phongtype = 1;
    }
#line 803
    fscanf((FILE * __restrict  )ph->ifp, (char const   * __restrict  )"%f", & phong);
#line 804
    GetString(ph, "PHONG_SIZE");
#line 805
    fscanf((FILE * __restrict  )ph->ifp, (char const   * __restrict  )"%f", & phongexp);
#line 806
    fscanf((FILE * __restrict  )ph->ifp, (char const   * __restrict  )"%s", tmp);
  }
#line 815
  if (modeflag == 0) {
#line 816
    tmp___7 = stringcmp((char const   *)(tmp), "COLOR");
#line 816
    if (tmp___7) {
#line 817
      rc |= 4U;
    }
#line 820
    fscanf((FILE * __restrict  )ph->ifp, (char const   * __restrict  )"%f %f %f",
           & a, & b, & c);
#line 821
    tex.col.r = a;
#line 822
    tex.col.g = b;
#line 823
    tex.col.b = c;
#line 825
    tmp___8 = GetString(ph, "TEXFUNC");
#line 825
    rc |= tmp___8;
#line 828
    fscanf((FILE * __restrict  )ph->ifp, (char const   * __restrict  )"%d", & tex.texturefunc);
#line 830
    switch (tex.texturefunc) {
    default: 
#line 833
    break;
    case 6: 
    case 5: 
    case 4: 
    case 3: 
    case 2: 
    case 1: 
#line 841
    tmp___9 = GetString(ph, "CENTER");
#line 841
    rc |= tmp___9;
#line 842
    tmp___10 = GetVector(ph, & tex.ctr);
#line 842
    rc |= tmp___10;
#line 843
    tmp___11 = GetString(ph, "ROTATE");
#line 843
    rc |= tmp___11;
#line 844
    tmp___12 = GetVector(ph, & tex.rot);
#line 844
    rc |= tmp___12;
#line 845
    tmp___13 = GetString(ph, "SCALE");
#line 845
    rc |= tmp___13;
#line 846
    tmp___14 = GetVector(ph, & tex.scale);
#line 846
    rc |= tmp___14;
#line 847
    break;
    case 8: 
    case 7: 
#line 851
    fscanf((FILE * __restrict  )ph->ifp, (char const   * __restrict  )"%s", tex.imap);
#line 852
    tmp___15 = GetString(ph, "CENTER");
#line 852
    rc |= tmp___15;
#line 853
    tmp___16 = GetVector(ph, & tex.ctr);
#line 853
    rc |= tmp___16;
#line 854
    tmp___17 = GetString(ph, "ROTATE");
#line 854
    rc |= tmp___17;
#line 855
    tmp___18 = GetVector(ph, & tex.rot);
#line 855
    rc |= tmp___18;
#line 856
    tmp___19 = GetString(ph, "SCALE");
#line 856
    rc |= tmp___19;
#line 857
    tmp___20 = GetVector(ph, & tex.scale);
#line 857
    rc |= tmp___20;
#line 858
    break;
    case 9: 
#line 861
    fscanf((FILE * __restrict  )ph->ifp, (char const   * __restrict  )"%s", tex.imap);
#line 862
    tmp___21 = GetString(ph, "CENTER");
#line 862
    rc |= tmp___21;
#line 863
    tmp___22 = GetVector(ph, & tex.ctr);
#line 863
    rc |= tmp___22;
#line 864
    tmp___23 = GetString(ph, "ROTATE");
#line 864
    rc |= tmp___23;
#line 865
    tmp___24 = GetVector(ph, & tex.rot);
#line 865
    rc |= tmp___24;
#line 866
    tmp___25 = GetString(ph, "SCALE");
#line 866
    rc |= tmp___25;
#line 867
    tmp___26 = GetVector(ph, & tex.scale);
#line 867
    rc |= tmp___26;
#line 868
    tmp___27 = GetString(ph, "UAXIS");
#line 868
    rc |= tmp___27;
#line 869
    tmp___28 = GetVector(ph, & tex.uaxs);
#line 869
    rc |= tmp___28;
#line 870
    tmp___29 = GetString(ph, "VAXIS");
#line 870
    rc |= tmp___29;
#line 871
    tmp___30 = GetVector(ph, & tex.vaxs);
#line 871
    rc |= tmp___30;
#line 872
    break;
    case 10: 
#line 875
    fscanf((FILE * __restrict  )ph->ifp, (char const   * __restrict  )"%s", tex.imap);
#line 876
    tmp___31 = GetString(ph, "CENTER");
#line 876
    rc |= tmp___31;
#line 877
    tmp___32 = GetVector(ph, & tex.ctr);
#line 877
    rc |= tmp___32;
#line 878
    tmp___33 = GetString(ph, "ROTATE");
#line 878
    rc |= tmp___33;
#line 879
    tmp___34 = GetVector(ph, & tex.rot);
#line 879
    rc |= tmp___34;
#line 880
    tmp___35 = GetString(ph, "SCALE");
#line 880
    rc |= tmp___35;
#line 881
    tmp___36 = GetVector(ph, & tex.scale);
#line 881
    rc |= tmp___36;
#line 882
    tmp___37 = GetString(ph, "UAXIS");
#line 882
    rc |= tmp___37;
#line 883
    tmp___38 = GetVector(ph, & tex.uaxs);
#line 883
    rc |= tmp___38;
#line 884
    tmp___39 = GetString(ph, "VAXIS");
#line 884
    rc |= tmp___39;
#line 885
    tmp___40 = GetVector(ph, & tex.vaxs);
#line 885
    rc |= tmp___40;
#line 886
    tmp___41 = GetString(ph, "WAXIS");
#line 886
    rc |= tmp___41;
#line 887
    tmp___42 = GetVector(ph, & tex.waxs);
#line 887
    rc |= tmp___42;
#line 888
    break;
    }
  } else {
#line 891
    tmp___43 = stringcmp((char const   *)(tmp), "VCST");
#line 891
    if (tmp___43) {
#line 892
      rc |= 4U;
    }
#line 896
    tex.col.r = (float )1.0;
#line 897
    tex.col.g = (float )1.0;
#line 898
    tex.col.b = (float )1.0;
#line 899
    tex.texturefunc = 0;
  }
#line 902
  voidtex = rt_texture(scene, & tex);
#line 903
  rt_tex_phong(voidtex, (apiflt )phong, (apiflt )phongexp, phongtype);
#line 904
  rt_tex_outline(voidtex, (apiflt )outline, (apiflt )outlinewidth);
#line 906
  return (voidtex);
}
}
#line 909 "../demosrc/parse.c"
static errcode GetDirLight(parsehandle *ph , SceneHandle scene ) 
{ 
  char tmp[255] ;
  apivector dir ;
  apitexture tex ;
  float r ;
  float g ;
  float b ;
  errcode rc ;
  errcode tmp___0 ;
  void *tmp___1 ;
  int tmp___2 ;

  {
#line 916
  memset((void *)(& tex), 0, sizeof(apitexture ));
#line 918
  rc = GetString(ph, "DIRECTION");
#line 919
  tmp___0 = GetVector(ph, & dir);
#line 919
  rc |= tmp___0;
#line 921
  fscanf((FILE * __restrict  )ph->ifp, (char const   * __restrict  )"%s", tmp);
#line 922
  tmp___2 = stringcmp((char const   *)(tmp), "COLOR");
#line 922
  if (! tmp___2) {
#line 923
    fscanf((FILE * __restrict  )ph->ifp, (char const   * __restrict  )"%f %f %f",
           & r, & g, & b);
#line 924
    tex.col.r = r;
#line 925
    tex.col.g = g;
#line 926
    tex.col.b = b;
#line 928
    tmp___1 = rt_texture(scene, & tex);
#line 928
    rt_directional_light(scene, tmp___1, dir);
  }
#line 931
  return (rc);
}
}
#line 934 "../demosrc/parse.c"
static errcode GetLight(parsehandle *ph , SceneHandle scene ) 
{ 
  char tmp[255] ;
  apiflt rad ;
  apiflt Kc ;
  apiflt Kl ;
  apiflt Kq ;
  apivector ctr ;
  apitexture tex ;
  float r ;
  float g ;
  float b ;
  float a ;
  errcode rc ;
  void *li ;
  errcode tmp___0 ;
  errcode tmp___1 ;
  void *tmp___2 ;
  int tmp___3 ;
  errcode tmp___4 ;
  errcode tmp___5 ;
  errcode tmp___6 ;
  errcode tmp___7 ;
  void *tmp___8 ;
  int tmp___9 ;

  {
#line 943
  memset((void *)(& tex), 0, sizeof(apitexture ));
#line 945
  rc = GetString(ph, "CENTER");
#line 946
  tmp___0 = GetVector(ph, & ctr);
#line 946
  rc |= tmp___0;
#line 947
  tmp___1 = GetString(ph, "RAD");
#line 947
  rc |= tmp___1;
#line 948
  fscanf((FILE * __restrict  )ph->ifp, (char const   * __restrict  )"%f", & a);
#line 949
  rad = (apiflt )a;
#line 951
  fscanf((FILE * __restrict  )ph->ifp, (char const   * __restrict  )"%s", tmp);
#line 952
  tmp___9 = stringcmp((char const   *)(tmp), "COLOR");
#line 952
  if (tmp___9) {
#line 961
    tmp___3 = stringcmp((char const   *)(tmp), "ATTENUATION");
#line 961
    if (tmp___3) {
#line 962
      return ((errcode )-1);
    }
#line 964
    tmp___4 = GetString(ph, "CONSTANT");
#line 964
    rc |= tmp___4;
#line 965
    fscanf((FILE * __restrict  )ph->ifp, (char const   * __restrict  )"%f", & a);
#line 966
    Kc = (apiflt )a;
#line 967
    tmp___5 = GetString(ph, "LINEAR");
#line 967
    rc |= tmp___5;
#line 968
    fscanf((FILE * __restrict  )ph->ifp, (char const   * __restrict  )"%f", & a);
#line 969
    Kl = (apiflt )a;
#line 970
    tmp___6 = GetString(ph, "QUADRATIC");
#line 970
    rc |= tmp___6;
#line 971
    fscanf((FILE * __restrict  )ph->ifp, (char const   * __restrict  )"%f", & a);
#line 972
    Kq = (apiflt )a;
#line 973
    tmp___7 = GetColor(ph, & tex.col);
#line 973
    rc |= tmp___7;
#line 975
    tmp___8 = rt_texture(scene, & tex);
#line 975
    li = rt_light(scene, tmp___8, ctr, rad);
#line 977
    rt_light_attenuation(li, Kc, Kl, Kq);
  } else {
#line 953
    fscanf((FILE * __restrict  )ph->ifp, (char const   * __restrict  )"%f %f %f",
           & r, & g, & b);
#line 954
    tex.col.r = r;
#line 955
    tex.col.g = g;
#line 956
    tex.col.b = b;
#line 958
    tmp___2 = rt_texture(scene, & tex);
#line 958
    li = rt_light(scene, tmp___2, ctr, rad);
  }
#line 980
  return (rc);
}
}
#line 983 "../demosrc/parse.c"
static errcode GetSkyLight(parsehandle *ph , SceneHandle scene ) 
{ 
  errcode rc ;
  apicolor ambcol ;
  int numsamples ;
  errcode tmp ;

  {
#line 986
  numsamples = 128;
#line 988
  ambcol.r = (float )1.0;
#line 989
  ambcol.g = (float )1.0;
#line 990
  ambcol.b = (float )1.0;
#line 992
  rc = GetString(ph, "NUMSAMPLES");
#line 993
  fscanf((FILE * __restrict  )ph->ifp, (char const   * __restrict  )"%d", & numsamples);
#line 995
  tmp = GetString(ph, "COLOR");
#line 995
  rc |= tmp;
#line 996
  fscanf((FILE * __restrict  )ph->ifp, (char const   * __restrict  )"%f %f %f", & ambcol.r,
         & ambcol.g, & ambcol.b);
#line 998
  rt_ambient_occlusion(scene, numsamples, ambcol);
#line 1000
  return (rc);
}
}
#line 1003 "../demosrc/parse.c"
static errcode GetSpotLight(parsehandle *ph , SceneHandle scene ) 
{ 
  char tmp[255] ;
  apiflt rad ;
  apiflt Kc ;
  apiflt Kl ;
  apiflt Kq ;
  apivector ctr ;
  apitexture tex ;
  apivector direction ;
  apiflt start ;
  apiflt end ;
  float r ;
  float g ;
  float b ;
  float a ;
  errcode rc ;
  void *li ;
  errcode tmp___0 ;
  errcode tmp___1 ;
  errcode tmp___2 ;
  errcode tmp___3 ;
  errcode tmp___4 ;
  errcode tmp___5 ;
  void *tmp___6 ;
  int tmp___7 ;
  errcode tmp___8 ;
  errcode tmp___9 ;
  errcode tmp___10 ;
  errcode tmp___11 ;
  void *tmp___12 ;
  int tmp___13 ;

  {
#line 1014
  memset((void *)(& tex), 0, sizeof(apitexture ));
#line 1016
  rc = GetString(ph, "CENTER");
#line 1017
  tmp___0 = GetVector(ph, & ctr);
#line 1017
  rc |= tmp___0;
#line 1018
  tmp___1 = GetString(ph, "RAD");
#line 1018
  rc |= tmp___1;
#line 1019
  fscanf((FILE * __restrict  )ph->ifp, (char const   * __restrict  )"%f", & a);
#line 1020
  rad = (apiflt )a;
#line 1022
  tmp___2 = GetString(ph, "DIRECTION");
#line 1022
  rc |= tmp___2;
#line 1023
  tmp___3 = GetVector(ph, & direction);
#line 1023
  rc |= tmp___3;
#line 1024
  tmp___4 = GetString(ph, "FALLOFF_START");
#line 1024
  rc |= tmp___4;
#line 1025
  fscanf((FILE * __restrict  )ph->ifp, (char const   * __restrict  )"%f", & a);
#line 1026
  start = (apiflt )a;
#line 1027
  tmp___5 = GetString(ph, "FALLOFF_END");
#line 1027
  rc |= tmp___5;
#line 1028
  fscanf((FILE * __restrict  )ph->ifp, (char const   * __restrict  )"%f", & a);
#line 1029
  end = (apiflt )a;
#line 1031
  fscanf((FILE * __restrict  )ph->ifp, (char const   * __restrict  )"%s", tmp);
#line 1032
  tmp___13 = stringcmp((char const   *)(tmp), "COLOR");
#line 1032
  if (tmp___13) {
#line 1041
    tmp___7 = stringcmp((char const   *)(tmp), "ATTENUATION");
#line 1041
    if (tmp___7) {
#line 1042
      return ((errcode )-1);
    }
#line 1043
    tmp___8 = GetString(ph, "CONSTANT");
#line 1043
    rc |= tmp___8;
#line 1044
    fscanf((FILE * __restrict  )ph->ifp, (char const   * __restrict  )"%f", & a);
#line 1045
    Kc = (apiflt )a;
#line 1046
    tmp___9 = GetString(ph, "LINEAR");
#line 1046
    rc |= tmp___9;
#line 1047
    fscanf((FILE * __restrict  )ph->ifp, (char const   * __restrict  )"%f", & a);
#line 1048
    Kl = (apiflt )a;
#line 1049
    tmp___10 = GetString(ph, "QUADRATIC");
#line 1049
    rc |= tmp___10;
#line 1050
    fscanf((FILE * __restrict  )ph->ifp, (char const   * __restrict  )"%f", & a);
#line 1051
    Kq = (apiflt )a;
#line 1052
    tmp___11 = GetColor(ph, & tex.col);
#line 1052
    rc |= tmp___11;
#line 1054
    tmp___12 = rt_texture(scene, & tex);
#line 1054
    li = rt_spotlight(scene, tmp___12, ctr, rad, direction, start, end);
#line 1055
    rt_light_attenuation(li, Kc, Kl, Kq);
  } else {
#line 1033
    fscanf((FILE * __restrict  )ph->ifp, (char const   * __restrict  )"%f %f %f",
           & r, & g, & b);
#line 1034
    tex.col.r = r;
#line 1035
    tex.col.g = g;
#line 1036
    tex.col.b = b;
#line 1038
    tmp___6 = rt_texture(scene, & tex);
#line 1038
    li = rt_spotlight(scene, tmp___6, ctr, rad, direction, start, end);
  }
#line 1058
  return (rc);
}
}
#line 1062 "../demosrc/parse.c"
static errcode GetFog(parsehandle *ph , SceneHandle scene ) 
{ 
  char tmp[255] ;
  apicolor fogcol ;
  float start ;
  float end ;
  float density ;
  errcode rc ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  errcode tmp___4 ;
  errcode tmp___5 ;
  errcode tmp___6 ;
  errcode tmp___7 ;

  {
#line 1066
  rc = (errcode )0;
#line 1068
  fscanf((FILE * __restrict  )ph->ifp, (char const   * __restrict  )"%s", tmp);
#line 1069
  tmp___3 = stringcmp((char const   *)(tmp), "LINEAR");
#line 1069
  if (tmp___3) {
#line 1071
    tmp___2 = stringcmp((char const   *)(tmp), "EXP");
#line 1071
    if (tmp___2) {
#line 1073
      tmp___1 = stringcmp((char const   *)(tmp), "EXP2");
#line 1073
      if (tmp___1) {
#line 1075
        tmp___0 = stringcmp((char const   *)(tmp), "OFF");
#line 1075
        if (! tmp___0) {
#line 1076
          rt_fog_mode(scene, 0);
        }
      } else {
#line 1074
        rt_fog_mode(scene, 3);
      }
    } else {
#line 1072
      rt_fog_mode(scene, 2);
    }
  } else {
#line 1070
    rt_fog_mode(scene, 1);
  }
#line 1079
  tmp___4 = GetString(ph, "START");
#line 1079
  rc |= tmp___4;
#line 1080
  fscanf((FILE * __restrict  )ph->ifp, (char const   * __restrict  )"%f", & start);
#line 1082
  tmp___5 = GetString(ph, "END");
#line 1082
  rc |= tmp___5;
#line 1083
  fscanf((FILE * __restrict  )ph->ifp, (char const   * __restrict  )"%f", & end);
#line 1085
  tmp___6 = GetString(ph, "DENSITY");
#line 1085
  rc |= tmp___6;
#line 1086
  fscanf((FILE * __restrict  )ph->ifp, (char const   * __restrict  )"%f", & density);
#line 1088
  tmp___7 = GetColor(ph, & fogcol);
#line 1088
  rc |= tmp___7;
#line 1090
  rt_fog_parms(scene, fogcol, (apiflt )start, (apiflt )end, (apiflt )density);
#line 1092
  return ((errcode )0);
}
}
#line 1096 "../demosrc/parse.c"
static errcode GetBackGnd(parsehandle *ph , SceneHandle scene ) 
{ 
  float r ;
  float g ;
  float b ;
  apicolor scenebackcol___0 ;

  {
#line 1100
  fscanf((FILE * __restrict  )ph->ifp, (char const   * __restrict  )"%f %f %f", & r,
         & g, & b);
#line 1102
  scenebackcol___0.r = r;
#line 1103
  scenebackcol___0.g = g;
#line 1104
  scenebackcol___0.b = b;
#line 1105
  rt_background(scene, scenebackcol___0);
#line 1107
  return ((errcode )0);
}
}
#line 1111 "../demosrc/parse.c"
static errcode GetCylinder(parsehandle *ph , SceneHandle scene ) 
{ 
  apiflt rad ;
  apivector ctr ;
  apivector axis ;
  void *tex ;
  float a ;
  errcode rc ;
  errcode tmp ;
  errcode tmp___0 ;
  errcode tmp___1 ;
  errcode tmp___2 ;
  errcode tmp___3 ;

  {
#line 1118
  rc = GetString(ph, "CENTER");
#line 1119
  tmp = GetVector(ph, & ctr);
#line 1119
  rc |= tmp;
#line 1120
  tmp___0 = GetString(ph, "AXIS");
#line 1120
  rc |= tmp___0;
#line 1121
  tmp___1 = GetVector(ph, & axis);
#line 1121
  rc |= tmp___1;
#line 1122
  tmp___2 = GetString(ph, "RAD");
#line 1122
  rc |= tmp___2;
#line 1123
  fscanf((FILE * __restrict  )ph->ifp, (char const   * __restrict  )"%f", & a);
#line 1124
  rad = (apiflt )a;
#line 1126
  tmp___3 = GetTexture(ph, scene, & tex);
#line 1126
  rc |= tmp___3;
#line 1127
  rt_cylinder(scene, tex, ctr, axis, rad);
#line 1129
  return (rc);
}
}
#line 1132 "../demosrc/parse.c"
static errcode GetFCylinder(parsehandle *ph , SceneHandle scene ) 
{ 
  apiflt rad ;
  apivector ctr ;
  apivector axis ;
  apivector pnt1 ;
  apivector pnt2 ;
  void *tex ;
  float a ;
  errcode rc ;
  errcode tmp ;
  errcode tmp___0 ;
  errcode tmp___1 ;
  errcode tmp___2 ;
  errcode tmp___3 ;

  {
#line 1135
  pnt1.x = (apiflt )0;
#line 1135
  pnt1.y = (apiflt )0;
#line 1135
  pnt1.z = (apiflt )0;
#line 1136
  pnt2.x = (apiflt )0;
#line 1136
  pnt2.y = (apiflt )0;
#line 1136
  pnt2.z = (apiflt )0;
#line 1141
  rc = GetString(ph, "BASE");
#line 1142
  tmp = GetVector(ph, & pnt1);
#line 1142
  rc |= tmp;
#line 1143
  tmp___0 = GetString(ph, "APEX");
#line 1143
  rc |= tmp___0;
#line 1144
  tmp___1 = GetVector(ph, & pnt2);
#line 1144
  rc |= tmp___1;
#line 1146
  ctr = pnt1;
#line 1147
  axis.x = pnt2.x - pnt1.x;
#line 1148
  axis.y = pnt2.y - pnt1.y;
#line 1149
  axis.z = pnt2.z - pnt1.z;
#line 1151
  tmp___2 = GetString(ph, "RAD");
#line 1151
  rc |= tmp___2;
#line 1152
  fscanf((FILE * __restrict  )ph->ifp, (char const   * __restrict  )"%f", & a);
#line 1153
  rad = (apiflt )a;
#line 1155
  tmp___3 = GetTexture(ph, scene, & tex);
#line 1155
  rc |= tmp___3;
#line 1156
  rt_fcylinder(scene, tex, ctr, axis, rad);
#line 1158
  return (rc);
}
}
#line 1161 "../demosrc/parse.c"
static errcode GetPolyCylinder(parsehandle *ph , SceneHandle scene ) 
{ 
  apiflt rad ;
  apivector *temp ;
  void *tex ;
  float a ;
  int numpts ;
  int i ;
  errcode rc ;
  void *tmp ;
  errcode tmp___0 ;
  errcode tmp___1 ;
  errcode tmp___2 ;

  {
#line 1169
  rc = GetString(ph, "POINTS");
#line 1170
  fscanf((FILE * __restrict  )ph->ifp, (char const   * __restrict  )"%d", & numpts);
#line 1172
  tmp = malloc((unsigned long )numpts * sizeof(apivector ));
#line 1172
  temp = (apivector *)tmp;
#line 1174
  i = 0;
#line 1174
  while (i < numpts) {
#line 1175
    tmp___0 = GetVector(ph, temp + i);
#line 1175
    rc |= tmp___0;
#line 1174
    i ++;
  }
#line 1178
  tmp___1 = GetString(ph, "RAD");
#line 1178
  rc |= tmp___1;
#line 1179
  fscanf((FILE * __restrict  )ph->ifp, (char const   * __restrict  )"%f", & a);
#line 1180
  rad = (apiflt )a;
#line 1182
  tmp___2 = GetTexture(ph, scene, & tex);
#line 1182
  rc |= tmp___2;
#line 1183
  rt_polycylinder(scene, tex, temp, numpts, rad);
#line 1185
  free((void *)temp);
#line 1187
  return (rc);
}
}
#line 1191 "../demosrc/parse.c"
static errcode GetSphere(parsehandle *ph , SceneHandle scene ) 
{ 
  apiflt rad ;
  apivector ctr ;
  void *tex ;
  float a ;
  errcode rc ;
  errcode tmp ;
  errcode tmp___0 ;
  errcode tmp___1 ;

  {
#line 1198
  rc = GetString(ph, "CENTER");
#line 1199
  tmp = GetVector(ph, & ctr);
#line 1199
  rc |= tmp;
#line 1200
  tmp___0 = GetString(ph, "RAD");
#line 1200
  rc |= tmp___0;
#line 1201
  fscanf((FILE * __restrict  )ph->ifp, (char const   * __restrict  )"%f", & a);
#line 1202
  rad = (apiflt )a;
#line 1204
  tmp___1 = GetTexture(ph, scene, & tex);
#line 1204
  rc |= tmp___1;
#line 1206
  rt_sphere(scene, tex, ctr, rad);
#line 1208
  return (rc);
}
}
#line 1211 "../demosrc/parse.c"
static errcode GetPlane(parsehandle *ph , SceneHandle scene ) 
{ 
  apivector normal ;
  apivector ctr ;
  void *tex ;
  errcode rc ;
  errcode tmp ;
  errcode tmp___0 ;
  errcode tmp___1 ;
  errcode tmp___2 ;

  {
#line 1217
  rc = GetString(ph, "CENTER");
#line 1218
  tmp = GetVector(ph, & ctr);
#line 1218
  rc |= tmp;
#line 1219
  tmp___0 = GetString(ph, "NORMAL");
#line 1219
  rc |= tmp___0;
#line 1220
  tmp___1 = GetVector(ph, & normal);
#line 1220
  rc |= tmp___1;
#line 1221
  tmp___2 = GetTexture(ph, scene, & tex);
#line 1221
  rc |= tmp___2;
#line 1223
  rt_plane(scene, tex, ctr, normal);
#line 1225
  return (rc);
}
}
#line 1228 "../demosrc/parse.c"
static errcode GetVol(parsehandle *ph , SceneHandle scene ) 
{ 
  apivector min ;
  apivector max ;
  int x ;
  int y ;
  int z ;
  char fname[255] ;
  void *tex ;
  errcode rc ;
  errcode tmp ;
  errcode tmp___0 ;
  errcode tmp___1 ;
  errcode tmp___2 ;
  errcode tmp___3 ;
  errcode tmp___4 ;

  {
#line 1235
  rc = GetString(ph, "MIN");
#line 1236
  tmp = GetVector(ph, & min);
#line 1236
  rc |= tmp;
#line 1237
  tmp___0 = GetString(ph, "MAX");
#line 1237
  rc |= tmp___0;
#line 1238
  tmp___1 = GetVector(ph, & max);
#line 1238
  rc |= tmp___1;
#line 1239
  tmp___2 = GetString(ph, "DIM");
#line 1239
  rc |= tmp___2;
#line 1240
  fscanf((FILE * __restrict  )ph->ifp, (char const   * __restrict  )"%d %d %d ", & x,
         & y, & z);
#line 1241
  tmp___3 = GetString(ph, "FILE");
#line 1241
  rc |= tmp___3;
#line 1242
  fscanf((FILE * __restrict  )ph->ifp, (char const   * __restrict  )"%s", fname);
#line 1243
  tmp___4 = GetTexture(ph, scene, & tex);
#line 1243
  rc |= tmp___4;
#line 1245
  rt_scalarvol(scene, tex, min, max, x, y, z, (char const   *)(fname), (void *)0);
#line 1247
  return (rc);
}
}
#line 1250 "../demosrc/parse.c"
static errcode GetBox(parsehandle *ph , SceneHandle scene ) 
{ 
  apivector min ;
  apivector max ;
  void *tex ;
  errcode rc ;
  errcode tmp ;
  errcode tmp___0 ;
  errcode tmp___1 ;
  errcode tmp___2 ;

  {
#line 1255
  rc = GetString(ph, "MIN");
#line 1256
  tmp = GetVector(ph, & min);
#line 1256
  rc |= tmp;
#line 1257
  tmp___0 = GetString(ph, "MAX");
#line 1257
  rc |= tmp___0;
#line 1258
  tmp___1 = GetVector(ph, & max);
#line 1258
  rc |= tmp___1;
#line 1259
  tmp___2 = GetTexture(ph, scene, & tex);
#line 1259
  rc |= tmp___2;
#line 1261
  rt_box(scene, tex, min, max);
#line 1263
  return (rc);
}
}
#line 1266 "../demosrc/parse.c"
static errcode GetRing(parsehandle *ph , SceneHandle scene ) 
{ 
  apivector normal ;
  apivector ctr ;
  void *tex ;
  float a ;
  float b ;
  errcode rc ;
  errcode tmp ;
  errcode tmp___0 ;
  errcode tmp___1 ;
  errcode tmp___2 ;
  errcode tmp___3 ;
  errcode tmp___4 ;

  {
#line 1273
  rc = GetString(ph, "CENTER");
#line 1274
  tmp = GetVector(ph, & ctr);
#line 1274
  rc |= tmp;
#line 1275
  tmp___0 = GetString(ph, "NORMAL");
#line 1275
  rc |= tmp___0;
#line 1276
  tmp___1 = GetVector(ph, & normal);
#line 1276
  rc |= tmp___1;
#line 1277
  tmp___2 = GetString(ph, "INNER");
#line 1277
  rc |= tmp___2;
#line 1278
  fscanf((FILE * __restrict  )ph->ifp, (char const   * __restrict  )" %f ", & a);
#line 1279
  tmp___3 = GetString(ph, "OUTER");
#line 1279
  rc |= tmp___3;
#line 1280
  fscanf((FILE * __restrict  )ph->ifp, (char const   * __restrict  )" %f ", & b);
#line 1281
  tmp___4 = GetTexture(ph, scene, & tex);
#line 1281
  rc |= tmp___4;
#line 1283
  rt_ring(scene, tex, ctr, normal, (apiflt )a, (apiflt )b);
#line 1285
  return (rc);
}
}
#line 1288 "../demosrc/parse.c"
static errcode GetTri(parsehandle *ph , SceneHandle scene ) 
{ 
  apivector v0 ;
  apivector v1 ;
  apivector v2 ;
  void *tex ;
  errcode rc ;
  errcode tmp ;
  errcode tmp___0 ;
  errcode tmp___1 ;
  errcode tmp___2 ;
  errcode tmp___3 ;
  errcode tmp___4 ;

  {
#line 1293
  rc = GetString(ph, "V0");
#line 1294
  tmp = GetVector(ph, & v0);
#line 1294
  rc |= tmp;
#line 1296
  tmp___0 = GetString(ph, "V1");
#line 1296
  rc |= tmp___0;
#line 1297
  tmp___1 = GetVector(ph, & v1);
#line 1297
  rc |= tmp___1;
#line 1299
  tmp___2 = GetString(ph, "V2");
#line 1299
  rc |= tmp___2;
#line 1300
  tmp___3 = GetVector(ph, & v2);
#line 1300
  rc |= tmp___3;
#line 1302
  tmp___4 = GetTexture(ph, scene, & tex);
#line 1302
  rc |= tmp___4;
#line 1304
  rt_tri(scene, tex, v0, v1, v2);
#line 1306
  return (rc);
}
}
#line 1309 "../demosrc/parse.c"
static errcode GetSTri(parsehandle *ph , SceneHandle scene ) 
{ 
  apivector v0 ;
  apivector v1 ;
  apivector v2 ;
  apivector n0 ;
  apivector n1 ;
  apivector n2 ;
  void *tex ;
  errcode rc ;
  errcode tmp ;
  errcode tmp___0 ;
  errcode tmp___1 ;
  errcode tmp___2 ;
  errcode tmp___3 ;
  errcode tmp___4 ;
  errcode tmp___5 ;
  errcode tmp___6 ;
  errcode tmp___7 ;
  errcode tmp___8 ;
  errcode tmp___9 ;
  errcode tmp___10 ;

  {
#line 1314
  rc = GetString(ph, "V0");
#line 1315
  tmp = GetVector(ph, & v0);
#line 1315
  rc |= tmp;
#line 1317
  tmp___0 = GetString(ph, "V1");
#line 1317
  rc |= tmp___0;
#line 1318
  tmp___1 = GetVector(ph, & v1);
#line 1318
  rc |= tmp___1;
#line 1320
  tmp___2 = GetString(ph, "V2");
#line 1320
  rc |= tmp___2;
#line 1321
  tmp___3 = GetVector(ph, & v2);
#line 1321
  rc |= tmp___3;
#line 1323
  tmp___4 = GetString(ph, "N0");
#line 1323
  rc |= tmp___4;
#line 1324
  tmp___5 = GetVector(ph, & n0);
#line 1324
  rc |= tmp___5;
#line 1326
  tmp___6 = GetString(ph, "N1");
#line 1326
  rc |= tmp___6;
#line 1327
  tmp___7 = GetVector(ph, & n1);
#line 1327
  rc |= tmp___7;
#line 1329
  tmp___8 = GetString(ph, "N2");
#line 1329
  rc |= tmp___8;
#line 1330
  tmp___9 = GetVector(ph, & n2);
#line 1330
  rc |= tmp___9;
#line 1332
  tmp___10 = GetTexture(ph, scene, & tex);
#line 1332
  rc |= tmp___10;
#line 1334
  rt_stri(scene, tex, v0, v1, v2, n0, n1, n2);
#line 1336
  return (rc);
}
}
#line 1339 "../demosrc/parse.c"
static errcode GetVCSTri(parsehandle *ph , SceneHandle scene ) 
{ 
  apivector v0 ;
  apivector v1 ;
  apivector v2 ;
  apivector n0 ;
  apivector n1 ;
  apivector n2 ;
  apicolor c0 ;
  apicolor c1 ;
  apicolor c2 ;
  float a ;
  float b ;
  float c ;
  void *tex ;
  errcode rc ;
  errcode tmp ;
  errcode tmp___0 ;
  errcode tmp___1 ;
  errcode tmp___2 ;
  errcode tmp___3 ;
  errcode tmp___4 ;
  errcode tmp___5 ;
  errcode tmp___6 ;
  errcode tmp___7 ;
  errcode tmp___8 ;
  errcode tmp___9 ;
  errcode tmp___10 ;
  errcode tmp___11 ;
  errcode tmp___12 ;

  {
#line 1347
  rc = GetString(ph, "V0");
#line 1348
  tmp = GetVector(ph, & v0);
#line 1348
  rc |= tmp;
#line 1350
  tmp___0 = GetString(ph, "V1");
#line 1350
  rc |= tmp___0;
#line 1351
  tmp___1 = GetVector(ph, & v1);
#line 1351
  rc |= tmp___1;
#line 1353
  tmp___2 = GetString(ph, "V2");
#line 1353
  rc |= tmp___2;
#line 1354
  tmp___3 = GetVector(ph, & v2);
#line 1354
  rc |= tmp___3;
#line 1356
  tmp___4 = GetString(ph, "N0");
#line 1356
  rc |= tmp___4;
#line 1357
  tmp___5 = GetVector(ph, & n0);
#line 1357
  rc |= tmp___5;
#line 1359
  tmp___6 = GetString(ph, "N1");
#line 1359
  rc |= tmp___6;
#line 1360
  tmp___7 = GetVector(ph, & n1);
#line 1360
  rc |= tmp___7;
#line 1362
  tmp___8 = GetString(ph, "N2");
#line 1362
  rc |= tmp___8;
#line 1363
  tmp___9 = GetVector(ph, & n2);
#line 1363
  rc |= tmp___9;
#line 1365
  tmp___10 = GetString(ph, "C0");
#line 1365
  rc |= tmp___10;
#line 1366
  fscanf((FILE * __restrict  )ph->ifp, (char const   * __restrict  )"%f %f %f", & a,
         & b, & c);
#line 1367
  c0.r = a;
#line 1368
  c0.g = b;
#line 1369
  c0.b = c;
#line 1371
  tmp___11 = GetString(ph, "C1");
#line 1371
  rc |= tmp___11;
#line 1372
  fscanf((FILE * __restrict  )ph->ifp, (char const   * __restrict  )"%f %f %f", & a,
         & b, & c);
#line 1373
  c1.r = a;
#line 1374
  c1.g = b;
#line 1375
  c1.b = c;
#line 1377
  tmp___12 = GetString(ph, "C2");
#line 1377
  rc |= tmp___12;
#line 1378
  fscanf((FILE * __restrict  )ph->ifp, (char const   * __restrict  )"%f %f %f", & a,
         & b, & c);
#line 1379
  c2.r = a;
#line 1380
  c2.g = b;
#line 1381
  c2.b = c;
#line 1383
  tex = GetTexBody(ph, scene, 1);
#line 1385
  rt_vcstri(scene, tex, v0, v1, v2, n0, n1, n2, c0, c1, c2);
#line 1387
  return (rc);
}
}
#line 1391 "../demosrc/parse.c"
static errcode GetVertexArray(parsehandle *ph , SceneHandle scene ) 
{ 
  char arraytype[1024] ;
  int done ;
  int i ;
  int texusecount ;
  int vertexcount ;
  errcode rc ;
  void *tex ;
  float *v ;
  float *n ;
  float *c ;
  errcode tmp ;
  errcode tmp___0 ;
  void *tmp___1 ;
  int tmp___2 ;
  void *tmp___3 ;
  int tmp___4 ;
  void *tmp___5 ;
  int t ;
  int numv ;
  int stripaddr[2][3] ;
  int *facets ;
  errcode tmp___6 ;
  void *tmp___7 ;
  int v0 ;
  int v1 ;
  int v2 ;
  apicolor tmp___8 ;
  apicolor tmp___9 ;
  apicolor tmp___10 ;
  apivector tmp___11 ;
  apivector tmp___12 ;
  apivector tmp___13 ;
  apivector tmp___14 ;
  apivector tmp___15 ;
  apivector tmp___16 ;
  apivector tmp___17 ;
  apivector tmp___18 ;
  apivector tmp___19 ;
  apivector tmp___20 ;
  apivector tmp___21 ;
  apivector tmp___22 ;
  int numfacets ;
  int *facets___0 ;
  errcode tmp___23 ;
  void *tmp___24 ;
  int v0___0 ;
  int v1___0 ;
  int v2___0 ;
  apicolor tmp___25 ;
  apicolor tmp___26 ;
  apicolor tmp___27 ;
  apivector tmp___28 ;
  apivector tmp___29 ;
  apivector tmp___30 ;
  apivector tmp___31 ;
  apivector tmp___32 ;
  apivector tmp___33 ;
  apivector tmp___34 ;
  apivector tmp___35 ;
  apivector tmp___36 ;
  apivector tmp___37 ;
  apivector tmp___38 ;
  apivector tmp___39 ;
  int tmp___40 ;
  int tmp___41 ;
  int tmp___42 ;
  int tmp___43 ;
  int tmp___44 ;

  {
#line 1394
  vertexcount = 0;
#line 1395
  rc = (errcode )0;
#line 1396
  tex = (void *)0;
#line 1397
  v = (float *)((void *)0);
#line 1398
  n = (float *)((void *)0);
#line 1399
  c = (float *)((void *)0);
#line 1401
  tmp = GetString(ph, "NUMVERTS");
#line 1401
  rc |= tmp;
#line 1402
  tmp___0 = GetInt(ph, & vertexcount);
#line 1402
  rc |= tmp___0;
#line 1403
  if (rc != 0U) {
#line 1404
    return (rc);
  }
#line 1406
  fscanf((FILE * __restrict  )ph->ifp, (char const   * __restrict  )"%s", arraytype);
#line 1409
  tmp___2 = stringcmp((char const   *)(arraytype), "COORDS");
#line 1409
  if (tmp___2) {
#line 1416
    printf((char const   * __restrict  )"Expected vertex array coords block\n");
#line 1417
    return ((errcode )4);
  } else {
#line 1410
    tmp___1 = malloc((unsigned long )(vertexcount * 3) * sizeof(float ));
#line 1410
    v = (float *)tmp___1;
#line 1411
    i = 0;
#line 1411
    while (i < vertexcount * 3) {
#line 1412
      fscanf((FILE * __restrict  )ph->ifp, (char const   * __restrict  )"%f %f %f",
             v + i, v + (i + 1), v + (i + 2));
#line 1411
      i += 3;
    }
#line 1414
    fscanf((FILE * __restrict  )ph->ifp, (char const   * __restrict  )"%s", arraytype);
  }
#line 1421
  tmp___4 = stringcmp((char const   *)(arraytype), "NORMALS");
#line 1421
  if (tmp___4) {
#line 1428
    free((void *)v);
#line 1429
    printf((char const   * __restrict  )"Expected vertex array normals block\n");
#line 1430
    return ((errcode )4);
  } else {
#line 1422
    tmp___3 = malloc((unsigned long )(vertexcount * 3) * sizeof(float ));
#line 1422
    n = (float *)tmp___3;
#line 1423
    i = 0;
#line 1423
    while (i < vertexcount * 3) {
#line 1424
      fscanf((FILE * __restrict  )ph->ifp, (char const   * __restrict  )"%f %f %f",
             n + i, n + (i + 1), n + (i + 2));
#line 1423
      i += 3;
    }
#line 1426
    fscanf((FILE * __restrict  )ph->ifp, (char const   * __restrict  )"%s", arraytype);
  }
#line 1435
  tex = ph->defaulttex.tex;
#line 1437
  texusecount = 1;
#line 1438
  done = 0;
#line 1439
  while (! done) {
#line 1441
    tmp___44 = stringcmp((char const   *)(arraytype), "COLORS");
#line 1441
    if (tmp___44) {
#line 1461
      tmp___43 = stringcmp((char const   *)(arraytype), "TEXTURE");
#line 1461
      if (tmp___43) {
#line 1472
        tmp___42 = stringcmp((char const   *)(arraytype), "TRISTRIP");
#line 1472
        if (tmp___42) {
#line 1541
          tmp___41 = stringcmp((char const   *)(arraytype), "TRIMESH");
#line 1541
          if (tmp___41) {
#line 1603
            tmp___40 = stringcmp((char const   *)(arraytype), "END_VERTEXARRAY");
#line 1603
            if (tmp___40) {
#line 1606
              printf((char const   * __restrict  )"Unrecognized vertex array block `%s`\n",
                     arraytype);
#line 1607
              rc |= 4U;
#line 1608
              done = 1;
            } else {
#line 1604
              done = 1;
            }
          } else {
#line 1542
            numfacets = 0;
#line 1545
            tmp___23 = GetInt(ph, & numfacets);
#line 1545
            rc |= tmp___23;
#line 1546
            if (rc != 0U) {
#line 1547
              return ((errcode )4);
            }
#line 1549
            tmp___24 = malloc((unsigned long )(numfacets * 3) * sizeof(int ));
#line 1549
            facets___0 = (int *)tmp___24;
#line 1550
            i = 0;
#line 1550
            while (i < numfacets * 3) {
#line 1551
              fscanf((FILE * __restrict  )ph->ifp, (char const   * __restrict  )"%d %d %d",
                     facets___0 + i, facets___0 + (i + 1), facets___0 + (i + 2));
#line 1550
              i += 3;
            }
#line 1555
            i = 0;
#line 1555
            while (i < numfacets * 3) {
#line 1556
              v0___0 = *(facets___0 + i);
#line 1557
              v1___0 = *(facets___0 + (i + 1));
#line 1558
              v2___0 = *(facets___0 + (i + 2));
#line 1561
              if (v0___0 >= 0) {
#line 1561
                if (v0___0 < vertexcount) {
#line 1561
                  if (v1___0 >= 0) {
#line 1561
                    if (v1___0 < vertexcount) {
#line 1561
                      if (v2___0 >= 0) {
#line 1561
                        if (v2___0 < vertexcount) {
#line 1564
                          v0___0 *= 3;
#line 1565
                          v1___0 *= 3;
#line 1566
                          v2___0 *= 3;
#line 1568
                          if ((unsigned long )c != (unsigned long )((void *)0)) {
#line 1569
                            if (texusecount > 0) {
#line 1570
                              tex = rt_texture_copy_vcstri(scene, tex);
                            }
#line 1571
                            tmp___25 = rt_color((apiflt )*(c + v2___0), (apiflt )*(c + (v2___0 + 1)),
                                                (apiflt )*(c + (v2___0 + 2)));
#line 1571
                            tmp___26 = rt_color((apiflt )*(c + v1___0), (apiflt )*(c + (v1___0 + 1)),
                                                (apiflt )*(c + (v1___0 + 2)));
#line 1571
                            tmp___27 = rt_color((apiflt )*(c + v0___0), (apiflt )*(c + (v0___0 + 1)),
                                                (apiflt )*(c + (v0___0 + 2)));
#line 1571
                            tmp___28 = rt_vector((apiflt )*(n + v2___0), (apiflt )*(n + (v2___0 + 1)),
                                                 (apiflt )*(n + (v2___0 + 2)));
#line 1571
                            tmp___29 = rt_vector((apiflt )*(n + v1___0), (apiflt )*(n + (v1___0 + 1)),
                                                 (apiflt )*(n + (v1___0 + 2)));
#line 1571
                            tmp___30 = rt_vector((apiflt )*(n + v0___0), (apiflt )*(n + (v0___0 + 1)),
                                                 (apiflt )*(n + (v0___0 + 2)));
#line 1571
                            tmp___31 = rt_vector((apiflt )*(v + v2___0), (apiflt )*(v + (v2___0 + 1)),
                                                 (apiflt )*(v + (v2___0 + 2)));
#line 1571
                            tmp___32 = rt_vector((apiflt )*(v + v1___0), (apiflt )*(v + (v1___0 + 1)),
                                                 (apiflt )*(v + (v1___0 + 2)));
#line 1571
                            tmp___33 = rt_vector((apiflt )*(v + v0___0), (apiflt )*(v + (v0___0 + 1)),
                                                 (apiflt )*(v + (v0___0 + 2)));
#line 1571
                            rt_vcstri(scene, tex, tmp___33, tmp___32, tmp___31, tmp___30,
                                      tmp___29, tmp___28, tmp___27, tmp___26, tmp___25);
                          } else {
#line 1582
                            tmp___34 = rt_vector((apiflt )*(n + v2___0), (apiflt )*(n + (v2___0 + 1)),
                                                 (apiflt )*(n + (v2___0 + 2)));
#line 1582
                            tmp___35 = rt_vector((apiflt )*(n + v1___0), (apiflt )*(n + (v1___0 + 1)),
                                                 (apiflt )*(n + (v1___0 + 2)));
#line 1582
                            tmp___36 = rt_vector((apiflt )*(n + v0___0), (apiflt )*(n + (v0___0 + 1)),
                                                 (apiflt )*(n + (v0___0 + 2)));
#line 1582
                            tmp___37 = rt_vector((apiflt )*(v + v2___0), (apiflt )*(v + (v2___0 + 1)),
                                                 (apiflt )*(v + (v2___0 + 2)));
#line 1582
                            tmp___38 = rt_vector((apiflt )*(v + v1___0), (apiflt )*(v + (v1___0 + 1)),
                                                 (apiflt )*(v + (v1___0 + 2)));
#line 1582
                            tmp___39 = rt_vector((apiflt )*(v + v0___0), (apiflt )*(v + (v0___0 + 1)),
                                                 (apiflt )*(v + (v0___0 + 2)));
#line 1582
                            rt_stri(scene, tex, tmp___39, tmp___38, tmp___37, tmp___36,
                                    tmp___35, tmp___34);
                          }
                        } else {
#line 1561
                          goto _L___8;
                        }
                      } else {
#line 1561
                        goto _L___8;
                      }
                    } else {
#line 1561
                      goto _L___8;
                    }
                  } else {
#line 1561
                    goto _L___8;
                  }
                } else {
#line 1561
                  goto _L___8;
                }
              } else {
                _L___8: /* CIL Label */ 
#line 1591
                printf((char const   * __restrict  )"trimesh error: skipping invalid vertex in facet %d\n",
                       i / 3);
#line 1592
                printf((char const   * __restrict  )"  numfacets: %d  vertexcount: %d\n",
                       numfacets, vertexcount);
#line 1593
                printf((char const   * __restrict  )"  verts: %d %d %d\n", v0___0,
                       v1___0, v2___0);
#line 1594
                rc |= 4U;
#line 1595
                done = 1;
#line 1596
                break;
              }
#line 1599
              texusecount ++;
#line 1555
              i += 3;
            }
#line 1602
            free((void *)facets___0);
          }
        } else {
#line 1474
          numv = 0;
#line 1475
          stripaddr[0][0] = 0;
#line 1475
          stripaddr[0][1] = 1;
#line 1475
          stripaddr[0][2] = 2;
#line 1475
          stripaddr[1][0] = 1;
#line 1475
          stripaddr[1][1] = 0;
#line 1475
          stripaddr[1][2] = 2;
#line 1476
          facets = (int *)((void *)0);
#line 1478
          tmp___6 = GetInt(ph, & numv);
#line 1478
          rc |= tmp___6;
#line 1479
          if (rc != 0U) {
#line 1480
            return ((errcode )4);
          }
#line 1482
          tmp___7 = malloc((unsigned long )numv * sizeof(int ));
#line 1482
          facets = (int *)tmp___7;
#line 1483
          i = 0;
#line 1483
          while (i < numv) {
#line 1484
            fscanf((FILE * __restrict  )ph->ifp, (char const   * __restrict  )"%d",
                   facets + i);
#line 1483
            i ++;
          }
#line 1492
          t = 0;
#line 1492
          while (t < numv - 2) {
#line 1494
            v0 = *(facets + (t + stripaddr[t & 1][0]));
#line 1495
            v1 = *(facets + (t + stripaddr[t & 1][1]));
#line 1496
            v2 = *(facets + (t + stripaddr[t & 1][2]));
#line 1498
            if (v0 >= 0) {
#line 1498
              if (v0 < vertexcount) {
#line 1498
                if (v1 >= 0) {
#line 1498
                  if (v1 < vertexcount) {
#line 1498
                    if (v2 >= 0) {
#line 1498
                      if (v2 < vertexcount) {
#line 1501
                        v0 *= 3;
#line 1502
                        v1 *= 3;
#line 1503
                        v2 *= 3;
#line 1505
                        if ((unsigned long )c != (unsigned long )((void *)0)) {
#line 1506
                          if (texusecount > 0) {
#line 1507
                            tex = rt_texture_copy_vcstri(scene, tex);
                          }
#line 1509
                          tmp___8 = rt_color((apiflt )*(c + v2), (apiflt )*(c + (v2 + 1)),
                                             (apiflt )*(c + (v2 + 2)));
#line 1509
                          tmp___9 = rt_color((apiflt )*(c + v1), (apiflt )*(c + (v1 + 1)),
                                             (apiflt )*(c + (v1 + 2)));
#line 1509
                          tmp___10 = rt_color((apiflt )*(c + v0), (apiflt )*(c + (v0 + 1)),
                                              (apiflt )*(c + (v0 + 2)));
#line 1509
                          tmp___11 = rt_vector((apiflt )*(n + v2), (apiflt )*(n + (v2 + 1)),
                                               (apiflt )*(n + (v2 + 2)));
#line 1509
                          tmp___12 = rt_vector((apiflt )*(n + v1), (apiflt )*(n + (v1 + 1)),
                                               (apiflt )*(n + (v1 + 2)));
#line 1509
                          tmp___13 = rt_vector((apiflt )*(n + v0), (apiflt )*(n + (v0 + 1)),
                                               (apiflt )*(n + (v0 + 2)));
#line 1509
                          tmp___14 = rt_vector((apiflt )*(v + v2), (apiflt )*(v + (v2 + 1)),
                                               (apiflt )*(v + (v2 + 2)));
#line 1509
                          tmp___15 = rt_vector((apiflt )*(v + v1), (apiflt )*(v + (v1 + 1)),
                                               (apiflt )*(v + (v1 + 2)));
#line 1509
                          tmp___16 = rt_vector((apiflt )*(v + v0), (apiflt )*(v + (v0 + 1)),
                                               (apiflt )*(v + (v0 + 2)));
#line 1509
                          rt_vcstri(scene, tex, tmp___16, tmp___15, tmp___14, tmp___13,
                                    tmp___12, tmp___11, tmp___10, tmp___9, tmp___8);
                        } else {
#line 1520
                          tmp___17 = rt_vector((apiflt )*(n + v2), (apiflt )*(n + (v2 + 1)),
                                               (apiflt )*(n + (v2 + 2)));
#line 1520
                          tmp___18 = rt_vector((apiflt )*(n + v1), (apiflt )*(n + (v1 + 1)),
                                               (apiflt )*(n + (v1 + 2)));
#line 1520
                          tmp___19 = rt_vector((apiflt )*(n + v0), (apiflt )*(n + (v0 + 1)),
                                               (apiflt )*(n + (v0 + 2)));
#line 1520
                          tmp___20 = rt_vector((apiflt )*(v + v2), (apiflt )*(v + (v2 + 1)),
                                               (apiflt )*(v + (v2 + 2)));
#line 1520
                          tmp___21 = rt_vector((apiflt )*(v + v1), (apiflt )*(v + (v1 + 1)),
                                               (apiflt )*(v + (v1 + 2)));
#line 1520
                          tmp___22 = rt_vector((apiflt )*(v + v0), (apiflt )*(v + (v0 + 1)),
                                               (apiflt )*(v + (v0 + 2)));
#line 1520
                          rt_stri(scene, tex, tmp___22, tmp___21, tmp___20, tmp___19,
                                  tmp___18, tmp___17);
                        }
                      } else {
#line 1498
                        goto _L___3;
                      }
                    } else {
#line 1498
                      goto _L___3;
                    }
                  } else {
#line 1498
                    goto _L___3;
                  }
                } else {
#line 1498
                  goto _L___3;
                }
              } else {
#line 1498
                goto _L___3;
              }
            } else {
              _L___3: /* CIL Label */ 
#line 1529
              printf((char const   * __restrict  )"tristrip error: skipping invalid strip vertex %d\n",
                     t);
#line 1530
              printf((char const   * __restrict  )"  vertexcount: %d\n", vertexcount);
#line 1531
              printf((char const   * __restrict  )"  verts: %d %d %d\n", v0, v1, v2);
#line 1532
              rc |= 4U;
#line 1533
              done = 1;
#line 1534
              break;
            }
#line 1537
            texusecount ++;
#line 1492
            t ++;
          }
#line 1540
          free((void *)facets);
        }
      } else {
#line 1465
        tex = GetTexBody(ph, scene, 0);
#line 1466
        if ((unsigned long )tex == (unsigned long )((void *)0)) {
#line 1467
          printf((char const   * __restrict  )"Failed to parse vertex array texture block\n");
#line 1468
          rc |= 4U;
#line 1469
          done = 1;
        }
#line 1471
        texusecount = 0;
      }
    } else {
#line 1442
      tmp___5 = malloc((unsigned long )(vertexcount * 3) * sizeof(float ));
#line 1442
      c = (float *)tmp___5;
#line 1443
      i = 0;
#line 1443
      while (i < vertexcount * 3) {
#line 1444
        fscanf((FILE * __restrict  )ph->ifp, (char const   * __restrict  )"%f %f %f",
               c + i, c + (i + 1), c + (i + 2));
#line 1443
        i += 3;
      }
    }
#line 1611
    if (! done) {
#line 1612
      fscanf((FILE * __restrict  )ph->ifp, (char const   * __restrict  )"%s", arraytype);
    }
  }
#line 1616
  if ((unsigned long )v != (unsigned long )((void *)0)) {
#line 1617
    free((void *)v);
  }
#line 1618
  if ((unsigned long )n != (unsigned long )((void *)0)) {
#line 1619
    free((void *)n);
  }
#line 1620
  if ((unsigned long )c != (unsigned long )((void *)0)) {
#line 1621
    free((void *)c);
  }
#line 1623
  return (rc);
}
}
#line 1627 "../demosrc/parse.c"
static errcode GetLandScape(parsehandle *ph , SceneHandle scene ) 
{ 
  void *tex ;
  apivector ctr ;
  apiflt wx ;
  apiflt wy ;
  int m ;
  int n ;
  float a ;
  float b ;
  errcode rc ;
  errcode tmp ;
  errcode tmp___0 ;
  errcode tmp___1 ;
  errcode tmp___2 ;

  {
#line 1635
  rc = GetString(ph, "RES");
#line 1636
  fscanf((FILE * __restrict  )ph->ifp, (char const   * __restrict  )"%d %d", & m,
         & n);
#line 1638
  tmp = GetString(ph, "SCALE");
#line 1638
  rc |= tmp;
#line 1639
  fscanf((FILE * __restrict  )ph->ifp, (char const   * __restrict  )"%f %f", & a,
         & b);
#line 1640
  wx = (apiflt )a;
#line 1641
  wy = (apiflt )b;
#line 1643
  tmp___0 = GetString(ph, "CENTER");
#line 1643
  rc |= tmp___0;
#line 1644
  tmp___1 = GetVector(ph, & ctr);
#line 1644
  rc |= tmp___1;
#line 1646
  tmp___2 = GetTexture(ph, scene, & tex);
#line 1646
  rc |= tmp___2;
#line 1648
  rt_landscape(scene, tex, m, n, ctr, wx, wy);
#line 1650
  return (rc);
}
}
#line 1653 "../demosrc/parse.c"
static errcode GetTPolyFile(parsehandle *ph , SceneHandle scene ) 
{ 
  void *tex ;
  char ifname[255] ;
  FILE *ifp ;
  int v ;
  RotMat RotA ;
  errcode rc ;
  int totalpolys ;
  apivector ctr ;
  apivector rot ;
  apivector scale ;
  apivector v0 ;
  apivector v1 ;
  apivector v2 ;
  errcode tmp ;
  errcode tmp___0 ;
  errcode tmp___1 ;
  errcode tmp___2 ;
  errcode tmp___3 ;
  errcode tmp___4 ;
  errcode tmp___5 ;
  errcode tmp___6 ;
  errcode tmp___7 ;
  errcode tmp___8 ;
  int tmp___9 ;

  {
#line 1659
  rc = (errcode )0;
#line 1660
  totalpolys = 0;
#line 1661
  ctr.x = (apiflt )0;
#line 1661
  ctr.y = (apiflt )0;
#line 1661
  ctr.z = (apiflt )0;
#line 1662
  rot.x = (apiflt )0;
#line 1662
  rot.y = (apiflt )0;
#line 1662
  rot.z = (apiflt )0;
#line 1663
  scale.x = (apiflt )0;
#line 1663
  scale.y = (apiflt )0;
#line 1663
  scale.z = (apiflt )0;
#line 1664
  v0.x = (apiflt )0;
#line 1664
  v0.y = (apiflt )0;
#line 1664
  v0.z = (apiflt )0;
#line 1665
  v1.x = (apiflt )0;
#line 1665
  v1.y = (apiflt )0;
#line 1665
  v1.z = (apiflt )0;
#line 1666
  v2.x = (apiflt )0;
#line 1666
  v2.y = (apiflt )0;
#line 1666
  v2.z = (apiflt )0;
#line 1668
  rc = GetString(ph, "SCALE");
#line 1669
  tmp = GetVector(ph, & scale);
#line 1669
  rc |= tmp;
#line 1671
  tmp___0 = GetString(ph, "ROT");
#line 1671
  rc |= tmp___0;
#line 1672
  tmp___1 = GetVector(ph, & rot);
#line 1672
  rc |= tmp___1;
#line 1674
  degvectoradvec(& rot);
#line 1675
  InitRot3d(& RotA, rot.x, rot.y, rot.z);
#line 1677
  tmp___2 = GetString(ph, "CENTER");
#line 1677
  rc |= tmp___2;
#line 1678
  tmp___3 = GetVector(ph, & ctr);
#line 1678
  rc |= tmp___3;
#line 1680
  tmp___4 = GetString(ph, "FILE");
#line 1680
  rc |= tmp___4;
#line 1681
  fscanf((FILE * __restrict  )ph->ifp, (char const   * __restrict  )"%s", ifname);
#line 1683
  tmp___5 = GetTexture(ph, scene, & tex);
#line 1683
  rc |= tmp___5;
#line 1685
  ifp = fopen((char const   * __restrict  )(ifname), (char const   * __restrict  )"r");
#line 1685
  if ((unsigned long )ifp == (unsigned long )((void *)0)) {
#line 1686
    printf((char const   * __restrict  )"Can\'t open data file %s for input!! Aborting...\n",
           ifname);
#line 1687
    return ((errcode )2);
  }
#line 1690
  while (1) {
#line 1690
    tmp___9 = feof(ifp);
#line 1690
    if (tmp___9) {
#line 1690
      break;
    }
#line 1691
    fscanf((FILE * __restrict  )ifp, (char const   * __restrict  )"%d", & v);
#line 1692
    if (v != 3) {
#line 1692
      break;
    }
#line 1694
    totalpolys ++;
#line 1695
    v = 0;
#line 1697
    tmp___6 = GetVector(ph, & v0);
#line 1697
    rc |= tmp___6;
#line 1698
    tmp___7 = GetVector(ph, & v1);
#line 1698
    rc |= tmp___7;
#line 1699
    tmp___8 = GetVector(ph, & v2);
#line 1699
    rc |= tmp___8;
#line 1701
    Scale3d(& scale, & v0);
#line 1702
    Scale3d(& scale, & v1);
#line 1703
    Scale3d(& scale, & v2);
#line 1705
    Rotate3d(& RotA, & v0);
#line 1706
    Rotate3d(& RotA, & v1);
#line 1707
    Rotate3d(& RotA, & v2);
#line 1709
    Trans3d(& ctr, & v0);
#line 1710
    Trans3d(& ctr, & v1);
#line 1711
    Trans3d(& ctr, & v2);
#line 1713
    rt_tri(scene, tex, v1, v0, v2);
  }
#line 1716
  fclose(ifp);
#line 1718
  return (rc);
}
}
#line 1722 "../demosrc/parse.c"
static errcode GetClipGroup(parsehandle *ph , SceneHandle scene ) 
{ 
  char objtype[256] ;
  int tmp ;
  int numplanes ;
  int i ;
  float *planes ;
  int tmp___0 ;
  void *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 1725
  tmp = fscanf((FILE * __restrict  )ph->ifp, (char const   * __restrict  )"%s", objtype);
#line 1725
  if (tmp == -1) {
#line 1726
    return ((errcode )8);
  }
#line 1729
  tmp___3 = stringcmp((char const   *)(objtype), "NUMPLANES");
#line 1729
  if (! tmp___3) {
#line 1733
    tmp___0 = fscanf((FILE * __restrict  )ph->ifp, (char const   * __restrict  )"%d",
                     & numplanes);
#line 1733
    if (tmp___0 != 1) {
#line 1734
      return ((errcode )4);
    }
#line 1736
    tmp___1 = malloc((unsigned long )(numplanes * 4) * sizeof(float ));
#line 1736
    planes = (float *)tmp___1;
#line 1738
    i = 0;
#line 1738
    while (i < numplanes * 4) {
#line 1739
      tmp___2 = fscanf((FILE * __restrict  )ph->ifp, (char const   * __restrict  )"%f",
                       planes + i);
#line 1739
      if (tmp___2 != 1) {
#line 1740
        return ((errcode )4);
      }
#line 1738
      i ++;
    }
#line 1743
    rt_clip_fv(scene, numplanes, planes);
#line 1744
    free((void *)planes);
#line 1746
    return ((errcode )0);
  }
#line 1749
  return ((errcode )4);
}
}
#line 1753 "../demosrc/parse.c"
static errcode GetClipGroupEnd(parsehandle *ph , SceneHandle scene ) 
{ 


  {
#line 1754
  rt_clip_off(scene);
#line 1755
  return ((errcode )0);
}
}
#line 1 "nffparse.o"
#pragma merger("0","/tmp/cil-90BPEgne.i","-m64,-Wall,-O3,-fomit-frame-pointer,-ffast-math")
#line 150 "/usr/include/x86_64-linux-gnu/bits/mathinline.h"
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__, __always_inline__)) __signbitl)(long double __x )  __attribute__((__const__)) ;
#line 150 "/usr/include/x86_64-linux-gnu/bits/mathinline.h"
__inline extern int ( __attribute__((__leaf__, __always_inline__)) __signbitl)(long double __x ) 
{ 
  union __anonunion___u_8___0 __u ;

  {
#line 153
  __u.__l = __x;
#line 154
  return ((__u.__i[2] & 32768) != 0);
}
}
#line 17 "../demosrc/nffparse.c"
static void *curtexture  ;
#line 18 "../demosrc/nffparse.c"
static apicolor backgr  ;
#line 21
int NFFGetObject(FILE *dfile , SceneHandle scene ) ;
#line 24 "../demosrc/nffparse.c"
int NFFstringcmp(char *a , char *b ) 
{ 
  int i ;
  int s ;
  int l ;
  size_t tmp ;
  size_t tmp___0 ;
  int __res ;
  __int32_t const   **tmp___2 ;
  int __res___0 ;
  __int32_t const   **tmp___4 ;

  {
#line 27
  tmp = strlen((char const   *)a);
#line 27
  s = (int )tmp;
#line 28
  tmp___0 = strlen((char const   *)b);
#line 28
  l = (int )tmp___0;
#line 30
  if (s != l) {
#line 31
    return (1);
  }
#line 33
  i = 0;
#line 33
  while (i < s) {
#line 34
    if (sizeof(*(a + i)) > 1UL) {
#line 34
      __res = toupper((int )*(a + i));
    } else {
#line 34
      tmp___2 = __ctype_toupper_loc();
#line 34
      __res = (int )*(*tmp___2 + (int )*(a + i));
    }
#line 34
    if (sizeof(*(b + i)) > 1UL) {
#line 34
      __res___0 = toupper((int )*(b + i));
    } else {
#line 34
      tmp___4 = __ctype_toupper_loc();
#line 34
      __res___0 = (int )*(*tmp___4 + (int )*(b + i));
    }
#line 34
    if (__res != __res___0) {
#line 35
      return (1);
    }
#line 33
    i ++;
  }
#line 38
  return (0);
}
}
#line 42 "../demosrc/nffparse.c"
void NFFGetString(FILE *dfile , char *string ) 
{ 
  char data[100] ;
  int tmp ;

  {
#line 45
  fscanf((FILE * __restrict  )dfile, (char const   * __restrict  )"%s", data);
#line 47
  tmp = NFFstringcmp(data, string);
#line 47
  if (tmp != 0) {
#line 48
    printf((char const   * __restrict  )"parse: Expected %s, got %s \n", string, data);
#line 49
    printf((char const   * __restrict  )"Rendering terminated. \n");
#line 50
    exit(1);
  }
#line 52
  return;
}
}
#line 54 "../demosrc/nffparse.c"
void NFFGetVector(FILE *dfile , apivector *v1 ) 
{ 
  float a ;
  float b ;
  float c ;

  {
#line 57
  fscanf((FILE * __restrict  )dfile, (char const   * __restrict  )"%f %f %f", & a,
         & b, & c);
#line 58
  v1->x = (apiflt )a;
#line 59
  v1->y = (apiflt )b;
#line 60
  v1->z = (apiflt )c;
#line 61
  return;
}
}
#line 63 "../demosrc/nffparse.c"
unsigned int ParseNFF(char *nffname , SceneHandle scene ) 
{ 
  FILE *dfile ;
  int tmp ;

  {
#line 65
  backgr.r = (float )0.0;
#line 66
  backgr.g = (float )0.0;
#line 67
  backgr.b = (float )0.0;
#line 69
  if ((unsigned long )nffname == (unsigned long )((void *)0)) {
#line 70
    return (1U);
  } else {
#line 73
    dfile = fopen((char const   * __restrict  )nffname, (char const   * __restrict  )"r");
#line 74
    if ((unsigned long )dfile == (unsigned long )((void *)0)) {
#line 75
      return (1U);
    }
  }
#line 79
  while (1) {
#line 79
    tmp = NFFGetObject(dfile, scene);
#line 79
    if (! (tmp == 0)) {
#line 79
      break;
    }
  }
#line 81
  rt_background(scene, backgr);
#line 83
  return (0U);
}
}
#line 86 "../demosrc/nffparse.c"
int NFFGetScenedefs(FILE *dfile , SceneHandle scene ) 
{ 
  apivector Ccenter ;
  apivector Cview ;
  apivector Cup ;
  apiflt zoom ;
  apiflt aspectratio ;
  int raydepth ;
  int antialiasing ;
  int xres ;
  int yres ;
  int verbose ;
  apivector lookat ;
  float vangle ;
  float hither ;

  {
#line 94
  NFFGetString(dfile, (char *)"from");
#line 95
  NFFGetVector(dfile, & Ccenter);
#line 97
  NFFGetString(dfile, (char *)"at");
#line 98
  NFFGetVector(dfile, & lookat);
#line 99
  Cview.x = lookat.x - Ccenter.x;
#line 100
  Cview.y = lookat.y - Ccenter.y;
#line 101
  Cview.z = lookat.z - Ccenter.z;
#line 103
  NFFGetString(dfile, (char *)"up");
#line 104
  NFFGetVector(dfile, & Cup);
#line 106
  NFFGetString(dfile, (char *)"angle");
#line 107
  fscanf((FILE * __restrict  )dfile, (char const   * __restrict  )"%f", & vangle);
#line 108
  zoom = 1.0;
#line 109
  aspectratio = 1.0;
#line 111
  NFFGetString(dfile, (char *)"hither");
#line 112
  fscanf((FILE * __restrict  )dfile, (char const   * __restrict  )"%f", & hither);
#line 114
  NFFGetString(dfile, (char *)"resolution");
#line 115
  fscanf((FILE * __restrict  )dfile, (char const   * __restrict  )"%d %d", & xres,
         & yres);
#line 117
  antialiasing = 0;
#line 118
  raydepth = 6;
#line 119
  verbose = 0;
#line 121
  rt_outputfile(scene, "outfile.tga");
#line 122
  rt_resolution(scene, xres, yres);
#line 123
  rt_verbose(scene, verbose);
#line 125
  rt_camera_setup(scene, zoom, aspectratio, antialiasing, raydepth, Ccenter, Cview,
                  Cup);
#line 128
  rt_background(scene, backgr);
#line 130
  return (0);
}
}
#line 134 "../demosrc/nffparse.c"
int NFFGetBackground(FILE *dfile , SceneHandle scene ) 
{ 
  float r ;
  float g ;
  float b ;

  {
#line 136
  fscanf((FILE * __restrict  )dfile, (char const   * __restrict  )"%f %f %f", & r,
         & g, & b);
#line 137
  backgr.r = r;
#line 138
  backgr.g = g;
#line 139
  backgr.b = b;
#line 141
  return (0);
}
}
#line 144 "../demosrc/nffparse.c"
int NFFGetLight(FILE *dfile , SceneHandle scene ) 
{ 
  apiflt rad ;
  apivector ctr ;
  apitexture tex ;
  float r ;
  float g ;
  float b ;
  void *tmp ;

  {
#line 150
  NFFGetVector(dfile, & ctr);
#line 151
  rad = 1.0;
#line 153
  b = (float )1.0;
#line 153
  g = b;
#line 153
  r = g;
#line 155
  fscanf((FILE * __restrict  )dfile, (char const   * __restrict  )"%f %f %f", & r,
         & g, & b);
#line 156
  tex.col.r = r;
#line 157
  tex.col.g = g;
#line 158
  tex.col.b = b;
#line 160
  tmp = rt_texture(scene, & tex);
#line 160
  rt_light(scene, tmp, ctr, rad);
#line 162
  return (0);
}
}
#line 165 "../demosrc/nffparse.c"
int NFFGetTexture(FILE *dfile , SceneHandle scene ) 
{ 
  apitexture tex ;
  float r ;
  float g ;
  float b ;
  float Kd ;
  float Ks ;
  float Shine ;
  float T ;
  float IOR ;

  {
#line 169
  fscanf((FILE * __restrict  )dfile, (char const   * __restrict  )"%f %f %f %f %f %f %f %f",
         & r, & g, & b, & Kd, & Ks, & Shine, & T, & IOR);
#line 171
  tex.col.r = r;
#line 172
  tex.col.g = g;
#line 173
  tex.col.b = b;
#line 174
  tex.ambient = 0.1;
#line 175
  tex.diffuse = (apiflt )Kd;
#line 176
  tex.specular = (apiflt )Ks;
#line 177
  if ((double )T > 0.99) {
#line 177
    tex.opacity = 0.0;
  } else {
#line 177
    tex.opacity = 1.0 - (double )T;
  }
#line 178
  tex.texturefunc = 0;
#line 180
  curtexture = rt_texture(scene, & tex);
#line 182
  return (0);
}
}
#line 185 "../demosrc/nffparse.c"
int NFFGetCylCone(FILE *dfile , SceneHandle scene ) 
{ 
  apivector pnt1 ;
  apivector pnt2 ;
  apivector ctr ;
  apivector axis ;
  float baserad ;
  float apexrad ;

  {
#line 190
  NFFGetVector(dfile, & pnt1);
#line 191
  fscanf((FILE * __restrict  )dfile, (char const   * __restrict  )"%f", & baserad);
#line 193
  NFFGetVector(dfile, & pnt2);
#line 194
  fscanf((FILE * __restrict  )dfile, (char const   * __restrict  )"%f", & apexrad);
#line 196
  ctr = pnt1;
#line 197
  axis.x = pnt2.x - pnt1.x;
#line 198
  axis.y = pnt2.y - pnt1.y;
#line 199
  axis.z = pnt2.z - pnt1.z;
#line 202
  rt_fcylinder(scene, curtexture, ctr, axis, (apiflt )baserad);
#line 204
  return (0);
}
}
#line 207 "../demosrc/nffparse.c"
int NFFGetSphere(FILE *dfile , SceneHandle scene ) 
{ 
  apiflt rad ;
  apivector ctr ;
  float a ;

  {
#line 212
  NFFGetVector(dfile, & ctr);
#line 213
  fscanf((FILE * __restrict  )dfile, (char const   * __restrict  )"%f", & a);
#line 214
  rad = (apiflt )a;
#line 216
  rt_sphere(scene, curtexture, ctr, rad);
#line 218
  return (0);
}
}
#line 221 "../demosrc/nffparse.c"
int NFFGetPolygon(FILE *dfile , SceneHandle scene ) 
{ 
  int numverts ;
  int i ;
  apivector v0 ;
  apivector vold ;
  apivector vnew ;

  {
#line 225
  fscanf((FILE * __restrict  )dfile, (char const   * __restrict  )"%d", & numverts);
#line 226
  NFFGetVector(dfile, & v0);
#line 227
  NFFGetVector(dfile, & vold);
#line 229
  i = 2;
#line 229
  while (i < numverts) {
#line 230
    NFFGetVector(dfile, & vnew);
#line 231
    rt_tri(scene, curtexture, v0, vold, vnew);
#line 232
    vold = vnew;
#line 229
    i ++;
  }
#line 235
  return (0);
}
}
#line 238 "../demosrc/nffparse.c"
int NFFGetPatch(FILE *dfile , SceneHandle scene ) 
{ 
  int numverts ;
  int i ;
  apivector v0 ;
  apivector n0 ;
  apivector vold ;
  apivector nold ;
  apivector vnew ;
  apivector nnew ;

  {
#line 244
  fscanf((FILE * __restrict  )dfile, (char const   * __restrict  )"%d", & numverts);
#line 245
  NFFGetVector(dfile, & v0);
#line 246
  NFFGetVector(dfile, & n0);
#line 247
  NFFGetVector(dfile, & vold);
#line 248
  NFFGetVector(dfile, & nold);
#line 250
  i = 2;
#line 250
  while (i < numverts) {
#line 251
    NFFGetVector(dfile, & vnew);
#line 252
    NFFGetVector(dfile, & nnew);
#line 253
    rt_stri(scene, curtexture, v0, vold, vnew, n0, nold, nnew);
#line 254
    vold = vnew;
#line 255
    nold = nnew;
#line 250
    i ++;
  }
#line 258
  return (0);
}
}
#line 261 "../demosrc/nffparse.c"
int NFFGetObject(FILE *dfile , SceneHandle scene ) 
{ 
  char objtype[80] ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;

  {
#line 263
  tmp = fscanf((FILE * __restrict  )dfile, (char const   * __restrict  )"%s", objtype);
#line 263
  if (tmp != 1) {
#line 264
    return (3);
  }
#line 266
  tmp___1 = NFFstringcmp(objtype, (char *)"v");
#line 266
  if (! tmp___1) {
#line 267
    tmp___0 = NFFGetScenedefs(dfile, scene);
#line 267
    return (tmp___0);
  }
#line 269
  tmp___3 = NFFstringcmp(objtype, (char *)"b");
#line 269
  if (! tmp___3) {
#line 270
    tmp___2 = NFFGetBackground(dfile, scene);
#line 270
    return (tmp___2);
  }
#line 272
  tmp___5 = NFFstringcmp(objtype, (char *)"l");
#line 272
  if (! tmp___5) {
#line 273
    tmp___4 = NFFGetLight(dfile, scene);
#line 273
    return (tmp___4);
  }
#line 275
  tmp___7 = NFFstringcmp(objtype, (char *)"f");
#line 275
  if (! tmp___7) {
#line 276
    tmp___6 = NFFGetTexture(dfile, scene);
#line 276
    return (tmp___6);
  }
#line 278
  tmp___9 = NFFstringcmp(objtype, (char *)"s");
#line 278
  if (! tmp___9) {
#line 279
    tmp___8 = NFFGetSphere(dfile, scene);
#line 279
    return (tmp___8);
  }
#line 281
  tmp___11 = NFFstringcmp(objtype, (char *)"c");
#line 281
  if (! tmp___11) {
#line 282
    tmp___10 = NFFGetCylCone(dfile, scene);
#line 282
    return (tmp___10);
  }
#line 284
  tmp___13 = NFFstringcmp(objtype, (char *)"p");
#line 284
  if (! tmp___13) {
#line 285
    tmp___12 = NFFGetPolygon(dfile, scene);
#line 285
    return (tmp___12);
  }
#line 287
  tmp___15 = NFFstringcmp(objtype, (char *)"pp");
#line 287
  if (! tmp___15) {
#line 288
    tmp___14 = NFFGetPatch(dfile, scene);
#line 288
    return (tmp___14);
  }
#line 291
  return (3);
}
}
#line 1 "glwin.o"
#pragma merger("0","/tmp/cil-LVxlts9u.i","-m64,-Wall,-O3,-fomit-frame-pointer,-ffast-math")
#line 427 "../demosrc/glwin.c"
void *glwin_create(char const   *wintitle , int width , int height ) 
{ 


  {
#line 428
  return ((void *)0);
}
}
#line 431 "../demosrc/glwin.c"
void glwin_destroy(void *voidhandle ) 
{ 


  {
#line 432
  return;
}
}
#line 435 "../demosrc/glwin.c"
void glwin_swap_buffers(void *voidhandle ) 
{ 


  {
#line 436
  return;
}
}
#line 439 "../demosrc/glwin.c"
int glwin_handle_events(void *voidhandle ) 
{ 


  {
#line 440
  return (0);
}
}
#line 443 "../demosrc/glwin.c"
void glwin_draw_image(void *voidhandle , int xsize , int ysize , unsigned char *img ) 
{ 


  {
#line 444
  return;
}
}
#line 1 "spaceball.o"
#pragma merger("0","/tmp/cil-S0s16Ujv.i","-m64,-Wall,-O3,-fomit-frame-pointer,-ffast-math")
#line 1 "trackball.o"
#pragma merger("0","/tmp/cil-GCnorR0P.i","-m64,-Wall,-O3,-fomit-frame-pointer,-ffast-math")
#line 56 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h"
extern  __attribute__((__nothrow__)) double ( __attribute__((__leaf__)) asin)(double __x )  __asm__("__asin_finite")  ;
#line 157
extern  __attribute__((__nothrow__)) double ( __attribute__((__leaf__)) sqrt)(double __x )  __asm__("__sqrt_finite")  ;
#line 150 "/usr/include/x86_64-linux-gnu/bits/mathinline.h"
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__, __always_inline__)) __signbitl)(long double __x )  __attribute__((__const__)) ;
#line 150 "/usr/include/x86_64-linux-gnu/bits/mathinline.h"
__inline extern int ( __attribute__((__leaf__, __always_inline__)) __signbitl)(long double __x ) 
{ 
  union __anonunion___u_3 __u ;

  {
#line 153
  __u.__l = __x;
#line 154
  return ((__u.__i[2] & 32768) != 0);
}
}
#line 50 "../demosrc/trackball.h"
void trackball(float *q , float p1x , float p1y , float p2x , float p2y ) ;
#line 61
void add_quats(float *q1 , float *q2 , float *dest ) ;
#line 68
void build_rotmatrix(float (*m)[4] , float *q ) ;
#line 76
void axis_to_quat(float *a , float phi , float *q ) ;
#line 67 "../demosrc/trackball.c"
static float tb_project_to_sphere(float r , float x , float y ) ;
#line 68
static void normalize_quat(float *q ) ;
#line 70 "../demosrc/trackball.c"
void vzero(float *v ) 
{ 


  {
#line 73
  *(v + 0) = (float )0.0;
#line 74
  *(v + 1) = (float )0.0;
#line 75
  *(v + 2) = (float )0.0;
#line 76
  return;
}
}
#line 78 "../demosrc/trackball.c"
void vset(float *v , float x , float y , float z ) 
{ 


  {
#line 81
  *(v + 0) = x;
#line 82
  *(v + 1) = y;
#line 83
  *(v + 2) = z;
#line 84
  return;
}
}
#line 86 "../demosrc/trackball.c"
void vsub(float const   *src1 , float const   *src2 , float *dst ) 
{ 


  {
#line 89
  *(dst + 0) = (float )(*(src1 + 0) - *(src2 + 0));
#line 90
  *(dst + 1) = (float )(*(src1 + 1) - *(src2 + 1));
#line 91
  *(dst + 2) = (float )(*(src1 + 2) - *(src2 + 2));
#line 92
  return;
}
}
#line 94 "../demosrc/trackball.c"
void vcopy(float const   *v1 , float *v2 ) 
{ 
  register int i ;

  {
#line 98
  i = 0;
#line 98
  while (i < 3) {
#line 99
    *(v2 + i) = (float )*(v1 + i);
#line 98
    i ++;
  }
#line 100
  return;
}
}
#line 102 "../demosrc/trackball.c"
void vcross(float const   *v1 , float const   *v2 , float *cross ) 
{ 
  float temp[3] ;

  {
#line 107
  temp[0] = (float )(*(v1 + 1) * *(v2 + 2) - *(v1 + 2) * *(v2 + 1));
#line 108
  temp[1] = (float )(*(v1 + 2) * *(v2 + 0) - *(v1 + 0) * *(v2 + 2));
#line 109
  temp[2] = (float )(*(v1 + 0) * *(v2 + 1) - *(v1 + 1) * *(v2 + 0));
#line 110
  vcopy((float const   *)(temp), cross);
#line 111
  return;
}
}
#line 113 "../demosrc/trackball.c"
float vlength(float const   *v ) 
{ 
  double tmp ;

  {
#line 116
  tmp = sqrt((double )((*(v + 0) * *(v + 0) + *(v + 1) * *(v + 1)) + *(v + 2) * *(v + 2)));
#line 116
  return ((float )tmp);
}
}
#line 119 "../demosrc/trackball.c"
void vscale(float *v , float div ) 
{ 


  {
#line 122
  *(v + 0) *= div;
#line 123
  *(v + 1) *= div;
#line 124
  *(v + 2) *= div;
#line 125
  return;
}
}
#line 127 "../demosrc/trackball.c"
void vnormal(float *v ) 
{ 
  float tmp ;

  {
#line 130
  tmp = vlength((float const   *)v);
#line 130
  vscale(v, (float )(1.0 / (double )tmp));
#line 131
  return;
}
}
#line 133 "../demosrc/trackball.c"
float vdot(float const   *v1 , float const   *v2 ) 
{ 


  {
#line 136
  return ((float )((*(v1 + 0) * *(v2 + 0) + *(v1 + 1) * *(v2 + 1)) + *(v1 + 2) * *(v2 + 2)));
}
}
#line 139 "../demosrc/trackball.c"
void vadd(float const   *src1 , float const   *src2 , float *dst ) 
{ 


  {
#line 142
  *(dst + 0) = (float )(*(src1 + 0) + *(src2 + 0));
#line 143
  *(dst + 1) = (float )(*(src1 + 1) + *(src2 + 1));
#line 144
  *(dst + 2) = (float )(*(src1 + 2) + *(src2 + 2));
#line 145
  return;
}
}
#line 159 "../demosrc/trackball.c"
void trackball(float *q , float p1x , float p1y , float p2x , float p2y ) 
{ 
  float a[3] ;
  float phi ;
  float p1[3] ;
  float p2[3] ;
  float d[3] ;
  float t ;
  float tmp ;
  float tmp___0 ;
  float tmp___1 ;
  double tmp___2 ;

  {
#line 167
  if (p1x == p2x) {
#line 167
    if (p1y == p2y) {
#line 169
      vzero((float *)q);
#line 170
      *(q + 3) = (float )1.0;
#line 171
      return;
    }
  }
#line 178
  tmp = tb_project_to_sphere((float )0.8, p1x, p1y);
#line 178
  vset(p1, p1x, p1y, tmp);
#line 179
  tmp___0 = tb_project_to_sphere((float )0.8, p2x, p2y);
#line 179
  vset(p2, p2x, p2y, tmp___0);
#line 184
  vcross((float const   *)(p2), (float const   *)(p1), a);
#line 189
  vsub((float const   *)(p1), (float const   *)(p2), d);
#line 190
  tmp___1 = vlength((float const   *)(d));
#line 190
  t = (float )((double )tmp___1 / (2.0 * 0.8));
#line 195
  if ((double )t > 1.0) {
#line 195
    t = (float )1.0;
  }
#line 196
  if ((double )t < - 1.0) {
#line 196
    t = (float )(- 1.0);
  }
#line 197
  tmp___2 = asin((double )t);
#line 197
  phi = (float )(2.0 * tmp___2);
#line 199
  axis_to_quat((float *)(a), phi, q);
#line 200
  return;
}
}
#line 205 "../demosrc/trackball.c"
void axis_to_quat(float *a , float phi , float *q ) 
{ 
  double tmp ;
  double tmp___0 ;

  {
#line 208
  vnormal((float *)a);
#line 209
  vcopy((float const   *)a, (float *)q);
#line 210
  tmp = sin((double )phi / 2.0);
#line 210
  vscale((float *)q, (float )tmp);
#line 211
  tmp___0 = cos((double )phi / 2.0);
#line 211
  *(q + 3) = (float )tmp___0;
#line 212
  return;
}
}
#line 218 "../demosrc/trackball.c"
static float tb_project_to_sphere(float r , float x , float y ) 
{ 
  float d ;
  float t ;
  float z ;
  double tmp ;
  double tmp___0 ;

  {
#line 223
  tmp = sqrt((double )(x * x + y * y));
#line 223
  d = (float )tmp;
#line 224
  if ((double )d < (double )r * 0.70710678118654752440) {
#line 225
    tmp___0 = sqrt((double )(r * r - d * d));
#line 225
    z = (float )tmp___0;
  } else {
#line 227
    t = (float )((double )r / 1.41421356237309504880);
#line 228
    z = (t * t) / d;
  }
#line 230
  return (z);
}
}
#line 249 "../demosrc/trackball.c"
static int count  =    0;
#line 246 "../demosrc/trackball.c"
void add_quats(float *q1 , float *q2 , float *dest ) 
{ 
  float t1[4] ;
  float t2[4] ;
  float t3[4] ;
  float tf[4] ;
  float tmp ;

  {
#line 253
  vcopy((float const   *)q1, t1);
#line 254
  vscale(t1, *(q2 + 3));
#line 256
  vcopy((float const   *)q2, t2);
#line 257
  vscale(t2, *(q1 + 3));
#line 259
  vcross((float const   *)q2, (float const   *)q1, t3);
#line 260
  vadd((float const   *)(t1), (float const   *)(t2), tf);
#line 261
  vadd((float const   *)(t3), (float const   *)(tf), tf);
#line 262
  tmp = vdot((float const   *)q1, (float const   *)q2);
#line 262
  tf[3] = *(q1 + 3) * *(q2 + 3) - tmp;
#line 264
  *(dest + 0) = tf[0];
#line 265
  *(dest + 1) = tf[1];
#line 266
  *(dest + 2) = tf[2];
#line 267
  *(dest + 3) = tf[3];
#line 269
  count ++;
#line 269
  if (count > 97) {
#line 270
    count = 0;
#line 271
    normalize_quat(dest);
  }
#line 273
  return;
}
}
#line 287 "../demosrc/trackball.c"
static void normalize_quat(float *q ) 
{ 
  int i ;
  float mag ;

  {
#line 293
  mag = ((*(q + 0) * *(q + 0) + *(q + 1) * *(q + 1)) + *(q + 2) * *(q + 2)) + *(q + 3) * *(q + 3);
#line 294
  i = 0;
#line 294
  while (i < 4) {
#line 294
    *(q + i) /= mag;
#line 294
    i ++;
  }
#line 295
  return;
}
}
#line 301 "../demosrc/trackball.c"
void build_rotmatrix(float (*m)[4] , float *q ) 
{ 


  {
#line 304
  (*(m + 0))[0] = (float )(1.0 - 2.0 * (double )(*(q + 1) * *(q + 1) + *(q + 2) * *(q + 2)));
#line 305
  (*(m + 0))[1] = (float )(2.0 * (double )(*(q + 0) * *(q + 1) - *(q + 2) * *(q + 3)));
#line 306
  (*(m + 0))[2] = (float )(2.0 * (double )(*(q + 2) * *(q + 0) + *(q + 1) * *(q + 3)));
#line 307
  (*(m + 0))[3] = (float )0.0;
#line 309
  (*(m + 1))[0] = (float )(2.0 * (double )(*(q + 0) * *(q + 1) + *(q + 2) * *(q + 3)));
#line 310
  (*(m + 1))[1] = (float )(1.0 - 2.0 * (double )(*(q + 2) * *(q + 2) + *(q + 0) * *(q + 0)));
#line 311
  (*(m + 1))[2] = (float )(2.0 * (double )(*(q + 1) * *(q + 2) - *(q + 0) * *(q + 3)));
#line 312
  (*(m + 1))[3] = (float )0.0;
#line 314
  (*(m + 2))[0] = (float )(2.0 * (double )(*(q + 2) * *(q + 0) - *(q + 1) * *(q + 3)));
#line 315
  (*(m + 2))[1] = (float )(2.0 * (double )(*(q + 1) * *(q + 2) + *(q + 0) * *(q + 3)));
#line 316
  (*(m + 2))[2] = (float )(1.0 - 2.0 * (double )(*(q + 1) * *(q + 1) + *(q + 0) * *(q + 0)));
#line 317
  (*(m + 2))[3] = (float )0.0;
#line 319
  (*(m + 3))[0] = (float )0.0;
#line 320
  (*(m + 3))[1] = (float )0.0;
#line 321
  (*(m + 3))[2] = (float )0.0;
#line 322
  (*(m + 3))[3] = (float )1.0;
#line 323
  return;
}
}
#line 1 "mgfparse.o"
#pragma merger("0","/tmp/cil-6t_eipfA.i","-m64,-Wall,-O3,-fomit-frame-pointer,-ffast-math")
#line 1 "ac3dparse.o"
#pragma merger("0","/tmp/cil-PfO9EtV2.i","-m64,-Wall,-O3,-fomit-frame-pointer,-ffast-math")
#line 150 "/usr/include/x86_64-linux-gnu/bits/mathinline.h"
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__, __always_inline__)) __signbitl)(long double __x )  __attribute__((__const__)) ;
#line 150 "/usr/include/x86_64-linux-gnu/bits/mathinline.h"
__inline extern int ( __attribute__((__leaf__, __always_inline__)) __signbitl)(long double __x ) 
{ 
  union __anonunion___u_8___1 __u ;

  {
#line 153
  __u.__l = __x;
#line 154
  return ((__u.__i[2] & 32768) != 0);
}
}
#line 37 "../demosrc/ac3dparse.h"
static errcode add_texture___0(void *tex , char *name ) ;
#line 39
static void tlist_add_tri(tri_list **tlist , int v0 , int v1 , int v2 , int smooth ,
                          int texnum ) ;
#line 41
static void tlist_delete(tri_list **tlist ) ;
#line 42
static void clear_normals(apivector *normals , int numverts ) ;
#line 43
static void normalize(apivector *vec ) ;
#line 44
static void renormalize_normals(apivector *normals , int numverts ) ;
#line 45
static apivector tri_normal(apivector *v0 , apivector *v1 , apivector *v2 ) ;
#line 46
static void gen_triangles(SceneHandle scene , tri_list *tlist , apivector *vertex ,
                          apivector *normal ) ;
#line 48
static errcode GetMaterial(FILE *dfile , SceneHandle scene ) ;
#line 49
static errcode GetString___0(FILE *dfile , char *string ) ;
#line 50
static errcode GetScenedefs___0(FILE *dfile , SceneHandle scene ) ;
#line 51
static errcode GetScene(FILE *dfile , SceneHandle scene ) ;
#line 52
static errcode GetObject___0(FILE *dfile , SceneHandle scene ) ;
#line 20 "../demosrc/ac3dparse.c"
static texentry___0 textable[8192]  ;
#line 21 "../demosrc/ac3dparse.c"
static int numtextures  ;
#line 22 "../demosrc/ac3dparse.c"
static int numobjectsparsed  ;
#line 23 "../demosrc/ac3dparse.c"
static apicolor scenebackcol  ;
#line 25 "../demosrc/ac3dparse.c"
static int stringcmp___0(char *a , char *b ) 
{ 
  int i ;
  int s ;
  int l ;
  size_t tmp ;
  size_t tmp___0 ;
  int __res ;
  __int32_t const   **tmp___2 ;
  int __res___0 ;
  __int32_t const   **tmp___4 ;

  {
#line 28
  tmp = strlen((char const   *)a);
#line 28
  s = (int )tmp;
#line 29
  tmp___0 = strlen((char const   *)b);
#line 29
  l = (int )tmp___0;
#line 31
  if (s != l) {
#line 32
    return (1);
  }
#line 34
  i = 0;
#line 34
  while (i < s) {
#line 35
    if (sizeof(*(a + i)) > 1UL) {
#line 35
      __res = toupper((int )*(a + i));
    } else {
#line 35
      tmp___2 = __ctype_toupper_loc();
#line 35
      __res = (int )*(*tmp___2 + (int )*(a + i));
    }
#line 35
    if (sizeof(*(b + i)) > 1UL) {
#line 35
      __res___0 = toupper((int )*(b + i));
    } else {
#line 35
      tmp___4 = __ctype_toupper_loc();
#line 35
      __res___0 = (int )*(*tmp___4 + (int )*(b + i));
    }
#line 35
    if (__res != __res___0) {
#line 36
      return (1);
    }
#line 34
    i ++;
  }
#line 39
  return (0);
}
}
#line 43 "../demosrc/ac3dparse.c"
static void GetAC3DString(FILE *dfile , char *str ) 
{ 
  char c ;
  int i ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 45
  i = 0;
#line 48
  while (1) {
#line 48
    tmp = feof(dfile);
#line 48
    if (tmp) {
#line 48
      break;
    } else {
#line 48
      tmp___0 = fgetc(dfile);
#line 48
      c = (char )tmp___0;
#line 48
      if (! ((int )c != 34)) {
#line 48
        break;
      }
    }
  }
#line 51
  while (1) {
#line 51
    tmp___1 = feof(dfile);
#line 51
    if (tmp___1) {
#line 51
      break;
    } else {
#line 51
      tmp___2 = fgetc(dfile);
#line 51
      c = (char )tmp___2;
#line 51
      if (! ((int )c != 34)) {
#line 51
        break;
      }
    }
#line 52
    *(str + i) = c;
#line 53
    i ++;
  }
#line 55
  *(str + i) = (char )'\000';
#line 56
  return;
}
}
#line 58 "../demosrc/ac3dparse.c"
static void reset_tex_table___0(void) 
{ 


  {
#line 59
  numtextures = 0;
#line 60
  memset((void *)(& textable), 0, sizeof(textable));
#line 61
  return;
}
}
#line 63 "../demosrc/ac3dparse.c"
static errcode add_texture___0(void *tex , char *name ) 
{ 


  {
#line 64
  textable[numtextures].tex = tex;
#line 65
  strcpy((char * __restrict  )(textable[numtextures].name), (char const   * __restrict  )name);
#line 67
  numtextures ++;
#line 68
  if (numtextures > 8192) {
#line 69
    printf((char const   * __restrict  )"Parse: %d textures allocated, texture slots full!\n",
           numtextures);
#line 70
    numtextures --;
#line 71
    return ((errcode )16);
  }
#line 74
  return ((errcode )0);
}
}
#line 77 "../demosrc/ac3dparse.c"
static errcode GetString___0(FILE *dfile , char *string ) 
{ 
  char data[100] ;
  int tmp ;

  {
#line 80
  fscanf((FILE * __restrict  )dfile, (char const   * __restrict  )"%s", data);
#line 81
  tmp = stringcmp___0(data, string);
#line 81
  if (tmp != 0) {
#line 82
    printf((char const   * __restrict  )"parse: Expected %s, got %s \n", string, data);
#line 83
    printf((char const   * __restrict  )"parse: Error while parsing object: %d \n",
           numobjectsparsed);
#line 84
    return ((errcode )4);
  }
#line 87
  return ((errcode )0);
}
}
#line 90 "../demosrc/ac3dparse.c"
unsigned int ParseAC3D(char *modelfile , SceneHandle scene ) 
{ 
  FILE *dfile ;
  char filehdr[255] ;
  errcode rc ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___0 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
#line 95
  reset_tex_table___0();
#line 96
  dfile = (FILE *)((void *)0);
#line 98
  dfile = fopen((char const   * __restrict  )modelfile, (char const   * __restrict  )"r");
#line 99
  if ((unsigned long )dfile == (unsigned long )((void *)0)) {
#line 100
    return (1U);
  }
#line 103
  fscanf((FILE * __restrict  )dfile, (char const   * __restrict  )"%s", filehdr);
#line 104
  if (0) {
#line 104
    __s1_len = __builtin_strlen((char const   *)(filehdr));
#line 104
    __s2_len = __builtin_strlen("AC3Db");
#line 104
    if (! ((size_t )((void const   *)(filehdr + 1)) - (size_t )((void const   *)(filehdr)) == 1UL)) {
#line 104
      goto _L___0;
    } else
#line 104
    if (__s1_len >= 4UL) {
      _L___0: /* CIL Label */ 
#line 104
      if (! ((size_t )((void const   *)("AC3Db" + 1)) - (size_t )((void const   *)"AC3Db") == 1UL)) {
#line 104
        tmp___5 = 1;
      } else
#line 104
      if (__s2_len >= 4UL) {
#line 104
        tmp___5 = 1;
      } else {
#line 104
        tmp___5 = 0;
      }
    } else {
#line 104
      tmp___5 = 0;
    }
#line 104
    if (tmp___5) {
#line 104
      tmp___0 = __builtin_strcmp((char const   *)(filehdr), "AC3Db");
#line 104
      tmp___4 = tmp___0;
    } else {
#line 104
      tmp___3 = __builtin_strcmp((char const   *)(filehdr), "AC3Db");
#line 104
      tmp___4 = tmp___3;
    }
  } else {
#line 104
    tmp___3 = __builtin_strcmp((char const   *)(filehdr), "AC3Db");
#line 104
    tmp___4 = tmp___3;
  }
#line 104
  if (tmp___4) {
#line 105
    printf((char const   * __restrict  )"Unknown version of AC3D Model File Format\n");
#line 106
    fclose(dfile);
#line 107
    return (1U);
  }
#line 110
  rc = GetScenedefs___0(dfile, scene);
#line 111
  if (rc != 0U) {
#line 112
    return (rc);
  }
#line 114
  scenebackcol.r = (float )0.0;
#line 115
  scenebackcol.g = (float )0.0;
#line 116
  scenebackcol.b = (float )0.0;
#line 118
  numobjectsparsed = 0;
#line 119
  while (1) {
#line 119
    rc = GetScene(dfile, scene);
#line 119
    if (! (rc == 0U)) {
#line 119
      break;
    }
#line 120
    numobjectsparsed ++;
  }
#line 122
  fclose(dfile);
#line 124
  if (rc == 8U) {
#line 125
    rc = (errcode )0;
  }
#line 127
  rt_background(scene, scenebackcol);
#line 129
  return (rc);
}
}
#line 133 "../demosrc/ac3dparse.c"
static errcode GetScenedefs___0(FILE *dfile , SceneHandle scene ) 
{ 
  apivector Ccenter ;
  apivector Cview ;
  apivector Cup ;
  apiflt zoom ;
  apiflt aspectratio ;
  int raydepth ;
  int antialiasing ;
  apivector ctr ;
  apitexture tex ;
  void *tmp ;

  {
#line 138
  rt_outputfile(scene, "outfile.tga");
#line 139
  rt_resolution(scene, 512, 512);
#line 140
  rt_verbose(scene, 0);
#line 142
  zoom = 1.0;
#line 143
  aspectratio = 1.0;
#line 144
  antialiasing = 0;
#line 145
  raydepth = 6;
#line 147
  Ccenter.x = 0.0;
#line 148
  Ccenter.y = 0.0;
#line 149
  Ccenter.z = - 5.0;
#line 151
  Cview.x = 0.0;
#line 152
  Cview.y = 0.0;
#line 153
  Cview.z = 1.0;
#line 155
  Cup.x = 0.0;
#line 156
  Cup.y = 1.0;
#line 157
  Cup.z = 0.0;
#line 159
  rt_camera_setup(scene, zoom, aspectratio, antialiasing, raydepth, Ccenter, Cview,
                  Cup);
#line 166
  memset((void *)(& tex), 0, sizeof(apitexture ));
#line 168
  tex.col.r = (float )1.0;
#line 169
  tex.col.g = (float )1.0;
#line 170
  tex.col.b = (float )1.0;
#line 171
  ctr.x = 0.0;
#line 172
  ctr.y = 0.0;
#line 173
  ctr.z = - 100.0;
#line 175
  tmp = rt_texture(scene, & tex);
#line 175
  rt_light(scene, tmp, ctr, 1.0);
#line 178
  return ((errcode )0);
}
}
#line 181 "../demosrc/ac3dparse.c"
static errcode GetScene(FILE *dfile , SceneHandle scene ) 
{ 
  char objtype[80] ;
  int tmp ;
  errcode tmp___0 ;
  int tmp___1 ;
  errcode tmp___2 ;
  int tmp___3 ;

  {
#line 184
  tmp = fscanf((FILE * __restrict  )dfile, (char const   * __restrict  )"%s", objtype);
#line 184
  if (tmp != 1) {
#line 185
    return ((errcode )8);
  }
#line 187
  tmp___1 = stringcmp___0(objtype, (char *)"MATERIAL");
#line 187
  if (! tmp___1) {
#line 188
    tmp___0 = GetMaterial(dfile, scene);
#line 188
    return (tmp___0);
  }
#line 190
  tmp___3 = stringcmp___0(objtype, (char *)"OBJECT");
#line 190
  if (! tmp___3) {
#line 191
    tmp___2 = GetObject___0(dfile, scene);
#line 191
    return (tmp___2);
  }
#line 194
  printf((char const   * __restrict  )"Found bad token: %s expected an object type\n",
         objtype);
#line 195
  return ((errcode )4);
}
}
#line 198 "../demosrc/ac3dparse.c"
static errcode GetMaterial(FILE *dfile , SceneHandle scene ) 
{ 
  apitexture tex ;
  float a ;
  float b ;
  float c ;
  float d ;
  int e ;
  errcode rc ;
  char texname[24] ;
  errcode tmp ;
  errcode tmp___0 ;
  errcode tmp___1 ;
  errcode tmp___2 ;
  void *tmp___3 ;

  {
#line 205
  fscanf((FILE * __restrict  )dfile, (char const   * __restrict  )"%s", texname);
#line 207
  rc = GetString___0(dfile, (char *)"RGB");
#line 208
  fscanf((FILE * __restrict  )dfile, (char const   * __restrict  )"%f %f %f", & a,
         & b, & c);
#line 209
  tex.col.r = a;
#line 210
  tex.col.g = b;
#line 211
  tex.col.b = c;
#line 212
  tex.diffuse = (double )((a + b) + c) / 3.0;
#line 214
  rc = GetString___0(dfile, (char *)"AMB");
#line 215
  fscanf((FILE * __restrict  )dfile, (char const   * __restrict  )"%f %f %f", & a,
         & b, & c);
#line 216
  tex.ambient = (double )((a + b) + c) / 3.0;
#line 218
  tmp = GetString___0(dfile, (char *)"EMIS");
#line 218
  rc |= tmp;
#line 219
  fscanf((FILE * __restrict  )dfile, (char const   * __restrict  )"%f %f %f", & a,
         & b, & c);
#line 221
  tmp___0 = GetString___0(dfile, (char *)"SPEC");
#line 221
  rc |= tmp___0;
#line 222
  fscanf((FILE * __restrict  )dfile, (char const   * __restrict  )"%f %f %f", & a,
         & b, & c);
#line 223
  tex.specular = (double )((a + b) + c) / 3.0;
#line 225
  tmp___1 = GetString___0(dfile, (char *)"SHI");
#line 225
  rc |= tmp___1;
#line 226
  fscanf((FILE * __restrict  )dfile, (char const   * __restrict  )"%d", & e);
#line 228
  tmp___2 = GetString___0(dfile, (char *)"TRANS");
#line 228
  rc |= tmp___2;
#line 229
  fscanf((FILE * __restrict  )dfile, (char const   * __restrict  )"%f", & d);
#line 230
  if ((double )d > 0.99) {
#line 230
    tex.opacity = 0.0;
  } else {
#line 230
    tex.opacity = 1.0 - (double )d;
  }
#line 231
  tex.texturefunc = 0;
#line 233
  tmp___3 = rt_texture(scene, & tex);
#line 233
  add_texture___0(tmp___3, (char *)(texname));
#line 235
  return (rc);
}
}
#line 238 "../demosrc/ac3dparse.c"
static void RmatIdentity(float (*rmat)[3] ) 
{ 
  int i ;
  int j ;

  {
#line 240
  j = 0;
#line 240
  while (j < 3) {
#line 241
    i = 0;
#line 241
    while (i < 3) {
#line 242
      if (i == j) {
#line 243
        (*(rmat + j))[i] = (float )1.0;
      } else {
#line 245
        (*(rmat + j))[i] = (float )0.0;
      }
#line 241
      i ++;
    }
#line 240
    j ++;
  }
#line 248
  return;
}
}
#line 250 "../demosrc/ac3dparse.c"
static void RmatMult(float (*A)[3] , float (*B)[3] , float (*C)[3] ) 
{ 
  int i ;
  int j ;
  int k ;

  {
#line 253
  k = 0;
#line 253
  while (k < 3) {
#line 254
    j = 0;
#line 254
    while (j < 3) {
#line 255
      (*(A + k))[j] = (float )0.0;
#line 256
      i = 0;
#line 256
      while (i < 3) {
#line 257
        (*(A + k))[j] += (*(B + k))[i] * (*(C + i))[j];
#line 256
        i ++;
      }
#line 254
      j ++;
    }
#line 253
    k ++;
  }
#line 261
  return;
}
}
#line 263 "../demosrc/ac3dparse.c"
static void RmatTmatMult(float *NT , float (*R)[3] , float *T ) 
{ 
  int i ;
  int j ;

  {
#line 265
  j = 0;
#line 265
  while (j < 3) {
#line 266
    *(NT + j) = (float )0.0;
#line 267
    i = 0;
#line 267
    while (i < 3) {
#line 268
      *(NT + j) += (*(R + j))[i] * *(T + i);
#line 267
      i ++;
    }
#line 265
    j ++;
  }
#line 271
  return;
}
}
#line 273 "../demosrc/ac3dparse.c"
static void tlist_add_tri(tri_list **tlist , int v0 , int v1 , int v2 , int smooth ,
                          int texnum ) 
{ 
  tri_list *newlist ;
  void *tmp ;

  {
#line 277
  tmp = malloc(sizeof(tri_list ));
#line 277
  newlist = (tri_list *)tmp;
#line 278
  newlist->v0 = v0;
#line 279
  newlist->v1 = v1;
#line 280
  newlist->v2 = v2;
#line 281
  newlist->smooth = smooth;
#line 282
  newlist->texnum = texnum;
#line 283
  newlist->next = *tlist;
#line 285
  *tlist = newlist;
#line 286
  return;
}
}
#line 288 "../demosrc/ac3dparse.c"
static void tlist_delete(tri_list **tlist ) 
{ 
  tri_list *tmp ;
  tri_list *next ;

  {
#line 292
  tmp = *tlist;
#line 294
  while ((unsigned long )tmp != (unsigned long )((void *)0)) {
#line 295
    next = tmp->next;
#line 296
    free((void *)tmp);
#line 297
    tmp = next;
  }
#line 300
  *tlist = (tri_list *)((void *)0);
#line 301
  return;
}
}
#line 304 "../demosrc/ac3dparse.c"
static void clear_normals(apivector *normals , int numverts ) 
{ 
  apivector tmp ;
  int i ;

  {
#line 308
  tmp.z = 0.0;
#line 308
  tmp.y = tmp.z;
#line 308
  tmp.x = tmp.y;
#line 310
  i = 0;
#line 310
  while (i < numverts) {
#line 311
    *(normals + i) = tmp;
#line 310
    i ++;
  }
#line 313
  return;
}
}
#line 316 "../demosrc/ac3dparse.c"
static void normalize(apivector *vec ) 
{ 
  double length ;

  {
#line 318
  length = sqrt((vec->x * vec->x + vec->y * vec->y) + vec->z * vec->z);
#line 319
  vec->x /= length;
#line 320
  vec->y /= length;
#line 321
  vec->z /= length;
#line 322
  return;
}
}
#line 324 "../demosrc/ac3dparse.c"
static void renormalize_normals(apivector *normals , int numverts ) 
{ 
  int i ;

  {
#line 327
  i = 0;
#line 327
  while (i < numverts) {
#line 328
    normalize(normals + i);
#line 327
    i ++;
  }
#line 330
  return;
}
}
#line 332 "../demosrc/ac3dparse.c"
static apivector tri_normal(apivector *v0 , apivector *v1 , apivector *v2 ) 
{ 
  apivector U ;
  apivector V ;
  apivector norm ;

  {
#line 336
  U.x = v1->x - v0->x;
#line 337
  U.y = v1->y - v0->y;
#line 338
  U.z = v1->z - v0->z;
#line 340
  V.x = v2->x - v0->x;
#line 341
  V.y = v2->y - v0->y;
#line 342
  V.z = v2->z - v0->z;
#line 344
  norm.x = U.y * V.z - U.z * V.y;
#line 345
  norm.y = U.z * V.x - U.x * V.z;
#line 346
  norm.z = U.x * V.y - U.y * V.x;
#line 348
  normalize(& norm);
#line 350
  return (norm);
}
}
#line 353 "../demosrc/ac3dparse.c"
static void gen_triangles(SceneHandle scene , tri_list *tlist , apivector *vertex ,
                          apivector *normal ) 
{ 
  tri_list *cur ;

  {
#line 357
  cur = tlist;
#line 358
  while ((unsigned long )cur != (unsigned long )((void *)0)) {
#line 359
    if (cur->smooth) {
#line 360
      rt_stri(scene, textable[cur->texnum].tex, *(vertex + cur->v0), *(vertex + cur->v1),
              *(vertex + cur->v2), *(normal + cur->v0), *(normal + cur->v1), *(normal + cur->v2));
    } else {
#line 366
      rt_tri(scene, textable[cur->texnum].tex, *(vertex + cur->v0), *(vertex + cur->v1),
             *(vertex + cur->v2));
    }
#line 370
    cur = cur->next;
  }
#line 372
  return;
}
}
#line 375 "../demosrc/ac3dparse.c"
static errcode GetRecurseObject(SceneHandle scene , FILE *dfile , float (*rmat)[3] ,
                                float *tmat ) 
{ 
  char token[256] ;
  char objname[128] ;
  char name[128] ;
  char texname[128] ;
  char urlname[100] ;
  RotMat___0 localrmat ;
  RotMat___0 newrmat ;
  TransMat localtmat ;
  TransMat newtmat ;
  float txrepa ;
  float txrepb ;
  float a ;
  float b ;
  int numvert ;
  int numsurf ;
  int surf ;
  int materialnum ;
  int numrefs ;
  int numkids ;
  int data ;
  int i ;
  int j ;
  apivector *vertexarray ;
  apivector *normalarray ;
  int *refarray ;
  tri_list *tlist ;
  errcode rc ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  TransMat vtx ;
  TransMat tvtx ;
  void *tmp___8 ;
  void *tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  void *tmp___14 ;
  int v0 ;
  int vold ;
  int vnew ;
  apivector trinorm ;
  int tmp___15 ;
  int tmp___16 ;
  errcode tmp___17 ;
  errcode tmp___18 ;

  {
#line 383
  vertexarray = (apivector *)((void *)0);
#line 384
  normalarray = (apivector *)((void *)0);
#line 385
  refarray = (int *)((void *)0);
#line 386
  tlist = (tri_list *)((void *)0);
#line 387
  rc = (errcode )0;
#line 390
  data = 0;
#line 390
  numkids = data;
#line 390
  numrefs = numkids;
#line 390
  materialnum = numrefs;
#line 390
  surf = materialnum;
#line 390
  numsurf = surf;
#line 390
  numvert = numsurf;
#line 392
  RmatIdentity((float (*)[3])(localrmat));
#line 393
  localtmat[0] = (float )0.0;
#line 394
  localtmat[1] = (float )0.0;
#line 395
  localtmat[2] = (float )0.0;
#line 396
  fscanf((FILE * __restrict  )dfile, (char const   * __restrict  )"%s", objname);
#line 397
  fscanf((FILE * __restrict  )dfile, (char const   * __restrict  )"%s", token);
#line 398
  tmp = stringcmp___0(token, (char *)"NAME");
#line 398
  if (! tmp) {
#line 399
    GetAC3DString(dfile, name);
#line 400
    fscanf((FILE * __restrict  )dfile, (char const   * __restrict  )"%s", token);
  }
#line 402
  tmp___0 = stringcmp___0(token, (char *)"DATA");
#line 402
  if (! tmp___0) {
#line 403
    fscanf((FILE * __restrict  )dfile, (char const   * __restrict  )"%d", & data);
#line 404
    fscanf((FILE * __restrict  )dfile, (char const   * __restrict  )"%s", token);
  }
#line 406
  tmp___1 = stringcmp___0(token, (char *)"TEXTURE");
#line 406
  if (! tmp___1) {
#line 407
    fscanf((FILE * __restrict  )dfile, (char const   * __restrict  )"%s", texname);
#line 408
    fscanf((FILE * __restrict  )dfile, (char const   * __restrict  )"%s", token);
  }
#line 410
  tmp___2 = stringcmp___0(token, (char *)"TEXREP");
#line 410
  if (! tmp___2) {
#line 411
    fscanf((FILE * __restrict  )dfile, (char const   * __restrict  )"%f %f", & txrepa,
           & txrepb);
#line 412
    fscanf((FILE * __restrict  )dfile, (char const   * __restrict  )"%s", token);
  }
#line 414
  tmp___3 = stringcmp___0(token, (char *)"ROT");
#line 414
  if (! tmp___3) {
#line 415
    j = 0;
#line 415
    while (j < 3) {
#line 416
      i = 0;
#line 416
      while (i < 3) {
#line 417
        fscanf((FILE * __restrict  )dfile, (char const   * __restrict  )"%f", & localrmat[j][i]);
#line 416
        i ++;
      }
#line 415
      j ++;
    }
#line 420
    fscanf((FILE * __restrict  )dfile, (char const   * __restrict  )"%s", token);
  }
#line 422
  tmp___4 = stringcmp___0(token, (char *)"LOC");
#line 422
  if (! tmp___4) {
#line 423
    j = 0;
#line 423
    while (j < 3) {
#line 424
      fscanf((FILE * __restrict  )dfile, (char const   * __restrict  )"%f", & localtmat[j]);
#line 423
      j ++;
    }
#line 426
    fscanf((FILE * __restrict  )dfile, (char const   * __restrict  )"%s", token);
  }
#line 428
  tmp___5 = stringcmp___0(token, (char *)"ROT");
#line 428
  if (! tmp___5) {
#line 429
    j = 0;
#line 429
    while (j < 3) {
#line 430
      i = 0;
#line 430
      while (i < 3) {
#line 431
        fscanf((FILE * __restrict  )dfile, (char const   * __restrict  )"%f", & localrmat[j][i]);
#line 430
        i ++;
      }
#line 429
      j ++;
    }
#line 434
    fscanf((FILE * __restrict  )dfile, (char const   * __restrict  )"%s", token);
  }
#line 438
  RmatTmatMult((float *)(newtmat), rmat, (float *)(localtmat));
#line 439
  newtmat[0] += *(tmat + 0);
#line 440
  newtmat[1] += *(tmat + 1);
#line 441
  newtmat[2] += *(tmat + 2);
#line 442
  RmatMult((float (*)[3])(newrmat), rmat, (float (*)[3])(localrmat));
#line 444
  tmp___6 = stringcmp___0(token, (char *)"URL");
#line 444
  if (! tmp___6) {
#line 445
    fscanf((FILE * __restrict  )dfile, (char const   * __restrict  )"%s", urlname);
#line 446
    fscanf((FILE * __restrict  )dfile, (char const   * __restrict  )"%s", token);
  }
#line 448
  tmp___7 = stringcmp___0(token, (char *)"TEXTURE");
#line 448
  if (! tmp___7) {
#line 449
    GetAC3DString(dfile, token);
#line 450
    fscanf((FILE * __restrict  )dfile, (char const   * __restrict  )"%s", token);
  }
#line 452
  tmp___10 = stringcmp___0(token, (char *)"NUMVERT");
#line 452
  if (! tmp___10) {
#line 455
    fscanf((FILE * __restrict  )dfile, (char const   * __restrict  )"%d", & numvert);
#line 457
    tmp___8 = malloc((unsigned long )numvert * sizeof(apivector ));
#line 457
    vertexarray = (apivector *)tmp___8;
#line 458
    tmp___9 = malloc((unsigned long )numvert * sizeof(apivector ));
#line 458
    normalarray = (apivector *)tmp___9;
#line 461
    clear_normals(normalarray, numvert);
#line 464
    i = 0;
#line 464
    while (i < numvert) {
#line 465
      fscanf((FILE * __restrict  )dfile, (char const   * __restrict  )"%f %f %f",
             & vtx[0], & vtx[1], & vtx[2]);
#line 467
      RmatTmatMult((float *)(tvtx), (float (*)[3])(newrmat), (float *)(vtx));
#line 468
      (vertexarray + i)->x = (apiflt )(tvtx[0] + newtmat[0]);
#line 469
      (vertexarray + i)->y = (apiflt )(tvtx[1] + newtmat[1]);
#line 470
      (vertexarray + i)->z = (apiflt )(tvtx[2] + newtmat[2]);
#line 464
      i ++;
    }
#line 473
    fscanf((FILE * __restrict  )dfile, (char const   * __restrict  )"%s", token);
  }
#line 475
  tmp___15 = stringcmp___0(token, (char *)"NUMSURF");
#line 475
  if (! tmp___15) {
#line 476
    fscanf((FILE * __restrict  )dfile, (char const   * __restrict  )"%d", & numsurf);
#line 477
    fscanf((FILE * __restrict  )dfile, (char const   * __restrict  )"%s", token);
#line 479
    j = 0;
#line 479
    while (j < numsurf) {
#line 480
      materialnum = 0;
#line 480
      surf = materialnum;
#line 480
      numrefs = surf;
#line 482
      tmp___11 = stringcmp___0(token, (char *)"SURF");
#line 482
      if (! tmp___11) {
#line 490
        fscanf((FILE * __restrict  )dfile, (char const   * __restrict  )"%s", token);
#line 491
        sscanf((char const   * __restrict  )(token), (char const   * __restrict  )"%x",
               & surf);
#line 495
        fscanf((FILE * __restrict  )dfile, (char const   * __restrict  )"%s", token);
      }
#line 497
      tmp___12 = stringcmp___0(token, (char *)"MAT");
#line 497
      if (! tmp___12) {
#line 498
        fscanf((FILE * __restrict  )dfile, (char const   * __restrict  )"%d", & materialnum);
#line 499
        fscanf((FILE * __restrict  )dfile, (char const   * __restrict  )"%s", token);
      }
#line 501
      tmp___13 = stringcmp___0(token, (char *)"REFS");
#line 501
      if (tmp___13) {
#line 504
        rc |= 4U;
#line 504
        return (rc);
      } else {
#line 502
        fscanf((FILE * __restrict  )dfile, (char const   * __restrict  )"%d", & numrefs);
      }
#line 506
      tmp___14 = malloc((unsigned long )numrefs * sizeof(int ));
#line 506
      refarray = (int *)tmp___14;
#line 507
      i = 0;
#line 507
      while (i < numrefs) {
#line 508
        fscanf((FILE * __restrict  )dfile, (char const   * __restrict  )"%d %f %f",
               refarray + i, & a, & b);
#line 507
        i ++;
      }
#line 513
      if ((surf & 15) == 0) {
#line 518
        trinorm = tri_normal(vertexarray + *(refarray + 1), vertexarray + *(refarray + 0),
                             vertexarray + *(refarray + 2));
#line 522
        i = 0;
#line 522
        while (i < numrefs) {
#line 523
          (normalarray + *(refarray + i))->x += trinorm.x;
#line 524
          (normalarray + *(refarray + i))->y += trinorm.y;
#line 525
          (normalarray + *(refarray + i))->z += trinorm.z;
#line 522
          i ++;
        }
#line 528
        v0 = *(refarray + 0);
#line 529
        vold = *(refarray + 1);
#line 531
        i = 2;
#line 531
        while (i < numrefs) {
#line 532
          vnew = *(refarray + i);
#line 533
          tlist_add_tri(& tlist, vold, v0, vnew, surf & 16, materialnum);
#line 534
          vold = vnew;
#line 531
          i ++;
        }
      }
#line 538
      free((void *)refarray);
#line 539
      refarray = (int *)((void *)0);
#line 540
      fscanf((FILE * __restrict  )dfile, (char const   * __restrict  )"%s", token);
#line 479
      j ++;
    }
  }
#line 544
  if ((unsigned long )vertexarray != (unsigned long )((void *)0)) {
#line 544
    if ((unsigned long )normalarray != (unsigned long )((void *)0)) {
#line 546
      renormalize_normals(normalarray, numvert);
#line 548
      gen_triangles(scene, tlist, vertexarray, normalarray);
#line 549
      tlist_delete(& tlist);
    }
  }
#line 553
  if ((unsigned long )vertexarray != (unsigned long )((void *)0)) {
#line 554
    free((void *)vertexarray);
  }
#line 555
  vertexarray = (apivector *)((void *)0);
#line 557
  if ((unsigned long )normalarray != (unsigned long )((void *)0)) {
#line 558
    free((void *)normalarray);
  }
#line 559
  normalarray = (apivector *)((void *)0);
#line 563
  tmp___16 = stringcmp___0(token, (char *)"KIDS");
#line 563
  if (tmp___16) {
#line 566
    rc |= 4U;
#line 566
    return (rc);
  } else {
#line 564
    fscanf((FILE * __restrict  )dfile, (char const   * __restrict  )"%d", & numkids);
  }
#line 569
  while (numkids > 0) {
#line 570
    tmp___17 = GetString___0(dfile, (char *)"OBJECT");
#line 570
    rc |= tmp___17;
#line 571
    tmp___18 = GetRecurseObject(scene, dfile, (float (*)[3])(newrmat), (float *)(newtmat));
#line 571
    rc |= tmp___18;
#line 572
    numkids --;
  }
#line 575
  return (rc);
}
}
#line 578 "../demosrc/ac3dparse.c"
static errcode GetObject___0(FILE *dfile , SceneHandle scene ) 
{ 
  RotMat___0 defaultrmat ;
  TransMat defaulttmat ;
  errcode rc ;

  {
#line 583
  RmatIdentity((float (*)[3])(defaultrmat));
#line 584
  defaulttmat[0] = (float )0.0;
#line 585
  defaulttmat[1] = (float )0.0;
#line 586
  defaulttmat[2] = (float )0.0;
#line 588
  rc = GetRecurseObject(scene, dfile, (float (*)[3])(defaultrmat), (float *)(defaulttmat));
#line 590
  return (rc);
}
}
