/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is true */

#line 213 "/usr/lib/gcc/x86_64-linux-gnu/4.7/include/stddef.h"
typedef unsigned long size_t;
#line 140 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 141 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 148 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 40 "/usr/lib/gcc/x86_64-linux-gnu/4.7/include/stdarg.h"
typedef __builtin_va_list __gnuc_va_list;
#line 155 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 161 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 246 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 316 "/usr/include/libio.h"
typedef struct _IO_FILE _IO_FILE;
#line 325 "/usr/lib/gcc/x86_64-linux-gnu/4.7/include/stddef.h"
typedef int wchar_t;
#line 75 "/usr/include/time.h"
typedef __time_t time_t;
#line 153 "/usr/include/x86_64-linux-gnu/bits/mathinline.h"
union __anonunion___u_26 {
   long double __l ;
   int __i[3] ;
};
#line 82 "src/csuCommonMatrix.h"
struct __anonstruct_matrix_28 {
   int row_dim ;
   int col_dim ;
   double *data ;
   double **cols ;
};
#line 82 "src/csuCommonMatrix.h"
typedef struct __anonstruct_matrix_28 matrix;
#line 90 "src/csuCommonMatrix.h"
typedef matrix *Matrix;
#line 115 "src/csuCommonFile.h"
struct image_list_node {
   char *filename ;
   int imageIndex ;
   struct image_list_node *next_replicate ;
   struct image_list_node *next_subject ;
};
#line 115 "src/csuCommonFile.h"
typedef struct image_list_node ImageList;
#line 103 "src/csuEBGMUtil.h"
struct __anonstruct_gabor_jet_params_34 {
   int length ;
   double *wavelength ;
   double *angle ;
   double *phase ;
   double *aspect ;
   double *radius ;
   int *size ;
   double *kx ;
   double *ky ;
};
#line 103 "src/csuEBGMUtil.h"
typedef struct __anonstruct_gabor_jet_params_34 gabor_jet_params;
#line 118 "src/csuEBGMUtil.h"
typedef gabor_jet_params *GaborJetParams;
#line 156 "src/csuEBGMUtil.h"
struct __anonstruct_gabor_jet_36 {
   int length ;
   double x ;
   double y ;
   double *realPart ;
   double *imagPart ;
   double *mag ;
   double *ang ;
   GaborJetParams params ;
};
#line 156 "src/csuEBGMUtil.h"
typedef struct __anonstruct_gabor_jet_36 gabor_jet;
#line 172 "src/csuEBGMUtil.h"
typedef gabor_jet *GaborJet;
#line 238 "src/csuEBGMUtil.h"
struct __anonstruct_face_graph_41 {
   int geosize ;
   int totalsize ;
   GaborJetParams params ;
   GaborJet *jets ;
};
#line 238 "src/csuEBGMUtil.h"
typedef struct __anonstruct_face_graph_41 face_graph;
#line 245 "src/csuEBGMUtil.h"
typedef face_graph *FaceGraph;
#line 95 "src/csuEBGMMeasure.c"
struct distDirNode {
   struct distDirNode *next ;
   char *distDirectory ;
   double (*distMeasure)(FaceGraph  , FaceGraph  ) ;
};
#line 95 "src/csuEBGMMeasure.c"
typedef struct distDirNode DistDirNode;
#line 103 "src/csuEBGMMeasure.c"
struct __anonstruct_Arguments_42 {
   char *imageNamesFile ;
   char *faceGraphDir ;
   DistDirNode *distList ;
   int argc ;
   char **argv ;
};
#line 103 "src/csuEBGMMeasure.c"
typedef struct __anonstruct_Arguments_42 Arguments;
#line 153 "/usr/include/x86_64-linux-gnu/bits/mathinline.h"
union __anonunion___u_26___0 {
   long double __l ;
   int __i[3] ;
};
#line 153 "src/csuCommonMatrix.h"
enum __anonenum_MatrixSaveMode_29 {
    octaveFormat = 0,
    matlabFormat = 1,
    appendToFile = 2,
    formatMask = 1
} ;
#line 153 "src/csuCommonMatrix.h"
typedef enum __anonenum_MatrixSaveMode_29 MatrixSaveMode;
#line 40 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __int32_t;
#line 133 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __dev_t;
#line 134 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __uid_t;
#line 135 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __gid_t;
#line 136 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __ino_t;
#line 138 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __mode_t;
#line 139 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __nlink_t;
#line 162 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blksize_t;
#line 167 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blkcnt_t;
#line 181 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __ssize_t;
#line 184 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __syscall_slong_t;
#line 120 "/usr/include/time.h"
struct timespec {
   __time_t tv_sec ;
   __syscall_slong_t tv_nsec ;
};
#line 46 "/usr/include/x86_64-linux-gnu/bits/stat.h"
struct stat {
   __dev_t st_dev ;
   __ino_t st_ino ;
   __nlink_t st_nlink ;
   __mode_t st_mode ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   int __pad0 ;
   __dev_t st_rdev ;
   __off_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   __syscall_slong_t __unused[3] ;
};
#line 220 "/usr/include/unistd.h"
typedef __ssize_t ssize_t;
#line 153 "/usr/include/x86_64-linux-gnu/bits/mathinline.h"
union __anonunion___u_30 {
   long double __l ;
   int __i[3] ;
};
#line 182 "src/csuCommonUtil.h"
struct __anonstruct_Tokenizer_31 {
   int state ;
   char in_buff[512] ;
   char *i_ptr ;
   char word_buff[100] ;
   char *w_ptr ;
   int endOfLine ;
   int endOfFile ;
   int availChars ;
   int (*dataSource)(char *buff , size_t nChars , void **arg ) ;
   void *dataSrcArg ;
};
#line 182 "src/csuCommonUtil.h"
typedef struct __anonstruct_Tokenizer_31 Tokenizer;
#line 90 "src/csuCommonFile.h"
typedef char **ListOfStrings;
#line 122 "src/csuCommonFile.c"
struct __anonstruct_bytes4_40 {
   char a ;
   char b ;
   char c ;
   char d ;
};
#line 122 "src/csuCommonFile.c"
typedef struct __anonstruct_bytes4_40 bytes4;
#line 123 "src/csuCommonFile.c"
union __anonunion_float4_41 {
   float n ;
   bytes4 elem ;
};
#line 123 "src/csuCommonFile.c"
typedef union __anonunion_float4_41 float4;
#line 124 "src/csuCommonFile.c"
union __anonunion_int4_42 {
   int n ;
   bytes4 elem ;
};
#line 124 "src/csuCommonFile.c"
typedef union __anonunion_int4_42 int4;
#line 126 "src/csuCommonFile.c"
struct __anonstruct_bytes8_43 {
   char a ;
   char b ;
   char c ;
   char d ;
   char e ;
   char f ;
   char g ;
   char h ;
};
#line 126 "src/csuCommonFile.c"
typedef struct __anonstruct_bytes8_43 bytes8;
#line 127 "src/csuCommonFile.c"
union __anonunion_double8_44 {
   double n ;
   bytes8 elem ;
};
#line 127 "src/csuCommonFile.c"
typedef union __anonunion_double8_44 double8;
#line 443 "src/csuCommonFile.c"
struct __anonstruct_DistanceMeasure_45 {
   char *subject ;
   double distance ;
   int index ;
};
#line 443 "src/csuCommonFile.c"
typedef struct __anonstruct_DistanceMeasure_45 DistanceMeasure;
#line 153 "/usr/include/x86_64-linux-gnu/bits/mathinline.h"
union __anonunion___u_26___1 {
   long double __l ;
   int __i[3] ;
};
#line 456 "src/csuCommonUtil.c"
struct linkedListNode {
   struct linkedListNode *link ;
   char *data ;
};
#line 456 "src/csuCommonUtil.c"
typedef struct linkedListNode *LinkedListNode;
#line 478 "src/csuCommonUtil.c"
struct linkedListNode___0 {
   struct linkedListNode *link ;
   char *data ;
};
#line 478 "src/csuCommonUtil.c"
typedef struct linkedListNode___0 *LinkedListNode___0;
#line 554 "src/csuCommonUtil.c"
struct __anonstruct_Pair_35 {
   long key ;
   long index ;
};
#line 554 "src/csuCommonUtil.c"
typedef struct __anonstruct_Pair_35 Pair;
#line 153 "/usr/include/x86_64-linux-gnu/bits/mathinline.h"
union __anonunion___u_26___2 {
   long double __l ;
   int __i[3] ;
};
#line 89 "src/csuCommonSubspace.h"
enum __anonenum_CutOffMode_32 {
    CUTOFF_NONE = 0,
    CUTOFF_SIMPLE = 1,
    CUTOFF_ENERGY = 2,
    CUTOFF_STRETCH = 3,
    CUTOFF_CLASSES = 4
} ;
#line 89 "src/csuCommonSubspace.h"
typedef enum __anonenum_CutOffMode_32 CutOffMode;
#line 101 "src/csuCommonSubspace.h"
struct __anonstruct_Subspace_33 {
   int numSubjects ;
   int numPixels ;
   int basisDim ;
   Matrix values ;
   Matrix basis ;
   Matrix mean ;
   int useLDA ;
   CutOffMode cutOffMode ;
   double cutOff ;
   int dropNVectors ;
};
#line 101 "src/csuCommonSubspace.h"
typedef struct __anonstruct_Subspace_33 Subspace;
#line 153 "/usr/include/x86_64-linux-gnu/bits/mathinline.h"
union __anonunion___u_26___3 {
   long double __l ;
   int __i[3] ;
};
#line 153 "/usr/include/x86_64-linux-gnu/bits/mathinline.h"
union __anonunion___u_26___4 {
   long double __l ;
   int __i[3] ;
};
#line 85 "src/csuCommonImage.h"
struct __anonstruct_image_30 {
   int width ;
   int height ;
   int channels ;
   double ***data ;
};
#line 85 "src/csuCommonImage.h"
typedef struct __anonstruct_image_30 image;
#line 92 "src/csuCommonImage.h"
typedef image *Image;
#line 215 "src/csuCommonImage.h"
struct __anonstruct_ImageStatistics_31 {
   double max ;
   double min ;
   double mean ;
   double variance ;
   double stddev ;
   int max_x ;
   int max_y ;
   int max_c ;
   int min_x ;
   int min_y ;
   int min_c ;
};
#line 215 "src/csuCommonImage.h"
typedef struct __anonstruct_ImageStatistics_31 ImageStatistics;
#line 318 "src/csuCommonImage.c"
struct __anonstruct_EL_34 {
   char a ;
   char b ;
   char c ;
   char d ;
};
#line 318 "src/csuCommonImage.c"
typedef struct __anonstruct_EL_34 EL;
#line 319 "src/csuCommonImage.c"
union __anonunion_NUM_35 {
   float f ;
   EL elem ;
};
#line 319 "src/csuCommonImage.c"
typedef union __anonunion_NUM_35 NUM;
#line 994 "src/csuCommonImage.c"
struct hist_bin {
   int count ;
   double rangeStart ;
   double rangeEnd ;
};
#line 994 "src/csuCommonImage.c"
typedef struct hist_bin HistogramBin;
#line 153 "/usr/include/x86_64-linux-gnu/bits/mathinline.h"
union __anonunion___u_26___5 {
   long double __l ;
   int __i[3] ;
};
#line 130 "src/csuEBGMUtil.h"
struct __anonstruct_jet_masks_35 {
   int size ;
   Image *masks ;
   GaborJetParams params ;
};
#line 130 "src/csuEBGMUtil.h"
typedef struct __anonstruct_jet_masks_35 jet_masks;
#line 137 "src/csuEBGMUtil.h"
typedef jet_masks *JetMasks;
#line 188 "src/csuEBGMUtil.h"
struct __anonstruct_jet_bunch_37 {
   int allocsize ;
   int size ;
   GaborJet *jets ;
};
#line 188 "src/csuEBGMUtil.h"
typedef struct __anonstruct_jet_bunch_37 jet_bunch;
#line 195 "src/csuEBGMUtil.h"
typedef jet_bunch *JetBunch;
#line 205 "src/csuEBGMUtil.h"
struct __anonstruct_Edge_38 {
   int vert1 ;
   int vert2 ;
};
#line 205 "src/csuEBGMUtil.h"
typedef struct __anonstruct_Edge_38 Edge;
#line 209 "src/csuEBGMUtil.h"
struct __anonstruct_Vert_39 {
   double x ;
   double y ;
};
#line 209 "src/csuEBGMUtil.h"
typedef struct __anonstruct_Vert_39 Vert;
#line 213 "src/csuEBGMUtil.h"
struct __anonstruct_graph_discription_40 {
   int numVert ;
   int numEdge ;
   Vert *verts ;
   Edge *edges ;
   char **vertLabels ;
   JetBunch *bunch ;
};
#line 213 "src/csuEBGMUtil.h"
typedef struct __anonstruct_graph_discription_40 graph_discription;
#line 223 "src/csuEBGMUtil.h"
typedef graph_discription *GraphDiscription;
#line 153 "/usr/include/x86_64-linux-gnu/bits/mathinline.h"
union __anonunion___u_26___6 {
   long double __l ;
   int __i[3] ;
};
#line 153 "/usr/include/x86_64-linux-gnu/bits/mathinline.h"
union __anonunion___u_26___7 {
   long double __l ;
   int __i[3] ;
};
#line 153 "/usr/include/x86_64-linux-gnu/bits/mathinline.h"
union __anonunion___u_26___8 {
   long double __l ;
   int __i[3] ;
};
#line 153 "/usr/include/x86_64-linux-gnu/bits/mathinline.h"
union __anonunion___u_3 {
   long double __l ;
   int __i[3] ;
};
/* compiler builtin: 
   void *__builtin___memmove_chk(void * , void const   * , unsigned long  , unsigned long  ) ;  */
/* compiler builtin: 
   char *__builtin_strchr(char * , int  ) ;  */
/* compiler builtin: 
   void *__builtin___memcpy_chk(void * , void const   * , unsigned long  , unsigned long  ) ;  */
/* compiler builtin: 
   int __builtin___vsprintf_chk(char * , int  , unsigned long  , char const   * ,
                                __builtin_va_list  ) ;  */
/* compiler builtin: 
   char *__builtin___strncpy_chk(char * , char const   * , unsigned long  , unsigned long  ) ;  */
/* compiler builtin: 
   char *__builtin___strcat_chk(char * , char const   * , unsigned long  ) ;  */
/* compiler builtin: 
   unsigned long __builtin_object_size(void * , int  ) ;  */
/* compiler builtin: 
   int __builtin___sprintf_chk(char * , int  , unsigned long  , char const   *  , ...) ;  */
/* compiler builtin: 
   int __builtin___snprintf_chk(char * , unsigned long  , int  , unsigned long  ,
                                char const   *  , ...) ;  */
/* compiler builtin: 
   int __builtin___vsnprintf_chk(char * , unsigned long  , int  , unsigned long  ,
                                 char const   * , __builtin_va_list  ) ;  */
/* compiler builtin: 
   char *__builtin___strcpy_chk(char * , char const   * , unsigned long  ) ;  */
/* compiler builtin: 
   void *__builtin___memset_chk(void * , int  , unsigned long  , unsigned long  ) ;  */
/* compiler builtin: 
   char *__builtin___strncat_chk(char * , char const   * , unsigned long  , unsigned long  ) ;  */
/* compiler builtin: 
   long __builtin_expect(long  , long  ) ;  */
/* compiler builtin: 
   int __builtin_va_arg_pack(void) ;  */
#line 1 "csuEBGMMeasure.o"
#pragma merger("0","/tmp/cil-CT9WK8xn.i","-O3,-Wall")
#line 392 "/usr/include/libio.h"
extern int __uflow(_IO_FILE * ) ;
#line 393
extern int __overflow(_IO_FILE * , int  ) ;
#line 435
extern int _IO_getc(_IO_FILE *__fp ) ;
#line 436
extern int _IO_putc(int __c , _IO_FILE *__fp ) ;
#line 168 "/usr/include/stdio.h"
extern struct _IO_FILE *stdin ;
#line 169
extern struct _IO_FILE *stdout ;
#line 237
extern int fclose(FILE *__stream ) ;
#line 242
extern int fflush(FILE *__stream ) ;
#line 272
extern FILE *( __attribute__((__warn_unused_result__)) fopen)(char const   * __restrict  __filename ,
                                                              char const   * __restrict  __modes ) ;
#line 356
__inline extern int ( __attribute__((__artificial__, __always_inline__)) fprintf)(FILE * __restrict  __stream ,
                                                                                  char const   * __restrict  __fmt 
                                                                                  , ...) ;
#line 362
__inline extern int ( __attribute__((__artificial__, __always_inline__)) printf)(char const   * __restrict  __fmt 
                                                                                 , ...) ;
#line 364
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__, __artificial__,
__always_inline__)) sprintf)(char * __restrict  __s , char const   * __restrict  __fmt 
                             , ...) ;
#line 371
__inline extern int ( __attribute__((__artificial__, __always_inline__)) vfprintf)(FILE * __restrict  __stream ,
                                                                                   char const   * __restrict  __fmt ,
                                                                                   __gnuc_va_list __ap ) ;
#line 377
__inline extern int ( __attribute__((__artificial__, __always_inline__)) vprintf)(char const   * __restrict  __fmt ,
                                                                                  __gnuc_va_list __ap ) ;
#line 379
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__, __artificial__,
__always_inline__)) vsprintf)(char * __restrict  __s , char const   * __restrict  __fmt ,
                              __gnuc_va_list __ap ) ;
#line 386
__inline extern  __attribute__((__nothrow__)) int ( /* format attribute */ __attribute__((__leaf__,
__artificial__, __always_inline__)) snprintf)(char * __restrict  __s , size_t __n ,
                                              char const   * __restrict  __fmt  , ...) ;
#line 390
__inline extern  __attribute__((__nothrow__)) int ( /* format attribute */ __attribute__((__leaf__,
__artificial__, __always_inline__)) vsnprintf)(char * __restrict  __s , size_t __n ,
                                               char const   * __restrict  __fmt ,
                                               __gnuc_va_list __ap ) ;
#line 412
__inline extern int ( /* format attribute */ __attribute__((__artificial__, __always_inline__)) vdprintf)(int __fd ,
                                                                                                          char const   * __restrict  __fmt ,
                                                                                                          __gnuc_va_list __ap ) ;
#line 415
__inline extern int ( /* format attribute */ __attribute__((__artificial__, __always_inline__)) dprintf)(int __fd ,
                                                                                                         char const   * __restrict  __fmt 
                                                                                                         , ...) ;
#line 538
__inline extern int getchar(void) ;
#line 550
__inline extern int getc_unlocked(FILE *__fp ) ;
#line 551
__inline extern int getchar_unlocked(void) ;
#line 561
__inline extern int fgetc_unlocked(FILE *__fp ) ;
#line 580
__inline extern int putchar(int __c ) ;
#line 594
__inline extern int fputc_unlocked(int __c , FILE *__stream ) ;
#line 602
__inline extern int putc_unlocked(int __c , FILE *__stream ) ;
#line 603
__inline extern int putchar_unlocked(int __c ) ;
#line 622
__inline extern char *( __attribute__((__warn_unused_result__, __artificial__, __always_inline__)) fgets)(char * __restrict  __s ,
                                                                                                          int __n ,
                                                                                                          FILE * __restrict  __stream ) ;
#line 638
__inline extern char *( __attribute__((__warn_unused_result__, __artificial__, __always_inline__)) gets)(char *__str )  __attribute__((__deprecated__)) ;
#line 709
__inline extern size_t ( __attribute__((__warn_unused_result__, __artificial__, __always_inline__)) fread)(void * __restrict  __ptr ,
                                                                                                           size_t __size ,
                                                                                                           size_t __n ,
                                                                                                           FILE * __restrict  __stream ) ;
#line 737
__inline extern size_t ( __attribute__((__warn_unused_result__, __artificial__, __always_inline__)) fread_unlocked)(void * __restrict  __ptr ,
                                                                                                                    size_t __size ,
                                                                                                                    size_t __n ,
                                                                                                                    FILE * __restrict  __stream ) ;
#line 836
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__warn_unused_result__,
__leaf__)) feof_unlocked)(FILE *__stream ) ;
#line 837
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__warn_unused_result__,
__leaf__)) ferror_unlocked)(FILE *__stream ) ;
#line 43 "/usr/include/x86_64-linux-gnu/bits/stdio.h"
__inline extern int getchar(void) 
{ 
  int tmp ;

  {
#line 46
  tmp = _IO_getc(stdin);
#line 46
  return (tmp);
}
}
#line 52 "/usr/include/x86_64-linux-gnu/bits/stdio.h"
__inline extern int fgetc_unlocked(FILE *__fp ) 
{ 
  int tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  long tmp___3 ;

  {
#line 55
  tmp___3 = __builtin_expect((long )((unsigned long )__fp->_IO_read_ptr >= (unsigned long )__fp->_IO_read_end),
                             0L);
#line 55
  if (tmp___3) {
#line 55
    tmp___0 = __uflow(__fp);
#line 55
    tmp___2 = tmp___0;
  } else {
#line 55
    tmp___1 = __fp->_IO_read_ptr;
#line 55
    (__fp->_IO_read_ptr) ++;
#line 55
    tmp___2 = (int )*((unsigned char *)tmp___1);
  }
#line 55
  return (tmp___2);
}
}
#line 69 "/usr/include/x86_64-linux-gnu/bits/stdio.h"
__inline extern int getchar_unlocked(void) 
{ 
  int tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  long tmp___3 ;

  {
#line 72
  tmp___3 = __builtin_expect((long )((unsigned long )stdin->_IO_read_ptr >= (unsigned long )stdin->_IO_read_end),
                             0L);
#line 72
  if (tmp___3) {
#line 72
    tmp___0 = __uflow(stdin);
#line 72
    tmp___2 = tmp___0;
  } else {
#line 72
    tmp___1 = stdin->_IO_read_ptr;
#line 72
    (stdin->_IO_read_ptr) ++;
#line 72
    tmp___2 = (int )*((unsigned char *)tmp___1);
  }
#line 72
  return (tmp___2);
}
}
#line 78 "/usr/include/x86_64-linux-gnu/bits/stdio.h"
__inline extern int putchar(int __c ) 
{ 
  int tmp ;

  {
#line 81
  tmp = _IO_putc(__c, stdout);
#line 81
  return (tmp);
}
}
#line 87 "/usr/include/x86_64-linux-gnu/bits/stdio.h"
__inline extern int fputc_unlocked(int __c , FILE *__stream ) 
{ 
  int tmp___0 ;
  char *tmp___1 ;
  char tmp___2 ;
  int tmp___3 ;
  long tmp___4 ;

  {
#line 90
  tmp___4 = __builtin_expect((long )((unsigned long )__stream->_IO_write_ptr >= (unsigned long )__stream->_IO_write_end),
                             0L);
#line 90
  if (tmp___4) {
#line 90
    tmp___0 = __overflow(__stream, (int )((unsigned char )__c));
#line 90
    tmp___3 = tmp___0;
  } else {
#line 90
    tmp___1 = __stream->_IO_write_ptr;
#line 90
    (__stream->_IO_write_ptr) ++;
#line 90
    tmp___2 = (char )__c;
#line 90
    *tmp___1 = tmp___2;
#line 90
    tmp___3 = (int )((unsigned char )tmp___2);
  }
#line 90
  return (tmp___3);
}
}
#line 104 "/usr/include/x86_64-linux-gnu/bits/stdio.h"
__inline extern int putchar_unlocked(int __c ) 
{ 
  int tmp___0 ;
  char *tmp___1 ;
  char tmp___2 ;
  int tmp___3 ;
  long tmp___4 ;

  {
#line 107
  tmp___4 = __builtin_expect((long )((unsigned long )stdout->_IO_write_ptr >= (unsigned long )stdout->_IO_write_end),
                             0L);
#line 107
  if (tmp___4) {
#line 107
    tmp___0 = __overflow(stdout, (int )((unsigned char )__c));
#line 107
    tmp___3 = tmp___0;
  } else {
#line 107
    tmp___1 = stdout->_IO_write_ptr;
#line 107
    (stdout->_IO_write_ptr) ++;
#line 107
    tmp___2 = (char )__c;
#line 107
    *tmp___1 = tmp___2;
#line 107
    tmp___3 = (int )((unsigned char )tmp___2);
  }
#line 107
  return (tmp___3);
}
}
#line 124
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__warn_unused_result__,
__leaf__)) feof_unlocked)(FILE *__stream ) ;
#line 124 "/usr/include/x86_64-linux-gnu/bits/stdio.h"
__inline extern int ( __attribute__((__warn_unused_result__, __leaf__)) feof_unlocked)(FILE *__stream ) 
{ 


  {
#line 127
  return ((__stream->_flags & 16) != 0);
}
}
#line 131
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__warn_unused_result__,
__leaf__)) ferror_unlocked)(FILE *__stream ) ;
#line 131 "/usr/include/x86_64-linux-gnu/bits/stdio.h"
__inline extern int ( __attribute__((__warn_unused_result__, __leaf__)) ferror_unlocked)(FILE *__stream ) 
{ 


  {
#line 134
  return ((__stream->_flags & 32) != 0);
}
}
#line 30 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__, __artificial__,
__always_inline__)) sprintf)(char * __restrict  __s , char const   * __restrict  __fmt 
                             , ...) ;
#line 30 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern int ( __attribute__((__leaf__, __artificial__, __always_inline__)) sprintf)(char * __restrict  __s ,
                                                                                            char const   * __restrict  __fmt 
                                                                                            , ...) 
{ 
  unsigned long tmp ;
  int tmp___0 ;

  {
#line 33
  tmp = __builtin_object_size((void *)__s, 1);
#line 33
  tmp___0 = __builtin___sprintf_chk((char *)__s, 1, tmp, (char const   *)__fmt, __builtin_va_arg_pack());
#line 33
  return (tmp___0);
}
}
#line 42
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__, __artificial__,
__always_inline__)) vsprintf)(char * __restrict  __s , char const   * __restrict  __fmt ,
                              __gnuc_va_list __ap ) ;
#line 42 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern int ( __attribute__((__leaf__, __artificial__, __always_inline__)) vsprintf)(char * __restrict  __s ,
                                                                                             char const   * __restrict  __fmt ,
                                                                                             __gnuc_va_list __ap ) 
{ 
  unsigned long tmp ;
  int tmp___0 ;

  {
#line 46
  tmp = __builtin_object_size((void *)__s, 1);
#line 46
  tmp___0 = __builtin___vsprintf_chk((char *)__s, 1, tmp, (char const   *)__fmt, __ap);
#line 46
  return (tmp___0);
}
}
#line 60
__inline extern  __attribute__((__nothrow__)) int ( /* format attribute */ __attribute__((__leaf__,
__artificial__, __always_inline__)) snprintf)(char * __restrict  __s , size_t __n ,
                                              char const   * __restrict  __fmt  , ...) ;
#line 60 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern int ( /* format attribute */ __attribute__((__leaf__, __artificial__,
__always_inline__)) snprintf)(char * __restrict  __s , size_t __n , char const   * __restrict  __fmt 
                              , ...) 
{ 
  unsigned long tmp ;
  int tmp___0 ;

  {
#line 64
  tmp = __builtin_object_size((void *)__s, 1);
#line 64
  tmp___0 = __builtin___snprintf_chk((char *)__s, __n, 1, tmp, (char const   *)__fmt,
                                     __builtin_va_arg_pack());
#line 64
  return (tmp___0);
}
}
#line 73
__inline extern  __attribute__((__nothrow__)) int ( /* format attribute */ __attribute__((__leaf__,
__artificial__, __always_inline__)) vsnprintf)(char * __restrict  __s , size_t __n ,
                                               char const   * __restrict  __fmt ,
                                               __gnuc_va_list __ap ) ;
#line 73 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern int ( /* format attribute */ __attribute__((__leaf__, __artificial__,
__always_inline__)) vsnprintf)(char * __restrict  __s , size_t __n , char const   * __restrict  __fmt ,
                               __gnuc_va_list __ap ) 
{ 
  unsigned long tmp ;
  int tmp___0 ;

  {
#line 77
  tmp = __builtin_object_size((void *)__s, 1);
#line 77
  tmp___0 = __builtin___vsnprintf_chk((char *)__s, __n, 1, tmp, (char const   *)__fmt,
                                      __ap);
#line 77
  return (tmp___0);
}
}
#line 85
extern int __fprintf_chk(FILE * __restrict  __stream , int __flag , char const   * __restrict  __format 
                         , ...) ;
#line 87
extern int __printf_chk(int __flag , char const   * __restrict  __format  , ...) ;
#line 88
extern int __vfprintf_chk(FILE * __restrict  __stream , int __flag , char const   * __restrict  __format ,
                          __gnuc_va_list __ap ) ;
#line 94 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern int ( __attribute__((__artificial__, __always_inline__)) fprintf)(FILE * __restrict  __stream ,
                                                                                  char const   * __restrict  __fmt 
                                                                                  , ...) 
{ 
  int tmp ;

  {
#line 97
  tmp = __fprintf_chk(__stream, 1, __fmt, __builtin_va_arg_pack());
#line 97
  return (tmp);
}
}
#line 101 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern int ( __attribute__((__artificial__, __always_inline__)) printf)(char const   * __restrict  __fmt 
                                                                                 , ...) 
{ 
  int tmp ;

  {
#line 104
  tmp = __printf_chk(1, __fmt, __builtin_va_arg_pack());
#line 104
  return (tmp);
}
}
#line 113 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern int ( __attribute__((__artificial__, __always_inline__)) vprintf)(char const   * __restrict  __fmt ,
                                                                                  __gnuc_va_list __ap ) 
{ 
  int tmp ;

  {
#line 117
  tmp = __vfprintf_chk((FILE * __restrict  )stdout, 1, __fmt, __ap);
#line 117
  return (tmp);
}
}
#line 123 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern int ( __attribute__((__artificial__, __always_inline__)) vfprintf)(FILE * __restrict  __stream ,
                                                                                   char const   * __restrict  __fmt ,
                                                                                   __gnuc_va_list __ap ) 
{ 
  int tmp ;

  {
#line 127
  tmp = __vfprintf_chk(__stream, 1, __fmt, __ap);
#line 127
  return (tmp);
}
}
#line 131
extern int ( /* format attribute */  __dprintf_chk)(int __fd , int __flag , char const   * __restrict  __fmt 
                                                    , ...) ;
#line 133
extern int ( /* format attribute */  __vdprintf_chk)(int __fd , int __flag , char const   * __restrict  __fmt ,
                                                     __gnuc_va_list __arg ) ;
#line 138 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern int ( /* format attribute */ __attribute__((__artificial__, __always_inline__)) dprintf)(int __fd ,
                                                                                                         char const   * __restrict  __fmt 
                                                                                                         , ...) 
{ 
  int tmp ;

  {
#line 141
  tmp = __dprintf_chk(__fd, 1, __fmt, __builtin_va_arg_pack());
#line 141
  return (tmp);
}
}
#line 149 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern int ( /* format attribute */ __attribute__((__artificial__, __always_inline__)) vdprintf)(int __fd ,
                                                                                                          char const   * __restrict  __fmt ,
                                                                                                          __gnuc_va_list __ap ) 
{ 
  int tmp ;

  {
#line 152
  tmp = __vdprintf_chk(__fd, 1, __fmt, __ap);
#line 152
  return (tmp);
}
}
#line 227
extern char *( __attribute__((__warn_unused_result__)) __gets_chk)(char *__str , size_t  ) ;
#line 228
extern char *( __attribute__((__warn_unused_result__)) __gets_warn)(char *__str )  __asm__("gets") __attribute__((__warning__("please use fgets or getline instead, gets can\'t specify buffer size"))) ;
#line 232
__inline extern char *( __attribute__((__warn_unused_result__, __artificial__, __always_inline__)) gets)(char *__str )  __attribute__((__deprecated__)) ;
#line 232 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern char *( __attribute__((__warn_unused_result__, __artificial__, __always_inline__)) gets)(char *__str ) 
{ 
  unsigned long tmp ;
  char *tmp___0 ;
  unsigned long tmp___1 ;
  char *tmp___2 ;

  {
#line 235
  tmp___1 = __builtin_object_size((void *)__str, 1);
#line 235
  if (tmp___1 != 0xffffffffffffffffUL) {
#line 236
    tmp = __builtin_object_size((void *)__str, 1);
#line 236
    tmp___0 = __gets_chk(__str, tmp);
#line 236
    return (tmp___0);
  }
#line 237
  tmp___2 = __gets_warn(__str);
#line 237
  return (tmp___2);
}
}
#line 241
extern char *( __attribute__((__warn_unused_result__)) __fgets_chk)(char * __restrict  __s ,
                                                                    size_t __size ,
                                                                    int __n , FILE * __restrict  __stream ) ;
#line 243
extern char *( __attribute__((__warn_unused_result__)) __fgets_alias)(char * __restrict  __s ,
                                                                      int __n , FILE * __restrict  __stream )  __asm__("fgets")  ;
#line 246
extern char *( __attribute__((__warn_unused_result__)) __fgets_chk_warn)(char * __restrict  __s ,
                                                                         size_t __size ,
                                                                         int __n ,
                                                                         FILE * __restrict  __stream )  __asm__("__fgets_chk") __attribute__((__warning__("fgets called with bigger size than length of destination buffer"))) ;
#line 252 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern char *( __attribute__((__warn_unused_result__, __artificial__, __always_inline__)) fgets)(char * __restrict  __s ,
                                                                                                          int __n ,
                                                                                                          FILE * __restrict  __stream ) 
{ 
  unsigned long tmp ;
  char *tmp___0 ;
  unsigned long tmp___1 ;
  char *tmp___2 ;
  unsigned long tmp___3 ;
  unsigned long tmp___4 ;
  char *tmp___5 ;

  {
#line 255
  tmp___4 = __builtin_object_size((void *)__s, 1);
#line 255
  if (tmp___4 != 0xffffffffffffffffUL) {
#line 258
    tmp = __builtin_object_size((void *)__s, 1);
#line 258
    tmp___0 = __fgets_chk(__s, tmp, __n, __stream);
#line 258
    return (tmp___0);
#line 260
    tmp___3 = __builtin_object_size((void *)__s, 1);
#line 260
    if ((size_t )__n > tmp___3) {
#line 261
      tmp___1 = __builtin_object_size((void *)__s, 1);
#line 261
      tmp___2 = __fgets_chk_warn(__s, tmp___1, __n, __stream);
#line 261
      return (tmp___2);
    }
  }
#line 263
  tmp___5 = __fgets_alias(__s, __n, __stream);
#line 263
  return (tmp___5);
}
}
#line 266
extern size_t ( __attribute__((__warn_unused_result__)) __fread_chk)(void * __restrict  __ptr ,
                                                                     size_t __ptrlen ,
                                                                     size_t __size ,
                                                                     size_t __n ,
                                                                     FILE * __restrict  __stream ) ;
#line 269
extern size_t ( __attribute__((__warn_unused_result__)) __fread_alias)(void * __restrict  __ptr ,
                                                                       size_t __size ,
                                                                       size_t __n ,
                                                                       FILE * __restrict  __stream )  __asm__("fread")  ;
#line 273
extern size_t ( __attribute__((__warn_unused_result__)) __fread_chk_warn)(void * __restrict  __ptr ,
                                                                          size_t __ptrlen ,
                                                                          size_t __size ,
                                                                          size_t __n ,
                                                                          FILE * __restrict  __stream )  __asm__("__fread_chk") __attribute__((__warning__("fread called with bigger size * nmemb than length of destination buffer"))) ;
#line 281 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern size_t ( __attribute__((__warn_unused_result__, __artificial__, __always_inline__)) fread)(void * __restrict  __ptr ,
                                                                                                           size_t __size ,
                                                                                                           size_t __n ,
                                                                                                           FILE * __restrict  __stream ) 
{ 
  unsigned long tmp ;
  size_t tmp___0 ;
  unsigned long tmp___1 ;
  size_t tmp___2 ;
  unsigned long tmp___3 ;
  unsigned long tmp___4 ;
  size_t tmp___5 ;

  {
#line 285
  tmp___4 = __builtin_object_size((void *)__ptr, 0);
#line 285
  if (tmp___4 != 0xffffffffffffffffUL) {
#line 290
    tmp = __builtin_object_size((void *)__ptr, 0);
#line 290
    tmp___0 = __fread_chk(__ptr, tmp, __size, __n, __stream);
#line 290
    return (tmp___0);
#line 292
    tmp___3 = __builtin_object_size((void *)__ptr, 0);
#line 292
    if (__size * __n > tmp___3) {
#line 293
      tmp___1 = __builtin_object_size((void *)__ptr, 0);
#line 293
      tmp___2 = __fread_chk_warn(__ptr, tmp___1, __size, __n, __stream);
#line 293
      return (tmp___2);
    }
  }
#line 295
  tmp___5 = __fread_alias(__ptr, __size, __n, __stream);
#line 295
  return (tmp___5);
}
}
#line 327
extern size_t ( __attribute__((__warn_unused_result__)) __fread_unlocked_chk)(void * __restrict  __ptr ,
                                                                              size_t __ptrlen ,
                                                                              size_t __size ,
                                                                              size_t __n ,
                                                                              FILE * __restrict  __stream ) ;
#line 330
extern size_t ( __attribute__((__warn_unused_result__)) __fread_unlocked_alias)(void * __restrict  __ptr ,
                                                                                size_t __size ,
                                                                                size_t __n ,
                                                                                FILE * __restrict  __stream )  __asm__("fread_unlocked")  ;
#line 334
extern size_t ( __attribute__((__warn_unused_result__)) __fread_unlocked_chk_warn)(void * __restrict  __ptr ,
                                                                                   size_t __ptrlen ,
                                                                                   size_t __size ,
                                                                                   size_t __n ,
                                                                                   FILE * __restrict  __stream )  __asm__("__fread_unlocked_chk") __attribute__((__warning__("fread_unlocked called with bigger size * nmemb than length of destination buffer"))) ;
#line 342 "/usr/include/x86_64-linux-gnu/bits/stdio2.h"
__inline extern size_t ( __attribute__((__warn_unused_result__, __artificial__, __always_inline__)) fread_unlocked)(void * __restrict  __ptr ,
                                                                                                                    size_t __size ,
                                                                                                                    size_t __n ,
                                                                                                                    FILE * __restrict  __stream ) 
{ 
  unsigned long tmp ;
  size_t tmp___0 ;
  unsigned long tmp___1 ;
  size_t tmp___2 ;
  unsigned long tmp___3 ;
  unsigned long tmp___4 ;
  size_t tmp___11 ;

  {
#line 346
  tmp___4 = __builtin_object_size((void *)__ptr, 0);
#line 346
  if (tmp___4 != 0xffffffffffffffffUL) {
#line 351
    tmp = __builtin_object_size((void *)__ptr, 0);
#line 351
    tmp___0 = __fread_unlocked_chk(__ptr, tmp, __size, __n, __stream);
#line 351
    return (tmp___0);
#line 354
    tmp___3 = __builtin_object_size((void *)__ptr, 0);
#line 354
    if (__size * __n > tmp___3) {
#line 355
      tmp___1 = __builtin_object_size((void *)__ptr, 0);
#line 355
      tmp___2 = __fread_unlocked_chk_warn(__ptr, tmp___1, __size, __n, __stream);
#line 355
      return (tmp___2);
    }
  }
#line 380
  tmp___11 = __fread_unlocked_alias(__ptr, __size, __n, __stream);
#line 380
  return (tmp___11);
}
}
#line 144 "/usr/include/stdlib.h"
__inline extern  __attribute__((__nothrow__)) double ( __attribute__((__warn_unused_result__,
__nonnull__(1), __leaf__)) atof)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 147
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__warn_unused_result__,
__nonnull__(1), __leaf__)) atoi)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 150
__inline extern  __attribute__((__nothrow__)) long ( __attribute__((__warn_unused_result__,
__nonnull__(1), __leaf__)) atol)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 157
__inline extern  __attribute__((__nothrow__)) long long ( __attribute__((__warn_unused_result__,
__nonnull__(1), __leaf__)) atoll)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 164
extern  __attribute__((__nothrow__)) double ( __attribute__((__nonnull__(1), __leaf__)) strtod)(char const   * __restrict  __nptr ,
                                                                                                char ** __restrict  __endptr ) ;
#line 183
extern  __attribute__((__nothrow__)) long ( __attribute__((__nonnull__(1), __leaf__)) strtol)(char const   * __restrict  __nptr ,
                                                                                              char ** __restrict  __endptr ,
                                                                                              int __base ) ;
#line 209
extern  __attribute__((__nothrow__)) long long ( __attribute__((__nonnull__(1), __leaf__)) strtoll)(char const   * __restrict  __nptr ,
                                                                                                    char ** __restrict  __endptr ,
                                                                                                    int __base ) ;
#line 277
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__warn_unused_result__,
__nonnull__(1), __leaf__)) atoi)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 277 "/usr/include/stdlib.h"
__inline extern int ( __attribute__((__warn_unused_result__, __nonnull__(1), __leaf__)) atoi)(char const   *__nptr ) 
{ 
  long tmp ;

  {
#line 280
  tmp = strtol((char const   * __restrict  )__nptr, (char ** __restrict  )((char **)((void *)0)),
               10);
#line 280
  return ((int )tmp);
}
}
#line 282
__inline extern  __attribute__((__nothrow__)) long ( __attribute__((__warn_unused_result__,
__nonnull__(1), __leaf__)) atol)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 282 "/usr/include/stdlib.h"
__inline extern long ( __attribute__((__warn_unused_result__, __nonnull__(1), __leaf__)) atol)(char const   *__nptr ) 
{ 
  long tmp ;

  {
#line 285
  tmp = strtol((char const   * __restrict  )__nptr, (char ** __restrict  )((char **)((void *)0)),
               10);
#line 285
  return (tmp);
}
}
#line 291
__inline extern  __attribute__((__nothrow__)) long long ( __attribute__((__warn_unused_result__,
__nonnull__(1), __leaf__)) atoll)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 291 "/usr/include/stdlib.h"
__inline extern long long ( __attribute__((__warn_unused_result__, __nonnull__(1),
__leaf__)) atoll)(char const   *__nptr ) 
{ 
  long long tmp ;

  {
#line 294
  tmp = strtoll((char const   * __restrict  )__nptr, (char ** __restrict  )((char **)((void *)0)),
                10);
#line 294
  return (tmp);
}
}
#line 32 "/usr/include/x86_64-linux-gnu/sys/sysmacros.h"
__inline extern  __attribute__((__nothrow__)) unsigned int ( __attribute__((__leaf__)) gnu_dev_major)(unsigned long long __dev )  __attribute__((__const__)) ;
#line 35
__inline extern  __attribute__((__nothrow__)) unsigned int ( __attribute__((__leaf__)) gnu_dev_minor)(unsigned long long __dev )  __attribute__((__const__)) ;
#line 38
__inline extern  __attribute__((__nothrow__)) unsigned long long ( __attribute__((__leaf__)) gnu_dev_makedev)(unsigned int __major ,
                                                                                                              unsigned int __minor )  __attribute__((__const__)) ;
#line 43
__inline extern  __attribute__((__nothrow__)) unsigned int ( __attribute__((__leaf__)) gnu_dev_major)(unsigned long long __dev )  __attribute__((__const__)) ;
#line 43 "/usr/include/x86_64-linux-gnu/sys/sysmacros.h"
__inline extern unsigned int ( __attribute__((__leaf__)) gnu_dev_major)(unsigned long long __dev ) 
{ 


  {
#line 46
  return ((unsigned int )(((__dev >> 8) & 4095ULL) | (unsigned long long )((unsigned int )(__dev >> 32) & 4294963200U)));
}
}
#line 49
__inline extern  __attribute__((__nothrow__)) unsigned int ( __attribute__((__leaf__)) gnu_dev_minor)(unsigned long long __dev )  __attribute__((__const__)) ;
#line 49 "/usr/include/x86_64-linux-gnu/sys/sysmacros.h"
__inline extern unsigned int ( __attribute__((__leaf__)) gnu_dev_minor)(unsigned long long __dev ) 
{ 


  {
#line 52
  return ((unsigned int )((__dev & 255ULL) | (unsigned long long )((unsigned int )(__dev >> 12) & 4294967040U)));
}
}
#line 55
__inline extern  __attribute__((__nothrow__)) unsigned long long ( __attribute__((__leaf__)) gnu_dev_makedev)(unsigned int __major ,
                                                                                                              unsigned int __minor )  __attribute__((__const__)) ;
#line 55 "/usr/include/x86_64-linux-gnu/sys/sysmacros.h"
__inline extern unsigned long long ( __attribute__((__leaf__)) gnu_dev_makedev)(unsigned int __major ,
                                                                                unsigned int __minor ) 
{ 


  {
#line 58
  return (((unsigned long long )((__minor & 255U) | ((__major & 4095U) << 8)) | ((unsigned long long )(__minor & 4294967040U) << 12)) | ((unsigned long long )(__major & 4294963200U) << 32));
}
}
#line 465 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__warn_unused_result__,
__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 542
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 733
__inline extern  __attribute__((__nothrow__)) char *( __attribute__((__warn_unused_result__,
__leaf__, __artificial__, __always_inline__)) realpath)(char const   * __restrict  __name ,
                                                        char * __restrict  __resolved ) ;
#line 866
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__warn_unused_result__,
__leaf__, __artificial__, __always_inline__)) wctomb)(char *__s , wchar_t __wchar ) ;
#line 870
__inline extern  __attribute__((__nothrow__)) size_t ( __attribute__((__leaf__, __artificial__,
__always_inline__)) mbstowcs)(wchar_t * __restrict  __dst , char const   * __restrict  __src ,
                              size_t __len ) ;
#line 873
__inline extern  __attribute__((__nothrow__)) size_t ( __attribute__((__leaf__, __artificial__,
__always_inline__)) wcstombs)(char * __restrict  __dst , wchar_t const   * __restrict  __src ,
                              size_t __len ) ;
#line 25 "/usr/include/x86_64-linux-gnu/bits/stdlib-float.h"
__inline extern  __attribute__((__nothrow__)) double ( __attribute__((__warn_unused_result__,
__nonnull__(1), __leaf__)) atof)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 25 "/usr/include/x86_64-linux-gnu/bits/stdlib-float.h"
__inline extern double ( __attribute__((__warn_unused_result__, __nonnull__(1), __leaf__)) atof)(char const   *__nptr ) 
{ 
  double tmp ;

  {
#line 28
  tmp = strtod((char const   * __restrict  )__nptr, (char ** __restrict  )((char **)((void *)0)));
#line 28
  return (tmp);
}
}
#line 23 "/usr/include/x86_64-linux-gnu/bits/stdlib.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__warn_unused_result__,
__leaf__)) __realpath_chk)(char const   * __restrict  __name , char * __restrict  __resolved ,
                           size_t __resolvedlen ) ;
#line 26
extern  __attribute__((__nothrow__)) char *( __attribute__((__warn_unused_result__,
__leaf__)) __realpath_alias)(char const   * __restrict  __name , char * __restrict  __resolved )  __asm__("realpath")  ;
#line 36
__inline extern  __attribute__((__nothrow__)) char *( __attribute__((__warn_unused_result__,
__leaf__, __artificial__, __always_inline__)) realpath)(char const   * __restrict  __name ,
                                                        char * __restrict  __resolved ) ;
#line 36 "/usr/include/x86_64-linux-gnu/bits/stdlib.h"
__inline extern char *( __attribute__((__warn_unused_result__, __leaf__, __artificial__,
__always_inline__)) realpath)(char const   * __restrict  __name , char * __restrict  __resolved ) 
{ 
  unsigned long tmp ;
  char *tmp___0 ;
  unsigned long tmp___1 ;
  char *tmp___2 ;

  {
#line 39
  tmp___1 = __builtin_object_size((void *)__resolved, 1);
#line 39
  if (tmp___1 != 0xffffffffffffffffUL) {
#line 45
    tmp = __builtin_object_size((void *)__resolved, 1);
#line 45
    tmp___0 = __realpath_chk(__name, __resolved, tmp);
#line 45
    return (tmp___0);
  }
#line 48
  tmp___2 = __realpath_alias(__name, __resolved);
#line 48
  return (tmp___2);
}
}
#line 52
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2), __leaf__)) __ptsname_r_chk)(int __fd ,
                                                                                                      char *__buf ,
                                                                                                      size_t __buflen ,
                                                                                                      size_t __nreal ) ;
#line 54
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2), __leaf__)) __ptsname_r_alias)(int __fd ,
                                                                                                        char *__buf ,
                                                                                                        size_t __buflen )  __asm__("ptsname_r")  ;
#line 57
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2), __leaf__)) __ptsname_r_chk_warn)(int __fd ,
                                                                                                           char *__buf ,
                                                                                                           size_t __buflen ,
                                                                                                           size_t __nreal )  __asm__("__ptsname_r_chk") __attribute__((__warning__("ptsname_r called with buflen bigger than size of buf"))) ;
#line 63
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__, __artificial__,
__always_inline__)) ptsname_r)(int __fd , char *__buf , size_t __buflen ) ;
#line 63 "/usr/include/x86_64-linux-gnu/bits/stdlib.h"
__inline extern int ( __attribute__((__leaf__, __artificial__, __always_inline__)) ptsname_r)(int __fd ,
                                                                                              char *__buf ,
                                                                                              size_t __buflen ) 
{ 
  unsigned long tmp ;
  int tmp___0 ;
  unsigned long tmp___1 ;
  int tmp___2 ;
  unsigned long tmp___3 ;
  unsigned long tmp___4 ;
  int tmp___5 ;

  {
#line 66
  tmp___4 = __builtin_object_size((void *)__buf, 1);
#line 66
  if (tmp___4 != 0xffffffffffffffffUL) {
#line 69
    tmp = __builtin_object_size((void *)__buf, 1);
#line 69
    tmp___0 = __ptsname_r_chk(__fd, __buf, __buflen, tmp);
#line 69
    return (tmp___0);
#line 70
    tmp___3 = __builtin_object_size((void *)__buf, 1);
#line 70
    if (__buflen > tmp___3) {
#line 71
      tmp___1 = __builtin_object_size((void *)__buf, 1);
#line 71
      tmp___2 = __ptsname_r_chk_warn(__fd, __buf, __buflen, tmp___1);
#line 71
      return (tmp___2);
    }
  }
#line 73
  tmp___5 = __ptsname_r_alias(__fd, __buf, __buflen);
#line 73
  return (tmp___5);
}
}
#line 77
extern  __attribute__((__nothrow__)) int ( __attribute__((__warn_unused_result__,
__leaf__)) __wctomb_chk)(char *__s , wchar_t __wchar , size_t __buflen ) ;
#line 79
extern  __attribute__((__nothrow__)) int ( __attribute__((__warn_unused_result__,
__leaf__)) __wctomb_alias)(char *__s , wchar_t __wchar )  __asm__("wctomb")  ;
#line 82
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__warn_unused_result__,
__leaf__, __artificial__, __always_inline__)) wctomb)(char *__s , wchar_t __wchar ) ;
#line 82 "/usr/include/x86_64-linux-gnu/bits/stdlib.h"
__inline extern int ( __attribute__((__warn_unused_result__, __leaf__, __artificial__,
__always_inline__)) wctomb)(char *__s , wchar_t __wchar ) 
{ 
  unsigned long tmp ;
  int tmp___0 ;
  unsigned long tmp___1 ;
  unsigned long tmp___2 ;
  int tmp___3 ;

  {
#line 92
  tmp___1 = __builtin_object_size((void *)__s, 1);
#line 92
  if (tmp___1 != 0xffffffffffffffffUL) {
#line 92
    tmp___2 = __builtin_object_size((void *)__s, 1);
#line 92
    if (16UL > tmp___2) {
#line 93
      tmp = __builtin_object_size((void *)__s, 1);
#line 93
      tmp___0 = __wctomb_chk(__s, __wchar, tmp);
#line 93
      return (tmp___0);
    }
  }
#line 94
  tmp___3 = __wctomb_alias(__s, __wchar);
#line 94
  return (tmp___3);
}
}
#line 98
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__leaf__)) __mbstowcs_chk)(wchar_t * __restrict  __dst ,
                                                                                        char const   * __restrict  __src ,
                                                                                        size_t __len ,
                                                                                        size_t __dstlen ) ;
#line 101
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__leaf__)) __mbstowcs_alias)(wchar_t * __restrict  __dst ,
                                                                                          char const   * __restrict  __src ,
                                                                                          size_t __len )  __asm__("mbstowcs")  ;
#line 105
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__leaf__)) __mbstowcs_chk_warn)(wchar_t * __restrict  __dst ,
                                                                                             char const   * __restrict  __src ,
                                                                                             size_t __len ,
                                                                                             size_t __dstlen )  __asm__("__mbstowcs_chk") __attribute__((__warning__("mbstowcs called with dst buffer smaller than len * sizeof (wchar_t)"))) ;
#line 112
__inline extern  __attribute__((__nothrow__)) size_t ( __attribute__((__leaf__, __artificial__,
__always_inline__)) mbstowcs)(wchar_t * __restrict  __dst , char const   * __restrict  __src ,
                              size_t __len ) ;
#line 112 "/usr/include/x86_64-linux-gnu/bits/stdlib.h"
__inline extern size_t ( __attribute__((__leaf__, __artificial__, __always_inline__)) mbstowcs)(wchar_t * __restrict  __dst ,
                                                                                                char const   * __restrict  __src ,
                                                                                                size_t __len ) 
{ 
  unsigned long tmp ;
  size_t tmp___0 ;
  unsigned long tmp___1 ;
  size_t tmp___2 ;
  unsigned long tmp___3 ;
  unsigned long tmp___4 ;
  size_t tmp___5 ;

  {
#line 116
  tmp___4 = __builtin_object_size((void *)__dst, 1);
#line 116
  if (tmp___4 != 0xffffffffffffffffUL) {
#line 119
    tmp = __builtin_object_size((void *)__dst, 1);
#line 119
    tmp___0 = __mbstowcs_chk(__dst, __src, __len, tmp / sizeof(wchar_t ));
#line 119
    return (tmp___0);
#line 122
    tmp___3 = __builtin_object_size((void *)__dst, 1);
#line 122
    if (__len > tmp___3 / sizeof(wchar_t )) {
#line 123
      tmp___1 = __builtin_object_size((void *)__dst, 1);
#line 123
      tmp___2 = __mbstowcs_chk_warn(__dst, __src, __len, tmp___1 / sizeof(wchar_t ));
#line 123
      return (tmp___2);
    }
  }
#line 126
  tmp___5 = __mbstowcs_alias(__dst, __src, __len);
#line 126
  return (tmp___5);
}
}
#line 130
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__leaf__)) __wcstombs_chk)(char * __restrict  __dst ,
                                                                                        wchar_t const   * __restrict  __src ,
                                                                                        size_t __len ,
                                                                                        size_t __dstlen ) ;
#line 133
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__leaf__)) __wcstombs_alias)(char * __restrict  __dst ,
                                                                                          wchar_t const   * __restrict  __src ,
                                                                                          size_t __len )  __asm__("wcstombs")  ;
#line 137
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__leaf__)) __wcstombs_chk_warn)(char * __restrict  __dst ,
                                                                                             wchar_t const   * __restrict  __src ,
                                                                                             size_t __len ,
                                                                                             size_t __dstlen )  __asm__("__wcstombs_chk") __attribute__((__warning__("wcstombs called with dst buffer smaller than len"))) ;
#line 143
__inline extern  __attribute__((__nothrow__)) size_t ( __attribute__((__leaf__, __artificial__,
__always_inline__)) wcstombs)(char * __restrict  __dst , wchar_t const   * __restrict  __src ,
                              size_t __len ) ;
#line 143 "/usr/include/x86_64-linux-gnu/bits/stdlib.h"
__inline extern size_t ( __attribute__((__leaf__, __artificial__, __always_inline__)) wcstombs)(char * __restrict  __dst ,
                                                                                                wchar_t const   * __restrict  __src ,
                                                                                                size_t __len ) 
{ 
  unsigned long tmp ;
  size_t tmp___0 ;
  unsigned long tmp___1 ;
  size_t tmp___2 ;
  unsigned long tmp___3 ;
  unsigned long tmp___4 ;
  size_t tmp___5 ;

  {
#line 147
  tmp___4 = __builtin_object_size((void *)__dst, 1);
#line 147
  if (tmp___4 != 0xffffffffffffffffUL) {
#line 150
    tmp = __builtin_object_size((void *)__dst, 1);
#line 150
    tmp___0 = __wcstombs_chk(__dst, __src, __len, tmp);
#line 150
    return (tmp___0);
#line 151
    tmp___3 = __builtin_object_size((void *)__dst, 1);
#line 151
    if (__len > tmp___3) {
#line 152
      tmp___1 = __builtin_object_size((void *)__dst, 1);
#line 152
      tmp___2 = __wcstombs_chk_warn(__dst, __src, __len, tmp___1);
#line 152
      return (tmp___2);
    }
  }
#line 154
  tmp___5 = __wcstombs_alias(__dst, __src, __len);
#line 154
  return (tmp___5);
}
}
#line 42 "/usr/include/string.h"
__inline extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2),
__leaf__, __artificial__, __always_inline__)) memcpy)(void * __restrict  __dest ,
                                                      void const   * __restrict  __src ,
                                                      size_t __len ) ;
#line 46
__inline extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2),
__leaf__, __artificial__, __always_inline__)) memmove)(void *__dest , void const   *__src ,
                                                       size_t __len ) ;
#line 62
__inline extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1),
__leaf__, __artificial__, __always_inline__)) memset)(void *__dest , int __ch , size_t __len ) ;
#line 125
__inline extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2),
__leaf__, __artificial__, __always_inline__)) strcpy)(char * __restrict  __dest ,
                                                      char const   * __restrict  __src ) ;
#line 128
__inline extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2),
__leaf__, __artificial__, __always_inline__)) strncpy)(char * __restrict  __dest ,
                                                       char const   * __restrict  __src ,
                                                       size_t __len ) ;
#line 133
__inline extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2),
__leaf__, __artificial__, __always_inline__)) strcat)(char * __restrict  __dest ,
                                                      char const   * __restrict  __src ) ;
#line 136
__inline extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2),
__leaf__, __artificial__, __always_inline__)) strncat)(char * __restrict  __dest ,
                                                       char const   * __restrict  __src ,
                                                       size_t __len ) ;
#line 451
__inline extern  __attribute__((__nothrow__)) void ( __attribute__((__nonnull__(1,2),
__leaf__, __artificial__, __always_inline__)) bcopy)(void const   *__src , void *__dest ,
                                                     size_t __len ) ;
#line 455
__inline extern  __attribute__((__nothrow__)) void ( __attribute__((__nonnull__(1),
__leaf__, __artificial__, __always_inline__)) bzero)(void *__dest , size_t __len ) ;
#line 532
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcasecmp)(char const   *__s1 ,
                                                                                                   char const   *__s2 )  __attribute__((__pure__)) ;
#line 575
__inline extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2),
__leaf__, __artificial__, __always_inline__)) stpncpy)(char * __restrict  __dest ,
                                                       char const   * __restrict  __src ,
                                                       size_t __n ) ;
#line 968 "/usr/include/x86_64-linux-gnu/bits/string2.h"
__inline extern size_t __strcspn_c1(char const   *__s , int __reject ) ;
#line 969 "/usr/include/x86_64-linux-gnu/bits/string2.h"
__inline extern size_t __strcspn_c1(char const   *__s , int __reject ) 
{ 
  register size_t __result ;

  {
#line 972
  __result = (size_t )0;
#line 973
  while (1) {
#line 973
    if ((int const   )*(__s + __result) != 0) {
#line 973
      if (! ((int const   )*(__s + __result) != (int const   )__reject)) {
#line 973
        break;
      }
    } else {
#line 973
      break;
    }
#line 974
    __result ++;
  }
#line 975
  return (__result);
}
}
#line 978
__inline extern size_t __strcspn_c2(char const   *__s , int __reject1 , int __reject2 ) ;
#line 980 "/usr/include/x86_64-linux-gnu/bits/string2.h"
__inline extern size_t __strcspn_c2(char const   *__s , int __reject1 , int __reject2 ) 
{ 
  register size_t __result ;

  {
#line 983
  __result = (size_t )0;
#line 984
  while (1) {
#line 984
    if ((int const   )*(__s + __result) != 0) {
#line 984
      if ((int const   )*(__s + __result) != (int const   )__reject1) {
#line 984
        if (! ((int const   )*(__s + __result) != (int const   )__reject2)) {
#line 984
          break;
        }
      } else {
#line 984
        break;
      }
    } else {
#line 984
      break;
    }
#line 986
    __result ++;
  }
#line 987
  return (__result);
}
}
#line 990
__inline extern size_t __strcspn_c3(char const   *__s , int __reject1 , int __reject2 ,
                                    int __reject3 ) ;
#line 992 "/usr/include/x86_64-linux-gnu/bits/string2.h"
__inline extern size_t __strcspn_c3(char const   *__s , int __reject1 , int __reject2 ,
                                    int __reject3 ) 
{ 
  register size_t __result ;

  {
#line 996
  __result = (size_t )0;
#line 997
  while (1) {
#line 997
    if ((int const   )*(__s + __result) != 0) {
#line 997
      if ((int const   )*(__s + __result) != (int const   )__reject1) {
#line 997
        if ((int const   )*(__s + __result) != (int const   )__reject2) {
#line 997
          if (! ((int const   )*(__s + __result) != (int const   )__reject3)) {
#line 997
            break;
          }
        } else {
#line 997
          break;
        }
      } else {
#line 997
        break;
      }
    } else {
#line 997
      break;
    }
#line 999
    __result ++;
  }
#line 1000
  return (__result);
}
}
#line 1044
__inline extern size_t __strspn_c1(char const   *__s , int __accept ) ;
#line 1045 "/usr/include/x86_64-linux-gnu/bits/string2.h"
__inline extern size_t __strspn_c1(char const   *__s , int __accept ) 
{ 
  register size_t __result ;

  {
#line 1048
  __result = (size_t )0;
#line 1050
  while ((int const   )*(__s + __result) == (int const   )__accept) {
#line 1051
    __result ++;
  }
#line 1052
  return (__result);
}
}
#line 1055
__inline extern size_t __strspn_c2(char const   *__s , int __accept1 , int __accept2 ) ;
#line 1057 "/usr/include/x86_64-linux-gnu/bits/string2.h"
__inline extern size_t __strspn_c2(char const   *__s , int __accept1 , int __accept2 ) 
{ 
  register size_t __result ;

  {
#line 1060
  __result = (size_t )0;
#line 1062
  while (1) {
#line 1062
    if (! ((int const   )*(__s + __result) == (int const   )__accept1)) {
#line 1062
      if (! ((int const   )*(__s + __result) == (int const   )__accept2)) {
#line 1062
        break;
      }
    }
#line 1063
    __result ++;
  }
#line 1064
  return (__result);
}
}
#line 1067
__inline extern size_t __strspn_c3(char const   *__s , int __accept1 , int __accept2 ,
                                   int __accept3 ) ;
#line 1069 "/usr/include/x86_64-linux-gnu/bits/string2.h"
__inline extern size_t __strspn_c3(char const   *__s , int __accept1 , int __accept2 ,
                                   int __accept3 ) 
{ 
  register size_t __result ;

  {
#line 1072
  __result = (size_t )0;
#line 1074
  while (1) {
#line 1074
    if (! ((int const   )*(__s + __result) == (int const   )__accept1)) {
#line 1074
      if (! ((int const   )*(__s + __result) == (int const   )__accept2)) {
#line 1074
        if (! ((int const   )*(__s + __result) == (int const   )__accept3)) {
#line 1074
          break;
        }
      }
    }
#line 1076
    __result ++;
  }
#line 1077
  return (__result);
}
}
#line 1120
__inline extern char *__strpbrk_c2(char const   *__s , int __accept1 , int __accept2 ) ;
#line 1122 "/usr/include/x86_64-linux-gnu/bits/string2.h"
__inline extern char *__strpbrk_c2(char const   *__s , int __accept1 , int __accept2 ) 
{ 
  char *tmp ;

  {
#line 1126
  while (1) {
#line 1126
    if ((int const   )*__s != 0) {
#line 1126
      if ((int const   )*__s != (int const   )__accept1) {
#line 1126
        if (! ((int const   )*__s != (int const   )__accept2)) {
#line 1126
          break;
        }
      } else {
#line 1126
        break;
      }
    } else {
#line 1126
      break;
    }
#line 1127
    __s ++;
  }
#line 1128
  if ((int const   )*__s == 0) {
#line 1128
    tmp = (char *)((void *)0);
  } else {
#line 1128
    tmp = (char *)((size_t )__s);
  }
#line 1128
  return (tmp);
}
}
#line 1131
__inline extern char *__strpbrk_c3(char const   *__s , int __accept1 , int __accept2 ,
                                   int __accept3 ) ;
#line 1133 "/usr/include/x86_64-linux-gnu/bits/string2.h"
__inline extern char *__strpbrk_c3(char const   *__s , int __accept1 , int __accept2 ,
                                   int __accept3 ) 
{ 
  char *tmp ;

  {
#line 1137
  while (1) {
#line 1137
    if ((int const   )*__s != 0) {
#line 1137
      if ((int const   )*__s != (int const   )__accept1) {
#line 1137
        if ((int const   )*__s != (int const   )__accept2) {
#line 1137
          if (! ((int const   )*__s != (int const   )__accept3)) {
#line 1137
            break;
          }
        } else {
#line 1137
          break;
        }
      } else {
#line 1137
        break;
      }
    } else {
#line 1137
      break;
    }
#line 1139
    __s ++;
  }
#line 1140
  if ((int const   )*__s == 0) {
#line 1140
    tmp = (char *)((void *)0);
  } else {
#line 1140
    tmp = (char *)((size_t )__s);
  }
#line 1140
  return (tmp);
}
}
#line 1170
__inline extern char *__strtok_r_1c(char *__s , char __sep , char **__nextp ) ;
#line 1171 "/usr/include/x86_64-linux-gnu/bits/string2.h"
__inline extern char *__strtok_r_1c(char *__s , char __sep , char **__nextp ) 
{ 
  char *__result ;
  char *tmp ;
  char *tmp___0 ;

  {
#line 1175
  if ((unsigned long )__s == (unsigned long )((void *)0)) {
#line 1176
    __s = *__nextp;
  }
#line 1177
  while ((int )*__s == (int )__sep) {
#line 1178
    __s ++;
  }
#line 1179
  __result = (char *)((void *)0);
#line 1180
  if ((int )*__s != 0) {
#line 1182
    tmp = __s;
#line 1182
    __s ++;
#line 1182
    __result = tmp;
#line 1183
    while ((int )*__s != 0) {
#line 1184
      tmp___0 = __s;
#line 1184
      __s ++;
#line 1184
      if ((int )*tmp___0 == (int )__sep) {
#line 1186
        *(__s + -1) = (char )'\000';
#line 1187
        break;
      }
    }
  }
#line 1190
  *__nextp = __s;
#line 1191
  return (__result);
}
}
#line 1220
__inline extern char *__strsep_1c(char **__s , char __reject ) ;
#line 1221 "/usr/include/x86_64-linux-gnu/bits/string2.h"
__inline extern char *__strsep_1c(char **__s , char __reject ) 
{ 
  register char *__retval ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___2 ;

  {
#line 1224
  __retval = *__s;
#line 1225
  if ((unsigned long )__retval != (unsigned long )((void *)0)) {
#line 1225
    tmp___2 = __builtin_strchr(__retval, (int )__reject);
#line 1225
    tmp___0 = tmp___2;
#line 1225
    *__s = tmp___0;
#line 1225
    if ((unsigned long )tmp___0 != (unsigned long )((void *)0)) {
#line 1226
      tmp = *__s;
#line 1226
      (*__s) ++;
#line 1226
      *tmp = (char )'\000';
    }
  }
#line 1227
  return (__retval);
}
}
#line 1230
__inline extern char *__strsep_2c(char **__s , char __reject1 , char __reject2 ) ;
#line 1231 "/usr/include/x86_64-linux-gnu/bits/string2.h"
__inline extern char *__strsep_2c(char **__s , char __reject1 , char __reject2 ) 
{ 
  register char *__retval ;
  register char *__cp ;
  char *tmp ;

  {
#line 1234
  __retval = *__s;
#line 1235
  if ((unsigned long )__retval != (unsigned long )((void *)0)) {
#line 1237
    __cp = __retval;
#line 1238
    while (1) {
#line 1240
      if ((int )*__cp == 0) {
#line 1242
        __cp = (char *)((void *)0);
#line 1243
        break;
      }
#line 1245
      if ((int )*__cp == (int )__reject1) {
#line 1247
        tmp = __cp;
#line 1247
        __cp ++;
#line 1247
        *tmp = (char )'\000';
#line 1248
        break;
      } else
#line 1245
      if ((int )*__cp == (int )__reject2) {
#line 1247
        tmp = __cp;
#line 1247
        __cp ++;
#line 1247
        *tmp = (char )'\000';
#line 1248
        break;
      }
#line 1250
      __cp ++;
    }
#line 1252
    *__s = __cp;
  }
#line 1254
  return (__retval);
}
}
#line 1257
__inline extern char *__strsep_3c(char **__s , char __reject1 , char __reject2 , char __reject3 ) ;
#line 1259 "/usr/include/x86_64-linux-gnu/bits/string2.h"
__inline extern char *__strsep_3c(char **__s , char __reject1 , char __reject2 , char __reject3 ) 
{ 
  register char *__retval ;
  register char *__cp ;
  char *tmp ;

  {
#line 1262
  __retval = *__s;
#line 1263
  if ((unsigned long )__retval != (unsigned long )((void *)0)) {
#line 1265
    __cp = __retval;
#line 1266
    while (1) {
#line 1268
      if ((int )*__cp == 0) {
#line 1270
        __cp = (char *)((void *)0);
#line 1271
        break;
      }
#line 1273
      if ((int )*__cp == (int )__reject1) {
#line 1275
        tmp = __cp;
#line 1275
        __cp ++;
#line 1275
        *tmp = (char )'\000';
#line 1276
        break;
      } else
#line 1273
      if ((int )*__cp == (int )__reject2) {
#line 1275
        tmp = __cp;
#line 1275
        __cp ++;
#line 1275
        *tmp = (char )'\000';
#line 1276
        break;
      } else
#line 1273
      if ((int )*__cp == (int )__reject3) {
#line 1275
        tmp = __cp;
#line 1275
        __cp ++;
#line 1275
        *tmp = (char )'\000';
#line 1276
        break;
      }
#line 1278
      __cp ++;
    }
#line 1280
    *__s = __cp;
  }
#line 1282
  return (__retval);
}
}
#line 1301
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) __strdup)(char const   *__string )  __attribute__((__malloc__)) ;
#line 47 "/usr/include/x86_64-linux-gnu/bits/string3.h"
__inline extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2),
__leaf__, __artificial__, __always_inline__)) memcpy)(void * __restrict  __dest ,
                                                      void const   * __restrict  __src ,
                                                      size_t __len ) ;
#line 47 "/usr/include/x86_64-linux-gnu/bits/string3.h"
__inline extern void *( __attribute__((__nonnull__(1,2), __leaf__, __artificial__,
__always_inline__)) memcpy)(void * __restrict  __dest , void const   * __restrict  __src ,
                            size_t __len ) 
{ 
  unsigned long tmp ;
  void *tmp___0 ;

  {
#line 51
  tmp = __builtin_object_size((void *)__dest, 0);
#line 51
  tmp___0 = __builtin___memcpy_chk((void *)__dest, (void const   *)__src, __len, tmp);
#line 51
  return (tmp___0);
}
}
#line 54
__inline extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2),
__leaf__, __artificial__, __always_inline__)) memmove)(void *__dest , void const   *__src ,
                                                       size_t __len ) ;
#line 54 "/usr/include/x86_64-linux-gnu/bits/string3.h"
__inline extern void *( __attribute__((__nonnull__(1,2), __leaf__, __artificial__,
__always_inline__)) memmove)(void *__dest , void const   *__src , size_t __len ) 
{ 
  unsigned long tmp ;
  void *tmp___0 ;

  {
#line 57
  tmp = __builtin_object_size(__dest, 0);
#line 57
  tmp___0 = __builtin___memmove_chk(__dest, __src, __len, tmp);
#line 57
  return (tmp___0);
}
}
#line 75
__inline extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1),
__leaf__, __artificial__, __always_inline__)) memset)(void *__dest , int __ch , size_t __len ) ;
#line 75 "/usr/include/x86_64-linux-gnu/bits/string3.h"
__inline extern void *( __attribute__((__nonnull__(1), __leaf__, __artificial__, __always_inline__)) memset)(void *__dest ,
                                                                                                             int __ch ,
                                                                                                             size_t __len ) 
{ 
  unsigned long tmp ;
  void *tmp___0 ;

  {
#line 84
  tmp = __builtin_object_size(__dest, 0);
#line 84
  tmp___0 = __builtin___memset_chk(__dest, __ch, __len, tmp);
#line 84
  return (tmp___0);
}
}
#line 88
__inline extern  __attribute__((__nothrow__)) void ( __attribute__((__nonnull__(1,2),
__leaf__, __artificial__, __always_inline__)) bcopy)(void const   *__src , void *__dest ,
                                                     size_t __len ) ;
#line 88 "/usr/include/x86_64-linux-gnu/bits/string3.h"
__inline extern void ( __attribute__((__nonnull__(1,2), __leaf__, __artificial__,
__always_inline__)) bcopy)(void const   *__src , void *__dest , size_t __len ) 
{ 
  unsigned long tmp ;

  {
#line 91
  tmp = __builtin_object_size(__dest, 0);
#line 91
  __builtin___memmove_chk(__dest, __src, __len, tmp);
#line 92
  return;
}
}
#line 94
__inline extern  __attribute__((__nothrow__)) void ( __attribute__((__nonnull__(1),
__leaf__, __artificial__, __always_inline__)) bzero)(void *__dest , size_t __len ) ;
#line 94 "/usr/include/x86_64-linux-gnu/bits/string3.h"
__inline extern void ( __attribute__((__nonnull__(1), __leaf__, __artificial__, __always_inline__)) bzero)(void *__dest ,
                                                                                                           size_t __len ) 
{ 
  unsigned long tmp ;

  {
#line 97
  tmp = __builtin_object_size(__dest, 0);
#line 97
  __builtin___memset_chk(__dest, '\000', __len, tmp);
#line 98
  return;
}
}
#line 101
__inline extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2),
__leaf__, __artificial__, __always_inline__)) strcpy)(char * __restrict  __dest ,
                                                      char const   * __restrict  __src ) ;
#line 101 "/usr/include/x86_64-linux-gnu/bits/string3.h"
__inline extern char *( __attribute__((__nonnull__(1,2), __leaf__, __artificial__,
__always_inline__)) strcpy)(char * __restrict  __dest , char const   * __restrict  __src ) 
{ 
  unsigned long tmp ;
  char *tmp___0 ;

  {
#line 104
  tmp = __builtin_object_size((void *)__dest, 1);
#line 104
  tmp___0 = __builtin___strcpy_chk((char *)__dest, (char const   *)__src, tmp);
#line 104
  return (tmp___0);
}
}
#line 116
__inline extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2),
__leaf__, __artificial__, __always_inline__)) strncpy)(char * __restrict  __dest ,
                                                       char const   * __restrict  __src ,
                                                       size_t __len ) ;
#line 116 "/usr/include/x86_64-linux-gnu/bits/string3.h"
__inline extern char *( __attribute__((__nonnull__(1,2), __leaf__, __artificial__,
__always_inline__)) strncpy)(char * __restrict  __dest , char const   * __restrict  __src ,
                             size_t __len ) 
{ 
  unsigned long tmp ;
  char *tmp___0 ;

  {
#line 120
  tmp = __builtin_object_size((void *)__dest, 1);
#line 120
  tmp___0 = __builtin___strncpy_chk((char *)__dest, (char const   *)__src, __len,
                                    tmp);
#line 120
  return (tmp___0);
}
}
#line 124
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) __stpncpy_chk)(char *__dest ,
                                                                                      char const   *__src ,
                                                                                      size_t __n ,
                                                                                      size_t __destlen ) ;
#line 126
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) __stpncpy_alias)(char *__dest ,
                                                                                        char const   *__src ,
                                                                                        size_t __n )  __asm__("stpncpy")  ;
#line 129
__inline extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2),
__leaf__, __artificial__, __always_inline__)) stpncpy)(char * __restrict  __dest ,
                                                       char const   * __restrict  __src ,
                                                       size_t __n ) ;
#line 129 "/usr/include/x86_64-linux-gnu/bits/string3.h"
__inline extern char *( __attribute__((__nonnull__(1,2), __leaf__, __artificial__,
__always_inline__)) stpncpy)(char * __restrict  __dest , char const   * __restrict  __src ,
                             size_t __n ) 
{ 
  unsigned long tmp ;
  char *tmp___0 ;
  unsigned long tmp___1 ;
  char *tmp___3 ;

  {
#line 132
  tmp___1 = __builtin_object_size((void *)__dest, 1);
#line 132
  if (tmp___1 != 0xffffffffffffffffUL) {
#line 134
    tmp = __builtin_object_size((void *)__dest, 1);
#line 134
    tmp___0 = __stpncpy_chk((char *)__dest, (char const   *)__src, __n, tmp);
#line 134
    return (tmp___0);
  }
#line 135
  tmp___3 = __stpncpy_alias((char *)__dest, (char const   *)__src, __n);
#line 135
  return (tmp___3);
}
}
#line 139
__inline extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2),
__leaf__, __artificial__, __always_inline__)) strcat)(char * __restrict  __dest ,
                                                      char const   * __restrict  __src ) ;
#line 139 "/usr/include/x86_64-linux-gnu/bits/string3.h"
__inline extern char *( __attribute__((__nonnull__(1,2), __leaf__, __artificial__,
__always_inline__)) strcat)(char * __restrict  __dest , char const   * __restrict  __src ) 
{ 
  unsigned long tmp ;
  char *tmp___0 ;

  {
#line 142
  tmp = __builtin_object_size((void *)__dest, 1);
#line 142
  tmp___0 = __builtin___strcat_chk((char *)__dest, (char const   *)__src, tmp);
#line 142
  return (tmp___0);
}
}
#line 146
__inline extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2),
__leaf__, __artificial__, __always_inline__)) strncat)(char * __restrict  __dest ,
                                                       char const   * __restrict  __src ,
                                                       size_t __len ) ;
#line 146 "/usr/include/x86_64-linux-gnu/bits/string3.h"
__inline extern char *( __attribute__((__nonnull__(1,2), __leaf__, __artificial__,
__always_inline__)) strncat)(char * __restrict  __dest , char const   * __restrict  __src ,
                             size_t __len ) 
{ 
  unsigned long tmp ;
  char *tmp___0 ;

  {
#line 150
  tmp = __builtin_object_size((void *)__dest, 1);
#line 150
  tmp___0 = __builtin___strncat_chk((char *)__dest, (char const   *)__src, __len,
                                    tmp);
#line 150
  return (tmp___0);
}
}
#line 157 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h"
extern  __attribute__((__nothrow__)) double ( __attribute__((__leaf__)) sqrt)(double __x ) ;
#line 350
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__, __always_inline__)) __signbit)(double __x )  __attribute__((__const__)) ;
#line 350
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__, __always_inline__)) __signbitf)(float __x )  __attribute__((__const__)) ;
#line 350
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__, __always_inline__)) __signbitl)(long double __x )  __attribute__((__const__)) ;
#line 126 "/usr/include/x86_64-linux-gnu/bits/mathinline.h"
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__, __always_inline__)) __signbitf)(float __x )  __attribute__((__const__)) ;
#line 126 "/usr/include/x86_64-linux-gnu/bits/mathinline.h"
__inline extern int ( __attribute__((__leaf__, __always_inline__)) __signbitf)(float __x ) 
{ 
  int __m ;

  {
#line 131
  __asm__  ("pmovmskb %1, %0": "=r" (__m): "x" (__x));
#line 132
  return ((__m & 8) != 0);
}
}
#line 138
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__, __always_inline__)) __signbit)(double __x )  __attribute__((__const__)) ;
#line 138 "/usr/include/x86_64-linux-gnu/bits/mathinline.h"
__inline extern int ( __attribute__((__leaf__, __always_inline__)) __signbit)(double __x ) 
{ 
  int __m ;

  {
#line 143
  __asm__  ("pmovmskb %1, %0": "=r" (__m): "x" (__x));
#line 144
  return ((__m & 128) != 0);
}
}
#line 150
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__, __always_inline__)) __signbitl)(long double __x )  __attribute__((__const__)) ;
#line 150 "/usr/include/x86_64-linux-gnu/bits/mathinline.h"
__inline extern int ( __attribute__((__leaf__, __always_inline__)) __signbitl)(long double __x ) 
{ 
  union __anonunion___u_26 __u ;

  {
#line 153
  __u.__l = __x;
#line 154
  return ((__u.__i[2] & 32768) != 0);
}
}
#line 151 "src/csuCommonUtil.h"
void *csu_allocate(char const   *type , int sof , int num , char const   *file , int line ) ;
#line 192 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) time_t ( __attribute__((__leaf__)) time)(time_t *__timer ) ;
#line 264
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) ctime)(time_t const   *__timer ) ;
#line 251 "src/csuCommonUtil.h"
int debuglevel ;
#line 252
int quiet ;
#line 92 "src/csuCommonMatrix.h"
Matrix makeMatrix(int row_dim , int col_dim ) ;
#line 93
void freeMatrix(Matrix A ) ;
#line 95
Matrix makeZeroMatrix(int row_dim , int col_dim ) ;
#line 135 "src/csuCommonFile.h"
char *makePath(char const   *directoryName , char const   *fileName ) ;
#line 149
ImageList *getImageNames(char *imageNamesFile , int *numImages ) ;
#line 122 "src/csuCommonCommandLine.h"
void usage(char const   *name ) ;
#line 125
int readOption(int argc , char **argv , int *i , char const   *opt ) ;
#line 138
int readOptionInt(int argc , char **argv , int *i , char const   *opt , int *arg ) ;
#line 159
int checkBadOption(int argc , char **argv , int *i ) ;
#line 162
void clParseError(int argc , char **argv , int i , char *message ) ;
#line 92 "src/csuEBGMUtil.h"
double WiskottDCFree  ;
#line 250
FaceGraph loadFaceGraph(char *filename ) ;
#line 130 "src/csuEBGMSimilarity.h"
double GeometrySimL2(FaceGraph f1 , FaceGraph f2 ) ;
#line 131
double GeometrySimCorrelation(FaceGraph f1 , FaceGraph f2 ) ;
#line 132
double GeometrySimLeastSquares(FaceGraph f1 , FaceGraph f2 ) ;
#line 133
double GeometrySimLeastSquaresPS(FaceGraph f1 , FaceGraph f2 ) ;
#line 134
double GeometrySimLeastSquaresPI(FaceGraph f1 , FaceGraph f2 ) ;
#line 135
double GeometrySimLeastSquaresFLS(FaceGraph f1 , FaceGraph f2 ) ;
#line 136
double GeometrySimLeastSquaresNLS(FaceGraph f1 , FaceGraph f2 ) ;
#line 139
double fgSimMagnitude(FaceGraph f1 , FaceGraph f2 ) ;
#line 140
double fgSimPhase(FaceGraph f1 , FaceGraph f2 ) ;
#line 141
double fgSimPhaseGridSample(FaceGraph f1 , FaceGraph f2 ) ;
#line 142
double fgSimPhasePredictiveStep(FaceGraph f1 , FaceGraph f2 ) ;
#line 143
double fgSimPhasePredictiveIter(FaceGraph f1 , FaceGraph f2 ) ;
#line 144
double fgSimPhaseFixedLocalSearch(FaceGraph f1 , FaceGraph f2 ) ;
#line 145
double fgSimPhaseNarrowingLocalSearch(FaceGraph f1 , FaceGraph f2 ) ;
#line 93 "src/csuEBGMMeasure.c"
time_t start_time  ;
#line 114 "src/csuEBGMMeasure.c"
int completed  =    0;
#line 115 "src/csuEBGMMeasure.c"
int total  =    0;
#line 119 "src/csuEBGMMeasure.c"
void usage(char const   *name ) 
{ 


  {
#line 120
  printf((char const   * __restrict  )"useage: %s imagelist.srt face_graph_dir dist_measure distance_dir\n\n",
         name);
#line 122
  printf((char const   * __restrict  )"**************************** DISCRIPTION ****************************\n");
#line 123
  printf((char const   * __restrict  )"* csuGaborMeasure                                                   *\n");
#line 124
  printf((char const   * __restrict  )"*                                                                   *\n");
#line 125
  printf((char const   * __restrict  )"* This program reads face graphs from a directory and computes the  *\n");
#line 126
  printf((char const   * __restrict  )"* similarity matrix between those graphs.  The matrix is saved to   *\n");
#line 127
  printf((char const   * __restrict  )"* the specified distance directory for use with the analysis tools. *\n");
#line 128
  printf((char const   * __restrict  )"*                                                                   *\n");
#line 129
  printf((char const   * __restrict  )"*********************************************************************\n");
#line 130
  printf((char const   * __restrict  )"\n");
#line 131
  printf((char const   * __restrict  )"Arguments:\n");
#line 132
  printf((char const   * __restrict  )"imagelist.srt  - This is the list of faces for which the image\n");
#line 133
  printf((char const   * __restrict  )"                 distances are computed.\n");
#line 134
  printf((char const   * __restrict  )"face_graph_dir - The directory that contains the face graphs,\n");
#line 135
  printf((char const   * __restrict  )"                 produced by csuGaborFaceGraph.\n");
#line 136
  printf((char const   * __restrict  )"dist_measure   - A label specifying the distance measure to be used\n");
#line 137
  printf((char const   * __restrict  )"distance_dir   - The output directory that will contain distance\n");
#line 138
  printf((char const   * __restrict  )"                 files that can be used by the csuAnalysis tools.\n");
#line 139
  printf((char const   * __restrict  )"\n");
#line 140
  printf((char const   * __restrict  )"Distance Measure is one of the following options:\n");
#line 141
  printf((char const   * __restrict  )"        FGMagnitude\n");
#line 142
  printf((char const   * __restrict  )"        FGPhase\n");
#line 143
  printf((char const   * __restrict  )"        FGGridSample\n");
#line 144
  printf((char const   * __restrict  )"        FGPredictiveStep\n");
#line 145
  printf((char const   * __restrict  )"        FGPredictiveIter\n");
#line 146
  printf((char const   * __restrict  )"        FGFixedLocalSearch\n");
#line 147
  printf((char const   * __restrict  )"        FGNarrowingLocalSearch\n");
#line 148
  printf((char const   * __restrict  )"        GeoSimL2\n");
#line 149
  printf((char const   * __restrict  )"        GeoSimCorrelation\n");
#line 150
  printf((char const   * __restrict  )"        GeoSimLeastSquares\n");
#line 151
  printf((char const   * __restrict  )"        GeoSimLeastSquaresPS\n");
#line 152
  printf((char const   * __restrict  )"        GeoSimLeastSquaresPI\n");
#line 153
  printf((char const   * __restrict  )"        GeoSimLeastSquaresFLS\n");
#line 154
  printf((char const   * __restrict  )"        GeoSimLeastSquaresNLS\n");
#line 155
  printf((char const   * __restrict  )"\n");
#line 156
  exit(1);
}
}
#line 161 "src/csuEBGMMeasure.c"
void processCommand(int argc , char **argv , Arguments *args ) 
{ 
  int i ;
  int param_num ;
  DistDirNode *tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  time_t tttt ;
  time_t tmp___15 ;
  char *tmp___16 ;
  char *tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;
  int tmp___25 ;
  int tmp___26 ;
  int tmp___27 ;
  time_t tttt___0 ;
  time_t tmp___28 ;
  char *tmp___29 ;

  {
#line 163
  param_num = 0;
#line 167
  args->argv = argv;
#line 168
  args->argc = argc;
#line 169
  args->imageNamesFile = (char *)((void *)0);
#line 170
  args->faceGraphDir = (char *)((void *)0);
#line 171
  args->distList = (DistDirNode *)((void *)0);
#line 173
  debuglevel = 0;
#line 177
  i = 1;
#line 177
  while (i < argc) {
#line 180
    tmp___27 = readOption(argc, argv, & i, "-help");
#line 180
    if (tmp___27) {
#line 180
      usage((char const   *)*(argv + 0));
    } else {
#line 181
      tmp___26 = readOption(argc, argv, & i, "--help");
#line 181
      if (tmp___26) {
#line 181
        usage((char const   *)*(argv + 0));
      } else {
#line 184
        tmp___25 = readOption(argc, argv, & i, "-quiet");
#line 184
        if (tmp___25) {
#line 184
          quiet = 1;
        } else {
#line 185
          tmp___24 = readOptionInt(argc, argv, & i, "-debuglevel", & debuglevel);
#line 185
          if (! tmp___24) {
#line 188
            tmp___23 = checkBadOption(argc, argv, & i);
#line 188
            if (! tmp___23) {
#line 191
              if (param_num == 0) {
#line 192
                args->imageNamesFile = *(argv + i);
#line 193
                param_num ++;
              } else
#line 195
              if (param_num == 1) {
#line 196
                args->faceGraphDir = *(argv + i);
#line 197
                param_num ++;
              } else
#line 199
              if (param_num > 1) {
#line 200
                tmp___0 = malloc(sizeof(DistDirNode ));
#line 200
                tmp = (DistDirNode *)tmp___0;
#line 201
                tmp->next = args->distList;
#line 202
                tmp___14 = strcasecmp((char const   *)*(argv + i), "FGMagnitude");
#line 202
                if (tmp___14 == 0) {
#line 202
                  tmp->distMeasure = & fgSimMagnitude;
                } else {
#line 203
                  tmp___13 = strcasecmp((char const   *)*(argv + i), "FGPhase");
#line 203
                  if (tmp___13 == 0) {
#line 203
                    tmp->distMeasure = & fgSimPhase;
                  } else {
#line 204
                    tmp___12 = strcasecmp((char const   *)*(argv + i), "FGGridSample");
#line 204
                    if (tmp___12 == 0) {
#line 204
                      tmp->distMeasure = & fgSimPhaseGridSample;
                    } else {
#line 205
                      tmp___11 = strcasecmp((char const   *)*(argv + i), "FGPredictiveStep");
#line 205
                      if (tmp___11 == 0) {
#line 205
                        tmp->distMeasure = & fgSimPhasePredictiveStep;
                      } else {
#line 206
                        tmp___10 = strcasecmp((char const   *)*(argv + i), "FGPredictiveIter");
#line 206
                        if (tmp___10 == 0) {
#line 206
                          tmp->distMeasure = & fgSimPhasePredictiveIter;
                        } else {
#line 207
                          tmp___9 = strcasecmp((char const   *)*(argv + i), "FGFixedLocalSearch");
#line 207
                          if (tmp___9 == 0) {
#line 207
                            tmp->distMeasure = & fgSimPhaseFixedLocalSearch;
                          } else {
#line 208
                            tmp___8 = strcasecmp((char const   *)*(argv + i), "FGNarrowingLocalSearch");
#line 208
                            if (tmp___8 == 0) {
#line 208
                              tmp->distMeasure = & fgSimPhaseNarrowingLocalSearch;
                            } else {
#line 209
                              tmp___7 = strcasecmp((char const   *)*(argv + i), "GeoSimL2");
#line 209
                              if (tmp___7 == 0) {
#line 209
                                tmp->distMeasure = & GeometrySimL2;
                              } else {
#line 210
                                tmp___6 = strcasecmp((char const   *)*(argv + i),
                                                     "GeoSimCorrelation");
#line 210
                                if (tmp___6 == 0) {
#line 210
                                  tmp->distMeasure = & GeometrySimCorrelation;
                                } else {
#line 211
                                  tmp___5 = strcasecmp((char const   *)*(argv + i),
                                                       "GeoSimLeastSquares");
#line 211
                                  if (tmp___5 == 0) {
#line 211
                                    tmp->distMeasure = & GeometrySimLeastSquares;
                                  } else {
#line 212
                                    tmp___4 = strcasecmp((char const   *)*(argv + i),
                                                         "GeoSimLeastSquaresPS");
#line 212
                                    if (tmp___4 == 0) {
#line 212
                                      tmp->distMeasure = & GeometrySimLeastSquaresPS;
                                    } else {
#line 213
                                      tmp___3 = strcasecmp((char const   *)*(argv + i),
                                                           "GeoSimLeastSquaresPI");
#line 213
                                      if (tmp___3 == 0) {
#line 213
                                        tmp->distMeasure = & GeometrySimLeastSquaresPI;
                                      } else {
#line 214
                                        tmp___2 = strcasecmp((char const   *)*(argv + i),
                                                             "GeoSimLeastSquaresFLS");
#line 214
                                        if (tmp___2 == 0) {
#line 214
                                          tmp->distMeasure = & GeometrySimLeastSquaresFLS;
                                        } else {
#line 215
                                          tmp___1 = strcasecmp((char const   *)*(argv + i),
                                                               "GeoSimLeastSquaresNLS");
#line 215
                                          if (tmp___1 == 0) {
#line 215
                                            tmp->distMeasure = & GeometrySimLeastSquaresNLS;
                                          } else {
#line 216
                                            clParseError(argc, argv, i, (char *)"Unrecognized FaceGraph Similarity function");
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
#line 218
                i ++;
#line 219
                if (! (i < argc)) {
#line 219
                  tmp___15 = time((time_t *)0);
#line 219
                  tttt = tmp___15;
#line 219
                  tmp___16 = ctime((time_t const   *)(& tttt));
#line 219
                  printf((char const   * __restrict  )"**DEBUG CHECK** Failed check (%s) \"%s\"\n             at [%s]<%s():line %u>\n             %s\n",
                         "i < argc", "Distance directory expected at end of argument list.",
                         "src/csuEBGMMeasure.c", "processCommand", 219, tmp___16);
#line 219
                  fflush(stdout);
#line 219
                  exit(1);
                }
#line 220
                tmp___22 = __strdup((char const   *)*(argv + i));
#line 220
                tmp->distDirectory = tmp___22;
#line 221
                args->distList = tmp;
#line 222
                param_num ++;
              }
            }
          }
        }
      }
    }
#line 177
    i ++;
  }
#line 228
  if (param_num < 2) {
#line 228
    clParseError(argc, argv, i, (char *)"Wrong number of required arguments");
  }
#line 230
  if (1 <= debuglevel) {
#line 230
    tmp___28 = time((time_t *)0);
#line 230
    tttt___0 = tmp___28;
#line 230
    tmp___29 = ctime((time_t const   *)(& tttt___0));
#line 230
    printf((char const   * __restrict  )"**DEBUG %d** \"%s\"\n             at [%s]<%s():line %u>\n             %s\n",
           1, "Debuging enabled", "src/csuEBGMMeasure.c", "processCommand", 230, tmp___29);
#line 230
    fflush(stdout);
  }
#line 231
  return;
}
}
#line 235 "src/csuEBGMMeasure.c"
void NormalizeGeometry(FaceGraph f1 ) 
{ 
  int i ;
  double sum1 ;
  double mean1 ;
  double len1 ;
  double sqsum1 ;
  Matrix g1 ;
  Matrix tmp ;
  double tmp___0 ;

  {
#line 237
  sum1 = 0.0;
#line 238
  mean1 = 0.0;
#line 239
  len1 = 0.0;
#line 240
  sqsum1 = 0.0;
#line 242
  tmp = makeMatrix(f1->geosize * 2, 1);
#line 242
  g1 = tmp;
#line 244
  i = 0;
#line 244
  while (i < g1->row_dim) {
#line 245
    if (i % 2) {
#line 245
      *(*(g1->cols + 0) + i) = (*(f1->jets + i / 2))->y;
    } else {
#line 245
      *(*(g1->cols + 0) + i) = (*(f1->jets + i / 2))->x;
    }
#line 244
    i ++;
  }
#line 248
  i = 0;
#line 248
  while (i < g1->row_dim) {
#line 249
    sum1 += *(*(g1->cols + 0) + i);
#line 248
    i ++;
  }
#line 252
  mean1 = sum1 / (double )g1->row_dim;
#line 254
  i = 0;
#line 254
  while (i < g1->row_dim) {
#line 255
    *(*(g1->cols + 0) + i) -= mean1;
#line 256
    sqsum1 += *(*(g1->cols + 0) + i) * *(*(g1->cols + 0) + i);
#line 254
    i ++;
  }
#line 259
  tmp___0 = sqrt(sqsum1);
#line 259
  len1 = 1.0 / tmp___0;
#line 261
  i = 0;
#line 261
  while (i < g1->row_dim) {
#line 262
    *(*(g1->cols + 0) + i) *= len1;
#line 261
    i ++;
  }
#line 265
  i = 0;
#line 265
  while (i < f1->geosize) {
#line 266
    (*(f1->jets + i))->x = *(*(g1->cols + 0) + 2 * i);
#line 267
    (*(f1->jets + i))->y = *(*(g1->cols + 0) + (2 * i + 1));
#line 265
    i ++;
  }
#line 270
  freeMatrix(g1);
#line 271
  return;
}
}
#line 276
void computeDistanceMatrix(Matrix distance , FaceGraph *graphs , int mini , int maxi ,
                           int minj , int maxj , double (*distMeasure)(FaceGraph  ,
                                                                       FaceGraph  ) ) ;
#line 276 "src/csuEBGMMeasure.c"
static time_t current_time  =    (time_t )0;
#line 274 "src/csuEBGMMeasure.c"
void computeDistanceMatrix(Matrix distance , FaceGraph *graphs , int mini , int maxi ,
                           int minj , int maxj , double (*distMeasure)(FaceGraph  ,
                                                                       FaceGraph  ) ) 
{ 
  int i ;
  int j ;
  int sizei ;
  int sizej ;
  int hour ;
  int min ;
  int sec ;
  double remaining_time ;
  time_t tmp ;

  {
#line 278
  if (maxi - mini > 8) {
#line 278
    goto _L;
  } else
#line 278
  if (maxi - mini > 8) {
    _L: /* CIL Label */ 
#line 279
    sizei = maxi - mini;
#line 280
    sizej = maxj - minj;
#line 281
    computeDistanceMatrix(distance, graphs, mini, mini + sizei / 2, minj, minj + sizej / 2,
                          distMeasure);
#line 282
    computeDistanceMatrix(distance, graphs, mini + sizei / 2, maxi, minj, minj + sizej / 2,
                          distMeasure);
#line 283
    computeDistanceMatrix(distance, graphs, mini, mini + sizei / 2, minj + sizej / 2,
                          maxj, distMeasure);
#line 284
    computeDistanceMatrix(distance, graphs, mini + sizei / 2, maxi, minj + sizej / 2,
                          maxj, distMeasure);
#line 285
    tmp = time((time_t *)((void *)0));
#line 285
    if (current_time + 10L < tmp) {
#line 289
      current_time = time((time_t *)((void *)0));
#line 290
      remaining_time = (((double )total - (double )completed) * ((double )current_time - (double )start_time)) / (double )completed;
#line 291
      hour = (int )remaining_time / 3600;
#line 292
      min = ((int )remaining_time % 3600) / 60;
#line 293
      sec = (int )remaining_time % 60;
#line 294
      printf((char const   * __restrict  )"Measuring: %010d of %010d  (%5.2f%%)  ETR = %02dh %02dm %02ds\r",
             completed, total, ((double )completed * 100.0) / (double )total, hour,
             min, sec);
#line 295
      fflush(stdout);
    }
#line 297
    return;
  }
#line 300
  i = mini;
#line 300
  while (i < maxi) {
#line 301
    j = minj;
#line 301
    while (j < maxj) {
#line 302
      *(*(distance->cols + j) + i) = (*distMeasure)(*(graphs + i), *(graphs + j));
#line 303
      completed ++;
#line 301
      j ++;
    }
#line 300
    i ++;
  }
#line 307
  return;
}
}
#line 310 "src/csuEBGMMeasure.c"
int main(int argc , char **argv ) 
{ 
  ImageList *imagenames ;
  ImageList *subject ;
  ImageList *replicate ;
  int imageCount ;
  Matrix distance ;
  FaceGraph *graphs ;
  char **names ;
  int i ;
  int j ;
  Arguments args ;
  DistDirNode *distrec ;
  time_t tttt ;
  time_t tmp ;
  char *tmp___0 ;
  time_t tttt___0 ;
  time_t tmp___1 ;
  char *tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  time_t tttt___1 ;
  time_t tmp___5 ;
  char *tmp___6 ;
  char *tmp___12 ;
  char *tmp___13 ;
  time_t tttt___2 ;
  time_t tmp___14 ;
  char *tmp___15 ;
  FILE *distfile ;
  char *tmp___16 ;
  FILE *tmp___17 ;
  char *tmp___18 ;

  {
#line 320
  processCommand(argc, argv, & args);
#line 322
  tmp = time((time_t *)0);
#line 322
  tttt = tmp;
#line 322
  if (quiet == 0) {
#line 322
    printf((char const   * __restrict  )"Reading in image names");
  } else
#line 322
  if (debuglevel != 0) {
#line 322
    printf((char const   * __restrict  )"Reading in image names");
  }
#line 322
  if (quiet == 0) {
#line 322
    printf((char const   * __restrict  )"\n");
  } else
#line 322
  if (debuglevel != 0) {
#line 322
    printf((char const   * __restrict  )"\n");
  }
#line 322
  if (debuglevel > 0) {
#line 322
    tmp___0 = ctime((time_t const   *)(& tttt));
#line 322
    printf((char const   * __restrict  )"    [%s]<%s():line %u> %s\n", "src/csuEBGMMeasure.c",
           "main", 322, tmp___0);
  }
#line 322
  fflush(stdout);
#line 323
  imagenames = getImageNames(args.imageNamesFile, & imageCount);
#line 325
  tmp___1 = time((time_t *)0);
#line 325
  tttt___0 = tmp___1;
#line 325
  if (quiet == 0) {
#line 325
    printf((char const   * __restrict  )"Reading in graph files %d", imageCount);
  } else
#line 325
  if (debuglevel != 0) {
#line 325
    printf((char const   * __restrict  )"Reading in graph files %d", imageCount);
  }
#line 325
  if (quiet == 0) {
#line 325
    printf((char const   * __restrict  )"\n");
  } else
#line 325
  if (debuglevel != 0) {
#line 325
    printf((char const   * __restrict  )"\n");
  }
#line 325
  if (debuglevel > 0) {
#line 325
    tmp___2 = ctime((time_t const   *)(& tttt___0));
#line 325
    printf((char const   * __restrict  )"    [%s]<%s():line %u> %s\n", "src/csuEBGMMeasure.c",
           "main", 325, tmp___2);
  }
#line 325
  fflush(stdout);
#line 328
  tmp___3 = csu_allocate("char*", (int )sizeof(char *), imageCount, "src/csuEBGMMeasure.c",
                         328);
#line 328
  names = (char **)tmp___3;
#line 329
  tmp___4 = csu_allocate("FaceGraph", (int )sizeof(FaceGraph ), imageCount, "src/csuEBGMMeasure.c",
                         329);
#line 329
  graphs = (FaceGraph *)tmp___4;
#line 330
  distance = makeZeroMatrix(imageCount, imageCount);
#line 333
  tmp___5 = time((time_t *)0);
#line 333
  tttt___1 = tmp___5;
#line 333
  if (quiet == 0) {
#line 333
    printf((char const   * __restrict  )"Reading in graph files");
  } else
#line 333
  if (debuglevel != 0) {
#line 333
    printf((char const   * __restrict  )"Reading in graph files");
  }
#line 333
  if (quiet == 0) {
#line 333
    printf((char const   * __restrict  )"\n");
  } else
#line 333
  if (debuglevel != 0) {
#line 333
    printf((char const   * __restrict  )"\n");
  }
#line 333
  if (debuglevel > 0) {
#line 333
    tmp___6 = ctime((time_t const   *)(& tttt___1));
#line 333
    printf((char const   * __restrict  )"    [%s]<%s():line %u> %s\n", "src/csuEBGMMeasure.c",
           "main", 333, tmp___6);
  }
#line 333
  fflush(stdout);
#line 334
  i = 0;
#line 335
  subject = imagenames;
#line 335
  while ((unsigned long )subject != (unsigned long )((void *)0)) {
#line 336
    replicate = subject;
#line 336
    while ((unsigned long )replicate != (unsigned long )((void *)0)) {
#line 337
      printf((char const   * __restrict  )"Reading in graph: %s\n", replicate->filename);
#line 337
      fflush(stdout);
#line 338
      tmp___12 = __strdup((char const   *)replicate->filename);
#line 338
      *(names + i) = tmp___12;
#line 339
      tmp___13 = makePath((char const   *)args.faceGraphDir, (char const   *)replicate->filename);
#line 339
      *(graphs + i) = loadFaceGraph(tmp___13);
#line 340
      i ++;
#line 336
      replicate = replicate->next_replicate;
    }
#line 335
    subject = subject->next_subject;
  }
#line 344
  distrec = args.distList;
#line 344
  while ((unsigned long )distrec != (unsigned long )((void *)0)) {
#line 346
    completed = 0;
#line 347
    total = imageCount * imageCount;
#line 349
    tmp___14 = time((time_t *)0);
#line 349
    tttt___2 = tmp___14;
#line 349
    if (quiet == 0) {
#line 349
      printf((char const   * __restrict  )"Computing Distance Matrix");
    } else
#line 349
    if (debuglevel != 0) {
#line 349
      printf((char const   * __restrict  )"Computing Distance Matrix");
    }
#line 349
    if (quiet == 0) {
#line 349
      printf((char const   * __restrict  )"\n");
    } else
#line 349
    if (debuglevel != 0) {
#line 349
      printf((char const   * __restrict  )"\n");
    }
#line 349
    if (debuglevel > 0) {
#line 349
      tmp___15 = ctime((time_t const   *)(& tttt___2));
#line 349
      printf((char const   * __restrict  )"    [%s]<%s():line %u> %s\n", "src/csuEBGMMeasure.c",
             "main", 349, tmp___15);
    }
#line 349
    fflush(stdout);
#line 350
    start_time = time((time_t *)((void *)0));
#line 352
    computeDistanceMatrix(distance, graphs, 0, imageCount, 0, imageCount, distrec->distMeasure);
#line 355
    i = 0;
#line 355
    while (i < imageCount) {
#line 356
      tmp___16 = makePath((char const   *)distrec->distDirectory, (char const   *)*(names + i));
#line 356
      tmp___17 = fopen((char const   * __restrict  )tmp___16, (char const   * __restrict  )"w");
#line 356
      distfile = tmp___17;
#line 358
      if (! distfile) {
#line 359
        tmp___18 = makePath((char const   *)distrec->distDirectory, (char const   *)*(names + i));
#line 359
        printf((char const   * __restrict  )"Error opening distance file: %s\n", tmp___18);
#line 360
        exit(1);
      }
#line 363
      printf((char const   * __restrict  )"Saving distances for image: %s\n", *(names + i));
#line 363
      fflush(stdout);
#line 365
      j = 0;
#line 365
      while (j < imageCount) {
#line 366
        fprintf((FILE * __restrict  )distfile, (char const   * __restrict  )"%s\t%16e\n",
                *(names + j), *(*(distance->cols + j) + i));
#line 365
        j ++;
      }
#line 368
      fclose(distfile);
#line 355
      i ++;
    }
#line 344
    distrec = distrec->next;
  }
#line 372
  return (0);
}
}
#line 1 "csuCommonMatrix.o"
#pragma merger("0","/tmp/cil-9N3BTd0I.i","-O3,-Wall")
#line 170 "/usr/include/stdio.h"
extern struct _IO_FILE *stderr ;
#line 321 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) long ( __attribute__((__leaf__)) random)(void) ;
#line 482
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 182 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h"
extern  __attribute__((__nothrow__)) double ( __attribute__((__leaf__)) fabs)(double __x )  __attribute__((__const__)) ;
#line 150 "/usr/include/x86_64-linux-gnu/bits/mathinline.h"
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__, __always_inline__)) __signbitl)(long double __x )  __attribute__((__const__)) ;
#line 150 "/usr/include/x86_64-linux-gnu/bits/mathinline.h"
__inline extern int ( __attribute__((__leaf__, __always_inline__)) __signbitl)(long double __x ) 
{ 
  union __anonunion___u_26___0 __u ;

  {
#line 153
  __u.__l = __x;
#line 154
  return ((__u.__i[2] & 32768) != 0);
}
}
#line 70 "/usr/include/assert.h"
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) __assert_fail)(char const   *__assertion ,
                                                                                                   char const   *__file ,
                                                                                                   unsigned int __line ,
                                                                                                   char const   *__function ) ;
#line 96 "src/csuCommonMatrix.h"
Matrix makeIdentityMatrix(int dim ) ;
#line 121
Matrix rangeCheck(Matrix mat , int i , int j , char const   *file_name , char const   *func_name ,
                  int line_num , char const   *mat_name ) ;
#line 124
Matrix multiplyMatrix(Matrix const   A , Matrix const   B ) ;
#line 126
Matrix transposeMultiplyMatrixL(Matrix const   A , Matrix const   B ) ;
#line 128
Matrix transposeMultiplyMatrixR(Matrix const   A , Matrix const   B ) ;
#line 131
Matrix subtractMatrix(Matrix const   A , Matrix const   B ) ;
#line 133
Matrix addMatrix(Matrix const   A , Matrix const   B ) ;
#line 135
void addMatrixEquals(Matrix A , Matrix const   B ) ;
#line 138
Matrix transposeMatrix(Matrix const   A ) ;
#line 141
Matrix invertRREF(Matrix m ) ;
#line 144
Matrix leastSquares(Matrix A , Matrix b ) ;
#line 145
Matrix weightedLeastSquares(Matrix A , Matrix b , Matrix W ) ;
#line 148
Matrix matrixCols(Matrix const   mat , int col1 , int col2 ) ;
#line 151
Matrix duplicateMatrix(Matrix const   mat ) ;
#line 161
MatrixSaveMode asciiFormat ;
#line 164
void saveMatrixAscii(char const   *fname , char const   *label , Matrix const   m ,
                     MatrixSaveMode mode ) ;
#line 167
Matrix makeRandomMatrix(int row_dim , int col_dim ) ;
#line 170
double matrixSumOfSquares(Matrix m ) ;
#line 172
void printMatrix(char const   *label , Matrix m ) ;
#line 79 "src/csuCommonMatrix.c"
int alloc_matrix  =    0;
#line 81 "src/csuCommonMatrix.c"
Matrix makeMatrix(int row_dim , int col_dim ) 
{ 
  int i ;
  Matrix A ;
  void *tmp ;
  time_t tttt ;
  time_t tmp___0 ;
  char *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;

  {
#line 89
  tmp = malloc(sizeof(matrix ));
#line 89
  A = (Matrix )tmp;
#line 90
  if (! A) {
#line 90
    __assert_fail("A", "src/csuCommonMatrix.c", 90U, "makeMatrix");
  }
#line 93
  alloc_matrix ++;
#line 95
  if (10 <= debuglevel) {
#line 95
    tmp___0 = time((time_t *)0);
#line 95
    tttt = tmp___0;
#line 95
    tmp___1 = ctime((time_t const   *)(& tttt));
#line 95
    printf((char const   * __restrict  )"**DEBUG %d** \"%s\"\n             at [%s]<%s():line %u>\n             %s\n",
           10, "Allocating Matrix", "src/csuCommonMatrix.c", "makeMatrix", 95, tmp___1);
#line 95
    fflush(stdout);
  }
#line 98
  A->row_dim = row_dim;
#line 99
  A->col_dim = col_dim;
#line 105
  tmp___2 = malloc((sizeof(double ) * (unsigned long )row_dim) * (unsigned long )col_dim);
#line 105
  A->data = (double *)tmp___2;
#line 109
  if (! A->data) {
#line 110
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Matrix Size: %d X %d\n",
            A->row_dim, A->col_dim);
#line 111
    fflush(stderr);
  }
#line 113
  if (! A->data) {
#line 113
    __assert_fail("A->data", "src/csuCommonMatrix.c", 113U, "makeMatrix");
  }
#line 114
  tmp___3 = malloc(sizeof(double *) * (unsigned long )col_dim);
#line 114
  A->cols = (double **)tmp___3;
#line 115
  if (! A->cols) {
#line 115
    __assert_fail("A->cols", "src/csuCommonMatrix.c", 115U, "makeMatrix");
  }
#line 117
  i = 0;
#line 117
  while (i < col_dim) {
#line 121
    *(A->cols + i) = A->data + i * row_dim;
#line 117
    i ++;
  }
#line 125
  return (A);
}
}
#line 128 "src/csuCommonMatrix.c"
Matrix makeZeroMatrix(int row_dim , int col_dim ) 
{ 
  int i ;
  int j ;
  Matrix A ;
  Matrix tmp ;

  {
#line 131
  tmp = makeMatrix(row_dim, col_dim);
#line 131
  A = tmp;
#line 134
  i = 0;
#line 134
  while (i < row_dim) {
#line 135
    j = 0;
#line 135
    while (j < col_dim) {
#line 136
      *(*(A->cols + j) + i) = (double )0;
#line 135
      j ++;
    }
#line 134
    i ++;
  }
#line 139
  return (A);
}
}
#line 144 "src/csuCommonMatrix.c"
void freeMatrix(Matrix A ) 
{ 
  time_t tttt ;
  time_t tmp ;
  char *tmp___0 ;

  {
#line 150
  alloc_matrix --;
#line 151
  if (10 <= debuglevel) {
#line 151
    tmp = time((time_t *)0);
#line 151
    tttt = tmp;
#line 151
    tmp___0 = ctime((time_t const   *)(& tttt));
#line 151
    printf((char const   * __restrict  )"**DEBUG %d** \"%s\"\n             at [%s]<%s():line %u>\n             %s\n",
           10, "Freeing Matrix", "src/csuCommonMatrix.c", "freeMatrix", 151, tmp___0);
#line 151
    fflush(stdout);
  }
#line 155
  free((void *)A->data);
#line 157
  free((void *)A->cols);
#line 158
  free((void *)A);
#line 159
  return;
}
}
#line 161 "src/csuCommonMatrix.c"
Matrix makeIdentityMatrix(int dim ) 
{ 
  Matrix I ;
  int i ;
  int j ;
  time_t tttt ;
  time_t tmp ;
  char *tmp___0 ;

  {
#line 166
  if (10 <= debuglevel) {
#line 166
    tmp = time((time_t *)0);
#line 166
    tttt = tmp;
#line 166
    tmp___0 = ctime((time_t const   *)(& tttt));
#line 166
    printf((char const   * __restrict  )"**DEBUG %d** \"%s\"\n             at [%s]<%s():line %u>\n             %s\n",
           10, "Creating identity matrix", "src/csuCommonMatrix.c", "makeIdentityMatrix",
           166, tmp___0);
#line 166
    fflush(stdout);
  }
#line 168
  I = makeMatrix(dim, dim);
#line 169
  i = 0;
#line 169
  while (i < dim) {
#line 170
    j = 0;
#line 170
    while (j < dim) {
#line 171
      *(*(I->cols + j) + i) = (double )(i == j);
#line 170
      j ++;
    }
#line 169
    i ++;
  }
#line 175
  return (I);
}
}
#line 178 "src/csuCommonMatrix.c"
Matrix duplicateMatrix(Matrix const   mat ) 
{ 
  Matrix dup ;
  Matrix tmp ;
  int i ;
  int j ;

  {
#line 179
  tmp = makeMatrix(mat->row_dim, mat->col_dim);
#line 179
  dup = tmp;
#line 181
  i = 0;
#line 181
  while (i < mat->row_dim) {
#line 182
    j = 0;
#line 182
    while (j < mat->col_dim) {
#line 183
      *(*(dup->cols + j) + i) = *(*(mat->cols + j) + i);
#line 182
      j ++;
    }
#line 181
    i ++;
  }
#line 187
  return (dup);
}
}
#line 190 "src/csuCommonMatrix.c"
Matrix multiplyMatrix(Matrix const   A , Matrix const   B ) 
{ 
  int i ;
  int j ;
  int k ;
  Matrix P ;
  Matrix tmp ;
  time_t tttt ;
  time_t tmp___0 ;
  char *tmp___1 ;

  {
#line 194
  tmp = makeMatrix(A->row_dim, B->col_dim);
#line 194
  P = tmp;
#line 196
  if (10 <= debuglevel) {
#line 196
    tmp___0 = time((time_t *)0);
#line 196
    tttt = tmp___0;
#line 196
    tmp___1 = ctime((time_t const   *)(& tttt));
#line 196
    printf((char const   * __restrict  )"**DEBUG %d** \"%s\"\n             at [%s]<%s():line %u>\n             %s\n",
           10, "Multiplying Matrix", "src/csuCommonMatrix.c", "multiplyMatrix", 196,
           tmp___1);
#line 196
    fflush(stdout);
  }
#line 198
  if (! (A->col_dim == B->row_dim)) {
#line 198
    __assert_fail("A->col_dim == B->row_dim", "src/csuCommonMatrix.c", 198U, "multiplyMatrix");
  }
#line 201
  j = 0;
#line 201
  while (j < B->col_dim) {
#line 202
    i = 0;
#line 202
    while (i < A->row_dim) {
#line 203
      *(*(P->cols + j) + i) = (double )0;
#line 204
      k = 0;
#line 204
      while (k < A->col_dim) {
#line 205
        *(*(P->cols + j) + i) += *(*(A->cols + k) + i) * *(*(B->cols + j) + k);
#line 204
        k ++;
      }
#line 202
      i ++;
    }
#line 201
    j ++;
  }
#line 210
  return (P);
}
}
#line 214 "src/csuCommonMatrix.c"
Matrix transposeMultiplyMatrixL(Matrix const   A , Matrix const   B ) 
{ 
  int i ;
  int j ;
  int k ;
  Matrix P ;
  Matrix tmp ;
  time_t tttt ;
  time_t tmp___0 ;
  char *tmp___1 ;

  {
#line 218
  tmp = makeMatrix(A->col_dim, B->col_dim);
#line 218
  P = tmp;
#line 220
  if (10 <= debuglevel) {
#line 220
    tmp___0 = time((time_t *)0);
#line 220
    tttt = tmp___0;
#line 220
    tmp___1 = ctime((time_t const   *)(& tttt));
#line 220
    printf((char const   * __restrict  )"**DEBUG %d** \"%s\"\n             at [%s]<%s():line %u>\n             %s\n",
           10, "Multiplying Matrix", "src/csuCommonMatrix.c", "transposeMultiplyMatrixL",
           220, tmp___1);
#line 220
    fflush(stdout);
  }
#line 222
  if (! (A->row_dim == B->row_dim)) {
#line 222
    __assert_fail("A->row_dim == B->row_dim", "src/csuCommonMatrix.c", 222U, "transposeMultiplyMatrixL");
  }
#line 227
  j = 0;
#line 227
  while (j < B->col_dim) {
#line 228
    i = 0;
#line 228
    while (i < A->col_dim) {
#line 229
      *(*(P->cols + j) + i) = (double )0;
#line 228
      i ++;
    }
#line 227
    j ++;
  }
#line 232
  j = 0;
#line 232
  while (j < B->col_dim) {
#line 233
    i = 0;
#line 233
    while (i < A->col_dim) {
#line 234
      k = 0;
#line 234
      while (k < A->row_dim) {
#line 235
        *(*(P->cols + j) + i) += *(*(A->cols + i) + k) * *(*(B->cols + j) + k);
#line 234
        k ++;
      }
#line 233
      i ++;
    }
#line 232
    j ++;
  }
#line 240
  return (P);
}
}
#line 243 "src/csuCommonMatrix.c"
Matrix transposeMultiplyMatrixR(Matrix const   A , Matrix const   B ) 
{ 
  int i ;
  int j ;
  int k ;
  Matrix P ;
  Matrix tmp ;
  time_t tttt ;
  time_t tmp___0 ;
  char *tmp___1 ;

  {
#line 247
  tmp = makeMatrix(A->row_dim, B->row_dim);
#line 247
  P = tmp;
#line 249
  if (10 <= debuglevel) {
#line 249
    tmp___0 = time((time_t *)0);
#line 249
    tttt = tmp___0;
#line 249
    tmp___1 = ctime((time_t const   *)(& tttt));
#line 249
    printf((char const   * __restrict  )"**DEBUG %d** \"%s\"\n             at [%s]<%s():line %u>\n             %s\n",
           10, "Multiplying Matrix", "src/csuCommonMatrix.c", "transposeMultiplyMatrixR",
           249, tmp___1);
#line 249
    fflush(stdout);
  }
#line 251
  if (! (A->row_dim == B->row_dim)) {
#line 251
    __assert_fail("A->row_dim == B->row_dim", "src/csuCommonMatrix.c", 251U, "transposeMultiplyMatrixR");
  }
#line 254
  i = 0;
#line 254
  while (i < A->row_dim) {
#line 255
    j = 0;
#line 255
    while (j < B->row_dim) {
#line 256
      *(*(P->cols + j) + i) = (double )0;
#line 255
      j ++;
    }
#line 254
    i ++;
  }
#line 260
  k = 0;
#line 260
  while (k < A->col_dim) {
#line 261
    i = 0;
#line 261
    while (i < A->row_dim) {
#line 262
      j = 0;
#line 262
      while (j < B->row_dim) {
#line 263
        *(*(P->cols + j) + i) += *(*(A->cols + k) + i) * *(*(B->cols + k) + j);
#line 262
        j ++;
      }
#line 261
      i ++;
    }
#line 260
    k ++;
  }
#line 268
  return (P);
}
}
#line 272 "src/csuCommonMatrix.c"
Matrix transposeMatrix(Matrix const   A ) 
{ 
  int i ;
  int j ;
  Matrix T ;
  Matrix tmp ;
  time_t tttt ;
  time_t tmp___0 ;
  char *tmp___1 ;

  {
#line 275
  tmp = makeMatrix(A->col_dim, A->row_dim);
#line 275
  T = tmp;
#line 277
  if (10 <= debuglevel) {
#line 277
    tmp___0 = time((time_t *)0);
#line 277
    tttt = tmp___0;
#line 277
    tmp___1 = ctime((time_t const   *)(& tttt));
#line 277
    printf((char const   * __restrict  )"**DEBUG %d** \"%s\"\n             at [%s]<%s():line %u>\n             %s\n",
           10, "Transposing Matrix", "src/csuCommonMatrix.c", "transposeMatrix", 277,
           tmp___1);
#line 277
    fflush(stdout);
  }
#line 280
  i = 0;
#line 280
  while (i < A->row_dim) {
#line 281
    j = 0;
#line 281
    while (j < A->col_dim) {
#line 282
      *(*(T->cols + i) + j) = *(*(A->cols + j) + i);
#line 281
      j ++;
    }
#line 280
    i ++;
  }
#line 286
  return (T);
}
}
#line 289 "src/csuCommonMatrix.c"
void rowSwap(Matrix m , int rSrc , int rDest ) 
{ 
  int col ;
  double tmp ;

  {
#line 290
  col = 0;
#line 293
  col = 0;
#line 293
  while (col < m->col_dim) {
#line 294
    tmp = *(*(m->cols + col) + rSrc);
#line 295
    *(*(m->cols + col) + rSrc) = *(*(m->cols + col) + rDest);
#line 296
    *(*(m->cols + col) + rDest) = tmp;
#line 293
    col ++;
  }
#line 298
  return;
}
}
#line 300 "src/csuCommonMatrix.c"
void rowMult(Matrix m , int rSrc , double value ) 
{ 
  int col ;

  {
#line 301
  col = 0;
#line 303
  col = 0;
#line 303
  while (col < m->col_dim) {
#line 304
    *(*(m->cols + col) + rSrc) *= value;
#line 303
    col ++;
  }
#line 306
  return;
}
}
#line 308 "src/csuCommonMatrix.c"
void rowMultAdd(Matrix m , int rSrc , int rDest , double value ) 
{ 
  int col ;

  {
#line 309
  col = 0;
#line 311
  col = 0;
#line 311
  while (col < m->col_dim) {
#line 312
    *(*(m->cols + col) + rDest) += value * *(*(m->cols + col) + rSrc);
#line 311
    col ++;
  }
#line 314
  return;
}
}
#line 316 "src/csuCommonMatrix.c"
void matrixRREF(Matrix m ) 
{ 
  int prealloc ;
  int pivotCol ;
  int pivotRow ;
  int row ;
  double absVal ;
  int tmp ;
  double tmp___0 ;

  {
#line 317
  prealloc = alloc_matrix;
#line 318
  pivotCol = 0;
#line 319
  pivotRow = 0;
#line 322
  tmp = 0;
#line 324
  while (1) {
#line 327
    absVal = 0.0;
#line 328
    while (1) {
#line 328
      if (absVal == 0.0) {
#line 328
        if (! (pivotCol < m->col_dim)) {
#line 328
          break;
        }
      } else {
#line 328
        break;
      }
#line 329
      if (*(*(m->cols + pivotCol) + pivotRow) < (double )0) {
#line 329
        absVal = - *(*(m->cols + pivotCol) + pivotRow);
      } else {
#line 329
        absVal = *(*(m->cols + pivotCol) + pivotRow);
      }
#line 330
      tmp = pivotRow;
#line 332
      row = pivotRow + 1;
#line 332
      while (row < m->row_dim) {
#line 333
        if (*(*(m->cols + pivotCol) + row) < (double )0) {
#line 333
          tmp___0 = - *(*(m->cols + pivotCol) + row);
        } else {
#line 333
          tmp___0 = *(*(m->cols + pivotCol) + row);
        }
#line 333
        if (tmp___0 > absVal) {
#line 334
          if (*(*(m->cols + pivotCol) + row) < (double )0) {
#line 334
            absVal = - *(*(m->cols + pivotCol) + row);
          } else {
#line 334
            absVal = *(*(m->cols + pivotCol) + row);
          }
#line 335
          tmp = row;
        }
#line 332
        row ++;
      }
#line 338
      if (absVal == (double )0) {
#line 339
        pivotCol ++;
      }
    }
#line 344
    if (pivotCol >= m->col_dim) {
#line 344
      return;
    } else
#line 344
    if (pivotRow >= m->row_dim) {
#line 344
      return;
    }
#line 347
    if (pivotRow != tmp) {
#line 347
      rowSwap(m, tmp, pivotRow);
    }
#line 350
    rowMult(m, pivotRow, 1.0 / *(*(m->cols + pivotCol) + pivotRow));
#line 354
    row = 0;
#line 354
    while (row < m->row_dim) {
#line 355
      if (row != pivotRow) {
#line 356
        rowMultAdd(m, pivotRow, row, - *(*(m->cols + pivotCol) + row));
      }
#line 354
      row ++;
    }
#line 359
    pivotRow ++;
#line 360
    pivotCol ++;
  }
#line 363
  if (prealloc != alloc_matrix) {
#line 364
    printf((char const   * __restrict  )"Error deallocating matricies <%s>: pre=%d post=%d",
           "matrixRREF", prealloc, alloc_matrix);
#line 365
    exit(1);
  }
}
}
#line 370 "src/csuCommonMatrix.c"
Matrix invertRREF(Matrix m ) 
{ 
  int prealloc ;
  int i ;
  int j ;
  Matrix tmp ;
  Matrix tmp___0 ;
  Matrix inverse ;
  Matrix tmp___1 ;
  time_t tttt ;
  time_t tmp___2 ;
  char *tmp___3 ;

  {
#line 371
  prealloc = alloc_matrix;
#line 373
  tmp___0 = makeZeroMatrix(m->row_dim, m->col_dim * 2);
#line 373
  tmp = tmp___0;
#line 374
  tmp___1 = makeMatrix(m->row_dim, m->col_dim);
#line 374
  inverse = tmp___1;
#line 375
  if (! (m->row_dim == m->col_dim)) {
#line 375
    tmp___2 = time((time_t *)0);
#line 375
    tttt = tmp___2;
#line 375
    tmp___3 = ctime((time_t const   *)(& tttt));
#line 375
    printf((char const   * __restrict  )"**DEBUG CHECK** Failed check (%s) \"%s\"\n             at [%s]<%s():line %u>\n             %s\n",
           "m->row_dim == m->col_dim", "Matrix can only be inverted if it is square",
           "src/csuCommonMatrix.c", "invertRREF", 375, tmp___3);
#line 375
    fflush(stdout);
#line 375
    exit(1);
  }
#line 377
  i = 0;
#line 377
  while (i < m->row_dim) {
#line 378
    j = 0;
#line 378
    while (j < m->col_dim) {
#line 379
      *(*(tmp->cols + j) + i) = *(*(m->cols + j) + i);
#line 380
      if (i == j) {
#line 381
        *(*(tmp->cols + (j + m->col_dim)) + i) = (double )1;
      }
#line 378
      j ++;
    }
#line 377
    i ++;
  }
#line 385
  matrixRREF(tmp);
#line 387
  i = 0;
#line 387
  while (i < m->row_dim) {
#line 388
    j = 0;
#line 388
    while (j < m->col_dim) {
#line 389
      *(*(inverse->cols + j) + i) = *(*(tmp->cols + (j + m->col_dim)) + i);
#line 388
      j ++;
    }
#line 387
    i ++;
  }
#line 393
  freeMatrix(tmp);
#line 395
  if (prealloc != alloc_matrix - 1) {
#line 396
    printf((char const   * __restrict  )"Error deallocating matricies <%s>: pre=%d post=%d",
           "invertRREF", prealloc, alloc_matrix);
#line 397
    exit(1);
  }
#line 399
  return (inverse);
}
}
#line 402 "src/csuCommonMatrix.c"
Matrix leastSquares(Matrix A , Matrix b ) 
{ 
  int prealloc ;
  Matrix At ;
  Matrix tmp ;
  Matrix AtA ;
  Matrix tmp___0 ;
  Matrix AtAi ;
  Matrix tmp___1 ;
  Matrix Atb ;
  Matrix tmp___2 ;
  Matrix a ;
  Matrix tmp___3 ;

  {
#line 403
  prealloc = alloc_matrix;
#line 404
  tmp = transposeMatrix((Matrix const   )A);
#line 404
  At = tmp;
#line 405
  tmp___0 = transposeMultiplyMatrixL((Matrix const   )A, (Matrix const   )A);
#line 405
  AtA = tmp___0;
#line 406
  tmp___1 = invertRREF(AtA);
#line 406
  AtAi = tmp___1;
#line 407
  tmp___2 = multiplyMatrix((Matrix const   )At, (Matrix const   )b);
#line 407
  Atb = tmp___2;
#line 408
  tmp___3 = multiplyMatrix((Matrix const   )AtAi, (Matrix const   )Atb);
#line 408
  a = tmp___3;
#line 410
  freeMatrix(At);
#line 411
  freeMatrix(AtA);
#line 412
  freeMatrix(AtAi);
#line 413
  freeMatrix(Atb);
#line 415
  if (prealloc != alloc_matrix - 1) {
#line 416
    printf((char const   * __restrict  )"Error deallocating matricies <%s>: pre=%d post=%d",
           "leastSquares", prealloc, alloc_matrix);
#line 417
    exit(1);
  }
#line 419
  return (a);
}
}
#line 422 "src/csuCommonMatrix.c"
Matrix weightedLeastSquares(Matrix A , Matrix b , Matrix W ) 
{ 
  int prealloc ;
  Matrix WA ;
  Matrix tmp ;
  Matrix WAt ;
  Matrix tmp___0 ;
  Matrix WAtW ;
  Matrix tmp___1 ;
  Matrix WAtWA ;
  Matrix tmp___2 ;
  Matrix WAtWAi ;
  Matrix tmp___3 ;
  Matrix WAtWAiWAt ;
  Matrix tmp___4 ;
  Matrix WAtWAiWAtW ;
  Matrix tmp___5 ;
  Matrix a ;
  Matrix tmp___6 ;

  {
#line 423
  prealloc = alloc_matrix;
#line 425
  tmp = multiplyMatrix((Matrix const   )W, (Matrix const   )A);
#line 425
  WA = tmp;
#line 426
  tmp___0 = transposeMatrix((Matrix const   )WA);
#line 426
  WAt = tmp___0;
#line 427
  tmp___1 = multiplyMatrix((Matrix const   )WAt, (Matrix const   )W);
#line 427
  WAtW = tmp___1;
#line 428
  tmp___2 = multiplyMatrix((Matrix const   )WAtW, (Matrix const   )A);
#line 428
  WAtWA = tmp___2;
#line 429
  tmp___3 = invertRREF(WAtWA);
#line 429
  WAtWAi = tmp___3;
#line 430
  tmp___4 = multiplyMatrix((Matrix const   )WAtWAi, (Matrix const   )WAt);
#line 430
  WAtWAiWAt = tmp___4;
#line 431
  tmp___5 = multiplyMatrix((Matrix const   )WAtWAiWAt, (Matrix const   )W);
#line 431
  WAtWAiWAtW = tmp___5;
#line 432
  tmp___6 = multiplyMatrix((Matrix const   )WAtWAiWAtW, (Matrix const   )b);
#line 432
  a = tmp___6;
#line 434
  freeMatrix(WA);
#line 435
  freeMatrix(WAt);
#line 436
  freeMatrix(WAtW);
#line 437
  freeMatrix(WAtWA);
#line 438
  freeMatrix(WAtWAi);
#line 439
  freeMatrix(WAtWAiWAt);
#line 440
  freeMatrix(WAtWAiWAtW);
#line 442
  if (prealloc != alloc_matrix - 1) {
#line 443
    printf((char const   * __restrict  )"Error deallocating matricies <%s>: pre=%d post=%d",
           "weightedLeastSquares", prealloc, alloc_matrix);
#line 444
    exit(1);
  }
#line 446
  return (a);
}
}
#line 449 "src/csuCommonMatrix.c"
Matrix subtractMatrix(Matrix const   A , Matrix const   B ) 
{ 
  Matrix diff ;
  Matrix tmp ;
  int i ;
  int j ;
  time_t tttt ;
  time_t tmp___0 ;
  char *tmp___1 ;

  {
#line 451
  tmp = makeMatrix(A->row_dim, A->col_dim);
#line 451
  diff = tmp;
#line 453
  if (10 <= debuglevel) {
#line 453
    tmp___0 = time((time_t *)0);
#line 453
    tttt = tmp___0;
#line 453
    tmp___1 = ctime((time_t const   *)(& tttt));
#line 453
    printf((char const   * __restrict  )"**DEBUG %d** \"%s\"\n             at [%s]<%s():line %u>\n             %s\n",
           10, "Subtracting Matrix", "src/csuCommonMatrix.c", "subtractMatrix", 453,
           tmp___1);
#line 453
    fflush(stdout);
  }
#line 455
  if (! (A->row_dim == B->row_dim)) {
#line 455
    __assert_fail("A->row_dim == B->row_dim", "src/csuCommonMatrix.c", 455U, "subtractMatrix");
  }
#line 456
  if (! (A->col_dim == B->col_dim)) {
#line 456
    __assert_fail("A->col_dim == B->col_dim", "src/csuCommonMatrix.c", 456U, "subtractMatrix");
  }
#line 458
  i = 0;
#line 458
  while (i < A->row_dim) {
#line 459
    j = 0;
#line 459
    while (j < A->col_dim) {
#line 460
      *(*(diff->cols + j) + i) = *(*(A->cols + j) + i) - *(*(B->cols + j) + i);
#line 459
      j ++;
    }
#line 458
    i ++;
  }
#line 464
  return (diff);
}
}
#line 468 "src/csuCommonMatrix.c"
Matrix addMatrix(Matrix const   A , Matrix const   B ) 
{ 
  Matrix sum ;
  Matrix tmp ;
  int i ;
  int j ;
  time_t tttt ;
  time_t tmp___0 ;
  char *tmp___1 ;

  {
#line 470
  tmp = makeMatrix(A->row_dim, A->col_dim);
#line 470
  sum = tmp;
#line 472
  if (10 <= debuglevel) {
#line 472
    tmp___0 = time((time_t *)0);
#line 472
    tttt = tmp___0;
#line 472
    tmp___1 = ctime((time_t const   *)(& tttt));
#line 472
    printf((char const   * __restrict  )"**DEBUG %d** \"%s\"\n             at [%s]<%s():line %u>\n             %s\n",
           10, "Adding Matrix", "src/csuCommonMatrix.c", "addMatrix", 472, tmp___1);
#line 472
    fflush(stdout);
  }
#line 474
  if (! (A->row_dim == B->row_dim)) {
#line 474
    __assert_fail("A->row_dim == B->row_dim", "src/csuCommonMatrix.c", 474U, "addMatrix");
  }
#line 475
  if (! (A->col_dim == B->col_dim)) {
#line 475
    __assert_fail("A->col_dim == B->col_dim", "src/csuCommonMatrix.c", 475U, "addMatrix");
  }
#line 477
  i = 0;
#line 477
  while (i < A->row_dim) {
#line 478
    j = 0;
#line 478
    while (j < A->col_dim) {
#line 479
      *(*(sum->cols + j) + i) = *(*(A->cols + j) + i) + *(*(B->cols + j) + i);
#line 478
      j ++;
    }
#line 477
    i ++;
  }
#line 483
  return (sum);
}
}
#line 486 "src/csuCommonMatrix.c"
void addMatrixEquals(Matrix A , Matrix const   B ) 
{ 
  int i ;
  int j ;
  time_t tttt ;
  time_t tmp ;
  char *tmp___0 ;

  {
#line 489
  if (10 <= debuglevel) {
#line 489
    tmp = time((time_t *)0);
#line 489
    tttt = tmp;
#line 489
    tmp___0 = ctime((time_t const   *)(& tttt));
#line 489
    printf((char const   * __restrict  )"**DEBUG %d** \"%s\"\n             at [%s]<%s():line %u>\n             %s\n",
           10, "Adding Matrix", "src/csuCommonMatrix.c", "addMatrixEquals", 489, tmp___0);
#line 489
    fflush(stdout);
  }
#line 491
  if (! (A->row_dim == B->row_dim)) {
#line 491
    __assert_fail("A->row_dim == B->row_dim", "src/csuCommonMatrix.c", 491U, "addMatrixEquals");
  }
#line 492
  if (! (A->col_dim == B->col_dim)) {
#line 492
    __assert_fail("A->col_dim == B->col_dim", "src/csuCommonMatrix.c", 492U, "addMatrixEquals");
  }
#line 494
  i = 0;
#line 494
  while (i < A->row_dim) {
#line 495
    j = 0;
#line 495
    while (j < A->col_dim) {
#line 496
      *(*(A->cols + j) + i) += *(*(B->cols + j) + i);
#line 495
      j ++;
    }
#line 494
    i ++;
  }
#line 499
  return;
}
}
#line 501 "src/csuCommonMatrix.c"
Matrix matrixCols(Matrix const   mat , int col1 , int col2 ) 
{ 
  Matrix cols ;
  Matrix tmp ;
  int i ;
  int j ;
  time_t tttt ;
  time_t tmp___0 ;
  char *tmp___1 ;

  {
#line 502
  tmp = makeMatrix(mat->row_dim, (col2 - col1) + 1);
#line 502
  cols = tmp;
#line 505
  if (col1 <= col2) {
#line 505
    if (! (col2 < mat->col_dim)) {
#line 505
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
#line 505
    tmp___0 = time((time_t *)0);
#line 505
    tttt = tmp___0;
#line 505
    tmp___1 = ctime((time_t const   *)(& tttt));
#line 505
    printf((char const   * __restrict  )"**DEBUG CHECK** Failed check (%s) \"%s\"\n             at [%s]<%s():line %u>\n             %s\n",
           "col1 <= col2 && col2 < mat->col_dim", "Poorly chosen columns for extract columns operation",
           "src/csuCommonMatrix.c", "matrixCols", 505, tmp___1);
#line 505
    fflush(stdout);
#line 505
    exit(1);
  }
#line 507
  i = col1;
#line 507
  while (i <= col2) {
#line 508
    j = 0;
#line 508
    while (j < mat->row_dim) {
#line 509
      *(*(cols->cols + (i - col1)) + j) = *(*(mat->cols + i) + j);
#line 508
      j ++;
    }
#line 507
    i ++;
  }
#line 513
  return (cols);
}
}
#line 517 "src/csuCommonMatrix.c"
Matrix rangeCheck(Matrix mat , int i , int j , char const   *file_name , char const   *func_name ,
                  int line_num , char const   *mat_name ) 
{ 


  {
#line 519
  if (i >= 0) {
#line 519
    if (i < mat->row_dim) {
#line 519
      if (j >= 0) {
#line 519
        if (j < mat->col_dim) {
#line 520
          return (mat);
        }
      }
    }
  }
#line 522
  printf((char const   * __restrict  )"*********************  ERROR  *********************\n");
#line 523
  printf((char const   * __restrict  )"Error: Matrix bounds out of range     \n");
#line 524
  printf((char const   * __restrict  )"  in function: %s  Matrix: %s     \n", func_name,
         mat_name);
#line 525
  printf((char const   * __restrict  )"        Index: (%d,%d)  Size: (%dX%d) \n",
         i, j, mat->row_dim, mat->col_dim);
#line 526
  printf((char const   * __restrict  )"                     file: %s         \n",
         file_name);
#line 527
  printf((char const   * __restrict  )"                     line: %d         \n",
         line_num);
#line 528
  printf((char const   * __restrict  )"***************************************************\n");
#line 530
  exit(1);
#line 531
  return (mat);
}
}
#line 539 "src/csuCommonMatrix.c"
void printMatrix(char const   *label , Matrix m ) 
{ 
  int i ;
  int j ;

  {
#line 542
  printf((char const   * __restrict  )"%s = dimentions: %dX%d\n", label, m->row_dim,
         m->col_dim);
#line 543
  i = 0;
#line 543
  while (i < m->row_dim) {
#line 544
    j = 0;
#line 544
    while (j < m->col_dim) {
#line 545
      printf((char const   * __restrict  )"%6.12f ", *(*(m->cols + j) + i));
#line 544
      j ++;
    }
#line 547
    printf((char const   * __restrict  )"\n");
#line 543
    i ++;
  }
#line 550
  return;
}
}
#line 553 "src/csuCommonMatrix.c"
MatrixSaveMode asciiFormat  =    (MatrixSaveMode )0;
#line 555 "src/csuCommonMatrix.c"
void saveMatrixAscii(char const   *fname , char const   *label , Matrix const   m ,
                     MatrixSaveMode mode ) 
{ 
  FILE *matfile ;
  int i ;
  int j ;
  char filename[1024] ;
  time_t tttt ;
  time_t tmp ;
  char *tmp___0 ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;
  char const   *tmp___3 ;
  char const   *tmp___4 ;

  {
#line 561
  if (((unsigned int )mode & 1U) == 1U) {
#line 561
    if ((unsigned int )mode & 2U) {
#line 561
      tmp = time((time_t *)0);
#line 561
      tttt = tmp;
#line 561
      tmp___0 = ctime((time_t const   *)(& tttt));
#line 561
      printf((char const   * __restrict  )"**DEBUG CHECK** Failed check (%s) \"%s\"\n             at [%s]<%s():line %u>\n             %s\n",
             "!(((mode & formatMask) == matlabFormat) && (mode & appendToFile))",
             "Writing multiple matrices to an ascii file not supported by Matlab",
             "src/csuCommonMatrix.c", "saveMatrixAscii", 562, tmp___0);
#line 561
      fflush(stdout);
#line 561
      exit(1);
    }
  }
#line 564
  if ((unsigned long )fname == (unsigned long )((void *)0)) {
#line 565
    if (((unsigned int )mode & 1U) == 0U) {
#line 566
      if ((int const   )*(label + 0) == 42) {
#line 566
        tmp___1 = label + 1;
      } else {
#line 566
        tmp___1 = label;
      }
#line 566
      sprintf((char * __restrict  )(filename), (char const   * __restrict  )"%s.mat",
              tmp___1);
    } else {
#line 568
      if ((int const   )*(label + 0) == 42) {
#line 568
        tmp___2 = label + 1;
      } else {
#line 568
        tmp___2 = label;
      }
#line 568
      sprintf((char * __restrict  )(filename), (char const   * __restrict  )"%s.txt",
              tmp___2);
    }
#line 570
    fname = (char const   *)(filename);
  }
#line 573
  if ((unsigned int )mode & 2U) {
#line 573
    tmp___3 = "a";
  } else {
#line 573
    tmp___3 = "w";
  }
#line 573
  matfile = fopen((char const   * __restrict  )fname, (char const   * __restrict  )tmp___3);
#line 575
  if (! matfile) {
#line 576
    printf((char const   * __restrict  )"Error could not open file: \"%s\" for writing.\n",
           fname);
#line 577
    exit(1);
  }
#line 583
  if (((unsigned int )mode & 1U) == 0U) {
#line 584
    if ((int const   )*(label + 0) == 42) {
#line 584
      tmp___4 = label + 1;
    } else {
#line 584
      tmp___4 = label;
    }
#line 584
    fprintf((FILE * __restrict  )matfile, (char const   * __restrict  )"# name: %s\n",
            tmp___4);
#line 585
    fprintf((FILE * __restrict  )matfile, (char const   * __restrict  )"# type: matrix\n");
#line 586
    fprintf((FILE * __restrict  )matfile, (char const   * __restrict  )"# rows: %d\n",
            m->row_dim);
#line 587
    fprintf((FILE * __restrict  )matfile, (char const   * __restrict  )"# columns: %d\n",
            m->col_dim);
  }
#line 591
  i = 0;
#line 591
  while (i < m->row_dim) {
#line 592
    j = 0;
#line 592
    while (j < m->col_dim) {
#line 593
      fprintf((FILE * __restrict  )matfile, (char const   * __restrict  )" %e", *(*(m->cols + j) + i));
#line 592
      j ++;
    }
#line 595
    fprintf((FILE * __restrict  )matfile, (char const   * __restrict  )"\n");
#line 591
    i ++;
  }
#line 598
  fclose(matfile);
#line 600
  return;
}
}
#line 604 "src/csuCommonMatrix.c"
Matrix makeRandomMatrix(int row_dim , int col_dim ) 
{ 
  int i ;
  int j ;
  Matrix m ;
  Matrix tmp ;
  long tmp___0 ;

  {
#line 608
  tmp = makeMatrix(row_dim, col_dim);
#line 608
  m = tmp;
#line 609
  i = 0;
#line 609
  while (i < m->row_dim) {
#line 610
    j = 0;
#line 610
    while (j < m->col_dim) {
#line 611
      tmp___0 = random();
#line 611
      *(*(m->cols + j) + i) = fabs((double )tmp___0 / (double )2147483647);
#line 610
      j ++;
    }
#line 609
    i ++;
  }
#line 614
  return (m);
}
}
#line 620 "src/csuCommonMatrix.c"
double matrixSumOfSquares(Matrix m ) 
{ 
  double sumOfSquares ;
  int i ;
  int j ;

  {
#line 623
  sumOfSquares = 0.0;
#line 625
  i = 0;
#line 625
  while (i < m->row_dim) {
#line 626
    j = 0;
#line 626
    while (j < m->col_dim) {
#line 627
      sumOfSquares += *(*(m->cols + j) + i) * *(*(m->cols + j) + i);
#line 626
      j ++;
    }
#line 625
    i ++;
  }
#line 630
  return (sumOfSquares);
}
}
/* compiler builtin: 
   int __builtin_strcmp(char const   * , char const   * ) ;  */
/* compiler builtin: 
   unsigned long __builtin_strlen(char const   * ) ;  */
/* compiler builtin: 
   int __builtin_va_arg_pack_len(void) ;  */
#line 1 "csuCommonFile.o"
#pragma merger("0","/tmp/cil-o1nlunSY.i","-O3,-Wall")
#line 210 "/usr/include/x86_64-linux-gnu/sys/stat.h"
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2),
__leaf__)) stat)(char const   * __restrict  __path , struct stat * __restrict  __statbuf ) ;
#line 215
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2),
__leaf__)) fstat)(int __fd , struct stat *__statbuf ) ;
#line 239
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2,3),
__leaf__)) fstatat)(int __fd , char const   * __restrict  __filename , struct stat * __restrict  __statbuf ,
                    int __flag ) ;
#line 264
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2),
__leaf__)) lstat)(char const   * __restrict  __path , struct stat * __restrict  __statbuf ) ;
#line 337
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1),
__leaf__)) mknod)(char const   *__path , __mode_t __mode , __dev_t __dev ) ;
#line 344
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2),
__leaf__)) mknodat)(int __fd , char const   *__path , __mode_t __mode , __dev_t __dev ) ;
#line 400
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(3), __leaf__)) __fxstat)(int __ver ,
                                                                                               int __fildes ,
                                                                                               struct stat *__stat_buf ) ;
#line 402
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2,3), __leaf__)) __xstat)(int __ver ,
                                                                                                char const   *__filename ,
                                                                                                struct stat *__stat_buf ) ;
#line 404
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2,3), __leaf__)) __lxstat)(int __ver ,
                                                                                                 char const   *__filename ,
                                                                                                 struct stat *__stat_buf ) ;
#line 406
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(3,4), __leaf__)) __fxstatat)(int __ver ,
                                                                                                   int __fildes ,
                                                                                                   char const   *__filename ,
                                                                                                   struct stat *__stat_buf ,
                                                                                                   int __flag ) ;
#line 443
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2,4), __leaf__)) __xmknod)(int __ver ,
                                                                                                 char const   *__path ,
                                                                                                 __mode_t __mode ,
                                                                                                 __dev_t *__dev ) ;
#line 446
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(3,5), __leaf__)) __xmknodat)(int __ver ,
                                                                                                   int __fd ,
                                                                                                   char const   *__path ,
                                                                                                   __mode_t __mode ,
                                                                                                   __dev_t *__dev ) ;
#line 453
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2),
__leaf__)) stat)(char const   * __restrict  __path , struct stat * __restrict  __statbuf ) ;
#line 453 "/usr/include/x86_64-linux-gnu/sys/stat.h"
__inline extern int ( __attribute__((__nonnull__(1,2), __leaf__)) stat)(char const   * __restrict  __path ,
                                                                        struct stat * __restrict  __statbuf ) 
{ 
  int tmp ;

  {
#line 456
  tmp = __xstat(1, (char const   *)__path, (struct stat *)__statbuf);
#line 456
  return (tmp);
}
}
#line 460
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2),
__leaf__)) lstat)(char const   * __restrict  __path , struct stat * __restrict  __statbuf ) ;
#line 460 "/usr/include/x86_64-linux-gnu/sys/stat.h"
__inline extern int ( __attribute__((__nonnull__(1,2), __leaf__)) lstat)(char const   * __restrict  __path ,
                                                                         struct stat * __restrict  __statbuf ) 
{ 
  int tmp ;

  {
#line 463
  tmp = __lxstat(1, (char const   *)__path, (struct stat *)__statbuf);
#line 463
  return (tmp);
}
}
#line 467
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2),
__leaf__)) fstat)(int __fd , struct stat *__statbuf ) ;
#line 467 "/usr/include/x86_64-linux-gnu/sys/stat.h"
__inline extern int ( __attribute__((__nonnull__(2), __leaf__)) fstat)(int __fd ,
                                                                       struct stat *__statbuf ) 
{ 
  int tmp ;

  {
#line 470
  tmp = __fxstat(1, __fd, __statbuf);
#line 470
  return (tmp);
}
}
#line 474
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2,3),
__leaf__)) fstatat)(int __fd , char const   * __restrict  __filename , struct stat * __restrict  __statbuf ,
                    int __flag ) ;
#line 474 "/usr/include/x86_64-linux-gnu/sys/stat.h"
__inline extern int ( __attribute__((__nonnull__(2,3), __leaf__)) fstatat)(int __fd ,
                                                                           char const   * __restrict  __filename ,
                                                                           struct stat * __restrict  __statbuf ,
                                                                           int __flag ) 
{ 
  int tmp ;

  {
#line 478
  tmp = __fxstatat(1, __fd, (char const   *)__filename, (struct stat *)__statbuf,
                   __flag);
#line 478
  return (tmp);
}
}
#line 483
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1),
__leaf__)) mknod)(char const   *__path , __mode_t __mode , __dev_t __dev ) ;
#line 483 "/usr/include/x86_64-linux-gnu/sys/stat.h"
__inline extern int ( __attribute__((__nonnull__(1), __leaf__)) mknod)(char const   *__path ,
                                                                       __mode_t __mode ,
                                                                       __dev_t __dev ) 
{ 
  int tmp ;

  {
#line 486
  tmp = __xmknod(0, __path, __mode, & __dev);
#line 486
  return (tmp);
}
}
#line 491
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2),
__leaf__)) mknodat)(int __fd , char const   *__path , __mode_t __mode , __dev_t __dev ) ;
#line 491 "/usr/include/x86_64-linux-gnu/sys/stat.h"
__inline extern int ( __attribute__((__nonnull__(2), __leaf__)) mknodat)(int __fd ,
                                                                         char const   *__path ,
                                                                         __mode_t __mode ,
                                                                         __dev_t __dev ) 
{ 
  int tmp ;

  {
#line 495
  tmp = __xmknodat(0, __fd, __path, __mode, & __dev);
#line 495
  return (tmp);
}
}
#line 146 "/usr/include/fcntl.h"
__inline extern int ( __attribute__((__nonnull__(1), __artificial__, __always_inline__)) open)(char const   *__path ,
                                                                                               int __oflag 
                                                                                               , ...) ;
#line 170
__inline extern int ( __attribute__((__nonnull__(2), __artificial__, __always_inline__)) openat)(int __fd ,
                                                                                                 char const   *__path ,
                                                                                                 int __oflag 
                                                                                                 , ...) ;
#line 26 "/usr/include/x86_64-linux-gnu/bits/fcntl2.h"
extern int ( __attribute__((__nonnull__(1))) __open_2)(char const   *__path , int __oflag ) ;
#line 27
extern int ( __attribute__((__nonnull__(1))) __open_alias)(char const   *__path ,
                                                           int __oflag  , ...)  __asm__("open")  ;
#line 35
extern void __open_too_many_args(void)  __attribute__((__error__("open can be called either with 2 or 3 arguments, not more"))) ;
#line 40 "/usr/include/x86_64-linux-gnu/bits/fcntl2.h"
__inline extern int ( __attribute__((__nonnull__(1), __artificial__, __always_inline__)) open)(char const   *__path ,
                                                                                               int __oflag 
                                                                                               , ...) 
{ 
  int tmp ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
#line 43
  tmp = __builtin_va_arg_pack_len();
#line 43
  if (tmp > 1) {
#line 44
    __open_too_many_args();
  }
#line 56
  tmp___4 = __builtin_va_arg_pack_len();
#line 56
  if (tmp___4 < 1) {
#line 57
    tmp___3 = __open_2(__path, __oflag);
#line 57
    return (tmp___3);
  }
#line 59
  tmp___5 = __open_alias(__path, __oflag, __builtin_va_arg_pack());
#line 59
  return (tmp___5);
}
}
#line 98
extern int ( __attribute__((__nonnull__(2))) __openat_2)(int __fd , char const   *__path ,
                                                         int __oflag ) ;
#line 100
extern int ( __attribute__((__nonnull__(2))) __openat_alias)(int __fd , char const   *__path ,
                                                             int __oflag  , ...)  __asm__("openat")  ;
#line 111
extern void __openat_too_many_args(void)  __attribute__((__error__("openat can be called either with 3 or 4 arguments, not more"))) ;
#line 116 "/usr/include/x86_64-linux-gnu/bits/fcntl2.h"
__inline extern int ( __attribute__((__nonnull__(2), __artificial__, __always_inline__)) openat)(int __fd ,
                                                                                                 char const   *__path ,
                                                                                                 int __oflag 
                                                                                                 , ...) 
{ 
  int tmp ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
#line 119
  tmp = __builtin_va_arg_pack_len();
#line 119
  if (tmp > 1) {
#line 120
    __openat_too_many_args();
  }
#line 132
  tmp___4 = __builtin_va_arg_pack_len();
#line 132
  if (tmp___4 < 1) {
#line 133
    tmp___3 = __openat_2(__fd, __path, __oflag);
#line 133
    return (tmp___3);
  }
#line 135
  tmp___5 = __openat_alias(__fd, __path, __oflag, __builtin_va_arg_pack());
#line 135
  return (tmp___5);
}
}
#line 287 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) access)(char const   *__name ,
                                                                                             int __type ) ;
#line 360
__inline extern ssize_t ( __attribute__((__warn_unused_result__, __artificial__, __always_inline__)) read)(int __fd ,
                                                                                                           void *__buf ,
                                                                                                           size_t __nbytes ) ;
#line 511
__inline extern  __attribute__((__nothrow__)) char *( __attribute__((__warn_unused_result__,
__leaf__, __artificial__, __always_inline__)) getcwd)(char *__buf , size_t __size ) ;
#line 525
__inline extern  __attribute__((__nothrow__)) char __attribute__((__deprecated__))  *( __attribute__((__warn_unused_result__,
__nonnull__(1), __leaf__, __artificial__, __always_inline__)) getwd)(char *__buf )  __attribute__((__deprecated__)) ;
#line 623
__inline extern  __attribute__((__nothrow__)) size_t ( __attribute__((__leaf__, __artificial__,
__always_inline__)) confstr)(int __name , char *__buf , size_t __len ) ;
#line 711
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__warn_unused_result__,
__leaf__, __artificial__, __always_inline__)) getgroups)(int __size , __gid_t *__list ) ;
#line 796
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__warn_unused_result__,
__nonnull__(2), __leaf__, __artificial__, __always_inline__)) ttyname_r)(int __fd ,
                                                                         char *__buf ,
                                                                         size_t __buflen ) ;
#line 831
__inline extern  __attribute__((__nothrow__)) ssize_t ( __attribute__((__warn_unused_result__,
__nonnull__(1,2), __leaf__, __artificial__, __always_inline__)) readlink)(char const   * __restrict  __path ,
                                                                          char * __restrict  __buf ,
                                                                          size_t __len ) ;
#line 842
__inline extern  __attribute__((__nothrow__)) ssize_t ( __attribute__((__warn_unused_result__,
__nonnull__(2,3), __leaf__, __artificial__, __always_inline__)) readlinkat)(int __fd ,
                                                                            char const   * __restrict  __path ,
                                                                            char * __restrict  __buf ,
                                                                            size_t __len ) ;
#line 879
__inline extern int ( __attribute__((__nonnull__(1), __artificial__, __always_inline__)) getlogin_r)(char *__buf ,
                                                                                                     size_t __buflen ) ;
#line 901
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1),
__leaf__, __artificial__, __always_inline__)) gethostname)(char *__buf , size_t __buflen ) ;
#line 919
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__warn_unused_result__,
__nonnull__(1), __leaf__, __artificial__, __always_inline__)) getdomainname)(char *__buf ,
                                                                             size_t __buflen ) ;
#line 23 "/usr/include/x86_64-linux-gnu/bits/unistd.h"
extern ssize_t ( __attribute__((__warn_unused_result__)) __read_chk)(int __fd , void *__buf ,
                                                                     size_t __nbytes ,
                                                                     size_t __buflen ) ;
#line 25
extern ssize_t ( __attribute__((__warn_unused_result__)) __read_alias)(int __fd ,
                                                                       void *__buf ,
                                                                       size_t __nbytes )  __asm__("read")  ;
#line 27
extern ssize_t ( __attribute__((__warn_unused_result__)) __read_chk_warn)(int __fd ,
                                                                          void *__buf ,
                                                                          size_t __nbytes ,
                                                                          size_t __buflen )  __asm__("__read_chk") __attribute__((__warning__("read called with bigger length than size of the destination buffer"))) ;
#line 33 "/usr/include/x86_64-linux-gnu/bits/unistd.h"
__inline extern ssize_t ( __attribute__((__warn_unused_result__, __artificial__, __always_inline__)) read)(int __fd ,
                                                                                                           void *__buf ,
                                                                                                           size_t __nbytes ) 
{ 
  unsigned long tmp ;
  ssize_t tmp___0 ;
  unsigned long tmp___1 ;
  ssize_t tmp___2 ;
  unsigned long tmp___3 ;
  unsigned long tmp___4 ;
  ssize_t tmp___5 ;

  {
#line 36
  tmp___4 = __builtin_object_size(__buf, 0);
#line 36
  if (tmp___4 != 0xffffffffffffffffUL) {
#line 39
    tmp = __builtin_object_size(__buf, 0);
#line 39
    tmp___0 = __read_chk(__fd, __buf, __nbytes, tmp);
#line 39
    return (tmp___0);
#line 41
    tmp___3 = __builtin_object_size(__buf, 0);
#line 41
    if (__nbytes > tmp___3) {
#line 42
      tmp___1 = __builtin_object_size(__buf, 0);
#line 42
      tmp___2 = __read_chk_warn(__fd, __buf, __nbytes, tmp___1);
#line 42
      return (tmp___2);
    }
  }
#line 44
  tmp___5 = __read_alias(__fd, __buf, __nbytes);
#line 44
  return (tmp___5);
}
}
#line 123
extern  __attribute__((__nothrow__)) ssize_t ( __attribute__((__warn_unused_result__,
__nonnull__(1,2), __leaf__)) __readlink_chk)(char const   * __restrict  __path , char * __restrict  __buf ,
                                             size_t __len , size_t __buflen ) ;
#line 127
extern  __attribute__((__nothrow__)) ssize_t ( __attribute__((__warn_unused_result__,
__nonnull__(1,2), __leaf__)) __readlink_alias)(char const   * __restrict  __path ,
                                               char * __restrict  __buf , size_t __len )  __asm__("readlink")  ;
#line 131
extern  __attribute__((__nothrow__)) ssize_t ( __attribute__((__warn_unused_result__,
__nonnull__(1,2), __leaf__)) __readlink_chk_warn)(char const   * __restrict  __path ,
                                                  char * __restrict  __buf , size_t __len ,
                                                  size_t __buflen )  __asm__("__readlink_chk") __attribute__((__warning__("readlink called with bigger length than size of destination buffer"))) ;
#line 138
__inline extern  __attribute__((__nothrow__)) ssize_t ( __attribute__((__warn_unused_result__,
__nonnull__(1,2), __leaf__, __artificial__, __always_inline__)) readlink)(char const   * __restrict  __path ,
                                                                          char * __restrict  __buf ,
                                                                          size_t __len ) ;
#line 138 "/usr/include/x86_64-linux-gnu/bits/unistd.h"
__inline extern ssize_t ( __attribute__((__warn_unused_result__, __nonnull__(1,2),
__leaf__, __artificial__, __always_inline__)) readlink)(char const   * __restrict  __path ,
                                                        char * __restrict  __buf ,
                                                        size_t __len ) 
{ 
  unsigned long tmp ;
  ssize_t tmp___0 ;
  unsigned long tmp___1 ;
  ssize_t tmp___2 ;
  unsigned long tmp___3 ;
  unsigned long tmp___4 ;
  ssize_t tmp___5 ;

  {
#line 142
  tmp___4 = __builtin_object_size((void *)__buf, 1);
#line 142
  if (tmp___4 != 0xffffffffffffffffUL) {
#line 145
    tmp = __builtin_object_size((void *)__buf, 1);
#line 145
    tmp___0 = __readlink_chk(__path, __buf, __len, tmp);
#line 145
    return (tmp___0);
#line 147
    tmp___3 = __builtin_object_size((void *)__buf, 1);
#line 147
    if (__len > tmp___3) {
#line 148
      tmp___1 = __builtin_object_size((void *)__buf, 1);
#line 148
      tmp___2 = __readlink_chk_warn(__path, __buf, __len, tmp___1);
#line 148
      return (tmp___2);
    }
  }
#line 150
  tmp___5 = __readlink_alias(__path, __buf, __len);
#line 150
  return (tmp___5);
}
}
#line 155
extern  __attribute__((__nothrow__)) ssize_t ( __attribute__((__warn_unused_result__,
__nonnull__(2,3), __leaf__)) __readlinkat_chk)(int __fd , char const   * __restrict  __path ,
                                               char * __restrict  __buf , size_t __len ,
                                               size_t __buflen ) ;
#line 159
extern  __attribute__((__nothrow__)) ssize_t ( __attribute__((__warn_unused_result__,
__nonnull__(2,3), __leaf__)) __readlinkat_alias)(int __fd , char const   * __restrict  __path ,
                                                 char * __restrict  __buf , size_t __len )  __asm__("readlinkat")  ;
#line 164
extern  __attribute__((__nothrow__)) ssize_t ( __attribute__((__warn_unused_result__,
__nonnull__(2,3), __leaf__)) __readlinkat_chk_warn)(int __fd , char const   * __restrict  __path ,
                                                    char * __restrict  __buf , size_t __len ,
                                                    size_t __buflen )  __asm__("__readlinkat_chk") __attribute__((__warning__("readlinkat called with bigger length than size of destination buffer"))) ;
#line 172
__inline extern  __attribute__((__nothrow__)) ssize_t ( __attribute__((__warn_unused_result__,
__nonnull__(2,3), __leaf__, __artificial__, __always_inline__)) readlinkat)(int __fd ,
                                                                            char const   * __restrict  __path ,
                                                                            char * __restrict  __buf ,
                                                                            size_t __len ) ;
#line 172 "/usr/include/x86_64-linux-gnu/bits/unistd.h"
__inline extern ssize_t ( __attribute__((__warn_unused_result__, __nonnull__(2,3),
__leaf__, __artificial__, __always_inline__)) readlinkat)(int __fd , char const   * __restrict  __path ,
                                                          char * __restrict  __buf ,
                                                          size_t __len ) 
{ 
  unsigned long tmp ;
  ssize_t tmp___0 ;
  unsigned long tmp___1 ;
  ssize_t tmp___2 ;
  unsigned long tmp___3 ;
  unsigned long tmp___4 ;
  ssize_t tmp___5 ;

  {
#line 176
  tmp___4 = __builtin_object_size((void *)__buf, 1);
#line 176
  if (tmp___4 != 0xffffffffffffffffUL) {
#line 179
    tmp = __builtin_object_size((void *)__buf, 1);
#line 179
    tmp___0 = __readlinkat_chk(__fd, __path, __buf, __len, tmp);
#line 179
    return (tmp___0);
#line 181
    tmp___3 = __builtin_object_size((void *)__buf, 1);
#line 181
    if (__len > tmp___3) {
#line 182
      tmp___1 = __builtin_object_size((void *)__buf, 1);
#line 182
      tmp___2 = __readlinkat_chk_warn(__fd, __path, __buf, __len, tmp___1);
#line 182
      return (tmp___2);
    }
  }
#line 185
  tmp___5 = __readlinkat_alias(__fd, __path, __buf, __len);
#line 185
  return (tmp___5);
}
}
#line 189
extern  __attribute__((__nothrow__)) char *( __attribute__((__warn_unused_result__,
__leaf__)) __getcwd_chk)(char *__buf , size_t __size , size_t __buflen ) ;
#line 191
extern  __attribute__((__nothrow__)) char *( __attribute__((__warn_unused_result__,
__leaf__)) __getcwd_alias)(char *__buf , size_t __size )  __asm__("getcwd")  ;
#line 193
extern  __attribute__((__nothrow__)) char *( __attribute__((__warn_unused_result__,
__leaf__)) __getcwd_chk_warn)(char *__buf , size_t __size , size_t __buflen )  __asm__("__getcwd_chk") __attribute__((__warning__("getcwd caller with bigger length than size of destination buffer"))) ;
#line 199
__inline extern  __attribute__((__nothrow__)) char *( __attribute__((__warn_unused_result__,
__leaf__, __artificial__, __always_inline__)) getcwd)(char *__buf , size_t __size ) ;
#line 199 "/usr/include/x86_64-linux-gnu/bits/unistd.h"
__inline extern char *( __attribute__((__warn_unused_result__, __leaf__, __artificial__,
__always_inline__)) getcwd)(char *__buf , size_t __size ) 
{ 
  unsigned long tmp ;
  char *tmp___0 ;
  unsigned long tmp___1 ;
  char *tmp___2 ;
  unsigned long tmp___3 ;
  unsigned long tmp___4 ;
  char *tmp___5 ;

  {
#line 202
  tmp___4 = __builtin_object_size((void *)__buf, 1);
#line 202
  if (tmp___4 != 0xffffffffffffffffUL) {
#line 205
    tmp = __builtin_object_size((void *)__buf, 1);
#line 205
    tmp___0 = __getcwd_chk(__buf, __size, tmp);
#line 205
    return (tmp___0);
#line 207
    tmp___3 = __builtin_object_size((void *)__buf, 1);
#line 207
    if (__size > tmp___3) {
#line 208
      tmp___1 = __builtin_object_size((void *)__buf, 1);
#line 208
      tmp___2 = __getcwd_chk_warn(__buf, __size, tmp___1);
#line 208
      return (tmp___2);
    }
  }
#line 210
  tmp___5 = __getcwd_alias(__buf, __size);
#line 210
  return (tmp___5);
}
}
#line 214
extern  __attribute__((__nothrow__)) char *( __attribute__((__warn_unused_result__,
__nonnull__(1), __leaf__)) __getwd_chk)(char *__buf , size_t buflen ) ;
#line 216
extern  __attribute__((__nothrow__)) char *( __attribute__((__warn_unused_result__,
__nonnull__(1), __leaf__)) __getwd_warn)(char *__buf )  __asm__("getwd") __attribute__((__warning__("please use getcwd instead, as getwd doesn\'t specify buffer size"))) ;
#line 220
__inline extern  __attribute__((__nothrow__)) char __attribute__((__deprecated__))  *( __attribute__((__warn_unused_result__,
__nonnull__(1), __leaf__, __artificial__, __always_inline__)) getwd)(char *__buf )  __attribute__((__deprecated__)) ;
#line 220 "/usr/include/x86_64-linux-gnu/bits/unistd.h"
__inline extern char __attribute__((__deprecated__))  *( __attribute__((__warn_unused_result__,
__nonnull__(1), __leaf__, __artificial__, __always_inline__)) getwd)(char *__buf ) 
{ 
  unsigned long tmp ;
  char *tmp___0 ;
  unsigned long tmp___1 ;
  char *tmp___2 ;

  {
#line 223
  tmp___1 = __builtin_object_size((void *)__buf, 1);
#line 223
  if (tmp___1 != 0xffffffffffffffffUL) {
#line 224
    tmp = __builtin_object_size((void *)__buf, 1);
#line 224
    tmp___0 = __getwd_chk(__buf, tmp);
#line 224
    return ((char __attribute__((__deprecated__))  *)tmp___0);
  }
#line 225
  tmp___2 = __getwd_warn(__buf);
#line 225
  return ((char __attribute__((__deprecated__))  *)tmp___2);
}
}
#line 229
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__leaf__)) __confstr_chk)(int __name ,
                                                                                       char *__buf ,
                                                                                       size_t __len ,
                                                                                       size_t __buflen ) ;
#line 231
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__leaf__)) __confstr_alias)(int __name ,
                                                                                         char *__buf ,
                                                                                         size_t __len )  __asm__("confstr")  ;
#line 233
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__leaf__)) __confstr_chk_warn)(int __name ,
                                                                                            char *__buf ,
                                                                                            size_t __len ,
                                                                                            size_t __buflen )  __asm__("__confstr_chk") __attribute__((__warning__("confstr called with bigger length than size of destination buffer"))) ;
#line 239
__inline extern  __attribute__((__nothrow__)) size_t ( __attribute__((__leaf__, __artificial__,
__always_inline__)) confstr)(int __name , char *__buf , size_t __len ) ;
#line 239 "/usr/include/x86_64-linux-gnu/bits/unistd.h"
__inline extern size_t ( __attribute__((__leaf__, __artificial__, __always_inline__)) confstr)(int __name ,
                                                                                               char *__buf ,
                                                                                               size_t __len ) 
{ 
  unsigned long tmp ;
  size_t tmp___0 ;
  unsigned long tmp___1 ;
  size_t tmp___2 ;
  unsigned long tmp___3 ;
  unsigned long tmp___4 ;
  size_t tmp___5 ;

  {
#line 242
  tmp___4 = __builtin_object_size((void *)__buf, 1);
#line 242
  if (tmp___4 != 0xffffffffffffffffUL) {
#line 245
    tmp = __builtin_object_size((void *)__buf, 1);
#line 245
    tmp___0 = __confstr_chk(__name, __buf, __len, tmp);
#line 245
    return (tmp___0);
#line 247
    tmp___3 = __builtin_object_size((void *)__buf, 1);
#line 247
    if (tmp___3 < __len) {
#line 248
      tmp___1 = __builtin_object_size((void *)__buf, 1);
#line 248
      tmp___2 = __confstr_chk_warn(__name, __buf, __len, tmp___1);
#line 248
      return (tmp___2);
    }
  }
#line 250
  tmp___5 = __confstr_alias(__name, __buf, __len);
#line 250
  return (tmp___5);
}
}
#line 254
extern  __attribute__((__nothrow__)) int ( __attribute__((__warn_unused_result__,
__leaf__)) __getgroups_chk)(int __size , __gid_t *__list , size_t __listlen ) ;
#line 256
extern  __attribute__((__nothrow__)) int ( __attribute__((__warn_unused_result__,
__leaf__)) __getgroups_alias)(int __size , __gid_t *__list )  __asm__("getgroups")  ;
#line 258
extern  __attribute__((__nothrow__)) int ( __attribute__((__warn_unused_result__,
__leaf__)) __getgroups_chk_warn)(int __size , __gid_t *__list , size_t __listlen )  __asm__("__getgroups_chk") __attribute__((__warning__("getgroups called with bigger group count than what can fit into destination buffer"))) ;
#line 264
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__warn_unused_result__,
__leaf__, __artificial__, __always_inline__)) getgroups)(int __size , __gid_t *__list ) ;
#line 264 "/usr/include/x86_64-linux-gnu/bits/unistd.h"
__inline extern int ( __attribute__((__warn_unused_result__, __leaf__, __artificial__,
__always_inline__)) getgroups)(int __size , __gid_t *__list ) 
{ 
  unsigned long tmp ;
  int tmp___0 ;
  unsigned long tmp___1 ;
  int tmp___2 ;
  unsigned long tmp___3 ;
  unsigned long tmp___4 ;
  int tmp___5 ;

  {
#line 267
  tmp___4 = __builtin_object_size((void *)__list, 1);
#line 267
  if (tmp___4 != 0xffffffffffffffffUL) {
#line 270
    tmp = __builtin_object_size((void *)__list, 1);
#line 270
    tmp___0 = __getgroups_chk(__size, __list, tmp);
#line 270
    return (tmp___0);
#line 272
    tmp___3 = __builtin_object_size((void *)__list, 1);
#line 272
    if ((unsigned long )__size * sizeof(__gid_t ) > tmp___3) {
#line 273
      tmp___1 = __builtin_object_size((void *)__list, 1);
#line 273
      tmp___2 = __getgroups_chk_warn(__size, __list, tmp___1);
#line 273
      return (tmp___2);
    }
  }
#line 275
  tmp___5 = __getgroups_alias(__size, __list);
#line 275
  return (tmp___5);
}
}
#line 279
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2), __leaf__)) __ttyname_r_chk)(int __fd ,
                                                                                                      char *__buf ,
                                                                                                      size_t __buflen ,
                                                                                                      size_t __nreal ) ;
#line 281
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2), __leaf__)) __ttyname_r_alias)(int __fd ,
                                                                                                        char *__buf ,
                                                                                                        size_t __buflen )  __asm__("ttyname_r")  ;
#line 284
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2), __leaf__)) __ttyname_r_chk_warn)(int __fd ,
                                                                                                           char *__buf ,
                                                                                                           size_t __buflen ,
                                                                                                           size_t __nreal )  __asm__("__ttyname_r_chk") __attribute__((__warning__("ttyname_r called with bigger buflen than size of destination buffer"))) ;
#line 290
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__warn_unused_result__,
__nonnull__(2), __leaf__, __artificial__, __always_inline__)) ttyname_r)(int __fd ,
                                                                         char *__buf ,
                                                                         size_t __buflen ) ;
#line 290 "/usr/include/x86_64-linux-gnu/bits/unistd.h"
__inline extern int ( __attribute__((__warn_unused_result__, __nonnull__(2), __leaf__,
__artificial__, __always_inline__)) ttyname_r)(int __fd , char *__buf , size_t __buflen ) 
{ 
  unsigned long tmp ;
  int tmp___0 ;
  unsigned long tmp___1 ;
  int tmp___2 ;
  unsigned long tmp___3 ;
  unsigned long tmp___4 ;
  int tmp___5 ;

  {
#line 293
  tmp___4 = __builtin_object_size((void *)__buf, 1);
#line 293
  if (tmp___4 != 0xffffffffffffffffUL) {
#line 296
    tmp = __builtin_object_size((void *)__buf, 1);
#line 296
    tmp___0 = __ttyname_r_chk(__fd, __buf, __buflen, tmp);
#line 296
    return (tmp___0);
#line 298
    tmp___3 = __builtin_object_size((void *)__buf, 1);
#line 298
    if (__buflen > tmp___3) {
#line 299
      tmp___1 = __builtin_object_size((void *)__buf, 1);
#line 299
      tmp___2 = __ttyname_r_chk_warn(__fd, __buf, __buflen, tmp___1);
#line 299
      return (tmp___2);
    }
  }
#line 301
  tmp___5 = __ttyname_r_alias(__fd, __buf, __buflen);
#line 301
  return (tmp___5);
}
}
#line 306
extern int ( __attribute__((__nonnull__(1))) __getlogin_r_chk)(char *__buf , size_t __buflen ,
                                                               size_t __nreal ) ;
#line 308
extern int ( __attribute__((__nonnull__(1))) __getlogin_r_alias)(char *__buf , size_t __buflen )  __asm__("getlogin_r")  ;
#line 310
extern int ( __attribute__((__nonnull__(1))) __getlogin_r_chk_warn)(char *__buf ,
                                                                    size_t __buflen ,
                                                                    size_t __nreal )  __asm__("__getlogin_r_chk") __attribute__((__warning__("getlogin_r called with bigger buflen than size of destination buffer"))) ;
#line 316 "/usr/include/x86_64-linux-gnu/bits/unistd.h"
__inline extern int ( __attribute__((__nonnull__(1), __artificial__, __always_inline__)) getlogin_r)(char *__buf ,
                                                                                                     size_t __buflen ) 
{ 
  unsigned long tmp ;
  int tmp___0 ;
  unsigned long tmp___1 ;
  int tmp___2 ;
  unsigned long tmp___3 ;
  unsigned long tmp___4 ;
  int tmp___5 ;

  {
#line 319
  tmp___4 = __builtin_object_size((void *)__buf, 1);
#line 319
  if (tmp___4 != 0xffffffffffffffffUL) {
#line 322
    tmp = __builtin_object_size((void *)__buf, 1);
#line 322
    tmp___0 = __getlogin_r_chk(__buf, __buflen, tmp);
#line 322
    return (tmp___0);
#line 324
    tmp___3 = __builtin_object_size((void *)__buf, 1);
#line 324
    if (__buflen > tmp___3) {
#line 325
      tmp___1 = __builtin_object_size((void *)__buf, 1);
#line 325
      tmp___2 = __getlogin_r_chk_warn(__buf, __buflen, tmp___1);
#line 325
      return (tmp___2);
    }
  }
#line 327
  tmp___5 = __getlogin_r_alias(__buf, __buflen);
#line 327
  return (tmp___5);
}
}
#line 333
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) __gethostname_chk)(char *__buf ,
                                                                                                        size_t __buflen ,
                                                                                                        size_t __nreal ) ;
#line 335
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) __gethostname_alias)(char *__buf ,
                                                                                                          size_t __buflen )  __asm__("gethostname")  ;
#line 337
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) __gethostname_chk_warn)(char *__buf ,
                                                                                                             size_t __buflen ,
                                                                                                             size_t __nreal )  __asm__("__gethostname_chk") __attribute__((__warning__("gethostname called with bigger buflen than size of destination buffer"))) ;
#line 343
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1),
__leaf__, __artificial__, __always_inline__)) gethostname)(char *__buf , size_t __buflen ) ;
#line 343 "/usr/include/x86_64-linux-gnu/bits/unistd.h"
__inline extern int ( __attribute__((__nonnull__(1), __leaf__, __artificial__, __always_inline__)) gethostname)(char *__buf ,
                                                                                                                size_t __buflen ) 
{ 
  unsigned long tmp ;
  int tmp___0 ;
  unsigned long tmp___1 ;
  int tmp___2 ;
  unsigned long tmp___3 ;
  unsigned long tmp___4 ;
  int tmp___5 ;

  {
#line 346
  tmp___4 = __builtin_object_size((void *)__buf, 1);
#line 346
  if (tmp___4 != 0xffffffffffffffffUL) {
#line 349
    tmp = __builtin_object_size((void *)__buf, 1);
#line 349
    tmp___0 = __gethostname_chk(__buf, __buflen, tmp);
#line 349
    return (tmp___0);
#line 351
    tmp___3 = __builtin_object_size((void *)__buf, 1);
#line 351
    if (__buflen > tmp___3) {
#line 352
      tmp___1 = __builtin_object_size((void *)__buf, 1);
#line 352
      tmp___2 = __gethostname_chk_warn(__buf, __buflen, tmp___1);
#line 352
      return (tmp___2);
    }
  }
#line 354
  tmp___5 = __gethostname_alias(__buf, __buflen);
#line 354
  return (tmp___5);
}
}
#line 360
extern  __attribute__((__nothrow__)) int ( __attribute__((__warn_unused_result__,
__nonnull__(1), __leaf__)) __getdomainname_chk)(char *__buf , size_t __buflen , size_t __nreal ) ;
#line 362
extern  __attribute__((__nothrow__)) int ( __attribute__((__warn_unused_result__,
__nonnull__(1), __leaf__)) __getdomainname_alias)(char *__buf , size_t __buflen )  __asm__("getdomainname")  ;
#line 365
extern  __attribute__((__nothrow__)) int ( __attribute__((__warn_unused_result__,
__nonnull__(1), __leaf__)) __getdomainname_chk_warn)(char *__buf , size_t __buflen ,
                                                     size_t __nreal )  __asm__("__getdomainname_chk") __attribute__((__warning__("getdomainname called with bigger buflen than size of destination buffer"))) ;
#line 372
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__warn_unused_result__,
__nonnull__(1), __leaf__, __artificial__, __always_inline__)) getdomainname)(char *__buf ,
                                                                             size_t __buflen ) ;
#line 372 "/usr/include/x86_64-linux-gnu/bits/unistd.h"
__inline extern int ( __attribute__((__warn_unused_result__, __nonnull__(1), __leaf__,
__artificial__, __always_inline__)) getdomainname)(char *__buf , size_t __buflen ) 
{ 
  unsigned long tmp ;
  int tmp___0 ;
  unsigned long tmp___1 ;
  int tmp___2 ;
  unsigned long tmp___3 ;
  unsigned long tmp___4 ;
  int tmp___5 ;

  {
#line 375
  tmp___4 = __builtin_object_size((void *)__buf, 1);
#line 375
  if (tmp___4 != 0xffffffffffffffffUL) {
#line 378
    tmp = __builtin_object_size((void *)__buf, 1);
#line 378
    tmp___0 = __getdomainname_chk(__buf, __buflen, tmp);
#line 378
    return (tmp___0);
#line 380
    tmp___3 = __builtin_object_size((void *)__buf, 1);
#line 380
    if (__buflen > tmp___3) {
#line 381
      tmp___1 = __builtin_object_size((void *)__buf, 1);
#line 381
      tmp___2 = __getdomainname_chk_warn(__buf, __buflen, tmp___1);
#line 381
      return (tmp___2);
    }
  }
#line 383
  tmp___5 = __getdomainname_alias(__buf, __buflen);
#line 383
  return (tmp___5);
}
}
#line 82 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) __int32_t const   **( __attribute__((__leaf__)) __ctype_tolower_loc)(void)  __attribute__((__const__)) ;
#line 84
extern  __attribute__((__nothrow__)) __int32_t const   **( __attribute__((__leaf__)) __ctype_toupper_loc)(void)  __attribute__((__const__)) ;
#line 125
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) tolower)(int __c ) ;
#line 128
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) toupper)(int __c ) ;
#line 215
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) tolower)(int __c ) ;
#line 215 "/usr/include/ctype.h"
__inline extern int ( __attribute__((__leaf__)) tolower)(int __c ) 
{ 
  __int32_t const   **tmp ;
  __int32_t tmp___0 ;

  {
#line 218
  if (__c >= -128) {
#line 218
    if (__c < 256) {
#line 218
      tmp = __ctype_tolower_loc();
#line 218
      tmp___0 = *(*tmp + __c);
    } else {
#line 218
      tmp___0 = (__int32_t const   )__c;
    }
  } else {
#line 218
    tmp___0 = (__int32_t const   )__c;
  }
#line 218
  return ((int )tmp___0);
}
}
#line 221
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) toupper)(int __c ) ;
#line 221 "/usr/include/ctype.h"
__inline extern int ( __attribute__((__leaf__)) toupper)(int __c ) 
{ 
  __int32_t const   **tmp ;
  __int32_t tmp___0 ;

  {
#line 224
  if (__c >= -128) {
#line 224
    if (__c < 256) {
#line 224
      tmp = __ctype_toupper_loc();
#line 224
      tmp___0 = *(*tmp + __c);
    } else {
#line 224
      tmp___0 = (__int32_t const   )__c;
    }
  } else {
#line 224
    tmp___0 = (__int32_t const   )__c;
  }
#line 224
  return ((int )tmp___0);
}
}
#line 433 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) sscanf)(char const   * __restrict  __s ,
                                                                             char const   * __restrict  __format 
                                                                             , ...)  __asm__("__isoc99_sscanf")  ;
#line 531
extern int fgetc(FILE *__stream ) ;
#line 573
extern int fputc(int __c , FILE *__stream ) ;
#line 715
extern size_t fwrite(void const   * __restrict  __ptr , size_t __size , size_t __n ,
                     FILE * __restrict  __s ) ;
#line 759
extern void rewind(FILE *__stream ) ;
#line 760 "/usr/include/stdlib.h"
extern void ( __attribute__((__nonnull__(1,4))) qsort)(void *__base , size_t __nmemb ,
                                                       size_t __size , int (*__compar)(void const   * ,
                                                                                       void const   * ) ) ;
#line 205 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) finite)(double __value )  __attribute__((__const__)) ;
#line 150 "/usr/include/x86_64-linux-gnu/bits/mathinline.h"
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__, __always_inline__)) __signbitl)(long double __x )  __attribute__((__const__)) ;
#line 150 "/usr/include/x86_64-linux-gnu/bits/mathinline.h"
__inline extern int ( __attribute__((__leaf__, __always_inline__)) __signbitl)(long double __x ) 
{ 
  union __anonunion___u_30 __u ;

  {
#line 153
  __u.__l = __x;
#line 154
  return ((__u.__i[2] & 32768) != 0);
}
}
#line 200 "src/csuCommonUtil.h"
void tokenizerInit(Tokenizer *tok , int (*source)(char *buff , size_t nChars , void **arg ) ,
                   void *arg ) ;
#line 201
char *tokenizerGetWord(Tokenizer *tok ) ;
#line 202
int tokenizerEndOfFile(Tokenizer *tok ) ;
#line 203
int tokenizerEndOfLine(Tokenizer *tok ) ;
#line 209
int tokenizerStreamReader(char *buff , size_t nChars , void **arg ) ;
#line 218
void listAccumulate(void **base , void *data , size_t size ) ;
#line 219
void *listToArray(void **base , size_t size , size_t *nelems ) ;
#line 231
int isMachineLittleEndian(void) ;
#line 233
void byteswap_4(void *data , int const   numfourbyteelements ) ;
#line 126 "src/csuCommonFile.h"
void writeInt(FILE *f , int n ) ;
#line 127
void writeFloat(FILE *f , float n ) ;
#line 128
void writeDouble(FILE *f , double n ) ;
#line 130
void readInt(FILE *f , int *n ) ;
#line 131
void readFloat(FILE *f , float *n ) ;
#line 132
void readDouble(FILE *f , double *n ) ;
#line 136
void checkWriteableDirectory(char const   *directory , char const   *message ) ;
#line 137
void checkReadableDirectory(char const   *directory , char const   *message ) ;
#line 138
void checkReadableFile(char const   *file , char const   *message ) ;
#line 140
ListOfStrings readListOfStrings(char const   *fileName , int *nStrings ) ;
#line 141
void freeListOfStrings(ListOfStrings list ) ;
#line 143
void sortSubjectsBySimilarityToProbe(char *probe , ListOfStrings subjects , char *distanceMatrix ,
                                     int *indices ) ;
#line 145
void readFile(char const   *fname , int n , Matrix images ) ;
#line 151
void freeImageNames(ImageList *srt ) ;
#line 152
Matrix readImages(char *imageNamesFile , char *imageDirectory , int *numPixels , int *numImages ,
                  int *numSubjects , ImageList **srt ) ;
#line 155
int numImageInImageList(ImageList *srt ) ;
#line 156
int autoFileLength(char const   *imageName ) ;
#line 158
float *readFeretRaster(char const   *fn , int numpix ) ;
#line 159
float *writeFeretRaster(char const   *fn , float *data , int numpix ) ;
#line 161
unsigned char *readImagePGM(char const   *filename , int *w , int *h , int verbose ) ;
#line 162
void writeImagePGM(char const   *fn , float *data , int numpix , int w , int h ) ;
#line 129 "src/csuCommonFile.c"
void writeInt(FILE *f , int n ) 
{ 
  int4 tmp ;
  int tmp___0 ;

  {
#line 131
  tmp.n = n;
#line 132
  tmp___0 = isMachineLittleEndian();
#line 132
  if (tmp___0) {
#line 133
    fwrite((void const   * __restrict  )(& tmp.elem.d), (size_t )1, (size_t )1, (FILE * __restrict  )f);
#line 134
    fwrite((void const   * __restrict  )(& tmp.elem.c), (size_t )1, (size_t )1, (FILE * __restrict  )f);
#line 135
    fwrite((void const   * __restrict  )(& tmp.elem.b), (size_t )1, (size_t )1, (FILE * __restrict  )f);
#line 136
    fwrite((void const   * __restrict  )(& tmp.elem.a), (size_t )1, (size_t )1, (FILE * __restrict  )f);
  } else {
#line 139
    fwrite((void const   * __restrict  )(& tmp.elem.a), (size_t )1, (size_t )1, (FILE * __restrict  )f);
#line 140
    fwrite((void const   * __restrict  )(& tmp.elem.b), (size_t )1, (size_t )1, (FILE * __restrict  )f);
#line 141
    fwrite((void const   * __restrict  )(& tmp.elem.c), (size_t )1, (size_t )1, (FILE * __restrict  )f);
#line 142
    fwrite((void const   * __restrict  )(& tmp.elem.d), (size_t )1, (size_t )1, (FILE * __restrict  )f);
  }
#line 144
  return;
}
}
#line 146 "src/csuCommonFile.c"
void writeFloat(FILE *f , float n ) 
{ 
  float4 tmp ;
  int tmp___0 ;

  {
#line 148
  tmp.n = n;
#line 149
  tmp___0 = isMachineLittleEndian();
#line 149
  if (tmp___0) {
#line 150
    fwrite((void const   * __restrict  )(& tmp.elem.d), (size_t )1, (size_t )1, (FILE * __restrict  )f);
#line 151
    fwrite((void const   * __restrict  )(& tmp.elem.c), (size_t )1, (size_t )1, (FILE * __restrict  )f);
#line 152
    fwrite((void const   * __restrict  )(& tmp.elem.b), (size_t )1, (size_t )1, (FILE * __restrict  )f);
#line 153
    fwrite((void const   * __restrict  )(& tmp.elem.a), (size_t )1, (size_t )1, (FILE * __restrict  )f);
  } else {
#line 156
    fwrite((void const   * __restrict  )(& tmp.elem.a), (size_t )1, (size_t )1, (FILE * __restrict  )f);
#line 157
    fwrite((void const   * __restrict  )(& tmp.elem.b), (size_t )1, (size_t )1, (FILE * __restrict  )f);
#line 158
    fwrite((void const   * __restrict  )(& tmp.elem.c), (size_t )1, (size_t )1, (FILE * __restrict  )f);
#line 159
    fwrite((void const   * __restrict  )(& tmp.elem.d), (size_t )1, (size_t )1, (FILE * __restrict  )f);
  }
#line 161
  return;
}
}
#line 163 "src/csuCommonFile.c"
void writeDouble(FILE *f , double n ) 
{ 
  double8 tmp ;
  int tmp___0 ;

  {
#line 165
  tmp.n = n;
#line 166
  tmp___0 = isMachineLittleEndian();
#line 166
  if (tmp___0) {
#line 167
    fwrite((void const   * __restrict  )(& tmp.elem.h), (size_t )1, (size_t )1, (FILE * __restrict  )f);
#line 168
    fwrite((void const   * __restrict  )(& tmp.elem.g), (size_t )1, (size_t )1, (FILE * __restrict  )f);
#line 169
    fwrite((void const   * __restrict  )(& tmp.elem.f), (size_t )1, (size_t )1, (FILE * __restrict  )f);
#line 170
    fwrite((void const   * __restrict  )(& tmp.elem.e), (size_t )1, (size_t )1, (FILE * __restrict  )f);
#line 171
    fwrite((void const   * __restrict  )(& tmp.elem.d), (size_t )1, (size_t )1, (FILE * __restrict  )f);
#line 172
    fwrite((void const   * __restrict  )(& tmp.elem.c), (size_t )1, (size_t )1, (FILE * __restrict  )f);
#line 173
    fwrite((void const   * __restrict  )(& tmp.elem.b), (size_t )1, (size_t )1, (FILE * __restrict  )f);
#line 174
    fwrite((void const   * __restrict  )(& tmp.elem.a), (size_t )1, (size_t )1, (FILE * __restrict  )f);
  } else {
#line 177
    fwrite((void const   * __restrict  )(& tmp.elem.a), (size_t )1, (size_t )1, (FILE * __restrict  )f);
#line 178
    fwrite((void const   * __restrict  )(& tmp.elem.b), (size_t )1, (size_t )1, (FILE * __restrict  )f);
#line 179
    fwrite((void const   * __restrict  )(& tmp.elem.c), (size_t )1, (size_t )1, (FILE * __restrict  )f);
#line 180
    fwrite((void const   * __restrict  )(& tmp.elem.d), (size_t )1, (size_t )1, (FILE * __restrict  )f);
#line 181
    fwrite((void const   * __restrict  )(& tmp.elem.e), (size_t )1, (size_t )1, (FILE * __restrict  )f);
#line 182
    fwrite((void const   * __restrict  )(& tmp.elem.f), (size_t )1, (size_t )1, (FILE * __restrict  )f);
#line 183
    fwrite((void const   * __restrict  )(& tmp.elem.g), (size_t )1, (size_t )1, (FILE * __restrict  )f);
#line 184
    fwrite((void const   * __restrict  )(& tmp.elem.h), (size_t )1, (size_t )1, (FILE * __restrict  )f);
  }
#line 187
  return;
}
}
#line 189 "src/csuCommonFile.c"
void readInt(FILE *f , int *n ) 
{ 
  int4 tmp ;
  int tmp___0 ;

  {
#line 191
  tmp___0 = isMachineLittleEndian();
#line 191
  if (tmp___0) {
#line 192
    fread((void * __restrict  )(& tmp.elem.d), (size_t )1, (size_t )1, (FILE * __restrict  )f);
#line 193
    fread((void * __restrict  )(& tmp.elem.c), (size_t )1, (size_t )1, (FILE * __restrict  )f);
#line 194
    fread((void * __restrict  )(& tmp.elem.b), (size_t )1, (size_t )1, (FILE * __restrict  )f);
#line 195
    fread((void * __restrict  )(& tmp.elem.a), (size_t )1, (size_t )1, (FILE * __restrict  )f);
  } else {
#line 198
    fread((void * __restrict  )(& tmp.elem.a), (size_t )1, (size_t )1, (FILE * __restrict  )f);
#line 199
    fread((void * __restrict  )(& tmp.elem.b), (size_t )1, (size_t )1, (FILE * __restrict  )f);
#line 200
    fread((void * __restrict  )(& tmp.elem.c), (size_t )1, (size_t )1, (FILE * __restrict  )f);
#line 201
    fread((void * __restrict  )(& tmp.elem.d), (size_t )1, (size_t )1, (FILE * __restrict  )f);
  }
#line 203
  *n = tmp.n;
#line 204
  return;
}
}
#line 206 "src/csuCommonFile.c"
void readFloat(FILE *f , float *n ) 
{ 
  float4 tmp ;
  int tmp___0 ;

  {
#line 208
  tmp___0 = isMachineLittleEndian();
#line 208
  if (tmp___0) {
#line 210
    fread((void * __restrict  )(& tmp.elem.d), (size_t )1, (size_t )1, (FILE * __restrict  )f);
#line 211
    fread((void * __restrict  )(& tmp.elem.c), (size_t )1, (size_t )1, (FILE * __restrict  )f);
#line 212
    fread((void * __restrict  )(& tmp.elem.b), (size_t )1, (size_t )1, (FILE * __restrict  )f);
#line 213
    fread((void * __restrict  )(& tmp.elem.a), (size_t )1, (size_t )1, (FILE * __restrict  )f);
  } else {
#line 216
    fread((void * __restrict  )(& tmp.elem.a), (size_t )1, (size_t )1, (FILE * __restrict  )f);
#line 217
    fread((void * __restrict  )(& tmp.elem.b), (size_t )1, (size_t )1, (FILE * __restrict  )f);
#line 218
    fread((void * __restrict  )(& tmp.elem.c), (size_t )1, (size_t )1, (FILE * __restrict  )f);
#line 219
    fread((void * __restrict  )(& tmp.elem.d), (size_t )1, (size_t )1, (FILE * __restrict  )f);
  }
#line 221
  *n = tmp.n;
#line 222
  return;
}
}
#line 233 "src/csuCommonFile.c"
void readDouble(FILE *f , double *n ) 
{ 
  double8 tmp ;
  int tmp___0 ;

  {
#line 237
  tmp___0 = isMachineLittleEndian();
#line 237
  if (tmp___0) {
#line 238
    fread((void * __restrict  )(& tmp.elem.h), (size_t )1, (size_t )1, (FILE * __restrict  )f);
#line 239
    fread((void * __restrict  )(& tmp.elem.g), (size_t )1, (size_t )1, (FILE * __restrict  )f);
#line 240
    fread((void * __restrict  )(& tmp.elem.f), (size_t )1, (size_t )1, (FILE * __restrict  )f);
#line 241
    fread((void * __restrict  )(& tmp.elem.e), (size_t )1, (size_t )1, (FILE * __restrict  )f);
#line 242
    fread((void * __restrict  )(& tmp.elem.d), (size_t )1, (size_t )1, (FILE * __restrict  )f);
#line 243
    fread((void * __restrict  )(& tmp.elem.c), (size_t )1, (size_t )1, (FILE * __restrict  )f);
#line 244
    fread((void * __restrict  )(& tmp.elem.b), (size_t )1, (size_t )1, (FILE * __restrict  )f);
#line 245
    fread((void * __restrict  )(& tmp.elem.a), (size_t )1, (size_t )1, (FILE * __restrict  )f);
  } else {
#line 248
    fread((void * __restrict  )(& tmp.elem.a), (size_t )1, (size_t )1, (FILE * __restrict  )f);
#line 249
    fread((void * __restrict  )(& tmp.elem.b), (size_t )1, (size_t )1, (FILE * __restrict  )f);
#line 250
    fread((void * __restrict  )(& tmp.elem.c), (size_t )1, (size_t )1, (FILE * __restrict  )f);
#line 251
    fread((void * __restrict  )(& tmp.elem.d), (size_t )1, (size_t )1, (FILE * __restrict  )f);
#line 252
    fread((void * __restrict  )(& tmp.elem.e), (size_t )1, (size_t )1, (FILE * __restrict  )f);
#line 253
    fread((void * __restrict  )(& tmp.elem.f), (size_t )1, (size_t )1, (FILE * __restrict  )f);
#line 254
    fread((void * __restrict  )(& tmp.elem.g), (size_t )1, (size_t )1, (FILE * __restrict  )f);
#line 255
    fread((void * __restrict  )(& tmp.elem.h), (size_t )1, (size_t )1, (FILE * __restrict  )f);
  }
#line 257
  *n = tmp.n;
#line 258
  return;
}
}
#line 278 "src/csuCommonFile.c"
static char path[255]  ;
#line 275 "src/csuCommonFile.c"
char *makePath(char const   *directoryName , char const   *fileName ) 
{ 
  char const   *osDependentPathSeparator ;

  {
#line 279
  osDependentPathSeparator = "/";
#line 280
  sprintf((char * __restrict  )(path), (char const   * __restrict  )"%s%s%s", directoryName,
          osDependentPathSeparator, fileName);
#line 281
  return (path);
}
}
#line 292 "src/csuCommonFile.c"
void checkWriteableDirectory(char const   *directory , char const   *message ) 
{ 
  struct stat buf ;
  int err ;
  int tmp ;
  int ok ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 296
  tmp = stat((char const   * __restrict  )directory, (struct stat * __restrict  )(& buf));
#line 296
  err = tmp;
#line 297
  if (err == 0) {
#line 297
    if ((buf.st_mode & 61440U) == 16384U) {
#line 297
      tmp___0 = access(directory, 2);
#line 297
      if (tmp___0 == 0) {
#line 297
        tmp___1 = 1;
      } else {
#line 297
        tmp___1 = 0;
      }
    } else {
#line 297
      tmp___1 = 0;
    }
  } else {
#line 297
    tmp___1 = 0;
  }
#line 297
  ok = tmp___1;
#line 300
  if (! ok) {
#line 302
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )message, directory);
#line 303
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"\n");
#line 304
    exit(1);
  }
#line 306
  return;
}
}
#line 316 "src/csuCommonFile.c"
void checkReadableDirectory(char const   *directory , char const   *message ) 
{ 
  struct stat buf ;
  int err ;
  int tmp ;
  int ok ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 320
  tmp = stat((char const   * __restrict  )directory, (struct stat * __restrict  )(& buf));
#line 320
  err = tmp;
#line 321
  if (err == 0) {
#line 321
    if ((buf.st_mode & 61440U) == 16384U) {
#line 321
      tmp___0 = access(directory, 4);
#line 321
      if (tmp___0 == 0) {
#line 321
        tmp___1 = 1;
      } else {
#line 321
        tmp___1 = 0;
      }
    } else {
#line 321
      tmp___1 = 0;
    }
  } else {
#line 321
    tmp___1 = 0;
  }
#line 321
  ok = tmp___1;
#line 323
  if (! ok) {
#line 325
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )message, directory);
#line 326
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"\n");
#line 327
    exit(1);
  }
#line 329
  return;
}
}
#line 338 "src/csuCommonFile.c"
void checkReadableFile(char const   *file , char const   *message ) 
{ 
  struct stat buf ;
  int err ;
  int tmp ;
  int ok ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 342
  tmp = stat((char const   * __restrict  )file, (struct stat * __restrict  )(& buf));
#line 342
  err = tmp;
#line 343
  if (err == 0) {
#line 343
    if ((buf.st_mode & 61440U) == 32768U) {
#line 343
      tmp___0 = access(file, 4);
#line 343
      if (tmp___0 == 0) {
#line 343
        tmp___1 = 1;
      } else {
#line 343
        tmp___1 = 0;
      }
    } else {
#line 343
      tmp___1 = 0;
    }
  } else {
#line 343
    tmp___1 = 0;
  }
#line 343
  ok = tmp___1;
#line 344
  if (! ok) {
#line 346
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )message, file);
#line 347
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"\n");
#line 348
    exit(1);
  }
#line 350
  return;
}
}
#line 371 "src/csuCommonFile.c"
ListOfStrings readListOfStrings(char const   *fileName , int *nStrings ) 
{ 
  Tokenizer tok ;
  void *stringList ;
  FILE *f ;
  char *string ;
  ListOfStrings array ;
  size_t numStrings ;
  time_t tttt ;
  time_t tmp ;
  char *tmp___0 ;
  char *tmp___13 ;
  char *tmp___14 ;
  int tmp___15 ;
  void *tmp___16 ;

  {
#line 375
  stringList = (void *)0;
#line 381
  f = fopen((char const   * __restrict  )fileName, (char const   * __restrict  )"r");
#line 382
  if (! f) {
#line 382
    tmp = time((time_t *)0);
#line 382
    tttt = tmp;
#line 382
    tmp___0 = ctime((time_t const   *)(& tttt));
#line 382
    printf((char const   * __restrict  )"**DEBUG CHECK** Failed check (%s) \"%s\"\n             at [%s]<%s():line %u>\n             %s\n",
           "f", "Unable to read file", "src/csuCommonFile.c", "readListOfStrings",
           382, tmp___0);
#line 382
    fflush(stdout);
#line 382
    exit(1);
  }
#line 384
  tokenizerInit(& tok, & tokenizerStreamReader, (void *)f);
#line 385
  while (1) {
#line 385
    tmp___15 = tokenizerEndOfFile(& tok);
#line 385
    if (tmp___15) {
#line 385
      break;
    }
#line 387
    tmp___13 = tokenizerGetWord(& tok);
#line 387
    tmp___14 = __strdup((char const   *)tmp___13);
#line 387
    string = tmp___14;
#line 388
    listAccumulate(& stringList, (void *)(& string), sizeof(unsigned char *));
  }
#line 391
  fclose(f);
#line 394
  string = (char *)((void *)0);
#line 395
  listAccumulate(& stringList, (void *)(& string), sizeof(unsigned char *));
#line 397
  tmp___16 = listToArray(& stringList, sizeof(unsigned char *), & numStrings);
#line 397
  array = (ListOfStrings )tmp___16;
#line 398
  if (nStrings) {
#line 398
    *nStrings = (int )(numStrings - 1UL);
  }
#line 399
  return (array);
}
}
#line 407 "src/csuCommonFile.c"
void freeListOfStrings(ListOfStrings list ) 
{ 
  char **p ;
  char **tmp ;

  {
#line 410
  p = list;
#line 411
  while ((unsigned long )*p != (unsigned long )((void *)0)) {
#line 412
    tmp = p;
#line 412
    p ++;
#line 412
    free((void *)*tmp);
  }
#line 413
  free((void *)list);
#line 414
  return;
}
}
#line 423 "src/csuCommonFile.c"
int countStrings(ListOfStrings list ) 
{ 
  int count ;
  char **p ;
  char **tmp ;

  {
#line 426
  count = 0;
#line 427
  p = list;
#line 428
  while (1) {
#line 428
    tmp = p;
#line 428
    p ++;
#line 428
    if (! ((unsigned long )*tmp != (unsigned long )((void *)0))) {
#line 428
      break;
    }
#line 429
    count ++;
  }
#line 430
  return (count);
}
}
#line 460 "src/csuCommonFile.c"
int distanceMeasureComparator(void const   *a , void const   *b ) 
{ 
  DistanceMeasure const   *d1 ;
  DistanceMeasure const   *d2 ;

  {
#line 463
  d1 = (DistanceMeasure const   *)((DistanceMeasure *)a);
#line 464
  d2 = (DistanceMeasure const   *)((DistanceMeasure *)b);
#line 466
  if (d1->distance < d2->distance) {
#line 467
    return (-1);
  }
#line 468
  if (d1->distance > d2->distance) {
#line 469
    return (1);
  }
#line 470
  return (0);
}
}
#line 491 "src/csuCommonFile.c"
void sortSubjectsBySimilarityToProbe(char *probe , ListOfStrings subjects , char *distanceMatrix ,
                                     int *indices ) 
{ 
  int i ;
  int j ;
  int nDistances ;
  DistanceMeasure *distances ;
  DistanceMeasure *toSort ;
  int nSubjects ;
  int tmp ;
  Tokenizer tok ;
  FILE *f ;
  char *tmp___0 ;
  FILE *tmp___1 ;
  void *distanceList ;
  time_t tttt ;
  time_t tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  DistanceMeasure m ;
  char *tmp___17 ;
  char *tmp___18 ;
  char *tmp___19 ;
  int tmp___20 ;
  void *tmp___21 ;
  void *tmp___22 ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___24 ;
  int tmp___27 ;
  int tmp___28 ;
  int tmp___29 ;
  long tmp___30 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___32 ;
  int tmp___35 ;
  int tmp___36 ;
  int tmp___37 ;

  {
#line 495
  distances = (DistanceMeasure *)((void *)0);
#line 496
  toSort = (DistanceMeasure *)((void *)0);
#line 498
  tmp = countStrings(subjects);
#line 498
  nSubjects = tmp;
#line 504
  if (distanceMatrix) {
#line 507
    tmp___0 = makePath((char const   *)distanceMatrix, (char const   *)probe);
#line 507
    tmp___1 = fopen((char const   * __restrict  )tmp___0, (char const   * __restrict  )"r");
#line 507
    f = tmp___1;
#line 508
    distanceList = (void *)0;
#line 510
    if (! f) {
#line 510
      tmp___2 = time((time_t *)0);
#line 510
      tttt = tmp___2;
#line 510
      printf((char const   * __restrict  )"**DEBUG CHECK** Failed check (%s) \"",
             "f");
#line 510
      tmp___3 = makePath((char const   *)distanceMatrix, (char const   *)probe);
#line 510
      printf((char const   * __restrict  )"Unable to open file %s in scores directory",
             tmp___3);
#line 510
      tmp___4 = ctime((time_t const   *)(& tttt));
#line 510
      printf((char const   * __restrict  )"\"\n             at [%s]<%s():line %u>\n             %s\n",
             "src/csuCommonFile.c", "sortSubjectsBySimilarityToProbe", 510, tmp___4);
#line 510
      fflush(stdout);
#line 510
      exit(1);
    }
#line 512
    tokenizerInit(& tok, & tokenizerStreamReader, (void *)f);
#line 513
    while (1) {
#line 513
      tmp___20 = tokenizerEndOfFile(& tok);
#line 513
      if (tmp___20) {
#line 513
        break;
      }
#line 516
      tmp___17 = tokenizerGetWord(& tok);
#line 516
      tmp___18 = __strdup((char const   *)tmp___17);
#line 516
      m.subject = tmp___18;
#line 517
      tmp___19 = tokenizerGetWord(& tok);
#line 517
      m.distance = atof((char const   *)tmp___19);
#line 518
      listAccumulate(& distanceList, (void *)(& m), sizeof(DistanceMeasure ));
    }
#line 520
    fclose(f);
#line 521
    tmp___21 = listToArray(& distanceList, sizeof(DistanceMeasure ), (size_t *)(& nDistances));
#line 521
    distances = (DistanceMeasure *)tmp___21;
  }
#line 528
  tmp___22 = malloc((unsigned long )nSubjects * sizeof(DistanceMeasure ));
#line 528
  toSort = (DistanceMeasure *)tmp___22;
#line 530
  j = 0;
#line 530
  while (j < nSubjects) {
#line 532
    (toSort + j)->subject = *(subjects + j);
#line 533
    (toSort + j)->distance = 0.0;
#line 534
    (toSort + j)->index = j;
#line 530
    j ++;
  }
#line 541
  j = 0;
#line 541
  while (j < nSubjects) {
#line 543
    if (0) {
#line 543
      __s1_len___0 = __builtin_strlen((char const   *)*(subjects + j));
#line 543
      __s2_len___0 = __builtin_strlen((char const   *)probe);
#line 543
      if (! ((size_t )((void const   *)(*(subjects + j) + 1)) - (size_t )((void const   *)*(subjects + j)) == 1UL)) {
#line 543
        goto _L___2;
      } else
#line 543
      if (__s1_len___0 >= 4UL) {
        _L___2: /* CIL Label */ 
#line 543
        if (! ((size_t )((void const   *)(probe + 1)) - (size_t )((void const   *)probe) == 1UL)) {
#line 543
          tmp___37 = 1;
        } else
#line 543
        if (__s2_len___0 >= 4UL) {
#line 543
          tmp___37 = 1;
        } else {
#line 543
          tmp___37 = 0;
        }
      } else {
#line 543
        tmp___37 = 0;
      }
#line 543
      if (tmp___37) {
#line 543
        tmp___32 = __builtin_strcmp((char const   *)*(subjects + j), (char const   *)probe);
#line 543
        tmp___36 = tmp___32;
      } else {
#line 543
        tmp___35 = __builtin_strcmp((char const   *)*(subjects + j), (char const   *)probe);
#line 543
        tmp___36 = tmp___35;
      }
    } else {
#line 543
      tmp___35 = __builtin_strcmp((char const   *)*(subjects + j), (char const   *)probe);
#line 543
      tmp___36 = tmp___35;
    }
#line 543
    if (tmp___36 == 0) {
#line 549
      (toSort + j)->distance = (double )3.40282347e+38F;
    } else
#line 551
    if ((unsigned long )distanceMatrix != (unsigned long )((void *)0)) {
#line 556
      (toSort + j)->distance = (double )3.40282347e+38F;
#line 558
      i = 0;
#line 558
      while (i < nDistances) {
#line 559
        if (0) {
#line 559
          __s1_len = __builtin_strlen((char const   *)(distances + i)->subject);
#line 559
          __s2_len = __builtin_strlen((char const   *)(toSort + j)->subject);
#line 559
          if (! ((size_t )((void const   *)((distances + i)->subject + 1)) - (size_t )((void const   *)(distances + i)->subject) == 1UL)) {
#line 559
            goto _L___0;
          } else
#line 559
          if (__s1_len >= 4UL) {
            _L___0: /* CIL Label */ 
#line 559
            if (! ((size_t )((void const   *)((toSort + j)->subject + 1)) - (size_t )((void const   *)(toSort + j)->subject) == 1UL)) {
#line 559
              tmp___29 = 1;
            } else
#line 559
            if (__s2_len >= 4UL) {
#line 559
              tmp___29 = 1;
            } else {
#line 559
              tmp___29 = 0;
            }
          } else {
#line 559
            tmp___29 = 0;
          }
#line 559
          if (tmp___29) {
#line 559
            tmp___24 = __builtin_strcmp((char const   *)(distances + i)->subject,
                                        (char const   *)(toSort + j)->subject);
#line 559
            tmp___28 = tmp___24;
          } else {
#line 559
            tmp___27 = __builtin_strcmp((char const   *)(distances + i)->subject,
                                        (char const   *)(toSort + j)->subject);
#line 559
            tmp___28 = tmp___27;
          }
        } else {
#line 559
          tmp___27 = __builtin_strcmp((char const   *)(distances + i)->subject, (char const   *)(toSort + j)->subject);
#line 559
          tmp___28 = tmp___27;
        }
#line 559
        if (tmp___28 == 0) {
#line 560
          (toSort + j)->distance = (distances + i)->distance;
        }
#line 558
        i ++;
      }
    } else {
#line 567
      tmp___30 = random();
#line 567
      (toSort + j)->distance = (double )tmp___30 / (double )2147483647;
    }
#line 541
    j ++;
  }
#line 574
  qsort((void *)toSort, (size_t )nSubjects, sizeof(DistanceMeasure ), & distanceMeasureComparator);
#line 578
  if ((unsigned long )indices == (unsigned long )((void *)0)) {
#line 579
    j = 0;
#line 579
    while (j < nSubjects) {
#line 580
      *(subjects + j) = (toSort + j)->subject;
#line 579
      j ++;
    }
  } else {
#line 583
    j = 0;
#line 583
    while (j < nSubjects) {
#line 584
      *(indices + j) = (toSort + j)->index;
#line 583
      j ++;
    }
  }
#line 589
  if (distanceMatrix) {
#line 591
    i = 0;
#line 591
    while (i < nDistances) {
#line 592
      free((void *)(distances + i)->subject);
#line 591
      i ++;
    }
#line 593
    free((void *)distances);
  }
#line 596
  free((void *)toSort);
#line 597
  return;
}
}
#line 618 "src/csuCommonFile.c"
void readFile(char const   *fname , int n , Matrix images ) 
{ 
  int i ;
  FILE *f ;
  char line[512] ;
  char imagetype[512] ;
  time_t tttt ;
  time_t tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___4 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___11 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  float flt ;
  int tmp___17 ;

  {
#line 630
  printf((char const   * __restrict  )"\nReading file: %s\n", fname);
#line 630
  fflush(stdout);
#line 633
  tmp___2 = autoFileLength(fname);
#line 633
  if (images->row_dim != tmp___2) {
#line 634
    tmp___1 = autoFileLength(fname);
#line 634
    if (! (tmp___1 < images->row_dim)) {
#line 634
      tmp = time((time_t *)0);
#line 634
      tttt = tmp;
#line 634
      tmp___0 = ctime((time_t const   *)(& tttt));
#line 634
      printf((char const   * __restrict  )"**DEBUG CHECK** Failed check (%s) \"%s\"\n             at [%s]<%s():line %u>\n             %s\n",
             "autoFileLength(fname) < images->row_dim", "File does not contian enough values",
             "src/csuCommonFile.c", "readFile", 634, tmp___0);
#line 634
      fflush(stdout);
#line 634
      exit(1);
    }
#line 635
    printf((char const   * __restrict  )"Warning: file length is greater than vector length.  Croping file...\n");
  }
#line 639
  f = fopen((char const   * __restrict  )fname, (char const   * __restrict  )"rb");
#line 640
  if (! f) {
#line 640
    __assert_fail("f", "src/csuCommonFile.c", 640U, "readFile");
  }
#line 644
  fgets((char * __restrict  )(line), 512, (FILE * __restrict  )f);
#line 646
  sscanf((char const   * __restrict  )(line), (char const   * __restrict  )"%s", imagetype);
#line 647
  if (0) {
#line 647
    __s1_len = __builtin_strlen((char const   *)(imagetype));
#line 647
    __s2_len = __builtin_strlen("CSU_SFI");
#line 647
    if (! ((size_t )((void const   *)(imagetype + 1)) - (size_t )((void const   *)(imagetype)) == 1UL)) {
#line 647
      goto _L___0;
    } else
#line 647
    if (__s1_len >= 4UL) {
      _L___0: /* CIL Label */ 
#line 647
      if (! ((size_t )((void const   *)("CSU_SFI" + 1)) - (size_t )((void const   *)"CSU_SFI") == 1UL)) {
#line 647
        tmp___9 = 1;
      } else
#line 647
      if (__s2_len >= 4UL) {
#line 647
        tmp___9 = 1;
      } else {
#line 647
        tmp___9 = 0;
      }
    } else {
#line 647
      tmp___9 = 0;
    }
#line 647
    if (tmp___9) {
#line 647
      tmp___4 = __builtin_strcmp((char const   *)(imagetype), "CSU_SFI");
#line 647
      tmp___8 = tmp___4;
    } else {
#line 647
      tmp___7 = __builtin_strcmp((char const   *)(imagetype), "CSU_SFI");
#line 647
      tmp___8 = tmp___7;
    }
  } else {
#line 647
    tmp___7 = __builtin_strcmp((char const   *)(imagetype), "CSU_SFI");
#line 647
    tmp___8 = tmp___7;
  }
#line 647
  if (tmp___8 == 0) {
#line 648
    rewind(f);
#line 650
    fgets((char * __restrict  )(imagetype), 512, (FILE * __restrict  )f);
  } else {
#line 647
    if (0) {
#line 647
      __s1_len___0 = __builtin_strlen((char const   *)(imagetype));
#line 647
      __s2_len___0 = __builtin_strlen("CSU_RASTER");
#line 647
      if (! ((size_t )((void const   *)(imagetype + 1)) - (size_t )((void const   *)(imagetype)) == 1UL)) {
#line 647
        goto _L___2;
      } else
#line 647
      if (__s1_len___0 >= 4UL) {
        _L___2: /* CIL Label */ 
#line 647
        if (! ((size_t )((void const   *)("CSU_RASTER" + 1)) - (size_t )((void const   *)"CSU_RASTER") == 1UL)) {
#line 647
          tmp___16 = 1;
        } else
#line 647
        if (__s2_len___0 >= 4UL) {
#line 647
          tmp___16 = 1;
        } else {
#line 647
          tmp___16 = 0;
        }
      } else {
#line 647
        tmp___16 = 0;
      }
#line 647
      if (tmp___16) {
#line 647
        tmp___11 = __builtin_strcmp((char const   *)(imagetype), "CSU_RASTER");
#line 647
        tmp___15 = tmp___11;
      } else {
#line 647
        tmp___14 = __builtin_strcmp((char const   *)(imagetype), "CSU_RASTER");
#line 647
        tmp___15 = tmp___14;
      }
    } else {
#line 647
      tmp___14 = __builtin_strcmp((char const   *)(imagetype), "CSU_RASTER");
#line 647
      tmp___15 = tmp___14;
    }
#line 647
    if (tmp___15 == 0) {
#line 648
      rewind(f);
#line 650
      fgets((char * __restrict  )(imagetype), 512, (FILE * __restrict  )f);
    } else {
#line 654
      rewind(f);
    }
  }
#line 680
  i = 0;
#line 680
  while (i < images->row_dim) {
#line 683
    readFloat(f, & flt);
#line 688
    tmp___17 = finite((double )n);
#line 688
    if (! tmp___17) {
#line 688
      __assert_fail("0 && \"infinite value\"", "src/csuCommonFile.c", 688U, "readFile");
    }
#line 692
    *(*(images->cols + n) + i) = (double )flt;
#line 680
    i ++;
  }
#line 696
  fclose(f);
#line 697
  return;
}
}
#line 720 "src/csuCommonFile.c"
int autoFileLength(char const   *imageName ) 
{ 
  FILE *f ;
  char imagetype[512] ;
  char line[512] ;
  int w ;
  int h ;
  int c ;
  struct stat filestatus ;
  time_t tttt ;
  time_t tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___3 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___10 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;

  {
#line 729
  f = fopen((char const   * __restrict  )imageName, (char const   * __restrict  )"r");
#line 730
  if (! f) {
#line 730
    printf((char const   * __restrict  )"Can\'t open %s\n", imageName);
#line 730
    exit(1);
  }
#line 732
  fgets((char * __restrict  )(line), 512, (FILE * __restrict  )f);
#line 734
  fclose(f);
#line 736
  sscanf((char const   * __restrict  )(line), (char const   * __restrict  )"%s", imagetype);
#line 738
  if (0) {
#line 738
    __s1_len = __builtin_strlen((char const   *)(imagetype));
#line 738
    __s2_len = __builtin_strlen("CSU_SFI");
#line 738
    if (! ((size_t )((void const   *)(imagetype + 1)) - (size_t )((void const   *)(imagetype)) == 1UL)) {
#line 738
      goto _L___0;
    } else
#line 738
    if (__s1_len >= 4UL) {
      _L___0: /* CIL Label */ 
#line 738
      if (! ((size_t )((void const   *)("CSU_SFI" + 1)) - (size_t )((void const   *)"CSU_SFI") == 1UL)) {
#line 738
        tmp___8 = 1;
      } else
#line 738
      if (__s2_len >= 4UL) {
#line 738
        tmp___8 = 1;
      } else {
#line 738
        tmp___8 = 0;
      }
    } else {
#line 738
      tmp___8 = 0;
    }
#line 738
    if (tmp___8) {
#line 738
      tmp___3 = __builtin_strcmp((char const   *)(imagetype), "CSU_SFI");
#line 738
      tmp___7 = tmp___3;
    } else {
#line 738
      tmp___6 = __builtin_strcmp((char const   *)(imagetype), "CSU_SFI");
#line 738
      tmp___7 = tmp___6;
    }
  } else {
#line 738
    tmp___6 = __builtin_strcmp((char const   *)(imagetype), "CSU_SFI");
#line 738
    tmp___7 = tmp___6;
  }
#line 738
  if (tmp___7 == 0) {
#line 741
    sscanf((char const   * __restrict  )(line), (char const   * __restrict  )"%s %d %d %d",
           imagetype, & w, & h, & c);
#line 742
    return ((w * h) * c);
  } else {
#line 738
    if (0) {
#line 738
      __s1_len___0 = __builtin_strlen((char const   *)(imagetype));
#line 738
      __s2_len___0 = __builtin_strlen("CSU_RASTER");
#line 738
      if (! ((size_t )((void const   *)(imagetype + 1)) - (size_t )((void const   *)(imagetype)) == 1UL)) {
#line 738
        goto _L___2;
      } else
#line 738
      if (__s1_len___0 >= 4UL) {
        _L___2: /* CIL Label */ 
#line 738
        if (! ((size_t )((void const   *)("CSU_RASTER" + 1)) - (size_t )((void const   *)"CSU_RASTER") == 1UL)) {
#line 738
          tmp___15 = 1;
        } else
#line 738
        if (__s2_len___0 >= 4UL) {
#line 738
          tmp___15 = 1;
        } else {
#line 738
          tmp___15 = 0;
        }
      } else {
#line 738
        tmp___15 = 0;
      }
#line 738
      if (tmp___15) {
#line 738
        tmp___10 = __builtin_strcmp((char const   *)(imagetype), "CSU_RASTER");
#line 738
        tmp___14 = tmp___10;
      } else {
#line 738
        tmp___13 = __builtin_strcmp((char const   *)(imagetype), "CSU_RASTER");
#line 738
        tmp___14 = tmp___13;
      }
    } else {
#line 738
      tmp___13 = __builtin_strcmp((char const   *)(imagetype), "CSU_RASTER");
#line 738
      tmp___14 = tmp___13;
    }
#line 738
    if (tmp___14 == 0) {
#line 741
      sscanf((char const   * __restrict  )(line), (char const   * __restrict  )"%s %d %d %d",
             imagetype, & w, & h, & c);
#line 742
      return ((w * h) * c);
    } else {
#line 748
      tmp = time((time_t *)0);
#line 748
      tttt = tmp;
#line 748
      tmp___0 = ctime((time_t const   *)(& tttt));
#line 748
      printf((char const   * __restrict  )"**DEBUG CHECK** Failed check (%s) \"%s\"\n             at [%s]<%s():line %u>\n             %s\n",
             "0", "Old nrm image format no longer supported", "src/csuCommonFile.c",
             "autoFileLength", 748, tmp___0);
#line 748
      fflush(stdout);
#line 748
      exit(1);
#line 749
      tmp___1 = stat((char const   * __restrict  )imageName, (struct stat * __restrict  )(& filestatus));
#line 749
      if (tmp___1) {
#line 750
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Error: Could not stat file %s\n",
                imageName);
#line 751
        exit(1);
      }
#line 753
      return ((int )(filestatus.st_size / 4L));
    }
  }
}
}
#line 768 "src/csuCommonFile.c"
ImageList *createILNode(char *filename ) 
{ 
  ImageList *node ;
  void *tmp ;
  char *tmp___5 ;

  {
#line 769
  tmp = malloc(sizeof(ImageList ));
#line 769
  node = (ImageList *)tmp;
#line 771
  tmp___5 = __strdup((char const   *)filename);
#line 771
  node->filename = tmp___5;
#line 773
  node->imageIndex = 0;
#line 774
  node->next_replicate = (struct image_list_node *)((void *)0);
#line 775
  node->next_subject = (struct image_list_node *)((void *)0);
#line 776
  return (node);
}
}
#line 792 "src/csuCommonFile.c"
ImageList *getImageNames(char *imageNamesFile , int *numImages ) 
{ 
  Tokenizer tok ;
  char *token ;
  FILE *ilf ;
  ImageList *subject ;
  ImageList *replicate ;
  ImageList *header ;
  int nImages ;
  time_t tttt ;
  time_t tmp ;
  char *tmp___0 ;
  time_t tttt___0 ;
  time_t tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
#line 797
  subject = (ImageList *)((void *)0);
#line 797
  header = (ImageList *)((void *)0);
#line 803
  if (2 <= debuglevel) {
#line 803
    tmp = time((time_t *)0);
#line 803
    tttt = tmp;
#line 803
    tmp___0 = ctime((time_t const   *)(& tttt));
#line 803
    printf((char const   * __restrict  )"**DEBUG %d** \"%s\" %s=\"%s\"\n             at [%s]<%s():line %u>\n             %s\n",
           2, "Get image Names from file", "imageNamesFile", imageNamesFile, "src/csuCommonFile.c",
           "getImageNames", 803, tmp___0);
#line 803
    fflush(stdout);
  }
#line 805
  ilf = fopen((char const   * __restrict  )imageNamesFile, (char const   * __restrict  )"r");
#line 806
  if (! ilf) {
#line 806
    tmp___1 = time((time_t *)0);
#line 806
    tttt___0 = tmp___1;
#line 806
    tmp___2 = ctime((time_t const   *)(& tttt___0));
#line 806
    printf((char const   * __restrict  )"**DEBUG CHECK** Failed check (%s) \"%s\"\n             at [%s]<%s():line %u>\n             %s\n",
           "ilf", "Problem opening image list file", "src/csuCommonFile.c", "getImageNames",
           806, tmp___2);
#line 806
    fflush(stdout);
#line 806
    exit(1);
  }
#line 808
  nImages = 0;
#line 809
  tokenizerInit(& tok, & tokenizerStreamReader, (void *)ilf);
#line 810
  while (1) {
#line 810
    tmp___5 = tokenizerEndOfFile(& tok);
#line 810
    if (tmp___5) {
#line 810
      break;
    }
#line 812
    token = tokenizerGetWord(& tok);
#line 813
    nImages ++;
#line 818
    if ((unsigned long )header == (unsigned long )((void *)0)) {
#line 819
      header = createILNode(token);
#line 819
      subject = header;
    } else {
#line 821
      subject->next_subject = createILNode(token);
#line 822
      subject = subject->next_subject;
    }
#line 825
    replicate = subject;
#line 827
    replicate->imageIndex = nImages - 1;
#line 830
    while (1) {
#line 830
      tmp___3 = tokenizerEndOfLine(& tok);
#line 830
      if (tmp___3) {
#line 830
        break;
      } else {
#line 830
        tmp___4 = tokenizerEndOfFile(& tok);
#line 830
        if (tmp___4) {
#line 830
          break;
        }
      }
#line 832
      token = tokenizerGetWord(& tok);
#line 833
      nImages ++;
#line 835
      replicate->next_replicate = createILNode(token);
#line 836
      replicate = replicate->next_replicate;
#line 838
      replicate->imageIndex = nImages - 1;
    }
  }
#line 843
  fclose(ilf);
#line 845
  if (numImages) {
#line 852
    *numImages = nImages;
  }
#line 857
  return (header);
}
}
#line 866 "src/csuCommonFile.c"
Matrix readImages(char *imageNamesFile , char *imageDirectory , int *numPixels , int *numImages ,
                  int *numSubjects , ImageList **srt ) 
{ 
  int i ;
  Matrix images ;
  ImageList *subject ;
  ImageList *replicate ;
  time_t tttt ;
  time_t tmp ;
  char *tmp___0 ;
  time_t tttt___0 ;
  time_t tmp___1 ;
  char *tmp___2 ;
  time_t tttt___1 ;
  time_t tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  time_t tttt___2 ;
  time_t tmp___6 ;
  char *tmp___7 ;
  time_t tttt___3 ;
  time_t tmp___8 ;
  char *tmp___9 ;
  time_t tttt___4 ;
  time_t tmp___10 ;
  char *tmp___11 ;
  int tmp___12 ;
  char *tmp___13 ;

  {
#line 871
  if (1 <= debuglevel) {
#line 871
    tmp = time((time_t *)0);
#line 871
    tttt = tmp;
#line 871
    tmp___0 = ctime((time_t const   *)(& tttt));
#line 871
    printf((char const   * __restrict  )"**DEBUG %d** \"%s\"\n             at [%s]<%s():line %u>\n             %s\n",
           1, "Reading training file names from file", "src/csuCommonFile.c", "readImages",
           871, tmp___0);
#line 871
    fflush(stdout);
  }
#line 876
  *srt = getImageNames(imageNamesFile, numImages);
#line 879
  if (! *srt) {
#line 879
    tmp___1 = time((time_t *)0);
#line 879
    tttt___0 = tmp___1;
#line 879
    tmp___2 = ctime((time_t const   *)(& tttt___0));
#line 879
    printf((char const   * __restrict  )"**DEBUG CHECK** Failed check (%s) \"%s\"\n             at [%s]<%s():line %u>\n             %s\n",
           "*srt", "Error: header no imagenames found in file image list file", "src/csuCommonFile.c",
           "readImages", 879, tmp___2);
#line 879
    fflush(stdout);
#line 879
    exit(1);
  }
#line 883
  if (1 <= debuglevel) {
#line 883
    tmp___3 = time((time_t *)0);
#line 883
    tttt___1 = tmp___3;
#line 883
    tmp___4 = ctime((time_t const   *)(& tttt___1));
#line 883
    printf((char const   * __restrict  )"**DEBUG %d** \"%s\"\n             at [%s]<%s():line %u>\n             %s\n",
           1, "Autodetecting number of pixels, i.e. vector length based on the size of image 0.",
           "src/csuCommonFile.c", "readImages", 883, tmp___4);
#line 883
    fflush(stdout);
  }
#line 884
  tmp___5 = makePath((char const   *)imageDirectory, (char const   *)(*srt)->filename);
#line 884
  *numPixels = autoFileLength((char const   *)tmp___5);
#line 885
  if (1 <= debuglevel) {
#line 885
    tmp___6 = time((time_t *)0);
#line 885
    tttt___2 = tmp___6;
#line 885
    tmp___7 = ctime((time_t const   *)(& tttt___2));
#line 885
    printf((char const   * __restrict  )"**DEBUG %d** \"%s\" %s=%d\n             at [%s]<%s():line %u>\n             %s\n",
           1, "Vector length", "* numPixels", *numPixels, "src/csuCommonFile.c", "readImages",
           885, tmp___7);
#line 885
    fflush(stdout);
  }
#line 886
  if (! (*numPixels > 0)) {
#line 886
    tmp___8 = time((time_t *)0);
#line 886
    tttt___3 = tmp___8;
#line 886
    tmp___9 = ctime((time_t const   *)(& tttt___3));
#line 886
    printf((char const   * __restrict  )"**DEBUG CHECK** Failed check (%s) \"%s\"\n             at [%s]<%s():line %u>\n             %s\n",
           "*numPixels > 0", "Error positive value required for a Vector Length",
           "src/csuCommonFile.c", "readImages", 886, tmp___9);
#line 886
    fflush(stdout);
#line 886
    exit(1);
  }
#line 889
  if (1 <= debuglevel) {
#line 889
    tmp___10 = time((time_t *)0);
#line 889
    tttt___4 = tmp___10;
#line 889
    tmp___11 = ctime((time_t const   *)(& tttt___4));
#line 889
    printf((char const   * __restrict  )"**DEBUG %d** \"%s\"\n             at [%s]<%s():line %u>\n             %s\n",
           1, "Allocating image matrix", "src/csuCommonFile.c", "readImages", 889,
           tmp___11);
#line 889
    fflush(stdout);
  }
#line 890
  images = makeMatrix(*numPixels, *numImages);
#line 892
  i = 0;
#line 893
  *numSubjects = 0;
#line 894
  subject = *srt;
#line 894
  while (subject) {
#line 895
    replicate = subject;
#line 895
    while (replicate) {
#line 896
      if (debuglevel > 0) {
#line 897
        printf((char const   * __restrict  )"%s ", replicate->filename);
      }
#line 898
      replicate->imageIndex = i;
#line 899
      tmp___12 = i;
#line 899
      i ++;
#line 899
      tmp___13 = makePath((char const   *)imageDirectory, (char const   *)replicate->filename);
#line 899
      readFile((char const   *)tmp___13, tmp___12, images);
#line 895
      replicate = replicate->next_replicate;
    }
#line 901
    if (debuglevel > 0) {
#line 902
      printf((char const   * __restrict  )"\n");
    }
#line 903
    (*numSubjects) ++;
#line 894
    subject = subject->next_subject;
  }
#line 906
  return (images);
}
}
#line 917 "src/csuCommonFile.c"
int numImageInImageList(ImageList *srt ) 
{ 
  int num ;
  ImageList *subject ;
  ImageList *replicate ;

  {
#line 918
  num = 0;
#line 921
  subject = srt;
#line 921
  while (subject) {
#line 922
    replicate = subject;
#line 922
    while (replicate) {
#line 923
      num ++;
#line 922
      replicate = replicate->next_replicate;
    }
#line 921
    subject = subject->next_subject;
  }
#line 926
  return (num);
}
}
#line 935 "src/csuCommonFile.c"
void freeImageNames(ImageList *srt ) 
{ 


  {
#line 937
  return;
}
}
#line 951 "src/csuCommonFile.c"
float *readFeretRaster(char const   *fn , int numpix ) 
{ 
  FILE *fp ;
  float *data ;
  void *tmp ;
  time_t tttt ;
  time_t tmp___0 ;
  char *tmp___1 ;
  size_t tmp___2 ;
  int tmp___3 ;

  {
#line 956
  fp = fopen((char const   * __restrict  )fn, (char const   * __restrict  )"rb");
#line 957
  if ((unsigned long )fp == (unsigned long )((void *)0)) {
#line 959
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"failed to open %s",
            fn);
#line 960
    exit(0);
  }
#line 963
  tmp = malloc(sizeof(float ) * (unsigned long )numpix);
#line 963
  data = (float *)tmp;
#line 964
  if (! data) {
#line 964
    tmp___0 = time((time_t *)0);
#line 964
    tttt = tmp___0;
#line 964
    tmp___1 = ctime((time_t const   *)(& tttt));
#line 964
    printf((char const   * __restrict  )"**DEBUG CHECK** Failed check (%s) \"%s\"\n             at [%s]<%s():line %u>\n             %s\n",
           "data", "malloc failed", "src/csuCommonFile.c", "readFeretRaster", 964,
           tmp___1);
#line 964
    fflush(stdout);
#line 964
    exit(1);
  }
#line 966
  tmp___2 = fread((void * __restrict  )data, sizeof(float ), (size_t )numpix, (FILE * __restrict  )fp);
#line 966
  if (! tmp___2) {
#line 968
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"fread in readFeretRaster failed");
#line 969
    exit(0);
  }
#line 972
  tmp___3 = isMachineLittleEndian();
#line 972
  if (tmp___3) {
#line 972
    byteswap_4((void *)data, (int const   )numpix);
  }
#line 974
  fclose(fp);
#line 975
  return (data);
}
}
#line 986 "src/csuCommonFile.c"
float *writeFeretRaster(char const   *fn , float *data , int numpix ) 
{ 
  FILE *fp ;
  int tmp ;
  size_t tmp___0 ;

  {
#line 990
  fp = fopen((char const   * __restrict  )fn, (char const   * __restrict  )"wb");
#line 991
  if ((unsigned long )fp == (unsigned long )((void *)0)) {
#line 993
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"failed to open %s",
            fn);
#line 994
    exit(0);
  }
#line 997
  tmp = isMachineLittleEndian();
#line 997
  if (tmp) {
#line 997
    byteswap_4((void *)data, (int const   )numpix);
  }
#line 999
  tmp___0 = fwrite((void const   * __restrict  )data, sizeof(float ), (size_t )numpix,
                   (FILE * __restrict  )fp);
#line 999
  if ((size_t )numpix != tmp___0) {
#line 1001
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"fwrite in writeFeretRaster failed");
#line 1002
    exit(0);
  }
#line 1005
  fclose(fp);
#line 1006
  return (data);
}
}
#line 1018 "src/csuCommonFile.c"
unsigned char *readImagePGM(char const   *filename , int *w , int *h , int verbose ) 
{ 
  int width ;
  int height ;
  int max ;
  int i ;
  int val ;
  char fchar ;
  char line[100] ;
  char ftype[16] ;
  FILE *infile ;
  unsigned char *im ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___0 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  void *tmp___6 ;
  time_t tttt ;
  time_t tmp___7 ;
  char *tmp___8 ;

  {
#line 1029
  if (verbose) {
#line 1029
    fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )"Going to open file %s\n",
            filename);
  }
#line 1030
  infile = fopen((char const   * __restrict  )filename, (char const   * __restrict  )"rb");
#line 1031
  if ((unsigned long )infile == (unsigned long )((void *)0)) {
#line 1033
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"failed to open %s",
            filename);
#line 1034
    exit(0);
  }
#line 1036
  fgets((char * __restrict  )(line), 100, (FILE * __restrict  )infile);
#line 1037
  sscanf((char const   * __restrict  )(line), (char const   * __restrict  )"%s", ftype);
#line 1038
  if (verbose) {
#line 1038
    fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )"File Type is %s.\n",
            ftype);
  }
#line 1040
  if (0) {
#line 1040
    __s1_len = __builtin_strlen((char const   *)(ftype));
#line 1040
    __s2_len = __builtin_strlen("P5");
#line 1040
    if (! ((size_t )((void const   *)(ftype + 1)) - (size_t )((void const   *)(ftype)) == 1UL)) {
#line 1040
      goto _L___0;
    } else
#line 1040
    if (__s1_len >= 4UL) {
      _L___0: /* CIL Label */ 
#line 1040
      if (! ((size_t )((void const   *)("P5" + 1)) - (size_t )((void const   *)"P5") == 1UL)) {
#line 1040
        tmp___5 = 1;
      } else
#line 1040
      if (__s2_len >= 4UL) {
#line 1040
        tmp___5 = 1;
      } else {
#line 1040
        tmp___5 = 0;
      }
    } else {
#line 1040
      tmp___5 = 0;
    }
#line 1040
    if (tmp___5) {
#line 1040
      tmp___0 = __builtin_strcmp((char const   *)(ftype), "P5");
#line 1040
      tmp___4 = tmp___0;
    } else {
#line 1040
      tmp___3 = __builtin_strcmp((char const   *)(ftype), "P5");
#line 1040
      tmp___4 = tmp___3;
    }
  } else {
#line 1040
    tmp___3 = __builtin_strcmp((char const   *)(ftype), "P5");
#line 1040
    tmp___4 = tmp___3;
  }
#line 1040
  if (tmp___4 != 0) {
#line 1042
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Currently only binary pgm files, type P5, supported");
#line 1043
    exit(0);
  }
#line 1048
  fchar = (char )'#';
#line 1049
  while ((int )fchar == 35) {
#line 1050
    fgets((char * __restrict  )(line), 100, (FILE * __restrict  )infile);
#line 1051
    sscanf((char const   * __restrict  )(line), (char const   * __restrict  )" %c",
           & fchar);
  }
#line 1053
  if (verbose) {
#line 1053
    fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )"Second non-comment line of image file %s.\n",
            line);
  }
#line 1054
  sscanf((char const   * __restrict  )(line), (char const   * __restrict  )" %d %d",
         & width, & height);
#line 1055
  *w = width;
#line 1056
  *h = height;
#line 1057
  if (verbose) {
#line 1057
    fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )"The width,  height and size are: %d %d %d\n",
            width, height, width * height);
  }
#line 1061
  fchar = (char )'#';
#line 1062
  while ((int )fchar == 35) {
#line 1063
    fgets((char * __restrict  )(line), 100, (FILE * __restrict  )infile);
#line 1064
    sscanf((char const   * __restrict  )(line), (char const   * __restrict  )" %c",
           & fchar);
  }
#line 1066
  sscanf((char const   * __restrict  )(line), (char const   * __restrict  )"%d", & max);
#line 1067
  if (verbose) {
#line 1067
    fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )"The max value for the pixels is: %d\n",
            max);
  }
#line 1068
  if (! (max == 255)) {
#line 1069
    fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )"readImagePGM: Warning, max value %d for pixels in image %s is not 255\n",
            max, filename);
  }
#line 1072
  tmp___6 = malloc((sizeof(unsigned char ) * (unsigned long )width) * (unsigned long )height);
#line 1072
  im = (unsigned char *)tmp___6;
#line 1073
  if (! im) {
#line 1073
    tmp___7 = time((time_t *)0);
#line 1073
    tttt = tmp___7;
#line 1073
    tmp___8 = ctime((time_t const   *)(& tttt));
#line 1073
    printf((char const   * __restrict  )"**DEBUG CHECK** Failed check (%s) \"%s\"\n             at [%s]<%s():line %u>\n             %s\n",
           "im", "malloc failed", "src/csuCommonFile.c", "readImagePGM", 1073, tmp___8);
#line 1073
    fflush(stdout);
#line 1073
    exit(1);
  }
#line 1075
  i = 0;
#line 1076
  val = fgetc(infile);
#line 1077
  while (1) {
#line 1077
    if (! (val == -1)) {
#line 1077
      if (! (i < width * height)) {
#line 1077
        break;
      }
    } else {
#line 1077
      break;
    }
#line 1078
    *(im + i) = (unsigned char )val;
#line 1079
    i ++;
#line 1080
    val = fgetc(infile);
  }
#line 1082
  if (verbose) {
#line 1082
    fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )"Read in %d Pixel Values\n",
            i);
  }
#line 1083
  fclose(infile);
#line 1084
  return (im);
}
}
#line 1096 "src/csuCommonFile.c"
void writeImagePGM(char const   *fn , float *data , int numpix , int w , int h ) 
{ 
  float min ;
  float max ;
  float sum ;
  float scale ;
  int i ;
  int val ;
  FILE *fp ;

  {
#line 1102
  min = *(data + 0);
#line 1103
  max = *(data + 0);
#line 1104
  sum = (float )0.0;
#line 1106
  i = 1;
#line 1106
  while (i < numpix) {
#line 1107
    if (*(data + i) < min) {
#line 1107
      min = *(data + i);
    }
#line 1108
    if (*(data + i) > max) {
#line 1108
      max = *(data + i);
    }
#line 1109
    sum += *(data + i);
#line 1106
    i ++;
  }
#line 1112
  scale = (float )(255.0 / (double )(max - min));
#line 1114
  fp = fopen((char const   * __restrict  )fn, (char const   * __restrict  )"wb");
#line 1115
  if ((unsigned long )fp == (unsigned long )((void *)0)) {
#line 1117
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"failed to open %s",
            fn);
#line 1118
    exit(0);
  }
#line 1121
  fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"P5\n");
#line 1122
  fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"%d %d\n", w, h);
#line 1123
  fprintf((FILE * __restrict  )fp, (char const   * __restrict  )"255\n");
#line 1124
  i = 0;
#line 1124
  while (i < numpix) {
#line 1125
    val = (int )((*(data + i) - min) * scale);
#line 1126
    fputc(val, fp);
#line 1124
    i ++;
  }
#line 1128
  fclose(fp);
#line 1129
  return;
}
}
#line 1 "csuCommonUtil.o"
#pragma merger("0","/tmp/cil-pSTaIGw6.i","-O3,-Wall")
#line 374 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) rand)(void) ;
#line 259 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strrchr)(char const   *__s ,
                                                                                                int __c )  __attribute__((__pure__)) ;
#line 395
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 100 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h"
extern  __attribute__((__nothrow__)) double ( __attribute__((__leaf__)) exp)(double __x ) ;
#line 154
extern  __attribute__((__nothrow__)) double ( __attribute__((__leaf__)) pow)(double __x ,
                                                                             double __y ) ;
#line 150 "/usr/include/x86_64-linux-gnu/bits/mathinline.h"
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__, __always_inline__)) __signbitl)(long double __x )  __attribute__((__const__)) ;
#line 150 "/usr/include/x86_64-linux-gnu/bits/mathinline.h"
__inline extern int ( __attribute__((__leaf__, __always_inline__)) __signbitl)(long double __x ) 
{ 
  union __anonunion___u_26___1 __u ;

  {
#line 153
  __u.__l = __x;
#line 154
  return ((__u.__i[2] & 32768) != 0);
}
}
#line 139 "src/csuCommonUtil.h"
double probNormal(double a ) ;
#line 144
int *shuffle(int size ) ;
#line 204
void tokenizerTestSuite(Tokenizer *tok ) ;
#line 210
int tokenizerStringReader(char *buff , size_t nChars , void **arg ) ;
#line 220
void *listToNullTerminatedArray(void **base , size_t size , size_t *nelems ) ;
#line 224
int *shuffledNumbers(int max ) ;
#line 228
void writeProgress(char *what , int value , int max ) ;
#line 239
char *strconc(char const   *s1 , char const   *s2 ) ;
#line 240
char *strclone(char const   *si ) ;
#line 241
char *strlower(char *x ) ;
#line 242
char *strupper(char *x ) ;
#line 243
char *newextlong(char **filename , char const   *extension ) ;
#line 101 "src/csuCommonUtil.c"
double probNormal(double a ) 
{ 
  int i ;
  double j ;
  double sum ;
  double term ;
  double tmp ;
  double tmp___0 ;
  double tmp___1 ;
  double tmp___2 ;

  {
#line 104
  j = (double )1;
#line 105
  sum = (double )0;
#line 107
  i = 1;
#line 107
  while (i < 200) {
#line 108
    j *= (double )i;
#line 109
    tmp = pow(a, (double )i);
#line 109
    term = tmp / j;
#line 110
    sum += term;
#line 107
    i += 2;
  }
#line 113
  tmp___0 = pow(a, (double )2);
#line 113
  tmp___1 = exp(- tmp___0 / (double )2);
#line 113
  tmp___2 = sqrt((double )2 * 3.141592654);
#line 113
  return ((sum * tmp___1) / tmp___2 + 0.5);
}
}
#line 119 "src/csuCommonUtil.c"
int *shuffle(int size ) 
{ 
  int *vec ;
  int *temp ;
  int bound ;
  int place ;
  int i ;
  int j ;
  void *tmp ;
  void *tmp___0 ;
  int tmp___1 ;

  {
#line 125
  tmp = malloc(sizeof(int ) * (unsigned long )size);
#line 125
  vec = (int *)tmp;
#line 126
  if (! vec) {
#line 126
    __assert_fail("vec", "src/csuCommonUtil.c", 126U, "shuffle");
  }
#line 127
  tmp___0 = malloc(sizeof(int ) * (unsigned long )size);
#line 127
  temp = (int *)tmp___0;
#line 128
  if (! temp) {
#line 128
    __assert_fail("temp", "src/csuCommonUtil.c", 128U, "shuffle");
  }
#line 129
  i = 0;
#line 129
  while (i < size) {
#line 130
    *(temp + i) = i;
#line 129
    i ++;
  }
#line 138
  bound = size;
#line 139
  i = 0;
#line 139
  while (i < size) {
#line 143
    tmp___1 = rand();
#line 143
    place = (int )(((double )bound * (double )tmp___1) / ((double )2147483647 + 1.0));
#line 145
    *(vec + i) = *(temp + place);
#line 146
    j = place;
#line 146
    while (j < bound - 1) {
#line 147
      *(temp + j) = *(temp + (j + 1));
#line 146
      j ++;
    }
#line 149
    bound --;
#line 139
    i ++;
  }
#line 151
  free((void *)temp);
#line 152
  return (vec);
}
}
#line 155 "src/csuCommonUtil.c"
void *csu_allocate(char const   *type , int sof , int num , char const   *file , int line ) 
{ 
  void *tmp ;
  void *tmp___0 ;

  {
#line 156
  tmp___0 = malloc((size_t )(sof * num));
#line 156
  tmp = tmp___0;
#line 157
  if ((unsigned long )tmp == (unsigned long )((void *)0)) {
#line 158
    printf((char const   * __restrict  )"ERROR: failed to allocate memory.\n       type: %s - number: %d\n       in <%s:%d>\n",
           type, num, file, line);
#line 161
    exit(1);
  }
#line 163
  return (tmp);
}
}
#line 180 "src/csuCommonUtil.c"
void tokenizerInit(Tokenizer *tok , int (*source)(char *buff , size_t nChars , void **arg ) ,
                   void *arg ) 
{ 


  {
#line 183
  tok->i_ptr = tok->in_buff;
#line 184
  tok->endOfLine = 0;
#line 185
  tok->endOfFile = 0;
#line 186
  tok->state = 0;
#line 187
  tok->availChars = 0;
#line 188
  tok->dataSource = source;
#line 189
  tok->dataSrcArg = arg;
#line 190
  return;
}
}
#line 196 "src/csuCommonUtil.c"
int tokenizerStreamReader(char *buff , size_t nChars , void **arg ) 
{ 
  size_t tmp ;

  {
#line 199
  tmp = fread((void * __restrict  )buff, sizeof(char ), nChars, (FILE * __restrict  )((FILE *)*arg));
#line 199
  return ((int )tmp);
}
}
#line 206 "src/csuCommonUtil.c"
int tokenizerStringReader(char *buff , size_t nChars , void **arg ) 
{ 
  char *c ;
  int n ;
  char *tmp ;
  char *tmp___0 ;

  {
#line 209
  c = (char *)*arg;
#line 212
  n = 0;
#line 212
  while (1) {
#line 212
    if ((size_t )n < nChars) {
#line 212
      if (! ((int )*c != 0)) {
#line 212
        break;
      }
    } else {
#line 212
      break;
    }
#line 213
    tmp = buff;
#line 213
    buff ++;
#line 213
    tmp___0 = c;
#line 213
    c ++;
#line 213
    *tmp = *tmp___0;
#line 212
    n ++;
  }
#line 215
  *arg = (void *)c;
#line 216
  return (n);
}
}
#line 273 "src/csuCommonUtil.c"
static int stateTransitionTable[7][5]  = { {        6,        0,        0,        1, 
            2}, 
   {        6,        1,        0,        1, 
            1}, 
   {        6,        3,        4,        5, 
            2}, 
   {        6,        3,        4,        5, 
            2}, 
   {        6,        4,        4,        5, 
            2}, 
   {        6,        5,        4,        5, 
            5}, 
   {        6,        6,        6,        6, 
            6}};
#line 299 "src/csuCommonUtil.c"
static int stateActionTable[7][5]  = { {        6,        0,        0,        0, 
            1}, 
   {        6,        0,        0,        0, 
            0}, 
   {        14,        0,        0,        0, 
            1}, 
   {        14,        0,        0,        0, 
            3}, 
   {        14,        0,        0,        0, 
            11}, 
   {        14,        0,        0,        0, 
            0}, 
   {        6,        6,        6,        6, 
            6}};
#line 235 "src/csuCommonUtil.c"
char *tokenizerGetWord(Tokenizer *tok ) 
{ 
  char c ;
  int charClass ;
  int emitWord ;
  int saveChar ;
  char *tmp ;

  {
#line 311
  tok->w_ptr = tok->word_buff;
#line 316
  while (1) {
#line 320
    if (tok->availChars == 0) {
#line 322
      tok->availChars = (*(tok->dataSource))(tok->in_buff, sizeof(tok->in_buff) / sizeof(tok->in_buff[0]),
                                             & tok->dataSrcArg);
#line 325
      tok->i_ptr = tok->in_buff;
    }
#line 330
    c = *(tok->i_ptr);
#line 332
    if (tok->availChars == 0) {
#line 333
      charClass = 0;
    } else
#line 334
    if ((int )c == 32) {
#line 335
      charClass = 1;
    } else
#line 334
    if ((int )c == 9) {
#line 335
      charClass = 1;
    } else
#line 336
    if ((int )c == 10) {
#line 337
      charClass = 2;
    } else
#line 336
    if ((int )c == 13) {
#line 337
      charClass = 2;
    } else
#line 338
    if ((int )c == 35) {
#line 339
      charClass = 3;
    } else {
#line 341
      charClass = 4;
    }
#line 345
    saveChar = stateActionTable[tok->state][charClass] & 1;
#line 346
    emitWord = stateActionTable[tok->state][charClass] & 2;
#line 347
    tok->endOfFile = stateActionTable[tok->state][charClass] & 4;
#line 348
    tok->endOfLine = stateActionTable[tok->state][charClass] & 8;
#line 349
    tok->state = stateTransitionTable[tok->state][charClass];
#line 355
    if (emitWord) {
#line 356
      break;
    }
#line 361
    if (saveChar) {
#line 362
      tmp = tok->w_ptr;
#line 362
      (tok->w_ptr) ++;
#line 362
      *tmp = c;
    }
#line 366
    (tok->i_ptr) ++;
#line 367
    (tok->availChars) --;
  }
#line 373
  *(tok->w_ptr) = (char )'\000';
#line 374
  return (tok->word_buff);
}
}
#line 379 "src/csuCommonUtil.c"
int tokenizerEndOfFile(Tokenizer *tok ) 
{ 


  {
#line 382
  return (tok->endOfFile);
}
}
#line 389 "src/csuCommonUtil.c"
int tokenizerEndOfLine(Tokenizer *tok ) 
{ 


  {
#line 392
  return (tok->endOfLine);
}
}
#line 400 "src/csuCommonUtil.c"
void tokenizerTestSuite(Tokenizer *tok ) 
{ 
  char *msg ;
  char *test ;
  time_t tttt ;
  time_t tmp ;
  char *tmp___0 ;
  size_t __s1_len ;
  size_t __s2_len ;
  char *tmp___6 ;
  int tmp___7 ;
  char *tmp___24 ;
  int tmp___25 ;
  int tmp___26 ;
  char *tmp___28 ;
  char *tmp___29 ;
  char *tmp___30 ;
  int tmp___31 ;
  time_t tttt___0 ;
  time_t tmp___32 ;
  char *tmp___33 ;
  int tmp___34 ;
  time_t tttt___1 ;
  time_t tmp___35 ;
  char *tmp___36 ;
  int tmp___37 ;
  time_t tttt___2 ;
  time_t tmp___38 ;
  char *tmp___39 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  char *tmp___45 ;
  int tmp___46 ;
  char *tmp___63 ;
  int tmp___64 ;
  int tmp___65 ;
  char *tmp___67 ;
  char *tmp___68 ;
  char *tmp___69 ;
  int tmp___70 ;
  time_t tttt___3 ;
  time_t tmp___71 ;
  char *tmp___72 ;
  int tmp___73 ;
  time_t tttt___4 ;
  time_t tmp___74 ;
  char *tmp___75 ;
  int tmp___76 ;
  time_t tttt___5 ;
  time_t tmp___77 ;
  char *tmp___78 ;
  size_t __s1_len___1 ;
  size_t __s2_len___1 ;
  char *tmp___84 ;
  int tmp___85 ;
  char *tmp___102 ;
  int tmp___103 ;
  int tmp___104 ;
  char *tmp___106 ;
  char *tmp___107 ;
  char *tmp___108 ;
  int tmp___109 ;
  time_t tttt___6 ;
  time_t tmp___110 ;
  char *tmp___111 ;
  int tmp___112 ;
  time_t tttt___7 ;
  time_t tmp___113 ;
  char *tmp___114 ;
  int tmp___115 ;
  time_t tttt___8 ;
  time_t tmp___116 ;
  char *tmp___117 ;
  size_t __s1_len___2 ;
  size_t __s2_len___2 ;
  char *tmp___123 ;
  int tmp___124 ;
  char *tmp___141 ;
  int tmp___142 ;
  int tmp___143 ;
  char *tmp___145 ;
  char *tmp___146 ;
  char *tmp___147 ;
  int tmp___148 ;
  time_t tttt___9 ;
  time_t tmp___149 ;
  char *tmp___150 ;
  int tmp___151 ;
  time_t tttt___10 ;
  time_t tmp___152 ;
  char *tmp___153 ;
  int tmp___154 ;
  time_t tttt___11 ;
  time_t tmp___155 ;
  char *tmp___156 ;
  size_t __s1_len___3 ;
  size_t __s2_len___3 ;
  char *tmp___162 ;
  int tmp___163 ;
  char *tmp___180 ;
  int tmp___181 ;
  int tmp___182 ;
  char *tmp___184 ;
  char *tmp___185 ;
  char *tmp___186 ;
  int tmp___187 ;
  time_t tttt___12 ;
  time_t tmp___188 ;
  char *tmp___189 ;
  int tmp___190 ;
  time_t tttt___13 ;
  time_t tmp___191 ;
  char *tmp___192 ;
  int tmp___193 ;
  time_t tttt___14 ;
  time_t tmp___194 ;
  char *tmp___195 ;
  size_t __s1_len___4 ;
  size_t __s2_len___4 ;
  char *tmp___201 ;
  int tmp___202 ;
  char *tmp___219 ;
  int tmp___220 ;
  int tmp___221 ;
  char *tmp___223 ;
  char *tmp___224 ;
  char *tmp___225 ;
  int tmp___226 ;
  time_t tttt___15 ;
  time_t tmp___227 ;
  char *tmp___228 ;
  int tmp___229 ;
  time_t tttt___16 ;
  time_t tmp___230 ;
  char *tmp___231 ;
  int tmp___232 ;

  {
#line 403
  msg = (char *)"Tokenizer test failed";
#line 404
  test = (char *)"Hello, World!";
#line 406
  tokenizerInit(tok, & tokenizerStringReader, (void *)test);
#line 407
  if (0) {
#line 407
    __s1_len = __builtin_strlen("Hello,");
#line 407
    tmp___28 = tokenizerGetWord(tok);
#line 407
    __s2_len = __builtin_strlen((char const   *)tmp___28);
#line 407
    if (! ((size_t )((void const   *)("Hello," + 1)) - (size_t )((void const   *)"Hello,") == 1UL)) {
#line 407
      goto _L___0;
    } else
#line 407
    if (__s1_len >= 4UL) {
      _L___0: /* CIL Label */ 
#line 407
      tmp___29 = tokenizerGetWord(tok);
#line 407
      tmp___30 = tokenizerGetWord(tok);
#line 407
      if ((size_t )((void const   *)(tmp___29 + 1)) - (size_t )((void const   *)tmp___30) == 1UL) {
#line 407
        if (__s2_len >= 4UL) {
#line 407
          tmp___31 = 1;
        } else {
#line 407
          tmp___31 = 0;
        }
      } else {
#line 407
        tmp___31 = 1;
      }
    } else {
#line 407
      tmp___31 = 0;
    }
#line 407
    if (tmp___31) {
#line 407
      tmp___6 = tokenizerGetWord(tok);
#line 407
      tmp___7 = __builtin_strcmp("Hello,", (char const   *)tmp___6);
#line 407
      tmp___26 = tmp___7;
    } else {
#line 407
      tmp___24 = tokenizerGetWord(tok);
#line 407
      tmp___25 = __builtin_strcmp("Hello,", (char const   *)tmp___24);
#line 407
      tmp___26 = tmp___25;
    }
  } else {
#line 407
    tmp___24 = tokenizerGetWord(tok);
#line 407
    tmp___25 = __builtin_strcmp("Hello,", (char const   *)tmp___24);
#line 407
    tmp___26 = tmp___25;
  }
#line 407
  if (tmp___26) {
#line 407
    tmp = time((time_t *)0);
#line 407
    tttt = tmp;
#line 407
    tmp___0 = ctime((time_t const   *)(& tttt));
#line 407
    printf((char const   * __restrict  )"**DEBUG CHECK** Failed check (%s) \"%s\"\n             at [%s]<%s():line %u>\n             %s\n",
           "!strcmp (\"Hello,\", tokenizerGetWord (tok))", msg, "src/csuCommonUtil.c",
           "tokenizerTestSuite", 407, tmp___0);
#line 407
    fflush(stdout);
#line 407
    exit(1);
  }
#line 408
  tmp___34 = tokenizerEndOfLine(tok);
#line 408
  if (tmp___34) {
#line 408
    tmp___32 = time((time_t *)0);
#line 408
    tttt___0 = tmp___32;
#line 408
    tmp___33 = ctime((time_t const   *)(& tttt___0));
#line 408
    printf((char const   * __restrict  )"**DEBUG CHECK** Failed check (%s) \"%s\"\n             at [%s]<%s():line %u>\n             %s\n",
           "!tokenizerEndOfLine (tok)", msg, "src/csuCommonUtil.c", "tokenizerTestSuite",
           408, tmp___33);
#line 408
    fflush(stdout);
#line 408
    exit(1);
  }
#line 409
  tmp___37 = tokenizerEndOfFile(tok);
#line 409
  if (tmp___37) {
#line 409
    tmp___35 = time((time_t *)0);
#line 409
    tttt___1 = tmp___35;
#line 409
    tmp___36 = ctime((time_t const   *)(& tttt___1));
#line 409
    printf((char const   * __restrict  )"**DEBUG CHECK** Failed check (%s) \"%s\"\n             at [%s]<%s():line %u>\n             %s\n",
           "!tokenizerEndOfFile (tok)", msg, "src/csuCommonUtil.c", "tokenizerTestSuite",
           409, tmp___36);
#line 409
    fflush(stdout);
#line 409
    exit(1);
  }
#line 410
  if (0) {
#line 410
    __s1_len___0 = __builtin_strlen("World!");
#line 410
    tmp___67 = tokenizerGetWord(tok);
#line 410
    __s2_len___0 = __builtin_strlen((char const   *)tmp___67);
#line 410
    if (! ((size_t )((void const   *)("World!" + 1)) - (size_t )((void const   *)"World!") == 1UL)) {
#line 410
      goto _L___2;
    } else
#line 410
    if (__s1_len___0 >= 4UL) {
      _L___2: /* CIL Label */ 
#line 410
      tmp___68 = tokenizerGetWord(tok);
#line 410
      tmp___69 = tokenizerGetWord(tok);
#line 410
      if ((size_t )((void const   *)(tmp___68 + 1)) - (size_t )((void const   *)tmp___69) == 1UL) {
#line 410
        if (__s2_len___0 >= 4UL) {
#line 410
          tmp___70 = 1;
        } else {
#line 410
          tmp___70 = 0;
        }
      } else {
#line 410
        tmp___70 = 1;
      }
    } else {
#line 410
      tmp___70 = 0;
    }
#line 410
    if (tmp___70) {
#line 410
      tmp___45 = tokenizerGetWord(tok);
#line 410
      tmp___46 = __builtin_strcmp("World!", (char const   *)tmp___45);
#line 410
      tmp___65 = tmp___46;
    } else {
#line 410
      tmp___63 = tokenizerGetWord(tok);
#line 410
      tmp___64 = __builtin_strcmp("World!", (char const   *)tmp___63);
#line 410
      tmp___65 = tmp___64;
    }
  } else {
#line 410
    tmp___63 = tokenizerGetWord(tok);
#line 410
    tmp___64 = __builtin_strcmp("World!", (char const   *)tmp___63);
#line 410
    tmp___65 = tmp___64;
  }
#line 410
  if (tmp___65) {
#line 410
    tmp___38 = time((time_t *)0);
#line 410
    tttt___2 = tmp___38;
#line 410
    tmp___39 = ctime((time_t const   *)(& tttt___2));
#line 410
    printf((char const   * __restrict  )"**DEBUG CHECK** Failed check (%s) \"%s\"\n             at [%s]<%s():line %u>\n             %s\n",
           "!strcmp (\"World!\", tokenizerGetWord (tok))", msg, "src/csuCommonUtil.c",
           "tokenizerTestSuite", 410, tmp___39);
#line 410
    fflush(stdout);
#line 410
    exit(1);
  }
#line 411
  tmp___73 = tokenizerEndOfLine(tok);
#line 411
  if (! tmp___73) {
#line 411
    tmp___71 = time((time_t *)0);
#line 411
    tttt___3 = tmp___71;
#line 411
    tmp___72 = ctime((time_t const   *)(& tttt___3));
#line 411
    printf((char const   * __restrict  )"**DEBUG CHECK** Failed check (%s) \"%s\"\n             at [%s]<%s():line %u>\n             %s\n",
           "tokenizerEndOfLine (tok)", msg, "src/csuCommonUtil.c", "tokenizerTestSuite",
           411, tmp___72);
#line 411
    fflush(stdout);
#line 411
    exit(1);
  }
#line 412
  tmp___76 = tokenizerEndOfFile(tok);
#line 412
  if (! tmp___76) {
#line 412
    tmp___74 = time((time_t *)0);
#line 412
    tttt___4 = tmp___74;
#line 412
    tmp___75 = ctime((time_t const   *)(& tttt___4));
#line 412
    printf((char const   * __restrict  )"**DEBUG CHECK** Failed check (%s) \"%s\"\n             at [%s]<%s():line %u>\n             %s\n",
           "tokenizerEndOfFile (tok)", msg, "src/csuCommonUtil.c", "tokenizerTestSuite",
           412, tmp___75);
#line 412
    fflush(stdout);
#line 412
    exit(1);
  }
#line 414
  test = (char *)"\n\nYogi # Bear ";
#line 415
  tokenizerInit(tok, & tokenizerStringReader, (void *)test);
#line 416
  if (0) {
#line 416
    __s1_len___1 = __builtin_strlen("Yogi");
#line 416
    tmp___106 = tokenizerGetWord(tok);
#line 416
    __s2_len___1 = __builtin_strlen((char const   *)tmp___106);
#line 416
    if (! ((size_t )((void const   *)("Yogi" + 1)) - (size_t )((void const   *)"Yogi") == 1UL)) {
#line 416
      goto _L___4;
    } else
#line 416
    if (__s1_len___1 >= 4UL) {
      _L___4: /* CIL Label */ 
#line 416
      tmp___107 = tokenizerGetWord(tok);
#line 416
      tmp___108 = tokenizerGetWord(tok);
#line 416
      if ((size_t )((void const   *)(tmp___107 + 1)) - (size_t )((void const   *)tmp___108) == 1UL) {
#line 416
        if (__s2_len___1 >= 4UL) {
#line 416
          tmp___109 = 1;
        } else {
#line 416
          tmp___109 = 0;
        }
      } else {
#line 416
        tmp___109 = 1;
      }
    } else {
#line 416
      tmp___109 = 0;
    }
#line 416
    if (tmp___109) {
#line 416
      tmp___84 = tokenizerGetWord(tok);
#line 416
      tmp___85 = __builtin_strcmp("Yogi", (char const   *)tmp___84);
#line 416
      tmp___104 = tmp___85;
    } else {
#line 416
      tmp___102 = tokenizerGetWord(tok);
#line 416
      tmp___103 = __builtin_strcmp("Yogi", (char const   *)tmp___102);
#line 416
      tmp___104 = tmp___103;
    }
  } else {
#line 416
    tmp___102 = tokenizerGetWord(tok);
#line 416
    tmp___103 = __builtin_strcmp("Yogi", (char const   *)tmp___102);
#line 416
    tmp___104 = tmp___103;
  }
#line 416
  if (tmp___104) {
#line 416
    tmp___77 = time((time_t *)0);
#line 416
    tttt___5 = tmp___77;
#line 416
    tmp___78 = ctime((time_t const   *)(& tttt___5));
#line 416
    printf((char const   * __restrict  )"**DEBUG CHECK** Failed check (%s) \"%s\"\n             at [%s]<%s():line %u>\n             %s\n",
           "!strcmp (\"Yogi\", tokenizerGetWord (tok))", msg, "src/csuCommonUtil.c",
           "tokenizerTestSuite", 416, tmp___78);
#line 416
    fflush(stdout);
#line 416
    exit(1);
  }
#line 417
  tmp___112 = tokenizerEndOfLine(tok);
#line 417
  if (! tmp___112) {
#line 417
    tmp___110 = time((time_t *)0);
#line 417
    tttt___6 = tmp___110;
#line 417
    tmp___111 = ctime((time_t const   *)(& tttt___6));
#line 417
    printf((char const   * __restrict  )"**DEBUG CHECK** Failed check (%s) \"%s\"\n             at [%s]<%s():line %u>\n             %s\n",
           "tokenizerEndOfLine (tok)", msg, "src/csuCommonUtil.c", "tokenizerTestSuite",
           417, tmp___111);
#line 417
    fflush(stdout);
#line 417
    exit(1);
  }
#line 418
  tmp___115 = tokenizerEndOfFile(tok);
#line 418
  if (! tmp___115) {
#line 418
    tmp___113 = time((time_t *)0);
#line 418
    tttt___7 = tmp___113;
#line 418
    tmp___114 = ctime((time_t const   *)(& tttt___7));
#line 418
    printf((char const   * __restrict  )"**DEBUG CHECK** Failed check (%s) \"%s\"\n             at [%s]<%s():line %u>\n             %s\n",
           "tokenizerEndOfFile (tok)", msg, "src/csuCommonUtil.c", "tokenizerTestSuite",
           418, tmp___114);
#line 418
    fflush(stdout);
#line 418
    exit(1);
  }
#line 420
  test = (char *)"";
#line 421
  tokenizerInit(tok, & tokenizerStringReader, (void *)test);
#line 422
  if (0) {
#line 422
    __s1_len___2 = __builtin_strlen("");
#line 422
    tmp___145 = tokenizerGetWord(tok);
#line 422
    __s2_len___2 = __builtin_strlen((char const   *)tmp___145);
#line 422
    if (! ((size_t )((void const   *)("" + 1)) - (size_t )((void const   *)"") == 1UL)) {
#line 422
      goto _L___6;
    } else
#line 422
    if (__s1_len___2 >= 4UL) {
      _L___6: /* CIL Label */ 
#line 422
      tmp___146 = tokenizerGetWord(tok);
#line 422
      tmp___147 = tokenizerGetWord(tok);
#line 422
      if ((size_t )((void const   *)(tmp___146 + 1)) - (size_t )((void const   *)tmp___147) == 1UL) {
#line 422
        if (__s2_len___2 >= 4UL) {
#line 422
          tmp___148 = 1;
        } else {
#line 422
          tmp___148 = 0;
        }
      } else {
#line 422
        tmp___148 = 1;
      }
    } else {
#line 422
      tmp___148 = 0;
    }
#line 422
    if (tmp___148) {
#line 422
      tmp___123 = tokenizerGetWord(tok);
#line 422
      tmp___124 = __builtin_strcmp("", (char const   *)tmp___123);
#line 422
      tmp___143 = tmp___124;
    } else {
#line 422
      tmp___141 = tokenizerGetWord(tok);
#line 422
      tmp___142 = __builtin_strcmp("", (char const   *)tmp___141);
#line 422
      tmp___143 = tmp___142;
    }
  } else {
#line 422
    tmp___141 = tokenizerGetWord(tok);
#line 422
    tmp___142 = __builtin_strcmp("", (char const   *)tmp___141);
#line 422
    tmp___143 = tmp___142;
  }
#line 422
  if (tmp___143) {
#line 422
    tmp___116 = time((time_t *)0);
#line 422
    tttt___8 = tmp___116;
#line 422
    tmp___117 = ctime((time_t const   *)(& tttt___8));
#line 422
    printf((char const   * __restrict  )"**DEBUG CHECK** Failed check (%s) \"%s\"\n             at [%s]<%s():line %u>\n             %s\n",
           "!strcmp (\"\", tokenizerGetWord (tok))", msg, "src/csuCommonUtil.c", "tokenizerTestSuite",
           422, tmp___117);
#line 422
    fflush(stdout);
#line 422
    exit(1);
  }
#line 423
  tmp___151 = tokenizerEndOfLine(tok);
#line 423
  if (tmp___151) {
#line 423
    tmp___149 = time((time_t *)0);
#line 423
    tttt___9 = tmp___149;
#line 423
    tmp___150 = ctime((time_t const   *)(& tttt___9));
#line 423
    printf((char const   * __restrict  )"**DEBUG CHECK** Failed check (%s) \"%s\"\n             at [%s]<%s():line %u>\n             %s\n",
           "!tokenizerEndOfLine (tok)", msg, "src/csuCommonUtil.c", "tokenizerTestSuite",
           423, tmp___150);
#line 423
    fflush(stdout);
#line 423
    exit(1);
  }
#line 424
  tmp___154 = tokenizerEndOfFile(tok);
#line 424
  if (! tmp___154) {
#line 424
    tmp___152 = time((time_t *)0);
#line 424
    tttt___10 = tmp___152;
#line 424
    tmp___153 = ctime((time_t const   *)(& tttt___10));
#line 424
    printf((char const   * __restrict  )"**DEBUG CHECK** Failed check (%s) \"%s\"\n             at [%s]<%s():line %u>\n             %s\n",
           "tokenizerEndOfFile (tok)", msg, "src/csuCommonUtil.c", "tokenizerTestSuite",
           424, tmp___153);
#line 424
    fflush(stdout);
#line 424
    exit(1);
  }
#line 426
  test = (char *)"\n  \na\tb##b\n#d";
#line 427
  tokenizerInit(tok, & tokenizerStringReader, (void *)test);
#line 428
  if (0) {
#line 428
    __s1_len___3 = __builtin_strlen("a");
#line 428
    tmp___184 = tokenizerGetWord(tok);
#line 428
    __s2_len___3 = __builtin_strlen((char const   *)tmp___184);
#line 428
    if (! ((size_t )((void const   *)("a" + 1)) - (size_t )((void const   *)"a") == 1UL)) {
#line 428
      goto _L___8;
    } else
#line 428
    if (__s1_len___3 >= 4UL) {
      _L___8: /* CIL Label */ 
#line 428
      tmp___185 = tokenizerGetWord(tok);
#line 428
      tmp___186 = tokenizerGetWord(tok);
#line 428
      if ((size_t )((void const   *)(tmp___185 + 1)) - (size_t )((void const   *)tmp___186) == 1UL) {
#line 428
        if (__s2_len___3 >= 4UL) {
#line 428
          tmp___187 = 1;
        } else {
#line 428
          tmp___187 = 0;
        }
      } else {
#line 428
        tmp___187 = 1;
      }
    } else {
#line 428
      tmp___187 = 0;
    }
#line 428
    if (tmp___187) {
#line 428
      tmp___162 = tokenizerGetWord(tok);
#line 428
      tmp___163 = __builtin_strcmp("a", (char const   *)tmp___162);
#line 428
      tmp___182 = tmp___163;
    } else {
#line 428
      tmp___180 = tokenizerGetWord(tok);
#line 428
      tmp___181 = __builtin_strcmp("a", (char const   *)tmp___180);
#line 428
      tmp___182 = tmp___181;
    }
  } else {
#line 428
    tmp___180 = tokenizerGetWord(tok);
#line 428
    tmp___181 = __builtin_strcmp("a", (char const   *)tmp___180);
#line 428
    tmp___182 = tmp___181;
  }
#line 428
  if (tmp___182) {
#line 428
    tmp___155 = time((time_t *)0);
#line 428
    tttt___11 = tmp___155;
#line 428
    tmp___156 = ctime((time_t const   *)(& tttt___11));
#line 428
    printf((char const   * __restrict  )"**DEBUG CHECK** Failed check (%s) \"%s\"\n             at [%s]<%s():line %u>\n             %s\n",
           "!strcmp (\"a\", tokenizerGetWord (tok))", msg, "src/csuCommonUtil.c",
           "tokenizerTestSuite", 428, tmp___156);
#line 428
    fflush(stdout);
#line 428
    exit(1);
  }
#line 429
  tmp___190 = tokenizerEndOfLine(tok);
#line 429
  if (tmp___190) {
#line 429
    tmp___188 = time((time_t *)0);
#line 429
    tttt___12 = tmp___188;
#line 429
    tmp___189 = ctime((time_t const   *)(& tttt___12));
#line 429
    printf((char const   * __restrict  )"**DEBUG CHECK** Failed check (%s) \"%s\"\n             at [%s]<%s():line %u>\n             %s\n",
           "!tokenizerEndOfLine (tok)", msg, "src/csuCommonUtil.c", "tokenizerTestSuite",
           429, tmp___189);
#line 429
    fflush(stdout);
#line 429
    exit(1);
  }
#line 430
  tmp___193 = tokenizerEndOfFile(tok);
#line 430
  if (tmp___193) {
#line 430
    tmp___191 = time((time_t *)0);
#line 430
    tttt___13 = tmp___191;
#line 430
    tmp___192 = ctime((time_t const   *)(& tttt___13));
#line 430
    printf((char const   * __restrict  )"**DEBUG CHECK** Failed check (%s) \"%s\"\n             at [%s]<%s():line %u>\n             %s\n",
           "!tokenizerEndOfFile (tok)", msg, "src/csuCommonUtil.c", "tokenizerTestSuite",
           430, tmp___192);
#line 430
    fflush(stdout);
#line 430
    exit(1);
  }
#line 431
  if (0) {
#line 431
    __s1_len___4 = __builtin_strlen("b");
#line 431
    tmp___223 = tokenizerGetWord(tok);
#line 431
    __s2_len___4 = __builtin_strlen((char const   *)tmp___223);
#line 431
    if (! ((size_t )((void const   *)("b" + 1)) - (size_t )((void const   *)"b") == 1UL)) {
#line 431
      goto _L___10;
    } else
#line 431
    if (__s1_len___4 >= 4UL) {
      _L___10: /* CIL Label */ 
#line 431
      tmp___224 = tokenizerGetWord(tok);
#line 431
      tmp___225 = tokenizerGetWord(tok);
#line 431
      if ((size_t )((void const   *)(tmp___224 + 1)) - (size_t )((void const   *)tmp___225) == 1UL) {
#line 431
        if (__s2_len___4 >= 4UL) {
#line 431
          tmp___226 = 1;
        } else {
#line 431
          tmp___226 = 0;
        }
      } else {
#line 431
        tmp___226 = 1;
      }
    } else {
#line 431
      tmp___226 = 0;
    }
#line 431
    if (tmp___226) {
#line 431
      tmp___201 = tokenizerGetWord(tok);
#line 431
      tmp___202 = __builtin_strcmp("b", (char const   *)tmp___201);
#line 431
      tmp___221 = tmp___202;
    } else {
#line 431
      tmp___219 = tokenizerGetWord(tok);
#line 431
      tmp___220 = __builtin_strcmp("b", (char const   *)tmp___219);
#line 431
      tmp___221 = tmp___220;
    }
  } else {
#line 431
    tmp___219 = tokenizerGetWord(tok);
#line 431
    tmp___220 = __builtin_strcmp("b", (char const   *)tmp___219);
#line 431
    tmp___221 = tmp___220;
  }
#line 431
  if (tmp___221) {
#line 431
    tmp___194 = time((time_t *)0);
#line 431
    tttt___14 = tmp___194;
#line 431
    tmp___195 = ctime((time_t const   *)(& tttt___14));
#line 431
    printf((char const   * __restrict  )"**DEBUG CHECK** Failed check (%s) \"%s\"\n             at [%s]<%s():line %u>\n             %s\n",
           "!strcmp (\"b\", tokenizerGetWord (tok))", msg, "src/csuCommonUtil.c",
           "tokenizerTestSuite", 431, tmp___195);
#line 431
    fflush(stdout);
#line 431
    exit(1);
  }
#line 432
  tmp___229 = tokenizerEndOfLine(tok);
#line 432
  if (! tmp___229) {
#line 432
    tmp___227 = time((time_t *)0);
#line 432
    tttt___15 = tmp___227;
#line 432
    tmp___228 = ctime((time_t const   *)(& tttt___15));
#line 432
    printf((char const   * __restrict  )"**DEBUG CHECK** Failed check (%s) \"%s\"\n             at [%s]<%s():line %u>\n             %s\n",
           "tokenizerEndOfLine (tok)", msg, "src/csuCommonUtil.c", "tokenizerTestSuite",
           432, tmp___228);
#line 432
    fflush(stdout);
#line 432
    exit(1);
  }
#line 433
  tmp___232 = tokenizerEndOfFile(tok);
#line 433
  if (! tmp___232) {
#line 433
    tmp___230 = time((time_t *)0);
#line 433
    tttt___16 = tmp___230;
#line 433
    tmp___231 = ctime((time_t const   *)(& tttt___16));
#line 433
    printf((char const   * __restrict  )"**DEBUG CHECK** Failed check (%s) \"%s\"\n             at [%s]<%s():line %u>\n             %s\n",
           "tokenizerEndOfFile (tok)", msg, "src/csuCommonUtil.c", "tokenizerTestSuite",
           433, tmp___231);
#line 433
    fflush(stdout);
#line 433
    exit(1);
  }
#line 434
  return;
}
}
#line 453 "src/csuCommonUtil.c"
void listAccumulate(void **base , void *data , size_t size ) 
{ 
  LinkedListNode node ;
  void *tmp ;

  {
#line 461
  tmp = malloc(sizeof(LinkedListNode ) + size);
#line 461
  node = (LinkedListNode )tmp;
#line 463
  memcpy((void * __restrict  )(& node->data), (void const   * __restrict  )data, size);
#line 464
  node->link = (LinkedListNode )*base;
#line 465
  *base = (void *)node;
#line 466
  return;
}
}
#line 475 "src/csuCommonUtil.c"
void *listToArray(void **base , size_t size , size_t *nelems ) 
{ 
  int nItems ;
  LinkedListNode___0 node ;
  LinkedListNode___0 nextNode ;
  void *array ;
  void *a_dest ;

  {
#line 489
  nItems = 0;
#line 490
  node = (LinkedListNode___0 )*base;
#line 491
  while (node) {
#line 493
    nItems ++;
#line 494
    node = (LinkedListNode___0 )node->link;
  }
#line 499
  array = malloc(size * (size_t )nItems);
#line 504
  node = (LinkedListNode___0 )*base;
#line 505
  a_dest = (void *)((char *)array + size * (size_t )nItems);
#line 506
  while (node) {
#line 508
    a_dest = (void *)((char *)a_dest - size);
#line 509
    memcpy((void * __restrict  )a_dest, (void const   * __restrict  )(& node->data),
           size);
#line 510
    nextNode = (LinkedListNode___0 )node->link;
#line 511
    free((void *)node);
#line 512
    node = nextNode;
  }
#line 517
  if ((unsigned long )nelems != (unsigned long )((void *)0)) {
#line 518
    *nelems = (size_t )nItems;
  }
#line 520
  return (array);
}
}
#line 528 "src/csuCommonUtil.c"
void *listToNullTerminatedArray(void **base , size_t size , size_t *nelems ) 
{ 
  void *res ;
  char *s ;

  {
#line 535
  s = (char *)((void *)0);
#line 536
  listAccumulate(base, (void *)(& s), size);
#line 538
  res = listToArray(base, size, nelems);
#line 539
  if ((unsigned long )nelems != (unsigned long )((void *)0)) {
#line 540
    (*nelems) --;
  }
#line 542
  return (res);
}
}
#line 568 "src/csuCommonUtil.c"
int pairComparator(void const   *a , void const   *b ) 
{ 
  Pair const   *p1 ;
  Pair const   *p2 ;

  {
#line 571
  p1 = (Pair const   *)((Pair *)a);
#line 572
  p2 = (Pair const   *)((Pair *)b);
#line 574
  if (p1->key < p2->key) {
#line 575
    return (-1);
  }
#line 576
  if (p1->key > p2->key) {
#line 577
    return (1);
  }
#line 578
  return (0);
}
}
#line 584 "src/csuCommonUtil.c"
int *shuffledNumbers(int max ) 
{ 
  int *indices ;
  int i ;
  Pair *toSort ;
  void *tmp ;
  void *tmp___0 ;

  {
#line 587
  tmp = malloc((unsigned long )max * sizeof(Pair ));
#line 587
  toSort = (Pair *)tmp;
#line 589
  i = 0;
#line 589
  while (i < max) {
#line 591
    (toSort + i)->key = random();
#line 592
    (toSort + i)->index = (long )i;
#line 589
    i ++;
  }
#line 595
  qsort((void *)toSort, (size_t )max, sizeof(Pair ), & pairComparator);
#line 597
  tmp___0 = malloc((unsigned long )max * sizeof(int ));
#line 597
  indices = (int *)tmp___0;
#line 599
  i = 0;
#line 599
  while (i < max) {
#line 600
    *(indices + i) = (int )(toSort + i)->index;
#line 599
    i ++;
  }
#line 603
  free((void *)toSort);
#line 605
  return (indices);
}
}
#line 623 "src/csuCommonUtil.c"
static char *sym  =    (char *)"";
#line 619 "src/csuCommonUtil.c"
void writeProgress(char *what , int value , int max ) 
{ 
  char *symbols ;
  char *tmp ;
  char *tmp___0 ;

  {
#line 622
  symbols = (char *)"\\|/-";
#line 625
  if ((int )*sym == 0) {
#line 626
    sym = symbols;
  }
#line 628
  if (max) {
#line 629
    tmp = sym;
#line 629
    sym ++;
#line 629
    fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )"%s: %c Processed: %d (%d%%)   \r",
            what, (int )*tmp, value, (100 * value) / max);
  } else {
#line 631
    tmp___0 = sym;
#line 631
    sym ++;
#line 631
    fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )"%s: %c Processed: %d          \r",
            what, (int )*tmp___0, value);
  }
#line 633
  fflush(stdout);
#line 634
  return;
}
}
#line 643 "src/csuCommonUtil.c"
static int flag  =    -1;
#line 642 "src/csuCommonUtil.c"
int isMachineLittleEndian(void) 
{ 
  char magic[4] ;
  unsigned long *longMagic ;

  {
#line 644
  if (flag == -1) {
#line 645
    magic[0] = (char)1;
#line 645
    magic[1] = (char)2;
#line 645
    magic[2] = (char)3;
#line 645
    magic[3] = (char)4;
#line 646
    longMagic = (unsigned long *)(magic);
#line 647
    if (*longMagic == 16909060UL) {
#line 648
      flag = 0;
    } else
#line 649
    if (*longMagic == 67305985UL) {
#line 650
      flag = 1;
    } else {
#line 652
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Funky Byte Order, I give Up!!\n");
#line 653
      exit(1);
    }
  }
#line 656
  return (flag);
}
}
#line 659 "src/csuCommonUtil.c"
void byteswap_4(void *data , int const   numfourbyteelements ) 
{ 
  int i ;
  int *d4 ;
  unsigned char *d1 ;
  int tmp ;

  {
#line 662
  d4 = (int *)data;
#line 663
  d1 = (unsigned char *)data;
#line 665
  tmp = isMachineLittleEndian();
#line 665
  if (tmp) {
#line 673
    i = 0;
#line 673
    while (i < (int )numfourbyteelements) {
#line 674
      *(d4 + i) = ((((int )*(d1 + 0) << 24) | ((int )*(d1 + 1) << 16)) | ((int )*(d1 + 2) << 8)) | (int )*(d1 + 3);
#line 673
      i ++;
#line 673
      d1 += 4;
    }
  } else {
#line 667
    i = 0;
#line 667
    while (i < (int )numfourbyteelements) {
#line 668
      *(d4 + i) = ((((int )*(d1 + 3) << 24) | ((int )*(d1 + 2) << 16)) | ((int )*(d1 + 1) << 8)) | (int )*(d1 + 0);
#line 667
      i ++;
#line 667
      d1 += 4;
    }
  }
#line 677
  return;
}
}
#line 682 "src/csuCommonUtil.c"
char *strconc(char const   *s1 , char const   *s2 ) 
{ 
  char *result ;
  size_t tmp ;
  size_t tmp___0 ;
  void *tmp___1 ;
  time_t tttt ;
  time_t tmp___2 ;
  char *tmp___3 ;

  {
#line 684
  tmp = strlen(s1);
#line 684
  tmp___0 = strlen(s2);
#line 684
  tmp___1 = malloc(sizeof(char ) * ((tmp + tmp___0) + 1UL));
#line 684
  result = (char *)tmp___1;
#line 685
  if (! result) {
#line 685
    tmp___2 = time((time_t *)0);
#line 685
    tttt = tmp___2;
#line 685
    tmp___3 = ctime((time_t const   *)(& tttt));
#line 685
    printf((char const   * __restrict  )"**DEBUG CHECK** Failed check (%s) \"%s\"\n             at [%s]<%s():line %u>\n             %s\n",
           "result", "malloc failed", "src/csuCommonUtil.c", "strconc", 685, tmp___3);
#line 685
    fflush(stdout);
#line 685
    exit(1);
  }
#line 687
  strcpy((char * __restrict  )result, (char const   * __restrict  )s1);
#line 688
  strcat((char * __restrict  )result, (char const   * __restrict  )s2);
#line 689
  return (result);
}
}
#line 692 "src/csuCommonUtil.c"
char *strclone(char const   *si ) 
{ 
  char *so ;
  char *tmp___4 ;
  time_t tttt ;
  time_t tmp___5 ;
  char *tmp___6 ;

  {
#line 694
  tmp___4 = __strdup(si);
#line 694
  so = tmp___4;
#line 695
  if (! so) {
#line 695
    tmp___5 = time((time_t *)0);
#line 695
    tttt = tmp___5;
#line 695
    tmp___6 = ctime((time_t const   *)(& tttt));
#line 695
    printf((char const   * __restrict  )"**DEBUG CHECK** Failed check (%s) \"%s\"\n             at [%s]<%s():line %u>\n             %s\n",
           "so", "malloc failed", "src/csuCommonUtil.c", "strclone", 695, tmp___6);
#line 695
    fflush(stdout);
#line 695
    exit(1);
  }
#line 696
  return (so);
}
}
#line 703 "src/csuCommonUtil.c"
char *strlower(char *x ) 
{ 
  char *result ;
  char tmp ;
  int __res ;
  __int32_t const   **tmp___1 ;

  {
#line 705
  result = x;
#line 706
  while (1) {
#line 706
    if (sizeof((int )*x) > 1UL) {
#line 706
      __res = tolower((int )*x);
    } else {
#line 706
      tmp___1 = __ctype_tolower_loc();
#line 706
      __res = (int )*(*tmp___1 + (int )*x);
    }
#line 706
    tmp = (char )__res;
#line 706
    *x = tmp;
#line 706
    if (! tmp) {
#line 706
      break;
    }
#line 706
    x ++;
  }
#line 707
  return (result);
}
}
#line 714 "src/csuCommonUtil.c"
char *strupper(char *x ) 
{ 
  char *result ;
  char tmp ;
  int __res ;
  __int32_t const   **tmp___1 ;

  {
#line 716
  result = x;
#line 717
  while (1) {
#line 717
    if (sizeof((int )*x) > 1UL) {
#line 717
      __res = toupper((int )*x);
    } else {
#line 717
      tmp___1 = __ctype_toupper_loc();
#line 717
      __res = (int )*(*tmp___1 + (int )*x);
    }
#line 717
    tmp = (char )__res;
#line 717
    *x = tmp;
#line 717
    if (! tmp) {
#line 717
      break;
    }
#line 717
    x ++;
  }
#line 718
  return (result);
}
}
#line 727 "src/csuCommonUtil.c"
char *newextlong(char **filename , char const   *extension ) 
{ 
  char *result ;
  char *finalperiod ;
  char *tmp ;
  char *periodized ;
  char *tmp___0 ;

  {
#line 729
  if (extension) {
#line 731
    result = (char *)0;
#line 732
    tmp = strrchr((char const   *)*filename, '.');
#line 732
    finalperiod = tmp;
#line 734
    if (! finalperiod) {
#line 736
      tmp___0 = strconc(".", extension);
#line 736
      periodized = tmp___0;
#line 737
      result = strconc((char const   *)*filename, (char const   *)periodized);
#line 738
      free((void *)periodized);
    } else {
#line 742
      *(finalperiod + 1) = (char )'\000';
#line 743
      result = strconc((char const   *)*filename, extension);
    }
#line 746
    free((void *)*filename);
#line 747
    *filename = result;
  }
#line 749
  return (*filename);
}
}
#line 758 "src/csuCommonUtil.c"
int debuglevel  =    0;
#line 759 "src/csuCommonUtil.c"
int quiet  =    0;
#line 1 "csuCommonSubspace.o"
#pragma merger("0","/tmp/cil-RbEkW2xP.i","-O3,-Wall")
#line 150 "/usr/include/x86_64-linux-gnu/bits/mathinline.h"
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__, __always_inline__)) __signbitl)(long double __x )  __attribute__((__const__)) ;
#line 150 "/usr/include/x86_64-linux-gnu/bits/mathinline.h"
__inline extern int ( __attribute__((__leaf__, __always_inline__)) __signbitl)(long double __x ) 
{ 
  union __anonunion___u_26___2 __u ;

  {
#line 153
  __u.__l = __x;
#line 154
  return ((__u.__i[2] & 32768) != 0);
}
}
#line 132 "src/csuCommonSubspace.h"
void subspaceTrain(Subspace *s , Matrix images , ImageList *srt , int numSubjects ,
                   int dropNVectors , CutOffMode cutOffMode , double cutOff , int useLDA ,
                   int writeTextInterm ) ;
#line 133
void writeSubspace(Subspace *s , char *training_filename , char *imageList , int argc ,
                   char **argv ) ;
#line 134
void readSubspace(Subspace *s , char const   *trainingFile , int quiet___0 ) ;
#line 136
void validateBasisIsOrthonormal(Matrix basis , int printlevel ) ;
#line 138
Matrix centerThenProjectImages(Subspace *s , Matrix images ) ;
#line 141
Matrix readAndProjectImages(Subspace *s , char *imageNamesFile , char *imageDirectory ,
                            int *numImages , ImageList **srt ) ;
#line 150
void basis_normalize(Matrix eigenvectors ) ;
#line 151
void mean_subtract_images(Matrix images , Matrix mean ) ;
#line 152
Matrix get_mean_image(Matrix images ) ;
#line 155
void eigentrain(Matrix *mean , Matrix *eigen_vals , Matrix *eigen_base , Matrix images ) ;
#line 156
void fisherTrain(Matrix imspca , ImageList *srt , Matrix *fisherBasis , Matrix *fisherValues ,
                 int writeTextInterm ) ;
#line 94 "src/csuCommonSubspace.c"
void subspaceTrain(Subspace *s , Matrix images , ImageList *srt , int numSubjects ,
                   int dropNVectors , CutOffMode cutOffMode , double cutOff , int useLDA ,
                   int writeTextInterm ) 
{ 
  int i ;
  Matrix m ;
  int n ;
  double total_energy ;
  double energy ;
  Matrix tmp ;
  time_t tttt ;
  time_t tmp___0 ;
  char *tmp___1 ;
  time_t tttt___0 ;
  time_t tmp___2 ;
  char *tmp___3 ;
  time_t tttt___1 ;
  time_t tmp___4 ;
  char *tmp___5 ;
  time_t tttt___2 ;
  time_t tmp___6 ;
  char *tmp___7 ;
  time_t tttt___3 ;
  time_t tmp___8 ;
  char *tmp___9 ;
  time_t tttt___4 ;
  time_t tmp___10 ;
  char *tmp___11 ;
  time_t tttt___5 ;
  time_t tmp___12 ;
  char *tmp___13 ;
  time_t tttt___6 ;
  time_t tmp___14 ;
  char *tmp___15 ;
  time_t tttt___7 ;
  time_t tmp___16 ;
  char *tmp___17 ;
  time_t tttt___8 ;
  time_t tmp___18 ;
  char *tmp___19 ;
  Matrix fisherBasis ;
  Matrix fisherValues ;
  Matrix combinedBasis ;
  Matrix imspca ;
  Matrix tmp___20 ;
  time_t tttt___9 ;
  time_t tmp___21 ;
  char *tmp___22 ;
  time_t tttt___10 ;
  time_t tmp___23 ;
  char *tmp___24 ;

  {
#line 99
  n = 0;
#line 105
  s->useLDA = useLDA;
#line 106
  s->cutOffMode = cutOffMode;
#line 107
  s->cutOff = cutOff;
#line 108
  s->dropNVectors = dropNVectors;
#line 110
  s->numSubjects = numSubjects;
#line 111
  s->numPixels = images->row_dim;
#line 122
  tmp___0 = time((time_t *)0);
#line 122
  tttt = tmp___0;
#line 122
  if (quiet == 0) {
#line 122
    printf((char const   * __restrict  )"Computing the PCA eigenspace.");
  } else
#line 122
  if (debuglevel != 0) {
#line 122
    printf((char const   * __restrict  )"Computing the PCA eigenspace.");
  }
#line 122
  if (quiet == 0) {
#line 122
    printf((char const   * __restrict  )"\n");
  } else
#line 122
  if (debuglevel != 0) {
#line 122
    printf((char const   * __restrict  )"\n");
  }
#line 122
  if (debuglevel > 0) {
#line 122
    tmp___1 = ctime((time_t const   *)(& tttt));
#line 122
    printf((char const   * __restrict  )"    [%s]<%s():line %u> %s\n", "src/csuCommonSubspace.c",
           "subspaceTrain", 122, tmp___1);
  }
#line 122
  fflush(stdout);
#line 124
  eigentrain(& s->mean, & s->values, & s->basis, images);
#line 126
  tmp___2 = time((time_t *)0);
#line 126
  tttt___0 = tmp___2;
#line 126
  if (quiet == 0) {
#line 126
    printf((char const   * __restrict  )"Finished computing eigenspace.");
  } else
#line 126
  if (debuglevel != 0) {
#line 126
    printf((char const   * __restrict  )"Finished computing eigenspace.");
  }
#line 126
  if (quiet == 0) {
#line 126
    printf((char const   * __restrict  )"\n");
  } else
#line 126
  if (debuglevel != 0) {
#line 126
    printf((char const   * __restrict  )"\n");
  }
#line 126
  if (debuglevel > 0) {
#line 126
    tmp___3 = ctime((time_t const   *)(& tttt___0));
#line 126
    printf((char const   * __restrict  )"    [%s]<%s():line %u> %s\n", "src/csuCommonSubspace.c",
           "subspaceTrain", 126, tmp___3);
  }
#line 126
  fflush(stdout);
#line 131
  m = s->values;
#line 132
  i = 0;
#line 132
  while (i < m->row_dim) {
#line 134
    if (*(*(m->cols + 0) + i) < (double )0) {
#line 135
      if (*(*(m->cols + 0) + i) < - 1e-10) {
#line 136
        printf((char const   * __restrict  )"WARNING: Large negative eigenvalue found %f. Truncating to zero.\n",
               *(*(m->cols + 0) + i));
      }
#line 137
      *(*(m->cols + 0) + i) = (double )0;
    }
#line 132
    i ++;
  }
#line 170
  if (! (s->dropNVectors < (s->basis)->col_dim)) {
#line 170
    tmp___4 = time((time_t *)0);
#line 170
    tttt___1 = tmp___4;
#line 170
    tmp___5 = ctime((time_t const   *)(& tttt___1));
#line 170
    printf((char const   * __restrict  )"**DEBUG CHECK** Failed check (%s) \"%s\"\n             at [%s]<%s():line %u>\n             %s\n",
           "s->dropNVectors < (s->basis)->col_dim", "Number of vectors to drop must be less than the number of the eigen vectors",
           "src/csuCommonSubspace.c", "subspaceTrain", 170, tmp___5);
#line 170
    fflush(stdout);
#line 170
    exit(1);
  }
#line 174
  tmp = transposeMatrix((Matrix const   )s->values);
#line 175
  freeMatrix(s->values);
#line 176
  s->values = tmp;
#line 178
  if (s->dropNVectors) {
#line 178
    if (s->dropNVectors < (s->values)->col_dim) {
#line 180
      tmp = matrixCols((Matrix const   )s->basis, s->dropNVectors, (s->basis)->col_dim - 1);
#line 181
      freeMatrix(s->basis);
#line 182
      s->basis = tmp;
#line 184
      tmp = matrixCols((Matrix const   )s->values, s->dropNVectors, (s->values)->col_dim - 1);
#line 185
      freeMatrix(s->values);
#line 186
      s->values = tmp;
    }
  }
#line 191
  tmp = transposeMatrix((Matrix const   )s->values);
#line 192
  freeMatrix(s->values);
#line 193
  s->values = tmp;
#line 195
  if (! ((s->values)->row_dim - s->dropNVectors > 0)) {
#line 195
    tmp___6 = time((time_t *)0);
#line 195
    tttt___2 = tmp___6;
#line 195
    tmp___7 = ctime((time_t const   *)(& tttt___2));
#line 195
    printf((char const   * __restrict  )"**DEBUG CHECK** Failed check (%s) \"%s\"\n             at [%s]<%s():line %u>\n             %s\n",
           "(s->values)->row_dim - s->dropNVectors > 0", "Too many eigen vectors droped from front. Can not proceed.",
           "src/csuCommonSubspace.c", "subspaceTrain", 195, tmp___7);
#line 195
    fflush(stdout);
#line 195
    exit(1);
  }
#line 197
  switch ((unsigned int )s->cutOffMode) {
  case 0U: 
#line 200
  n = (s->basis)->col_dim;
#line 201
  break;
  case 1U: 
#line 204
  n = (int )(((double )(s->basis)->col_dim * s->cutOff) / 100.0);
#line 205
  break;
  case 2U: 
#line 209
  total_energy = (double )0;
#line 210
  i = 0;
#line 210
  while (i < (s->values)->row_dim) {
#line 211
    total_energy += *(*((s->values)->cols + 0) + i);
#line 210
    i ++;
  }
#line 215
  i = 0;
#line 216
  energy = (double )0;
#line 217
  while (1) {
#line 217
    if (i < (s->values)->row_dim) {
#line 217
      if (! (energy < (total_energy * s->cutOff) / 100.0)) {
#line 217
        break;
      }
    } else {
#line 217
      break;
    }
#line 218
    energy += *(*((s->values)->cols + 0) + i);
#line 219
    i ++;
  }
#line 221
  n = i;
#line 222
  break;
  case 3U: 
#line 225
  i = 1;
#line 226
  while (1) {
#line 226
    if (i < (s->values)->row_dim) {
#line 226
      if (! (100.0 * (*(*((s->values)->cols + 0) + i) / *(*((s->values)->cols + 0) + s->dropNVectors)) > cutOff)) {
#line 226
        break;
      }
    } else {
#line 226
      break;
    }
#line 228
    i ++;
  }
#line 230
  n = i;
#line 231
  break;
  case 4U: 
#line 234
  n = s->numSubjects;
#line 235
  break;
  default: 
#line 238
  n = 0;
#line 239
  tmp___8 = time((time_t *)0);
#line 239
  tttt___3 = tmp___8;
#line 239
  tmp___9 = ctime((time_t const   *)(& tttt___3));
#line 239
  printf((char const   * __restrict  )"**DEBUG CHECK** Failed check (%s) \"%s\"\n             at [%s]<%s():line %u>\n             %s\n",
         "0", "ERROR: Unkown cutoff type", "src/csuCommonSubspace.c", "subspaceTrain",
         239, tmp___9);
#line 239
  fflush(stdout);
#line 239
  exit(1);
#line 240
  break;
  }
#line 247
  if (s->useLDA) {
#line 247
    if (n < s->numSubjects) {
#line 248
      n = s->numSubjects;
    }
  }
#line 250
  if (! (n <= (s->basis)->col_dim)) {
#line 250
    tmp___10 = time((time_t *)0);
#line 250
    tttt___4 = tmp___10;
#line 250
    tmp___11 = ctime((time_t const   *)(& tttt___4));
#line 250
    printf((char const   * __restrict  )"**DEBUG CHECK** Failed check (%s) \"%s\"\n             at [%s]<%s():line %u>\n             %s\n",
           "n <= (s->basis)->col_dim", "Tried to expand, not contract, PCA space.",
           "src/csuCommonSubspace.c", "subspaceTrain", 250, tmp___11);
#line 250
    fflush(stdout);
#line 250
    exit(1);
  }
#line 252
  tmp___12 = time((time_t *)0);
#line 252
  tttt___5 = tmp___12;
#line 252
  if (quiet == 0) {
#line 252
    printf((char const   * __restrict  )"Retaining %d eigen vectors.", n);
  } else
#line 252
  if (debuglevel != 0) {
#line 252
    printf((char const   * __restrict  )"Retaining %d eigen vectors.", n);
  }
#line 252
  if (quiet == 0) {
#line 252
    printf((char const   * __restrict  )"\n");
  } else
#line 252
  if (debuglevel != 0) {
#line 252
    printf((char const   * __restrict  )"\n");
  }
#line 252
  if (debuglevel > 0) {
#line 252
    tmp___13 = ctime((time_t const   *)(& tttt___5));
#line 252
    printf((char const   * __restrict  )"    [%s]<%s():line %u> %s\n", "src/csuCommonSubspace.c",
           "subspaceTrain", 252, tmp___13);
  }
#line 252
  fflush(stdout);
#line 254
  tmp = matrixCols((Matrix const   )s->basis, 0, n - 1);
#line 255
  freeMatrix(s->basis);
#line 256
  s->basis = tmp;
#line 258
  if (1 <= debuglevel) {
#line 258
    tmp___14 = time((time_t *)0);
#line 258
    tttt___6 = tmp___14;
#line 258
    tmp___15 = ctime((time_t const   *)(& tttt___6));
#line 258
    printf((char const   * __restrict  )"**DEBUG %d** \"%s\" %s=%d\n             at [%s]<%s():line %u>\n             %s\n",
           1, "Number of eigen vectors kept.", "n", n, "src/csuCommonSubspace.c",
           "subspaceTrain", 258, tmp___15);
#line 258
    fflush(stdout);
  }
#line 260
  if (! ((s->basis)->col_dim > 0)) {
#line 260
    tmp___16 = time((time_t *)0);
#line 260
    tttt___7 = tmp___16;
#line 260
    tmp___17 = ctime((time_t const   *)(& tttt___7));
#line 260
    printf((char const   * __restrict  )"**DEBUG CHECK** Failed check (%s) \"%s\"\n             at [%s]<%s():line %u>\n             %s\n",
           "(s->basis)->col_dim > 0", "All basis vectors deleted after cutoff and vector drop was processed.",
           "src/csuCommonSubspace.c", "subspaceTrain", 261, tmp___17);
#line 260
    fflush(stdout);
#line 260
    exit(1);
  }
#line 263
  tmp___18 = time((time_t *)0);
#line 263
  tttt___8 = tmp___18;
#line 263
  if (quiet == 0) {
#line 263
    printf((char const   * __restrict  )"Truncating PCA Space. Subspace projection expressed as %d by %d matrix.",
           (s->basis)->row_dim, (s->basis)->col_dim);
  } else
#line 263
  if (debuglevel != 0) {
#line 263
    printf((char const   * __restrict  )"Truncating PCA Space. Subspace projection expressed as %d by %d matrix.",
           (s->basis)->row_dim, (s->basis)->col_dim);
  }
#line 263
  if (quiet == 0) {
#line 263
    printf((char const   * __restrict  )"\n");
  } else
#line 263
  if (debuglevel != 0) {
#line 263
    printf((char const   * __restrict  )"\n");
  }
#line 263
  if (debuglevel > 0) {
#line 263
    tmp___19 = ctime((time_t const   *)(& tttt___8));
#line 263
    printf((char const   * __restrict  )"    [%s]<%s():line %u> %s\n", "src/csuCommonSubspace.c",
           "subspaceTrain", 264, tmp___19);
  }
#line 263
  fflush(stdout);
#line 270
  if (s->useLDA) {
#line 275
    tmp___20 = transposeMultiplyMatrixL((Matrix const   )s->basis, (Matrix const   )images);
#line 275
    imspca = tmp___20;
#line 277
    tmp___21 = time((time_t *)0);
#line 277
    tttt___9 = tmp___21;
#line 277
    if (quiet == 0) {
#line 277
      printf((char const   * __restrict  )"Computing Fisher Linear Discriminants for training images projected into PCA subspace.");
    } else
#line 277
    if (debuglevel != 0) {
#line 277
      printf((char const   * __restrict  )"Computing Fisher Linear Discriminants for training images projected into PCA subspace.");
    }
#line 277
    if (quiet == 0) {
#line 277
      printf((char const   * __restrict  )"\n");
    } else
#line 277
    if (debuglevel != 0) {
#line 277
      printf((char const   * __restrict  )"\n");
    }
#line 277
    if (debuglevel > 0) {
#line 277
      tmp___22 = ctime((time_t const   *)(& tttt___9));
#line 277
      printf((char const   * __restrict  )"    [%s]<%s():line %u> %s\n", "src/csuCommonSubspace.c",
             "subspaceTrain", 278, tmp___22);
    }
#line 277
    fflush(stdout);
#line 280
    fisherTrain(imspca, srt, & fisherBasis, & fisherValues, writeTextInterm);
#line 282
    combinedBasis = multiplyMatrix((Matrix const   )s->basis, (Matrix const   )fisherBasis);
#line 283
    basis_normalize(combinedBasis);
#line 285
    tmp___23 = time((time_t *)0);
#line 285
    tttt___10 = tmp___23;
#line 285
    if (quiet == 0) {
#line 285
      printf((char const   * __restrict  )"PCA and LDA Combined. Combined projection expressed as %d by %d matrix.",
             combinedBasis->row_dim, combinedBasis->col_dim);
    } else
#line 285
    if (debuglevel != 0) {
#line 285
      printf((char const   * __restrict  )"PCA and LDA Combined. Combined projection expressed as %d by %d matrix.",
             combinedBasis->row_dim, combinedBasis->col_dim);
    }
#line 285
    if (quiet == 0) {
#line 285
      printf((char const   * __restrict  )"\n");
    } else
#line 285
    if (debuglevel != 0) {
#line 285
      printf((char const   * __restrict  )"\n");
    }
#line 285
    if (debuglevel > 0) {
#line 285
      tmp___24 = ctime((time_t const   *)(& tttt___10));
#line 285
      printf((char const   * __restrict  )"    [%s]<%s():line %u> %s\n", "src/csuCommonSubspace.c",
             "subspaceTrain", 286, tmp___24);
    }
#line 285
    fflush(stdout);
#line 288
    s->values = fisherValues;
#line 289
    s->basis = combinedBasis;
  }
#line 291
  return;
}
}
#line 316 "src/csuCommonSubspace.c"
void writeSubspace(Subspace *s , char *training_filename , char *imageList , int argc ,
                   char **argv ) 
{ 
  int i ;
  int j ;
  FILE *file ;
  char *cutOffModeStr ;
  time_t ttt ;
  time_t tmp ;
  time_t tttt ;
  time_t tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char const   *tmp___3 ;

  {
#line 322
  tmp = time((time_t *)0);
#line 322
  ttt = tmp;
#line 324
  switch ((unsigned int )s->cutOffMode) {
  case 0U: 
#line 326
  cutOffModeStr = (char *)"NONE";
#line 326
  break;
  case 1U: 
#line 327
  cutOffModeStr = (char *)"SIMPLE";
#line 327
  break;
  case 2U: 
#line 328
  cutOffModeStr = (char *)"ENERGY";
#line 328
  break;
  case 3U: 
#line 329
  cutOffModeStr = (char *)"STRETCH";
#line 329
  break;
  default: 
#line 330
  cutOffModeStr = (char *)"UNKNOWN";
#line 330
  break;
  }
#line 333
  tmp___0 = time((time_t *)0);
#line 333
  tttt = tmp___0;
#line 333
  if (quiet == 0) {
#line 333
    printf((char const   * __restrict  )"Saving trianing information to file %s",
           training_filename);
  } else
#line 333
  if (debuglevel != 0) {
#line 333
    printf((char const   * __restrict  )"Saving trianing information to file %s",
           training_filename);
  }
#line 333
  if (quiet == 0) {
#line 333
    printf((char const   * __restrict  )"\n");
  } else
#line 333
  if (debuglevel != 0) {
#line 333
    printf((char const   * __restrict  )"\n");
  }
#line 333
  if (debuglevel > 0) {
#line 333
    tmp___1 = ctime((time_t const   *)(& tttt));
#line 333
    printf((char const   * __restrict  )"    [%s]<%s():line %u> %s\n", "src/csuCommonSubspace.c",
           "writeSubspace", 333, tmp___1);
  }
#line 333
  fflush(stdout);
#line 335
  file = fopen((char const   * __restrict  )training_filename, (char const   * __restrict  )"wb");
#line 336
  if (! file) {
#line 337
    printf((char const   * __restrict  )"Error: could not open file <%s>\n", training_filename);
#line 338
    exit(1);
  }
#line 341
  fprintf((FILE * __restrict  )file, (char const   * __restrict  )"TRAINING_COMMAND =");
#line 343
  i = 0;
#line 343
  while (i < argc) {
#line 344
    fprintf((FILE * __restrict  )file, (char const   * __restrict  )" %s", *(argv + i));
#line 343
    i ++;
  }
#line 346
  fprintf((FILE * __restrict  )file, (char const   * __restrict  )"\n");
#line 347
  tmp___2 = ctime((time_t const   *)(& ttt));
#line 347
  fprintf((FILE * __restrict  )file, (char const   * __restrict  )"DATE          = %s",
          tmp___2);
#line 348
  fprintf((FILE * __restrict  )file, (char const   * __restrict  )"FILE_LIST     = %s\n",
          imageList);
#line 349
  fprintf((FILE * __restrict  )file, (char const   * __restrict  )"VECTOR_LENGTH = %d\n",
          (s->basis)->row_dim);
#line 350
  if (s->useLDA) {
#line 350
    tmp___3 = "YES";
  } else {
#line 350
    tmp___3 = "NO";
  }
#line 350
  fprintf((FILE * __restrict  )file, (char const   * __restrict  )"USE_LDA       = %s\n",
          tmp___3);
#line 352
  fprintf((FILE * __restrict  )file, (char const   * __restrict  )"CUTOFF_MODE   = %s\n",
          cutOffModeStr);
#line 353
  fprintf((FILE * __restrict  )file, (char const   * __restrict  )"CUTOFF_PERCENTAGE  = %f\n",
          s->cutOff);
#line 354
  fprintf((FILE * __restrict  )file, (char const   * __restrict  )"BASIS_VALUE_COUNT  = %d\n",
          (s->values)->row_dim);
#line 355
  fprintf((FILE * __restrict  )file, (char const   * __restrict  )"BASIS_VECTOR_COUNT = %d\n",
          (s->basis)->col_dim);
#line 356
  fprintf((FILE * __restrict  )file, (char const   * __restrict  )"DROPPED_FROM_FRONT = %d\n",
          s->dropNVectors);
#line 358
  i = 11;
#line 358
  while (i < 256) {
#line 359
    fprintf((FILE * __restrict  )file, (char const   * __restrict  )"\n");
#line 358
    i ++;
  }
#line 363
  writeInt(file, (s->mean)->row_dim);
#line 366
  i = 0;
#line 366
  while (i < (s->mean)->row_dim) {
#line 367
    writeDouble(file, *(*((s->mean)->cols + 0) + i));
#line 366
    i ++;
  }
#line 371
  writeInt(file, (s->values)->row_dim);
#line 374
  i = 0;
#line 374
  while (i < (s->values)->row_dim) {
#line 375
    writeDouble(file, *(*((s->values)->cols + 0) + i));
#line 374
    i ++;
  }
#line 379
  writeInt(file, (s->basis)->col_dim);
#line 382
  i = 0;
#line 382
  while (i < (s->basis)->col_dim) {
#line 383
    j = 0;
#line 383
    while (j < (s->basis)->row_dim) {
#line 384
      writeDouble(file, *(*((s->basis)->cols + i) + j));
#line 383
      j ++;
    }
#line 382
    i ++;
  }
#line 387
  fclose(file);
#line 388
  return;
}
}
#line 399 "src/csuCommonSubspace.c"
void readSubspace(Subspace *s , char const   *trainingFile , int quiet___0 ) 
{ 
  int i ;
  int j ;
  int headerSize ;
  int rowDim ;
  int colDim ;
  char junk[512] ;
  char text[512] ;
  char **header ;
  FILE *file ;
  void *tmp ;
  void *tmp___0 ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___2 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  time_t tttt ;
  time_t tmp___8 ;
  char *tmp___9 ;

  {
#line 407
  headerSize = 255;
#line 408
  tmp = malloc(sizeof(char *) * (unsigned long )headerSize);
#line 408
  header = (char **)tmp;
#line 409
  if (! header) {
#line 409
    __assert_fail("header", "src/csuCommonSubspace.c", 409U, "readSubspace");
  }
#line 410
  i = 0;
#line 410
  while (i < headerSize) {
#line 411
    tmp___0 = malloc(sizeof(char ) * 512UL);
#line 411
    *(header + i) = (char *)tmp___0;
#line 412
    if (! *(header + i)) {
#line 412
      __assert_fail("header[i]", "src/csuCommonSubspace.c", 412U, "readSubspace");
    }
#line 410
    i ++;
  }
#line 415
  file = fopen((char const   * __restrict  )trainingFile, (char const   * __restrict  )"rb");
#line 417
  if (! file) {
#line 418
    printf((char const   * __restrict  )"Error: could not open file <%s>\n", trainingFile);
#line 419
    exit(1);
  }
#line 422
  i = 0;
#line 422
  while (i < headerSize) {
#line 423
    fgets((char * __restrict  )*(header + i), 512, (FILE * __restrict  )file);
#line 422
    i ++;
  }
#line 425
  if (! quiet___0) {
#line 426
    printf((char const   * __restrict  )"\nTraining Header File is:\n");
#line 427
    i = 0;
#line 427
    while (i < 10) {
#line 428
      printf((char const   * __restrict  )"   Line %d: %s", i, *(header + i));
#line 427
      i ++;
    }
  }
#line 431
  sscanf((char const   * __restrict  )*(header + 7), (char const   * __restrict  )"%s%s%d",
         junk, junk, & s->basisDim);
#line 432
  sscanf((char const   * __restrict  )*(header + 4), (char const   * __restrict  )"%s%*s%s",
         junk, text);
#line 434
  if (0) {
#line 434
    __s1_len = __builtin_strlen((char const   *)(text));
#line 434
    __s2_len = __builtin_strlen("NO");
#line 434
    if (! ((size_t )((void const   *)(text + 1)) - (size_t )((void const   *)(text)) == 1UL)) {
#line 434
      goto _L___0;
    } else
#line 434
    if (__s1_len >= 4UL) {
      _L___0: /* CIL Label */ 
#line 434
      if (! ((size_t )((void const   *)("NO" + 1)) - (size_t )((void const   *)"NO") == 1UL)) {
#line 434
        tmp___7 = 1;
      } else
#line 434
      if (__s2_len >= 4UL) {
#line 434
        tmp___7 = 1;
      } else {
#line 434
        tmp___7 = 0;
      }
    } else {
#line 434
      tmp___7 = 0;
    }
#line 434
    if (tmp___7) {
#line 434
      tmp___2 = __builtin_strcmp((char const   *)(text), "NO");
#line 434
      tmp___6 = tmp___2;
    } else {
#line 434
      tmp___5 = __builtin_strcmp((char const   *)(text), "NO");
#line 434
      tmp___6 = tmp___5;
    }
  } else {
#line 434
    tmp___5 = __builtin_strcmp((char const   *)(text), "NO");
#line 434
    tmp___6 = tmp___5;
  }
#line 434
  if (tmp___6 == 0) {
#line 435
    s->useLDA = 0;
  } else {
#line 437
    s->useLDA = 1;
  }
#line 439
  readInt(file, & rowDim);
#line 440
  s->numPixels = rowDim;
#line 441
  if (3 <= debuglevel) {
#line 441
    tmp___8 = time((time_t *)0);
#line 441
    tttt = tmp___8;
#line 441
    tmp___9 = ctime((time_t const   *)(& tttt));
#line 441
    printf((char const   * __restrict  )"**DEBUG %d** \"%s\" %s=%d\n             at [%s]<%s():line %u>\n             %s\n",
           3, "Vector size", "rowDim", rowDim, "src/csuCommonSubspace.c", "readSubspace",
           441, tmp___9);
#line 441
    fflush(stdout);
  }
#line 442
  s->mean = makeMatrix(rowDim, 1);
#line 443
  i = 0;
#line 443
  while (i < (s->mean)->row_dim) {
#line 444
    readDouble(file, *((s->mean)->cols + 0) + i);
#line 443
    i ++;
  }
#line 447
  readInt(file, & rowDim);
#line 448
  s->values = makeMatrix(rowDim, 1);
#line 449
  i = 0;
#line 449
  while (i < (s->values)->row_dim) {
#line 450
    readDouble(file, *((s->values)->cols + 0) + i);
#line 449
    i ++;
  }
#line 453
  rowDim = s->numPixels;
#line 454
  readInt(file, & colDim);
#line 455
  s->basis = makeMatrix(rowDim, colDim);
#line 456
  i = 0;
#line 456
  while (i < (s->basis)->col_dim) {
#line 457
    j = 0;
#line 457
    while (j < (s->basis)->row_dim) {
#line 458
      readDouble(file, *((s->basis)->cols + i) + j);
#line 457
      j ++;
    }
#line 456
    i ++;
  }
#line 462
  fclose(file);
#line 463
  return;
}
}
#line 465 "src/csuCommonSubspace.c"
void validateBasisIsOrthonormal(Matrix basis , int printlevel ) 
{ 
  int i ;
  int j ;
  double tolerance ;
  Matrix test ;
  Matrix tmp ;
  double tmp___0 ;
  double tmp___1 ;

  {
#line 469
  tolerance = 0.000001;
#line 470
  tmp = transposeMultiplyMatrixL((Matrix const   )basis, (Matrix const   )basis);
#line 470
  test = tmp;
#line 472
  i = 0;
#line 472
  while (i < test->row_dim) {
#line 473
    j = 0;
#line 473
    while (j < test->col_dim) {
#line 474
      if (i == j) {
#line 475
        if (*(*(test->cols + j) + i) - 1.0 < (double )0) {
#line 475
          tmp___0 = - (*(*(test->cols + j) + i) - 1.0);
        } else {
#line 475
          tmp___0 = *(*(test->cols + j) + i) - 1.0;
        }
#line 475
        if (tmp___0 > tolerance) {
#line 476
          fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"WARNING: Subspace basis failed orthonormality check at (%d, %d) value: %f\n",
                  i, j, *(*(test->cols + j) + i));
        }
      } else {
#line 479
        if (*(*(test->cols + j) + i) < (double )0) {
#line 479
          tmp___1 = - *(*(test->cols + j) + i);
        } else {
#line 479
          tmp___1 = *(*(test->cols + j) + i);
        }
#line 479
        if (tmp___1 > tolerance) {
#line 480
          fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"WARNING: Subspace basis failed orthonormality check at (%d, %d) value: %f\n",
                  i, j, *(*(test->cols + j) + i));
        }
      }
#line 473
      j ++;
    }
#line 472
    i ++;
  }
#line 485
  if (printlevel > 0) {
#line 486
    printf((char const   * __restrict  )"\nSubspace Basis Passed Orthonormality Check");
  }
#line 487
  return;
}
}
#line 489 "src/csuCommonSubspace.c"
Matrix centerThenProjectImages(Subspace *s , Matrix images ) 
{ 
  Matrix subspims ;

  {
#line 494
  mean_subtract_images(images, s->mean);
#line 495
  subspims = transposeMultiplyMatrixL((Matrix const   )s->basis, (Matrix const   )images);
#line 496
  return (subspims);
}
}
#line 553 "src/csuCommonSubspace.c"
Matrix readAndProjectImages(Subspace *s , char *imageNamesFile , char *imageDirectory ,
                            int *numImages , ImageList **srt ) 
{ 
  int i ;
  int j ;
  Matrix images ;
  Matrix vector ;
  Matrix smallVector ;
  char name[512] ;
  ImageList *subject ;
  ImageList *replicate ;
  time_t tttt ;
  time_t tmp ;
  char *tmp___0 ;
  time_t tttt___0 ;
  time_t tmp___1 ;
  char *tmp___2 ;
  time_t tttt___1 ;
  time_t tmp___3 ;
  char *tmp___4 ;
  time_t tttt___2 ;
  time_t tmp___5 ;
  char *tmp___6 ;
  int tmp___7 ;
  time_t tttt___3 ;
  time_t tmp___8 ;
  char *tmp___9 ;
  time_t tttt___4 ;
  time_t tmp___10 ;
  char *tmp___11 ;
  time_t tttt___5 ;
  time_t tmp___12 ;
  char *tmp___13 ;

  {
#line 569
  if (1 <= debuglevel) {
#line 569
    tmp = time((time_t *)0);
#line 569
    tttt = tmp;
#line 569
    tmp___0 = ctime((time_t const   *)(& tttt));
#line 569
    printf((char const   * __restrict  )"**DEBUG %d** \"%s\"\n             at [%s]<%s():line %u>\n             %s\n",
           1, "Reading training file names from file", "src/csuCommonSubspace.c",
           "readAndProjectImages", 569, tmp___0);
#line 569
    fflush(stdout);
  }
#line 574
  *srt = getImageNames(imageNamesFile, numImages);
#line 577
  if (! *srt) {
#line 577
    tmp___1 = time((time_t *)0);
#line 577
    tttt___0 = tmp___1;
#line 577
    tmp___2 = ctime((time_t const   *)(& tttt___0));
#line 577
    printf((char const   * __restrict  )"**DEBUG CHECK** Failed check (%s) \"%s\"\n             at [%s]<%s():line %u>\n             %s\n",
           "*srt", "Error: header no imagenames found in file image list file", "src/csuCommonSubspace.c",
           "readAndProjectImages", 577, tmp___2);
#line 577
    fflush(stdout);
#line 577
    exit(1);
  }
#line 580
  sprintf((char * __restrict  )(name), (char const   * __restrict  )"%s/%s", imageDirectory,
          (*srt)->filename);
#line 581
  if (1 <= debuglevel) {
#line 581
    tmp___3 = time((time_t *)0);
#line 581
    tttt___1 = tmp___3;
#line 581
    tmp___4 = ctime((time_t const   *)(& tttt___1));
#line 581
    printf((char const   * __restrict  )"**DEBUG %d** \"%s\"\n             at [%s]<%s():line %u>\n             %s\n",
           1, "Autodetecting number of pixels, i.e. vector length based on the size of image 0.",
           "src/csuCommonSubspace.c", "readAndProjectImages", 581, tmp___4);
#line 581
    fflush(stdout);
  }
#line 582
  tmp___7 = autoFileLength((char const   *)(name));
#line 582
  if (! (tmp___7 == s->numPixels)) {
#line 582
    tmp___5 = time((time_t *)0);
#line 582
    tttt___2 = tmp___5;
#line 582
    tmp___6 = ctime((time_t const   *)(& tttt___2));
#line 582
    printf((char const   * __restrict  )"**DEBUG CHECK** Failed check (%s) \"%s\"\n             at [%s]<%s():line %u>\n             %s\n",
           "autoFileLength(name) == s->numPixels", "Images sizes do not match subspace basis vector size",
           "src/csuCommonSubspace.c", "readAndProjectImages", 582, tmp___6);
#line 582
    fflush(stdout);
#line 582
    exit(1);
  }
#line 583
  if (1 <= debuglevel) {
#line 583
    tmp___8 = time((time_t *)0);
#line 583
    tttt___3 = tmp___8;
#line 583
    tmp___9 = ctime((time_t const   *)(& tttt___3));
#line 583
    printf((char const   * __restrict  )"**DEBUG %d** \"%s\" %s=%d\n             at [%s]<%s():line %u>\n             %s\n",
           1, "Vector length", "s->numPixels", s->numPixels, "src/csuCommonSubspace.c",
           "readAndProjectImages", 583, tmp___9);
#line 583
    fflush(stdout);
  }
#line 584
  if (! (s->numPixels > 0)) {
#line 584
    tmp___10 = time((time_t *)0);
#line 584
    tttt___4 = tmp___10;
#line 584
    tmp___11 = ctime((time_t const   *)(& tttt___4));
#line 584
    printf((char const   * __restrict  )"**DEBUG CHECK** Failed check (%s) \"%s\"\n             at [%s]<%s():line %u>\n             %s\n",
           "s->numPixels > 0", "Error positive value required for a Vector Length",
           "src/csuCommonSubspace.c", "readAndProjectImages", 584, tmp___11);
#line 584
    fflush(stdout);
#line 584
    exit(1);
  }
#line 587
  if (1 <= debuglevel) {
#line 587
    tmp___12 = time((time_t *)0);
#line 587
    tttt___5 = tmp___12;
#line 587
    tmp___13 = ctime((time_t const   *)(& tttt___5));
#line 587
    printf((char const   * __restrict  )"**DEBUG %d** \"%s\"\n             at [%s]<%s():line %u>\n             %s\n",
           1, "Allocating image matrix", "src/csuCommonSubspace.c", "readAndProjectImages",
           587, tmp___13);
#line 587
    fflush(stdout);
  }
#line 589
  images = makeMatrix((s->basis)->col_dim, *numImages + 1);
#line 657
  i = 0;
#line 658
  vector = makeMatrix(s->numPixels, 1);
#line 659
  subject = *srt;
#line 659
  while (subject) {
#line 660
    replicate = subject;
#line 660
    while (replicate) {
#line 661
      if (debuglevel > 0) {
#line 662
        printf((char const   * __restrict  )"%s ", replicate->filename);
      }
#line 663
      sprintf((char * __restrict  )(name), (char const   * __restrict  )"%s/%s", imageDirectory,
              replicate->filename);
#line 664
      replicate->imageIndex = i;
#line 665
      readFile((char const   *)(name), 0, vector);
#line 667
      writeProgress((char *)"Reading images", i, *numImages);
#line 668
      smallVector = centerThenProjectImages(s, vector);
#line 671
      j = 0;
#line 671
      while (j < smallVector->row_dim) {
#line 672
        *(*(images->cols + i) + j) = *(*(smallVector->cols + 0) + j);
#line 671
        j ++;
      }
#line 674
      freeMatrix(smallVector);
#line 675
      i ++;
#line 660
      replicate = replicate->next_replicate;
    }
#line 677
    if (debuglevel > 0) {
#line 678
      printf((char const   * __restrict  )"\n");
    }
#line 659
    subject = subject->next_subject;
  }
#line 682
  return (images);
}
}
#line 693 "src/csuCommonSubspace.c"
void basis_normalize(Matrix eigenvectors ) 
{ 
  int i ;
  int j ;
  double sumsqr ;
  double inv_len ;
  double tmp ;

  {
#line 698
  i = 0;
#line 698
  while (i < eigenvectors->col_dim) {
#line 700
    sumsqr = 0.0;
#line 701
    j = 0;
#line 701
    while (j < eigenvectors->row_dim) {
#line 702
      sumsqr += *(*(eigenvectors->cols + i) + j) * *(*(eigenvectors->cols + i) + j);
#line 701
      j ++;
    }
#line 703
    if (sumsqr != (double )0) {
#line 704
      tmp = sqrt(sumsqr);
#line 704
      inv_len = 1.0 / tmp;
    } else {
#line 706
      inv_len = (double )0;
    }
#line 707
    j = 0;
#line 707
    while (j < eigenvectors->row_dim) {
#line 708
      *(*(eigenvectors->cols + i) + j) *= inv_len;
#line 707
      j ++;
    }
#line 698
    i ++;
  }
#line 710
  return;
}
}
#line 735 "src/csuCommonSubspace.c"
void mean_subtract_images(Matrix images , Matrix mean ) 
{ 
  int i ;
  int j ;

  {
#line 740
  if (! (images->row_dim % 2)) {
#line 740
    if (! "unrolled twice") {
#line 740
      __assert_fail("!(images->row_dim %2) && \"unrolled twice\"", "src/csuCommonSubspace.c",
                    740U, "mean_subtract_images");
    }
  } else {
#line 740
    __assert_fail("!(images->row_dim %2) && \"unrolled twice\"", "src/csuCommonSubspace.c",
                  740U, "mean_subtract_images");
  }
#line 742
  i = 0;
#line 742
  while (i < images->row_dim) {
#line 744
    j = 0;
#line 744
    while (j < images->col_dim) {
#line 745
      *(*(images->cols + j) + i) -= *(*(mean->cols + 0) + i);
#line 746
      *(*(images->cols + j) + (i + 1)) -= *(*(mean->cols + 0) + (i + 1));
#line 744
      j ++;
    }
#line 742
    i += 2;
  }
#line 749
  return;
}
}
#line 761 "src/csuCommonSubspace.c"
Matrix get_mean_image(Matrix images ) 
{ 
  int i ;
  int j ;
  Matrix mean ;
  Matrix tmp ;

  {
#line 765
  tmp = makeMatrix(images->row_dim, 1);
#line 765
  mean = tmp;
#line 767
  i = 0;
#line 767
  while (i < images->row_dim) {
#line 769
    *(*(mean->cols + 0) + i) = 0.0;
#line 770
    j = 0;
#line 770
    while (j < images->col_dim) {
#line 771
      *(*(mean->cols + 0) + i) += *(*(images->cols + j) + i);
#line 770
      j ++;
    }
#line 772
    *(*(mean->cols + 0) + i) /= (double )images->col_dim;
#line 767
    i ++;
  }
#line 775
  return (mean);
}
}
#line 1 "csuCommonCommandLine.o"
#pragma merger("0","/tmp/cil-WNCY6t6A.i","-O3,-Wall")
#line 150 "/usr/include/x86_64-linux-gnu/bits/mathinline.h"
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__, __always_inline__)) __signbitl)(long double __x )  __attribute__((__const__)) ;
#line 150 "/usr/include/x86_64-linux-gnu/bits/mathinline.h"
__inline extern int ( __attribute__((__leaf__, __always_inline__)) __signbitl)(long double __x ) 
{ 
  union __anonunion___u_26___3 __u ;

  {
#line 153
  __u.__l = __x;
#line 154
  return ((__u.__i[2] & 32768) != 0);
}
}
#line 128 "src/csuCommonCommandLine.h"
int readOptionString(int argc , char **argv , int *i , char const   *opt , char **arg ) ;
#line 131
int readOptionYesNo(int argc , char **argv , int *i , char const   *opt , int *flag___0 ) ;
#line 135
int readOptionMatch(int argc , char **argv , int *i , char const   *opt , char const   *arg ) ;
#line 141
int readOptionInt2(int argc , char **argv , int *i , char const   *opt , int *arg1 ,
                   int *arg2 ) ;
#line 144
int readOptionDouble(int argc , char **argv , int *i , char const   *opt , double *arg ) ;
#line 147
int readOptionDouble2(int argc , char **argv , int *i , char const   *opt , double *arg1 ,
                      double *arg2 ) ;
#line 150
int readOptionDouble4(int argc , char **argv , int *i , char const   *opt , double *arg1 ,
                      double *arg2 , double *arg3 , double *arg4 ) ;
#line 89 "src/csuCommonCommandLine.c"
int readOption(int argc , char **argv , int *i , char const   *opt ) 
{ 
  int tmp ;

  {
#line 90
  if (*i < argc) {
#line 91
    tmp = strcasecmp((char const   *)*(argv + *i), opt);
#line 91
    if (tmp == 0) {
#line 92
      return (1);
    }
  } else {
#line 96
    clParseError(argc, argv, *i, (char *)"Error parsing command line.");
  }
#line 99
  return (0);
}
}
#line 103 "src/csuCommonCommandLine.c"
int readOptionString(int argc , char **argv , int *i , char const   *opt , char **arg ) 
{ 
  int tmp ;

  {
#line 104
  if (*i < argc) {
#line 105
    tmp = strcasecmp((char const   *)*(argv + *i), opt);
#line 105
    if (tmp == 0) {
#line 106
      (*i) ++;
#line 107
      if (*i < argc) {
#line 108
        *arg = *(argv + *i);
      } else {
#line 110
        clParseError(argc, argv, *i, (char *)"Option expects one argument.");
      }
#line 113
      return (1);
    }
  } else {
#line 117
    clParseError(argc, argv, *i, (char *)"Error parsing command line.");
  }
#line 120
  return (0);
}
}
#line 124 "src/csuCommonCommandLine.c"
int readOptionYesNo(int argc , char **argv , int *i , char const   *opt , int *flag___0 ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 125
  if (*i < argc) {
#line 126
    tmp___1 = strcasecmp((char const   *)*(argv + *i), opt);
#line 126
    if (tmp___1 == 0) {
#line 127
      (*i) ++;
#line 128
      if (*i < argc) {
#line 129
        tmp___0 = strcasecmp((char const   *)*(argv + *i), "YES");
#line 129
        if (tmp___0 == 0) {
#line 130
          *flag___0 = 1;
#line 131
          return (1);
        } else {
#line 133
          tmp = strcasecmp((char const   *)*(argv + *i), "NO");
#line 133
          if (tmp == 0) {
#line 134
            *flag___0 = 0;
#line 135
            return (1);
          } else {
#line 138
            clParseError(argc, argv, *i, (char *)"Option expects YES or NO.");
          }
        }
      } else {
#line 141
        clParseError(argc, argv, *i, (char *)"Option expects YES or NO.");
      }
#line 144
      return (1);
    }
  } else {
#line 148
    clParseError(argc, argv, *i, (char *)"Error parsing command line.");
  }
#line 151
  return (0);
}
}
#line 157 "src/csuCommonCommandLine.c"
int readOptionMatch(int argc , char **argv , int *i , char const   *opt , char const   *arg ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 158
  if (*i < argc) {
#line 159
    tmp___0 = strcasecmp((char const   *)*(argv + *i), opt);
#line 159
    if (tmp___0 == 0) {
#line 160
      if (*i < argc) {
#line 161
        tmp = strcasecmp((char const   *)*(argv + (*i + 1)), arg);
#line 161
        if (tmp == 0) {
#line 163
          (*i) ++;
#line 164
          return (1);
        }
      } else {
#line 167
        clParseError(argc, argv, *i, (char *)"Option expects one argument");
      }
#line 170
      return (0);
    }
  } else {
#line 174
    clParseError(argc, argv, *i, (char *)"Error parsing command line.");
  }
#line 177
  return (0);
}
}
#line 181 "src/csuCommonCommandLine.c"
int readOptionInt(int argc , char **argv , int *i , char const   *opt , int *arg ) 
{ 
  int tmp ;

  {
#line 182
  if (*i < argc) {
#line 183
    tmp = strcasecmp((char const   *)*(argv + *i), opt);
#line 183
    if (tmp == 0) {
#line 184
      (*i) ++;
#line 185
      if (*i < argc) {
#line 186
        *arg = atoi((char const   *)*(argv + *i));
#line 187
        return (1);
      } else {
#line 189
        clParseError(argc, argv, *i, (char *)"Option expects one argument");
      }
#line 192
      return (0);
    }
  } else {
#line 196
    clParseError(argc, argv, *i, (char *)"Error parsing command line.");
  }
#line 199
  return (0);
}
}
#line 203 "src/csuCommonCommandLine.c"
int readOptionInt2(int argc , char **argv , int *i , char const   *opt , int *arg1 ,
                   int *arg2 ) 
{ 
  int tmp ;

  {
#line 204
  if (*i < argc) {
#line 205
    tmp = strcasecmp((char const   *)*(argv + *i), opt);
#line 205
    if (tmp == 0) {
#line 207
      (*i) ++;
#line 208
      if (*i < argc) {
#line 209
        *arg1 = atoi((char const   *)*(argv + *i));
      } else {
#line 211
        clParseError(argc, argv, *i, (char *)"Option expects two arguments");
      }
#line 215
      (*i) ++;
#line 216
      if (*i < argc) {
#line 217
        *arg2 = atoi((char const   *)*(argv + *i));
#line 218
        return (1);
      } else {
#line 220
        clParseError(argc, argv, *i, (char *)"Option expects two arguments");
      }
#line 223
      return (0);
    }
  } else {
#line 227
    clParseError(argc, argv, *i, (char *)"Error parsing command line.");
  }
#line 230
  return (0);
}
}
#line 234 "src/csuCommonCommandLine.c"
int readOptionDouble(int argc , char **argv , int *i , char const   *opt , double *arg ) 
{ 
  int tmp ;

  {
#line 235
  if (*i < argc) {
#line 236
    tmp = strcasecmp((char const   *)*(argv + *i), opt);
#line 236
    if (tmp == 0) {
#line 237
      (*i) ++;
#line 238
      if (*i < argc) {
#line 239
        *arg = atof((char const   *)*(argv + *i));
#line 240
        return (1);
      } else {
#line 242
        clParseError(argc, argv, *i, (char *)"Option expects one argument");
      }
#line 245
      return (0);
    }
  } else {
#line 249
    clParseError(argc, argv, *i, (char *)"Error parsing command line.");
  }
#line 252
  return (0);
}
}
#line 256 "src/csuCommonCommandLine.c"
int readOptionDouble2(int argc , char **argv , int *i , char const   *opt , double *arg1 ,
                      double *arg2 ) 
{ 
  int tmp ;

  {
#line 257
  if (*i < argc) {
#line 258
    tmp = strcasecmp((char const   *)*(argv + *i), opt);
#line 258
    if (tmp == 0) {
#line 260
      (*i) ++;
#line 261
      if (*i < argc) {
#line 262
        *arg1 = atof((char const   *)*(argv + *i));
      } else {
#line 264
        clParseError(argc, argv, *i, (char *)"Option expects two arguments");
      }
#line 268
      (*i) ++;
#line 269
      if (*i < argc) {
#line 270
        *arg2 = atof((char const   *)*(argv + *i));
#line 271
        return (1);
      } else {
#line 273
        clParseError(argc, argv, *i, (char *)"Option expects two arguments");
      }
#line 276
      return (0);
    }
  } else {
#line 280
    clParseError(argc, argv, *i, (char *)"Error parsing command line.");
  }
#line 283
  return (0);
}
}
#line 288 "src/csuCommonCommandLine.c"
int readOptionDouble4(int argc , char **argv , int *i , char const   *opt , double *arg1 ,
                      double *arg2 , double *arg3 , double *arg4 ) 
{ 
  int tmp ;

  {
#line 289
  if (*i < argc) {
#line 290
    tmp = strcasecmp((char const   *)*(argv + *i), opt);
#line 290
    if (tmp == 0) {
#line 292
      (*i) ++;
#line 293
      if (*i < argc) {
#line 294
        *arg1 = atof((char const   *)*(argv + *i));
      } else {
#line 296
        clParseError(argc, argv, *i, (char *)"Option expects four arguments");
      }
#line 300
      (*i) ++;
#line 301
      if (*i < argc) {
#line 302
        *arg2 = atof((char const   *)*(argv + *i));
      } else {
#line 304
        clParseError(argc, argv, *i, (char *)"Option expects four arguments");
      }
#line 308
      (*i) ++;
#line 309
      if (*i < argc) {
#line 310
        *arg3 = atof((char const   *)*(argv + *i));
      } else {
#line 312
        clParseError(argc, argv, *i, (char *)"Option expects four arguments");
      }
#line 316
      (*i) ++;
#line 317
      if (*i < argc) {
#line 318
        *arg4 = atof((char const   *)*(argv + *i));
#line 319
        return (1);
      } else {
#line 321
        clParseError(argc, argv, *i, (char *)"Option expects four arguments");
      }
#line 324
      return (0);
    }
  } else {
#line 328
    clParseError(argc, argv, *i, (char *)"Error parsing command line.");
  }
#line 331
  return (0);
}
}
#line 341 "src/csuCommonCommandLine.c"
int checkBadOption(int argc , char **argv , int *i ) 
{ 


  {
#line 342
  if (*i < argc) {
#line 343
    if ((int )*(*(argv + *i) + 0) == 45) {
#line 344
      clParseError(argc, argv, *i, (char *)"Unrecognized option.");
    }
  } else {
#line 348
    clParseError(argc, argv, *i, (char *)"Error parsing command line.");
  }
#line 351
  return (0);
}
}
#line 355 "src/csuCommonCommandLine.c"
void clParseError(int argc , char **argv , int i , char *message ) 
{ 
  char const   *tmp ;
  char const   *tmp___0 ;

  {
#line 356
  fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )"Error: %s\n",
          message);
#line 357
  if (i < argc) {
#line 357
    tmp = (char const   *)*(argv + i);
  } else {
#line 357
    tmp = "(Error: passed end of line)";
  }
#line 357
  fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )"       for command at command line argument <%d: %s >\n",
          i, tmp);
#line 358
  if (0 < argc) {
#line 358
    tmp___0 = (char const   *)*(argv + 0);
  } else {
#line 358
    tmp___0 = "(Error: No program name)";
  }
#line 358
  usage(tmp___0);
#line 359
  exit(1);
}
}
#line 1 "csuCommonImage.o"
#pragma merger("0","/tmp/cil-CvYxkppl.i","-O3,-Wall")
#line 109 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h"
extern  __attribute__((__nothrow__)) double ( __attribute__((__leaf__)) log)(double __x ) ;
#line 185
extern  __attribute__((__nothrow__)) double ( __attribute__((__leaf__)) floor)(double __x )  __attribute__((__const__)) ;
#line 150 "/usr/include/x86_64-linux-gnu/bits/mathinline.h"
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__, __always_inline__)) __signbitl)(long double __x )  __attribute__((__const__)) ;
#line 150 "/usr/include/x86_64-linux-gnu/bits/mathinline.h"
__inline extern int ( __attribute__((__leaf__, __always_inline__)) __signbitl)(long double __x ) 
{ 
  union __anonunion___u_26___4 __u ;

  {
#line 153
  __u.__l = __x;
#line 154
  return ((__u.__i[2] & 32768) != 0);
}
}
#line 94 "src/csuCommonImage.h"
Image makeImage(int width , int height , int channels ) ;
#line 95
Image makeZeroImage(int width , int height , int channels ) ;
#line 96
void freeImage(Image i ) ;
#line 98
Image duplicateImage(Image im ) ;
#line 104
double randBM(void) ;
#line 111
double ie(Image im , int x , int y , int c ) ;
#line 119
double interpLinear(Image img , double x , double y , int c ) ;
#line 126
Image convolveImage(Image const   im , Image const   mask ) ;
#line 128
double convolvePoint(double x , double y , int c , Image const   im , Image const   mask ) ;
#line 130
void contrastImage(Image im , double scalar ) ;
#line 133
void brightnessImage(Image im , double scalar ) ;
#line 136
void ZeroMeanUnitLength(Image im ) ;
#line 138
void ZeroMeanUnitLengthMasked(Image im , char const   **mask ) ;
#line 141
void ZeroMeanOneStdDev(Image im ) ;
#line 143
void ZeroMeanOneStdDevMasked(Image im , char const   **mask ) ;
#line 146
double correlateImages(Image const   i1 , Image const   i2 ) ;
#line 148
double dotImages(Image const   i1 , Image const   i2 ) ;
#line 154
Image accumulateChannels(Image const   im ) ;
#line 157
void accumulateImages(Image i1 , Image const   i2 ) ;
#line 166
double gaussianNoise(Image im , double noise ) ;
#line 170
void histEqual(Image im , int N ) ;
#line 171
void histEqualMask(Image im , int N , char const   **mask ) ;
#line 172
void histEqualRect(Image im , int N , int top , int left , int bottom , int right ) ;
#line 175
void ZeroBorder(Image im ) ;
#line 178
void smoothImageEdge(Image im , int width ) ;
#line 181
void applyMask(Image im , char const   **mask ) ;
#line 184
char **imageToMask(Image im , int c ) ;
#line 186
double imageMax(Image im , char const   **mask ) ;
#line 187
double imageMin(Image im , char const   **mask ) ;
#line 188
double imageMean(Image im , char const   **mask ) ;
#line 189
double imageVariance(Image im , char const   **mask ) ;
#line 190
double imageStdDev(Image im , char const   **mask ) ;
#line 191
double imageMedian(Image im , char const   **mask ) ;
#line 192
double imageMad(Image im , char const   **mask ) ;
#line 193
int imageNumOfPixels(Image im , char const   **mask ) ;
#line 195
void markPoint(Image im , double X , double Y ) ;
#line 197
Image makeThermalColorImage(Image im ) ;
#line 199
Image makeThermalComboImage(Image thrm , Image bw ) ;
#line 204
Image readPGMImage(char const   *filename ) ;
#line 205
Image readRawImage(char const   *fname ) ;
#line 206
Image readFeretImage(char const   *fname , int width , int height , int channels ) ;
#line 208
void writePGMImage(Image const   im , char const   *filename , int channel ) ;
#line 209
void writePPMImage(Image const   im , char const   *filename ) ;
#line 210
void writeRawImage(Image const   im , char const   *fname ) ;
#line 211
void writeFeretImage(Image const   im , char const   *fname ) ;
#line 220
void computeImageStatistics(ImageStatistics *is , Image im ) ;
#line 221
void computeImageStatisticsMask(ImageStatistics *is , Image im , char const   **mask ) ;
#line 222
void computeImageStatisticsLocal(ImageStatistics *is , Image im , int xt , int yt ,
                                 int dist ) ;
#line 87 "src/csuCommonImage.c"
int ImageIsMachineLittleEndian(void) 
{ 
  int flag___0 ;
  char magic[4] ;
  unsigned long *longMagic ;

  {
#line 89
  magic[0] = (char)1;
#line 89
  magic[1] = (char)2;
#line 89
  magic[2] = (char)3;
#line 89
  magic[3] = (char)4;
#line 90
  longMagic = (unsigned long *)(magic);
#line 91
  if (*longMagic == 16909060UL) {
#line 92
    flag___0 = 0;
  } else
#line 93
  if (*longMagic == 67305985UL) {
#line 94
    flag___0 = 1;
  } else {
#line 96
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Funky Byte Order, I give Up!!\n");
#line 97
    exit(1);
  }
#line 99
  return (flag___0);
}
}
#line 107 "src/csuCommonImage.c"
static int iset  =    0;
#line 108 "src/csuCommonImage.c"
static double gset  ;
#line 106 "src/csuCommonImage.c"
double randBM(void) 
{ 
  double v1 ;
  double v2 ;
  double fac ;
  double rsq ;
  long tmp ;
  double tmp___0 ;
  long tmp___1 ;
  double tmp___2 ;
  double tmp___3 ;

  {
#line 110
  if (iset == 0) {
#line 113
    while (1) {
#line 114
      tmp = random();
#line 114
      tmp___0 = fabs((double )tmp / (double )2147483647);
#line 114
      v1 = 2.0 * tmp___0 - 1.0;
#line 115
      tmp___1 = random();
#line 115
      tmp___2 = fabs((double )tmp___1 / (double )2147483647);
#line 115
      v2 = 2.0 * tmp___2 - 1.0;
#line 116
      rsq = v1 * v1 + v2 * v2;
#line 113
      if (! (rsq >= 1.0)) {
#line 113
        if (! (rsq == (double )0)) {
#line 113
          break;
        }
      }
    }
#line 120
    tmp___3 = log(rsq);
#line 120
    fac = sqrt(((double )-2 * tmp___3) / rsq);
#line 121
    gset = v1 * fac;
#line 122
    iset = 1;
#line 123
    return (v2 * fac);
  } else {
#line 127
    iset = 0;
#line 128
    return (gset);
  }
}
}
#line 135 "src/csuCommonImage.c"
Image makeImage(int width , int height , int channels ) 
{ 
  int x ;
  int y ;
  Image i ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;

  {
#line 137
  tmp = malloc(sizeof(image ));
#line 137
  i = (Image )tmp;
#line 138
  if (! i) {
#line 138
    __assert_fail("i", "src/csuCommonImage.c", 138U, "makeImage");
  }
#line 139
  tmp___0 = malloc(sizeof(double **) * (unsigned long )width);
#line 139
  i->data = (double ***)tmp___0;
#line 140
  if (! i->data) {
#line 140
    __assert_fail("i->data", "src/csuCommonImage.c", 140U, "makeImage");
  }
#line 142
  x = 0;
#line 142
  while (x < width) {
#line 143
    tmp___1 = malloc(sizeof(double *) * (unsigned long )height);
#line 143
    *(i->data + x) = (double **)tmp___1;
#line 144
    if (! *(i->data + x)) {
#line 144
      __assert_fail("i->data[x]", "src/csuCommonImage.c", 144U, "makeImage");
    }
#line 145
    y = 0;
#line 145
    while (y < height) {
#line 146
      tmp___2 = malloc(sizeof(double ) * (unsigned long )channels);
#line 146
      *(*(i->data + x) + y) = (double *)tmp___2;
#line 147
      if (! *(*(i->data + x) + y)) {
#line 147
        __assert_fail("i->data[x][y]", "src/csuCommonImage.c", 147U, "makeImage");
      }
#line 145
      y ++;
    }
#line 142
    x ++;
  }
#line 151
  i->width = width;
#line 152
  i->height = height;
#line 153
  i->channels = channels;
#line 155
  return (i);
}
}
#line 159 "src/csuCommonImage.c"
Image makeZeroImage(int width , int height , int channels ) 
{ 
  Image im ;
  Image tmp ;
  int i ;
  int j ;
  int c ;

  {
#line 160
  tmp = makeImage(width, height, channels);
#line 160
  im = tmp;
#line 163
  i = 0;
#line 163
  while (i < im->width) {
#line 164
    j = 0;
#line 164
    while (j < im->height) {
#line 165
      c = 0;
#line 165
      while (c < im->channels) {
#line 166
        *(*(*(im->data + i) + j) + c) = 0.0;
#line 165
        c ++;
      }
#line 164
      j ++;
    }
#line 163
    i ++;
  }
#line 170
  return (im);
}
}
#line 174 "src/csuCommonImage.c"
Image duplicateImage(Image im ) 
{ 
  Image output ;
  Image tmp ;
  int i ;
  int j ;
  int c ;

  {
#line 175
  tmp = makeImage(im->width, im->height, im->channels);
#line 175
  output = tmp;
#line 178
  j = 0;
#line 178
  while (j < output->height) {
#line 179
    i = 0;
#line 179
    while (i < output->width) {
#line 180
      c = 0;
#line 180
      while (c < output->channels) {
#line 181
        *(*(*(output->data + i) + j) + c) = *(*(*(im->data + i) + j) + c);
#line 180
        c ++;
      }
#line 179
      i ++;
    }
#line 178
    j ++;
  }
#line 186
  return (output);
}
}
#line 192 "src/csuCommonImage.c"
double ie(Image im , int x , int y , int c ) 
{ 
  double out ;
  double tmp ;

  {
#line 193
  if (x < im->width) {
#line 193
    if (y < im->height) {
#line 193
      if (c < im->channels) {
#line 193
        if (x >= 0) {
#line 193
          if (y >= 0) {
#line 193
            if (c >= 0) {
#line 193
              tmp = *(*(*(im->data + x) + y) + c);
            } else {
#line 193
              tmp = 0.0;
            }
          } else {
#line 193
            tmp = 0.0;
          }
        } else {
#line 193
          tmp = 0.0;
        }
      } else {
#line 193
        tmp = 0.0;
      }
    } else {
#line 193
      tmp = 0.0;
    }
  } else {
#line 193
    tmp = 0.0;
  }
#line 193
  out = tmp;
#line 195
  return (out);
}
}
#line 205 "src/csuCommonImage.c"
double interpLinear(Image img , double x , double y , int c ) 
{ 
  double xfrac ;
  double tmp ;
  double yfrac ;
  double tmp___0 ;
  int xLower ;
  int xUpper ;
  int yLower ;
  int yUpper ;
  double valUpper ;
  double valLower ;
  double tmp___1 ;
  double tmp___2 ;
  double tmp___3 ;
  double tmp___4 ;

  {
#line 206
  tmp = floor(x);
#line 206
  xfrac = x - tmp;
#line 207
  tmp___0 = floor(y);
#line 207
  yfrac = y - tmp___0;
#line 208
  xLower = (int )x;
#line 209
  xUpper = (int )x + 1;
#line 210
  yLower = (int )y;
#line 211
  yUpper = (int )y + 1;
#line 214
  tmp___1 = ie(img, xLower, yUpper, c);
#line 214
  tmp___2 = ie(img, xUpper, yUpper, c);
#line 214
  valUpper = tmp___1 * (1.0 - xfrac) + tmp___2 * xfrac;
#line 215
  tmp___3 = ie(img, xLower, yLower, c);
#line 215
  tmp___4 = ie(img, xUpper, yLower, c);
#line 215
  valLower = tmp___3 * (1.0 - xfrac) + tmp___4 * xfrac;
#line 217
  return (valLower * (1.0 - yfrac) + valUpper * yfrac);
}
}
#line 221 "src/csuCommonImage.c"
void freeImage(Image i ) 
{ 
  int x ;
  int y ;

  {
#line 223
  if ((unsigned long )i == (unsigned long )((Image )0)) {
#line 224
    printf((char const   * __restrict  )"Warning: free null image\n");
#line 225
    return;
  }
#line 227
  x = 0;
#line 227
  while (x < i->width) {
#line 228
    y = 0;
#line 228
    while (y < i->height) {
#line 229
      free((void *)*(*(i->data + x) + y));
#line 228
      y ++;
    }
#line 231
    free((void *)*(i->data + x));
#line 227
    x ++;
  }
#line 233
  free((void *)i->data);
#line 234
  free((void *)i);
#line 235
  return;
}
}
#line 240 "src/csuCommonImage.c"
Image readPGMImage(char const   *filename ) 
{ 
  int width ;
  int height ;
  int max ;
  int x ;
  int y ;
  unsigned int val ;
  char fchar ;
  char line[100] ;
  char ftype[16] ;
  FILE *infile ;
  Image im ;
  FILE *tmp ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___1 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;

  {
#line 251
  tmp = fopen((char const   * __restrict  )filename, (char const   * __restrict  )"rb");
#line 251
  infile = tmp;
#line 252
  if (! infile) {
#line 252
    __assert_fail("infile", "src/csuCommonImage.c", 252U, "readPGMImage");
  }
#line 254
  fgets((char * __restrict  )(line), 100, (FILE * __restrict  )infile);
#line 255
  sscanf((char const   * __restrict  )(line), (char const   * __restrict  )" %s",
         ftype);
#line 257
  if (0) {
#line 257
    __s1_len = __builtin_strlen((char const   *)(ftype));
#line 257
    __s2_len = __builtin_strlen("P5");
#line 257
    if (! ((size_t )((void const   *)(ftype + 1)) - (size_t )((void const   *)(ftype)) == 1UL)) {
#line 257
      goto _L___0;
    } else
#line 257
    if (__s1_len >= 4UL) {
      _L___0: /* CIL Label */ 
#line 257
      if (! ((size_t )((void const   *)("P5" + 1)) - (size_t )((void const   *)"P5") == 1UL)) {
#line 257
        tmp___6 = 1;
      } else
#line 257
      if (__s2_len >= 4UL) {
#line 257
        tmp___6 = 1;
      } else {
#line 257
        tmp___6 = 0;
      }
    } else {
#line 257
      tmp___6 = 0;
    }
#line 257
    if (tmp___6) {
#line 257
      tmp___1 = __builtin_strcmp((char const   *)(ftype), "P5");
#line 257
      tmp___5 = tmp___1;
    } else {
#line 257
      tmp___4 = __builtin_strcmp((char const   *)(ftype), "P5");
#line 257
      tmp___5 = tmp___4;
    }
  } else {
#line 257
    tmp___4 = __builtin_strcmp((char const   *)(ftype), "P5");
#line 257
    tmp___5 = tmp___4;
  }
#line 257
  if (! (tmp___5 == 0)) {
#line 258
    printf((char const   * __restrict  )"Error <%s,%d>: Currenlty only binary pgm files, type P5, supported",
           "src/csuCommonImage.c", 258);
#line 258
    fflush(stdout);
#line 259
    exit(1);
  }
#line 264
  fchar = (char )'#';
#line 265
  while ((int )fchar == 35) {
#line 266
    fgets((char * __restrict  )(line), 100, (FILE * __restrict  )infile);
#line 267
    sscanf((char const   * __restrict  )(line), (char const   * __restrict  )" %c",
           & fchar);
  }
#line 269
  sscanf((char const   * __restrict  )(line), (char const   * __restrict  )" %d %d",
         & width, & height);
#line 273
  fchar = (char )'#';
#line 274
  while ((int )fchar == 35) {
#line 275
    fgets((char * __restrict  )(line), 100, (FILE * __restrict  )infile);
#line 276
    sscanf((char const   * __restrict  )(line), (char const   * __restrict  )" %c",
           & fchar);
  }
#line 278
  sscanf((char const   * __restrict  )(line), (char const   * __restrict  )"%d", & max);
#line 280
  if (! (max == 255)) {
#line 281
    fprintf((FILE * __restrict  )stdout, (char const   * __restrict  )"readImagePGM: Warning, max value %d for pixels in image %s is not 255\n",
            max, filename);
#line 281
    fflush(stdout);
  }
#line 284
  im = makeImage(width, height, 1);
#line 286
  tmp___7 = fgetc(infile);
#line 286
  val = (unsigned int )tmp___7;
#line 287
  y = 0;
#line 287
  while (y < height) {
#line 288
    x = 0;
#line 288
    while (x < width) {
#line 289
      if (val == 4294967295U) {
#line 290
        printf((char const   * __restrict  )"Error <%s,%d>: Unexpected end of file: %s",
               "src/csuCommonImage.c", 290, filename);
#line 290
        fflush(stdout);
#line 291
        exit(1);
      }
#line 294
      *(*(*(im->data + x) + y) + 0) = (double )((unsigned char )val);
#line 295
      tmp___8 = fgetc(infile);
#line 295
      val = (unsigned int )tmp___8;
#line 288
      x ++;
    }
#line 287
    y ++;
  }
#line 299
  fclose(infile);
#line 301
  return (im);
}
}
#line 321 "src/csuCommonImage.c"
Image readRawImage(char const   *fname ) 
{ 
  int i ;
  int j ;
  int c ;
  FILE *f ;
  NUM junk ;
  char firstline[1000] ;
  char ftype[1000] ;
  Image im ;
  size_t __s1_len ;
  size_t __s2_len ;
  int tmp___0 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  size_t __s1_len___0 ;
  size_t __s2_len___0 ;
  int tmp___7 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;

  {
#line 331
  f = fopen((char const   * __restrict  )fname, (char const   * __restrict  )"rb");
#line 332
  if (! f) {
#line 332
    printf((char const   * __restrict  )"Can\'t open %s\n", fname);
#line 332
    exit(1);
  }
#line 334
  fgets((char * __restrict  )(firstline), 1000, (FILE * __restrict  )f);
#line 335
  sscanf((char const   * __restrict  )(firstline), (char const   * __restrict  )"%s %d %d %d",
         ftype, & i, & j, & c);
#line 337
  if (0) {
#line 337
    __s1_len = __builtin_strlen((char const   *)(ftype));
#line 337
    __s2_len = __builtin_strlen("CSU_SFI");
#line 337
    if (! ((size_t )((void const   *)(ftype + 1)) - (size_t )((void const   *)(ftype)) == 1UL)) {
#line 337
      goto _L___0;
    } else
#line 337
    if (__s1_len >= 4UL) {
      _L___0: /* CIL Label */ 
#line 337
      if (! ((size_t )((void const   *)("CSU_SFI" + 1)) - (size_t )((void const   *)"CSU_SFI") == 1UL)) {
#line 337
        tmp___5 = 1;
      } else
#line 337
      if (__s2_len >= 4UL) {
#line 337
        tmp___5 = 1;
      } else {
#line 337
        tmp___5 = 0;
      }
    } else {
#line 337
      tmp___5 = 0;
    }
#line 337
    if (tmp___5) {
#line 337
      tmp___0 = __builtin_strcmp((char const   *)(ftype), "CSU_SFI");
#line 337
      tmp___4 = tmp___0;
    } else {
#line 337
      tmp___3 = __builtin_strcmp((char const   *)(ftype), "CSU_SFI");
#line 337
      tmp___4 = tmp___3;
    }
  } else {
#line 337
    tmp___3 = __builtin_strcmp((char const   *)(ftype), "CSU_SFI");
#line 337
    tmp___4 = tmp___3;
  }
#line 337
  if (! (tmp___4 == 0)) {
#line 337
    if (0) {
#line 337
      __s1_len___0 = __builtin_strlen((char const   *)(ftype));
#line 337
      __s2_len___0 = __builtin_strlen("CSU_RASTER");
#line 337
      if (! ((size_t )((void const   *)(ftype + 1)) - (size_t )((void const   *)(ftype)) == 1UL)) {
#line 337
        goto _L___2;
      } else
#line 337
      if (__s1_len___0 >= 4UL) {
        _L___2: /* CIL Label */ 
#line 337
        if (! ((size_t )((void const   *)("CSU_RASTER" + 1)) - (size_t )((void const   *)"CSU_RASTER") == 1UL)) {
#line 337
          tmp___12 = 1;
        } else
#line 337
        if (__s2_len___0 >= 4UL) {
#line 337
          tmp___12 = 1;
        } else {
#line 337
          tmp___12 = 0;
        }
      } else {
#line 337
        tmp___12 = 0;
      }
#line 337
      if (tmp___12) {
#line 337
        tmp___7 = __builtin_strcmp((char const   *)(ftype), "CSU_RASTER");
#line 337
        tmp___11 = tmp___7;
      } else {
#line 337
        tmp___10 = __builtin_strcmp((char const   *)(ftype), "CSU_RASTER");
#line 337
        tmp___11 = tmp___10;
      }
    } else {
#line 337
      tmp___10 = __builtin_strcmp((char const   *)(ftype), "CSU_RASTER");
#line 337
      tmp___11 = tmp___10;
    }
#line 337
    if (! (tmp___11 == 0)) {
#line 338
      printf((char const   * __restrict  )"Error<%s,%d>: Do not recognize file type \'%s\'\n",
             "src/csuCommonImage.c", 338, ftype);
#line 339
      exit(1);
    }
  }
#line 342
  im = makeImage(i, j, c);
#line 344
  j = 0;
#line 344
  while (j < im->height) {
#line 345
    i = 0;
#line 345
    while (i < im->width) {
#line 346
      c = 0;
#line 346
      while (c < im->channels) {
#line 348
        tmp___13 = ImageIsMachineLittleEndian();
#line 348
        if (tmp___13) {
#line 349
          fread((void * __restrict  )(& junk.elem.d), (size_t )1, (size_t )1, (FILE * __restrict  )f);
#line 350
          fread((void * __restrict  )(& junk.elem.c), (size_t )1, (size_t )1, (FILE * __restrict  )f);
#line 351
          fread((void * __restrict  )(& junk.elem.b), (size_t )1, (size_t )1, (FILE * __restrict  )f);
#line 352
          fread((void * __restrict  )(& junk.elem.a), (size_t )1, (size_t )1, (FILE * __restrict  )f);
        } else {
#line 355
          fread((void * __restrict  )(& junk.elem.a), (size_t )1, (size_t )1, (FILE * __restrict  )f);
#line 356
          fread((void * __restrict  )(& junk.elem.b), (size_t )1, (size_t )1, (FILE * __restrict  )f);
#line 357
          fread((void * __restrict  )(& junk.elem.c), (size_t )1, (size_t )1, (FILE * __restrict  )f);
#line 358
          fread((void * __restrict  )(& junk.elem.d), (size_t )1, (size_t )1, (FILE * __restrict  )f);
        }
#line 367
        *(*(*(im->data + i) + j) + c) = (double )junk.f;
#line 346
        c ++;
      }
#line 345
      i ++;
    }
#line 344
    j ++;
  }
#line 371
  fclose(f);
#line 373
  return (im);
}
}
#line 377 "src/csuCommonImage.c"
void writePGMImage(Image const   im , char const   *filename , int channel ) 
{ 
  FILE *outfile ;
  FILE *tmp ;
  unsigned char pixel ;
  double pmax ;
  double pmin ;
  int x ;
  int y ;
  int tmp___0 ;

  {
#line 378
  tmp = fopen((char const   * __restrict  )filename, (char const   * __restrict  )"wb");
#line 378
  outfile = tmp;
#line 383
  if (! im) {
#line 383
    __assert_fail("im", "src/csuCommonImage.c", 383U, "writePGMImage");
  }
#line 384
  if (! outfile) {
#line 385
    printf((char const   * __restrict  )"could not open %s for writing.\n", filename);
#line 386
    exit(1);
  }
#line 388
  fprintf((FILE * __restrict  )outfile, (char const   * __restrict  )"P5\n");
#line 389
  fprintf((FILE * __restrict  )outfile, (char const   * __restrict  )"%d %d\n", im->width,
          im->height);
#line 390
  fprintf((FILE * __restrict  )outfile, (char const   * __restrict  )"%d\n", 255);
#line 392
  pmax = *(*(*(im->data + 0) + 0) + channel);
#line 393
  pmin = *(*(*(im->data + 0) + 0) + channel);
#line 395
  x = 0;
#line 395
  while (x < im->width) {
#line 396
    y = 0;
#line 396
    while (y < im->height) {
#line 397
      if (*(*(*(im->data + x) + y) + channel) < pmax) {
#line 397
        pmax = pmax;
      } else {
#line 397
        pmax = *(*(*(im->data + x) + y) + channel);
      }
#line 398
      if (*(*(*(im->data + x) + y) + channel) > pmin) {
#line 398
        pmin = pmin;
      } else {
#line 398
        pmin = *(*(*(im->data + x) + y) + channel);
      }
#line 396
      y ++;
    }
#line 395
    x ++;
  }
#line 403
  y = 0;
#line 403
  while (y < im->height) {
#line 404
    x = 0;
#line 404
    while (x < im->width) {
#line 405
      if (pmax - pmin <= (double )0) {
#line 406
        pixel = (unsigned char)0;
      } else {
#line 409
        tmp___0 = (int )(((double )255 * (*(*(*(im->data + x) + y) + channel) - pmin)) / (pmax - pmin) + 0.5);
#line 410
        if (tmp___0 < 0) {
#line 410
          tmp___0 = 0;
        }
#line 411
        if (tmp___0 > 255) {
#line 411
          tmp___0 = 255;
        }
#line 412
        pixel = (unsigned char )tmp___0;
      }
#line 414
      fputc((int )pixel, outfile);
#line 404
      x ++;
    }
#line 403
    y ++;
  }
#line 419
  fclose(outfile);
#line 420
  return;
}
}
#line 422 "src/csuCommonImage.c"
void writePPMImage(Image const   im , char const   *filename ) 
{ 
  FILE *outfile ;
  FILE *tmp ;
  unsigned char pixel ;
  double pmax ;
  double pmin ;
  int x ;
  int y ;
  int c ;
  int tmp___0 ;

  {
#line 423
  tmp = fopen((char const   * __restrict  )filename, (char const   * __restrict  )"wb");
#line 423
  outfile = tmp;
#line 428
  if (! im) {
#line 428
    __assert_fail("im", "src/csuCommonImage.c", 428U, "writePPMImage");
  }
#line 429
  if (! (im->channels == 3)) {
#line 429
    __assert_fail("im->channels == 3", "src/csuCommonImage.c", 429U, "writePPMImage");
  }
#line 430
  if (! outfile) {
#line 431
    printf((char const   * __restrict  )"could not open %s for writing.\n", filename);
#line 432
    exit(1);
  }
#line 434
  fprintf((FILE * __restrict  )outfile, (char const   * __restrict  )"P6\n");
#line 435
  fprintf((FILE * __restrict  )outfile, (char const   * __restrict  )"%d %d\n", im->width,
          im->height);
#line 436
  fprintf((FILE * __restrict  )outfile, (char const   * __restrict  )"%d\n", 255);
#line 438
  pmax = *(*(*(im->data + 0) + 0) + 0);
#line 439
  pmin = *(*(*(im->data + 0) + 0) + 0);
#line 441
  x = 0;
#line 441
  while (x < im->width) {
#line 442
    y = 0;
#line 442
    while (y < im->height) {
#line 443
      c = 0;
#line 443
      while (c < im->channels) {
#line 444
        if (*(*(*(im->data + x) + y) + c) < pmax) {
#line 444
          pmax = pmax;
        } else {
#line 444
          pmax = *(*(*(im->data + x) + y) + c);
        }
#line 445
        if (*(*(*(im->data + x) + y) + c) > pmin) {
#line 445
          pmin = pmin;
        } else {
#line 445
          pmin = *(*(*(im->data + x) + y) + c);
        }
#line 443
        c ++;
      }
#line 442
      y ++;
    }
#line 441
    x ++;
  }
#line 450
  y = 0;
#line 450
  while (y < im->height) {
#line 451
    x = 0;
#line 451
    while (x < im->width) {
#line 452
      c = 0;
#line 452
      while (c < im->channels) {
#line 453
        if (pmax - pmin <= (double )0) {
#line 454
          pixel = (unsigned char)0;
        } else {
#line 457
          tmp___0 = (int )(((double )255 * (*(*(*(im->data + x) + y) + c) - pmin)) / (pmax - pmin) + 0.5);
#line 458
          if (tmp___0 < 0) {
#line 458
            tmp___0 = 0;
          }
#line 459
          if (tmp___0 > 255) {
#line 459
            tmp___0 = 255;
          }
#line 460
          pixel = (unsigned char )tmp___0;
        }
#line 462
        fputc((int )pixel, outfile);
#line 452
        c ++;
      }
#line 451
      x ++;
    }
#line 450
    y ++;
  }
#line 468
  fclose(outfile);
#line 469
  return;
}
}
#line 471 "src/csuCommonImage.c"
void writeRawImage(Image const   im , char const   *fname ) 
{ 
  int i ;
  int j ;
  int c ;
  FILE *f ;
  NUM junk ;
  int tmp ;

  {
#line 477
  f = fopen((char const   * __restrict  )fname, (char const   * __restrict  )"wb");
#line 478
  if (! f) {
#line 478
    printf((char const   * __restrict  )"Can\'t open %s\n", fname);
#line 478
    exit(1);
  }
#line 480
  fprintf((FILE * __restrict  )f, (char const   * __restrict  )"%s %d %d %d\n", "CSU_SFI",
          im->width, im->height, im->channels);
#line 483
  j = 0;
#line 483
  while (j < im->height) {
#line 484
    i = 0;
#line 484
    while (i < im->width) {
#line 485
      c = 0;
#line 485
      while (c < im->channels) {
#line 487
        junk.f = (float )*(*(*(im->data + i) + j) + c);
#line 501
        tmp = ImageIsMachineLittleEndian();
#line 501
        if (tmp) {
#line 502
          fwrite((void const   * __restrict  )(& junk.elem.d), (size_t )1, (size_t )1,
                 (FILE * __restrict  )f);
#line 503
          fwrite((void const   * __restrict  )(& junk.elem.c), (size_t )1, (size_t )1,
                 (FILE * __restrict  )f);
#line 504
          fwrite((void const   * __restrict  )(& junk.elem.b), (size_t )1, (size_t )1,
                 (FILE * __restrict  )f);
#line 505
          fwrite((void const   * __restrict  )(& junk.elem.a), (size_t )1, (size_t )1,
                 (FILE * __restrict  )f);
        } else {
#line 508
          fwrite((void const   * __restrict  )(& junk.elem.a), (size_t )1, (size_t )1,
                 (FILE * __restrict  )f);
#line 509
          fwrite((void const   * __restrict  )(& junk.elem.b), (size_t )1, (size_t )1,
                 (FILE * __restrict  )f);
#line 510
          fwrite((void const   * __restrict  )(& junk.elem.c), (size_t )1, (size_t )1,
                 (FILE * __restrict  )f);
#line 511
          fwrite((void const   * __restrict  )(& junk.elem.d), (size_t )1, (size_t )1,
                 (FILE * __restrict  )f);
        }
#line 485
        c ++;
      }
#line 484
      i ++;
    }
#line 483
    j ++;
  }
#line 517
  fclose(f);
#line 519
  return;
}
}
#line 522 "src/csuCommonImage.c"
Image readFeretImage(char const   *fname , int width , int height , int channels ) 
{ 
  int i ;
  int j ;
  int c ;
  FILE *f ;
  NUM junk ;
  Image im ;
  int tmp ;

  {
#line 530
  f = fopen((char const   * __restrict  )fname, (char const   * __restrict  )"rb");
#line 531
  if (! f) {
#line 531
    printf((char const   * __restrict  )"Can\'t open %s\n", fname);
#line 531
    exit(1);
  }
#line 533
  im = makeImage(width, height, channels);
#line 535
  j = 0;
#line 535
  while (j < im->height) {
#line 536
    i = 0;
#line 536
    while (i < im->width) {
#line 537
      c = 0;
#line 537
      while (c < im->channels) {
#line 539
        tmp = ImageIsMachineLittleEndian();
#line 539
        if (tmp) {
#line 540
          fread((void * __restrict  )(& junk.elem.d), (size_t )1, (size_t )1, (FILE * __restrict  )f);
#line 541
          fread((void * __restrict  )(& junk.elem.c), (size_t )1, (size_t )1, (FILE * __restrict  )f);
#line 542
          fread((void * __restrict  )(& junk.elem.b), (size_t )1, (size_t )1, (FILE * __restrict  )f);
#line 543
          fread((void * __restrict  )(& junk.elem.a), (size_t )1, (size_t )1, (FILE * __restrict  )f);
        } else {
#line 546
          fread((void * __restrict  )(& junk.elem.a), (size_t )1, (size_t )1, (FILE * __restrict  )f);
#line 547
          fread((void * __restrict  )(& junk.elem.b), (size_t )1, (size_t )1, (FILE * __restrict  )f);
#line 548
          fread((void * __restrict  )(& junk.elem.c), (size_t )1, (size_t )1, (FILE * __restrict  )f);
#line 549
          fread((void * __restrict  )(& junk.elem.d), (size_t )1, (size_t )1, (FILE * __restrict  )f);
        }
#line 558
        *(*(*(im->data + i) + j) + c) = (double )junk.f;
#line 537
        c ++;
      }
#line 536
      i ++;
    }
#line 535
    j ++;
  }
#line 562
  fclose(f);
#line 564
  return (im);
}
}
#line 568 "src/csuCommonImage.c"
void writeFeretImage(Image const   im , char const   *fname ) 
{ 
  int i ;
  int j ;
  int c ;
  FILE *f ;
  NUM junk ;
  int tmp ;

  {
#line 574
  f = fopen((char const   * __restrict  )fname, (char const   * __restrict  )"wb");
#line 575
  if (! f) {
#line 575
    printf((char const   * __restrict  )"Can\'t open %s\n", fname);
#line 575
    exit(1);
  }
#line 577
  j = 0;
#line 577
  while (j < im->height) {
#line 578
    i = 0;
#line 578
    while (i < im->width) {
#line 579
      c = 0;
#line 579
      while (c < im->channels) {
#line 581
        junk.f = (float )*(*(*(im->data + i) + j) + c);
#line 596
        tmp = ImageIsMachineLittleEndian();
#line 596
        if (tmp) {
#line 597
          fwrite((void const   * __restrict  )(& junk.elem.d), (size_t )1, (size_t )1,
                 (FILE * __restrict  )f);
#line 598
          fwrite((void const   * __restrict  )(& junk.elem.c), (size_t )1, (size_t )1,
                 (FILE * __restrict  )f);
#line 599
          fwrite((void const   * __restrict  )(& junk.elem.b), (size_t )1, (size_t )1,
                 (FILE * __restrict  )f);
#line 600
          fwrite((void const   * __restrict  )(& junk.elem.a), (size_t )1, (size_t )1,
                 (FILE * __restrict  )f);
        } else {
#line 603
          fwrite((void const   * __restrict  )(& junk.elem.a), (size_t )1, (size_t )1,
                 (FILE * __restrict  )f);
#line 604
          fwrite((void const   * __restrict  )(& junk.elem.b), (size_t )1, (size_t )1,
                 (FILE * __restrict  )f);
#line 605
          fwrite((void const   * __restrict  )(& junk.elem.c), (size_t )1, (size_t )1,
                 (FILE * __restrict  )f);
#line 606
          fwrite((void const   * __restrict  )(& junk.elem.d), (size_t )1, (size_t )1,
                 (FILE * __restrict  )f);
        }
#line 579
        c ++;
      }
#line 578
      i ++;
    }
#line 577
    j ++;
  }
#line 612
  fclose(f);
#line 614
  return;
}
}
#line 616 "src/csuCommonImage.c"
double convolvePoint(double x , double y , int c , Image const   im , Image const   mask ) 
{ 
  int i ;
  int j ;
  double mysum ;
  double offsetx ;
  double offsety ;
  double tmp ;
  double tmp___0 ;
  double tmp___1 ;
  double tmp___2 ;

  {
#line 618
  mysum = (double )0;
#line 619
  offsetx = (x - (double )mask->width / 2.0) - 0.5;
#line 620
  offsety = (y - (double )mask->height / 2.0) - 0.5;
#line 622
  if (offsetx - (double )((int )offsetx) < (double )0) {
#line 622
    tmp___1 = - (offsetx - (double )((int )offsetx));
  } else {
#line 622
    tmp___1 = offsetx - (double )((int )offsetx);
  }
#line 622
  if (tmp___1 < .01) {
#line 622
    if (offsetx - (double )((int )offsetx) < (double )0) {
#line 622
      tmp___2 = - (offsetx - (double )((int )offsetx));
    } else {
#line 622
      tmp___2 = offsetx - (double )((int )offsetx);
    }
#line 622
    if (tmp___2 < .01) {
#line 623
      mysum = (double )0;
#line 624
      j = 0;
#line 624
      while (j < mask->height) {
#line 625
        i = 0;
#line 625
        while (i < mask->width) {
#line 626
          tmp = ie((Image )im, i + (int )offsetx, j + (int )offsety, c);
#line 626
          mysum += tmp * *(*(*(mask->data + i) + j) + c);
#line 625
          i ++;
        }
#line 624
        j ++;
      }
    } else {
#line 622
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
#line 631
    mysum = (double )0;
#line 632
    j = 0;
#line 632
    while (j < mask->height) {
#line 633
      i = 0;
#line 633
      while (i < mask->width) {
#line 634
        tmp___0 = interpLinear((Image )im, (double )i + offsetx, (double )j + offsety,
                               c);
#line 634
        mysum += tmp___0 * *(*(*(mask->data + i) + j) + c);
#line 633
        i ++;
      }
#line 632
      j ++;
    }
  }
#line 644
  return (mysum);
}
}
#line 650 "src/csuCommonImage.c"
Image convolveImage(Image const   im , Image const   mask ) 
{ 
  Image output ;
  Image tmp ;
  int x ;
  int y ;
  int c ;

  {
#line 651
  tmp = makeImage(im->width, im->height, im->channels);
#line 651
  output = tmp;
#line 654
  y = 0;
#line 654
  while (y < output->height) {
#line 655
    x = 0;
#line 655
    while (x < output->width) {
#line 656
      c = 0;
#line 656
      while (c < output->channels) {
#line 657
        *(*(*(output->data + x) + y) + c) = convolvePoint((double )x, (double )y,
                                                          c, im, mask);
#line 656
        c ++;
      }
#line 655
      x ++;
    }
#line 654
    y ++;
  }
#line 662
  return (output);
}
}
#line 667 "src/csuCommonImage.c"
void contrastImage(Image im , double scalar ) 
{ 
  int i ;
  int j ;
  int c ;

  {
#line 670
  j = 0;
#line 670
  while (j < im->height) {
#line 671
    i = 0;
#line 671
    while (i < im->width) {
#line 672
      c = 0;
#line 672
      while (c < im->channels) {
#line 673
        *(*(*(im->data + i) + j) + c) *= scalar;
#line 672
        c ++;
      }
#line 671
      i ++;
    }
#line 670
    j ++;
  }
#line 678
  return;
}
}
#line 680 "src/csuCommonImage.c"
void brightnessImage(Image im , double scalar ) 
{ 
  int i ;
  int j ;
  int c ;

  {
#line 683
  j = 0;
#line 683
  while (j < im->height) {
#line 684
    i = 0;
#line 684
    while (i < im->width) {
#line 685
      c = 0;
#line 685
      while (c < im->channels) {
#line 686
        *(*(*(im->data + i) + j) + c) += scalar;
#line 685
        c ++;
      }
#line 684
      i ++;
    }
#line 683
    j ++;
  }
#line 691
  return;
}
}
#line 694 "src/csuCommonImage.c"
void ZeroMeanUnitLength(Image im ) 
{ 
  int i ;
  int j ;
  int c ;
  double mean ;
  double sqrsum ;
  double invlength ;
  double tmp ;

  {
#line 697
  mean = (double )0;
#line 697
  sqrsum = (double )0;
#line 697
  invlength = (double )0;
#line 699
  j = 0;
#line 699
  while (j < im->height) {
#line 700
    i = 0;
#line 700
    while (i < im->width) {
#line 701
      c = 0;
#line 701
      while (c < im->channels) {
#line 702
        mean += *(*(*(im->data + i) + j) + c);
#line 701
        c ++;
      }
#line 700
      i ++;
    }
#line 699
    j ++;
  }
#line 707
  mean /= (double )((im->height * im->width) * im->channels);
#line 710
  j = 0;
#line 710
  while (j < im->height) {
#line 711
    i = 0;
#line 711
    while (i < im->width) {
#line 712
      c = 0;
#line 712
      while (c < im->channels) {
#line 713
        *(*(*(im->data + i) + j) + c) -= mean;
#line 714
        sqrsum += *(*(*(im->data + i) + j) + c) * *(*(*(im->data + i) + j) + c);
#line 712
        c ++;
      }
#line 711
      i ++;
    }
#line 710
    j ++;
  }
#line 720
  if (sqrsum != (double )0) {
#line 721
    tmp = sqrt(sqrsum);
#line 721
    invlength = 1.0 / tmp;
  } else {
#line 723
    invlength = 1.0;
  }
#line 726
  j = 0;
#line 726
  while (j < im->height) {
#line 727
    i = 0;
#line 727
    while (i < im->width) {
#line 728
      c = 0;
#line 728
      while (c < im->channels) {
#line 729
        *(*(*(im->data + i) + j) + c) *= invlength;
#line 728
        c ++;
      }
#line 727
      i ++;
    }
#line 726
    j ++;
  }
#line 734
  return;
}
}
#line 738 "src/csuCommonImage.c"
void ZeroMeanUnitLengthMasked(Image im , char const   **mask ) 
{ 
  int i ;
  int j ;
  int c ;
  double mean ;
  double sqrsum ;
  double invlength ;
  int pixels ;
  double tmp ;

  {
#line 742
  mean = (double )0;
#line 742
  sqrsum = (double )0;
#line 742
  invlength = (double )0;
#line 743
  pixels = 0;
#line 745
  j = 0;
#line 745
  while (j < im->height) {
#line 746
    i = 0;
#line 746
    while (i < im->width) {
#line 747
      c = 0;
#line 747
      while (c < im->channels) {
#line 748
        if (! mask) {
#line 749
          mean += *(*(*(im->data + i) + j) + c);
#line 750
          pixels ++;
        } else
#line 748
        if (*(*(mask + i) + j)) {
#line 749
          mean += *(*(*(im->data + i) + j) + c);
#line 750
          pixels ++;
        }
#line 747
        c ++;
      }
#line 746
      i ++;
    }
#line 745
    j ++;
  }
#line 756
  mean /= (double )pixels;
#line 758
  j = 0;
#line 758
  while (j < im->height) {
#line 759
    i = 0;
#line 759
    while (i < im->width) {
#line 760
      c = 0;
#line 760
      while (c < im->channels) {
#line 761
        if (! mask) {
#line 762
          *(*(*(im->data + i) + j) + c) -= mean;
#line 763
          sqrsum += *(*(*(im->data + i) + j) + c) * *(*(*(im->data + i) + j) + c);
        } else
#line 761
        if (*(*(mask + i) + j)) {
#line 762
          *(*(*(im->data + i) + j) + c) -= mean;
#line 763
          sqrsum += *(*(*(im->data + i) + j) + c) * *(*(*(im->data + i) + j) + c);
        }
#line 760
        c ++;
      }
#line 759
      i ++;
    }
#line 758
    j ++;
  }
#line 769
  if (sqrsum != (double )0) {
#line 770
    tmp = sqrt(sqrsum);
#line 770
    invlength = 1.0 / tmp;
  } else {
#line 772
    invlength = 1.0;
  }
#line 775
  j = 0;
#line 775
  while (j < im->height) {
#line 776
    i = 0;
#line 776
    while (i < im->width) {
#line 777
      c = 0;
#line 777
      while (c < im->channels) {
#line 778
        if (! mask) {
#line 779
          *(*(*(im->data + i) + j) + c) *= invlength;
        } else
#line 778
        if (*(*(mask + i) + j)) {
#line 779
          *(*(*(im->data + i) + j) + c) *= invlength;
        } else {
#line 782
          *(*(*(im->data + i) + j) + c) = 0.0;
        }
#line 777
        c ++;
      }
#line 776
      i ++;
    }
#line 775
    j ++;
  }
#line 787
  return;
}
}
#line 789 "src/csuCommonImage.c"
void smoothImageEdge(Image im , int width ) 
{ 
  int i ;
  int x ;
  int y ;
  int c ;
  double scale ;

  {
#line 791
  i = 0;
#line 791
  while (i < width) {
#line 792
    scale = (double )i / (double )width;
#line 795
    x = 0;
#line 795
    while (x < im->width) {
#line 796
      c = 0;
#line 796
      while (c < im->channels) {
#line 797
        *(*(*(im->data + x) + i) + c) *= scale;
#line 798
        *(*(*(im->data + x) + ((im->height - i) - 1)) + c) *= scale;
#line 796
        c ++;
      }
#line 795
      x ++;
    }
#line 802
    y = 0;
#line 802
    while (y < im->height) {
#line 803
      c = 0;
#line 803
      while (c < im->channels) {
#line 804
        *(*(*(im->data + i) + y) + c) *= scale;
#line 805
        *(*(*(im->data + ((im->width - i) - 1)) + y) + c) *= scale;
#line 803
        c ++;
      }
#line 802
      y ++;
    }
#line 791
    i ++;
  }
#line 810
  return;
}
}
#line 813 "src/csuCommonImage.c"
void ZeroMeanOneStdDev(Image im ) 
{ 


  {
#line 814
  ZeroMeanOneStdDevMasked(im, (char const   **)((void *)0));
#line 815
  return;
}
}
#line 818 "src/csuCommonImage.c"
void ZeroMeanOneStdDevMasked(Image im , char const   **mask ) 
{ 
  int i ;
  int j ;
  int c ;
  double sum ;
  double sqsum ;
  double mean ;
  double vari ;
  double stddev ;
  double invlength ;
  int pixels ;

  {
#line 822
  sum = 0.0;
#line 823
  sqsum = 0.0;
#line 828
  pixels = 0;
#line 830
  j = 0;
#line 830
  while (j < im->height) {
#line 831
    i = 0;
#line 831
    while (i < im->width) {
#line 832
      c = 0;
#line 832
      while (c < im->channels) {
#line 833
        if (! mask) {
#line 834
          sum += *(*(*(im->data + i) + j) + c);
#line 835
          sqsum += *(*(*(im->data + i) + j) + c) * *(*(*(im->data + i) + j) + c);
#line 836
          pixels ++;
        } else
#line 833
        if (*(*(mask + i) + j)) {
#line 834
          sum += *(*(*(im->data + i) + j) + c);
#line 835
          sqsum += *(*(*(im->data + i) + j) + c) * *(*(*(im->data + i) + j) + c);
#line 836
          pixels ++;
        }
#line 832
        c ++;
      }
#line 831
      i ++;
    }
#line 830
    j ++;
  }
#line 842
  mean = sum / (double )pixels;
#line 843
  vari = sqsum / (double )pixels - mean * mean;
#line 844
  stddev = sqrt(vari);
#line 846
  invlength = 1.0 / stddev;
#line 848
  j = 0;
#line 848
  while (j < im->height) {
#line 849
    i = 0;
#line 849
    while (i < im->width) {
#line 850
      c = 0;
#line 850
      while (c < im->channels) {
#line 851
        if (! mask) {
#line 852
          *(*(*(im->data + i) + j) + c) = (*(*(*(im->data + i) + j) + c) - mean) * invlength;
        } else
#line 851
        if (*(*(mask + i) + j)) {
#line 852
          *(*(*(im->data + i) + j) + c) = (*(*(*(im->data + i) + j) + c) - mean) * invlength;
        } else {
#line 855
          *(*(*(im->data + i) + j) + c) = 0.0;
        }
#line 850
        c ++;
      }
#line 849
      i ++;
    }
#line 848
    j ++;
  }
#line 860
  return;
}
}
#line 863 "src/csuCommonImage.c"
double dotImages(Image const   i1 , Image const   i2 ) 
{ 
  double dot ;
  int i ;
  int j ;
  int c ;

  {
#line 864
  dot = (double )0;
#line 867
  if (! (i1->height == i2->height)) {
#line 867
    __assert_fail("i1->height == i2->height", "src/csuCommonImage.c", 867U, "dotImages");
  }
#line 868
  if (! (i1->width == i2->width)) {
#line 868
    __assert_fail("i1->width == i2->width", "src/csuCommonImage.c", 868U, "dotImages");
  }
#line 869
  if (! (i1->channels == i2->channels)) {
#line 869
    __assert_fail("i1->channels == i2->channels", "src/csuCommonImage.c", 869U, "dotImages");
  }
#line 871
  j = 0;
#line 871
  while (j < i1->height) {
#line 872
    i = 0;
#line 872
    while (i < i1->width) {
#line 873
      c = 0;
#line 873
      while (c < i1->channels) {
#line 874
        dot += *(*(*(i1->data + i) + j) + c) * *(*(*(i2->data + i) + j) + c);
#line 873
        c ++;
      }
#line 872
      i ++;
    }
#line 871
    j ++;
  }
#line 879
  return (dot);
}
}
#line 884 "src/csuCommonImage.c"
double correlateImages(Image const   i1 , Image const   i2 ) 
{ 
  int i ;
  int j ;
  int c ;
  double correlation ;
  double i1mean ;
  double i2mean ;
  double i1scale ;
  double i2scale ;
  double tmp ;
  double tmp___0 ;

  {
#line 887
  correlation = 0.0;
#line 888
  i1mean = 0.0;
#line 888
  i2mean = 0.0;
#line 889
  i1scale = 0.0;
#line 889
  i2scale = 0.0;
#line 891
  if (! (i1->height == i2->height)) {
#line 891
    __assert_fail("i1->height == i2->height", "src/csuCommonImage.c", 891U, "correlateImages");
  }
#line 892
  if (! (i1->width == i2->width)) {
#line 892
    __assert_fail("i1->width == i2->width", "src/csuCommonImage.c", 892U, "correlateImages");
  }
#line 893
  if (! (i1->channels == i2->channels)) {
#line 893
    __assert_fail("i1->channels == i2->channels", "src/csuCommonImage.c", 893U, "correlateImages");
  }
#line 896
  j = 0;
#line 896
  while (j < i1->height) {
#line 897
    i = 0;
#line 897
    while (i < i1->width) {
#line 898
      c = 0;
#line 898
      while (c < i1->channels) {
#line 899
        i1mean += *(*(*(i1->data + i) + j) + c);
#line 900
        i2mean += *(*(*(i2->data + i) + j) + c);
#line 898
        c ++;
      }
#line 897
      i ++;
    }
#line 896
    j ++;
  }
#line 904
  i1mean /= (double )((i1->height * i1->width) * i1->channels);
#line 905
  i2mean /= (double )((i2->height * i2->width) * i2->channels);
#line 907
  printf((char const   * __restrict  )"i1mean:  %f\n", i1mean);
#line 908
  printf((char const   * __restrict  )"i2mean:  %f\n", i2mean);
#line 910
  i = 0;
#line 910
  while (i < i1->width) {
#line 911
    j = 0;
#line 911
    while (j < i1->height) {
#line 912
      c = 0;
#line 912
      while (c < i1->channels) {
#line 913
        correlation += (*(*(*(i1->data + i) + j) + c) - i1mean) * (*(*(*(i2->data + i) + j) + c) - i2mean);
#line 914
        i1scale += (*(*(*(i1->data + i) + j) + c) - i1mean) * (*(*(*(i1->data + i) + j) + c) - i1mean);
#line 915
        i2scale += (*(*(*(i2->data + i) + j) + c) - i2mean) * (*(*(*(i2->data + i) + j) + c) - i2mean);
#line 912
        c ++;
      }
#line 911
      j ++;
    }
#line 910
    i ++;
  }
#line 920
  printf((char const   * __restrict  )"i1scale: %f\n", i1scale);
#line 921
  printf((char const   * __restrict  )"i2scale: %f\n", i2scale);
#line 922
  tmp = sqrt(i1scale);
#line 922
  tmp___0 = sqrt(i2scale);
#line 922
  correlation /= tmp * tmp___0;
#line 924
  return (correlation);
}
}
#line 929 "src/csuCommonImage.c"
Image accumulateChannels(Image const   im ) 
{ 
  int x ;
  int y ;
  int c ;
  Image accum ;
  Image tmp ;

  {
#line 931
  tmp = makeZeroImage(im->width, im->height, 1);
#line 931
  accum = tmp;
#line 933
  x = 0;
#line 933
  while (x < im->width) {
#line 934
    y = 0;
#line 934
    while (y < im->height) {
#line 935
      c = 0;
#line 935
      while (c < im->channels) {
#line 936
        *(*(*(accum->data + x) + y) + 0) += *(*(*(im->data + x) + y) + c);
#line 935
        c ++;
      }
#line 934
      y ++;
    }
#line 933
    x ++;
  }
#line 941
  return (accum);
}
}
#line 944 "src/csuCommonImage.c"
void accumulateImages(Image i1 , Image const   i2 ) 
{ 
  int x ;
  int y ;
  int c ;

  {
#line 948
  if (! (i1->height == i2->height)) {
#line 948
    __assert_fail("i1->height == i2->height", "src/csuCommonImage.c", 948U, "accumulateImages");
  }
#line 949
  if (! (i1->width == i2->width)) {
#line 949
    __assert_fail("i1->width == i2->width", "src/csuCommonImage.c", 949U, "accumulateImages");
  }
#line 950
  if (! (i1->channels == i2->channels)) {
#line 950
    __assert_fail("i1->channels == i2->channels", "src/csuCommonImage.c", 950U, "accumulateImages");
  }
#line 952
  x = 0;
#line 952
  while (x < i1->width) {
#line 953
    y = 0;
#line 953
    while (y < i1->height) {
#line 954
      c = 0;
#line 954
      while (c < i1->channels) {
#line 955
        *(*(*(i1->data + x) + y) + c) += *(*(*(i2->data + x) + y) + c);
#line 954
        c ++;
      }
#line 953
      y ++;
    }
#line 952
    x ++;
  }
#line 959
  return;
}
}
#line 1000 "src/csuCommonImage.c"
void histEqual(Image im , int N ) 
{ 
  HistogramBin *bins ;
  void *tmp ;
  double minVal ;
  double maxVal ;
  double binSize ;
  double totalPixels ;
  int x ;
  int y ;
  int c ;
  int tmp___0 ;
  int bin ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  double frac ;
  int bin___0 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;

  {
#line 1001
  tmp = malloc(sizeof(HistogramBin ) * (unsigned long )N);
#line 1001
  bins = (HistogramBin *)tmp;
#line 1003
  totalPixels = (double )((im->width * im->height) * im->channels);
#line 1006
  if (! bins) {
#line 1006
    __assert_fail("bins", "src/csuCommonImage.c", 1006U, "histEqual");
  }
#line 1009
  minVal = *(*(*(im->data + 0) + 0) + 0);
#line 1010
  maxVal = *(*(*(im->data + 0) + 0) + 0);
#line 1011
  x = 0;
#line 1011
  while (x < im->width) {
#line 1012
    y = 0;
#line 1012
    while (y < im->height) {
#line 1013
      c = 0;
#line 1013
      while (c < im->channels) {
#line 1014
        if (minVal > *(*(*(im->data + x) + y) + c)) {
#line 1014
          minVal = *(*(*(im->data + x) + y) + c);
        } else {
#line 1014
          minVal = minVal;
        }
#line 1015
        if (maxVal < *(*(*(im->data + x) + y) + c)) {
#line 1015
          maxVal = *(*(*(im->data + x) + y) + c);
        } else {
#line 1015
          maxVal = maxVal;
        }
#line 1013
        c ++;
      }
#line 1012
      y ++;
    }
#line 1011
    x ++;
  }
#line 1021
  binSize = (maxVal - minVal) / (double )N;
#line 1025
  x = 0;
#line 1025
  while (x < N) {
#line 1025
    (bins + x)->count = 0;
#line 1025
    x ++;
  }
#line 1028
  x = 0;
#line 1028
  while (x < im->width) {
#line 1029
    y = 0;
#line 1029
    while (y < im->height) {
#line 1030
      c = 0;
#line 1030
      while (c < im->channels) {
#line 1031
        tmp___0 = (int )((*(*(*(im->data + x) + y) + c) - minVal) / binSize);
#line 1032
        if (N - 1 > tmp___0) {
#line 1032
          tmp___4 = tmp___0;
        } else {
#line 1032
          tmp___4 = N - 1;
        }
#line 1032
        if (0 < tmp___4) {
#line 1032
          if (N - 1 > tmp___0) {
#line 1032
            tmp___2 = tmp___0;
          } else {
#line 1032
            tmp___2 = N - 1;
          }
#line 1032
          tmp___3 = tmp___2;
        } else {
#line 1032
          tmp___3 = 0;
        }
#line 1032
        bin = tmp___3;
#line 1033
        ((bins + bin)->count) ++;
#line 1030
        c ++;
      }
#line 1029
      y ++;
    }
#line 1028
    x ++;
  }
#line 1039
  c = 0;
#line 1040
  x = 0;
#line 1040
  while (x < N) {
#line 1041
    (bins + x)->rangeStart = (double )c / totalPixels;
#line 1042
    c += (bins + x)->count;
#line 1043
    (bins + x)->rangeEnd = (double )c / totalPixels;
#line 1040
    x ++;
  }
#line 1047
  x = 0;
#line 1047
  while (x < im->width) {
#line 1048
    y = 0;
#line 1048
    while (y < im->height) {
#line 1049
      c = 0;
#line 1049
      while (c < im->channels) {
#line 1050
        tmp___5 = (int )((*(*(*(im->data + x) + y) + c) - minVal) / binSize);
#line 1051
        frac = (*(*(*(im->data + x) + y) + c) - minVal) / binSize - (double )tmp___5;
#line 1052
        if (N - 1 > tmp___5) {
#line 1052
          tmp___9 = tmp___5;
        } else {
#line 1052
          tmp___9 = N - 1;
        }
#line 1052
        if (0 < tmp___9) {
#line 1052
          if (N - 1 > tmp___5) {
#line 1052
            tmp___7 = tmp___5;
          } else {
#line 1052
            tmp___7 = N - 1;
          }
#line 1052
          tmp___8 = tmp___7;
        } else {
#line 1052
          tmp___8 = 0;
        }
#line 1052
        bin___0 = tmp___8;
#line 1055
        *(*(*(im->data + x) + y) + c) = (bins + bin___0)->rangeStart * (1.0 - frac) + (bins + bin___0)->rangeEnd * frac;
#line 1049
        c ++;
      }
#line 1048
      y ++;
    }
#line 1047
    x ++;
  }
#line 1060
  free((void *)bins);
#line 1061
  return;
}
}
#line 1064 "src/csuCommonImage.c"
void histEqualMask(Image im , int N , char const   **mask ) 
{ 
  HistogramBin *bins ;
  void *tmp ;
  double minVal ;
  double maxVal ;
  double binSize ;
  double totalPixels ;
  int x ;
  int y ;
  int c ;
  int tmp___0 ;
  int bin ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  double frac ;
  int bin___0 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;

  {
#line 1065
  tmp = malloc(sizeof(HistogramBin ) * (unsigned long )N);
#line 1065
  bins = (HistogramBin *)tmp;
#line 1067
  totalPixels = 0.0;
#line 1070
  if (! bins) {
#line 1070
    __assert_fail("bins", "src/csuCommonImage.c", 1070U, "histEqualMask");
  }
#line 1073
  minVal = *(*(*(im->data + 0) + 0) + 0);
#line 1074
  maxVal = *(*(*(im->data + 0) + 0) + 0);
#line 1075
  x = 0;
#line 1075
  while (x < im->width) {
#line 1076
    y = 0;
#line 1076
    while (y < im->height) {
#line 1077
      c = 0;
#line 1077
      while (c < im->channels) {
#line 1078
        if (! mask) {
#line 1078
          goto _L;
        } else
#line 1078
        if (*(*(mask + x) + y)) {
          _L: /* CIL Label */ 
#line 1079
          if (minVal > *(*(*(im->data + x) + y) + c)) {
#line 1079
            minVal = *(*(*(im->data + x) + y) + c);
          } else {
#line 1079
            minVal = minVal;
          }
#line 1080
          if (maxVal < *(*(*(im->data + x) + y) + c)) {
#line 1080
            maxVal = *(*(*(im->data + x) + y) + c);
          } else {
#line 1080
            maxVal = maxVal;
          }
#line 1081
          totalPixels += (double )1;
        }
#line 1077
        c ++;
      }
#line 1076
      y ++;
    }
#line 1075
    x ++;
  }
#line 1088
  binSize = (maxVal - minVal) / (double )N;
#line 1092
  x = 0;
#line 1092
  while (x < N) {
#line 1092
    (bins + x)->count = 0;
#line 1092
    x ++;
  }
#line 1095
  x = 0;
#line 1095
  while (x < im->width) {
#line 1096
    y = 0;
#line 1096
    while (y < im->height) {
#line 1097
      c = 0;
#line 1097
      while (c < im->channels) {
#line 1098
        if (! mask) {
#line 1098
          goto _L___0;
        } else
#line 1098
        if (*(*(mask + x) + y)) {
          _L___0: /* CIL Label */ 
#line 1099
          tmp___0 = (int )((*(*(*(im->data + x) + y) + c) - minVal) / binSize);
#line 1100
          if (N - 1 > tmp___0) {
#line 1100
            tmp___4 = tmp___0;
          } else {
#line 1100
            tmp___4 = N - 1;
          }
#line 1100
          if (0 < tmp___4) {
#line 1100
            if (N - 1 > tmp___0) {
#line 1100
              tmp___2 = tmp___0;
            } else {
#line 1100
              tmp___2 = N - 1;
            }
#line 1100
            tmp___3 = tmp___2;
          } else {
#line 1100
            tmp___3 = 0;
          }
#line 1100
          bin = tmp___3;
#line 1101
          ((bins + bin)->count) ++;
        }
#line 1097
        c ++;
      }
#line 1096
      y ++;
    }
#line 1095
    x ++;
  }
#line 1108
  c = 0;
#line 1109
  x = 0;
#line 1109
  while (x < N) {
#line 1110
    (bins + x)->rangeStart = (double )c / totalPixels;
#line 1111
    c += (bins + x)->count;
#line 1112
    (bins + x)->rangeEnd = (double )c / totalPixels;
#line 1109
    x ++;
  }
#line 1116
  x = 0;
#line 1116
  while (x < im->width) {
#line 1117
    y = 0;
#line 1117
    while (y < im->height) {
#line 1118
      c = 0;
#line 1118
      while (c < im->channels) {
#line 1119
        if (! mask) {
#line 1119
          goto _L___1;
        } else
#line 1119
        if (*(*(mask + x) + y)) {
          _L___1: /* CIL Label */ 
#line 1120
          tmp___5 = (int )((*(*(*(im->data + x) + y) + c) - minVal) / binSize);
#line 1121
          frac = (*(*(*(im->data + x) + y) + c) - minVal) / binSize - (double )tmp___5;
#line 1122
          if (N - 1 > tmp___5) {
#line 1122
            tmp___9 = tmp___5;
          } else {
#line 1122
            tmp___9 = N - 1;
          }
#line 1122
          if (0 < tmp___9) {
#line 1122
            if (N - 1 > tmp___5) {
#line 1122
              tmp___7 = tmp___5;
            } else {
#line 1122
              tmp___7 = N - 1;
            }
#line 1122
            tmp___8 = tmp___7;
          } else {
#line 1122
            tmp___8 = 0;
          }
#line 1122
          bin___0 = tmp___8;
#line 1125
          *(*(*(im->data + x) + y) + c) = (bins + bin___0)->rangeStart * (1.0 - frac) + (bins + bin___0)->rangeEnd * frac;
        } else {
#line 1128
          *(*(*(im->data + x) + y) + c) = (double )0;
        }
#line 1118
        c ++;
      }
#line 1117
      y ++;
    }
#line 1116
    x ++;
  }
#line 1134
  free((void *)bins);
#line 1135
  return;
}
}
#line 1137 "src/csuCommonImage.c"
void histEqualRect(Image im , int N , int top , int left , int bottom , int right ) 
{ 
  HistogramBin *bins ;
  void *tmp ;
  double minVal ;
  double maxVal ;
  double binSize ;
  double totalPixels ;
  int x ;
  int y ;
  int c ;
  int tmp___0 ;
  int bin ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  double frac ;
  int bin___0 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  double zeroshift ;
  int tmp___10 ;
  double frac___0 ;
  int bin___1 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;

  {
#line 1138
  tmp = malloc(sizeof(HistogramBin ) * (unsigned long )N);
#line 1138
  bins = (HistogramBin *)tmp;
#line 1140
  totalPixels = (double )((im->width * im->height) * im->channels);
#line 1143
  if (! bins) {
#line 1143
    __assert_fail("bins", "src/csuCommonImage.c", 1143U, "histEqualRect");
  }
#line 1144
  if (! (top >= 0)) {
#line 1144
    __assert_fail("top >= 0", "src/csuCommonImage.c", 1144U, "histEqualRect");
  }
#line 1145
  if (! (left >= 0)) {
#line 1145
    __assert_fail("left >= 0", "src/csuCommonImage.c", 1145U, "histEqualRect");
  }
#line 1146
  if (! (bottom <= im->height)) {
#line 1146
    __assert_fail("bottom <= im->height", "src/csuCommonImage.c", 1146U, "histEqualRect");
  }
#line 1147
  if (! (right <= im->width)) {
#line 1147
    __assert_fail("right <= im->width", "src/csuCommonImage.c", 1147U, "histEqualRect");
  }
#line 1149
  minVal = *(*(*(im->data + 0) + 0) + 0);
#line 1150
  maxVal = *(*(*(im->data + 0) + 0) + 0);
#line 1151
  x = left;
#line 1151
  while (x < right) {
#line 1152
    y = top;
#line 1152
    while (y < bottom) {
#line 1153
      c = 0;
#line 1153
      while (c < im->channels) {
#line 1154
        if (minVal > *(*(*(im->data + x) + y) + c)) {
#line 1154
          minVal = *(*(*(im->data + x) + y) + c);
        } else {
#line 1154
          minVal = minVal;
        }
#line 1155
        if (maxVal < *(*(*(im->data + x) + y) + c)) {
#line 1155
          maxVal = *(*(*(im->data + x) + y) + c);
        } else {
#line 1155
          maxVal = maxVal;
        }
#line 1153
        c ++;
      }
#line 1152
      y ++;
    }
#line 1151
    x ++;
  }
#line 1161
  binSize = (maxVal - minVal) / (double )N;
#line 1165
  x = 0;
#line 1165
  while (x < N) {
#line 1165
    (bins + x)->count = 0;
#line 1165
    x ++;
  }
#line 1168
  x = left;
#line 1168
  while (x < right) {
#line 1169
    y = top;
#line 1169
    while (y < bottom) {
#line 1170
      c = 0;
#line 1170
      while (c < im->channels) {
#line 1171
        tmp___0 = (int )((*(*(*(im->data + x) + y) + c) - minVal) / binSize);
#line 1172
        if (N - 1 > tmp___0) {
#line 1172
          tmp___4 = tmp___0;
        } else {
#line 1172
          tmp___4 = N - 1;
        }
#line 1172
        if (0 < tmp___4) {
#line 1172
          if (N - 1 > tmp___0) {
#line 1172
            tmp___2 = tmp___0;
          } else {
#line 1172
            tmp___2 = N - 1;
          }
#line 1172
          tmp___3 = tmp___2;
        } else {
#line 1172
          tmp___3 = 0;
        }
#line 1172
        bin = tmp___3;
#line 1173
        ((bins + bin)->count) ++;
#line 1170
        c ++;
      }
#line 1169
      y ++;
    }
#line 1168
    x ++;
  }
#line 1179
  c = 0;
#line 1180
  x = 0;
#line 1180
  while (x < N) {
#line 1181
    (bins + x)->rangeStart = (double )c / totalPixels;
#line 1182
    c += (bins + x)->count;
#line 1183
    (bins + x)->rangeEnd = (double )c / totalPixels;
#line 1180
    x ++;
  }
#line 1187
  x = 0;
#line 1187
  while (x < N) {
#line 1188
    tmp___5 = (int )((0.0 - minVal) / binSize);
#line 1189
    frac = (0.0 - minVal) / binSize - (double )tmp___5;
#line 1190
    if (N - 1 > tmp___5) {
#line 1190
      tmp___9 = tmp___5;
    } else {
#line 1190
      tmp___9 = N - 1;
    }
#line 1190
    if (0 < tmp___9) {
#line 1190
      if (N - 1 > tmp___5) {
#line 1190
        tmp___7 = tmp___5;
      } else {
#line 1190
        tmp___7 = N - 1;
      }
#line 1190
      tmp___8 = tmp___7;
    } else {
#line 1190
      tmp___8 = 0;
    }
#line 1190
    bin___0 = tmp___8;
#line 1192
    zeroshift = (bins + bin___0)->rangeStart * (1.0 - frac) + (bins + bin___0)->rangeEnd * frac;
#line 1194
    (bins + x)->rangeStart -= zeroshift;
#line 1195
    (bins + x)->rangeEnd -= zeroshift;
#line 1187
    x ++;
  }
#line 1199
  x = 0;
#line 1199
  while (x < im->width) {
#line 1200
    y = 0;
#line 1200
    while (y < im->height) {
#line 1201
      c = 0;
#line 1201
      while (c < im->channels) {
#line 1202
        tmp___10 = (int )((*(*(*(im->data + x) + y) + c) - minVal) / binSize);
#line 1203
        frac___0 = (*(*(*(im->data + x) + y) + c) - minVal) / binSize - (double )tmp___10;
#line 1204
        if (N - 1 > tmp___10) {
#line 1204
          tmp___14 = tmp___10;
        } else {
#line 1204
          tmp___14 = N - 1;
        }
#line 1204
        if (0 < tmp___14) {
#line 1204
          if (N - 1 > tmp___10) {
#line 1204
            tmp___12 = tmp___10;
          } else {
#line 1204
            tmp___12 = N - 1;
          }
#line 1204
          tmp___13 = tmp___12;
        } else {
#line 1204
          tmp___13 = 0;
        }
#line 1204
        bin___1 = tmp___13;
#line 1208
        *(*(*(im->data + x) + y) + c) = (bins + bin___1)->rangeStart * (1.0 - frac___0) + (bins + bin___1)->rangeEnd * frac___0;
#line 1201
        c ++;
      }
#line 1200
      y ++;
    }
#line 1199
    x ++;
  }
#line 1213
  free((void *)bins);
#line 1214
  return;
}
}
#line 1217 "src/csuCommonImage.c"
void ZeroBorder(Image im ) 
{ 
  int x ;
  int y ;
  int c ;
  double sum ;
  int count ;
  double zero ;

  {
#line 1219
  sum = 0.0;
#line 1220
  count = 0;
#line 1223
  if (! im) {
#line 1223
    __assert_fail("im", "src/csuCommonImage.c", 1223U, "ZeroBorder");
  }
#line 1224
  if (! (im->width > 0)) {
#line 1224
    __assert_fail("im->width > 0", "src/csuCommonImage.c", 1224U, "ZeroBorder");
  }
#line 1225
  if (! (im->height > 0)) {
#line 1225
    __assert_fail("im->height > 0", "src/csuCommonImage.c", 1225U, "ZeroBorder");
  }
#line 1226
  x = 0;
#line 1226
  while (x < im->width) {
#line 1227
    c = 0;
#line 1227
    while (c < im->channels) {
#line 1228
      sum += *(*(*(im->data + x) + 0) + c);
#line 1229
      count ++;
#line 1227
      c ++;
    }
#line 1226
    x ++;
  }
#line 1234
  y = 1;
#line 1234
  while (y < im->height) {
#line 1235
    c = 0;
#line 1235
    while (c < im->channels) {
#line 1236
      sum += *(*(*(im->data + 0) + y) + c);
#line 1237
      sum += *(*(*(im->data + (im->width - 1)) + y) + c);
#line 1238
      count += 2;
#line 1235
      c ++;
    }
#line 1234
    y ++;
  }
#line 1242
  zero = sum / (double )count;
#line 1243
  x = 0;
#line 1243
  while (x < im->width) {
#line 1244
    y = 0;
#line 1244
    while (y < im->height) {
#line 1245
      c = 0;
#line 1245
      while (c < im->channels) {
#line 1246
        *(*(*(im->data + x) + y) + c) -= zero;
#line 1245
        c ++;
      }
#line 1244
      y ++;
    }
#line 1243
    x ++;
  }
#line 1252
  return;
}
}
#line 1264 "src/csuCommonImage.c"
double gaussianNoise(Image im , double noise ) 
{ 
  double max ;
  double min ;
  double stddev ;
  int x ;
  int y ;
  int c ;
  double tmp ;
  double tmp___0 ;

  {
#line 1271
  max = *(*(*(im->data + 0) + 0) + 0);
#line 1272
  min = *(*(*(im->data + 0) + 0) + 0);
#line 1274
  x = 0;
#line 1274
  while (x < im->width) {
#line 1275
    y = 0;
#line 1275
    while (y < im->height) {
#line 1276
      c = 0;
#line 1276
      while (c < im->channels) {
#line 1277
        if (*(*(*(im->data + x) + y) + c) < max) {
#line 1277
          max = max;
        } else {
#line 1277
          max = *(*(*(im->data + x) + y) + c);
        }
#line 1278
        if (*(*(*(im->data + x) + y) + c) > min) {
#line 1278
          min = min;
        } else {
#line 1278
          min = *(*(*(im->data + x) + y) + c);
        }
#line 1276
        c ++;
      }
#line 1275
      y ++;
    }
#line 1274
    x ++;
  }
#line 1283
  stddev = noise * (max - min);
#line 1285
  x = 0;
#line 1285
  while (x < im->width) {
#line 1286
    y = 0;
#line 1286
    while (y < im->height) {
#line 1287
      c = 0;
#line 1287
      while (c < im->channels) {
#line 1288
        tmp___0 = randBM();
#line 1288
        tmp = tmp___0 * stddev;
#line 1289
        *(*(*(im->data + x) + y) + c) += tmp;
#line 1287
        c ++;
      }
#line 1286
      y ++;
    }
#line 1285
    x ++;
  }
#line 1293
  return (stddev);
}
}
#line 1297 "src/csuCommonImage.c"
void applyMask(Image im , char const   **mask ) 
{ 
  int x ;
  int y ;
  int c ;

  {
#line 1300
  if (! mask) {
#line 1300
    return;
  }
#line 1302
  x = 0;
#line 1302
  while (x < im->width) {
#line 1303
    y = 0;
#line 1303
    while (y < im->height) {
#line 1304
      c = 0;
#line 1304
      while (c < im->channels) {
#line 1305
        if (! *(*(mask + x) + y)) {
#line 1309
          *(*(*(im->data + x) + y) + c) = 0.0;
        }
#line 1304
        c ++;
      }
#line 1303
      y ++;
    }
#line 1302
    x ++;
  }
#line 1315
  return;
}
}
#line 1328 "src/csuCommonImage.c"
char **imageToMask(Image im , int c ) 
{ 
  double max ;
  double tmp ;
  double min ;
  double tmp___0 ;
  double threshold ;
  char **mask ;
  int i ;
  int j ;
  void *tmp___1 ;
  void *tmp___2 ;

  {
#line 1330
  tmp = imageMax(im, (char const   **)((void *)0));
#line 1330
  max = tmp;
#line 1331
  tmp___0 = imageMin(im, (char const   **)((void *)0));
#line 1331
  min = tmp___0;
#line 1332
  threshold = (max + min) / (double )2;
#line 1336
  tmp___1 = malloc(sizeof(char *) * (unsigned long )im->width);
#line 1336
  mask = (char **)tmp___1;
#line 1337
  if (! mask) {
#line 1337
    __assert_fail("mask", "src/csuCommonImage.c", 1337U, "imageToMask");
  }
#line 1339
  i = 0;
#line 1339
  while (i < im->width) {
#line 1340
    tmp___2 = malloc(sizeof(char ) * (unsigned long )im->height);
#line 1340
    *(mask + i) = (char *)tmp___2;
#line 1341
    if (! *(mask + i)) {
#line 1341
      __assert_fail("mask[i]", "src/csuCommonImage.c", 1341U, "imageToMask");
    }
#line 1339
    i ++;
  }
#line 1344
  j = 0;
#line 1344
  while (j < im->height) {
#line 1345
    i = 0;
#line 1345
    while (i < im->width) {
#line 1346
      if (*(*(*(im->data + i) + j) + c) >= threshold) {
#line 1347
        *(*(mask + i) + j) = (char)1;
      } else {
#line 1349
        *(*(mask + i) + j) = (char)0;
      }
#line 1345
      i ++;
    }
#line 1344
    j ++;
  }
#line 1353
  return (mask);
}
}
#line 1356 "src/csuCommonImage.c"
void markPoint(Image im , double X , double Y ) 
{ 
  double mx ;
  double tmp ;
  int x ;
  int y ;
  int c ;

  {
#line 1357
  tmp = imageMax(im, (char const   **)((void *)0));
#line 1357
  mx = tmp;
#line 1359
  x = (int )(X + 0.5);
#line 1360
  y = (int )(Y + 0.5);
#line 1363
  if (x - 4 < 0) {
#line 1363
    return;
  } else
#line 1363
  if (x + 4 >= im->width) {
#line 1363
    return;
  }
#line 1364
  if (y - 4 < 0) {
#line 1364
    return;
  } else
#line 1364
  if (y + 4 >= im->height) {
#line 1364
    return;
  }
#line 1366
  c = 0;
#line 1366
  while (c < im->channels) {
#line 1367
    *(*(*(im->data + (x - 2)) + y) + c) = mx;
#line 1368
    *(*(*(im->data + (x + 2)) + y) + c) = mx;
#line 1369
    *(*(*(im->data + (x - 3)) + y) + c) = mx;
#line 1370
    *(*(*(im->data + (x + 3)) + y) + c) = mx;
#line 1371
    *(*(*(im->data + (x - 4)) + y) + c) = mx;
#line 1372
    *(*(*(im->data + (x + 4)) + y) + c) = mx;
#line 1373
    *(*(*(im->data + x) + (y - 2)) + c) = mx;
#line 1374
    *(*(*(im->data + x) + (y + 2)) + c) = mx;
#line 1375
    *(*(*(im->data + x) + (y - 3)) + c) = mx;
#line 1376
    *(*(*(im->data + x) + (y + 3)) + c) = mx;
#line 1377
    *(*(*(im->data + x) + (y - 4)) + c) = mx;
#line 1378
    *(*(*(im->data + x) + (y + 4)) + c) = mx;
#line 1366
    c ++;
  }
#line 1380
  return;
}
}
#line 1383 "src/csuCommonImage.c"
Image makeThermalColorImage(Image im ) 
{ 
  int x ;
  int y ;
  double mx ;
  double tmp ;
  double mn ;
  double tmp___0 ;
  Image Thermal ;
  Image tmp___1 ;
  double value ;

  {
#line 1385
  tmp = imageMax(im, (char const   **)((void *)0));
#line 1385
  mx = tmp;
#line 1386
  tmp___0 = imageMin(im, (char const   **)((void *)0));
#line 1386
  mn = tmp___0;
#line 1387
  tmp___1 = makeImage(im->width, im->height, 3);
#line 1387
  Thermal = tmp___1;
#line 1388
  if (! (im->channels == 1)) {
#line 1388
    __assert_fail("im->channels == 1", "src/csuCommonImage.c", 1388U, "makeThermalColorImage");
  }
#line 1390
  x = 0;
#line 1390
  while (x < im->width) {
#line 1391
    y = 0;
#line 1391
    while (y < im->height) {
#line 1392
      value = (*(*(*(im->data + x) + y) + 0) - mn) / (mx - mn);
#line 1393
      if (value < 0.60) {
#line 1394
        *(*(*(Thermal->data + x) + y) + 0) = (double )0;
#line 1395
        *(*(*(Thermal->data + x) + y) + 1) = (double )0;
#line 1396
        *(*(*(Thermal->data + x) + y) + 2) = exp((double )-50 * ((value - 0.60) * (value - 0.60)));
      } else
#line 1397
      if (value < 0.70) {
#line 1398
        *(*(*(Thermal->data + x) + y) + 0) = (double )0;
#line 1399
        *(*(*(Thermal->data + x) + y) + 1) = (value - .60) / .10;
#line 1400
        *(*(*(Thermal->data + x) + y) + 2) = (double )1;
      } else
#line 1401
      if (value < 0.80) {
#line 1402
        *(*(*(Thermal->data + x) + y) + 0) = (double )0;
#line 1403
        *(*(*(Thermal->data + x) + y) + 1) = (double )1;
#line 1404
        *(*(*(Thermal->data + x) + y) + 2) = (0.80 - value) / .10;
      } else
#line 1405
      if (value < 0.90) {
#line 1406
        *(*(*(Thermal->data + x) + y) + 0) = (value - .80) / .10;
#line 1407
        *(*(*(Thermal->data + x) + y) + 1) = (double )1;
#line 1408
        *(*(*(Thermal->data + x) + y) + 2) = (double )0;
      } else
#line 1409
      if (value < 1.0) {
#line 1410
        *(*(*(Thermal->data + x) + y) + 0) = (double )1;
#line 1411
        *(*(*(Thermal->data + x) + y) + 1) = (1.0 - value) / .10;
#line 1412
        *(*(*(Thermal->data + x) + y) + 2) = (double )0;
      } else {
#line 1414
        *(*(*(Thermal->data + x) + y) + 0) = (double )1;
#line 1415
        *(*(*(Thermal->data + x) + y) + 1) = (double )0;
#line 1416
        *(*(*(Thermal->data + x) + y) + 2) = (double )0;
      }
#line 1391
      y ++;
    }
#line 1390
    x ++;
  }
#line 1420
  return (Thermal);
}
}
#line 1423 "src/csuCommonImage.c"
Image makeThermalComboImage(Image thrm , Image bw ) 
{ 
  int x ;
  int y ;
  int c ;
  double mxthrm ;
  double tmp ;
  double mnthrm ;
  double tmp___0 ;
  double mxbw ;
  double tmp___1 ;
  double mnbw ;
  double tmp___2 ;
  Image combo ;
  Image tmp___3 ;

  {
#line 1425
  tmp = imageMax(thrm, (char const   **)((void *)0));
#line 1425
  mxthrm = tmp;
#line 1426
  tmp___0 = imageMin(thrm, (char const   **)((void *)0));
#line 1426
  mnthrm = tmp___0;
#line 1427
  tmp___1 = imageMax(bw, (char const   **)((void *)0));
#line 1427
  mxbw = tmp___1;
#line 1428
  tmp___2 = imageMin(bw, (char const   **)((void *)0));
#line 1428
  mnbw = tmp___2;
#line 1429
  tmp___3 = makeImage(bw->width, bw->height, 3);
#line 1429
  combo = tmp___3;
#line 1431
  if (! (bw->channels == 1)) {
#line 1431
    __assert_fail("bw->channels == 1", "src/csuCommonImage.c", 1431U, "makeThermalComboImage");
  }
#line 1432
  if (! (thrm->channels == 3)) {
#line 1432
    __assert_fail("thrm->channels == 3", "src/csuCommonImage.c", 1432U, "makeThermalComboImage");
  }
#line 1433
  if (! (thrm->width == bw->width)) {
#line 1433
    __assert_fail("thrm->width == bw->width", "src/csuCommonImage.c", 1433U, "makeThermalComboImage");
  }
#line 1434
  if (! (thrm->height == bw->height)) {
#line 1434
    __assert_fail("thrm->height == bw->height", "src/csuCommonImage.c", 1434U, "makeThermalComboImage");
  }
#line 1436
  x = 0;
#line 1436
  while (x < bw->width) {
#line 1437
    y = 0;
#line 1437
    while (y < bw->height) {
#line 1438
      c = 0;
#line 1438
      while (c < 3) {
#line 1439
        *(*(*(combo->data + x) + y) + c) = (.5 * (*(*(*(thrm->data + x) + y) + c) - mnthrm)) / (mxthrm - mnthrm) + (.5 * (*(*(*(bw->data + x) + y) + 0) - mnbw)) / (mxbw - mnbw);
#line 1438
        c ++;
      }
#line 1437
      y ++;
    }
#line 1436
    x ++;
  }
#line 1443
  return (combo);
}
}
#line 1455 "src/csuCommonImage.c"
double imageMax(Image im , char const   **mask ) 
{ 
  double m ;
  int x ;
  int y ;
  int c ;
  time_t tttt ;
  time_t tmp ;
  char *tmp___0 ;

  {
#line 1458
  m = (double )0;
#line 1459
  y = 0;
#line 1459
  c = 0;
#line 1461
  x = 0;
#line 1461
  while (x < im->width) {
#line 1462
    y = 0;
#line 1462
    while (y < im->height) {
#line 1463
      c = 0;
#line 1463
      while (c < im->channels) {
#line 1464
        if (! mask) {
#line 1466
          m = *(*(*(im->data + x) + y) + c);
#line 1467
          goto MAX_LOOP;
        } else
#line 1464
        if (*(*(mask + x) + y)) {
#line 1466
          m = *(*(*(im->data + x) + y) + c);
#line 1467
          goto MAX_LOOP;
        }
#line 1463
        c ++;
      }
#line 1462
      y ++;
    }
#line 1461
    x ++;
  }
#line 1470
  if (1 <= debuglevel) {
#line 1470
    tmp = time((time_t *)0);
#line 1470
    tttt = tmp;
#line 1470
    tmp___0 = ctime((time_t const   *)(& tttt));
#line 1470
    printf((char const   * __restrict  )"**DEBUG %d** \"%s\"\n             at [%s]<%s():line %u>\n             %s\n",
           1, "Warning: All pixels masked!", "src/csuCommonImage.c", "imageMax", 1470,
           tmp___0);
#line 1470
    fflush(stdout);
  }
#line 1472
  x = 0;
#line 1472
  while (x < im->width) {
#line 1473
    y = 0;
#line 1473
    while (y < im->height) {
#line 1474
      c = 0;
#line 1474
      while (c < im->channels) {
        MAX_LOOP: 
#line 1477
        if (m < *(*(*(im->data + x) + y) + c)) {
#line 1477
          m = *(*(*(im->data + x) + y) + c);
        } else {
#line 1477
          m = m;
        }
#line 1474
        c ++;
      }
#line 1473
      y ++;
    }
#line 1472
    x ++;
  }
#line 1480
  return (m);
}
}
#line 1492 "src/csuCommonImage.c"
double imageMin(Image im , char const   **mask ) 
{ 
  double m ;
  int x ;
  int y ;
  int c ;
  time_t tttt ;
  time_t tmp ;
  char *tmp___0 ;

  {
#line 1495
  m = (double )0;
#line 1496
  y = 0;
#line 1496
  c = 0;
#line 1498
  x = 0;
#line 1498
  while (x < im->width) {
#line 1499
    y = 0;
#line 1499
    while (y < im->height) {
#line 1500
      c = 0;
#line 1500
      while (c < im->channels) {
#line 1501
        if (! mask) {
#line 1503
          m = *(*(*(im->data + x) + y) + c);
#line 1504
          goto MIN_LOOP;
        } else
#line 1501
        if (*(*(mask + x) + y)) {
#line 1503
          m = *(*(*(im->data + x) + y) + c);
#line 1504
          goto MIN_LOOP;
        }
#line 1500
        c ++;
      }
#line 1499
      y ++;
    }
#line 1498
    x ++;
  }
#line 1507
  if (1 <= debuglevel) {
#line 1507
    tmp = time((time_t *)0);
#line 1507
    tttt = tmp;
#line 1507
    tmp___0 = ctime((time_t const   *)(& tttt));
#line 1507
    printf((char const   * __restrict  )"**DEBUG %d** \"%s\"\n             at [%s]<%s():line %u>\n             %s\n",
           1, "Warning: All pixels masked!", "src/csuCommonImage.c", "imageMin", 1507,
           tmp___0);
#line 1507
    fflush(stdout);
  }
#line 1509
  x = 0;
#line 1509
  while (x < im->width) {
#line 1510
    y = 0;
#line 1510
    while (y < im->height) {
#line 1511
      c = 0;
#line 1511
      while (c < im->channels) {
#line 1512
        if (! mask) {
#line 1512
          goto MIN_LOOP;
        } else
#line 1512
        if (*(*(mask + x) + y)) {
          MIN_LOOP: 
#line 1515
          if (m > *(*(*(im->data + x) + y) + c)) {
#line 1515
            m = *(*(*(im->data + x) + y) + c);
          } else {
#line 1515
            m = m;
          }
        }
#line 1511
        c ++;
      }
#line 1510
      y ++;
    }
#line 1509
    x ++;
  }
#line 1518
  return (m);
}
}
#line 1530 "src/csuCommonImage.c"
double imageMean(Image im , char const   **mask ) 
{ 
  int x ;
  int y ;
  int c ;
  int nPix ;
  double sum ;

  {
#line 1533
  nPix = 0;
#line 1534
  sum = (double )0;
#line 1536
  x = 0;
#line 1536
  while (x < im->width) {
#line 1537
    y = 0;
#line 1537
    while (y < im->height) {
#line 1538
      c = 0;
#line 1538
      while (c < im->channels) {
#line 1539
        if (! mask) {
#line 1541
          sum += *(*(*(im->data + x) + y) + c);
#line 1542
          nPix ++;
        } else
#line 1539
        if (*(*(mask + x) + y)) {
#line 1541
          sum += *(*(*(im->data + x) + y) + c);
#line 1542
          nPix ++;
        }
#line 1538
        c ++;
      }
#line 1537
      y ++;
    }
#line 1536
    x ++;
  }
#line 1545
  return (sum / (double )nPix);
}
}
#line 1557 "src/csuCommonImage.c"
double imageVariance(Image im , char const   **mask ) 
{ 
  int x ;
  int y ;
  int c ;
  int nPix ;
  double sqsum ;
  double mean ;
  double tmp ;

  {
#line 1560
  nPix = 0;
#line 1561
  sqsum = (double )0;
#line 1561
  tmp = imageMean(im, mask);
#line 1561
  mean = tmp;
#line 1563
  x = 0;
#line 1563
  while (x < im->width) {
#line 1564
    y = 0;
#line 1564
    while (y < im->height) {
#line 1565
      c = 0;
#line 1565
      while (c < im->channels) {
#line 1566
        if (! mask) {
#line 1568
          nPix ++;
#line 1569
          sqsum += (*(*(*(im->data + x) + y) + c) - mean) * (*(*(*(im->data + x) + y) + c) - mean);
        } else
#line 1566
        if (*(*(mask + x) + y)) {
#line 1568
          nPix ++;
#line 1569
          sqsum += (*(*(*(im->data + x) + y) + c) - mean) * (*(*(*(im->data + x) + y) + c) - mean);
        }
#line 1565
        c ++;
      }
#line 1564
      y ++;
    }
#line 1563
    x ++;
  }
#line 1572
  return (sqsum / (double )(nPix - 1));
}
}
#line 1584 "src/csuCommonImage.c"
double imageStdDev(Image im , char const   **mask ) 
{ 
  double tmp ;
  double tmp___0 ;

  {
#line 1587
  tmp = imageVariance(im, mask);
#line 1587
  tmp___0 = sqrt(tmp);
#line 1587
  return (tmp___0);
}
}
#line 1594 "src/csuCommonImage.c"
int pixelComparator(void const   *aV , void const   *bV ) 
{ 
  double const   *a ;
  double const   *b ;

  {
#line 1597
  a = (double const   *)aV;
#line 1598
  b = (double const   *)bV;
#line 1600
  if (*a < *b) {
#line 1600
    return (-1);
  }
#line 1601
  if (*a > *b) {
#line 1601
    return (1);
  }
#line 1602
  return (0);
}
}
#line 1614 "src/csuCommonImage.c"
double imageMedian(Image im , char const   **mask ) 
{ 
  int x ;
  int y ;
  int c ;
  int nPix ;
  int tmp ;
  double *sortedPixels ;
  double *pp ;
  double median ;
  void *tmp___0 ;
  double *tmp___1 ;

  {
#line 1617
  tmp = imageNumOfPixels(im, mask);
#line 1617
  nPix = tmp;
#line 1622
  tmp___0 = malloc(sizeof(double ) * (unsigned long )nPix);
#line 1622
  sortedPixels = (double *)tmp___0;
#line 1624
  pp = sortedPixels;
#line 1625
  x = 0;
#line 1625
  while (x < im->width) {
#line 1626
    y = 0;
#line 1626
    while (y < im->height) {
#line 1627
      c = 0;
#line 1627
      while (c < im->channels) {
#line 1628
        if (! mask) {
#line 1629
          tmp___1 = pp;
#line 1629
          pp ++;
#line 1629
          *tmp___1 = *(*(*(im->data + x) + y) + c);
        } else
#line 1628
        if (*(*(mask + x) + y)) {
#line 1629
          tmp___1 = pp;
#line 1629
          pp ++;
#line 1629
          *tmp___1 = *(*(*(im->data + x) + y) + c);
        }
#line 1627
        c ++;
      }
#line 1626
      y ++;
    }
#line 1625
    x ++;
  }
#line 1633
  qsort((void *)sortedPixels, (size_t )nPix, sizeof(double ), & pixelComparator);
#line 1635
  median = *(sortedPixels + nPix / 2);
#line 1637
  free((void *)sortedPixels);
#line 1639
  return (median);
}
}
#line 1655 "src/csuCommonImage.c"
double imageMad(Image im , char const   **mask ) 
{ 
  int x ;
  int y ;
  int c ;
  int nPix ;
  int tmp ;
  double *sortedPixels ;
  double *pp ;
  double median ;
  double mad ;
  void *tmp___0 ;
  double *tmp___1 ;
  double *tmp___2 ;

  {
#line 1658
  tmp = imageNumOfPixels(im, mask);
#line 1658
  nPix = tmp;
#line 1663
  tmp___0 = malloc(sizeof(double ) * (unsigned long )nPix);
#line 1663
  sortedPixels = (double *)tmp___0;
#line 1665
  pp = sortedPixels;
#line 1666
  x = 0;
#line 1666
  while (x < im->width) {
#line 1667
    y = 0;
#line 1667
    while (y < im->height) {
#line 1668
      c = 0;
#line 1668
      while (c < im->channels) {
#line 1669
        if (! mask) {
#line 1670
          tmp___1 = pp;
#line 1670
          pp ++;
#line 1670
          *tmp___1 = *(*(*(im->data + x) + y) + c);
        } else
#line 1669
        if (*(*(mask + x) + y)) {
#line 1670
          tmp___1 = pp;
#line 1670
          pp ++;
#line 1670
          *tmp___1 = *(*(*(im->data + x) + y) + c);
        }
#line 1668
        c ++;
      }
#line 1667
      y ++;
    }
#line 1666
    x ++;
  }
#line 1674
  qsort((void *)sortedPixels, (size_t )nPix, sizeof(double ), & pixelComparator);
#line 1676
  median = *(sortedPixels + nPix / 2);
#line 1680
  pp = sortedPixels;
#line 1681
  x = 0;
#line 1681
  while (x < im->width) {
#line 1682
    y = 0;
#line 1682
    while (y < im->height) {
#line 1683
      c = 0;
#line 1683
      while (c < im->channels) {
#line 1684
        if (! mask) {
#line 1685
          tmp___2 = pp;
#line 1685
          pp ++;
#line 1685
          *tmp___2 = fabs(*(*(*(im->data + x) + y) + c) - median);
        } else
#line 1684
        if (*(*(mask + x) + y)) {
#line 1685
          tmp___2 = pp;
#line 1685
          pp ++;
#line 1685
          *tmp___2 = fabs(*(*(*(im->data + x) + y) + c) - median);
        }
#line 1683
        c ++;
      }
#line 1682
      y ++;
    }
#line 1681
    x ++;
  }
#line 1689
  qsort((void *)sortedPixels, (size_t )nPix, sizeof(double ), & pixelComparator);
#line 1691
  mad = *(sortedPixels + nPix / 2);
#line 1693
  free((void *)sortedPixels);
#line 1695
  return (mad);
}
}
#line 1707 "src/csuCommonImage.c"
int imageNumOfPixels(Image im , char const   **mask ) 
{ 
  int x ;
  int y ;
  int nPix ;

  {
#line 1710
  nPix = 0;
#line 1712
  if (! mask) {
#line 1713
    nPix = (im->width * im->height) * im->channels;
  } else {
#line 1716
    x = 0;
#line 1716
    while (x < im->width) {
#line 1717
      y = 0;
#line 1717
      while (y < im->height) {
#line 1718
        if (*(*(mask + x) + y)) {
#line 1719
          nPix ++;
        }
#line 1717
        y ++;
      }
#line 1716
      x ++;
    }
#line 1720
    nPix *= im->channels;
  }
#line 1723
  return (nPix);
}
}
#line 1727 "src/csuCommonImage.c"
void computeImageStatistics(ImageStatistics *is , Image im ) 
{ 
  int x ;
  int y ;
  int c ;
  double sum ;
  double sqsum ;
  double tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 1729
  sum = (double )0;
#line 1729
  sqsum = (double )0;
#line 1730
  if (! is) {
#line 1730
    __assert_fail("is", "src/csuCommonImage.c", 1730U, "computeImageStatistics");
  }
#line 1732
  tmp = *(*(*(im->data + 0) + 0) + 0);
#line 1732
  is->max = tmp;
#line 1732
  is->min = tmp;
#line 1733
  tmp___4 = 0;
#line 1733
  is->max_c = tmp___4;
#line 1733
  tmp___3 = tmp___4;
#line 1733
  is->max_y = tmp___3;
#line 1733
  tmp___2 = tmp___3;
#line 1733
  is->max_x = tmp___2;
#line 1733
  tmp___1 = tmp___2;
#line 1733
  is->min_c = tmp___1;
#line 1733
  tmp___0 = tmp___1;
#line 1733
  is->min_y = tmp___0;
#line 1733
  is->min_x = tmp___0;
#line 1734
  x = 0;
#line 1734
  while (x < im->width) {
#line 1735
    y = 0;
#line 1735
    while (y < im->height) {
#line 1736
      c = 0;
#line 1736
      while (c < im->channels) {
#line 1737
        sum += *(*(*(im->data + x) + y) + c);
#line 1739
        if (is->min > *(*(*(im->data + x) + y) + c)) {
#line 1740
          is->min = *(*(*(im->data + x) + y) + c);
#line 1741
          is->min_x = x;
#line 1741
          is->min_y = y;
#line 1741
          is->min_c = c;
        }
#line 1743
        if (is->max < *(*(*(im->data + x) + y) + c)) {
#line 1744
          is->max = *(*(*(im->data + x) + y) + c);
#line 1745
          is->max_x = x;
#line 1745
          is->max_y = y;
#line 1745
          is->max_c = c;
        }
#line 1736
        c ++;
      }
#line 1735
      y ++;
    }
#line 1734
    x ++;
  }
#line 1751
  is->mean = sum / (double )((im->width * im->height) * im->channels);
#line 1753
  x = 0;
#line 1753
  while (x < im->width) {
#line 1754
    y = 0;
#line 1754
    while (y < im->height) {
#line 1755
      c = 0;
#line 1755
      while (c < im->channels) {
#line 1756
        sqsum += (*(*(*(im->data + x) + y) + c) - is->mean) * (*(*(*(im->data + x) + y) + c) - is->mean);
#line 1755
        c ++;
      }
#line 1754
      y ++;
    }
#line 1753
    x ++;
  }
#line 1761
  is->variance = sqsum / (double )((im->width * im->height) * im->channels - 1);
#line 1762
  is->stddev = sqrt(is->variance);
#line 1763
  return;
}
}
#line 1765 "src/csuCommonImage.c"
void computeImageStatisticsMask(ImageStatistics *is , Image im , char const   **mask ) 
{ 
  int x ;
  int y ;
  int c ;
  int first ;
  double sum ;
  double sqsum ;
  double nPix ;
  double tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 1766
  first = 1;
#line 1767
  sum = (double )0;
#line 1767
  sqsum = (double )0;
#line 1767
  nPix = (double )0;
#line 1768
  if (! is) {
#line 1768
    __assert_fail("is", "src/csuCommonImage.c", 1768U, "computeImageStatisticsMask");
  }
#line 1770
  tmp = *(*(*(im->data + 0) + 0) + 0);
#line 1770
  is->max = tmp;
#line 1770
  is->min = tmp;
#line 1771
  tmp___4 = 0;
#line 1771
  is->max_c = tmp___4;
#line 1771
  tmp___3 = tmp___4;
#line 1771
  is->max_y = tmp___3;
#line 1771
  tmp___2 = tmp___3;
#line 1771
  is->max_x = tmp___2;
#line 1771
  tmp___1 = tmp___2;
#line 1771
  is->min_c = tmp___1;
#line 1771
  tmp___0 = tmp___1;
#line 1771
  is->min_y = tmp___0;
#line 1771
  is->min_x = tmp___0;
#line 1772
  x = 0;
#line 1772
  while (x < im->width) {
#line 1773
    y = 0;
#line 1773
    while (y < im->height) {
#line 1774
      c = 0;
#line 1774
      while (c < im->channels) {
#line 1775
        if (! mask) {
#line 1775
          goto _L;
        } else
#line 1775
        if (*(*(mask + x) + y)) {
          _L: /* CIL Label */ 
#line 1776
          sum += *(*(*(im->data + x) + y) + c);
#line 1777
          nPix += (double )1;
#line 1779
          if (first) {
#line 1780
            is->min = *(*(*(im->data + x) + y) + c);
#line 1781
            is->min_x = x;
#line 1781
            is->min_y = y;
#line 1781
            is->min_c = c;
          } else
#line 1779
          if (is->min > *(*(*(im->data + x) + y) + c)) {
#line 1780
            is->min = *(*(*(im->data + x) + y) + c);
#line 1781
            is->min_x = x;
#line 1781
            is->min_y = y;
#line 1781
            is->min_c = c;
          }
#line 1783
          if (first) {
#line 1784
            is->max = *(*(*(im->data + x) + y) + c);
#line 1785
            is->max_x = x;
#line 1785
            is->max_y = y;
#line 1785
            is->max_c = c;
          } else
#line 1783
          if (is->max < *(*(*(im->data + x) + y) + c)) {
#line 1784
            is->max = *(*(*(im->data + x) + y) + c);
#line 1785
            is->max_x = x;
#line 1785
            is->max_y = y;
#line 1785
            is->max_c = c;
          }
#line 1787
          first = 0;
        }
#line 1774
        c ++;
      }
#line 1773
      y ++;
    }
#line 1772
    x ++;
  }
#line 1793
  is->mean = sum / nPix;
#line 1795
  x = 0;
#line 1795
  while (x < im->width) {
#line 1796
    y = 0;
#line 1796
    while (y < im->height) {
#line 1797
      c = 0;
#line 1797
      while (c < im->channels) {
#line 1798
        if (! mask) {
#line 1799
          sqsum += (*(*(*(im->data + x) + y) + c) - is->mean) * (*(*(*(im->data + x) + y) + c) - is->mean);
        } else
#line 1798
        if (*(*(mask + x) + y)) {
#line 1799
          sqsum += (*(*(*(im->data + x) + y) + c) - is->mean) * (*(*(*(im->data + x) + y) + c) - is->mean);
        }
#line 1797
        c ++;
      }
#line 1796
      y ++;
    }
#line 1795
    x ++;
  }
#line 1805
  is->variance = sqsum / (nPix - (double )1);
#line 1806
  is->stddev = sqrt(is->variance);
#line 1807
  return;
}
}
#line 1810 "src/csuCommonImage.c"
void computeImageStatisticsLocal(ImageStatistics *is , Image im , int xt , int yt ,
                                 int dist ) 
{ 
  int x ;
  int y ;
  int c ;
  double sum ;
  double sqsum ;
  double tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  double tmp___3 ;
  double tmp___4 ;
  double tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  double tmp___8 ;
  double tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;

  {
#line 1812
  sum = (double )0;
#line 1812
  sqsum = (double )0;
#line 1813
  if (! is) {
#line 1813
    __assert_fail("is", "src/csuCommonImage.c", 1813U, "computeImageStatisticsLocal");
  }
#line 1815
  if (dist < 0) {
#line 1815
    dist = - dist;
  } else {
#line 1815
    dist = dist;
  }
#line 1816
  tmp = ie(im, xt, yt, 0);
#line 1816
  is->max = tmp;
#line 1816
  is->min = tmp;
#line 1817
  tmp___0 = xt;
#line 1817
  is->max_x = tmp___0;
#line 1817
  is->min_x = tmp___0;
#line 1818
  tmp___1 = yt;
#line 1818
  is->max_y = tmp___1;
#line 1818
  is->min_y = tmp___1;
#line 1819
  tmp___2 = 0;
#line 1819
  is->max_c = tmp___2;
#line 1819
  is->min_c = tmp___2;
#line 1820
  if (xt - dist < 0) {
#line 1820
    x = 0;
  } else {
#line 1820
    x = xt - dist;
  }
#line 1820
  while (1) {
#line 1820
    if (xt + dist > im->width - 1) {
#line 1820
      tmp___7 = im->width - 1;
    } else {
#line 1820
      tmp___7 = xt + dist;
    }
#line 1820
    if (! (x <= tmp___7)) {
#line 1820
      break;
    }
#line 1821
    if (yt - dist < 0) {
#line 1821
      y = 0;
    } else {
#line 1821
      y = yt - dist;
    }
#line 1821
    while (1) {
#line 1821
      if (yt + dist > im->height - 1) {
#line 1821
        tmp___6 = im->height - 1;
      } else {
#line 1821
        tmp___6 = yt + dist;
      }
#line 1821
      if (! (y <= tmp___6)) {
#line 1821
        break;
      }
#line 1822
      c = 0;
#line 1822
      while (c < im->channels) {
#line 1823
        tmp___3 = ie(im, x, y, c);
#line 1823
        sum += tmp___3;
#line 1825
        tmp___4 = ie(im, x, y, c);
#line 1825
        if (is->min > tmp___4) {
#line 1826
          is->min = ie(im, x, y, c);
#line 1827
          is->min_x = x;
#line 1827
          is->min_y = y;
#line 1827
          is->min_c = c;
        }
#line 1829
        tmp___5 = ie(im, x, y, c);
#line 1829
        if (is->max < tmp___5) {
#line 1830
          is->max = ie(im, x, y, c);
#line 1831
          is->max_x = x;
#line 1831
          is->max_y = y;
#line 1831
          is->max_c = c;
        }
#line 1822
        c ++;
      }
#line 1821
      y ++;
    }
#line 1820
    x ++;
  }
#line 1837
  is->mean = sum / (double )(((2 * dist) * 2) * dist);
#line 1839
  if (xt - dist < 0) {
#line 1839
    x = 0;
  } else {
#line 1839
    x = xt - dist;
  }
#line 1839
  while (1) {
#line 1839
    if (xt + dist > im->width - 1) {
#line 1839
      tmp___11 = im->width - 1;
    } else {
#line 1839
      tmp___11 = xt + dist;
    }
#line 1839
    if (! (x <= tmp___11)) {
#line 1839
      break;
    }
#line 1840
    if (yt - dist < 0) {
#line 1840
      y = 0;
    } else {
#line 1840
      y = yt - dist;
    }
#line 1840
    while (1) {
#line 1840
      if (yt + dist > im->height - 1) {
#line 1840
        tmp___10 = im->height - 1;
      } else {
#line 1840
        tmp___10 = yt + dist;
      }
#line 1840
      if (! (y <= tmp___10)) {
#line 1840
        break;
      }
#line 1841
      c = 0;
#line 1841
      while (c < im->channels) {
#line 1842
        tmp___8 = ie(im, x, y, c);
#line 1842
        tmp___9 = ie(im, x, y, c);
#line 1842
        sqsum += (tmp___8 - is->mean) * (tmp___9 - is->mean);
#line 1841
        c ++;
      }
#line 1840
      y ++;
    }
#line 1839
    x ++;
  }
#line 1847
  is->variance = sqsum / (double )(((2 * dist) * 2) * dist - 1);
#line 1848
  is->stddev = sqrt(is->variance);
#line 1849
  return;
}
}
#line 1 "csuEBGMUtil.o"
#pragma merger("0","/tmp/cil-qCPTjpGx.i","-O3,-Wall")
#line 425 "/usr/include/stdio.h"
extern int ( __attribute__((__warn_unused_result__)) fscanf)(FILE * __restrict  __stream ,
                                                             char const   * __restrict  __format 
                                                             , ...)  __asm__("__isoc99_fscanf")  ;
#line 58 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h"
extern  __attribute__((__nothrow__)) double ( __attribute__((__leaf__)) atan)(double __x ) ;
#line 63
extern  __attribute__((__nothrow__)) double ( __attribute__((__leaf__)) cos)(double __x ) ;
#line 65
extern  __attribute__((__nothrow__)) double ( __attribute__((__leaf__)) sin)(double __x ) ;
#line 150 "/usr/include/x86_64-linux-gnu/bits/mathinline.h"
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__, __always_inline__)) __signbitl)(long double __x )  __attribute__((__const__)) ;
#line 150 "/usr/include/x86_64-linux-gnu/bits/mathinline.h"
__inline extern int ( __attribute__((__leaf__, __always_inline__)) __signbitl)(long double __x ) 
{ 
  union __anonunion___u_26___5 __u ;

  {
#line 153
  __u.__l = __x;
#line 154
  return ((__u.__i[2] & 32768) != 0);
}
}
#line 121 "src/csuEBGMUtil.h"
GaborJetParams makeJetParams(int length ) ;
#line 122
void freeJetParams(GaborJetParams params ) ;
#line 140
JetMasks makeJetMasks(int size ) ;
#line 141
void freeJetMasks(JetMasks masks ) ;
#line 143
Image makeGaborMask(double lambda , double theta , double phi , double gamma___0 ,
                    double sigma , int size ) ;
#line 145
JetMasks readMasksFile(char const   *filename ) ;
#line 174
GaborJet makeGaborJet(int length ) ;
#line 175
void freeGaborJet(GaborJet jet ) ;
#line 176
GaborJet extractJet(double x , double y , Image im , JetMasks masks ) ;
#line 198
JetBunch makeJetBunch(void) ;
#line 199
void freeJetBunch(JetBunch jb ) ;
#line 200
int addJetToBunch(JetBunch bunch , GaborJet jet ) ;
#line 231
GraphDiscription readGraphDiscription(char const   *filename ) ;
#line 232
void saveGraphDiscription(char const   *filename , GraphDiscription gd ) ;
#line 233
void freeGraphDiscription(GraphDiscription gd ) ;
#line 247
FaceGraph makeFaceGraph(int geosize , int totalsize ) ;
#line 248
void freeFaceGraph(FaceGraph fg ) ;
#line 251
void saveFaceGraph(char *filename , FaceGraph fg ) ;
#line 256
Image makeJetImage(JetMasks const   masks , Image const   im ) ;
#line 257
Image makeComplexImage(Image const   jetImage ) ;
#line 97 "src/csuEBGMUtil.c"
GaborJet makeGaborJet(int length ) 
{ 
  GaborJet jet ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;

  {
#line 98
  tmp = malloc(sizeof(gabor_jet ));
#line 98
  jet = (GaborJet )tmp;
#line 99
  if (! jet) {
#line 99
    __assert_fail("jet", "src/csuEBGMUtil.c", 99U, "makeGaborJet");
  }
#line 101
  if (length) {
#line 102
    jet->length = length;
#line 104
    tmp___0 = malloc(sizeof(double ) * (unsigned long )length);
#line 104
    jet->realPart = (double *)tmp___0;
#line 105
    if (! jet->realPart) {
#line 105
      __assert_fail("jet->realPart", "src/csuEBGMUtil.c", 105U, "makeGaborJet");
    }
#line 106
    tmp___1 = malloc(sizeof(double ) * (unsigned long )length);
#line 106
    jet->imagPart = (double *)tmp___1;
#line 107
    if (! jet->imagPart) {
#line 107
      __assert_fail("jet->imagPart", "src/csuEBGMUtil.c", 107U, "makeGaborJet");
    }
#line 108
    tmp___2 = malloc(sizeof(double ) * (unsigned long )length);
#line 108
    jet->mag = (double *)tmp___2;
#line 109
    if (! jet->mag) {
#line 109
      __assert_fail("jet->mag", "src/csuEBGMUtil.c", 109U, "makeGaborJet");
    }
#line 110
    tmp___3 = malloc(sizeof(double ) * (unsigned long )length);
#line 110
    jet->ang = (double *)tmp___3;
#line 111
    if (! jet->ang) {
#line 111
      __assert_fail("jet->ang", "src/csuEBGMUtil.c", 111U, "makeGaborJet");
    }
  } else {
#line 113
    length = 0;
  }
#line 116
  jet->params = (GaborJetParams )((void *)0);
#line 118
  return (jet);
}
}
#line 122 "src/csuEBGMUtil.c"
void freeGaborJet(GaborJet jet ) 
{ 


  {
#line 123
  if (jet->length) {
#line 124
    free((void *)jet->realPart);
#line 125
    free((void *)jet->imagPart);
#line 126
    free((void *)jet->mag);
#line 127
    free((void *)jet->ang);
  }
#line 130
  free((void *)jet);
#line 131
  return;
}
}
#line 137 "src/csuEBGMUtil.c"
void computePolar(GaborJet jet ) 
{ 
  int i ;
  double tmp ;

  {
#line 140
  i = 0;
#line 140
  while (i < jet->length) {
#line 142
    *(jet->mag + i) = sqrt(*(jet->realPart + i) * *(jet->realPart + i) + *(jet->imagPart + i) * *(jet->imagPart + i));
#line 144
    if (*(jet->realPart + i) != (double )0) {
#line 146
      if (*(jet->realPart + i) >= (double )0) {
#line 147
        *(jet->ang + i) = atan(*(jet->imagPart + i) / *(jet->realPart + i));
      } else {
#line 150
        tmp = atan(*(jet->imagPart + i) / *(jet->realPart + i));
#line 150
        *(jet->ang + i) = 3.141592654 + tmp;
      }
    } else
#line 154
    if (*(jet->imagPart + i) >= (double )0) {
#line 155
      *(jet->ang + i) = 3.141592654 / (double )2;
    } else {
#line 158
      *(jet->ang + i) = - 3.141592654 / (double )2;
    }
#line 140
    i ++;
  }
#line 162
  return;
}
}
#line 166 "src/csuEBGMUtil.c"
GaborJet extractJet(double x , double y , Image im , JetMasks masks ) 
{ 
  GaborJet jet ;
  int i ;
  float rx ;
  float ry ;
  float dx ;
  float dy ;
  int tmp ;
  int tmp___0 ;
  double tmp___1 ;
  double tmp___2 ;

  {
#line 167
  jet = (GaborJet )((void *)0);
#line 168
  if (masks->size) {
#line 174
    rx = (float )((int )(x + 0.5));
#line 175
    ry = (float )((int )(y + 0.5));
#line 176
    dx = (float )(x - (double )rx);
#line 177
    dy = (float )(y - (double )ry);
#line 178
    jet = makeGaborJet(masks->size / 2);
#line 181
    jet->params = masks->params;
#line 185
    i = 0;
#line 185
    while (i < jet->length) {
#line 186
      *(jet->realPart + i) = convolvePoint((double )rx, (double )ry, 0, (Image const   )im,
                                           (Image const   )*(masks->masks + 2 * i));
#line 187
      *(jet->imagPart + i) = convolvePoint((double )rx, (double )ry, 0, (Image const   )im,
                                           (Image const   )*(masks->masks + (2 * i + 1)));
#line 188
      tmp = finite(*(jet->realPart + i));
#line 188
      if (! tmp) {
#line 188
        printf((char const   * __restrict  )"ERROR: Not Finite - %10s:%5f <%10s,%10s,%3d>\n",
               "jet->realPart[i]", *(jet->realPart + i), "src/csuEBGMUtil.c", "extractJet",
               188);
      }
#line 189
      tmp___0 = finite(*(jet->imagPart + i));
#line 189
      if (! tmp___0) {
#line 189
        printf((char const   * __restrict  )"ERROR: Not Finite - %10s:%5f <%10s,%10s,%3d>\n",
               "jet->imagPart[i]", *(jet->imagPart + i), "src/csuEBGMUtil.c", "extractJet",
               189);
      }
#line 185
      i ++;
    }
#line 191
    computePolar(jet);
#line 194
    i = 0;
#line 194
    while (i < jet->length) {
#line 195
      *(jet->ang + i) += (double )dx * *((jet->params)->kx + 2 * i) + (double )dy * *((jet->params)->ky + 2 * i);
#line 194
      i ++;
    }
#line 199
    i = 0;
#line 199
    while (i < jet->length) {
#line 200
      tmp___1 = cos(*(jet->ang + i));
#line 200
      *(jet->realPart + i) = *(jet->mag + i) * tmp___1;
#line 201
      tmp___2 = sin(*(jet->ang + i));
#line 201
      *(jet->imagPart + i) = *(jet->mag + i) * tmp___2;
#line 199
      i ++;
    }
  } else {
#line 205
    jet = makeGaborJet(0);
  }
#line 209
  jet->x = x;
#line 210
  jet->y = y;
#line 212
  return (jet);
}
}
#line 218 "src/csuEBGMUtil.c"
GaborJetParams makeJetParams(int length ) 
{ 
  GaborJetParams params ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  void *tmp___5 ;
  void *tmp___6 ;
  void *tmp___7 ;

  {
#line 219
  tmp = malloc(sizeof(gabor_jet_params ));
#line 219
  params = (GaborJetParams )tmp;
#line 220
  if (! params) {
#line 220
    __assert_fail("params", "src/csuEBGMUtil.c", 220U, "makeJetParams");
  }
#line 222
  params->length = length;
#line 224
  tmp___0 = malloc(sizeof(double ) * (unsigned long )length);
#line 224
  params->wavelength = (double *)tmp___0;
#line 225
  tmp___1 = malloc(sizeof(double ) * (unsigned long )length);
#line 225
  params->angle = (double *)tmp___1;
#line 226
  tmp___2 = malloc(sizeof(double ) * (unsigned long )length);
#line 226
  params->phase = (double *)tmp___2;
#line 227
  tmp___3 = malloc(sizeof(double ) * (unsigned long )length);
#line 227
  params->aspect = (double *)tmp___3;
#line 228
  tmp___4 = malloc(sizeof(double ) * (unsigned long )length);
#line 228
  params->radius = (double *)tmp___4;
#line 229
  tmp___5 = malloc(sizeof(double ) * (unsigned long )length);
#line 229
  params->kx = (double *)tmp___5;
#line 230
  tmp___6 = malloc(sizeof(double ) * (unsigned long )length);
#line 230
  params->ky = (double *)tmp___6;
#line 231
  tmp___7 = malloc(sizeof(int ) * (unsigned long )length);
#line 231
  params->size = (int *)tmp___7;
#line 233
  return (params);
}
}
#line 237 "src/csuEBGMUtil.c"
void freeJetParams(GaborJetParams params ) 
{ 


  {
#line 239
  free((void *)params->wavelength);
#line 240
  free((void *)params->angle);
#line 241
  free((void *)params->phase);
#line 242
  free((void *)params->aspect);
#line 243
  free((void *)params->radius);
#line 244
  free((void *)params->size);
#line 245
  free((void *)params->kx);
#line 246
  free((void *)params->ky);
#line 248
  free((void *)params);
#line 249
  return;
}
}
#line 252 "src/csuEBGMUtil.c"
JetMasks makeJetMasks(int size ) 
{ 
  JetMasks masks ;
  void *tmp ;
  void *tmp___0 ;

  {
#line 253
  tmp = malloc(sizeof(jet_masks ));
#line 253
  masks = (JetMasks )tmp;
#line 254
  if (! masks) {
#line 254
    __assert_fail("masks", "src/csuEBGMUtil.c", 254U, "makeJetMasks");
  }
#line 256
  masks->size = size;
#line 257
  tmp___0 = malloc(sizeof(Image ) * (unsigned long )size);
#line 257
  masks->masks = (Image *)tmp___0;
#line 258
  masks->params = makeJetParams(size);
#line 259
  if (! masks->masks) {
#line 259
    __assert_fail("masks->masks", "src/csuEBGMUtil.c", 259U, "makeJetMasks");
  }
#line 261
  return (masks);
}
}
#line 266 "src/csuEBGMUtil.c"
void freeJetMasks(JetMasks masks ) 
{ 
  int n ;

  {
#line 269
  n = 0;
#line 269
  while (n < masks->size) {
#line 270
    freeImage(*(masks->masks + n));
#line 269
    n ++;
  }
#line 272
  freeJetParams(masks->params);
#line 273
  free((void *)masks->masks);
#line 274
  free((void *)masks);
#line 275
  return;
}
}
#line 281 "src/csuEBGMUtil.c"
double WiskottDCFree  =    0.0;
#line 283 "src/csuEBGMUtil.c"
Image makeGaborMask(double lambda , double theta , double phi , double gamma___0 ,
                    double sigma , int size ) 
{ 
  Image mask ;
  Image tmp ;
  int i ;
  int j ;
  double x ;
  double y ;
  double xp ;
  double tmp___0 ;
  double tmp___1 ;
  double yp ;
  double tmp___2 ;
  double tmp___3 ;
  double tmp1 ;
  double tmp2 ;
  double tmp___4 ;
  double tmp___5 ;
  double tmp___6 ;

  {
#line 286
  tmp = makeImage(size, size, 1);
#line 286
  mask = tmp;
#line 290
  j = 0;
#line 290
  while (j < size) {
#line 291
    i = 0;
#line 291
    while (i < size) {
#line 292
      x = ((double )size / 2.0 - (double )size) + (double )i;
#line 293
      y = ((double )size / 2.0 - (double )size) + (double )j;
#line 294
      tmp___0 = cos(theta);
#line 294
      tmp___1 = sin(theta);
#line 294
      xp = x * tmp___0 + y * tmp___1;
#line 295
      tmp___2 = sin(theta);
#line 295
      tmp___3 = cos(theta);
#line 295
      yp = - x * tmp___2 + y * tmp___3;
#line 296
      tmp1 = - (xp * xp + ((gamma___0 * gamma___0) * yp) * yp) / (((double )2 * sigma) * sigma);
#line 297
      tmp2 = (((double )2 * 3.141592654) * xp) / lambda + phi;
#line 298
      tmp___4 = exp(tmp1);
#line 298
      tmp___5 = cos(tmp2);
#line 298
      tmp___6 = exp((- sigma * sigma) * 0.5);
#line 298
      *(*(*(mask->data + i) + j) + 0) = tmp___4 * (tmp___5 - ((double )(phi == 0.0) * WiskottDCFree) * tmp___6);
#line 291
      i ++;
    }
#line 290
    j ++;
  }
#line 303
  ZeroMeanUnitLength(mask);
#line 305
  return (mask);
}
}
#line 309 "src/csuEBGMUtil.c"
JetMasks readMasksFile(char const   *filename ) 
{ 
  JetMasks masks ;
  int maskCount ;
  double lambda ;
  double angle ;
  double phase ;
  double gama ;
  double sigma ;
  int maskSize ;
  int i ;
  FILE *file ;
  FILE *tmp ;
  int tmp___0 ;
  double tmp___1 ;
  double tmp___2 ;

  {
#line 310
  masks = (JetMasks )((void *)0);
#line 314
  tmp = fopen((char const   * __restrict  )filename, (char const   * __restrict  )"r");
#line 314
  file = tmp;
#line 316
  if (! file) {
#line 317
    printf((char const   * __restrict  )"Error opening file: %s", filename);
#line 318
    exit(1);
  }
#line 322
  fscanf((FILE * __restrict  )file, (char const   * __restrict  )"%d", & maskCount);
#line 323
  masks = makeJetMasks(maskCount);
#line 327
  i = 0;
#line 327
  while (i < maskCount) {
#line 328
    tmp___0 = fscanf((FILE * __restrict  )file, (char const   * __restrict  )"%lf %lf %lf %lf %lf %d",
                     & lambda, & angle, & phase, & gama, & sigma, & maskSize);
#line 328
    if (tmp___0 != 6) {
#line 329
      printf((char const   * __restrict  )"Error reading mask file: %s line: %d",
             filename, i);
#line 330
      exit(1);
    }
#line 332
    *((masks->params)->wavelength + i) = lambda;
#line 333
    *((masks->params)->angle + i) = angle;
#line 334
    *((masks->params)->phase + i) = phase;
#line 335
    *((masks->params)->aspect + i) = gama;
#line 336
    *((masks->params)->radius + i) = sigma;
#line 337
    tmp___1 = cos(angle);
#line 337
    *((masks->params)->kx + i) = ((2.0 * 3.141592654) * tmp___1) / lambda;
#line 338
    tmp___2 = sin(angle);
#line 338
    *((masks->params)->ky + i) = ((2.0 * 3.141592654) * tmp___2) / lambda;
#line 339
    *((masks->params)->size + i) = maskSize;
#line 341
    *(masks->masks + i) = makeGaborMask(lambda, angle, phase, gama, sigma, maskSize);
#line 342
    ZeroMeanUnitLength(*(masks->masks + i));
#line 327
    i ++;
  }
#line 345
  fclose(file);
#line 347
  return (masks);
}
}
#line 359 "src/csuEBGMUtil.c"
GraphDiscription readGraphDiscription(char const   *filename ) 
{ 
  FILE *file ;
  int i ;
  GraphDiscription gd ;
  void *tmp ;
  time_t tttt ;
  time_t tmp___0 ;
  char *tmp___1 ;
  time_t tttt___0 ;
  time_t tmp___2 ;
  char *tmp___3 ;
  time_t tttt___1 ;
  time_t tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;
  void *tmp___7 ;
  void *tmp___8 ;
  void *tmp___9 ;
  void *tmp___10 ;
  time_t tttt___2 ;
  time_t tmp___11 ;
  char *tmp___12 ;
  int tmp___13 ;
  time_t tttt___3 ;
  time_t tmp___14 ;
  char *tmp___15 ;
  int tmp___16 ;
  void *tmp___17 ;
  time_t tttt___4 ;
  time_t tmp___18 ;
  char *tmp___19 ;
  int tmp___20 ;

  {
#line 362
  tmp = csu_allocate("graph_discription", (int )sizeof(graph_discription ), 1, "src/csuEBGMUtil.c",
                     362);
#line 362
  gd = (graph_discription *)tmp;
#line 363
  if (! gd) {
#line 363
    tmp___0 = time((time_t *)0);
#line 363
    tttt = tmp___0;
#line 363
    tmp___1 = ctime((time_t const   *)(& tttt));
#line 363
    printf((char const   * __restrict  )"**DEBUG CHECK** Failed check (%s) \"%s\"\n             at [%s]<%s():line %u>\n             %s\n",
           "gd", "Error allocating memory", "src/csuEBGMUtil.c", "readGraphDiscription",
           363, tmp___1);
#line 363
    fflush(stdout);
#line 363
    exit(1);
  }
#line 365
  file = fopen((char const   * __restrict  )filename, (char const   * __restrict  )"r");
#line 366
  if (! file) {
#line 366
    tmp___2 = time((time_t *)0);
#line 366
    tttt___0 = tmp___2;
#line 366
    printf((char const   * __restrict  )"**DEBUG CHECK** Failed check (%s) \"", "file");
#line 366
    printf((char const   * __restrict  )"Error opening file: %s", filename);
#line 366
    tmp___3 = ctime((time_t const   *)(& tttt___0));
#line 366
    printf((char const   * __restrict  )"\"\n             at [%s]<%s():line %u>\n             %s\n",
           "src/csuEBGMUtil.c", "readGraphDiscription", 366, tmp___3);
#line 366
    fflush(stdout);
#line 366
    exit(1);
  }
#line 369
  tmp___6 = fscanf((FILE * __restrict  )file, (char const   * __restrict  )"%d", & gd->numVert);
#line 369
  if (! (tmp___6 == 1)) {
#line 369
    tmp___4 = time((time_t *)0);
#line 369
    tttt___1 = tmp___4;
#line 369
    printf((char const   * __restrict  )"**DEBUG CHECK** Failed check (%s) \"", "fscanf(file,\"%d\",&(gd->numVert)) == 1");
#line 369
    printf((char const   * __restrict  )"Error: could not determin the number of verticies in file %s",
           filename);
#line 369
    tmp___5 = ctime((time_t const   *)(& tttt___1));
#line 369
    printf((char const   * __restrict  )"\"\n             at [%s]<%s():line %u>\n             %s\n",
           "src/csuEBGMUtil.c", "readGraphDiscription", 369, tmp___5);
#line 369
    fflush(stdout);
#line 369
    exit(1);
  }
#line 372
  tmp___7 = csu_allocate("Vert", (int )sizeof(Vert ), gd->numVert, "src/csuEBGMUtil.c",
                         372);
#line 372
  gd->verts = (Vert *)tmp___7;
#line 373
  tmp___8 = csu_allocate("char*", (int )sizeof(char *), gd->numVert, "src/csuEBGMUtil.c",
                         373);
#line 373
  gd->vertLabels = (char **)tmp___8;
#line 374
  tmp___9 = csu_allocate("JetBunch", (int )sizeof(JetBunch ), gd->numVert, "src/csuEBGMUtil.c",
                         374);
#line 374
  gd->bunch = (JetBunch *)tmp___9;
#line 375
  i = 0;
#line 375
  while (i < gd->numVert) {
#line 376
    tmp___10 = csu_allocate("char", (int )sizeof(char ), 100, "src/csuEBGMUtil.c",
                            376);
#line 376
    *(gd->vertLabels + i) = (char *)tmp___10;
#line 377
    tmp___13 = fscanf((FILE * __restrict  )file, (char const   * __restrict  )"%s %lf %lf",
                      *(gd->vertLabels + i), & (gd->verts + i)->x, & (gd->verts + i)->y);
#line 377
    if (! (tmp___13 == 3)) {
#line 377
      tmp___11 = time((time_t *)0);
#line 377
      tttt___2 = tmp___11;
#line 377
      printf((char const   * __restrict  )"**DEBUG CHECK** Failed check (%s) \"",
             "fscanf(file, \"%s %lf %lf\", gd->vertLabels[i], &(gd->verts[i].x), &(gd->verts[i].y)) == 3");
#line 377
      printf((char const   * __restrict  )"Error Parsing vertex %d in file: %s", i,
             filename);
#line 377
      tmp___12 = ctime((time_t const   *)(& tttt___2));
#line 377
      printf((char const   * __restrict  )"\"\n             at [%s]<%s():line %u>\n             %s\n",
             "src/csuEBGMUtil.c", "readGraphDiscription", 378, tmp___12);
#line 377
      fflush(stdout);
#line 377
      exit(1);
    }
#line 379
    *(gd->bunch + i) = makeJetBunch();
#line 375
    i ++;
  }
#line 384
  tmp___16 = fscanf((FILE * __restrict  )file, (char const   * __restrict  )"%d",
                    & gd->numEdge);
#line 384
  if (! (tmp___16 == 1)) {
#line 384
    tmp___14 = time((time_t *)0);
#line 384
    tttt___3 = tmp___14;
#line 384
    printf((char const   * __restrict  )"**DEBUG CHECK** Failed check (%s) \"", "fscanf(file,\"%d\",&(gd->numEdge)) == 1");
#line 384
    printf((char const   * __restrict  )"Error: could not determin the number of edges in file %s",
           filename);
#line 384
    tmp___15 = ctime((time_t const   *)(& tttt___3));
#line 384
    printf((char const   * __restrict  )"\"\n             at [%s]<%s():line %u>\n             %s\n",
           "src/csuEBGMUtil.c", "readGraphDiscription", 384, tmp___15);
#line 384
    fflush(stdout);
#line 384
    exit(1);
  }
#line 387
  tmp___17 = csu_allocate("Edge", (int )sizeof(Edge ), gd->numEdge, "src/csuEBGMUtil.c",
                          387);
#line 387
  gd->edges = (Edge *)tmp___17;
#line 388
  i = 0;
#line 388
  while (i < gd->numEdge) {
#line 389
    tmp___20 = fscanf((FILE * __restrict  )file, (char const   * __restrict  )"%d %d",
                      & (gd->edges + i)->vert1, & (gd->edges + i)->vert2);
#line 389
    if (! (tmp___20 == 2)) {
#line 389
      tmp___18 = time((time_t *)0);
#line 389
      tttt___4 = tmp___18;
#line 389
      printf((char const   * __restrict  )"**DEBUG CHECK** Failed check (%s) \"",
             "fscanf(file, \"%d %d\",&(gd->edges[i].vert1), &(gd->edges[i].vert2)) == 2");
#line 389
      printf((char const   * __restrict  )"Error Parsing vertex %d in file: %s", i,
             filename);
#line 389
      tmp___19 = ctime((time_t const   *)(& tttt___4));
#line 389
      printf((char const   * __restrict  )"\"\n             at [%s]<%s():line %u>\n             %s\n",
             "src/csuEBGMUtil.c", "readGraphDiscription", 390, tmp___19);
#line 389
      fflush(stdout);
#line 389
      exit(1);
    }
#line 388
    i ++;
  }
#line 392
  fclose(file);
#line 394
  return (gd);
}
}
#line 403 "src/csuEBGMUtil.c"
void saveGraphDiscription(char const   *filename , GraphDiscription gd ) 
{ 
  FILE *file ;
  int i ;
  time_t tttt ;
  time_t tmp ;
  char *tmp___0 ;

  {
#line 407
  file = fopen((char const   * __restrict  )filename, (char const   * __restrict  )"w");
#line 408
  if (! file) {
#line 408
    tmp = time((time_t *)0);
#line 408
    tttt = tmp;
#line 408
    printf((char const   * __restrict  )"**DEBUG CHECK** Failed check (%s) \"", "file");
#line 408
    printf((char const   * __restrict  )"Error opening file: %s", filename);
#line 408
    tmp___0 = ctime((time_t const   *)(& tttt));
#line 408
    printf((char const   * __restrict  )"\"\n             at [%s]<%s():line %u>\n             %s\n",
           "src/csuEBGMUtil.c", "saveGraphDiscription", 408, tmp___0);
#line 408
    fflush(stdout);
#line 408
    exit(1);
  }
#line 411
  fprintf((FILE * __restrict  )file, (char const   * __restrict  )"%d\n", gd->numVert);
#line 414
  i = 0;
#line 414
  while (i < gd->numVert) {
#line 415
    fprintf((FILE * __restrict  )file, (char const   * __restrict  )"%s %f %f\n",
            *(gd->vertLabels + i), (gd->verts + i)->x, (gd->verts + i)->y);
#line 414
    i ++;
  }
#line 419
  fprintf((FILE * __restrict  )file, (char const   * __restrict  )"%d\n", gd->numEdge);
#line 422
  i = 0;
#line 422
  while (i < gd->numEdge) {
#line 423
    fprintf((FILE * __restrict  )file, (char const   * __restrict  )"%d %d\n", (gd->edges + i)->vert1,
            (gd->edges + i)->vert2);
#line 422
    i ++;
  }
#line 426
  fclose(file);
#line 427
  return;
}
}
#line 429 "src/csuEBGMUtil.c"
void freeGraphDiscription(GraphDiscription gd ) 
{ 
  int i ;

  {
#line 432
  i = 0;
#line 432
  while (i < gd->numVert) {
#line 433
    free((void *)*(gd->vertLabels + i));
#line 434
    freeJetBunch(*(gd->bunch + i));
#line 432
    i ++;
  }
#line 437
  free((void *)gd->bunch);
#line 438
  free((void *)gd->verts);
#line 439
  free((void *)gd->vertLabels);
#line 440
  free((void *)gd->edges);
#line 441
  free((void *)gd);
#line 442
  return;
}
}
#line 446 "src/csuEBGMUtil.c"
Image makeComplexImage(Image const   jetImage ) 
{ 
  Image complexImage ;
  Image tmp ;
  int x ;
  int y ;
  int c ;
  time_t tttt ;
  time_t tmp___0 ;
  char *tmp___1 ;

  {
#line 447
  tmp = makeImage(jetImage->width, jetImage->height, jetImage->channels / 2);
#line 447
  complexImage = tmp;
#line 450
  if (! (jetImage->channels % 2 == 0)) {
#line 450
    tmp___0 = time((time_t *)0);
#line 450
    tttt = tmp___0;
#line 450
    tmp___1 = ctime((time_t const   *)(& tttt));
#line 450
    printf((char const   * __restrict  )"**DEBUG CHECK** Failed check (%s) \"%s\"\n             at [%s]<%s():line %u>\n             %s\n",
           "jetImage->channels%2 == 0", "jetImage must have an even number of channels",
           "src/csuEBGMUtil.c", "makeComplexImage", 450, tmp___1);
#line 450
    fflush(stdout);
#line 450
    exit(1);
  }
#line 452
  x = 0;
#line 452
  while (x < complexImage->width) {
#line 453
    y = 0;
#line 453
    while (y < complexImage->height) {
#line 454
      c = 0;
#line 454
      while (c < complexImage->channels) {
#line 455
        *(*(*(complexImage->data + x) + y) + c) = sqrt(*(*(*(jetImage->data + x) + y) + c * 2) * *(*(*(jetImage->data + x) + y) + c * 2) + *(*(*(jetImage->data + x) + y) + (c * 2 + 1)) * *(*(*(jetImage->data + x) + y) + (c * 2 + 1)));
#line 454
        c ++;
      }
#line 453
      y ++;
    }
#line 452
    x ++;
  }
#line 461
  return (complexImage);
}
}
#line 465 "src/csuEBGMUtil.c"
Image makeJetImage(JetMasks const   masks , Image const   im ) 
{ 
  Image jets ;
  Image tmp ;
  int n ;
  int x ;
  int y ;
  int c ;

  {
#line 467
  tmp = makeImage(im->width, im->height, im->channels * masks->size);
#line 467
  jets = tmp;
#line 469
  y = 0;
#line 469
  while (y < im->height) {
#line 470
    x = 0;
#line 470
    while (x < im->width) {
#line 471
      c = 0;
#line 471
      while (c < im->channels) {
#line 472
        n = 0;
#line 472
        while (n < masks->size) {
#line 473
          *(*(*(jets->data + x) + y) + (c * masks->size + n)) = convolvePoint((double )x,
                                                                              (double )y,
                                                                              c, im,
                                                                              (Image const   )*(masks->masks + n));
#line 472
          n ++;
        }
#line 471
        c ++;
      }
#line 470
      x ++;
    }
#line 469
    y ++;
  }
#line 479
  return (jets);
}
}
#line 486 "src/csuEBGMUtil.c"
JetBunch makeJetBunch(void) 
{ 
  JetBunch jb ;
  void *tmp ;
  void *tmp___0 ;

  {
#line 487
  tmp = csu_allocate("jet_bunch", (int )sizeof(jet_bunch ), 1, "src/csuEBGMUtil.c",
                     487);
#line 487
  jb = (jet_bunch *)tmp;
#line 488
  jb->allocsize = 0;
#line 489
  jb->size = 0;
#line 491
  tmp___0 = csu_allocate("GaborJet", (int )sizeof(GaborJet ), jb->allocsize, "src/csuEBGMUtil.c",
                         491);
#line 491
  jb->jets = (GaborJet *)tmp___0;
#line 492
  return (jb);
}
}
#line 495 "src/csuEBGMUtil.c"
void freeJetBunch(JetBunch jb ) 
{ 
  int i ;

  {
#line 497
  i = 0;
#line 497
  while (i < jb->size) {
#line 498
    if (*(jb->jets + i)) {
#line 498
      freeGaborJet(*(jb->jets + i));
    }
#line 497
    i ++;
  }
#line 500
  free((void *)jb->jets);
#line 501
  free((void *)jb);
#line 502
  return;
}
}
#line 505 "src/csuEBGMUtil.c"
int addJetToBunch(JetBunch bunch , GaborJet jet ) 
{ 
  int i ;
  GaborJet *tmpjets ;
  void *tmp ;

  {
#line 506
  if (bunch->size >= bunch->allocsize) {
#line 508
    tmp = csu_allocate("GaborJet", (int )sizeof(GaborJet ), bunch->allocsize + 32,
                       "src/csuEBGMUtil.c", 508);
#line 508
    tmpjets = (GaborJet *)tmp;
#line 509
    bunch->allocsize += 32;
#line 510
    i = 0;
#line 510
    while (i < bunch->size) {
#line 511
      *(tmpjets + i) = *(bunch->jets + i);
#line 510
      i ++;
    }
#line 513
    free((void *)bunch->jets);
#line 514
    bunch->jets = tmpjets;
  }
#line 516
  *(bunch->jets + bunch->size) = jet;
#line 517
  (bunch->size) ++;
#line 518
  return (bunch->size - 1);
}
}
#line 524 "src/csuEBGMUtil.c"
int alloc_faceGraph  =    0;
#line 526 "src/csuEBGMUtil.c"
FaceGraph makeFaceGraph(int geosize , int totalsize ) 
{ 
  int i ;
  FaceGraph fg ;
  void *tmp ;
  void *tmp___0 ;

  {
#line 528
  tmp = csu_allocate("face_graph", (int )sizeof(face_graph ), 1, "src/csuEBGMUtil.c",
                     528);
#line 528
  fg = (face_graph *)tmp;
#line 529
  if (! fg) {
#line 529
    __assert_fail("fg", "src/csuEBGMUtil.c", 529U, "makeFaceGraph");
  }
#line 530
  fg->geosize = geosize;
#line 531
  fg->totalsize = totalsize;
#line 532
  fg->params = (GaborJetParams )((void *)0);
#line 533
  tmp___0 = csu_allocate("GaborJet", (int )sizeof(GaborJet ), totalsize, "src/csuEBGMUtil.c",
                         533);
#line 533
  fg->jets = (GaborJet *)tmp___0;
#line 534
  i = 0;
#line 534
  while (i < totalsize) {
#line 535
    *(fg->jets + i) = (GaborJet )((void *)0);
#line 534
    i ++;
  }
#line 538
  alloc_faceGraph ++;
#line 539
  return (fg);
}
}
#line 542 "src/csuEBGMUtil.c"
void freeFaceGraph(FaceGraph fg ) 
{ 
  int i ;

  {
#line 544
  i = 0;
#line 544
  while (i < fg->totalsize) {
#line 545
    if ((unsigned long )*(fg->jets + i) != (unsigned long )((void *)0)) {
#line 546
      freeGaborJet(*(fg->jets + i));
    }
#line 544
    i ++;
  }
#line 549
  free((void *)fg->jets);
#line 550
  free((void *)fg);
#line 551
  alloc_faceGraph --;
#line 552
  return;
}
}
#line 554 "src/csuEBGMUtil.c"
void writeint(FILE *file , int i ) 
{ 


  {
#line 555
  fprintf((FILE * __restrict  )file, (char const   * __restrict  )"%d\n", i);
#line 556
  return;
}
}
#line 558 "src/csuEBGMUtil.c"
void writereal(FILE *file , double r ) 
{ 


  {
#line 559
  fprintf((FILE * __restrict  )file, (char const   * __restrict  )"%e\n", r);
#line 560
  return;
}
}
#line 562 "src/csuEBGMUtil.c"
int readint(FILE *file ) 
{ 
  int i ;

  {
#line 564
  fscanf((FILE * __restrict  )file, (char const   * __restrict  )"%d", & i);
#line 565
  return (i);
}
}
#line 568 "src/csuEBGMUtil.c"
double readreal(FILE *file ) 
{ 
  float f ;

  {
#line 570
  fscanf((FILE * __restrict  )file, (char const   * __restrict  )"%f", & f);
#line 571
  return ((double )f);
}
}
#line 574 "src/csuEBGMUtil.c"
FaceGraph loadFaceGraph(char *filename ) 
{ 
  int i ;
  int j ;
  int totalsize ;
  int geosize ;
  int params ;
  FaceGraph fg ;
  FILE *file ;
  FILE *tmp ;
  int gaborsize ;
  int tmp___0 ;
  int length ;

  {
#line 578
  tmp = fopen((char const   * __restrict  )filename, (char const   * __restrict  )"rb");
#line 578
  file = tmp;
#line 579
  printf((char const   * __restrict  )"Loading Graph: %s   \r", filename);
#line 579
  fflush(stdout);
#line 580
  if (! file) {
#line 580
    __assert_fail("file", "src/csuEBGMUtil.c", 580U, "loadFaceGraph");
  }
#line 582
  geosize = readint(file);
#line 583
  totalsize = readint(file);
#line 585
  fg = makeFaceGraph(geosize, totalsize);
#line 587
  params = readint(file);
#line 588
  if (params) {
#line 590
    tmp___0 = readint(file);
#line 590
    gaborsize = tmp___0;
#line 591
    fg->params = makeJetParams(gaborsize);
#line 592
    i = 0;
#line 592
    while (i < (fg->params)->length) {
#line 593
      *((fg->params)->wavelength + i) = readreal(file);
#line 594
      *((fg->params)->angle + i) = readreal(file);
#line 595
      *((fg->params)->phase + i) = readreal(file);
#line 596
      *((fg->params)->aspect + i) = readreal(file);
#line 597
      *((fg->params)->radius + i) = readreal(file);
#line 598
      *((fg->params)->size + i) = readint(file);
#line 599
      *((fg->params)->kx + i) = readreal(file);
#line 600
      *((fg->params)->ky + i) = readreal(file);
#line 592
      i ++;
    }
  }
#line 604
  i = 0;
#line 604
  while (i < fg->totalsize) {
#line 607
    length = readint(file);
#line 608
    *(fg->jets + i) = makeGaborJet(length);
#line 609
    (*(fg->jets + i))->params = fg->params;
#line 610
    (*(fg->jets + i))->x = readreal(file);
#line 611
    (*(fg->jets + i))->y = readreal(file);
#line 612
    j = 0;
#line 612
    while (j < (*(fg->jets + i))->length) {
#line 613
      *((*(fg->jets + i))->realPart + j) = readreal(file);
#line 614
      *((*(fg->jets + i))->imagPart + j) = readreal(file);
#line 615
      *((*(fg->jets + i))->mag + j) = readreal(file);
#line 616
      *((*(fg->jets + i))->ang + j) = readreal(file);
#line 612
      j ++;
    }
#line 604
    i ++;
  }
#line 619
  fclose(file);
#line 620
  return (fg);
}
}
#line 623 "src/csuEBGMUtil.c"
void saveFaceGraph(char *filename , FaceGraph fg ) 
{ 
  int i ;
  int j ;
  FILE *file ;
  FILE *tmp ;

  {
#line 625
  tmp = fopen((char const   * __restrict  )filename, (char const   * __restrict  )"wb");
#line 625
  file = tmp;
#line 626
  if (! file) {
#line 626
    __assert_fail("file", "src/csuEBGMUtil.c", 626U, "saveFaceGraph");
  }
#line 628
  writeint(file, fg->geosize);
#line 629
  writeint(file, fg->totalsize);
#line 630
  writeint(file, (unsigned long )fg->params != (unsigned long )((void *)0));
#line 631
  if (fg->params) {
#line 632
    writeint(file, (fg->params)->length);
#line 633
    i = 0;
#line 633
    while (i < (fg->params)->length) {
#line 634
      writereal(file, *((fg->params)->wavelength + i));
#line 635
      writereal(file, *((fg->params)->angle + i));
#line 636
      writereal(file, *((fg->params)->phase + i));
#line 637
      writereal(file, *((fg->params)->aspect + i));
#line 638
      writereal(file, *((fg->params)->radius + i));
#line 639
      writeint(file, *((fg->params)->size + i));
#line 640
      writereal(file, *((fg->params)->kx + i));
#line 641
      writereal(file, *((fg->params)->ky + i));
#line 633
      i ++;
    }
  }
#line 645
  i = 0;
#line 645
  while (i < fg->totalsize) {
#line 647
    writeint(file, (*(fg->jets + i))->length);
#line 648
    writereal(file, (*(fg->jets + i))->x);
#line 649
    writereal(file, (*(fg->jets + i))->y);
#line 650
    j = 0;
#line 650
    while (j < (*(fg->jets + i))->length) {
#line 651
      writereal(file, *((*(fg->jets + i))->realPart + j));
#line 652
      writereal(file, *((*(fg->jets + i))->imagPart + j));
#line 653
      writereal(file, *((*(fg->jets + i))->mag + j));
#line 654
      writereal(file, *((*(fg->jets + i))->ang + j));
#line 650
      j ++;
    }
#line 645
    i ++;
  }
#line 658
  fclose(file);
#line 659
  return;
}
}
#line 1 "csuEBGMSimilarity.o"
#pragma merger("0","/tmp/cil-2VnTxjhD.i","-O3,-Wall")
#line 150 "/usr/include/x86_64-linux-gnu/bits/mathinline.h"
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__, __always_inline__)) __signbitl)(long double __x )  __attribute__((__const__)) ;
#line 150 "/usr/include/x86_64-linux-gnu/bits/mathinline.h"
__inline extern int ( __attribute__((__leaf__, __always_inline__)) __signbitl)(long double __x ) 
{ 
  union __anonunion___u_26___6 __u ;

  {
#line 153
  __u.__l = __x;
#line 154
  return ((__u.__i[2] & 32768) != 0);
}
}
#line 94 "src/csuEBGMSimilarity.h"
double JetSimilarityMag(GaborJet j1___0 , GaborJet j2 ) ;
#line 95
double JetSimilarityPhase(GaborJet j1___0 , GaborJet j2 ) ;
#line 96
double JetSimilarityDEGridSample(GaborJet j1___0 , GaborJet j2 ) ;
#line 97
double JetSimilarityDEPredictiveStep(GaborJet j1___0 , GaborJet j2 ) ;
#line 98
double JetSimilarityDEPredictiveIter(GaborJet j1___0 , GaborJet j2 ) ;
#line 99
double JetSimilarityDEFixedLocalSearch(GaborJet j1___0 , GaborJet j2 ) ;
#line 100
double JetSimilarityDENarrowingLocalSearch(GaborJet j1___0 , GaborJet j2 ) ;
#line 101
double JetSimilarityCityBlock(GaborJet j1___0 , GaborJet j2 ) ;
#line 102
double JetSimilarityCorrelation(GaborJet j1___0 , GaborJet j2 ) ;
#line 103
double JetSimilarityCovariance(GaborJet j1___0 , GaborJet j2 ) ;
#line 107
double JetSimilarityResponseMag(GaborJet j1___0 , GaborJet j2 ) ;
#line 108
double JetSimilarityResponsePhase(GaborJet j1___0 , GaborJet j2 ) ;
#line 109
double JetSimilarityDisplacementCheckMag(GaborJet j1___0 , GaborJet j2 ) ;
#line 110
double JetSimilarityDisplacementCheckPhase(GaborJet j1___0 , GaborJet j2 ) ;
#line 120
double estimateDisplacementRandom(GaborJet j1___0 , GaborJet j2 , double *tdx , double *tdy ) ;
#line 121
double DEGridSample(GaborJet j1___0 , GaborJet j2 , double *tdx , double *tdy ) ;
#line 122
double DEPredictiveStep(GaborJet j1___0 , GaborJet j2 , double *tdx , double *tdy ) ;
#line 123
double DEPredictiveIter(GaborJet j1___0 , GaborJet j2 , double *tdx , double *tdy ) ;
#line 124
double DEFixedLocalSearch(GaborJet j1___0 , GaborJet j2 , double *tdx , double *tdy ) ;
#line 125
double DENarrowingLocalSearch(GaborJet j1___0 , GaborJet j2 , double *tdx , double *tdy ) ;
#line 90 "src/csuEBGMSimilarity.c"
double JetSimilarityMag(GaborJet j1___0 , GaborJet j2 ) 
{ 
  double j12 ;
  double j11 ;
  double j22 ;
  int i ;
  double tmp ;

  {
#line 91
  j12 = (double )0;
#line 92
  j11 = (double )0;
#line 93
  j22 = (double )0;
#line 96
  if (j1___0) {
#line 96
    if (j2) {
#line 96
      if (j1___0->length) {
#line 96
        if (! (j1___0->length == j2->length)) {
#line 96
          __assert_fail("j1 && j2 && j1->length && j1->length==j2->length", "src/csuEBGMSimilarity.c",
                        96U, "JetSimilarityMag");
        }
      } else {
#line 96
        __assert_fail("j1 && j2 && j1->length && j1->length==j2->length", "src/csuEBGMSimilarity.c",
                      96U, "JetSimilarityMag");
      }
    } else {
#line 96
      __assert_fail("j1 && j2 && j1->length && j1->length==j2->length", "src/csuEBGMSimilarity.c",
                    96U, "JetSimilarityMag");
    }
  } else {
#line 96
    __assert_fail("j1 && j2 && j1->length && j1->length==j2->length", "src/csuEBGMSimilarity.c",
                  96U, "JetSimilarityMag");
  }
#line 98
  i = 0;
#line 98
  while (i < j1___0->length) {
#line 99
    j12 += *(j1___0->mag + i) * *(j2->mag + i);
#line 100
    j11 += *(j1___0->mag + i) * *(j1___0->mag + i);
#line 101
    j22 += *(j2->mag + i) * *(j2->mag + i);
#line 98
    i ++;
  }
#line 104
  tmp = sqrt(j11 * j22);
#line 104
  return (j12 / tmp);
}
}
#line 109 "src/csuEBGMSimilarity.c"
double JetSimilarityPhase(GaborJet j1___0 , GaborJet j2 ) 
{ 
  double j12 ;
  double j11 ;
  double j22 ;
  int i ;
  double tmp ;
  double tmp___0 ;

  {
#line 110
  j12 = (double )0;
#line 111
  j11 = (double )0;
#line 112
  j22 = (double )0;
#line 115
  if (j1___0) {
#line 115
    if (j2) {
#line 115
      if (j1___0->length) {
#line 115
        if (! (j1___0->length == j2->length)) {
#line 115
          __assert_fail("j1 && j2 && j1->length && j1->length==j2->length", "src/csuEBGMSimilarity.c",
                        115U, "JetSimilarityPhase");
        }
      } else {
#line 115
        __assert_fail("j1 && j2 && j1->length && j1->length==j2->length", "src/csuEBGMSimilarity.c",
                      115U, "JetSimilarityPhase");
      }
    } else {
#line 115
      __assert_fail("j1 && j2 && j1->length && j1->length==j2->length", "src/csuEBGMSimilarity.c",
                    115U, "JetSimilarityPhase");
    }
  } else {
#line 115
    __assert_fail("j1 && j2 && j1->length && j1->length==j2->length", "src/csuEBGMSimilarity.c",
                  115U, "JetSimilarityPhase");
  }
#line 117
  i = 0;
#line 117
  while (i < j1___0->length) {
#line 118
    tmp = cos(*(j1___0->ang + i) - *(j2->ang + i));
#line 118
    j12 += (*(j1___0->mag + i) * *(j2->mag + i)) * tmp;
#line 119
    j11 += *(j1___0->mag + i) * *(j1___0->mag + i);
#line 120
    j22 += *(j2->mag + i) * *(j2->mag + i);
#line 117
    i ++;
  }
#line 123
  tmp___0 = sqrt(j11 * j22);
#line 123
  return (j12 / tmp___0);
}
}
#line 128 "src/csuEBGMSimilarity.c"
double JetSimilarityDEGridSample(GaborJet j1___0 , GaborJet j2 ) 
{ 
  double dx ;
  double dy ;
  double tmp ;

  {
#line 129
  dx = (double )0;
#line 129
  dy = (double )0;
#line 130
  tmp = DEGridSample(j1___0, j2, & dx, & dy);
#line 130
  return (tmp);
}
}
#line 133 "src/csuEBGMSimilarity.c"
double JetSimilarityDEPredictiveStep(GaborJet j1___0 , GaborJet j2 ) 
{ 
  double dx ;
  double dy ;
  double tmp ;

  {
#line 134
  dx = 0.0;
#line 134
  dy = 0.0;
#line 135
  tmp = DEPredictiveStep(j1___0, j2, & dx, & dy);
#line 135
  return (tmp);
}
}
#line 139 "src/csuEBGMSimilarity.c"
double JetSimilarityDEPredictiveIter(GaborJet j1___0 , GaborJet j2 ) 
{ 
  double dx ;
  double dy ;
  double tmp ;

  {
#line 140
  dx = 0.0;
#line 140
  dy = 0.0;
#line 141
  tmp = DEPredictiveIter(j1___0, j2, & dx, & dy);
#line 141
  return (tmp);
}
}
#line 145 "src/csuEBGMSimilarity.c"
double SIM_DISPLACE(GaborJet j1___0 , GaborJet j2 , double dx , double dy ) 
{ 
  double j12 ;
  double j11 ;
  double j22 ;
  int i ;
  double tmp ;
  double tmp___0 ;

  {
#line 146
  j12 = 0.0;
#line 147
  j11 = 0.0;
#line 148
  j22 = 0.0;
#line 150
  i = 0;
#line 150
  while (i < j1___0->length) {
#line 151
    tmp = cos((*(j1___0->ang + i) - *(j2->ang + i)) - (dx * *((j1___0->params)->kx + 2 * i) + dy * *((j1___0->params)->ky + 2 * i)));
#line 151
    j12 += (*(j1___0->mag + i) * *(j2->mag + i)) * tmp;
#line 154
    j11 += *(j1___0->mag + i) * *(j1___0->mag + i);
#line 155
    j22 += *(j2->mag + i) * *(j2->mag + i);
#line 150
    i ++;
  }
#line 157
  tmp___0 = sqrt(j11 * j22);
#line 157
  return (j12 / tmp___0);
}
}
#line 165 "src/csuEBGMSimilarity.c"
double JetSimilarityDEFixedLocalSearch(GaborJet j1___0 , GaborJet j2 ) 
{ 
  double dx ;
  double dy ;
  double tmp ;

  {
#line 166
  dx = 0.0;
#line 166
  dy = 0.0;
#line 167
  tmp = DEFixedLocalSearch(j1___0, j2, & dx, & dy);
#line 167
  return (tmp);
}
}
#line 174 "src/csuEBGMSimilarity.c"
double JetSimilarityDENarrowingLocalSearch(GaborJet j1___0 , GaborJet j2 ) 
{ 
  double dx ;
  double dy ;
  double tmp ;

  {
#line 175
  dx = (double )0;
#line 175
  dy = (double )0;
#line 176
  tmp = DENarrowingLocalSearch(j1___0, j2, & dx, & dy);
#line 176
  return (tmp);
}
}
#line 182 "src/csuEBGMSimilarity.c"
double JetSimilarityCityBlock(GaborJet j1___0 , GaborJet j2 ) 
{ 
  double sim ;
  int i ;
  double tmp ;
  double tmp___0 ;

  {
#line 183
  sim = (double )0;
#line 186
  if (j1___0) {
#line 186
    if (j2) {
#line 186
      if (j1___0->length) {
#line 186
        if (! (j1___0->length == j2->length)) {
#line 186
          __assert_fail("j1 && j2 && j1->length && j1->length==j2->length", "src/csuEBGMSimilarity.c",
                        186U, "JetSimilarityCityBlock");
        }
      } else {
#line 186
        __assert_fail("j1 && j2 && j1->length && j1->length==j2->length", "src/csuEBGMSimilarity.c",
                      186U, "JetSimilarityCityBlock");
      }
    } else {
#line 186
      __assert_fail("j1 && j2 && j1->length && j1->length==j2->length", "src/csuEBGMSimilarity.c",
                    186U, "JetSimilarityCityBlock");
    }
  } else {
#line 186
    __assert_fail("j1 && j2 && j1->length && j1->length==j2->length", "src/csuEBGMSimilarity.c",
                  186U, "JetSimilarityCityBlock");
  }
#line 188
  i = 0;
#line 188
  while (i < j1___0->length) {
#line 190
    if (*(j1___0->realPart + i) - *(j2->realPart + i) < (double )0) {
#line 190
      tmp = - (*(j1___0->realPart + i) - *(j2->realPart + i));
    } else {
#line 190
      tmp = *(j1___0->realPart + i) - *(j2->realPart + i);
    }
#line 190
    sim -= tmp;
#line 191
    if (*(j1___0->imagPart + i) - *(j2->imagPart + i) < (double )0) {
#line 191
      tmp___0 = - (*(j1___0->imagPart + i) - *(j2->imagPart + i));
    } else {
#line 191
      tmp___0 = *(j1___0->imagPart + i) - *(j2->imagPart + i);
    }
#line 191
    sim -= tmp___0;
#line 188
    i ++;
  }
#line 193
  return (sim);
}
}
#line 198 "src/csuEBGMSimilarity.c"
double JetSimilarityCorrelation(GaborJet j1___0 , GaborJet j2 ) 
{ 
  int i ;
  double corrilation ;
  double j1mean ;
  double j2mean ;
  double j1scale ;
  double j2scale ;
  double tmp ;
  double tmp___0 ;

  {
#line 201
  corrilation = 0.0;
#line 202
  j1mean = 0.0;
#line 202
  j2mean = 0.0;
#line 203
  j1scale = 0.0;
#line 203
  j2scale = 0.0;
#line 205
  if (j1___0) {
#line 205
    if (j2) {
#line 205
      if (j1___0->length) {
#line 205
        if (! (j1___0->length == j2->length)) {
#line 205
          __assert_fail("j1 && j2 && j1->length && j1->length == j2->length", "src/csuEBGMSimilarity.c",
                        205U, "JetSimilarityCorrelation");
        }
      } else {
#line 205
        __assert_fail("j1 && j2 && j1->length && j1->length == j2->length", "src/csuEBGMSimilarity.c",
                      205U, "JetSimilarityCorrelation");
      }
    } else {
#line 205
      __assert_fail("j1 && j2 && j1->length && j1->length == j2->length", "src/csuEBGMSimilarity.c",
                    205U, "JetSimilarityCorrelation");
    }
  } else {
#line 205
    __assert_fail("j1 && j2 && j1->length && j1->length == j2->length", "src/csuEBGMSimilarity.c",
                  205U, "JetSimilarityCorrelation");
  }
#line 208
  i = 0;
#line 208
  while (i < j1___0->length) {
#line 209
    j1mean += *(j1___0->realPart + i);
#line 210
    j1mean += *(j1___0->imagPart + i);
#line 211
    j2mean += *(j2->realPart + i);
#line 212
    j2mean += *(j2->imagPart + i);
#line 208
    i ++;
  }
#line 215
  j1mean /= (double )(2 * j1___0->length);
#line 216
  j2mean /= (double )(2 * j1___0->length);
#line 219
  i = 0;
#line 219
  while (i < j1___0->length) {
#line 220
    corrilation += (*(j1___0->realPart + i) - j1mean) * (*(j2->realPart + i) - j2mean);
#line 221
    corrilation += (*(j1___0->imagPart + i) - j1mean) * (*(j2->imagPart + i) - j2mean);
#line 222
    j1scale += (*(j1___0->realPart + i) - j1mean) * (*(j1___0->realPart + i) - j1mean);
#line 223
    j1scale += (*(j1___0->imagPart + i) - j1mean) * (*(j1___0->imagPart + i) - j1mean);
#line 224
    j2scale += (*(j2->realPart + i) - j2mean) * (*(j2->realPart + i) - j2mean);
#line 225
    j2scale += (*(j2->imagPart + i) - j2mean) * (*(j2->imagPart + i) - j2mean);
#line 219
    i ++;
  }
#line 228
  tmp = sqrt(j1scale);
#line 228
  tmp___0 = sqrt(j2scale);
#line 228
  corrilation /= tmp * tmp___0;
#line 230
  return (corrilation);
}
}
#line 236 "src/csuEBGMSimilarity.c"
double JetSimilarityCovariance(GaborJet j1___0 , GaborJet j2 ) 
{ 
  int i ;
  double magi ;
  double magj ;
  double dot ;
  double tmp ;
  double tmp___0 ;

  {
#line 238
  magi = 0.0;
#line 238
  magj = 0.0;
#line 238
  dot = 0.0;
#line 242
  if (j1___0) {
#line 242
    if (j2) {
#line 242
      if (j1___0->length) {
#line 242
        if (! (j1___0->length == j2->length)) {
#line 242
          __assert_fail("j1 && j2 && j1->length && j1->length==j2->length", "src/csuEBGMSimilarity.c",
                        242U, "JetSimilarityCovariance");
        }
      } else {
#line 242
        __assert_fail("j1 && j2 && j1->length && j1->length==j2->length", "src/csuEBGMSimilarity.c",
                      242U, "JetSimilarityCovariance");
      }
    } else {
#line 242
      __assert_fail("j1 && j2 && j1->length && j1->length==j2->length", "src/csuEBGMSimilarity.c",
                    242U, "JetSimilarityCovariance");
    }
  } else {
#line 242
    __assert_fail("j1 && j2 && j1->length && j1->length==j2->length", "src/csuEBGMSimilarity.c",
                  242U, "JetSimilarityCovariance");
  }
#line 244
  i = 0;
#line 244
  while (i < j1___0->length) {
#line 245
    magi += *(j1___0->realPart + i) * *(j1___0->realPart + i) + *(j1___0->imagPart + i) * *(j1___0->imagPart + i);
#line 246
    magj += *(j2->realPart + i) * *(j2->realPart + i) + *(j2->imagPart + i) * *(j2->imagPart + i);
#line 247
    dot += *(j1___0->realPart + i) * *(j2->realPart + i);
#line 248
    dot += *(j1___0->imagPart + i) * *(j2->imagPart + i);
#line 244
    i ++;
  }
#line 250
  tmp = sqrt(magi);
#line 250
  tmp___0 = sqrt(magj);
#line 250
  return (dot / (tmp * tmp___0));
}
}
#line 254 "src/csuEBGMSimilarity.c"
double JetSimilarityDisplacementCheckMag(GaborJet j1___0 , GaborJet j2 ) 
{ 
  double sim ;
  int i ;
  double tmp ;

  {
#line 255
  sim = 0.0;
#line 258
  i = 0;
#line 258
  while (i < j1___0->length) {
#line 259
    tmp = exp(- 0.1 * ((*(j1___0->mag + i) - *(j2->mag + i)) * (*(j1___0->mag + i) - *(j2->mag + i))));
#line 259
    sim += tmp;
#line 258
    i ++;
  }
#line 262
  return (sim);
}
}
#line 265 "src/csuEBGMSimilarity.c"
double JetSimilarityDisplacementCheckPhase(GaborJet j1___0 , GaborJet j2 ) 
{ 
  double sim ;
  double dx ;
  double dy ;
  int i ;
  double tmp ;

  {
#line 266
  sim = 0.0;
#line 267
  dx = j1___0->x - j2->x;
#line 268
  dy = j1___0->y - j2->y;
#line 271
  i = 0;
#line 271
  while (i < j1___0->length) {
#line 272
    tmp = cos((*(j1___0->ang + i) - *(j2->ang + i)) - (dx * *((j1___0->params)->kx + 2 * i) + dy * *((j1___0->params)->ky + 2 * i)));
#line 272
    sim += tmp;
#line 271
    i ++;
  }
#line 275
  return (sim);
}
}
#line 278 "src/csuEBGMSimilarity.c"
double JetSimilarityResponseMag(GaborJet j1___0 , GaborJet j2 ) 
{ 
  double sim ;
  int i ;

  {
#line 279
  sim = 0.0;
#line 282
  i = 0;
#line 282
  while (i < j1___0->length) {
#line 283
    sim += *(j1___0->mag + i);
#line 282
    i ++;
  }
#line 286
  return (sim);
}
}
#line 289 "src/csuEBGMSimilarity.c"
double JetSimilarityResponsePhase(GaborJet j1___0 , GaborJet j2 ) 
{ 
  double sim ;
  int i ;

  {
#line 290
  sim = 0.0;
#line 293
  i = 0;
#line 293
  while (i < j1___0->length) {
#line 294
    sim += *(j1___0->ang + i);
#line 293
    i ++;
  }
#line 297
  return (sim);
}
}
#line 308 "src/csuEBGMSimilarity.c"
double estimateDisplacementRandom(GaborJet j1___0 , GaborJet j2 , double *tdx , double *tdy ) 
{ 
  double j12 ;
  double j11 ;
  double j22 ;
  int i ;
  double sim ;
  double dx ;
  double tmp ;
  double dy ;
  double tmp___0 ;
  double tmp___1 ;
  double tmp___2 ;

  {
#line 309
  j12 = (double )0;
#line 310
  j11 = (double )0;
#line 311
  j22 = (double )0;
#line 313
  sim = 0.0;
#line 314
  tmp = randBM();
#line 314
  dx = tmp;
#line 314
  tmp___0 = randBM();
#line 314
  dy = tmp___0;
#line 317
  if (j1___0) {
#line 317
    if (j1___0->length) {
#line 317
      if (j2) {
#line 317
        if (! (j1___0->length == j2->length)) {
#line 317
          __assert_fail("j1 && j1->length && j2 && j1->length==j2->length", "src/csuEBGMSimilarity.c",
                        317U, "estimateDisplacementRandom");
        }
      } else {
#line 317
        __assert_fail("j1 && j1->length && j2 && j1->length==j2->length", "src/csuEBGMSimilarity.c",
                      317U, "estimateDisplacementRandom");
      }
    } else {
#line 317
      __assert_fail("j1 && j1->length && j2 && j1->length==j2->length", "src/csuEBGMSimilarity.c",
                    317U, "estimateDisplacementRandom");
    }
  } else {
#line 317
    __assert_fail("j1 && j1->length && j2 && j1->length==j2->length", "src/csuEBGMSimilarity.c",
                  317U, "estimateDisplacementRandom");
  }
#line 320
  j12 = 0.0;
#line 321
  j11 = 0.0;
#line 322
  j22 = 0.0;
#line 323
  i = 0;
#line 323
  while (i < j1___0->length) {
#line 324
    tmp___1 = cos((*(j1___0->ang + i) - *(j2->ang + i)) - (dx * *((j1___0->params)->kx + 2 * i) + dy * *((j1___0->params)->ky + 2 * i)));
#line 324
    j12 += (*(j1___0->mag + i) * *(j2->mag + i)) * tmp___1;
#line 325
    j11 += *(j1___0->mag + i) * *(j1___0->mag + i);
#line 326
    j22 += *(j2->mag + i) * *(j2->mag + i);
#line 323
    i ++;
  }
#line 328
  tmp___2 = sqrt(j11 * j22);
#line 328
  sim = j12 / tmp___2;
#line 331
  *tdx = dx;
#line 332
  *tdy = dy;
#line 334
  return (sim);
}
}
#line 339 "src/csuEBGMSimilarity.c"
double DEGridSample(GaborJet j1___0 , GaborJet j2 , double *tdx , double *tdy ) 
{ 
  double j12 ;
  double j11 ;
  double j22 ;
  int i ;
  int first ;
  double sim ;
  double dx ;
  double dy ;
  double tmp ;
  double tmp___0 ;
  double tmp___1 ;

  {
#line 340
  j12 = (double )0;
#line 341
  j11 = (double )0;
#line 342
  j22 = (double )0;
#line 344
  first = 1;
#line 345
  sim = 0.0;
#line 348
  if (j1___0) {
#line 348
    if (j1___0->length) {
#line 348
      if (j2) {
#line 348
        if (! (j1___0->length == j2->length)) {
#line 348
          __assert_fail("j1 && j1->length && j2 && j1->length==j2->length", "src/csuEBGMSimilarity.c",
                        348U, "DEGridSample");
        }
      } else {
#line 348
        __assert_fail("j1 && j1->length && j2 && j1->length==j2->length", "src/csuEBGMSimilarity.c",
                      348U, "DEGridSample");
      }
    } else {
#line 348
      __assert_fail("j1 && j1->length && j2 && j1->length==j2->length", "src/csuEBGMSimilarity.c",
                    348U, "DEGridSample");
    }
  } else {
#line 348
    __assert_fail("j1 && j1->length && j2 && j1->length==j2->length", "src/csuEBGMSimilarity.c",
                  348U, "DEGridSample");
  }
#line 349
  dx = - 16.0;
#line 349
  while (dx < 16.0) {
#line 350
    dy = - 16.0;
#line 350
    while (dy < 16.0) {
#line 351
      j12 = 0.0;
#line 352
      j11 = 0.0;
#line 353
      j22 = 0.0;
#line 354
      i = 0;
#line 354
      while (i < j1___0->length) {
#line 355
        tmp = cos((*(j1___0->ang + i) - *(j2->ang + i)) - (dx * *((j1___0->params)->kx + 2 * i) + dy * *((j1___0->params)->ky + 2 * i)));
#line 355
        j12 += (*(j1___0->mag + i) * *(j2->mag + i)) * tmp;
#line 356
        j11 += *(j1___0->mag + i) * *(j1___0->mag + i);
#line 357
        j22 += *(j2->mag + i) * *(j2->mag + i);
#line 354
        i ++;
      }
#line 359
      if (first) {
#line 360
        tmp___0 = sqrt(j11 * j22);
#line 360
        sim = j12 / tmp___0;
#line 361
        *tdx = dx;
#line 362
        *tdy = dy;
#line 363
        first = 0;
      } else {
#line 359
        tmp___1 = sqrt(j11 * j22);
#line 359
        if (sim < j12 / tmp___1) {
#line 360
          tmp___0 = sqrt(j11 * j22);
#line 360
          sim = j12 / tmp___0;
#line 361
          *tdx = dx;
#line 362
          *tdy = dy;
#line 363
          first = 0;
        }
      }
#line 350
      dy += 0.5;
    }
#line 349
    dx += 0.5;
  }
#line 367
  return (sim);
}
}
#line 374 "src/csuEBGMSimilarity.c"
double DEPredictiveStep(GaborJet j1___0 , GaborJet j2 , double *tdx , double *tdy ) 
{ 
  double j12 ;
  double j11 ;
  double j22 ;
  int i ;
  double sim ;
  double dx ;
  double dy ;
  double Gxx ;
  double Gxy ;
  double Gyx ;
  double Gyy ;
  double Px ;
  double Py ;
  double ang ;
  time_t tttt ;
  time_t tmp ;
  char *tmp___0 ;
  double tmp___1 ;
  double tmp___2 ;

  {
#line 375
  j12 = (double )0;
#line 376
  j11 = (double )0;
#line 377
  j22 = (double )0;
#line 379
  sim = 0.0;
#line 380
  dx = 0.0;
#line 380
  dy = 0.0;
#line 385
  if (j1___0) {
#line 385
    if (j1___0->length) {
#line 385
      if (j2) {
#line 385
        if (! (j1___0->length == j2->length)) {
#line 385
          __assert_fail("j1 && j1->length && j2 && j1->length==j2->length", "src/csuEBGMSimilarity.c",
                        385U, "DEPredictiveStep");
        }
      } else {
#line 385
        __assert_fail("j1 && j1->length && j2 && j1->length==j2->length", "src/csuEBGMSimilarity.c",
                      385U, "DEPredictiveStep");
      }
    } else {
#line 385
      __assert_fail("j1 && j1->length && j2 && j1->length==j2->length", "src/csuEBGMSimilarity.c",
                    385U, "DEPredictiveStep");
    }
  } else {
#line 385
    __assert_fail("j1 && j1->length && j2 && j1->length==j2->length", "src/csuEBGMSimilarity.c",
                  385U, "DEPredictiveStep");
  }
#line 387
  Gxx = (double )0;
#line 388
  Gxy = (double )0;
#line 389
  Gyx = (double )0;
#line 390
  Gyy = (double )0;
#line 392
  Px = (double )0;
#line 393
  Py = (double )0;
#line 395
  i = 0;
#line 395
  while (i < j1___0->length) {
#line 396
    ang = *(j1___0->ang + i) - *(j2->ang + i);
#line 399
    while (ang > 3.141592654) {
#line 399
      ang -= (double )2 * 3.141592654;
    }
#line 400
    while (ang < - 3.141592654) {
#line 400
      ang += (double )2 * 3.141592654;
    }
#line 402
    Gxx += ((*(j1___0->mag + i) * *(j2->mag + i)) * *((j1___0->params)->kx + 2 * i)) * *((j1___0->params)->kx + 2 * i);
#line 403
    Gxy += ((*(j1___0->mag + i) * *(j2->mag + i)) * *((j1___0->params)->kx + 2 * i)) * *((j1___0->params)->ky + 2 * i);
#line 404
    Gyx += ((*(j1___0->mag + i) * *(j2->mag + i)) * *((j1___0->params)->kx + 2 * i)) * *((j1___0->params)->ky + 2 * i);
#line 405
    Gyy += ((*(j1___0->mag + i) * *(j2->mag + i)) * *((j1___0->params)->ky + 2 * i)) * *((j1___0->params)->ky + 2 * i);
#line 407
    Px += ((*(j1___0->mag + i) * *(j2->mag + i)) * *((j1___0->params)->kx + 2 * i)) * ang;
#line 408
    Py += ((*(j1___0->mag + i) * *(j2->mag + i)) * *((j1___0->params)->ky + 2 * i)) * ang;
#line 395
    i ++;
  }
#line 412
  if (Gxx * Gyy - Gxy * Gyx != 0.0) {
#line 413
    dx = (Gyy * Px - Gyx * Py) / (Gxx * Gyy - Gxy * Gyx);
#line 414
    dy = (- Gxy * Px + Gxx * Py) / (Gxx * Gyy - Gxy * Gyx);
  } else {
#line 417
    tmp = time((time_t *)0);
#line 417
    tttt = tmp;
#line 417
    tmp___0 = ctime((time_t const   *)(& tttt));
#line 417
    printf((char const   * __restrict  )"**DEBUG %d** \"%s\"\n             at [%s]<%s():line %u>\n             %s\n",
           -1, "Warning: Divide by zero -- Attempting to recover", "src/csuEBGMSimilarity.c",
           "DEPredictiveStep", 417, tmp___0);
#line 417
    fflush(stdout);
#line 418
    dx = 0.0;
#line 419
    dy = 0.0;
  }
#line 423
  j12 = 0.0;
#line 424
  j11 = 0.0;
#line 425
  j22 = 0.0;
#line 426
  i = 0;
#line 426
  while (i < j1___0->length) {
#line 427
    tmp___1 = cos((*(j1___0->ang + i) - *(j2->ang + i)) - (dx * *((j1___0->params)->kx + 2 * i) + dy * *((j1___0->params)->ky + 2 * i)));
#line 427
    j12 += (*(j1___0->mag + i) * *(j2->mag + i)) * tmp___1;
#line 428
    j11 += *(j1___0->mag + i) * *(j1___0->mag + i);
#line 429
    j22 += *(j2->mag + i) * *(j2->mag + i);
#line 426
    i ++;
  }
#line 431
  tmp___2 = sqrt(j11 * j22);
#line 431
  sim = j12 / tmp___2;
#line 434
  *tdx = dx;
#line 435
  *tdy = dy;
#line 437
  return (sim);
}
}
#line 443 "src/csuEBGMSimilarity.c"
double DEPredictiveIter(GaborJet j1___0 , GaborJet j2 , double *tdx , double *tdy ) 
{ 
  double j12 ;
  double j11 ;
  double j22 ;
  int i ;
  int n ;
  double sim ;
  double dx ;
  double dy ;
  double ddx ;
  double ddy ;
  double Gxx ;
  double Gxy ;
  double Gyx ;
  double Gyy ;
  double Px ;
  double Py ;
  double ang ;
  time_t tttt ;
  time_t tmp ;
  char *tmp___0 ;
  double tmp___1 ;
  double tmp___2 ;

  {
#line 444
  j12 = (double )0;
#line 445
  j11 = (double )0;
#line 446
  j22 = (double )0;
#line 448
  sim = 0.0;
#line 449
  dx = 0.0;
#line 449
  dy = 0.0;
#line 455
  if (j1___0) {
#line 455
    if (j1___0->length) {
#line 455
      if (j2) {
#line 455
        if (! (j1___0->length == j2->length)) {
#line 455
          __assert_fail("j1 && j1->length && j2 && j1->length==j2->length", "src/csuEBGMSimilarity.c",
                        455U, "DEPredictiveIter");
        }
      } else {
#line 455
        __assert_fail("j1 && j1->length && j2 && j1->length==j2->length", "src/csuEBGMSimilarity.c",
                      455U, "DEPredictiveIter");
      }
    } else {
#line 455
      __assert_fail("j1 && j1->length && j2 && j1->length==j2->length", "src/csuEBGMSimilarity.c",
                    455U, "DEPredictiveIter");
    }
  } else {
#line 455
    __assert_fail("j1 && j1->length && j2 && j1->length==j2->length", "src/csuEBGMSimilarity.c",
                  455U, "DEPredictiveIter");
  }
#line 457
  n = 0;
#line 457
  while (n < 10) {
#line 459
    Gxx = (double )0;
#line 460
    Gxy = (double )0;
#line 461
    Gyx = (double )0;
#line 462
    Gyy = (double )0;
#line 464
    Px = (double )0;
#line 465
    Py = (double )0;
#line 467
    i = 0;
#line 467
    while (i < j1___0->length) {
#line 468
      ang = (*(j1___0->ang + i) - *(j2->ang + i)) - (dx * *((j1___0->params)->kx + 2 * i) + dy * *((j1___0->params)->ky + 2 * i));
#line 471
      while (ang > 3.141592654) {
#line 471
        ang -= (double )2 * 3.141592654;
      }
#line 472
      while (ang < - 3.141592654) {
#line 472
        ang += (double )2 * 3.141592654;
      }
#line 474
      Gxx += ((*(j1___0->mag + i) * *(j2->mag + i)) * *((j1___0->params)->kx + 2 * i)) * *((j1___0->params)->kx + 2 * i);
#line 475
      Gxy += ((*(j1___0->mag + i) * *(j2->mag + i)) * *((j1___0->params)->kx + 2 * i)) * *((j1___0->params)->ky + 2 * i);
#line 476
      Gyx += ((*(j1___0->mag + i) * *(j2->mag + i)) * *((j1___0->params)->kx + 2 * i)) * *((j1___0->params)->ky + 2 * i);
#line 477
      Gyy += ((*(j1___0->mag + i) * *(j2->mag + i)) * *((j1___0->params)->ky + 2 * i)) * *((j1___0->params)->ky + 2 * i);
#line 479
      Px += ((*(j1___0->mag + i) * *(j2->mag + i)) * *((j1___0->params)->kx + 2 * i)) * ang;
#line 480
      Py += ((*(j1___0->mag + i) * *(j2->mag + i)) * *((j1___0->params)->ky + 2 * i)) * ang;
#line 467
      i ++;
    }
#line 484
    if (Gxx * Gyy - Gxy * Gyx != 0.0) {
#line 485
      ddx = (Gyy * Px - Gyx * Py) / (Gxx * Gyy - Gxy * Gyx);
#line 486
      ddy = (- Gxy * Px + Gxx * Py) / (Gxx * Gyy - Gxy * Gyx);
#line 487
      dx += ddx;
#line 488
      dy += ddy;
#line 489
      if ((ddx * ddx + ddy) + ddy < .001) {
#line 489
        break;
      }
    } else {
#line 492
      tmp = time((time_t *)0);
#line 492
      tttt = tmp;
#line 492
      tmp___0 = ctime((time_t const   *)(& tttt));
#line 492
      printf((char const   * __restrict  )"**DEBUG %d** \"%s\"\n             at [%s]<%s():line %u>\n             %s\n",
             -1, "Warning: Divide by zero -- Attempting to recover", "src/csuEBGMSimilarity.c",
             "DEPredictiveIter", 492, tmp___0);
#line 492
      fflush(stdout);
#line 493
      dx += 0.0;
#line 494
      dy += 0.0;
    }
#line 457
    n ++;
  }
#line 499
  j12 = 0.0;
#line 500
  j11 = 0.0;
#line 501
  j22 = 0.0;
#line 502
  i = 0;
#line 502
  while (i < j1___0->length) {
#line 503
    tmp___1 = cos((*(j1___0->ang + i) - *(j2->ang + i)) - (dx * *((j1___0->params)->kx + 2 * i) + dy * *((j1___0->params)->ky + 2 * i)));
#line 503
    j12 += (*(j1___0->mag + i) * *(j2->mag + i)) * tmp___1;
#line 504
    j11 += *(j1___0->mag + i) * *(j1___0->mag + i);
#line 505
    j22 += *(j2->mag + i) * *(j2->mag + i);
#line 502
    i ++;
  }
#line 507
  tmp___2 = sqrt(j11 * j22);
#line 507
  sim = j12 / tmp___2;
#line 510
  *tdx = dx;
#line 511
  *tdy = dy;
#line 513
  return (sim);
}
}
#line 521 "src/csuEBGMSimilarity.c"
double DEFixedLocalSearch(GaborJet j1___0 , GaborJet j2 , double *tdx , double *tdy ) 
{ 
  double sim ;
  double dx ;
  double dy ;
  int change ;
  int iter ;
  double nextx ;
  double nexty ;
  double bestsim ;
  int tmp ;

  {
#line 522
  sim = 0.0;
#line 523
  dx = 0.0;
#line 523
  dy = 0.0;
#line 525
  change = 1;
#line 525
  iter = 50;
#line 528
  bestsim = 0.0;
#line 530
  if (j1___0) {
#line 530
    if (j1___0->length) {
#line 530
      if (j2) {
#line 530
        if (! (j1___0->length == j2->length)) {
#line 530
          __assert_fail("j1 && j1->length && j2 && j1->length==j2->length", "src/csuEBGMSimilarity.c",
                        530U, "DEFixedLocalSearch");
        }
      } else {
#line 530
        __assert_fail("j1 && j1->length && j2 && j1->length==j2->length", "src/csuEBGMSimilarity.c",
                      530U, "DEFixedLocalSearch");
      }
    } else {
#line 530
      __assert_fail("j1 && j1->length && j2 && j1->length==j2->length", "src/csuEBGMSimilarity.c",
                    530U, "DEFixedLocalSearch");
    }
  } else {
#line 530
    __assert_fail("j1 && j1->length && j2 && j1->length==j2->length", "src/csuEBGMSimilarity.c",
                  530U, "DEFixedLocalSearch");
  }
#line 533
  sim = SIM_DISPLACE(j1___0, j2, dx, dy);
#line 534
  bestsim = sim;
#line 536
  nextx = dx;
#line 537
  nexty = dy;
#line 538
  while (1) {
#line 538
    if (change) {
#line 538
      tmp = iter;
#line 538
      iter --;
#line 538
      if (! tmp) {
#line 538
        break;
      }
    } else {
#line 538
      break;
    }
#line 539
    dx = nextx;
#line 540
    dy = nexty;
#line 541
    change = 0;
#line 543
    sim = SIM_DISPLACE(j1___0, j2, dx + 0.5, dy + 0.5);
#line 544
    if (bestsim < sim) {
#line 545
      bestsim = sim;
#line 546
      nextx = dx + 0.5;
#line 547
      nexty = dy + 0.5;
#line 548
      change = 1;
    }
#line 551
    sim = SIM_DISPLACE(j1___0, j2, dx + 0.5, dy - 0.5);
#line 552
    if (bestsim < sim) {
#line 553
      bestsim = sim;
#line 554
      nextx = dx + 0.5;
#line 555
      nexty = dy - 0.5;
#line 556
      change = 1;
    }
#line 559
    sim = SIM_DISPLACE(j1___0, j2, dx - 0.5, dy - 0.5);
#line 560
    if (bestsim < sim) {
#line 561
      bestsim = sim;
#line 562
      nextx = dx - 0.5;
#line 563
      nexty = dy - 0.5;
#line 564
      change = 1;
    }
#line 567
    sim = SIM_DISPLACE(j1___0, j2, dx - 0.5, dy + 0.5);
#line 568
    if (bestsim < sim) {
#line 569
      bestsim = sim;
#line 570
      nextx = dx - 0.5;
#line 571
      nexty = dy + 0.5;
#line 572
      change = 1;
    }
#line 574
    dx = nextx;
#line 575
    dy = nexty;
  }
#line 578
  *tdx = dx;
#line 579
  *tdy = dy;
#line 581
  return (bestsim);
}
}
#line 584 "src/csuEBGMSimilarity.c"
double DENarrowingLocalSearch(GaborJet j1___0 , GaborJet j2 , double *tdx , double *tdy ) 
{ 
  double sim ;
  double dx ;
  double dy ;
  int change ;
  int iter ;
  double nextx ;
  double nexty ;
  double bestsim ;
  double tol ;
  double step ;
  int tmp ;

  {
#line 585
  sim = 0.0;
#line 586
  dx = 0.0;
#line 586
  dy = 0.0;
#line 588
  change = 1;
#line 588
  iter = 50;
#line 591
  bestsim = 0.0;
#line 592
  tol = .2;
#line 593
  step = 1.0;
#line 596
  if (j1___0) {
#line 596
    if (j1___0->length) {
#line 596
      if (j2) {
#line 596
        if (! (j1___0->length == j2->length)) {
#line 596
          __assert_fail("j1 && j1->length && j2 && j1->length==j2->length", "src/csuEBGMSimilarity.c",
                        596U, "DENarrowingLocalSearch");
        }
      } else {
#line 596
        __assert_fail("j1 && j1->length && j2 && j1->length==j2->length", "src/csuEBGMSimilarity.c",
                      596U, "DENarrowingLocalSearch");
      }
    } else {
#line 596
      __assert_fail("j1 && j1->length && j2 && j1->length==j2->length", "src/csuEBGMSimilarity.c",
                    596U, "DENarrowingLocalSearch");
    }
  } else {
#line 596
    __assert_fail("j1 && j1->length && j2 && j1->length==j2->length", "src/csuEBGMSimilarity.c",
                  596U, "DENarrowingLocalSearch");
  }
#line 598
  sim = SIM_DISPLACE(j1___0, j2, dx, dy);
#line 599
  bestsim = sim;
#line 600
  *tdx = 0.0;
#line 601
  *tdy = 0.0;
#line 603
  change = 1;
#line 604
  sim = SIM_DISPLACE(j1___0, j2, dx, dy);
#line 605
  bestsim = sim;
#line 607
  nextx = dx;
#line 608
  nexty = dy;
#line 609
  while (1) {
#line 609
    if (change) {
#line 609
      tmp = iter;
#line 609
      iter --;
#line 609
      if (! tmp) {
#line 609
        break;
      }
    } else {
#line 609
      break;
    }
#line 610
    dx = nextx;
#line 611
    dy = nexty;
#line 612
    change = 0;
#line 614
    sim = SIM_DISPLACE(j1___0, j2, dx + step, dy + step);
#line 615
    if (bestsim < sim) {
#line 616
      bestsim = sim;
#line 617
      nextx = dx + step;
#line 618
      nexty = dy + step;
#line 619
      change = 1;
    }
#line 622
    sim = SIM_DISPLACE(j1___0, j2, dx + step, dy - step);
#line 623
    if (bestsim < sim) {
#line 624
      bestsim = sim;
#line 625
      nextx = dx + step;
#line 626
      nexty = dy - step;
#line 627
      change = 1;
    }
#line 630
    sim = SIM_DISPLACE(j1___0, j2, dx - step, dy - step);
#line 631
    if (bestsim < sim) {
#line 632
      bestsim = sim;
#line 633
      nextx = dx - step;
#line 634
      nexty = dy - step;
#line 635
      change = 1;
    }
#line 638
    sim = SIM_DISPLACE(j1___0, j2, dx - step, dy + step);
#line 639
    if (bestsim < sim) {
#line 640
      bestsim = sim;
#line 641
      nextx = dx - step;
#line 642
      nexty = dy + step;
#line 643
      change = 1;
    }
#line 645
    dx = nextx;
#line 646
    dy = nexty;
#line 648
    if (change == 0) {
#line 648
      if (step > tol) {
#line 649
        change = 1;
#line 650
        step *= 0.5;
      }
    }
  }
#line 654
  *tdx = dx;
#line 655
  *tdy = dy;
#line 658
  return (bestsim);
}
}
#line 664 "src/csuEBGMSimilarity.c"
double GeometrySimL2(FaceGraph f1 , FaceGraph f2 ) 
{ 
  double totalSim ;
  int i ;
  double tmp ;

  {
#line 665
  totalSim = 0.0;
#line 668
  i = 0;
#line 668
  while (i < f1->geosize) {
#line 669
    tmp = sqrt(((*(f1->jets + i))->x - (*(f2->jets + i))->x) * ((*(f1->jets + i))->x - (*(f2->jets + i))->x) + ((*(f1->jets + i))->y - (*(f2->jets + i))->y) * ((*(f1->jets + i))->y - (*(f2->jets + i))->y));
#line 669
    totalSim += tmp;
#line 668
    i ++;
  }
#line 671
  return (totalSim);
}
}
#line 676 "src/csuEBGMSimilarity.c"
double GeometrySimCorrelation(FaceGraph f1 , FaceGraph f2 ) 
{ 
  int i ;
  double sum1 ;
  double sum2 ;
  double mean1 ;
  double mean2 ;
  double len1 ;
  double len2 ;
  double sqsum1 ;
  double sqsum2 ;
  double corr ;
  Matrix g1 ;
  Matrix tmp ;
  Matrix g2 ;
  Matrix tmp___0 ;
  time_t tttt ;
  time_t tmp___1 ;
  char *tmp___2 ;
  double tmp___3 ;
  double tmp___4 ;

  {
#line 678
  sum1 = 0.0;
#line 678
  sum2 = 0.0;
#line 679
  mean1 = 0.0;
#line 679
  mean2 = 0.0;
#line 680
  len1 = 0.0;
#line 680
  len2 = 0.0;
#line 681
  sqsum1 = 0.0;
#line 681
  sqsum2 = 0.0;
#line 682
  corr = 0.0;
#line 684
  tmp = makeMatrix(f1->geosize * 2, 1);
#line 684
  g1 = tmp;
#line 685
  tmp___0 = makeMatrix(f1->geosize * 2, 1);
#line 685
  g2 = tmp___0;
#line 687
  tmp___1 = time((time_t *)0);
#line 687
  tttt = tmp___1;
#line 687
  tmp___2 = ctime((time_t const   *)(& tttt));
#line 687
  printf((char const   * __restrict  )"**DEBUG CHECK** Failed check (%s) \"%s\"\n             at [%s]<%s():line %u>\n             %s\n",
         "0", "This function has not yet been implemented", "src/csuEBGMSimilarity.c",
         "GeometrySimCorrelation", 687, tmp___2);
#line 687
  fflush(stdout);
#line 687
  exit(1);
#line 689
  i = 0;
#line 689
  while (i < g1->row_dim) {
#line 690
    if (i % 2) {
#line 690
      *(*(g1->cols + 0) + i) = (*(f1->jets + i / 2))->y;
    } else {
#line 690
      *(*(g1->cols + 0) + i) = (*(f1->jets + i / 2))->x;
    }
#line 691
    if (i % 2) {
#line 691
      *(*(g2->cols + 0) + i) = (*(f2->jets + i / 2))->y;
    } else {
#line 691
      *(*(g2->cols + 0) + i) = (*(f2->jets + i / 2))->x;
    }
#line 689
    i ++;
  }
#line 694
  i = 0;
#line 694
  while (i < g1->row_dim) {
#line 695
    sum1 += *(*(g1->cols + 0) + i);
#line 696
    sum2 += *(*(g2->cols + 0) + i);
#line 694
    i ++;
  }
#line 699
  mean1 = sum1 / (double )g1->row_dim;
#line 700
  mean2 = sum2 / (double )g2->row_dim;
#line 702
  i = 0;
#line 702
  while (i < g1->row_dim) {
#line 703
    *(*(g1->cols + 0) + i) -= mean1;
#line 704
    *(*(g2->cols + 0) + i) -= mean2;
#line 705
    sqsum1 += *(*(g1->cols + 0) + i) * *(*(g1->cols + 0) + i);
#line 706
    sqsum2 += *(*(g2->cols + 0) + i) * *(*(g2->cols + 0) + i);
#line 702
    i ++;
  }
#line 709
  tmp___3 = sqrt(sqsum1);
#line 709
  len1 = 1.0 / tmp___3;
#line 710
  tmp___4 = sqrt(sqsum2);
#line 710
  len2 = 1.0 / tmp___4;
#line 712
  i = 0;
#line 712
  while (i < g1->row_dim) {
#line 713
    *(*(g1->cols + 0) + i) *= len1;
#line 714
    *(*(g2->cols + 0) + i) *= len2;
#line 715
    corr += *(*(g1->cols + 0) + i) * *(*(g2->cols + 0) + i);
#line 712
    i ++;
  }
#line 718
  freeMatrix(g1);
#line 719
  freeMatrix(g2);
#line 720
  return (- corr);
}
}
#line 730 "src/csuEBGMSimilarity.c"
void TransformLeastSquares(Matrix g1 , Matrix g2 ) 
{ 
  int i ;
  double dist ;
  Matrix A ;
  Matrix tmp ;
  Matrix v ;
  double b ;
  double a ;
  double dx ;
  double dy ;
  double x ;
  double y ;

  {
#line 732
  dist = 0.0;
#line 734
  tmp = makeMatrix(g1->row_dim, 4);
#line 734
  A = tmp;
#line 738
  dist = 0.0;
#line 740
  i = 0;
#line 740
  while (i < g1->row_dim / 2) {
#line 741
    *(*(A->cols + 0) + 2 * i) = *(*(g1->cols + 0) + 2 * i);
#line 742
    *(*(A->cols + 1) + 2 * i) = - *(*(g1->cols + 0) + (2 * i + 1));
#line 743
    *(*(A->cols + 2) + 2 * i) = (double )1;
#line 744
    *(*(A->cols + 3) + 2 * i) = (double )0;
#line 746
    *(*(A->cols + 0) + (2 * i + 1)) = *(*(g1->cols + 0) + (2 * i + 1));
#line 747
    *(*(A->cols + 1) + (2 * i + 1)) = *(*(g1->cols + 0) + 2 * i);
#line 748
    *(*(A->cols + 2) + (2 * i + 1)) = (double )0;
#line 749
    *(*(A->cols + 3) + (2 * i + 1)) = (double )1;
#line 740
    i ++;
  }
#line 752
  v = leastSquares(A, g2);
#line 754
  a = *(*(v->cols + 0) + 0);
#line 755
  b = *(*(v->cols + 0) + 1);
#line 756
  dx = *(*(v->cols + 0) + 2);
#line 757
  dy = *(*(v->cols + 0) + 3);
#line 759
  dist = 0.0;
#line 760
  i = 0;
#line 760
  while (i < g1->row_dim / 2) {
#line 761
    x = *(*(g1->cols + 0) + 2 * i);
#line 762
    y = *(*(g1->cols + 0) + (2 * i + 1));
#line 764
    *(*(g1->cols + 0) + 2 * i) = (a * x - b * y) + dx;
#line 765
    *(*(g1->cols + 0) + (2 * i + 1)) = (b * x + a * y) + dy;
#line 760
    i ++;
  }
#line 769
  freeMatrix(v);
#line 770
  freeMatrix(A);
#line 771
  return;
}
}
#line 773 "src/csuEBGMSimilarity.c"
double L2Dist(Matrix g1 , Matrix g2 ) 
{ 
  double dist ;
  int i ;
  double tmp ;

  {
#line 774
  dist = 0.0;
#line 777
  i = 0;
#line 777
  while (i < g1->row_dim / 2) {
#line 778
    dist += (*(*(g1->cols + 0) + 2 * i) - *(*(g2->cols + 0) + 2 * i)) * (*(*(g1->cols + 0) + 2 * i) - *(*(g2->cols + 0) + 2 * i));
#line 779
    dist += (*(*(g1->cols + 0) + (2 * i + 1)) - *(*(g2->cols + 0) + (2 * i + 1))) * (*(*(g1->cols + 0) + (2 * i + 1)) - *(*(g2->cols + 0) + (2 * i + 1)));
#line 777
    i ++;
  }
#line 782
  tmp = sqrt(dist);
#line 782
  return (tmp);
}
}
#line 792 "src/csuEBGMSimilarity.c"
double GeometrySimLeastSquares(FaceGraph f1 , FaceGraph f2 ) 
{ 
  int i ;
  double dist ;
  Matrix g1 ;
  Matrix tmp ;
  Matrix g2 ;
  Matrix tmp___0 ;

  {
#line 794
  dist = 0.0;
#line 796
  tmp = makeMatrix(f1->geosize * 2, 1);
#line 796
  g1 = tmp;
#line 797
  tmp___0 = makeMatrix(f1->geosize * 2, 1);
#line 797
  g2 = tmp___0;
#line 799
  i = 0;
#line 799
  while (i < g1->row_dim) {
#line 800
    if (i % 2) {
#line 800
      *(*(g1->cols + 0) + i) = (*(f1->jets + i / 2))->y;
    } else {
#line 800
      *(*(g1->cols + 0) + i) = (*(f1->jets + i / 2))->x;
    }
#line 801
    if (i % 2) {
#line 801
      *(*(g2->cols + 0) + i) = (*(f2->jets + i / 2))->y;
    } else {
#line 801
      *(*(g2->cols + 0) + i) = (*(f2->jets + i / 2))->x;
    }
#line 799
    i ++;
  }
#line 804
  TransformLeastSquares(g1, g2);
#line 806
  dist = L2Dist(g1, g2);
#line 808
  freeMatrix(g1);
#line 809
  freeMatrix(g2);
#line 811
  return (dist);
}
}
#line 820 "src/csuEBGMSimilarity.c"
double GeometrySimLeastSquaresPS(FaceGraph f1 , FaceGraph f2 ) 
{ 
  int i ;
  double dist ;
  Matrix g1 ;
  Matrix tmp ;
  Matrix g2 ;
  Matrix tmp___0 ;
  double dedx ;
  double dedy ;

  {
#line 822
  dist = 0.0;
#line 824
  tmp = makeMatrix(f1->geosize * 2, 1);
#line 824
  g1 = tmp;
#line 825
  tmp___0 = makeMatrix(f1->geosize * 2, 1);
#line 825
  g2 = tmp___0;
#line 827
  i = 0;
#line 827
  while (i < f1->geosize) {
#line 828
    dedx = (double )0;
#line 828
    dedy = (double )0;
#line 829
    DEPredictiveStep(*(f1->jets + i), *(f2->jets + i), & dedx, & dedy);
#line 831
    *(*(g1->cols + 0) + 2 * i) = (*(f1->jets + i))->x;
#line 832
    *(*(g1->cols + 0) + (2 * i + 1)) = (*(f1->jets + i))->y;
#line 833
    *(*(g2->cols + 0) + 2 * i) = (*(f2->jets + i))->x + dedx;
#line 834
    *(*(g2->cols + 0) + (2 * i + 1)) = (*(f2->jets + i))->y + dedy;
#line 827
    i ++;
  }
#line 837
  TransformLeastSquares(g1, g2);
#line 839
  dist = L2Dist(g1, g2);
#line 841
  freeMatrix(g1);
#line 842
  freeMatrix(g2);
#line 844
  return (dist);
}
}
#line 854 "src/csuEBGMSimilarity.c"
double GeometrySimLeastSquaresPI(FaceGraph f1 , FaceGraph f2 ) 
{ 
  int i ;
  double dist ;
  Matrix g1 ;
  Matrix tmp ;
  Matrix g2 ;
  Matrix tmp___0 ;
  double dedx ;
  double dedy ;

  {
#line 856
  dist = 0.0;
#line 858
  tmp = makeMatrix(f1->geosize * 2, 1);
#line 858
  g1 = tmp;
#line 859
  tmp___0 = makeMatrix(f1->geosize * 2, 1);
#line 859
  g2 = tmp___0;
#line 861
  i = 0;
#line 861
  while (i < f1->geosize) {
#line 862
    dedx = (double )0;
#line 862
    dedy = (double )0;
#line 863
    DEPredictiveIter(*(f1->jets + i), *(f2->jets + i), & dedx, & dedy);
#line 865
    *(*(g1->cols + 0) + 2 * i) = (*(f1->jets + i))->x;
#line 866
    *(*(g1->cols + 0) + (2 * i + 1)) = (*(f1->jets + i))->y;
#line 867
    *(*(g2->cols + 0) + 2 * i) = (*(f2->jets + i))->x + dedx;
#line 868
    *(*(g2->cols + 0) + (2 * i + 1)) = (*(f2->jets + i))->y + dedy;
#line 861
    i ++;
  }
#line 871
  TransformLeastSquares(g1, g2);
#line 873
  dist = L2Dist(g1, g2);
#line 875
  freeMatrix(g1);
#line 876
  freeMatrix(g2);
#line 878
  return (dist);
}
}
#line 888 "src/csuEBGMSimilarity.c"
double GeometrySimLeastSquaresFLS(FaceGraph f1 , FaceGraph f2 ) 
{ 
  int i ;
  double dist ;
  Matrix g1 ;
  Matrix tmp ;
  Matrix g2 ;
  Matrix tmp___0 ;
  double dedx ;
  double dedy ;

  {
#line 890
  dist = 0.0;
#line 892
  tmp = makeMatrix(f1->geosize * 2, 1);
#line 892
  g1 = tmp;
#line 893
  tmp___0 = makeMatrix(f1->geosize * 2, 1);
#line 893
  g2 = tmp___0;
#line 895
  i = 0;
#line 895
  while (i < f1->geosize) {
#line 896
    dedx = (double )0;
#line 896
    dedy = (double )0;
#line 897
    DEFixedLocalSearch(*(f1->jets + i), *(f2->jets + i), & dedx, & dedy);
#line 899
    *(*(g1->cols + 0) + 2 * i) = (*(f1->jets + i))->x;
#line 900
    *(*(g1->cols + 0) + (2 * i + 1)) = (*(f1->jets + i))->y;
#line 901
    *(*(g2->cols + 0) + 2 * i) = (*(f2->jets + i))->x + dedx;
#line 902
    *(*(g2->cols + 0) + (2 * i + 1)) = (*(f2->jets + i))->y + dedy;
#line 895
    i ++;
  }
#line 905
  TransformLeastSquares(g1, g2);
#line 907
  dist = L2Dist(g1, g2);
#line 909
  freeMatrix(g1);
#line 910
  freeMatrix(g2);
#line 912
  return (dist);
}
}
#line 922 "src/csuEBGMSimilarity.c"
double GeometrySimLeastSquaresNLS(FaceGraph f1 , FaceGraph f2 ) 
{ 
  int i ;
  double dist ;
  Matrix g1 ;
  Matrix tmp ;
  Matrix g2 ;
  Matrix tmp___0 ;
  double dedx ;
  double dedy ;

  {
#line 924
  dist = 0.0;
#line 926
  tmp = makeMatrix(f1->geosize * 2, 1);
#line 926
  g1 = tmp;
#line 927
  tmp___0 = makeMatrix(f1->geosize * 2, 1);
#line 927
  g2 = tmp___0;
#line 929
  i = 0;
#line 929
  while (i < f1->geosize) {
#line 930
    dedx = (double )0;
#line 930
    dedy = (double )0;
#line 931
    DENarrowingLocalSearch(*(f1->jets + i), *(f2->jets + i), & dedx, & dedy);
#line 933
    *(*(g1->cols + 0) + 2 * i) = (*(f1->jets + i))->x;
#line 934
    *(*(g1->cols + 0) + (2 * i + 1)) = (*(f1->jets + i))->y;
#line 935
    *(*(g2->cols + 0) + 2 * i) = (*(f2->jets + i))->x + dedx;
#line 936
    *(*(g2->cols + 0) + (2 * i + 1)) = (*(f2->jets + i))->y + dedy;
#line 929
    i ++;
  }
#line 939
  TransformLeastSquares(g1, g2);
#line 941
  dist = L2Dist(g1, g2);
#line 943
  freeMatrix(g1);
#line 944
  freeMatrix(g2);
#line 946
  return (dist);
}
}
#line 959 "src/csuEBGMSimilarity.c"
double fgSimMagnitude(FaceGraph f1 , FaceGraph f2 ) 
{ 
  double totalSim ;
  int i ;
  double tmp ;

  {
#line 960
  totalSim = 0.0;
#line 963
  i = 0;
#line 963
  while (i < f1->totalsize) {
#line 964
    tmp = JetSimilarityMag(*(f1->jets + i), *(f2->jets + i));
#line 964
    totalSim += tmp;
#line 963
    i ++;
  }
#line 966
  totalSim /= (double )f1->totalsize;
#line 968
  return (- totalSim);
}
}
#line 972 "src/csuEBGMSimilarity.c"
double fgSimPhase01(FaceGraph f1 , FaceGraph f2 ) 
{ 
  double totalSim ;
  int i ;
  double tmp ;

  {
#line 973
  totalSim = 0.0;
#line 976
  i = 0;
#line 976
  while (i < f1->totalsize) {
#line 977
    tmp = JetSimilarityPhase(*(f1->jets + i), *(f2->jets + i));
#line 977
    totalSim += tmp;
#line 976
    i ++;
  }
#line 979
  totalSim /= (double )f1->totalsize;
#line 981
  return (- totalSim);
}
}
#line 985 "src/csuEBGMSimilarity.c"
double fgSimPhase02(FaceGraph f1 , FaceGraph f2 ) 
{ 
  double totalSim ;
  int i ;
  double tmp ;

  {
#line 986
  totalSim = 0.0;
#line 989
  i = 0;
#line 989
  while (i < f1->totalsize) {
#line 990
    tmp = JetSimilarityDEPredictiveStep(*(f1->jets + i), *(f2->jets + i));
#line 990
    totalSim += tmp;
#line 989
    i ++;
  }
#line 992
  totalSim /= (double )f1->totalsize;
#line 994
  return (- totalSim);
}
}
#line 998 "src/csuEBGMSimilarity.c"
double fgSimPhase03(FaceGraph f1 , FaceGraph f2 ) 
{ 
  double totalSim ;
  int i ;
  double tmp ;

  {
#line 999
  totalSim = 0.0;
#line 1002
  i = 0;
#line 1002
  while (i < f1->totalsize) {
#line 1003
    tmp = JetSimilarityDEGridSample(*(f1->jets + i), *(f2->jets + i));
#line 1003
    totalSim += tmp;
#line 1002
    i ++;
  }
#line 1005
  totalSim /= (double )f1->totalsize;
#line 1007
  return (- totalSim);
}
}
#line 1011 "src/csuEBGMSimilarity.c"
double fgSimPhase04(FaceGraph f1 , FaceGraph f2 ) 
{ 
  double totalSim ;
  int i ;
  double tmp ;

  {
#line 1012
  totalSim = 0.0;
#line 1015
  i = 0;
#line 1015
  while (i < f1->totalsize) {
#line 1016
    tmp = JetSimilarityDEFixedLocalSearch(*(f1->jets + i), *(f2->jets + i));
#line 1016
    totalSim += tmp;
#line 1015
    i ++;
  }
#line 1018
  totalSim /= (double )f1->totalsize;
#line 1020
  return (- totalSim);
}
}
#line 1024 "src/csuEBGMSimilarity.c"
double fgSimPhase05(FaceGraph f1 , FaceGraph f2 ) 
{ 
  double totalSim ;
  int i ;
  double tmp ;

  {
#line 1025
  totalSim = 0.0;
#line 1028
  i = 0;
#line 1028
  while (i < f1->totalsize) {
#line 1029
    tmp = JetSimilarityDENarrowingLocalSearch(*(f1->jets + i), *(f2->jets + i));
#line 1029
    totalSim += tmp;
#line 1028
    i ++;
  }
#line 1031
  totalSim /= (double )f1->totalsize;
#line 1033
  return (- totalSim);
}
}
#line 1038 "src/csuEBGMSimilarity.c"
double fgSimPhase06(FaceGraph f1 , FaceGraph f2 ) 
{ 
  double totalSim ;
  int i ;
  double tmp ;

  {
#line 1039
  totalSim = 0.0;
#line 1042
  i = 0;
#line 1042
  while (i < f1->totalsize) {
#line 1043
    tmp = JetSimilarityDEPredictiveIter(*(f1->jets + i), *(f2->jets + i));
#line 1043
    totalSim += tmp;
#line 1042
    i ++;
  }
#line 1045
  totalSim /= (double )f1->totalsize;
#line 1047
  return (- totalSim);
}
}
#line 1050 "src/csuEBGMSimilarity.c"
double fgSimPhase(FaceGraph f1 , FaceGraph f2 ) 
{ 
  double totalSim ;
  int i ;
  double tmp ;

  {
#line 1051
  totalSim = 0.0;
#line 1054
  i = 0;
#line 1054
  while (i < f1->totalsize) {
#line 1055
    tmp = JetSimilarityPhase(*(f1->jets + i), *(f2->jets + i));
#line 1055
    totalSim += tmp;
#line 1054
    i ++;
  }
#line 1057
  totalSim /= (double )f1->totalsize;
#line 1059
  return (- totalSim);
}
}
#line 1064 "src/csuEBGMSimilarity.c"
double fgSimPhaseGridSample(FaceGraph f1 , FaceGraph f2 ) 
{ 
  double totalSim ;
  int i ;
  double tmp ;

  {
#line 1065
  totalSim = 0.0;
#line 1068
  i = 0;
#line 1068
  while (i < f1->totalsize) {
#line 1069
    tmp = JetSimilarityDEGridSample(*(f1->jets + i), *(f2->jets + i));
#line 1069
    totalSim += tmp;
#line 1068
    i ++;
  }
#line 1071
  totalSim /= (double )f1->totalsize;
#line 1073
  return (- totalSim);
}
}
#line 1079 "src/csuEBGMSimilarity.c"
double fgSimPhasePredictiveStep(FaceGraph f1 , FaceGraph f2 ) 
{ 
  double totalSim ;
  int i ;
  double tmp ;

  {
#line 1080
  totalSim = 0.0;
#line 1083
  i = 0;
#line 1083
  while (i < f1->totalsize) {
#line 1084
    tmp = JetSimilarityDEPredictiveStep(*(f1->jets + i), *(f2->jets + i));
#line 1084
    totalSim += tmp;
#line 1083
    i ++;
  }
#line 1086
  totalSim /= (double )f1->totalsize;
#line 1088
  return (- totalSim);
}
}
#line 1094 "src/csuEBGMSimilarity.c"
double fgSimPhasePredictiveIter(FaceGraph f1 , FaceGraph f2 ) 
{ 
  double totalSim ;
  int i ;
  double tmp ;

  {
#line 1095
  totalSim = 0.0;
#line 1098
  i = 0;
#line 1098
  while (i < f1->totalsize) {
#line 1099
    tmp = JetSimilarityDEPredictiveIter(*(f1->jets + i), *(f2->jets + i));
#line 1099
    totalSim += tmp;
#line 1098
    i ++;
  }
#line 1101
  totalSim /= (double )f1->totalsize;
#line 1103
  return (- totalSim);
}
}
#line 1109 "src/csuEBGMSimilarity.c"
double fgSimPhaseFixedLocalSearch(FaceGraph f1 , FaceGraph f2 ) 
{ 
  double totalSim ;
  int i ;
  double tmp ;

  {
#line 1110
  totalSim = 0.0;
#line 1113
  i = 0;
#line 1113
  while (i < f1->totalsize) {
#line 1114
    tmp = JetSimilarityDEFixedLocalSearch(*(f1->jets + i), *(f2->jets + i));
#line 1114
    totalSim += tmp;
#line 1113
    i ++;
  }
#line 1116
  totalSim /= (double )f1->totalsize;
#line 1118
  return (- totalSim);
}
}
#line 1124 "src/csuEBGMSimilarity.c"
double fgSimPhaseNarrowingLocalSearch(FaceGraph f1 , FaceGraph f2 ) 
{ 
  double totalSim ;
  int i ;
  double tmp ;

  {
#line 1125
  totalSim = 0.0;
#line 1128
  i = 0;
#line 1128
  while (i < f1->totalsize) {
#line 1129
    tmp = JetSimilarityDENarrowingLocalSearch(*(f1->jets + i), *(f2->jets + i));
#line 1129
    totalSim += tmp;
#line 1128
    i ++;
  }
#line 1131
  totalSim /= (double )f1->totalsize;
#line 1133
  return (- totalSim);
}
}
#line 1 "csuSubspaceEigen.o"
#pragma merger("0","/tmp/cil-ogFr61Hr.i","-O3,-Wall")
#line 150 "/usr/include/x86_64-linux-gnu/bits/mathinline.h"
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__, __always_inline__)) __signbitl)(long double __x )  __attribute__((__const__)) ;
#line 150 "/usr/include/x86_64-linux-gnu/bits/mathinline.h"
__inline extern int ( __attribute__((__leaf__, __always_inline__)) __signbitl)(long double __x ) 
{ 
  union __anonunion___u_26___7 __u ;

  {
#line 153
  __u.__l = __x;
#line 154
  return ((__u.__i[2] & 32768) != 0);
}
}
#line 147 "src/csuCommonSubspace.h"
int cvJacobiEigens_64d(double *A , double *V , double *E , int n , double eps ) ;
#line 88 "src/csuSubspaceEigen.c"
int eigen_verify(Matrix M , Matrix lambda , Matrix R ) 
{ 
  Matrix RtR ;
  Matrix tmp ;
  Matrix identity ;
  Matrix tmp___0 ;
  Matrix MR ;
  Matrix tmp___1 ;
  Matrix D ;
  Matrix tmp___2 ;
  Matrix RD ;
  Matrix test ;
  int i ;
  int j ;
  int failed ;
  double tol ;
  time_t tttt ;
  time_t tmp___3 ;
  char *tmp___4 ;
  time_t tttt___0 ;
  time_t tmp___5 ;
  char *tmp___6 ;
  time_t tttt___1 ;
  time_t tmp___7 ;
  char *tmp___8 ;
  time_t tttt___2 ;
  time_t tmp___9 ;
  char *tmp___10 ;
  double tmp___11 ;
  time_t tttt___3 ;
  time_t tmp___12 ;
  char *tmp___13 ;
  time_t tttt___4 ;
  time_t tmp___14 ;
  char *tmp___15 ;
  time_t tttt___5 ;
  time_t tmp___16 ;
  char *tmp___17 ;
  time_t tttt___6 ;
  time_t tmp___18 ;
  char *tmp___19 ;
  double tmp___20 ;

  {
#line 89
  tmp = transposeMultiplyMatrixL((Matrix const   )R, (Matrix const   )R);
#line 89
  RtR = tmp;
#line 90
  tmp___0 = makeIdentityMatrix(R->col_dim);
#line 90
  identity = tmp___0;
#line 92
  tmp___1 = multiplyMatrix((Matrix const   )M, (Matrix const   )R);
#line 92
  MR = tmp___1;
#line 93
  tmp___2 = makeIdentityMatrix(lambda->row_dim);
#line 93
  D = tmp___2;
#line 97
  failed = 0;
#line 98
  tol = 1.0e-7;
#line 100
  i = 0;
#line 100
  while (i < lambda->row_dim) {
#line 101
    *(*(D->cols + i) + i) = *(*(lambda->cols + 0) + i);
#line 100
    i ++;
  }
#line 103
  RD = multiplyMatrix((Matrix const   )R, (Matrix const   )D);
#line 104
  freeMatrix(D);
#line 106
  if (2 <= debuglevel) {
#line 106
    tmp___3 = time((time_t *)0);
#line 106
    tttt = tmp___3;
#line 106
    tmp___4 = ctime((time_t const   *)(& tttt));
#line 106
    printf((char const   * __restrict  )"**DEBUG %d** \"%s\"\n             at [%s]<%s():line %u>\n             %s\n",
           2, "Checking orthogonality of eigenvectors", "src/csuSubspaceEigen.c",
           "eigen_verify", 106, tmp___4);
#line 106
    fflush(stdout);
  }
#line 107
  test = subtractMatrix((Matrix const   )RtR, (Matrix const   )identity);
#line 108
  freeMatrix(RtR);
#line 109
  freeMatrix(identity);
#line 111
  i = 0;
#line 111
  while (i < test->row_dim) {
#line 112
    j = 0;
#line 112
    while (j < test->col_dim) {
#line 113
      if (*(*(test->cols + j) + i) < (double )0) {
#line 113
        tmp___11 = - *(*(test->cols + j) + i);
      } else {
#line 113
        tmp___11 = *(*(test->cols + j) + i);
      }
#line 113
      if (! (tmp___11 < tol)) {
#line 114
        failed = 1;
#line 115
        tmp___5 = time((time_t *)0);
#line 115
        tttt___0 = tmp___5;
#line 115
        if (quiet == 0) {
#line 115
          printf((char const   * __restrict  )"Eigenvectors are not orthogonal to within tolerance.");
        } else
#line 115
        if (debuglevel != 0) {
#line 115
          printf((char const   * __restrict  )"Eigenvectors are not orthogonal to within tolerance.");
        }
#line 115
        if (quiet == 0) {
#line 115
          printf((char const   * __restrict  )"\n");
        } else
#line 115
        if (debuglevel != 0) {
#line 115
          printf((char const   * __restrict  )"\n");
        }
#line 115
        if (debuglevel > 0) {
#line 115
          tmp___6 = ctime((time_t const   *)(& tttt___0));
#line 115
          printf((char const   * __restrict  )"    [%s]<%s():line %u> %s\n", "src/csuSubspaceEigen.c",
                 "eigen_verify", 115, tmp___6);
        }
#line 115
        fflush(stdout);
#line 116
        if (1 <= debuglevel) {
#line 116
          tmp___7 = time((time_t *)0);
#line 116
          tttt___1 = tmp___7;
#line 116
          tmp___8 = ctime((time_t const   *)(& tttt___1));
#line 116
          printf((char const   * __restrict  )"**DEBUG %d** \"%s\" %s=%f\n             at [%s]<%s():line %u>\n             %s\n",
                 1, "Matrix Element", "ME(test, i, j)", *(*(test->cols + j) + i),
                 "src/csuSubspaceEigen.c", "eigen_verify", 116, tmp___8);
#line 116
          fflush(stdout);
        }
#line 117
        if (1 <= debuglevel) {
#line 117
          tmp___9 = time((time_t *)0);
#line 117
          tttt___2 = tmp___9;
#line 117
          tmp___10 = ctime((time_t const   *)(& tttt___2));
#line 117
          printf((char const   * __restrict  )"**DEBUG %d** \"%s\" %s=%f\n             at [%s]<%s():line %u>\n             %s\n",
                 1, "Tolerance", "tol", tol, "src/csuSubspaceEigen.c", "eigen_verify",
                 117, tmp___10);
#line 117
          fflush(stdout);
        }
#line 118
        exit(1);
      }
#line 112
      j ++;
    }
#line 111
    i ++;
  }
#line 122
  freeMatrix(test);
#line 124
  if (2 <= debuglevel) {
#line 124
    tmp___12 = time((time_t *)0);
#line 124
    tttt___3 = tmp___12;
#line 124
    tmp___13 = ctime((time_t const   *)(& tttt___3));
#line 124
    printf((char const   * __restrict  )"**DEBUG %d** \"%s\"\n             at [%s]<%s():line %u>\n             %s\n",
           2, "Checking reconstruction property of eigensystem", "src/csuSubspaceEigen.c",
           "eigen_verify", 124, tmp___13);
#line 124
    fflush(stdout);
  }
#line 125
  test = subtractMatrix((Matrix const   )MR, (Matrix const   )RD);
#line 126
  freeMatrix(MR);
#line 127
  freeMatrix(RD);
#line 129
  i = 0;
#line 129
  while (i < test->row_dim) {
#line 130
    j = 0;
#line 130
    while (j < test->col_dim) {
#line 131
      if (*(*(test->cols + j) + i) < (double )0) {
#line 131
        tmp___20 = - *(*(test->cols + j) + i);
      } else {
#line 131
        tmp___20 = *(*(test->cols + j) + i);
      }
#line 131
      if (! (tmp___20 < tol)) {
#line 132
        failed = 1;
#line 133
        tmp___14 = time((time_t *)0);
#line 133
        tttt___4 = tmp___14;
#line 133
        if (quiet == 0) {
#line 133
          printf((char const   * __restrict  )"Covariance matrix is not reconstructable to within tolerance.");
        } else
#line 133
        if (debuglevel != 0) {
#line 133
          printf((char const   * __restrict  )"Covariance matrix is not reconstructable to within tolerance.");
        }
#line 133
        if (quiet == 0) {
#line 133
          printf((char const   * __restrict  )"\n");
        } else
#line 133
        if (debuglevel != 0) {
#line 133
          printf((char const   * __restrict  )"\n");
        }
#line 133
        if (debuglevel > 0) {
#line 133
          tmp___15 = ctime((time_t const   *)(& tttt___4));
#line 133
          printf((char const   * __restrict  )"    [%s]<%s():line %u> %s\n", "src/csuSubspaceEigen.c",
                 "eigen_verify", 133, tmp___15);
        }
#line 133
        fflush(stdout);
#line 134
        if (1 <= debuglevel) {
#line 134
          tmp___16 = time((time_t *)0);
#line 134
          tttt___5 = tmp___16;
#line 134
          tmp___17 = ctime((time_t const   *)(& tttt___5));
#line 134
          printf((char const   * __restrict  )"**DEBUG %d** \"%s\" %s=%f\n             at [%s]<%s():line %u>\n             %s\n",
                 1, "Matrix Element", "ME(test, i, j)", *(*(test->cols + j) + i),
                 "src/csuSubspaceEigen.c", "eigen_verify", 134, tmp___17);
#line 134
          fflush(stdout);
        }
#line 135
        if (1 <= debuglevel) {
#line 135
          tmp___18 = time((time_t *)0);
#line 135
          tttt___6 = tmp___18;
#line 135
          tmp___19 = ctime((time_t const   *)(& tttt___6));
#line 135
          printf((char const   * __restrict  )"**DEBUG %d** \"%s\" %s=%f\n             at [%s]<%s():line %u>\n             %s\n",
                 1, "Tolerance", "tol", tol, "src/csuSubspaceEigen.c", "eigen_verify",
                 135, tmp___19);
#line 135
          fflush(stdout);
        }
#line 136
        exit(1);
      }
#line 130
      j ++;
    }
#line 129
    i ++;
  }
#line 140
  freeMatrix(test);
#line 142
  return (failed);
}
}
#line 154 "src/csuSubspaceEigen.c"
int basis_verify(Matrix X , Matrix U ) 
{ 
  Matrix UtX ;
  Matrix tmp ;
  Matrix UUtX ;
  Matrix tmp___0 ;
  Matrix UtU ;
  Matrix tmp___1 ;
  Matrix identity ;
  Matrix tmp___2 ;
  Matrix test ;
  int i ;
  int j ;
  int failed ;
  double tol ;
  time_t tttt ;
  time_t tmp___3 ;
  char *tmp___4 ;
  time_t tttt___0 ;
  time_t tmp___5 ;
  char *tmp___6 ;
  time_t tttt___1 ;
  time_t tmp___7 ;
  char *tmp___8 ;
  time_t tttt___2 ;
  time_t tmp___9 ;
  char *tmp___10 ;
  double tmp___11 ;
  time_t tttt___3 ;
  time_t tmp___12 ;
  char *tmp___13 ;
  time_t tttt___4 ;
  time_t tmp___14 ;
  char *tmp___15 ;
  time_t tttt___5 ;
  time_t tmp___16 ;
  char *tmp___17 ;
  time_t tttt___6 ;
  time_t tmp___18 ;
  char *tmp___19 ;
  double tmp___20 ;

  {
#line 155
  tmp = transposeMultiplyMatrixL((Matrix const   )U, (Matrix const   )X);
#line 155
  UtX = tmp;
#line 156
  tmp___0 = multiplyMatrix((Matrix const   )U, (Matrix const   )UtX);
#line 156
  UUtX = tmp___0;
#line 157
  tmp___1 = transposeMultiplyMatrixL((Matrix const   )U, (Matrix const   )U);
#line 157
  UtU = tmp___1;
#line 158
  tmp___2 = makeIdentityMatrix(U->col_dim);
#line 158
  identity = tmp___2;
#line 161
  failed = 0;
#line 162
  tol = 1.0e-7;
#line 164
  freeMatrix(UtX);
#line 166
  if (2 <= debuglevel) {
#line 166
    tmp___3 = time((time_t *)0);
#line 166
    tttt = tmp___3;
#line 166
    tmp___4 = ctime((time_t const   *)(& tttt));
#line 166
    printf((char const   * __restrict  )"**DEBUG %d** \"%s\"\n             at [%s]<%s():line %u>\n             %s\n",
           2, "Checking orthogonality of eigenbasis", "src/csuSubspaceEigen.c", "basis_verify",
           166, tmp___4);
#line 166
    fflush(stdout);
  }
#line 167
  test = subtractMatrix((Matrix const   )UtU, (Matrix const   )identity);
#line 168
  freeMatrix(UtU);
#line 169
  freeMatrix(identity);
#line 171
  i = 0;
#line 171
  while (i < test->row_dim) {
#line 172
    j = 0;
#line 172
    while (j < test->col_dim) {
#line 173
      if (*(*(test->cols + j) + i) < (double )0) {
#line 173
        tmp___11 = - *(*(test->cols + j) + i);
      } else {
#line 173
        tmp___11 = *(*(test->cols + j) + i);
      }
#line 173
      if (! (tmp___11 < tol)) {
#line 174
        failed = 1;
#line 175
        tmp___5 = time((time_t *)0);
#line 175
        tttt___0 = tmp___5;
#line 175
        if (quiet == 0) {
#line 175
          printf((char const   * __restrict  )"Eigenbasis is not orthogonal to within tolerance.");
        } else
#line 175
        if (debuglevel != 0) {
#line 175
          printf((char const   * __restrict  )"Eigenbasis is not orthogonal to within tolerance.");
        }
#line 175
        if (quiet == 0) {
#line 175
          printf((char const   * __restrict  )"\n");
        } else
#line 175
        if (debuglevel != 0) {
#line 175
          printf((char const   * __restrict  )"\n");
        }
#line 175
        if (debuglevel > 0) {
#line 175
          tmp___6 = ctime((time_t const   *)(& tttt___0));
#line 175
          printf((char const   * __restrict  )"    [%s]<%s():line %u> %s\n", "src/csuSubspaceEigen.c",
                 "basis_verify", 175, tmp___6);
        }
#line 175
        fflush(stdout);
#line 176
        if (1 <= debuglevel) {
#line 176
          tmp___7 = time((time_t *)0);
#line 176
          tttt___1 = tmp___7;
#line 176
          tmp___8 = ctime((time_t const   *)(& tttt___1));
#line 176
          printf((char const   * __restrict  )"**DEBUG %d** \"%s\" %s=%f\n             at [%s]<%s():line %u>\n             %s\n",
                 1, "Matrix Element", "ME(test, i, j)", *(*(test->cols + j) + i),
                 "src/csuSubspaceEigen.c", "basis_verify", 176, tmp___8);
#line 176
          fflush(stdout);
        }
#line 177
        if (1 <= debuglevel) {
#line 177
          tmp___9 = time((time_t *)0);
#line 177
          tttt___2 = tmp___9;
#line 177
          tmp___10 = ctime((time_t const   *)(& tttt___2));
#line 177
          printf((char const   * __restrict  )"**DEBUG %d** \"%s\" %s=%f\n             at [%s]<%s():line %u>\n             %s\n",
                 1, "Tolerance", "tol", tol, "src/csuSubspaceEigen.c", "basis_verify",
                 177, tmp___10);
#line 177
          fflush(stdout);
        }
#line 178
        exit(1);
      }
#line 172
      j ++;
    }
#line 171
    i ++;
  }
#line 182
  freeMatrix(test);
#line 184
  if (2 <= debuglevel) {
#line 184
    tmp___12 = time((time_t *)0);
#line 184
    tttt___3 = tmp___12;
#line 184
    tmp___13 = ctime((time_t const   *)(& tttt___3));
#line 184
    printf((char const   * __restrict  )"**DEBUG %d** \"%s\"\n             at [%s]<%s():line %u>\n             %s\n",
           2, "Checking reconstruction property of the eigen decomposition", "src/csuSubspaceEigen.c",
           "basis_verify", 184, tmp___13);
#line 184
    fflush(stdout);
  }
#line 185
  test = subtractMatrix((Matrix const   )X, (Matrix const   )UUtX);
#line 186
  freeMatrix(UUtX);
#line 188
  i = 0;
#line 188
  while (i < test->row_dim) {
#line 189
    j = 0;
#line 189
    while (j < test->col_dim) {
#line 190
      if (*(*(test->cols + j) + i) < (double )0) {
#line 190
        tmp___20 = - *(*(test->cols + j) + i);
      } else {
#line 190
        tmp___20 = *(*(test->cols + j) + i);
      }
#line 190
      if (! (tmp___20 < tol)) {
#line 191
        failed = 1;
#line 192
        tmp___14 = time((time_t *)0);
#line 192
        tttt___4 = tmp___14;
#line 192
        if (quiet == 0) {
#line 192
          printf((char const   * __restrict  )"Data matrix is not reconstructable to within tolerance.");
        } else
#line 192
        if (debuglevel != 0) {
#line 192
          printf((char const   * __restrict  )"Data matrix is not reconstructable to within tolerance.");
        }
#line 192
        if (quiet == 0) {
#line 192
          printf((char const   * __restrict  )"\n");
        } else
#line 192
        if (debuglevel != 0) {
#line 192
          printf((char const   * __restrict  )"\n");
        }
#line 192
        if (debuglevel > 0) {
#line 192
          tmp___15 = ctime((time_t const   *)(& tttt___4));
#line 192
          printf((char const   * __restrict  )"    [%s]<%s():line %u> %s\n", "src/csuSubspaceEigen.c",
                 "basis_verify", 192, tmp___15);
        }
#line 192
        fflush(stdout);
#line 193
        if (1 <= debuglevel) {
#line 193
          tmp___16 = time((time_t *)0);
#line 193
          tttt___5 = tmp___16;
#line 193
          tmp___17 = ctime((time_t const   *)(& tttt___5));
#line 193
          printf((char const   * __restrict  )"**DEBUG %d** \"%s\" %s=%f\n             at [%s]<%s():line %u>\n             %s\n",
                 1, "Matrix Element", "ME(test, i, j)", *(*(test->cols + j) + i),
                 "src/csuSubspaceEigen.c", "basis_verify", 193, tmp___17);
#line 193
          fflush(stdout);
        }
#line 194
        if (1 <= debuglevel) {
#line 194
          tmp___18 = time((time_t *)0);
#line 194
          tttt___6 = tmp___18;
#line 194
          tmp___19 = ctime((time_t const   *)(& tttt___6));
#line 194
          printf((char const   * __restrict  )"**DEBUG %d** \"%s\" %s=%f\n             at [%s]<%s():line %u>\n             %s\n",
                 1, "Tolarence", "tol", tol, "src/csuSubspaceEigen.c", "basis_verify",
                 194, tmp___19);
#line 194
          fflush(stdout);
        }
#line 195
        exit(1);
      }
#line 189
      j ++;
    }
#line 188
    i ++;
  }
#line 199
  freeMatrix(test);
#line 201
  return (failed);
}
}
#line 220 "src/csuSubspaceEigen.c"
void eigentrain(Matrix *mean , Matrix *eigen_vals , Matrix *eigen_base , Matrix images ) 
{ 
  double p ;
  Matrix M ;
  Matrix eigenvectors ;
  time_t tttt ;
  time_t tmp ;
  char *tmp___0 ;
  time_t tttt___0 ;
  time_t tmp___1 ;
  char *tmp___2 ;
  time_t tttt___1 ;
  time_t tmp___3 ;
  char *tmp___4 ;
  time_t tttt___2 ;
  time_t tmp___5 ;
  char *tmp___6 ;
  time_t tttt___3 ;
  time_t tmp___7 ;
  char *tmp___8 ;
  time_t tttt___4 ;
  time_t tmp___9 ;
  char *tmp___10 ;
  time_t tttt___5 ;
  time_t tmp___11 ;
  char *tmp___12 ;
  time_t tttt___6 ;
  time_t tmp___13 ;
  char *tmp___14 ;
  time_t tttt___7 ;
  time_t tmp___15 ;
  char *tmp___16 ;
  time_t tttt___8 ;
  time_t tmp___17 ;
  char *tmp___18 ;
  time_t tttt___9 ;
  time_t tmp___19 ;
  char *tmp___20 ;

  {
#line 222
  p = 0.0;
#line 225
  if (1 <= debuglevel) {
#line 225
    tmp = time((time_t *)0);
#line 225
    tttt = tmp;
#line 225
    tmp___0 = ctime((time_t const   *)(& tttt));
#line 225
    printf((char const   * __restrict  )"**DEBUG %d** \"%s\"\n             at [%s]<%s():line %u>\n             %s\n",
           1, "Calculating mean image.", "src/csuSubspaceEigen.c", "eigentrain", 225,
           tmp___0);
#line 225
    fflush(stdout);
  }
#line 226
  *mean = get_mean_image(images);
#line 228
  if (1 <= debuglevel) {
#line 228
    tmp___1 = time((time_t *)0);
#line 228
    tttt___0 = tmp___1;
#line 228
    tmp___2 = ctime((time_t const   *)(& tttt___0));
#line 228
    printf((char const   * __restrict  )"**DEBUG %d** \"%s\"\n             at [%s]<%s():line %u>\n             %s\n",
           1, "Calculating the mean centered images for the training set.", "src/csuSubspaceEigen.c",
           "eigentrain", 228, tmp___2);
#line 228
    fflush(stdout);
  }
#line 229
  mean_subtract_images(images, *mean);
#line 231
  tmp___3 = time((time_t *)0);
#line 231
  tttt___1 = tmp___3;
#line 231
  if (quiet == 0) {
#line 231
    printf((char const   * __restrict  )"Calculating Covariance Matrix: M = images\' * images. M is a %d by %d Matrix.",
           images->col_dim, images->col_dim);
  } else
#line 231
  if (debuglevel != 0) {
#line 231
    printf((char const   * __restrict  )"Calculating Covariance Matrix: M = images\' * images. M is a %d by %d Matrix.",
           images->col_dim, images->col_dim);
  }
#line 231
  if (quiet == 0) {
#line 231
    printf((char const   * __restrict  )"\n");
  } else
#line 231
  if (debuglevel != 0) {
#line 231
    printf((char const   * __restrict  )"\n");
  }
#line 231
  if (debuglevel > 0) {
#line 231
    tmp___4 = ctime((time_t const   *)(& tttt___1));
#line 231
    printf((char const   * __restrict  )"    [%s]<%s():line %u> %s\n", "src/csuSubspaceEigen.c",
           "eigentrain", 231, tmp___4);
  }
#line 231
  fflush(stdout);
#line 232
  M = transposeMultiplyMatrixL((Matrix const   )images, (Matrix const   )images);
#line 233
  if (3 <= debuglevel) {
#line 233
    tmp___5 = time((time_t *)0);
#line 233
    tttt___2 = tmp___5;
#line 233
    tmp___6 = ctime((time_t const   *)(& tttt___2));
#line 233
    printf((char const   * __restrict  )"**DEBUG %d** \"%s\" %s=%d\n             at [%s]<%s():line %u>\n             %s\n",
           3, "Covariance Matrix Rows", "M->row_dim", M->row_dim, "src/csuSubspaceEigen.c",
           "eigentrain", 233, tmp___6);
#line 233
    fflush(stdout);
  }
#line 234
  if (3 <= debuglevel) {
#line 234
    tmp___7 = time((time_t *)0);
#line 234
    tttt___3 = tmp___7;
#line 234
    tmp___8 = ctime((time_t const   *)(& tttt___3));
#line 234
    printf((char const   * __restrict  )"**DEBUG %d** \"%s\" %s=%d\n             at [%s]<%s():line %u>\n             %s\n",
           3, "Covariance Matrix Cols", "M->col_dim", M->col_dim, "src/csuSubspaceEigen.c",
           "eigentrain", 234, tmp___8);
#line 234
    fflush(stdout);
  }
#line 236
  if (2 <= debuglevel) {
#line 236
    tmp___9 = time((time_t *)0);
#line 236
    tttt___4 = tmp___9;
#line 236
    tmp___10 = ctime((time_t const   *)(& tttt___4));
#line 236
    printf((char const   * __restrict  )"**DEBUG %d** \"%s\"\n             at [%s]<%s():line %u>\n             %s\n",
           2, "Allocating memory for eigenvectors and eigenvalues.", "src/csuSubspaceEigen.c",
           "eigentrain", 236, tmp___10);
#line 236
    fflush(stdout);
  }
#line 237
  eigenvectors = makeMatrix(M->row_dim, M->col_dim);
#line 238
  *eigen_vals = makeMatrix(M->row_dim, 1);
#line 240
  tmp___11 = time((time_t *)0);
#line 240
  tttt___5 = tmp___11;
#line 240
  if (quiet == 0) {
#line 240
    printf((char const   * __restrict  )"Computing snap shot eigen vectors using the double precision cv eigensolver.");
  } else
#line 240
  if (debuglevel != 0) {
#line 240
    printf((char const   * __restrict  )"Computing snap shot eigen vectors using the double precision cv eigensolver.");
  }
#line 240
  if (quiet == 0) {
#line 240
    printf((char const   * __restrict  )"\n");
  } else
#line 240
  if (debuglevel != 0) {
#line 240
    printf((char const   * __restrict  )"\n");
  }
#line 240
  if (debuglevel > 0) {
#line 240
    tmp___12 = ctime((time_t const   *)(& tttt___5));
#line 240
    printf((char const   * __restrict  )"    [%s]<%s():line %u> %s\n", "src/csuSubspaceEigen.c",
           "eigentrain", 240, tmp___12);
  }
#line 240
  fflush(stdout);
#line 241
  cvJacobiEigens_64d(M->data, eigenvectors->data, (*eigen_vals)->data, images->col_dim,
                     p);
#line 242
  freeMatrix(M);
#line 244
  if (1 <= debuglevel) {
#line 244
    tmp___13 = time((time_t *)0);
#line 244
    tttt___6 = tmp___13;
#line 244
    tmp___14 = ctime((time_t const   *)(& tttt___6));
#line 244
    printf((char const   * __restrict  )"**DEBUG %d** \"%s\"\n             at [%s]<%s():line %u>\n             %s\n",
           1, "Verifying the eigen vectors", "src/csuSubspaceEigen.c", "eigentrain",
           244, tmp___14);
#line 244
    fflush(stdout);
  }
#line 246
  M = transposeMultiplyMatrixL((Matrix const   )images, (Matrix const   )images);
#line 247
  if (debuglevel >= 3) {
#line 248
    eigen_verify(M, *eigen_vals, eigenvectors);
  }
#line 249
  freeMatrix(M);
#line 251
  *eigen_base = multiplyMatrix((Matrix const   )images, (Matrix const   )eigenvectors);
#line 252
  tmp___15 = time((time_t *)0);
#line 252
  tttt___7 = tmp___15;
#line 252
  if (quiet == 0) {
#line 252
    printf((char const   * __restrict  )"Recovered the %d by %d high resolution eigen basis.",
           (*eigen_base)->row_dim, (*eigen_base)->col_dim);
  } else
#line 252
  if (debuglevel != 0) {
#line 252
    printf((char const   * __restrict  )"Recovered the %d by %d high resolution eigen basis.",
           (*eigen_base)->row_dim, (*eigen_base)->col_dim);
  }
#line 252
  if (quiet == 0) {
#line 252
    printf((char const   * __restrict  )"\n");
  } else
#line 252
  if (debuglevel != 0) {
#line 252
    printf((char const   * __restrict  )"\n");
  }
#line 252
  if (debuglevel > 0) {
#line 252
    tmp___16 = ctime((time_t const   *)(& tttt___7));
#line 252
    printf((char const   * __restrict  )"    [%s]<%s():line %u> %s\n", "src/csuSubspaceEigen.c",
           "eigentrain", 252, tmp___16);
  }
#line 252
  fflush(stdout);
#line 254
  if (1 <= debuglevel) {
#line 254
    tmp___17 = time((time_t *)0);
#line 254
    tttt___8 = tmp___17;
#line 254
    tmp___18 = ctime((time_t const   *)(& tttt___8));
#line 254
    printf((char const   * __restrict  )"**DEBUG %d** \"%s\"\n             at [%s]<%s():line %u>\n             %s\n",
           1, "Normalizing eigen basis", "src/csuSubspaceEigen.c", "eigentrain", 254,
           tmp___18);
#line 254
    fflush(stdout);
  }
#line 255
  basis_normalize(*eigen_base);
#line 261
  ((*eigen_base)->col_dim) --;
#line 262
  ((*eigen_vals)->row_dim) --;
#line 263
  (eigenvectors->col_dim) --;
#line 265
  if (1 <= debuglevel) {
#line 265
    tmp___19 = time((time_t *)0);
#line 265
    tttt___9 = tmp___19;
#line 265
    tmp___20 = ctime((time_t const   *)(& tttt___9));
#line 265
    printf((char const   * __restrict  )"**DEBUG %d** \"%s\"\n             at [%s]<%s():line %u>\n             %s\n",
           1, "Verifying eigenbasis", "src/csuSubspaceEigen.c", "eigentrain", 265,
           tmp___20);
#line 265
    fflush(stdout);
  }
#line 266
  if (debuglevel >= 3) {
#line 267
    basis_verify(images, *eigen_base);
  }
#line 270
  freeMatrix(eigenvectors);
#line 271
  return;
}
}
#line 1 "csuSubspaceFisher.o"
#pragma merger("0","/tmp/cil-EjMyqpNT.i","-O3,-Wall")
#line 150 "/usr/include/x86_64-linux-gnu/bits/mathinline.h"
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__, __always_inline__)) __signbitl)(long double __x )  __attribute__((__const__)) ;
#line 150 "/usr/include/x86_64-linux-gnu/bits/mathinline.h"
__inline extern int ( __attribute__((__leaf__, __always_inline__)) __signbitl)(long double __x ) 
{ 
  union __anonunion___u_26___8 __u ;

  {
#line 153
  __u.__l = __x;
#line 154
  return ((__u.__i[2] & 32768) != 0);
}
}
#line 89 "src/csuSubspaceFisher.c"
void subtractClassMean(Matrix classmatrix , int classStart , int classEnd ) 
{ 
  int i ;
  int j ;
  Matrix mean ;
  Matrix tmp ;

  {
#line 91
  tmp = makeMatrix(classmatrix->row_dim, 1);
#line 91
  mean = tmp;
#line 94
  i = 0;
#line 94
  while (i < classmatrix->row_dim) {
#line 95
    *(*(mean->cols + 0) + i) = 0.0;
#line 96
    j = classStart;
#line 96
    while (j <= classEnd) {
#line 97
      *(*(mean->cols + 0) + i) += *(*(classmatrix->cols + j) + i);
#line 96
      j ++;
    }
#line 98
    *(*(mean->cols + 0) + i) /= (double )((classEnd - classStart) + 1);
#line 94
    i ++;
  }
#line 100
  i = 0;
#line 100
  while (i < classmatrix->row_dim) {
#line 101
    j = classStart;
#line 101
    while (j <= classEnd) {
#line 102
      *(*(classmatrix->cols + j) + i) -= *(*(mean->cols + 0) + i);
#line 101
      j ++;
    }
#line 100
    i ++;
  }
#line 105
  freeMatrix(mean);
#line 106
  return;
}
}
#line 109 "src/csuSubspaceFisher.c"
void fisherVerify(Matrix fisherBasis , Matrix fisherValues , Matrix Sw , Matrix Sb ) 
{ 
  Matrix SbW ;
  Matrix tmp ;
  Matrix SwW ;
  Matrix tmp___0 ;
  Matrix D ;
  Matrix tmp___1 ;
  Matrix DSwW ;
  Matrix zeroMat ;
  int i ;
  int j ;
  time_t tttt ;
  time_t tmp___2 ;
  char *tmp___3 ;
  time_t tttt___0 ;
  time_t tmp___4 ;
  char *tmp___5 ;
  double tmp___6 ;

  {
#line 110
  tmp = multiplyMatrix((Matrix const   )Sb, (Matrix const   )fisherBasis);
#line 110
  SbW = tmp;
#line 111
  tmp___0 = multiplyMatrix((Matrix const   )Sw, (Matrix const   )fisherBasis);
#line 111
  SwW = tmp___0;
#line 112
  tmp___1 = makeIdentityMatrix(fisherBasis->row_dim);
#line 112
  D = tmp___1;
#line 118
  tmp___2 = time((time_t *)0);
#line 118
  tttt = tmp___2;
#line 118
  if (quiet == 0) {
#line 118
    printf((char const   * __restrict  )"Verifying Fisher Basis.");
  } else
#line 118
  if (debuglevel != 0) {
#line 118
    printf((char const   * __restrict  )"Verifying Fisher Basis.");
  }
#line 118
  if (quiet == 0) {
#line 118
    printf((char const   * __restrict  )"\n");
  } else
#line 118
  if (debuglevel != 0) {
#line 118
    printf((char const   * __restrict  )"\n");
  }
#line 118
  if (debuglevel > 0) {
#line 118
    tmp___3 = ctime((time_t const   *)(& tttt));
#line 118
    printf((char const   * __restrict  )"    [%s]<%s():line %u> %s\n", "src/csuSubspaceFisher.c",
           "fisherVerify", 118, tmp___3);
  }
#line 118
  fflush(stdout);
#line 120
  i = 0;
#line 120
  while (i < D->row_dim) {
#line 121
    *(*(D->cols + i) + i) = *(*(fisherValues->cols + 0) + i);
#line 120
    i ++;
  }
#line 124
  DSwW = multiplyMatrix((Matrix const   )D, (Matrix const   )SwW);
#line 125
  zeroMat = subtractMatrix((Matrix const   )SbW, (Matrix const   )DSwW);
#line 127
  i = 0;
#line 127
  while (i < zeroMat->row_dim) {
#line 128
    j = 0;
#line 128
    while (j < zeroMat->col_dim) {
#line 129
      if (*(*(zeroMat->cols + j) + i) < (double )0) {
#line 129
        tmp___6 = - *(*(zeroMat->cols + j) + i);
      } else {
#line 129
        tmp___6 = *(*(zeroMat->cols + j) + i);
      }
#line 129
      if (! (tmp___6 < 0.000001)) {
#line 130
        tmp___4 = time((time_t *)0);
#line 130
        tttt___0 = tmp___4;
#line 130
        tmp___5 = ctime((time_t const   *)(& tttt___0));
#line 130
        printf((char const   * __restrict  )"**DEBUG %d** \"%s\"\n             at [%s]<%s():line %u>\n             %s\n",
               -1, "Fisher validation failed.", "src/csuSubspaceFisher.c", "fisherVerify",
               130, tmp___5);
#line 130
        fflush(stdout);
#line 131
        printf((char const   * __restrict  )"Element: (%d,%d) value = %f", i, j, *(*(zeroMat->cols + j) + i));
#line 132
        exit(1);
      }
#line 128
      j ++;
    }
#line 127
    i ++;
  }
#line 136
  return;
}
}
#line 156 "src/csuSubspaceFisher.c"
Matrix findWCSMatrix(Matrix imspca , ImageList *srt , int *numberOfClasses , int writeTextInterm ) 
{ 
  Matrix Sw ;
  Matrix classmatrix ;
  Matrix tmp ;
  ImageList *subject ;
  ImageList *replicate ;
  int maxClassSize ;
  int repCount ;
  time_t tttt ;
  time_t tmp___0 ;
  char *tmp___1 ;
  int classStart ;
  int classEnd ;
  time_t tttt___0 ;
  time_t tmp___2 ;
  char *tmp___3 ;
  time_t tttt___1 ;
  time_t tmp___4 ;
  char *tmp___5 ;
  time_t tttt___2 ;
  time_t tmp___6 ;
  char *tmp___7 ;
  time_t tttt___3 ;
  time_t tmp___8 ;
  char *tmp___9 ;
  time_t tttt___4 ;
  time_t tmp___10 ;
  char *tmp___11 ;
  time_t tttt___5 ;
  time_t tmp___12 ;
  char *tmp___13 ;

  {
#line 158
  tmp = duplicateMatrix((Matrix const   )imspca);
#line 158
  classmatrix = tmp;
#line 160
  maxClassSize = 0;
#line 163
  *numberOfClasses = 0;
#line 164
  tmp___0 = time((time_t *)0);
#line 164
  tttt = tmp___0;
#line 164
  if (quiet == 0) {
#line 164
    printf((char const   * __restrict  )"Finding within-class scatter matrix.");
  } else
#line 164
  if (debuglevel != 0) {
#line 164
    printf((char const   * __restrict  )"Finding within-class scatter matrix.");
  }
#line 164
  if (quiet == 0) {
#line 164
    printf((char const   * __restrict  )"\n");
  } else
#line 164
  if (debuglevel != 0) {
#line 164
    printf((char const   * __restrict  )"\n");
  }
#line 164
  if (debuglevel > 0) {
#line 164
    tmp___1 = ctime((time_t const   *)(& tttt));
#line 164
    printf((char const   * __restrict  )"    [%s]<%s():line %u> %s\n", "src/csuSubspaceFisher.c",
           "findWCSMatrix", 164, tmp___1);
  }
#line 164
  fflush(stdout);
#line 165
  subject = srt;
#line 165
  while (subject) {
#line 167
    (*numberOfClasses) ++;
#line 169
    if (3 <= debuglevel) {
#line 169
      tmp___2 = time((time_t *)0);
#line 169
      tttt___0 = tmp___2;
#line 169
      tmp___3 = ctime((time_t const   *)(& tttt___0));
#line 169
      printf((char const   * __restrict  )"**DEBUG %d** \"%s\"\n             at [%s]<%s():line %u>\n             %s\n",
             3, "Finding the class indexes.", "src/csuSubspaceFisher.c", "findWCSMatrix",
             169, tmp___3);
#line 169
      fflush(stdout);
    }
#line 170
    classEnd = subject->imageIndex;
#line 170
    classStart = classEnd;
#line 171
    repCount = 0;
#line 172
    replicate = subject;
#line 172
    while (replicate) {
#line 173
      repCount ++;
#line 174
      classEnd = replicate->imageIndex;
#line 172
      replicate = replicate->next_replicate;
    }
#line 177
    if (repCount > maxClassSize) {
#line 177
      maxClassSize = repCount;
    }
#line 179
    if (repCount == 1) {
#line 179
      if (! quiet) {
#line 180
        printf((char const   * __restrict  )"WARNING: class %d only contains one image.\n",
               *numberOfClasses);
      }
    }
#line 183
    if (4 <= debuglevel) {
#line 183
      tmp___4 = time((time_t *)0);
#line 183
      tttt___1 = tmp___4;
#line 183
      tmp___5 = ctime((time_t const   *)(& tttt___1));
#line 183
      printf((char const   * __restrict  )"**DEBUG %d** \"%s\" %s=%d\n             at [%s]<%s():line %u>\n             %s\n",
             4, "Lower limit on class.", "classStart", classStart, "src/csuSubspaceFisher.c",
             "findWCSMatrix", 183, tmp___5);
#line 183
      fflush(stdout);
    }
#line 184
    if (4 <= debuglevel) {
#line 184
      tmp___6 = time((time_t *)0);
#line 184
      tttt___2 = tmp___6;
#line 184
      tmp___7 = ctime((time_t const   *)(& tttt___2));
#line 184
      printf((char const   * __restrict  )"**DEBUG %d** \"%s\" %s=%d\n             at [%s]<%s():line %u>\n             %s\n",
             4, "Upper limit on class.", "classEnd", classEnd, "src/csuSubspaceFisher.c",
             "findWCSMatrix", 184, tmp___7);
#line 184
      fflush(stdout);
    }
#line 185
    if (3 <= debuglevel) {
#line 185
      tmp___8 = time((time_t *)0);
#line 185
      tttt___3 = tmp___8;
#line 185
      tmp___9 = ctime((time_t const   *)(& tttt___3));
#line 185
      printf((char const   * __restrict  )"**DEBUG %d** \"%s\"\n             at [%s]<%s():line %u>\n             %s\n",
             3, "Mean centering the class.", "src/csuSubspaceFisher.c", "findWCSMatrix",
             185, tmp___9);
#line 185
      fflush(stdout);
    }
#line 186
    subtractClassMean(classmatrix, classStart, classEnd);
#line 165
    subject = subject->next_subject;
  }
#line 190
  if (! (maxClassSize > 1)) {
#line 190
    tmp___10 = time((time_t *)0);
#line 190
    tttt___4 = tmp___10;
#line 190
    tmp___11 = ctime((time_t const   *)(& tttt___4));
#line 190
    printf((char const   * __restrict  )"**DEBUG CHECK** Failed check (%s) \"%s\"\n             at [%s]<%s():line %u>\n             %s\n",
           "maxClassSize > 1", "ERROR: at least one class must have more than one replicate.  Make sure your image list is not flat.",
           "src/csuSubspaceFisher.c", "findWCSMatrix", 190, tmp___11);
#line 190
    fflush(stdout);
#line 190
    exit(1);
  }
#line 192
  if (debuglevel > 3) {
#line 193
    printMatrix("classmatrix", classmatrix);
  }
#line 195
  if (writeTextInterm) {
#line 195
    saveMatrixAscii((char const   *)((void *)0), "classmatrix", (Matrix const   )classmatrix,
                    asciiFormat);
  }
#line 197
  if (3 <= debuglevel) {
#line 197
    tmp___12 = time((time_t *)0);
#line 197
    tttt___5 = tmp___12;
#line 197
    tmp___13 = ctime((time_t const   *)(& tttt___5));
#line 197
    printf((char const   * __restrict  )"**DEBUG %d** \"%s\"\n             at [%s]<%s():line %u>\n             %s\n",
           3, "Creating the class scatter matrix.", "src/csuSubspaceFisher.c", "findWCSMatrix",
           197, tmp___13);
#line 197
    fflush(stdout);
  }
#line 198
  Sw = transposeMultiplyMatrixR((Matrix const   )classmatrix, (Matrix const   )classmatrix);
#line 200
  if (debuglevel > 3) {
#line 201
    printMatrix("Sw", Sw);
  }
#line 202
  return (Sw);
}
}
#line 220 "src/csuSubspaceFisher.c"
Matrix findBCSMatrix(Matrix imspca , Matrix Sw ) 
{ 
  Matrix Sb ;
  Matrix St ;
  Matrix mean ;
  time_t tttt ;
  time_t tmp ;
  char *tmp___0 ;
  time_t tttt___0 ;
  time_t tmp___1 ;
  char *tmp___2 ;
  time_t tttt___1 ;
  time_t tmp___3 ;
  char *tmp___4 ;

  {
#line 225
  tmp = time((time_t *)0);
#line 225
  tttt = tmp;
#line 225
  if (quiet == 0) {
#line 225
    printf((char const   * __restrict  )"Finding between-class scatter matrix.");
  } else
#line 225
  if (debuglevel != 0) {
#line 225
    printf((char const   * __restrict  )"Finding between-class scatter matrix.");
  }
#line 225
  if (quiet == 0) {
#line 225
    printf((char const   * __restrict  )"\n");
  } else
#line 225
  if (debuglevel != 0) {
#line 225
    printf((char const   * __restrict  )"\n");
  }
#line 225
  if (debuglevel > 0) {
#line 225
    tmp___0 = ctime((time_t const   *)(& tttt));
#line 225
    printf((char const   * __restrict  )"    [%s]<%s():line %u> %s\n", "src/csuSubspaceFisher.c",
           "findBCSMatrix", 225, tmp___0);
  }
#line 225
  fflush(stdout);
#line 227
  mean = get_mean_image(imspca);
#line 228
  mean_subtract_images(imspca, mean);
#line 230
  if (3 <= debuglevel) {
#line 230
    tmp___1 = time((time_t *)0);
#line 230
    tttt___0 = tmp___1;
#line 230
    tmp___2 = ctime((time_t const   *)(& tttt___0));
#line 230
    printf((char const   * __restrict  )"**DEBUG %d** \"%s\"\n             at [%s]<%s():line %u>\n             %s\n",
           3, "Producing total scatter matrix", "src/csuSubspaceFisher.c", "findBCSMatrix",
           230, tmp___2);
#line 230
    fflush(stdout);
  }
#line 231
  St = transposeMultiplyMatrixR((Matrix const   )imspca, (Matrix const   )imspca);
#line 233
  if (2 <= debuglevel) {
#line 233
    tmp___3 = time((time_t *)0);
#line 233
    tttt___1 = tmp___3;
#line 233
    tmp___4 = ctime((time_t const   *)(& tttt___1));
#line 233
    printf((char const   * __restrict  )"**DEBUG %d** \"%s\"\n             at [%s]<%s():line %u>\n             %s\n",
           2, "Producing between-class scatter matrix", "src/csuSubspaceFisher.c",
           "findBCSMatrix", 233, tmp___4);
#line 233
    fflush(stdout);
  }
#line 234
  Sb = subtractMatrix((Matrix const   )St, (Matrix const   )Sw);
#line 236
  freeMatrix(St);
#line 237
  freeMatrix(mean);
#line 239
  return (Sb);
}
}
#line 258 "src/csuSubspaceFisher.c"
void fisherTrain(Matrix imspca , ImageList *srt , Matrix *fisherBasis , Matrix *fisherValues ,
                 int writeTextInterm ) 
{ 
  int i ;
  int numberOfClasses ;
  Matrix G ;
  Matrix N ;
  Matrix Tmp ;
  Matrix Rw ;
  Matrix tmp ;
  Matrix Siw ;
  Matrix tmp___0 ;
  Matrix Ev ;
  Matrix tmp___1 ;
  Matrix Evecs ;
  Matrix tmp___2 ;
  Matrix Mw ;
  Matrix tmp___3 ;
  Matrix Mb ;
  Matrix tmp___4 ;
  time_t tttt ;
  time_t tmp___5 ;
  char *tmp___6 ;
  time_t tttt___0 ;
  time_t tmp___7 ;
  char *tmp___8 ;
  time_t tttt___1 ;
  time_t tmp___9 ;
  char *tmp___10 ;
  double tmp___11 ;
  time_t tttt___2 ;
  time_t tmp___12 ;
  char *tmp___13 ;
  time_t tttt___3 ;
  time_t tmp___14 ;
  char *tmp___15 ;
  time_t tttt___4 ;
  time_t tmp___16 ;
  char *tmp___17 ;
  time_t tttt___5 ;
  time_t tmp___18 ;
  char *tmp___19 ;

  {
#line 262
  tmp = makeIdentityMatrix(imspca->row_dim);
#line 262
  Rw = tmp;
#line 263
  tmp___0 = makeIdentityMatrix(imspca->row_dim);
#line 263
  Siw = tmp___0;
#line 264
  tmp___1 = makeMatrix(imspca->row_dim, 1);
#line 264
  Ev = tmp___1;
#line 265
  tmp___2 = makeMatrix(imspca->row_dim, imspca->row_dim);
#line 265
  Evecs = tmp___2;
#line 266
  tmp___3 = findWCSMatrix(imspca, srt, & numberOfClasses, writeTextInterm);
#line 266
  Mw = tmp___3;
#line 267
  tmp___4 = findBCSMatrix(imspca, Mw);
#line 267
  Mb = tmp___4;
#line 268
  *fisherValues = makeMatrix(imspca->row_dim, 1);
#line 270
  tmp___5 = time((time_t *)0);
#line 270
  tttt = tmp___5;
#line 270
  if (quiet == 0) {
#line 270
    printf((char const   * __restrict  )"LDA Training started with %d classes and %d total training images.",
           numberOfClasses, imspca->col_dim);
  } else
#line 270
  if (debuglevel != 0) {
#line 270
    printf((char const   * __restrict  )"LDA Training started with %d classes and %d total training images.",
           numberOfClasses, imspca->col_dim);
  }
#line 270
  if (quiet == 0) {
#line 270
    printf((char const   * __restrict  )"\n");
  } else
#line 270
  if (debuglevel != 0) {
#line 270
    printf((char const   * __restrict  )"\n");
  }
#line 270
  if (debuglevel > 0) {
#line 270
    tmp___6 = ctime((time_t const   *)(& tttt));
#line 270
    printf((char const   * __restrict  )"    [%s]<%s():line %u> %s\n", "src/csuSubspaceFisher.c",
           "fisherTrain", 270, tmp___6);
  }
#line 270
  fflush(stdout);
#line 272
  if (writeTextInterm) {
#line 272
    saveMatrixAscii((char const   *)((void *)0), "Mw", (Matrix const   )Mw, asciiFormat);
#line 272
    saveMatrixAscii((char const   *)((void *)0), "Mb", (Matrix const   )Mb, asciiFormat);
  }
#line 275
  tmp___7 = time((time_t *)0);
#line 275
  tttt___0 = tmp___7;
#line 275
  if (quiet == 0) {
#line 275
    printf((char const   * __restrict  )"Computing eigenspace decomposition of within class scatter matrix.");
  } else
#line 275
  if (debuglevel != 0) {
#line 275
    printf((char const   * __restrict  )"Computing eigenspace decomposition of within class scatter matrix.");
  }
#line 275
  if (quiet == 0) {
#line 275
    printf((char const   * __restrict  )"\n");
  } else
#line 275
  if (debuglevel != 0) {
#line 275
    printf((char const   * __restrict  )"\n");
  }
#line 275
  if (debuglevel > 0) {
#line 275
    tmp___8 = ctime((time_t const   *)(& tttt___0));
#line 275
    printf((char const   * __restrict  )"    [%s]<%s():line %u> %s\n", "src/csuSubspaceFisher.c",
           "fisherTrain", 275, tmp___8);
  }
#line 275
  fflush(stdout);
#line 276
  cvJacobiEigens_64d(Mw->data, Rw->data, Ev->data, Mw->row_dim, 0.0);
#line 278
  tmp___9 = time((time_t *)0);
#line 278
  tttt___1 = tmp___9;
#line 278
  if (quiet == 0) {
#line 278
    printf((char const   * __restrict  )"Computing the inverse scale matrix derived from eigenvalues and transformed scatter matrix.");
  } else
#line 278
  if (debuglevel != 0) {
#line 278
    printf((char const   * __restrict  )"Computing the inverse scale matrix derived from eigenvalues and transformed scatter matrix.");
  }
#line 278
  if (quiet == 0) {
#line 278
    printf((char const   * __restrict  )"\n");
  } else
#line 278
  if (debuglevel != 0) {
#line 278
    printf((char const   * __restrict  )"\n");
  }
#line 278
  if (debuglevel > 0) {
#line 278
    tmp___10 = ctime((time_t const   *)(& tttt___1));
#line 278
    printf((char const   * __restrict  )"    [%s]<%s():line %u> %s\n", "src/csuSubspaceFisher.c",
           "fisherTrain", 278, tmp___10);
  }
#line 278
  fflush(stdout);
#line 279
  i = 0;
#line 279
  while (i < Ev->row_dim) {
#line 280
    if (*(*(Ev->cols + 0) + i) <= 0.0) {
#line 280
      *(*(Siw->cols + i) + i) = 0.0;
    } else {
#line 280
      tmp___11 = sqrt(*(*(Ev->cols + 0) + i));
#line 280
      *(*(Siw->cols + i) + i) = (double )1 / tmp___11;
    }
#line 279
    i ++;
  }
#line 282
  G = transposeMultiplyMatrixR((Matrix const   )Siw, (Matrix const   )Rw);
#line 283
  Tmp = transposeMultiplyMatrixR((Matrix const   )Mb, (Matrix const   )G);
#line 284
  N = multiplyMatrix((Matrix const   )G, (Matrix const   )Tmp);
#line 285
  freeMatrix(Tmp);
#line 287
  if (writeTextInterm) {
#line 288
    saveMatrixAscii((char const   *)((void *)0), "Rw", (Matrix const   )Rw, asciiFormat);
#line 289
    saveMatrixAscii((char const   *)((void *)0), "Ev", (Matrix const   )Ev, asciiFormat);
#line 290
    saveMatrixAscii((char const   *)((void *)0), "N", (Matrix const   )N, asciiFormat);
#line 291
    saveMatrixAscii((char const   *)((void *)0), "G", (Matrix const   )G, asciiFormat);
#line 292
    saveMatrixAscii((char const   *)((void *)0), "Siw", (Matrix const   )Siw, asciiFormat);
  }
#line 295
  tmp___12 = time((time_t *)0);
#line 295
  tttt___2 = tmp___12;
#line 295
  if (quiet == 0) {
#line 295
    printf((char const   * __restrict  )"Computing eigenspace of transformed between class scatter matrix.");
  } else
#line 295
  if (debuglevel != 0) {
#line 295
    printf((char const   * __restrict  )"Computing eigenspace of transformed between class scatter matrix.");
  }
#line 295
  if (quiet == 0) {
#line 295
    printf((char const   * __restrict  )"\n");
  } else
#line 295
  if (debuglevel != 0) {
#line 295
    printf((char const   * __restrict  )"\n");
  }
#line 295
  if (debuglevel > 0) {
#line 295
    tmp___13 = ctime((time_t const   *)(& tttt___2));
#line 295
    printf((char const   * __restrict  )"    [%s]<%s():line %u> %s\n", "src/csuSubspaceFisher.c",
           "fisherTrain", 295, tmp___13);
  }
#line 295
  fflush(stdout);
#line 296
  cvJacobiEigens_64d(N->data, Evecs->data, (*fisherValues)->data, N->row_dim, 0.0);
#line 297
  if (3 <= debuglevel) {
#line 297
    tmp___14 = time((time_t *)0);
#line 297
    tttt___3 = tmp___14;
#line 297
    tmp___15 = ctime((time_t const   *)(& tttt___3));
#line 297
    printf((char const   * __restrict  )"**DEBUG %d** \"%s\"\n             at [%s]<%s():line %u>\n             %s\n",
           3, "FINSISHED", "src/csuSubspaceFisher.c", "fisherTrain", 297, tmp___15);
#line 297
    fflush(stdout);
  }
#line 299
  Tmp = multiplyMatrix((Matrix const   )Siw, (Matrix const   )Evecs);
#line 300
  if (1 <= debuglevel) {
#line 300
    tmp___16 = time((time_t *)0);
#line 300
    tttt___4 = tmp___16;
#line 300
    tmp___17 = ctime((time_t const   *)(& tttt___4));
#line 300
    printf((char const   * __restrict  )"**DEBUG %d** \"%s\"\n             at [%s]<%s():line %u>\n             %s\n",
           1, "Calculating fisher basis", "src/csuSubspaceFisher.c", "fisherTrain",
           300, tmp___17);
#line 300
    fflush(stdout);
  }
#line 301
  *fisherBasis = multiplyMatrix((Matrix const   )Rw, (Matrix const   )Tmp);
#line 303
  if (writeTextInterm) {
#line 303
    saveMatrixAscii((char const   *)((void *)0), "*fisherBasis", (Matrix const   )*fisherBasis,
                    asciiFormat);
#line 303
    saveMatrixAscii((char const   *)((void *)0), "*fisherValues", (Matrix const   )*fisherValues,
                    asciiFormat);
#line 303
    saveMatrixAscii((char const   *)((void *)0), "Evecs", (Matrix const   )Evecs,
                    asciiFormat);
  }
#line 309
  (*fisherBasis)->col_dim = numberOfClasses - 1;
#line 310
  (*fisherValues)->row_dim = numberOfClasses - 1;
#line 312
  basis_normalize(*fisherBasis);
#line 314
  tmp___18 = time((time_t *)0);
#line 314
  tttt___5 = tmp___18;
#line 314
  if (quiet == 0) {
#line 314
    printf((char const   * __restrict  )"Completed LDA Training. Fisher basis projection matrix has dimensions %d by %d.",
           (*fisherBasis)->row_dim, (*fisherBasis)->col_dim);
  } else
#line 314
  if (debuglevel != 0) {
#line 314
    printf((char const   * __restrict  )"Completed LDA Training. Fisher basis projection matrix has dimensions %d by %d.",
           (*fisherBasis)->row_dim, (*fisherBasis)->col_dim);
  }
#line 314
  if (quiet == 0) {
#line 314
    printf((char const   * __restrict  )"\n");
  } else
#line 314
  if (debuglevel != 0) {
#line 314
    printf((char const   * __restrict  )"\n");
  }
#line 314
  if (debuglevel > 0) {
#line 314
    tmp___19 = ctime((time_t const   *)(& tttt___5));
#line 314
    printf((char const   * __restrict  )"    [%s]<%s():line %u> %s\n", "src/csuSubspaceFisher.c",
           "fisherTrain", 314, tmp___19);
  }
#line 314
  fflush(stdout);
#line 317
  freeMatrix(Tmp);
#line 318
  freeMatrix(Rw);
#line 319
  freeMatrix(Siw);
#line 320
  freeMatrix(Ev);
#line 321
  freeMatrix(Mw);
#line 322
  freeMatrix(Mb);
#line 323
  freeMatrix(G);
#line 324
  freeMatrix(N);
#line 325
  return;
}
}
#line 1 "csuSubspaceCVEigen.o"
#pragma merger("0","/tmp/cil-ApNfd7Kq.i","-O3,-Wall")
#line 150 "/usr/include/x86_64-linux-gnu/bits/mathinline.h"
__inline extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__, __always_inline__)) __signbitl)(long double __x )  __attribute__((__const__)) ;
#line 150 "/usr/include/x86_64-linux-gnu/bits/mathinline.h"
__inline extern int ( __attribute__((__leaf__, __always_inline__)) __signbitl)(long double __x ) 
{ 
  union __anonunion___u_3 __u ;

  {
#line 153
  __u.__l = __x;
#line 154
  return ((__u.__i[2] & 32768) != 0);
}
}
#line 95 "src/csuSubspaceCVEigen.c"
int cvJacobiEigens_32f(float *A , float *V , float *E , int n , float eps ) 
{ 
  int i ;
  int j ;
  int k ;
  int ind ;
  float *AA ;
  float *VV ;
  double Amax ;
  double anorm ;
  double ax ;
  double Am ;
  int p ;
  int q ;
  float *V1 ;
  float *A1 ;
  float *A2 ;
  float *V2 ;
  double x ;
  double y ;
  double c ;
  double s ;
  double c2 ;
  double s2 ;
  double a ;
  float *A3 ;
  float Apq ;
  float App ;
  float Aqq ;
  float Aip ;
  float Aiq ;
  float Vpi ;
  float Vqi ;
  double tmp ;
  double tmp___0 ;
  double tmp___1 ;
  double tmp___2 ;
  float tmp___3 ;
  int m ;
  float Em ;
  double tmp___4 ;
  float Ej ;
  double tmp___5 ;
  int l ;
  float b ;

  {
#line 101
  AA = A;
#line 101
  VV = V;
#line 102
  anorm = (double )0;
#line 106
  if (eps < 1.0e-7f) {
#line 107
    eps = 1.0e-7f;
  }
#line 110
  i = 0;
#line 110
  while (i < n) {
#line 111
    j = 0;
#line 111
    while (j < i) {
#line 112
      Am = (double )*(AA + j);
#line 113
      anorm += Am * Am;
#line 111
      j ++;
    }
#line 115
    j = 0;
#line 115
    while (j < n) {
#line 116
      *(VV + j) = 0.f;
#line 115
      j ++;
    }
#line 117
    *(VV + i) = 1.f;
#line 110
    i ++;
#line 110
    VV += n;
#line 110
    AA += n;
  }
#line 120
  anorm = sqrt(anorm + anorm);
#line 121
  ax = (anorm * (double )eps) / (double )n;
#line 122
  Amax = anorm;
#line 124
  while (Amax > ax) {
#line 125
    Amax /= (double )n;
#line 126
    while (1) {
#line 129
      V1 = V;
#line 129
      A1 = A;
#line 130
      ind = 0;
#line 131
      p = 0;
#line 131
      while (p < n - 1) {
#line 132
        A2 = A + n * (p + 1);
#line 132
        V2 = V + n * (p + 1);
#line 133
        q = p + 1;
#line 133
        while (q < n) {
#line 135
          Apq = *(A1 + q);
#line 136
          tmp = fabs((double )Apq);
#line 136
          if (tmp < Amax) {
#line 137
            goto __Cont;
          }
#line 139
          ind = 1;
#line 142
          App = *(A1 + p);
#line 143
          Aqq = *(A2 + q);
#line 144
          y = 5.0e-1 * (double )(App - Aqq);
#line 145
          tmp___0 = sqrt((double )(Apq * Apq) + y * y);
#line 145
          x = (double )(- Apq) / tmp___0;
#line 146
          if (y < 0.0) {
#line 147
            x = - x;
          }
#line 148
          tmp___1 = sqrt(1.0 - x * x);
#line 148
          tmp___2 = sqrt(2.0 * (1.0 + tmp___1));
#line 148
          s = x / tmp___2;
#line 149
          s2 = s * s;
#line 150
          c = sqrt(1.0 - s2);
#line 151
          c2 = c * c;
#line 152
          a = ((2.0 * (double )Apq) * c) * s;
#line 155
          A3 = A;
#line 156
          i = 0;
#line 156
          while (i < p) {
#line 157
            Aip = *(A3 + p);
#line 158
            Aiq = *(A3 + q);
#line 159
            Vpi = *(V1 + i);
#line 160
            Vqi = *(V2 + i);
#line 161
            *(A3 + p) = (float )((double )Aip * c - (double )Aiq * s);
#line 162
            *(A3 + q) = (float )((double )Aiq * c + (double )Aip * s);
#line 163
            *(V1 + i) = (float )((double )Vpi * c - (double )Vqi * s);
#line 164
            *(V2 + i) = (float )((double )Vqi * c + (double )Vpi * s);
#line 156
            i ++;
#line 156
            A3 += n;
          }
#line 166
          while (i < q) {
#line 167
            Aip = *(A1 + i);
#line 168
            Aiq = *(A3 + q);
#line 169
            Vpi = *(V1 + i);
#line 170
            Vqi = *(V2 + i);
#line 171
            *(A1 + i) = (float )((double )Aip * c - (double )Aiq * s);
#line 172
            *(A3 + q) = (float )((double )Aiq * c + (double )Aip * s);
#line 173
            *(V1 + i) = (float )((double )Vpi * c - (double )Vqi * s);
#line 174
            *(V2 + i) = (float )((double )Vqi * c + (double )Vpi * s);
#line 166
            i ++;
#line 166
            A3 += n;
          }
#line 176
          while (i < n) {
#line 177
            Aip = *(A1 + i);
#line 178
            Aiq = *(A2 + i);
#line 179
            Vpi = *(V1 + i);
#line 180
            Vqi = *(V2 + i);
#line 181
            *(A1 + i) = (float )((double )Aip * c - (double )Aiq * s);
#line 182
            *(A2 + i) = (float )((double )Aiq * c + (double )Aip * s);
#line 183
            *(V1 + i) = (float )((double )Vpi * c - (double )Vqi * s);
#line 184
            *(V2 + i) = (float )((double )Vqi * c + (double )Vpi * s);
#line 176
            i ++;
          }
#line 186
          *(A1 + p) = (float )(((double )App * c2 + (double )Aqq * s2) - a);
#line 187
          *(A2 + q) = (float )(((double )App * s2 + (double )Aqq * c2) + a);
#line 188
          tmp___3 = 0.0f;
#line 188
          *(A2 + p) = tmp___3;
#line 188
          *(A1 + q) = tmp___3;
          __Cont: /* CIL Label */ 
#line 133
          q ++;
#line 133
          A2 += n;
#line 133
          V2 += n;
        }
#line 131
        p ++;
#line 131
        A1 += n;
#line 131
        V1 += n;
      }
#line 126
      if (! ind) {
#line 126
        break;
      }
    }
#line 192
    Amax /= (double )n;
  }
#line 195
  i = 0;
#line 195
  k = 0;
#line 195
  while (i < n) {
#line 196
    *(E + i) = *(A + k);
#line 195
    i ++;
#line 195
    k += n + 1;
  }
#line 200
  i = 0;
#line 200
  while (i < n) {
#line 201
    m = i;
#line 202
    tmp___4 = fabs((double )*(E + i));
#line 202
    Em = (float )tmp___4;
#line 203
    j = i + 1;
#line 203
    while (j < n) {
#line 204
      tmp___5 = fabs((double )*(E + j));
#line 204
      Ej = (float )tmp___5;
#line 205
      if (Em < Ej) {
#line 205
        m = j;
      } else {
#line 205
        m = m;
      }
#line 206
      if (Em < Ej) {
#line 206
        Em = Ej;
      } else {
#line 206
        Em = Em;
      }
#line 203
      j ++;
    }
#line 208
    if (m != i) {
#line 210
      b = *(E + i);
#line 211
      *(E + i) = *(E + m);
#line 212
      *(E + m) = b;
#line 213
      j = 0;
#line 213
      k = i * n;
#line 213
      l = m * n;
#line 213
      while (j < n) {
#line 214
        b = *(V + k);
#line 215
        *(V + k) = *(V + l);
#line 216
        *(V + l) = b;
#line 213
        j ++;
#line 213
        k ++;
#line 213
        l ++;
      }
    }
#line 200
    i ++;
  }
#line 221
  return (0);
}
}
#line 226 "src/csuSubspaceCVEigen.c"
int cvJacobiEigens_64d(double *A , double *V , double *E , int n , double eps ) 
{ 
  int i ;
  int j ;
  int k ;
  int p ;
  int q ;
  int ind ;
  double *A1 ;
  double *V1 ;
  double *A2 ;
  double *V2 ;
  double Amax ;
  double anorm ;
  double ax ;
  double deps ;
  double Am ;
  double x ;
  double y ;
  double c ;
  double s ;
  double c2 ;
  double s2 ;
  double a ;
  double *A3 ;
  double Apq ;
  double App ;
  double Aqq ;
  double App2 ;
  double Aqq2 ;
  double Aip ;
  double Aiq ;
  double Vpi ;
  double Vqi ;
  double tmp ;
  double tmp___0 ;
  double tmp___1 ;
  double tmp___2 ;
  double tmp___3 ;
  int m ;
  double Em ;
  double tmp___4 ;
  double Ej ;
  double tmp___5 ;
  int l ;
  double b ;

  {
#line 232
  A1 = A;
#line 232
  V1 = V;
#line 232
  A2 = A;
#line 232
  V2 = V;
#line 233
  Amax = 0.0;
#line 233
  anorm = 0.0;
#line 237
  if (eps < 1.0e-15) {
#line 238
    eps = 1.0e-15;
  }
#line 239
  deps = eps / (double )n;
#line 242
  i = 0;
#line 242
  while (i < n) {
#line 243
    j = 0;
#line 243
    while (j < i) {
#line 244
      Am = *(A1 + j);
#line 245
      anorm += Am * Am;
#line 243
      j ++;
    }
#line 247
    j = 0;
#line 247
    while (j < n) {
#line 248
      *(V1 + j) = 0.0;
#line 247
      j ++;
    }
#line 249
    *(V1 + i) = 1.0;
#line 242
    i ++;
#line 242
    V1 += n;
#line 242
    A1 += n;
  }
#line 252
  anorm = sqrt(anorm + anorm);
#line 253
  ax = (anorm * eps) / (double )n;
#line 254
  Amax = anorm;
#line 256
  while (Amax > ax) {
#line 257
    Amax /= (double )n;
#line 258
    while (1) {
#line 260
      ind = 0;
#line 261
      A1 = A;
#line 262
      V1 = V;
#line 263
      p = 0;
#line 263
      while (p < n - 1) {
#line 264
        A2 = A + n * (p + 1);
#line 265
        V2 = V + n * (p + 1);
#line 266
        q = p + 1;
#line 266
        while (q < n) {
#line 269
          tmp = fabs(*(A1 + q));
#line 269
          if (tmp < Amax) {
#line 270
            goto __Cont;
          }
#line 271
          Apq = *(A1 + q);
#line 273
          ind = 1;
#line 276
          App = *(A1 + p);
#line 277
          Aqq = *(A2 + q);
#line 278
          y = 5.0e-1 * (App - Aqq);
#line 279
          tmp___0 = sqrt(Apq * Apq + y * y);
#line 279
          x = - Apq / tmp___0;
#line 280
          if (y < 0.0) {
#line 281
            x = - x;
          }
#line 282
          tmp___1 = sqrt(1.0 - x * x);
#line 282
          tmp___2 = sqrt(2.0 * (1.0 + tmp___1));
#line 282
          s = x / tmp___2;
#line 283
          s2 = s * s;
#line 284
          c = sqrt(1.0 - s2);
#line 285
          c2 = c * c;
#line 286
          a = ((2.0 * Apq) * c) * s;
#line 289
          A3 = A;
#line 290
          i = 0;
#line 290
          while (i < p) {
#line 291
            Aip = *(A3 + p);
#line 292
            Aiq = *(A3 + q);
#line 293
            Vpi = *(V1 + i);
#line 294
            Vqi = *(V2 + i);
#line 295
            *(A3 + p) = Aip * c - Aiq * s;
#line 296
            *(A3 + q) = Aiq * c + Aip * s;
#line 297
            *(V1 + i) = Vpi * c - Vqi * s;
#line 298
            *(V2 + i) = Vqi * c + Vpi * s;
#line 290
            i ++;
#line 290
            A3 += n;
          }
#line 300
          while (i < q) {
#line 301
            Aip = *(A1 + i);
#line 302
            Aiq = *(A3 + q);
#line 303
            Vpi = *(V1 + i);
#line 304
            Vqi = *(V2 + i);
#line 305
            *(A1 + i) = Aip * c - Aiq * s;
#line 306
            *(A3 + q) = Aiq * c + Aip * s;
#line 307
            *(V1 + i) = Vpi * c - Vqi * s;
#line 308
            *(V2 + i) = Vqi * c + Vpi * s;
#line 300
            i ++;
#line 300
            A3 += n;
          }
#line 310
          while (i < n) {
#line 311
            Aip = *(A1 + i);
#line 312
            Aiq = *(A2 + i);
#line 313
            Vpi = *(V1 + i);
#line 314
            Vqi = *(V2 + i);
#line 315
            *(A1 + i) = Aip * c - Aiq * s;
#line 316
            *(A2 + i) = Aiq * c + Aip * s;
#line 317
            *(V1 + i) = Vpi * c - Vqi * s;
#line 318
            *(V2 + i) = Vqi * c + Vpi * s;
#line 310
            i ++;
          }
#line 320
          App2 = (App * c2 + Aqq * s2) - a;
#line 321
          Aqq2 = (App * s2 + Aqq * c2) + a;
#line 322
          *(A1 + p) = App2;
#line 323
          *(A2 + q) = Aqq2;
#line 324
          tmp___3 = 0.0;
#line 324
          *(A2 + p) = tmp___3;
#line 324
          *(A1 + q) = tmp___3;
          __Cont: /* CIL Label */ 
#line 266
          q ++;
#line 266
          A2 += n;
#line 266
          V2 += n;
        }
#line 263
        p ++;
#line 263
        A1 += n;
#line 263
        V1 += n;
      }
#line 258
      if (! ind) {
#line 258
        break;
      }
    }
  }
#line 330
  i = 0;
#line 330
  k = 0;
#line 330
  while (i < n) {
#line 331
    *(E + i) = *(A + k);
#line 330
    i ++;
#line 330
    k += n + 1;
  }
#line 334
  i = 0;
#line 334
  while (i < n) {
#line 335
    m = i;
#line 336
    tmp___4 = fabs(*(E + i));
#line 336
    Em = tmp___4;
#line 337
    j = i + 1;
#line 337
    while (j < n) {
#line 338
      tmp___5 = fabs(*(E + j));
#line 338
      Ej = tmp___5;
#line 339
      if (Em < Ej) {
#line 339
        m = j;
      } else {
#line 339
        m = m;
      }
#line 340
      if (Em < Ej) {
#line 340
        Em = Ej;
      } else {
#line 340
        Em = Em;
      }
#line 337
      j ++;
    }
#line 342
    if (m != i) {
#line 344
      b = *(E + i);
#line 345
      *(E + i) = *(E + m);
#line 346
      *(E + m) = b;
#line 347
      j = 0;
#line 347
      k = i * n;
#line 347
      l = m * n;
#line 347
      while (j < n) {
#line 348
        b = *(V + k);
#line 349
        *(V + k) = *(V + l);
#line 350
        *(V + l) = b;
#line 347
        j ++;
#line 347
        k ++;
#line 347
        l ++;
      }
    }
#line 334
    i ++;
  }
#line 355
  return (0);
}
}
